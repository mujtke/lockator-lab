/* Generated by Frama-C */

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef int __s32;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef signed char s8;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned char u8;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned short u16;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef int s32;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned int u32;

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef long long s64;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned long long u64;

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;

#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;

#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u16 __be16;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __le32;

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __be32;

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __wsum;

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u32 __kernel_dev_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_dev_t dev_t;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned short umode_t;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_pid_t pid_t;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_clockid_t clockid_t;

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef _Bool bool;

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_uid32_t uid_t;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_gid32_t gid_t;

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_loff_t loff_t;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_size_t size_t;

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_time_t time_t;

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned char u_char;

#line 84  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned short u_short;

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int u_int;

#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned long u_long;

#line 92  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned long ulong;

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __s32 int32_t;

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u8 uint8_t;

#line 108  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u32 uint32_t;

#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u64 uint64_t;

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned long sector_t;

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned long blkcnt_t;

#line 152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef u64 dma_addr_t;

#line 157  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int gfp_t;

#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int fmode_t;

#line 159  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int oom_flags_t;

#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef u64 phys_addr_t;

#line 167  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef phys_addr_t resource_size_t;

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;

#line 183  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};

#line 188 
struct hlist_node;

#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};

#line 192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};

#line 203  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head *) ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct __anonstruct_9 {
   unsigned int a ;
   unsigned int b ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct __anonstruct_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) base1 : 8 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) type : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) s : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) dpl : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) p : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) limit : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) avl : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) l : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) g : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) base2 : 8 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
union __anonunion_8 {
   struct __anonstruct_9 __anonCompField___anonunion_8_4 ;
   struct __anonstruct_10 __anonCompField___anonunion_8_5 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion_8 __anonCompField_desc_struct_6 ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;

#line 361 
struct page;

#line 361  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;

#line 372 
struct file;

#line 385 
struct seq_file;

#line 423 
struct thread_struct;

#line 425 
struct mm_struct;

#line 426 
struct task_struct;

#line 427 
struct cpumask;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_debug.h"
struct device;

#line 54 
struct net_device;

#line 420  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
struct file_operations;

#line 432 
struct completion;

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct timespec;

#line 103 
struct compat_timespec;

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_futex_16 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_nanosleep_17 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};

#line 104 
struct pollfd;

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_poll_18 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
union __anonunion_15 {
   struct __anonstruct_futex_16 futex ;
   struct __anonstruct_nanosleep_17 nanosleep ;
   struct __anonstruct_poll_18 poll ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct restart_block {
   long (*fn)(struct restart_block *) ;
   union __anonunion_15 __anonCompField_restart_block_7 ;
};

#line 127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/vm86.h"
union __anonunion_19 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_19 __anonCompField_math_emu_info_8 ;
};

#line 328  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[128U] ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
typedef struct cpumask cpumask_t;

#line 652  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;

#line 260  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct __anonstruct_29 {
   u64 rip ;
   u64 rdp ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct __anonstruct_30 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union __anonunion_28 {
   struct __anonstruct_29 __anonCompField___anonunion_28_12 ;
   struct __anonstruct_30 __anonCompField___anonunion_28_13 ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union __anonunion_31 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_28 __anonCompField_fxregs_state_14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_31 __anonCompField_fxregs_state_15 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};

#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};

#line 179  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
   u8 __padding[4096U] ;
};

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
   union fpregs_state state ;
};

#line 170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
struct seq_operations;

#line 369 
struct perf_event;

#line 370  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   struct fpu fpu ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bottom_half.h"
struct lockdep_map;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};

#line 28  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};

#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const *name ;
   int cpu ;
   unsigned long ip ;
};

#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(13))) class_idx : 13 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) irq_context : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) trylock : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) read : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) check : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hardirqs_off : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))) references : 12 ;
   unsigned int pin_count ;
};

#line 546  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
struct __anonstruct_35 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
union __anonunion_34 {
   struct raw_spinlock rlock ;
   struct __anonstruct_35 __anonCompField___anonunion_34_17 ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_34 __anonCompField_spinlock_18 ;
};

#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_36 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_36 rwlock_t;

#line 41  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
struct mutex;

#line 30  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
struct fddi_addr {
   u_char a[6U] ;
};

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fddi.h"
struct sk_buff;

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fddi.h"
struct s_txd_os {
   struct sk_buff *skb ;
   dma_addr_t dma_addr ;
};

#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/osdef1st.h"
struct s_rxd_os {
   struct sk_buff *skb ;
   dma_addr_t dma_addr ;
};

#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/osdef1st.h"
struct smt_sid {
   u_char sid_oem[2U] ;
   struct fddi_addr sid_node ;
};

#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_header {
   struct fddi_addr smt_dest ;
   struct fddi_addr smt_source ;
   u_char smt_class ;
   u_char smt_type ;
   u_short smt_version ;
   u_int smt_tid ;
   struct smt_sid smt_sid ;
   u_short smt_pad ;
   u_short smt_len ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_para {
   u_short p_type ;
   u_short p_len ;
};

#line 400  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_reason {
   struct smt_para para ;
   u_int rdf_reason ;
};

#line 449  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_0015 {
   struct smt_para para ;
   u_int res_type ;
};

#line 459  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_0016 {
   struct smt_para para ;
   u_int sba_cmd ;
};

#line 471  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_0017 {
   struct smt_para para ;
   int sba_pl_req ;
};

#line 487  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_0018 {
   struct smt_para para ;
   int sba_ov_req ;
};

#line 497  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_0019 {
   struct smt_para para ;
   u_short sba_pad ;
   struct fddi_addr alloc_addr ;
};

#line 508  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_001a {
   struct smt_para para ;
   u_int category ;
};

#line 518  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_001b {
   struct smt_para para ;
   u_int max_t_neg ;
};

#line 528  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_001c {
   struct smt_para para ;
   u_int min_seg_siz ;
};

#line 634  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_320b {
   struct smt_para para ;
   u_int mib_index ;
   u_short path_pad ;
   u_short path_index ;
};

#line 656  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_320f {
   struct smt_para para ;
   u_int mib_index ;
   u_int mib_payload ;
};

#line 664  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_3210 {
   struct smt_para para ;
   u_int mib_index ;
   u_int mib_overhead ;
};

#line 810  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_sba_alc_req {
   struct smt_header smt ;
   struct smt_p_0015 s_type ;
   struct smt_p_0016 cmd ;
   struct smt_p_320b path ;
   struct smt_p_0017 pl_req ;
   struct smt_p_0018 ov_req ;
   struct smt_p_320f payload ;
   struct smt_p_3210 overhead ;
   struct smt_p_0019 a_addr ;
   struct smt_p_001a cat ;
   struct smt_p_001b tneg ;
   struct smt_p_001c segm ;
};

#line 828  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_sba_chg {
   struct smt_header smt ;
   struct smt_p_0015 s_type ;
   struct smt_p_0016 cmd ;
   struct smt_p_320b path ;
   struct smt_p_320f payload ;
   struct smt_p_3210 overhead ;
   struct smt_p_001a cat ;
};

#line 862 
struct s_smc;

#line 862  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_timer {
   struct smt_timer *tm_next ;
   struct s_smc *tm_smc ;
   u_long tm_delta ;
   u_long tm_token ;
   u_short tm_active ;
   u_short tm_pad ;
};

#line 394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/cmtdef.h"
struct mac_parameter {
   u_long t_neg ;
   u_long t_pri ;
};

#line 402  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/cmtdef.h"
struct mac_counter {
   u_long mac_nobuf_counter ;
   u_long mac_r_restart_counter ;
};

#line 420  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/cmtdef.h"
struct lem_counter {
   u_short lem_float_ber ;
   u_long lem_errors ;
   u_short lem_on ;
};

#line 442  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/cmtdef.h"
struct s_plc {
   u_short p_state ;
   u_short p_bits ;
   u_short p_start ;
   u_short p_pad ;
   u_long soft_err ;
   u_long parity_err ;
   u_long ebuf_err ;
   u_long ebuf_cont ;
   u_long phyinv ;
   u_long vsym_ctr ;
   u_long mini_ctr ;
   u_long tpc_exp ;
   u_long np_err ;
   u_long b_pcs ;
   u_long b_tpc ;
   u_long b_tne ;
   u_long b_qls ;
   u_long b_ils ;
   u_long b_hls ;
};

#line 472  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/cmtdef.h"
struct s_mbuf {
   struct s_mbuf *m_next ;
   short m_off ;
   u_int m_len ;
   int sm_use_count ;
   char m_data[4504U] ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/mbuf.h"
typedef struct s_mbuf Mbuf;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fddimib.h"
typedef u_long Counter;

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fddimib.h"
typedef u_char TimeStamp[8U];

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fddimib.h"
typedef struct fddi_addr LongAddr;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fddimib.h"
typedef u_long Timer_2;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fddimib.h"
typedef u_long Timer;

#line 28  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fddimib.h"
typedef u_short ResId;

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fddimib.h"
typedef u_short SMTEnum;

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fddimib.h"
typedef u_char SMTFlag;

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fddimib.h"
struct __anonstruct_SetCountType_37 {
   Counter count ;
   TimeStamp timestamp ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fddimib.h"
typedef struct __anonstruct_SetCountType_37 SetCountType;

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fddimib.h"
struct fddi_mib_m {
   u_short fddiMACFrameStatusFunctions ;
   Timer_2 fddiMACT_MaxCapabilitiy ;
   Timer_2 fddiMACTVXCapabilitiy ;
   u_char fddiMACMultiple_N ;
   u_char fddiMACMultiple_P ;
   u_char fddiMACDuplicateAddressCond ;
   u_char fddiMACAvailablePaths ;
   u_short fddiMACCurrentPath ;
   LongAddr fddiMACUpstreamNbr ;
   LongAddr fddiMACDownstreamNbr ;
   LongAddr fddiMACOldUpstreamNbr ;
   LongAddr fddiMACOldDownstreamNbr ;
   SMTEnum fddiMACDupAddressTest ;
   u_short fddiMACRequestedPaths ;
   SMTEnum fddiMACDownstreamPORTType ;
   ResId fddiMACIndex ;
   LongAddr fddiMACSMTAddress ;
   Timer_2 fddiMACT_Min ;
   Timer_2 fddiMACT_ReqMIB ;
   Timer_2 fddiMACT_Req ;
   Timer_2 fddiMACT_Neg ;
   Timer_2 fddiMACT_MaxMIB ;
   Timer_2 fddiMACT_Max ;
   Timer_2 fddiMACTvxValueMIB ;
   Timer_2 fddiMACTvxValue ;
   Timer_2 fddiMACT_Pri0 ;
   Timer_2 fddiMACT_Pri1 ;
   Timer_2 fddiMACT_Pri2 ;
   Timer_2 fddiMACT_Pri3 ;
   Timer_2 fddiMACT_Pri4 ;
   Timer_2 fddiMACT_Pri5 ;
   Timer_2 fddiMACT_Pri6 ;
   Counter fddiMACFrame_Ct ;
   Counter fddiMACCopied_Ct ;
   Counter fddiMACTransmit_Ct ;
   Counter fddiMACToken_Ct ;
   Counter fddiMACError_Ct ;
   Counter fddiMACLost_Ct ;
   Counter fddiMACTvxExpired_Ct ;
   Counter fddiMACNotCopied_Ct ;
   Counter fddiMACRingOp_Ct ;
   Counter fddiMACSMTCopied_Ct ;
   Counter fddiMACSMTTransmit_Ct ;
   Counter fddiMACOld_Frame_Ct ;
   Counter fddiMACOld_Copied_Ct ;
   Counter fddiMACOld_Error_Ct ;
   Counter fddiMACOld_Lost_Ct ;
   Counter fddiMACOld_NotCopied_Ct ;
   u_short fddiMACFrameErrorThreshold ;
   u_short fddiMACFrameErrorRatio ;
   u_short fddiMACNotCopiedThreshold ;
   u_short fddiMACNotCopiedRatio ;
   SMTEnum fddiMACRMTState ;
   SMTFlag fddiMACDA_Flag ;
   SMTFlag fddiMACUNDA_Flag ;
   SMTFlag fddiMACFrameErrorFlag ;
   SMTFlag fddiMACNotCopiedFlag ;
   SMTFlag fddiMACMA_UnitdataAvailable ;
   SMTFlag fddiMACHardwarePresent ;
   SMTFlag fddiMACMA_UnitdataEnable ;
};

#line 237  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fddimib.h"
struct fddi_mib_a {
   ResId fddiPATHIndex ;
   u_long fddiPATHSbaPayload ;
   u_long fddiPATHSbaOverhead ;
   Timer fddiPATHT_Rmode ;
   u_long fddiPATHSbaAvailable ;
   Timer_2 fddiPATHTVXLowerBound ;
   Timer_2 fddiPATHT_MaxLowerBound ;
   Timer_2 fddiPATHMaxT_Req ;
};

#line 252  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fddimib.h"
struct __anonstruct_fddiPORTMacIndicated_38 {
   u_char T_val ;
   u_char R_val ;
};

#line 252  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fddimib.h"
struct fddi_mib_p {
   SMTEnum fddiPORTMy_Type ;
   SMTEnum fddiPORTNeighborType ;
   u_char fddiPORTConnectionPolicies ;
   struct __anonstruct_fddiPORTMacIndicated_38 fddiPORTMacIndicated ;
   SMTEnum fddiPORTCurrentPath ;
   u_char fddiPORTRequestedPaths[4U] ;
   u_short fddiPORTMACPlacement ;
   u_char fddiPORTAvailablePaths ;
   u_char fddiPORTConnectionCapabilities ;
   SMTEnum fddiPORTPMDClass ;
   ResId fddiPORTIndex ;
   SMTEnum fddiPORTMaint_LS ;
   SMTEnum fddiPORTPC_LS ;
   u_char fddiPORTBS_Flag ;
   Counter fddiPORTLCTFail_Ct ;
   Counter fddiPORTEBError_Ct ;
   Counter fddiPORTOldEBError_Ct ;
   Counter fddiPORTLem_Reject_Ct ;
   Counter fddiPORTLem_Ct ;
   u_char fddiPORTLer_Estimate ;
   u_char fddiPORTLer_Cutoff ;
   u_char fddiPORTLer_Alarm ;
   SMTEnum fddiPORTConnectState ;
   SMTEnum fddiPORTPCMState ;
   SMTEnum fddiPORTPCMStateX ;
   SMTEnum fddiPORTPC_Withhold ;
   SMTFlag fddiPORTHardwarePresent ;
   u_char fddiPORTLerFlag ;
   u_char fddiPORTMultiple_U ;
   u_char fddiPORTMultiple_P ;
   u_char fddiPORTEB_Condition ;
};

#line 306  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fddimib.h"
struct __anonstruct_priv_39 {
   Counter fddiPRIVECF_Req_Rx ;
   Counter fddiPRIVECF_Reply_Rx ;
   Counter fddiPRIVECF_Req_Tx ;
   Counter fddiPRIVECF_Reply_Tx ;
   Counter fddiPRIVPMF_Get_Rx ;
   Counter fddiPRIVPMF_Set_Rx ;
   Counter fddiPRIVRDF_Rx ;
   Counter fddiPRIVRDF_Tx ;
};

#line 306  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fddimib.h"
struct fddi_mib {
   u_char fddiPRPMFPasswd[8U] ;
   struct smt_sid fddiPRPMFStation ;
   u_long fddiESSPayload ;
   u_long fddiESSOverhead ;
   u_long fddiESSMaxTNeg ;
   u_long fddiESSMinSegmentSize ;
   u_long fddiESSCategory ;
   short fddiESSSynchTxMode ;
   struct smt_sid fddiSMTStationId ;
   u_short fddiSMTOpVersionId ;
   u_short fddiSMTHiVersionId ;
   u_short fddiSMTLoVersionId ;
   u_char fddiSMTManufacturerData[32U] ;
   u_char fddiSMTUserData[32U] ;
   u_short fddiSMTMIBVersionId ;
   u_char fddiSMTMac_Ct ;
   u_char fddiSMTNonMaster_Ct ;
   u_char fddiSMTMaster_Ct ;
   u_char fddiSMTAvailablePaths ;
   u_short fddiSMTConfigCapabilities ;
   u_short fddiSMTConfigPolicy ;
   u_short fddiSMTConnectionPolicy ;
   u_short fddiSMTTT_Notify ;
   u_char fddiSMTStatRptPolicy ;
   u_long fddiSMTTrace_MaxExpiration ;
   u_short fddiSMTPORTIndexes[2U] ;
   u_short fddiSMTMACIndexes ;
   u_char fddiSMTBypassPresent ;
   SMTEnum fddiSMTECMState ;
   SMTEnum fddiSMTCF_State ;
   SMTEnum fddiSMTStationStatus ;
   u_char fddiSMTRemoteDisconnectFlag ;
   u_char fddiSMTPeerWrapFlag ;
   TimeStamp fddiSMTTimeStamp ;
   TimeStamp fddiSMTTransitionTimeStamp ;
   SetCountType fddiSMTSetCount ;
   struct smt_sid fddiSMTLastSetStationId ;
   struct fddi_mib_m m[1U] ;
   struct fddi_mib_a a[2U] ;
   struct fddi_mib_p p[2U] ;
   struct __anonstruct_priv_39 priv ;
};

#line 317  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fddimib.h"
struct err_st {
   u_long err_valid ;
   u_long err_abort ;
   u_long err_e_indicator ;
   u_long err_crc ;
   u_long err_llc_frame ;
   u_long err_mac_frame ;
   u_long err_smt_frame ;
   u_long err_imp_frame ;
   u_long err_no_buf ;
   u_long err_too_long ;
   u_long err_bec_stat ;
   u_long err_clm_stat ;
   u_long err_sifg_det ;
   u_long err_phinv ;
   u_long err_tkiss ;
   u_long err_tkerr ;
};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fplustm.h"
struct s_smt_fp_txd {
   __le32 txd_tbctrl ;
   __le32 txd_txdscr ;
   __le32 txd_tbadr ;
   __le32 txd_ntdadr ;
   char *txd_virt ;
   struct s_smt_fp_txd volatile *txd_next ;
   struct s_txd_os txd_os ;
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fplustm.h"
struct s_smt_fp_rxd {
   __le32 rxd_rbctrl ;
   __le32 rxd_rfsw ;
   __le32 rxd_rbadr ;
   __le32 rxd_nrdadr ;
   char *rxd_virt ;
   struct s_smt_fp_rxd volatile *rxd_next ;
   struct s_rxd_os rxd_os ;
};

#line 82  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fplustm.h"
union s_fp_descr {
   struct s_smt_fp_txd t ;
   struct s_smt_fp_rxd r ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fplustm.h"
struct s_smt_tx_queue {
   struct s_smt_fp_txd volatile *tx_curr_put ;
   struct s_smt_fp_txd volatile *tx_prev_put ;
   struct s_smt_fp_txd volatile *tx_curr_get ;
   u_short tx_free ;
   u_short tx_used ;
   void *tx_bmu_ctl ;
   void *tx_bmu_dsc ;
};

#line 103  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fplustm.h"
struct s_smt_rx_queue {
   struct s_smt_fp_rxd volatile *rx_curr_put ;
   struct s_smt_fp_rxd volatile *rx_prev_put ;
   struct s_smt_fp_rxd volatile *rx_curr_get ;
   u_short rx_free ;
   u_short rx_used ;
   void *rx_bmu_ctl ;
   void *rx_bmu_dsc ;
};

#line 116  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fplustm.h"
struct s_smt_fifo_conf {
   u_short rbc_ram_start ;
   u_short rbc_ram_end ;
   u_short rx1_fifo_start ;
   u_short rx1_fifo_size ;
   u_short rx2_fifo_start ;
   u_short rx2_fifo_size ;
   u_short tx_s_start ;
   u_short tx_s_size ;
   u_short tx_a0_start ;
   u_short tx_a0_size ;
   u_short fifo_config_mode ;
};

#line 152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fplustm.h"
struct fddi_mac_sf {
   u_char mac_fc ;
   struct fddi_addr mac_dest ;
   struct fddi_addr mac_source ;
   u_char mac_info[32U] ;
};

#line 175  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fplustm.h"
struct s_fpmc {
   struct fddi_addr a ;
   u_char n ;
   u_char perm ;
};

#line 227  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fplustm.h"
struct __anonstruct_mc_40 {
   struct s_fpmc table[32U] ;
};

#line 227  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fplustm.h"
struct s_smt_fp {
   u_short mdr2init ;
   u_short mdr3init ;
   u_short frselreg_init ;
   u_short rx_mode ;
   u_short nsa_mode ;
   u_short rx_prom ;
   u_short exgpa ;
   struct err_st err_stats ;
   struct fddi_mac_sf mac_sfb ;
   struct s_smt_tx_queue *tx[2U] ;
   struct s_smt_rx_queue *rx[2U] ;
   struct s_smt_tx_queue tx_q[2U] ;
   struct s_smt_rx_queue rx_q[2U] ;
   struct s_smt_fifo_conf fifo ;
   u_short s2u ;
   u_short s2l ;
   void *fm_st1u ;
   void *fm_st1l ;
   void *fm_st2u ;
   void *fm_st2l ;
   void *fm_st3u ;
   void *fm_st3l ;
   struct __anonstruct_mc_40 mc ;
   struct fddi_addr group_addr ;
   u_long func_addr ;
   int smt_slots_used ;
   int os_slots_used ;
};

#line 233  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fplustm.h"
struct s_smt_hw {
   void *iop ;
   short dma ;
   short irq ;
   short eprom ;
   short slot ;
   short max_slots ;
   short wdog_used ;
   u_short pci_handle ;
   u_long is_imask ;
   u_long phys_mem_addr ;
   u_short mc_dummy ;
   u_short hw_state ;
   int hw_is_64bit ;
   u_long pci_fix_value ;
   u_long t_start ;
   u_long t_stop ;
   u_short timer_activ ;
   u_char pic_a1 ;
   u_char pic_21 ;
   struct fddi_addr fddi_home_addr ;
   struct fddi_addr fddi_canon_addr ;
   struct fddi_addr fddi_phys_addr ;
   struct mac_parameter mac_pa ;
   struct mac_counter mac_ct ;
   u_short mac_ring_is_up ;
   struct s_smt_fp fp ;
};

#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/iomap.h"
struct pci_dev;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/xen/features.h"
struct bio_vec;

#line 355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
typedef struct seqcount seqcount_t;

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
struct __anonstruct_seqlock_t_71 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_71 seqlock_t;

#line 598  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};

#line 437  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ktime.h"
typedef union ktime ktime_t;

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debugobjects.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};

#line 238  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
struct hrtimer;

#line 239 
enum hrtimer_restart;

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;

#line 1170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};

#line 296  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
struct notifier_block;

#line 1120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};

#line 837  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/sysctl.h"
struct ctl_table;

#line 838 
struct nsproxy;

#line 839 
struct ctl_table_root;

#line 840 
struct ctl_table_header;

#line 841 
struct ctl_dir;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table *, int , void *, size_t *, loff_t *);

#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table {
   char const *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};

#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct __anonstruct_73 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
union __anonunion_72 {
   struct __anonstruct_73 __anonCompField___anonunion_72_29 ;
   struct callback_head rcu ;
};

#line 122 
struct ctl_table_set;

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion_72 __anonCompField_ctl_table_header_30 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};

#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};

#line 149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set *) ;
   struct ctl_dir dir ;
};

#line 154  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root *, struct nsproxy *) ;
   int (*permissions)(struct ctl_table_header *, struct ctl_table *) ;
};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/prefetch.h"
struct vm_area_struct;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmdebug.h"
struct llist_node;

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};

#line 152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mpspec.h"
struct workqueue_struct;

#line 153 
struct work_struct;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct *) ;
   struct lockdep_map lockdep_map ;
};

#line 107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct pm_message {
   int event ;
};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
typedef struct pm_message pm_message_t;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device *) ;
   void (*complete)(struct device *) ;
   int (*suspend)(struct device *) ;
   int (*resume)(struct device *) ;
   int (*freeze)(struct device *) ;
   int (*thaw)(struct device *) ;
   int (*poweroff)(struct device *) ;
   int (*restore)(struct device *) ;
   int (*suspend_late)(struct device *) ;
   int (*resume_early)(struct device *) ;
   int (*freeze_late)(struct device *) ;
   int (*thaw_early)(struct device *) ;
   int (*poweroff_late)(struct device *) ;
   int (*restore_early)(struct device *) ;
   int (*suspend_noirq)(struct device *) ;
   int (*resume_noirq)(struct device *) ;
   int (*freeze_noirq)(struct device *) ;
   int (*thaw_noirq)(struct device *) ;
   int (*poweroff_noirq)(struct device *) ;
   int (*restore_noirq)(struct device *) ;
   int (*runtime_suspend)(struct device *) ;
   int (*runtime_resume)(struct device *) ;
   int (*runtime_idle)(struct device *) ;
};

#line 320 
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
};

#line 327 
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
};

#line 335 
struct wakeup_source;

#line 336 
struct wake_irq;

#line 338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};

#line 553 
struct dev_pm_qos;

#line 553  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) can_wakeup : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) async_suspend : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_prepared : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_noirq_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_late_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_children : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) early_init : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) direct_complete : 1 ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wakeup_path : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) syscore : 1 ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) disable_depth : 3 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) idle_notification : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) request_pending : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) deferred_resume : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) run_wake : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) runtime_auto : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_callbacks : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) irq_safe : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) use_autosuspend : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) timer_autosuspends : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device *, s32 ) ;
   struct dev_pm_qos *qos ;
};

#line 615  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device *, bool ) ;
   int (*activate)(struct device *) ;
   void (*sync)(struct device *) ;
   void (*dismiss)(struct device *) ;
};

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nodemask.h"
struct __anonstruct_nodemask_t_138 {
   unsigned long bits[16U] ;
};

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_138 nodemask_t;

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/topology.h"
struct pci_bus;

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
struct ldt_struct;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_139 {
   struct ldt_struct *ldt ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_139 mm_context_t;

#line 461  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist.h"
union __anonunion_148 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};

#line 461  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion_148 __anonCompField_idr_layer_31 ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};

#line 153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};

#line 185 
struct dentry;

#line 186 
struct iattr;

#line 187 
struct super_block;

#line 188 
struct file_system_type;

#line 189 
struct kernfs_open_node;

#line 190 
struct kernfs_iattrs;

#line 213 
struct kernfs_root;

#line 213  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_node;

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};

#line 89 
struct kernfs_ops;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops const *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
union __anonunion_153 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const *name ;
   struct rb_node rb ;
   void const *ns ;
   unsigned int hash ;
   union __anonunion_153 __anonCompField_kernfs_node_32 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};

#line 138  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root *, int *, char *) ;
   int (*show_options)(struct seq_file *, struct kernfs_root *) ;
   int (*mkdir)(struct kernfs_node *, char const *, umode_t ) ;
   int (*rmdir)(struct kernfs_node *) ;
   int (*rename)(struct kernfs_node *, struct kernfs_node *, char const *) ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};

#line 171 
struct vm_operations_struct;

#line 171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct const *vm_ops ;
};

#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file *, void *) ;
   void *(*seq_start)(struct seq_file *, loff_t *) ;
   void *(*seq_next)(struct seq_file *, void *, loff_t *) ;
   void (*seq_stop)(struct seq_file *, void *) ;
   ssize_t (*read)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   int (*mmap)(struct kernfs_open_file *, struct vm_area_struct *) ;
   struct lock_class_key lockdep_key ;
};

#line 281 
struct inode;

#line 477 
struct sock;

#line 478 
struct kobject;

#line 479 
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
};

#line 485  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const *(*netlink_ns)(struct sock *) ;
   void const *(*initial_ns)(void) ;
   void (*drop_ns)(void *) ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/highuid.h"
struct user_namespace;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct __anonstruct_kuid_t_154 {
   uid_t val ;
};

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_154 kuid_t;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct __anonstruct_kgid_t_155 {
   gid_t val ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_155 kgid_t;

#line 139  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/stat.h"
struct bin_attribute;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/stat.h"
struct attribute {
   char const *name ;
   umode_t mode ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_lockdep : 1 ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct attribute_group {
   char const *name ;
   umode_t (*is_visible)(struct kobject *, struct attribute *, int ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};

#line 82  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t , size_t ) ;
   ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t , size_t ) ;
   int (*mmap)(struct file *, struct kobject *, struct bin_attribute *, struct vm_area_struct *) ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject *, struct attribute *, char *) ;
   ssize_t (*store)(struct kobject *, struct attribute *, char const *, size_t ) ;
};

#line 509  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset;

#line 52 
struct kobj_type;

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobject {
   char const *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_initialized : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_in_sysfs : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_add_uevent_sent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_remove_uevent_sent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) uevent_suppress : 1 ;
};

#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject *) ;
   struct sysfs_ops const *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations const *(*child_ns_type)(struct kobject *) ;
   void const *(*namespace)(struct kobject *) ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const filter)(struct kset *, struct kobject *) ;
   char const *(* const name)(struct kset *, struct kobject *) ;
   int (* const uevent)(struct kset *, struct kobject *, struct kobj_uevent_env *) ;
};

#line 148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops const *uevent_ops ;
};

#line 223 
struct klist_node;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};

#line 67 
struct path;

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations const *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file *, loff_t *) ;
   void (*stop)(struct seq_file *, void *) ;
   void *(*next)(struct seq_file *, void *, loff_t *) ;
   int (*show)(struct seq_file *, void *) ;
};

#line 222 
struct pinctrl;

#line 223 
struct pinctrl_state;

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};

#line 796  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
struct rw_semaphore;

#line 797  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block *, unsigned long , void *) ;
   struct notifier_block *next ;
   int priority ;
};

#line 428  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/gfp.h"
struct dma_map_ops;

#line 428  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/gfp.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/device.h"
struct device_driver;

#line 16 
struct driver_private;

#line 17 
struct class;

#line 18 
struct subsys_private;

#line 19 
struct bus_type;

#line 20 
struct device_node;

#line 21 
struct fwnode_handle;

#line 22 
struct iommu_ops;

#line 23 
struct iommu_group;

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_attribute;

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct bus_type {
   char const *name ;
   char const *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group const **bus_groups ;
   struct attribute_group const **dev_groups ;
   struct attribute_group const **drv_groups ;
   int (*match)(struct device *, struct device_driver *) ;
   int (*uevent)(struct device *, struct kobj_uevent_env *) ;
   int (*probe)(struct device *) ;
   int (*remove)(struct device *) ;
   void (*shutdown)(struct device *) ;
   int (*online)(struct device *) ;
   int (*offline)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct dev_pm_ops const *pm ;
   struct iommu_ops const *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};

#line 139 
struct device_type;

#line 197 
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
};

#line 203 
struct of_device_id;

#line 203 
struct acpi_device_id;

#line 203  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_driver {
   char const *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id const *of_match_table ;
   struct acpi_device_id const *acpi_match_table ;
   int (*probe)(struct device *) ;
   int (*remove)(struct device *) ;
   void (*shutdown)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct attribute_group const **groups ;
   struct dev_pm_ops const *pm ;
   struct driver_private *p ;
};

#line 353 
struct class_attribute;

#line 353  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct class {
   char const *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group const **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *, struct kobj_uevent_env *) ;
   char *(*devnode)(struct device *, umode_t *) ;
   void (*class_release)(struct class *) ;
   void (*dev_release)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct kobj_ns_type_operations const *ns_type ;
   void const *(*namespace)(struct device *) ;
   struct dev_pm_ops const *pm ;
   struct subsys_private *p ;
};

#line 446  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *, struct class_attribute *, char *) ;
   ssize_t (*store)(struct class *, struct class_attribute *, char const *, size_t ) ;
};

#line 514  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_type {
   char const *name ;
   struct attribute_group const **groups ;
   int (*uevent)(struct device *, struct kobj_uevent_env *) ;
   char *(*devnode)(struct device *, umode_t *, kuid_t *, kgid_t *) ;
   void (*release)(struct device *) ;
   struct dev_pm_ops const *pm ;
};

#line 542  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *, struct device_attribute *, char *) ;
   ssize_t (*store)(struct device *, struct device_attribute *, char const *, size_t ) ;
};

#line 675  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};

#line 684 
struct dma_coherent_mem;

#line 684 
struct cma;

#line 684  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const *init_name ;
   struct device_type const *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group const **groups ;
   void (*release)(struct device *) ;
   struct iommu_group *iommu_group ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) offline_disabled : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) offline : 1 ;
};

#line 830  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct wakeup_source {
   char const *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) active : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) autosleep_enabled : 1 ;
};

#line 1272  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uio.h"
union __anonunion_156 {
   struct iovec const *iov ;
   struct kvec const *kvec ;
   struct bio_vec const *bvec ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion_156 __anonCompField_iov_iter_33 ;
   unsigned long nr_segs ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};

#line 66 
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct __anonstruct_162 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct __anonstruct_163 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
union __anonunion_161 {
   struct __anonstruct_162 __anonCompField___anonunion_161_36 ;
   struct __anonstruct_163 __anonCompField___anonunion_161_37 ;
};

#line 73 
struct uprobe;

#line 73 
struct return_instance;

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion_161 __anonCompField_uprobe_task_38 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};

#line 94  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uprobes.h"
struct xol_area;

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};

#line 133 
struct address_space;

#line 134 
struct mem_cgroup;

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
typedef void compound_page_dtor(struct page *);

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_164 {
   struct address_space *mapping ;
   void *s_mem ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_166 {
   unsigned long index ;
   void *freelist ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_170 {
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) inuse : 16 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(15))) objects : 15 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) frozen : 1 ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_169 {
   atomic_t _mapcount ;
   struct __anonstruct_170 __anonCompField___anonunion_169_41 ;
   int units ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_168 {
   union __anonunion_169 __anonCompField___anonstruct_168_42 ;
   atomic_t _count ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_167 {
   unsigned long counters ;
   struct __anonstruct_168 __anonCompField___anonunion_167_43 ;
   unsigned int active ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_165 {
   union __anonunion_166 __anonCompField___anonstruct_165_40 ;
   union __anonunion_167 __anonCompField___anonstruct_165_44 ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_172 {
   struct page *next ;
   int pages ;
   int pobjects ;
};

#line 32 
struct slab;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_173 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_171 {
   struct list_head lru ;
   struct __anonstruct_172 __anonCompField___anonunion_171_46 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct_173 __anonCompField___anonunion_171_47 ;
   pgtable_t pmd_huge_pte ;
};

#line 32 
struct kmem_cache;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_174 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion_164 __anonCompField_page_39 ;
   struct __anonstruct_165 __anonCompField_page_45 ;
   union __anonunion_171 __anonCompField_page_48 ;
   union __anonunion_174 __anonCompField_page_49 ;
   struct mem_cgroup *mem_cgroup ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_shared_175 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};

#line 257 
struct anon_vma;

#line 257 
struct mempolicy;

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_175 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct const *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};

#line 331  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};

#line 344  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};

#line 352  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};

#line 357 
struct kioctx_table;

#line 358 
struct linux_binfmt;

#line 358 
struct mmu_notifier_mm;

#line 358  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker *, struct shrink_control *) ;
   unsigned long (*scan_objects)(struct shrinker *, struct shrink_control *) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/page_ext.h"
struct file_ra_state;

#line 65 
struct user_struct;

#line 66 
struct writeback_control;

#line 67 
struct bdi_writeback;

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};

#line 239  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *) ;
   void (*close)(struct vm_area_struct *) ;
   int (*fault)(struct vm_area_struct *, struct vm_fault *) ;
   void (*map_pages)(struct vm_area_struct *, struct vm_fault *) ;
   int (*page_mkwrite)(struct vm_area_struct *, struct vm_fault *) ;
   int (*pfn_mkwrite)(struct vm_area_struct *, struct vm_fault *) ;
   int (*access)(struct vm_area_struct *, unsigned long , void *, int , int ) ;
   char const *(*name)(struct vm_area_struct *) ;
   int (*set_policy)(struct vm_area_struct *, struct mempolicy *) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct *, unsigned long ) ;
   struct page *(*find_special_page)(struct vm_area_struct *, unsigned long ) ;
};

#line 2291  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};

#line 1182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dmaengine.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sem.h"
struct sem_undo_list;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;

#line 18 
struct pid;

#line 19 
struct cred;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};

#line 38 
struct kiocb;

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_178 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_178 sync_serial_settings;

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_179 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_179 te1_settings;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_180 {
   unsigned short encoding ;
   unsigned short parity ;
};

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_180 raw_hdlc_proto;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_181 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_181 fr_proto;

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_182 {
   unsigned int dlci ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_182 fr_proto_pvc;

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_183 {
   unsigned int dlci ;
   char master[16U] ;
};

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_183 fr_proto_pvc_info;

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_184 {
   unsigned int interval ;
   unsigned int timeout ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_184 cisco_proto;

#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_185 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_185 ifs_ifsu ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_186 {
   char ifrn_name[16U] ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifr_ifru_187 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_186 ifr_ifrn ;
   union __anonunion_ifr_ifru_187 ifr_ifru ;
};

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kdev_t.h"
struct hlist_bl_node;

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kdev_t.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
struct __anonstruct_192 {
   spinlock_t lock ;
   int count ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
union __anonunion_191 {
   struct __anonstruct_192 __anonCompField___anonunion_191_50 ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
struct lockref {
   union __anonunion_191 __anonCompField_lockref_51 ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct vfsmount;

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct __anonstruct_194 {
   u32 hash ;
   u32 len ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
union __anonunion_193 {
   struct __anonstruct_194 __anonCompField___anonunion_193_52 ;
   u64 hash_len ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct qstr {
   union __anonunion_193 __anonCompField_qstr_53 ;
   unsigned char const *name ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry_operations;

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
union __anonunion_d_u_195 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations const *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_195 d_u ;
};

#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry *, unsigned int ) ;
   int (*d_weak_revalidate)(struct dentry *, unsigned int ) ;
   int (*d_hash)(struct dentry const *, struct qstr *) ;
   int (*d_compare)(struct dentry const *, struct dentry const *, unsigned int , char const *, struct qstr const *) ;
   int (*d_delete)(struct dentry const *) ;
   void (*d_release)(struct dentry *) ;
   void (*d_prune)(struct dentry *) ;
   void (*d_iput)(struct dentry *, struct inode *) ;
   char *(*d_dname)(struct dentry *, char *, int ) ;
   struct vfsmount *(*d_automount)(struct path *) ;
   int (*d_manage)(struct dentry *, bool ) ;
   struct inode *(*d_select_inode)(struct dentry *, unsigned int ) ;
};

#line 586  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/path.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};

#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct __anonstruct_199 {
   struct radix_tree_node *parent ;
   void *private_data ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
union __anonunion_198 {
   struct __anonstruct_199 __anonCompField___anonunion_198_54 ;
   struct callback_head callback_head ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion_198 __anonCompField_radix_tree_node_55 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};

#line 428 
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
};

#line 435 
struct pid_namespace;

#line 435  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-rwsem.h"
struct block_device;

#line 31 
struct io_context;

#line 32 
struct cgroup_subsys_state;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/fs.h"
struct backing_dev_info;

#line 61 
struct export_operations;

#line 63 
struct pipe_inode_info;

#line 64 
struct poll_table_struct;

#line 65 
struct kstatfs;

#line 66 
struct swap_info_struct;

#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};

#line 263  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};

#line 212  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dqblk_xfs.h"
struct dquot;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
typedef __kernel_uid32_t projid_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
struct __anonstruct_kprojid_t_204 {
   projid_t val ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_204 kprojid_t;

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
typedef long long qsize_t;

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
union __anonunion_205 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct kqid {
   union __anonunion_205 __anonCompField_kqid_57 ;
   enum quota_type type ;
};

#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};

#line 206 
struct quota_format_type;

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};

#line 272  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};

#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *, int ) ;
   int (*read_file_info)(struct super_block *, int ) ;
   int (*write_file_info)(struct super_block *, int ) ;
   int (*free_file_info)(struct super_block *, int ) ;
   int (*read_dqblk)(struct dquot *) ;
   int (*commit_dqblk)(struct dquot *) ;
   int (*release_dqblk)(struct dquot *) ;
};

#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot *) ;
   struct dquot *(*alloc_dquot)(struct super_block *, int ) ;
   void (*destroy_dquot)(struct dquot *) ;
   int (*acquire_dquot)(struct dquot *) ;
   int (*release_dquot)(struct dquot *) ;
   int (*mark_dirty)(struct dquot *) ;
   int (*write_info)(struct super_block *, int ) ;
   qsize_t *(*get_reserved_space)(struct inode *) ;
   int (*get_projid)(struct inode *, kprojid_t *) ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};

#line 348  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};

#line 394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};

#line 405  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};

#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block *, int , int , struct path *) ;
   int (*quota_off)(struct super_block *, int ) ;
   int (*quota_enable)(struct super_block *, unsigned int ) ;
   int (*quota_disable)(struct super_block *, unsigned int ) ;
   int (*quota_sync)(struct super_block *, int ) ;
   int (*set_info)(struct super_block *, int , struct qc_info *) ;
   int (*get_dqblk)(struct super_block *, struct kqid , struct qc_dqblk *) ;
   int (*set_dqblk)(struct super_block *, struct kqid , struct qc_dqblk *) ;
   int (*get_state)(struct super_block *, struct qc_state *) ;
   int (*rm_xquota)(struct super_block *, unsigned int ) ;
};

#line 432  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops const *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};

#line 496  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops const *ops[3U] ;
};

#line 526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb *, long , long ) ;
   void *private ;
   int ki_flags ;
};

#line 366  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page *, struct writeback_control *) ;
   int (*readpage)(struct file *, struct page *) ;
   int (*writepages)(struct address_space *, struct writeback_control *) ;
   int (*set_page_dirty)(struct page *) ;
   int (*readpages)(struct file *, struct address_space *, struct list_head *, unsigned int ) ;
   int (*write_begin)(struct file *, struct address_space *, loff_t , unsigned int , unsigned int , struct page **, void **) ;
   int (*write_end)(struct file *, struct address_space *, loff_t , unsigned int , unsigned int , struct page *, void *) ;
   sector_t (*bmap)(struct address_space *, sector_t ) ;
   void (*invalidatepage)(struct page *, unsigned int , unsigned int ) ;
   int (*releasepage)(struct page *, gfp_t ) ;
   void (*freepage)(struct page *) ;
   ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *, loff_t ) ;
   int (*migratepage)(struct address_space *, struct page *, struct page *, enum migrate_mode ) ;
   int (*launder_page)(struct page *) ;
   int (*is_partially_uptodate)(struct page *, unsigned long , unsigned long ) ;
   void (*is_dirty_writeback)(struct page *, bool *, bool *) ;
   int (*error_remove_page)(struct address_space *, struct page *) ;
   int (*swap_activate)(struct swap_info_struct *, struct file *, sector_t *) ;
   void (*swap_deactivate)(struct file *) ;
};

#line 423  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations const *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};

#line 443 
struct request_queue;

#line 444 
struct hd_struct;

#line 444 
struct gendisk;

#line 444  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};

#line 560 
struct posix_acl;

#line 561 
struct inode_operations;

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_208 {
   unsigned int const i_nlink ;
   unsigned int __i_nlink ;
};

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_209 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};

#line 561 
struct file_lock_context;

#line 561 
struct cdev;

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_210 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations const *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_208 __anonCompField_inode_58 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_209 __anonCompField_inode_59 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations const *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion_210 __anonCompField_inode_60 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};

#line 807  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};

#line 815  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};

#line 838  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_f_u_211 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};

#line 838  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file {
   union __anonunion_f_u_211 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations const *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred const *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};

#line 923  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
typedef void *fl_owner_t;

#line 924 
struct file_lock;

#line 925  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock *, struct file_lock *) ;
   void (*fl_release_private)(struct file_lock *) ;
};

#line 931  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock *, struct file_lock *) ;
   unsigned long (*lm_owner_key)(struct file_lock *) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t ) ;
   void (*lm_put_owner)(fl_owner_t ) ;
   void (*lm_notify)(struct file_lock *) ;
   int (*lm_grant)(struct file_lock *, int ) ;
   bool (*lm_break)(struct file_lock *) ;
   int (*lm_change)(struct file_lock *, int , struct list_head *) ;
   void (*lm_setup)(struct file_lock *, void **) ;
};

#line 947 
struct net;

#line 952 
struct nlm_lockowner;

#line 953  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct nfs4_lock_state;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};

#line 19 
struct fasync_struct;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct __anonstruct_afs_213 {
   struct list_head link ;
   int state ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
union __anonunion_fl_u_212 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_213 afs ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations const *fl_ops ;
   struct lock_manager_operations const *fl_lmops ;
   union __anonunion_fl_u_212 fl_u ;
};

#line 1005  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};

#line 1061 
struct files_struct;

#line 1221  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};

#line 1256  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};

#line 1287 
struct super_operations;

#line 1287 
struct xattr_handler;

#line 1287 
struct mtd_info;

#line 1287  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations const *s_op ;
   struct dquot_operations const *dq_op ;
   struct quotactl_ops const *s_qcop ;
   struct export_operations const *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler const **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations const *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};

#line 1526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};

#line 1540 
struct dir_context;

#line 1565  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context *, char const *, int , loff_t , u64 , unsigned int ) ;
   loff_t pos ;
};

#line 1572  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file *, loff_t , int ) ;
   ssize_t (*read)(struct file *, char *, size_t , loff_t *) ;
   ssize_t (*write)(struct file *, char const *, size_t , loff_t *) ;
   ssize_t (*read_iter)(struct kiocb *, struct iov_iter *) ;
   ssize_t (*write_iter)(struct kiocb *, struct iov_iter *) ;
   int (*iterate)(struct file *, struct dir_context *) ;
   unsigned int (*poll)(struct file *, struct poll_table_struct *) ;
   long (*unlocked_ioctl)(struct file *, unsigned int , unsigned long ) ;
   long (*compat_ioctl)(struct file *, unsigned int , unsigned long ) ;
   int (*mmap)(struct file *, struct vm_area_struct *) ;
   int (*mremap)(struct file *, struct vm_area_struct *) ;
   int (*open)(struct inode *, struct file *) ;
   int (*flush)(struct file *, fl_owner_t ) ;
   int (*release)(struct inode *, struct file *) ;
   int (*fsync)(struct file *, loff_t , loff_t , int ) ;
   int (*aio_fsync)(struct kiocb *, int ) ;
   int (*fasync)(int , struct file *, int ) ;
   int (*lock)(struct file *, int , struct file_lock *) ;
   ssize_t (*sendpage)(struct file *, struct page *, int , size_t , loff_t *, int ) ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   int (*check_flags)(int ) ;
   int (*flock)(struct file *, int , struct file_lock *) ;
   ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ) ;
   ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ) ;
   int (*setlease)(struct file *, long , struct file_lock **, void **) ;
   long (*fallocate)(struct file *, int , loff_t , loff_t ) ;
   void (*show_fdinfo)(struct seq_file *, struct file *) ;
};

#line 1633  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode *, struct dentry *, unsigned int ) ;
   char const *(*follow_link)(struct dentry *, void **) ;
   int (*permission)(struct inode *, int ) ;
   struct posix_acl *(*get_acl)(struct inode *, int ) ;
   int (*readlink)(struct dentry *, char *, int ) ;
   void (*put_link)(struct inode *, void *) ;
   int (*create)(struct inode *, struct dentry *, umode_t , bool ) ;
   int (*link)(struct dentry *, struct inode *, struct dentry *) ;
   int (*unlink)(struct inode *, struct dentry *) ;
   int (*symlink)(struct inode *, struct dentry *, char const *) ;
   int (*mkdir)(struct inode *, struct dentry *, umode_t ) ;
   int (*rmdir)(struct inode *, struct dentry *) ;
   int (*mknod)(struct inode *, struct dentry *, umode_t , dev_t ) ;
   int (*rename)(struct inode *, struct dentry *, struct inode *, struct dentry *) ;
   int (*rename2)(struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int ) ;
   int (*setattr)(struct dentry *, struct iattr *) ;
   int (*getattr)(struct vfsmount *, struct dentry *, struct kstat *) ;
   int (*setxattr)(struct dentry *, char const *, void const *, size_t , int ) ;
   ssize_t (*getxattr)(struct dentry *, char const *, void *, size_t ) ;
   ssize_t (*listxattr)(struct dentry *, char *, size_t ) ;
   int (*removexattr)(struct dentry *, char const *) ;
   int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 , u64 ) ;
   int (*update_time)(struct inode *, struct timespec *, int ) ;
   int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned int , umode_t , int *) ;
   int (*tmpfile)(struct inode *, struct dentry *, umode_t ) ;
   int (*set_acl)(struct inode *, struct posix_acl *, int ) ;
};

#line 1687  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *) ;
   void (*destroy_inode)(struct inode *) ;
   void (*dirty_inode)(struct inode *, int ) ;
   int (*write_inode)(struct inode *, struct writeback_control *) ;
   int (*drop_inode)(struct inode *) ;
   void (*evict_inode)(struct inode *) ;
   void (*put_super)(struct super_block *) ;
   int (*sync_fs)(struct super_block *, int ) ;
   int (*freeze_super)(struct super_block *) ;
   int (*freeze_fs)(struct super_block *) ;
   int (*thaw_super)(struct super_block *) ;
   int (*unfreeze_fs)(struct super_block *) ;
   int (*statfs)(struct dentry *, struct kstatfs *) ;
   int (*remount_fs)(struct super_block *, int *, char *) ;
   void (*umount_begin)(struct super_block *) ;
   int (*show_options)(struct seq_file *, struct dentry *) ;
   int (*show_devname)(struct seq_file *, struct dentry *) ;
   int (*show_path)(struct seq_file *, struct dentry *) ;
   int (*show_stats)(struct seq_file *, struct dentry *) ;
   ssize_t (*quota_read)(struct super_block *, int , char *, size_t , loff_t ) ;
   ssize_t (*quota_write)(struct super_block *, int , char const *, size_t , loff_t ) ;
   struct dquot **(*get_dquots)(struct inode *) ;
   int (*bdev_try_to_free_page)(struct super_block *, struct page *, gfp_t ) ;
   long (*nr_cached_objects)(struct super_block *, struct shrink_control *) ;
   long (*free_cached_objects)(struct super_block *, struct shrink_control *) ;
};

#line 1926  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_system_type {
   char const *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type *, int , char const *, void *) ;
   void (*kill_sb)(struct super_block *) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};

#line 84  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};

#line 4  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_214 {
   unsigned long sig[1U] ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_214 sigset_t;

#line 25 
struct siginfo;

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int );

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};

#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_216 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_217 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_218 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_219 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_221 {
   void *_lower ;
   void *_upper ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_220 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_221 _addr_bnd ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_222 {
   long _band ;
   int _fd ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_223 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_215 {
   int _pad[28U] ;
   struct __anonstruct__kill_216 _kill ;
   struct __anonstruct__timer_217 _timer ;
   struct __anonstruct__rt_218 _rt ;
   struct __anonstruct__sigchld_219 _sigchld ;
   struct __anonstruct__sigfault_220 _sigfault ;
   struct __anonstruct__sigpoll_222 _sigpoll ;
   struct __anonstruct__sigsys_223 _sigsys ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_215 _sifields ;
};

#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};

#line 243  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/seccomp.h"
struct seccomp_filter;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rtmutex.h"
struct rt_mutex_waiter;

#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rtmutex.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};

#line 50 
struct hrtimer_clock_base;

#line 51 
struct hrtimer_cpu_base;

#line 60 
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer *) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};

#line 156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_hrtirq : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hres_active : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};

#line 466  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/latencytop.h"
struct assoc_array_ptr;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
typedef int32_t key_serial_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
typedef uint32_t key_perm_t;

#line 35 
struct key;

#line 36 
struct signal_struct;

#line 37 
struct key_type;

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const *description ;
   size_t desc_len ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_226 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};

#line 123 
struct key_user;

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_227 {
   time_t expiry ;
   time_t revoked_at ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct __anonstruct_229 {
   struct key_type *type ;
   char *description ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_228 {
   struct keyring_index_key index_key ;
   struct __anonstruct_229 __anonCompField___anonunion_228_63 ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_type_data_230 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_payload_232 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_231 {
   union __anonunion_payload_232 payload ;
   struct assoc_array keys ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_226 __anonCompField_key_61 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_227 __anonCompField_key_62 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion_228 __anonCompField_key_64 ;
   union __anonunion_type_data_230 type_data ;
   union __anonunion_231 __anonCompField_key_65 ;
};

#line 358 
struct audit_context;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};

#line 369 
struct percpu_ref;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref *);

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) force_atomic : 1 ;
   struct callback_head rcu ;
};

#line 327 
struct cgroup;

#line 328 
struct cgroup_root;

#line 329 
struct cgroup_subsys;

#line 330 
struct cgroup_taskset;

#line 372  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-refcount.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};

#line 197  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};

#line 270  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};

#line 306  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state *, struct cftype *) ;
   s64 (*read_s64)(struct cgroup_subsys_state *, struct cftype *) ;
   int (*seq_show)(struct seq_file *, void *) ;
   void *(*seq_start)(struct seq_file *, loff_t *) ;
   void *(*seq_next)(struct seq_file *, void *, loff_t *) ;
   void (*seq_stop)(struct seq_file *, void *) ;
   int (*write_u64)(struct cgroup_subsys_state *, struct cftype *, u64 ) ;
   int (*write_s64)(struct cgroup_subsys_state *, struct cftype *, s64 ) ;
   ssize_t (*write)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   struct lock_class_key lockdep_key ;
};

#line 388  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state *) ;
   int (*css_online)(struct cgroup_subsys_state *) ;
   void (*css_offline)(struct cgroup_subsys_state *) ;
   void (*css_released)(struct cgroup_subsys_state *) ;
   void (*css_free)(struct cgroup_subsys_state *) ;
   void (*css_reset)(struct cgroup_subsys_state *) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state *) ;
   int (*can_attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*cancel_attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*fork)(struct task_struct *) ;
   void (*exit)(struct cgroup_subsys_state *, struct cgroup_subsys_state *, struct task_struct *) ;
   void (*bind)(struct cgroup_subsys_state *) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};

#line 128  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct futex_pi_state;

#line 129 
struct robust_list_head;

#line 130 
struct bio_list;

#line 131 
struct fs_struct;

#line 132 
struct perf_event_context;

#line 133 
struct blk_plug;

#line 134 
struct nameidata;

#line 188 
struct cfs_rq;

#line 189 
struct task_group;

#line 477  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};

#line 516  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};

#line 524  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};

#line 531  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};

#line 543  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};

#line 563  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};

#line 584  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};

#line 620 
struct autogroup;

#line 621 
struct tty_struct;

#line 621 
struct taskstats;

#line 621 
struct tty_audit_buf;

#line 621  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_child_subreaper : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};

#line 802  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};

#line 845 
struct reclaim_state;

#line 846  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};

#line 861  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};

#line 909  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};

#line 1172 
struct uts_namespace;

#line 1173  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};

#line 1181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};

#line 1206  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};

#line 1241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};

#line 1273 
struct rt_rq;

#line 1273  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};

#line 1289  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};

#line 1355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) may_oom : 1 ;
};

#line 1779 
struct sched_class;

#line 1779 
struct compat_robust_list_head;

#line 1779 
struct numa_group;

#line 1779 
struct ftrace_ret_stack;

#line 1779  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_struct {
   long volatile state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class const *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_execve : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_iowait : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_reset_on_fork : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_contributes_to_load : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_migrated : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) memcg_kmem_skip_account : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred const *real_cred ;
   struct cred const *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void *) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
   struct thread_struct thread ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};

#line 276  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};

#line 280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};

#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/checksum_64.h"
struct in6_addr;

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/checksum.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
};

#line 77  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-attrs.h"
struct dma_map_ops {
   void *(*alloc)(struct device *, size_t , dma_addr_t *, gfp_t , struct dma_attrs *) ;
   void (*free)(struct device *, size_t , void *, dma_addr_t , struct dma_attrs *) ;
   int (*mmap)(struct device *, struct vm_area_struct *, void *, dma_addr_t , size_t , struct dma_attrs *) ;
   int (*get_sgtable)(struct device *, struct sg_table *, void *, dma_addr_t , size_t , struct dma_attrs *) ;
   dma_addr_t (*map_page)(struct device *, struct page *, unsigned long , size_t , enum dma_data_direction , struct dma_attrs *) ;
   void (*unmap_page)(struct device *, dma_addr_t , size_t , enum dma_data_direction , struct dma_attrs *) ;
   int (*map_sg)(struct device *, struct scatterlist *, int , enum dma_data_direction , struct dma_attrs *) ;
   void (*unmap_sg)(struct device *, struct scatterlist *, int , enum dma_data_direction , struct dma_attrs *) ;
   void (*sync_single_for_cpu)(struct device *, dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_single_for_device)(struct device *, dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_sg_for_cpu)(struct device *, struct scatterlist *, int , enum dma_data_direction ) ;
   void (*sync_sg_for_device)(struct device *, struct scatterlist *, int , enum dma_data_direction ) ;
   int (*mapping_error)(struct device *, dma_addr_t ) ;
   int (*dma_supported)(struct device *, u64 ) ;
   int (*set_dma_mask)(struct device *, u64 ) ;
   int is_phys ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
typedef u64 netdev_features_t;

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
union __anonunion_in6_u_261 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
struct in6_addr {
   union __anonunion_in6_u_261 in6_u ;
};

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/in6.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow_dissector.h"
struct pipe_buf_operations;

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow_dissector.h"
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
   struct pipe_buf_operations const *ops ;
   unsigned int flags ;
   unsigned long private ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pipe_fs_i.h"
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int nrbufs ;
   unsigned int curbuf ;
   unsigned int buffers ;
   unsigned int readers ;
   unsigned int writers ;
   unsigned int files ;
   unsigned int waiting_writers ;
   unsigned int r_counter ;
   unsigned int w_counter ;
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pipe_fs_i.h"
struct pipe_buf_operations {
   int can_merge ;
   int (*confirm)(struct pipe_inode_info *, struct pipe_buffer *) ;
   void (*release)(struct pipe_inode_info *, struct pipe_buffer *) ;
   int (*steal)(struct pipe_inode_info *, struct pipe_buffer *) ;
   void (*get)(struct pipe_inode_info *, struct pipe_buffer *) ;
};

#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/splice.h"
struct napi_struct;

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/splice.h"
struct nf_conntrack {
   atomic_t use ;
};

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
enum ldv_25311 {
    BRNF_PROTO_UNCHANGED = 0,
    BRNF_PROTO_8021Q = 1,
    BRNF_PROTO_PPPOE = 2
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_266 {
   struct net_device *physoutdev ;
   char neigh_header[8U] ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_267 {
   __be32 ipv4_daddr ;
   struct in6_addr ipv6_daddr ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   enum ldv_25311 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) orig_proto : 8 ;
   bool pkt_otherhost ;
   __u16 frag_max_size ;
   unsigned int mask ;
   struct net_device *physindev ;
   union __anonunion_266 __anonCompField_nf_bridge_info_72 ;
   union __anonunion_267 __anonCompField_nf_bridge_info_73 ;
};

#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};

#line 403  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_270 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_269 {
   u64 v64 ;
   struct __anonstruct_270 __anonCompField___anonunion_269_74 ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_mstamp {
   union __anonunion_269 __anonCompField_skb_mstamp_75 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_273 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_272 {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion_273 __anonCompField___anonstruct_272_76 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_271 {
   struct __anonstruct_272 __anonCompField___anonunion_271_77 ;
   struct rb_node rbnode ;
};

#line 457 
struct sec_path;

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_275 {
   __u16 csum_start ;
   __u16 csum_offset ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_274 {
   __wsum csum ;
   struct __anonstruct_275 __anonCompField___anonunion_274_79 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_276 {
   unsigned int napi_id ;
   unsigned int sender_cpu ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_277 {
   __u32 mark ;
   __u32 reserved_tailroom ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_278 {
   __be16 inner_protocol ;
   __u8 inner_ipproto ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct sk_buff {
   union __anonunion_271 __anonCompField_sk_buff_78 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   void (*destructor)(struct sk_buff *) ;
   struct sec_path *sp ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   __u16 queue_mapping ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cloned : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) nohdr : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) fclone : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) peeked : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) head_frag : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) xmit_more : 1 ;
   __u32 headers_start[0U] ;
   __u8 __pkt_type_offset[0U] ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) pkt_type : 3 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pfmemalloc : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_df : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) nfctinfo : 3 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) nf_trace : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) ip_summed : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ooo_okay : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) l4_hash : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sw_hash : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wifi_acked_valid : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wifi_acked : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_fcs : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) encapsulation : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) encap_hdr_csum : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_valid : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_complete_sw : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) csum_level : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_bad : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) ndisc_nodetype : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ipvs_property : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) inner_protocol_type : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) remcsum_offload : 1 ;
   __u16 tc_index ;
   __u16 tc_verd ;
   union __anonunion_274 __anonCompField_sk_buff_80 ;
   __u32 priority ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   union __anonunion_276 __anonCompField_sk_buff_81 ;
   __u32 secmark ;
   union __anonunion_277 __anonCompField_sk_buff_82 ;
   union __anonunion_278 __anonCompField_sk_buff_83 ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __be16 protocol ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   __u32 headers_end[0U] ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};

#line 718 
struct dst_entry;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_ether.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};

#line 125  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char erom_version[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};

#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};

#line 233  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_tunable {
   __u32 cmd ;
   __u32 id ;
   __u32 type_id ;
   __u32 len ;
   void *data[0U] ;
};

#line 245  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 267  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 293  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};

#line 322  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};

#line 438  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};

#line 475  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};

#line 503  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};

#line 605  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};

#line 637  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};

#line 679  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};

#line 712  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};

#line 728  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};

#line 748  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};

#line 759  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};

#line 778  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};

#line 828  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};

#line 999  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};

#line 1007  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 1083  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
};

#line 99  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device *, struct ethtool_cmd *) ;
   int (*set_settings)(struct net_device *, struct ethtool_cmd *) ;
   void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *) ;
   int (*get_regs_len)(struct net_device *) ;
   void (*get_regs)(struct net_device *, struct ethtool_regs *, void *) ;
   void (*get_wol)(struct net_device *, struct ethtool_wolinfo *) ;
   int (*set_wol)(struct net_device *, struct ethtool_wolinfo *) ;
   u32 (*get_msglevel)(struct net_device *) ;
   void (*set_msglevel)(struct net_device *, u32 ) ;
   int (*nway_reset)(struct net_device *) ;
   u32 (*get_link)(struct net_device *) ;
   int (*get_eeprom_len)(struct net_device *) ;
   int (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_coalesce)(struct net_device *, struct ethtool_coalesce *) ;
   int (*set_coalesce)(struct net_device *, struct ethtool_coalesce *) ;
   void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *) ;
   int (*set_ringparam)(struct net_device *, struct ethtool_ringparam *) ;
   void (*get_pauseparam)(struct net_device *, struct ethtool_pauseparam *) ;
   int (*set_pauseparam)(struct net_device *, struct ethtool_pauseparam *) ;
   void (*self_test)(struct net_device *, struct ethtool_test *, u64 *) ;
   void (*get_strings)(struct net_device *, u32 , u8 *) ;
   int (*set_phys_id)(struct net_device *, enum ethtool_phys_id_state ) ;
   void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *, u64 *) ;
   int (*begin)(struct net_device *) ;
   void (*complete)(struct net_device *) ;
   u32 (*get_priv_flags)(struct net_device *) ;
   int (*set_priv_flags)(struct net_device *, u32 ) ;
   int (*get_sset_count)(struct net_device *, int ) ;
   int (*get_rxnfc)(struct net_device *, struct ethtool_rxnfc *, u32 *) ;
   int (*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *) ;
   int (*flash_device)(struct net_device *, struct ethtool_flash *) ;
   int (*reset)(struct net_device *, u32 *) ;
   u32 (*get_rxfh_key_size)(struct net_device *) ;
   u32 (*get_rxfh_indir_size)(struct net_device *) ;
   int (*get_rxfh)(struct net_device *, u32 *, u8 *, u8 *) ;
   int (*set_rxfh)(struct net_device *, u32 const *, u8 const *, u8 const ) ;
   void (*get_channels)(struct net_device *, struct ethtool_channels *) ;
   int (*set_channels)(struct net_device *, struct ethtool_channels *) ;
   int (*get_dump_flag)(struct net_device *, struct ethtool_dump *) ;
   int (*get_dump_data)(struct net_device *, struct ethtool_dump *, void *) ;
   int (*set_dump)(struct net_device *, struct ethtool_dump *) ;
   int (*get_ts_info)(struct net_device *, struct ethtool_ts_info *) ;
   int (*get_module_info)(struct net_device *, struct ethtool_modinfo *) ;
   int (*get_module_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_eee)(struct net_device *, struct ethtool_eee *) ;
   int (*set_eee)(struct net_device *, struct ethtool_eee *) ;
   int (*get_tunable)(struct net_device *, struct ethtool_tunable const *, void *) ;
   int (*set_tunable)(struct net_device *, struct ethtool_tunable const *, void const *) ;
};

#line 235  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow.h"
struct prot_inuse;

#line 236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct u64_stats_sync {
   
};

#line 146  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};

#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[9U] ;
};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[115U] ;
};

#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};

#line 118 
struct proc_dir_entry;

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/packet.h"
struct netns_frags {
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};

#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_frag.h"
struct ipv4_devconf;

#line 185 
struct fib_rules_ops;

#line 186 
struct fib_table;

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
   bool warned ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};

#line 29 
struct inet_peer_base;

#line 29 
struct xt_table;

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   bool fib_offload_disabled ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct inet_peer_base *peers ;
   struct sock **tcp_sk ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_tcp_ecn_fallback ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_ip_nonlocal_bind ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   int sysctl_tcp_mtu_probing ;
   int sysctl_tcp_base_mss ;
   int sysctl_tcp_probe_threshold ;
   u32 sysctl_tcp_probe_interval ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};

#line 113 
struct neighbour;

#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops *) ;
   struct dst_entry *(*check)(struct dst_entry *, __u32 ) ;
   unsigned int (*default_advmss)(struct dst_entry const *) ;
   unsigned int (*mtu)(struct dst_entry const *) ;
   u32 *(*cow_metrics)(struct dst_entry *, unsigned long ) ;
   void (*destroy)(struct dst_entry *) ;
   void (*ifdown)(struct dst_entry *, struct net_device *, int ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry *) ;
   void (*link_failure)(struct sk_buff *) ;
   void (*update_pmtu)(struct dst_entry *, struct sock *, struct sk_buff *, u32 ) ;
   void (*redirect)(struct dst_entry *, struct sock *, struct sk_buff *) ;
   int (*local_out)(struct sk_buff *) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry const *, struct sk_buff *, void const *) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int auto_flowlabels ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
   int idgen_retries ;
   int idgen_delay ;
   int flowlabel_state_ranges ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct ipv6_devconf;

#line 39 
struct rt6_info;

#line 39 
struct rt6_statistics;

#line 39 
struct fib6_table;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t fib6_sernum ;
};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
};

#line 20 
struct sctp_mib;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ieee802154_6lowpan.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netfilter.h"
struct nf_logger;

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger const *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/netfilter.h"
struct ebt_table;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   bool clusterip_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_node;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
};

#line 72 
struct ip_conntrack_stat;

#line 72 
struct nf_ct_event_notifier;

#line 72 
struct nf_exp_event_notifier;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct delayed_work ecache_dwork ;
   bool ecache_dwork_pending ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};

#line 114 
struct nft_af_info;

#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   struct nft_af_info *netdev ;
   unsigned int base_seq ;
   u8 gencursor ;
};

#line 465  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long ) ;
   unsigned long data ;
};

#line 672  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flowcache.h"
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flowcache.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
   u8 dbits4 ;
   u8 sbits4 ;
   u8 dbits6 ;
   u8 sbits6 ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct xfrm_policy_hthresh {
   struct work_struct work ;
   seqlock_t lock ;
   u8 lbits4 ;
   u8 rbits4 ;
   u8 lbits6 ;
   u8 rbits6 ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[3U] ;
   struct xfrm_policy_hash policy_bydst[3U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct xfrm_policy_hthresh policy_hthresh ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};

#line 88 
struct mpls_route;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct netns_mpls {
   size_t platform_labels ;
   struct mpls_route **platform_label ;
   struct ctl_table_header *ctl ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mpls.h"
struct proc_ns_operations;

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mpls.h"
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations const *ops ;
   unsigned int inum ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ns_common.h"
struct net_generic;

#line 12 
struct netns_ipvs;

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ns_common.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   atomic64_t cookie_gen ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   spinlock_t nsid_lock ;
   struct idr netns_ids ;
   struct ns_common ns ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct netns_mpls mpls ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};

#line 241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
struct __anonstruct_possible_net_t_295 {
   struct net *net ;
};

#line 241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
typedef struct __anonstruct_possible_net_t_295 possible_net_t;

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};

#line 186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
   __u32 cls ;
   __u32 cls_msk ;
};

#line 221  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const *data ;
};

#line 652 
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2,
    FWNODE_PDATA = 3
};

#line 659  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct fwnode_handle {
   enum fwnode_type type ;
   struct fwnode_handle *secondary ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
typedef u32 phandle;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
struct device_node {
   char const *name ;
   char const *type ;
   phandle phandle ;
   char const *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};

#line 338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mii.h"
enum ldv_28242 {
    PHY_INTERFACE_MODE_NA = 0,
    PHY_INTERFACE_MODE_MII = 1,
    PHY_INTERFACE_MODE_GMII = 2,
    PHY_INTERFACE_MODE_SGMII = 3,
    PHY_INTERFACE_MODE_TBI = 4,
    PHY_INTERFACE_MODE_REVMII = 5,
    PHY_INTERFACE_MODE_RMII = 6,
    PHY_INTERFACE_MODE_RGMII = 7,
    PHY_INTERFACE_MODE_RGMII_ID = 8,
    PHY_INTERFACE_MODE_RGMII_RXID = 9,
    PHY_INTERFACE_MODE_RGMII_TXID = 10,
    PHY_INTERFACE_MODE_RTBI = 11,
    PHY_INTERFACE_MODE_SMII = 12,
    PHY_INTERFACE_MODE_XGMII = 13,
    PHY_INTERFACE_MODE_MOCA = 14,
    PHY_INTERFACE_MODE_QSGMII = 15,
    PHY_INTERFACE_MODE_MAX = 16
};

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
typedef enum ldv_28242 phy_interface_t;

#line 126 
enum ldv_28295 {
    MDIOBUS_ALLOCATED = 1,
    MDIOBUS_REGISTERED = 2,
    MDIOBUS_UNREGISTERED = 3,
    MDIOBUS_RELEASED = 4
};

#line 133 
struct phy_device;

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct mii_bus {
   char const *name ;
   char id[17U] ;
   void *priv ;
   int (*read)(struct mii_bus *, int , int ) ;
   int (*write)(struct mii_bus *, int , int , u16 ) ;
   int (*reset)(struct mii_bus *) ;
   struct mutex mdio_lock ;
   struct device *parent ;
   enum ldv_28295 state ;
   struct device dev ;
   struct phy_device *phy_map[32U] ;
   u32 phy_mask ;
   u32 phy_ignore_ta_mask ;
   int *irq ;
};

#line 214 
enum phy_state {
    PHY_DOWN = 0,
    PHY_STARTING = 1,
    PHY_READY = 2,
    PHY_PENDING = 3,
    PHY_UP = 4,
    PHY_AN = 5,
    PHY_RUNNING = 6,
    PHY_NOLINK = 7,
    PHY_FORCING = 8,
    PHY_CHANGELINK = 9,
    PHY_HALTED = 10,
    PHY_RESUMING = 11
};

#line 229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_c45_device_ids {
   u32 devices_in_package ;
   u32 device_ids[8U] ;
};

#line 323 
struct phy_driver;

#line 323  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_device {
   struct phy_driver *drv ;
   struct mii_bus *bus ;
   struct device dev ;
   u32 phy_id ;
   struct phy_c45_device_ids c45_ids ;
   bool is_c45 ;
   bool is_internal ;
   bool has_fixups ;
   bool suspended ;
   enum phy_state state ;
   u32 dev_flags ;
   phy_interface_t interface ;
   int addr ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
   int link ;
   u32 interrupts ;
   u32 supported ;
   u32 advertising ;
   u32 lp_advertising ;
   int autoneg ;
   int link_timeout ;
   int irq ;
   void *priv ;
   struct work_struct phy_queue ;
   struct delayed_work state_queue ;
   atomic_t irq_disable ;
   struct mutex lock ;
   struct net_device *attached_dev ;
   void (*adjust_link)(struct net_device *) ;
};

#line 429  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_driver {
   u32 phy_id ;
   char *name ;
   unsigned int phy_id_mask ;
   u32 features ;
   u32 flags ;
   void const *driver_data ;
   int (*soft_reset)(struct phy_device *) ;
   int (*config_init)(struct phy_device *) ;
   int (*probe)(struct phy_device *) ;
   int (*suspend)(struct phy_device *) ;
   int (*resume)(struct phy_device *) ;
   int (*config_aneg)(struct phy_device *) ;
   int (*aneg_done)(struct phy_device *) ;
   int (*read_status)(struct phy_device *) ;
   int (*ack_interrupt)(struct phy_device *) ;
   int (*config_intr)(struct phy_device *) ;
   int (*did_interrupt)(struct phy_device *) ;
   void (*remove)(struct phy_device *) ;
   int (*match_phy_device)(struct phy_device *) ;
   int (*ts_info)(struct phy_device *, struct ethtool_ts_info *) ;
   int (*hwtstamp)(struct phy_device *, struct ifreq *) ;
   bool (*rxtstamp)(struct phy_device *, struct sk_buff *, int ) ;
   void (*txtstamp)(struct phy_device *, struct sk_buff *, int ) ;
   int (*set_wol)(struct phy_device *, struct ethtool_wolinfo *) ;
   void (*get_wol)(struct phy_device *, struct ethtool_wolinfo *) ;
   void (*link_change_notify)(struct phy_device *) ;
   int (*read_mmd_indirect)(struct phy_device *, int , int , int ) ;
   void (*write_mmd_indirect)(struct phy_device *, int , int , int , u32 ) ;
   int (*module_info)(struct phy_device *, struct ethtool_modinfo *) ;
   int (*module_eeprom)(struct phy_device *, struct ethtool_eeprom *, u8 *) ;
   struct device_driver driver ;
};

#line 803  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct fixed_phy_status {
   int link ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy_fixed.h"
enum dsa_tag_protocol {
    DSA_TAG_PROTO_NONE = 0,
    DSA_TAG_PROTO_DSA = 1,
    DSA_TAG_PROTO_TRAILER = 2,
    DSA_TAG_PROTO_EDSA = 3,
    DSA_TAG_PROTO_BRCM = 4
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy_fixed.h"
struct dsa_chip_data {
   struct device *host_dev ;
   int sw_addr ;
   int eeprom_len ;
   struct device_node *of_node ;
   char *port_names[12U] ;
   struct device_node *port_dn[12U] ;
   s8 *rtable ;
};

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   struct net_device *of_netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};

#line 84 
struct packet_type;

#line 85 
struct dsa_switch;

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   int (*rcv)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *) ;
   enum dsa_tag_protocol tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};

#line 123 
struct dsa_switch_driver;

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   enum dsa_tag_protocol tag_protocol ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct device *master_dev ;
   char hwmon_name[24U] ;
   struct device *hwmon_dev ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   u32 phys_mii_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   enum dsa_tag_protocol tag_protocol ;
   int priv_size ;
   char *(*probe)(struct device *, int ) ;
   int (*setup)(struct dsa_switch *) ;
   int (*set_addr)(struct dsa_switch *, u8 *) ;
   u32 (*get_phy_flags)(struct dsa_switch *, int ) ;
   int (*phy_read)(struct dsa_switch *, int , int ) ;
   int (*phy_write)(struct dsa_switch *, int , int , u16 ) ;
   void (*poll_link)(struct dsa_switch *) ;
   void (*adjust_link)(struct dsa_switch *, int , struct phy_device *) ;
   void (*fixed_link_update)(struct dsa_switch *, int , struct fixed_phy_status *) ;
   void (*get_strings)(struct dsa_switch *, int , uint8_t *) ;
   void (*get_ethtool_stats)(struct dsa_switch *, int , uint64_t *) ;
   int (*get_sset_count)(struct dsa_switch *) ;
   void (*get_wol)(struct dsa_switch *, int , struct ethtool_wolinfo *) ;
   int (*set_wol)(struct dsa_switch *, int , struct ethtool_wolinfo *) ;
   int (*suspend)(struct dsa_switch *) ;
   int (*resume)(struct dsa_switch *) ;
   int (*port_enable)(struct dsa_switch *, int , struct phy_device *) ;
   void (*port_disable)(struct dsa_switch *, int , struct phy_device *) ;
   int (*set_eee)(struct dsa_switch *, int , struct phy_device *, struct ethtool_eee *) ;
   int (*get_eee)(struct dsa_switch *, int , struct ethtool_eee *) ;
   int (*get_temp)(struct dsa_switch *, int *) ;
   int (*get_temp_limit)(struct dsa_switch *, int *) ;
   int (*set_temp_limit)(struct dsa_switch *, int ) ;
   int (*get_temp_alarm)(struct dsa_switch *, bool *) ;
   int (*get_eeprom_len)(struct dsa_switch *) ;
   int (*get_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *) ;
   int (*set_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *) ;
   int (*get_regs_len)(struct dsa_switch *, int ) ;
   void (*get_regs)(struct dsa_switch *, int , struct ethtool_regs *, void *) ;
   int (*port_join_bridge)(struct dsa_switch *, int , u32 ) ;
   int (*port_leave_bridge)(struct dsa_switch *, int , u32 ) ;
   int (*port_stp_update)(struct dsa_switch *, int , u8 ) ;
   int (*fdb_add)(struct dsa_switch *, int , unsigned char const *, u16 ) ;
   int (*fdb_del)(struct dsa_switch *, int , unsigned char const *, u16 ) ;
   int (*fdb_getnext)(struct dsa_switch *, int , unsigned char *, bool *) ;
};

#line 320  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_qcn {
   __u8 rpg_enable[8U] ;
   __u32 rppp_max_rps[8U] ;
   __u32 rpg_time_reset[8U] ;
   __u32 rpg_byte_reset[8U] ;
   __u32 rpg_threshold[8U] ;
   __u32 rpg_max_rate[8U] ;
   __u32 rpg_ai_rate[8U] ;
   __u32 rpg_hai_rate[8U] ;
   __u32 rpg_gd[8U] ;
   __u32 rpg_min_dec_fac[8U] ;
   __u32 rpg_min_rate[8U] ;
   __u32 cndd_state_machine[8U] ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_qcn_stats {
   __u64 rppp_rp_centiseconds[8U] ;
   __u32 rppp_created_rps[8U] ;
};

#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};

#line 164  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};

#line 202  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};

#line 236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_setets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_getmaxrate)(struct net_device *, struct ieee_maxrate *) ;
   int (*ieee_setmaxrate)(struct net_device *, struct ieee_maxrate *) ;
   int (*ieee_getqcn)(struct net_device *, struct ieee_qcn *) ;
   int (*ieee_setqcn)(struct net_device *, struct ieee_qcn *) ;
   int (*ieee_getqcnstats)(struct net_device *, struct ieee_qcn_stats *) ;
   int (*ieee_getpfc)(struct net_device *, struct ieee_pfc *) ;
   int (*ieee_setpfc)(struct net_device *, struct ieee_pfc *) ;
   int (*ieee_getapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_setapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_delapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_peer_getets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_peer_getpfc)(struct net_device *, struct ieee_pfc *) ;
   u8 (*getstate)(struct net_device *) ;
   u8 (*setstate)(struct net_device *, u8 ) ;
   void (*getpermhwaddr)(struct net_device *, u8 *) ;
   void (*setpgtccfgtx)(struct net_device *, int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgtx)(struct net_device *, int , u8 ) ;
   void (*setpgtccfgrx)(struct net_device *, int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgrx)(struct net_device *, int , u8 ) ;
   void (*getpgtccfgtx)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *) ;
   void (*getpgbwgcfgtx)(struct net_device *, int , u8 *) ;
   void (*getpgtccfgrx)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *) ;
   void (*getpgbwgcfgrx)(struct net_device *, int , u8 *) ;
   void (*setpfccfg)(struct net_device *, int , u8 ) ;
   void (*getpfccfg)(struct net_device *, int , u8 *) ;
   u8 (*setall)(struct net_device *) ;
   u8 (*getcap)(struct net_device *, int , u8 *) ;
   int (*getnumtcs)(struct net_device *, int , u8 *) ;
   int (*setnumtcs)(struct net_device *, int , u8 ) ;
   u8 (*getpfcstate)(struct net_device *) ;
   void (*setpfcstate)(struct net_device *, u8 ) ;
   void (*getbcncfg)(struct net_device *, int , u32 *) ;
   void (*setbcncfg)(struct net_device *, int , u32 ) ;
   void (*getbcnrp)(struct net_device *, int , u8 *) ;
   void (*setbcnrp)(struct net_device *, int , u8 ) ;
   int (*setapp)(struct net_device *, u8 , u16 , u8 ) ;
   int (*getapp)(struct net_device *, u8 , u16 ) ;
   u8 (*getfeatcfg)(struct net_device *, int , u8 *) ;
   u8 (*setfeatcfg)(struct net_device *, int , u8 ) ;
   u8 (*getdcbx)(struct net_device *) ;
   u8 (*setdcbx)(struct net_device *, u8 ) ;
   int (*peer_getappinfo)(struct net_device *, struct dcb_peer_app_info *, u16 *) ;
   int (*peer_getapptable)(struct net_device *, struct dcb_app *) ;
   int (*cee_peer_getpg)(struct net_device *, struct cee_pg *) ;
   int (*cee_peer_getpfc)(struct net_device *, struct cee_pfc *) ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};

#line 515  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};

#line 1628  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/security.h"
struct mnt_namespace;

#line 1629 
struct ipc_namespace;

#line 1630  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};

#line 147  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr const *nlh ;
   int (*dump)(struct sk_buff *, struct netlink_callback *) ;
   int (*done)(struct netlink_callback *) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netlink.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};

#line 643  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_link.h"
struct ifla_vf_stats {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 broadcast ;
   __u64 multicast ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
   __u32 rss_query_en ;
};

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_bonding.h"
struct netpoll_info;

#line 119 
struct wireless_dev;

#line 120 
struct wpan_dev;

#line 121 
struct mpls_dev;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = -2147483648,
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;

#line 129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};

#line 190 
struct neigh_parms;

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};

#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};

#line 245  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff *, struct net_device *, unsigned short , void const *, void const *, unsigned int ) ;
   int (*parse)(struct sk_buff const *, unsigned char *) ;
   int (*cache)(struct neighbour const *, struct hh_cache *, __be16 ) ;
   void (*cache_update)(struct hh_cache *, struct net_device const *, unsigned char const *) ;
};

#line 295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct *, int ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct hrtimer timer ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};

#line 340 
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
};

#line 388  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;

#line 389  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff **);

#line 537 
struct Qdisc;

#line 537  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
   unsigned long tx_maxrate ;
};

#line 607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};

#line 619  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};

#line 631  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};

#line 683  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};

#line 706  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};

#line 719  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};

#line 730  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};

#line 741  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};

#line 757  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_phys_item_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};

#line 770  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device *) ;
   void (*ndo_uninit)(struct net_device *) ;
   int (*ndo_open)(struct net_device *) ;
   int (*ndo_stop)(struct net_device *) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff *, struct net_device *) ;
   u16 (*ndo_select_queue)(struct net_device *, struct sk_buff *, void *, u16 (*)(struct net_device *, struct sk_buff *)) ;
   void (*ndo_change_rx_flags)(struct net_device *, int ) ;
   void (*ndo_set_rx_mode)(struct net_device *) ;
   int (*ndo_set_mac_address)(struct net_device *, void *) ;
   int (*ndo_validate_addr)(struct net_device *) ;
   int (*ndo_do_ioctl)(struct net_device *, struct ifreq *, int ) ;
   int (*ndo_set_config)(struct net_device *, struct ifmap *) ;
   int (*ndo_change_mtu)(struct net_device *, int ) ;
   int (*ndo_neigh_setup)(struct net_device *, struct neigh_parms *) ;
   void (*ndo_tx_timeout)(struct net_device *) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device *, struct rtnl_link_stats64 *) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device *) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device *, __be16 , u16 ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device *, __be16 , u16 ) ;
   void (*ndo_poll_controller)(struct net_device *) ;
   int (*ndo_netpoll_setup)(struct net_device *, struct netpoll_info *) ;
   void (*ndo_netpoll_cleanup)(struct net_device *) ;
   int (*ndo_busy_poll)(struct napi_struct *) ;
   int (*ndo_set_vf_mac)(struct net_device *, int , u8 *) ;
   int (*ndo_set_vf_vlan)(struct net_device *, int , u16 , u8 ) ;
   int (*ndo_set_vf_rate)(struct net_device *, int , int , int ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device *, int , bool ) ;
   int (*ndo_get_vf_config)(struct net_device *, int , struct ifla_vf_info *) ;
   int (*ndo_set_vf_link_state)(struct net_device *, int , int ) ;
   int (*ndo_get_vf_stats)(struct net_device *, int , struct ifla_vf_stats *) ;
   int (*ndo_set_vf_port)(struct net_device *, int , struct nlattr **) ;
   int (*ndo_get_vf_port)(struct net_device *, int , struct sk_buff *) ;
   int (*ndo_set_vf_rss_query_en)(struct net_device *, int , bool ) ;
   int (*ndo_setup_tc)(struct net_device *, u8 ) ;
   int (*ndo_fcoe_enable)(struct net_device *) ;
   int (*ndo_fcoe_disable)(struct net_device *) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device *, u16 , struct scatterlist *, unsigned int ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device *, u16 ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device *, u16 , struct scatterlist *, unsigned int ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device *, struct netdev_fcoe_hbainfo *) ;
   int (*ndo_fcoe_get_wwn)(struct net_device *, u64 *, int ) ;
   int (*ndo_rx_flow_steer)(struct net_device *, struct sk_buff const *, u16 , u32 ) ;
   int (*ndo_add_slave)(struct net_device *, struct net_device *) ;
   int (*ndo_del_slave)(struct net_device *, struct net_device *) ;
   netdev_features_t (*ndo_fix_features)(struct net_device *, netdev_features_t ) ;
   int (*ndo_set_features)(struct net_device *, netdev_features_t ) ;
   int (*ndo_neigh_construct)(struct neighbour *) ;
   void (*ndo_neigh_destroy)(struct neighbour *) ;
   int (*ndo_fdb_add)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 , u16 ) ;
   int (*ndo_fdb_del)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 ) ;
   int (*ndo_fdb_dump)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int ) ;
   int (*ndo_bridge_setlink)(struct net_device *, struct nlmsghdr *, u16 ) ;
   int (*ndo_bridge_getlink)(struct sk_buff *, u32 , u32 , struct net_device *, u32 , int ) ;
   int (*ndo_bridge_dellink)(struct net_device *, struct nlmsghdr *, u16 ) ;
   int (*ndo_change_carrier)(struct net_device *, bool ) ;
   int (*ndo_get_phys_port_id)(struct net_device *, struct netdev_phys_item_id *) ;
   int (*ndo_get_phys_port_name)(struct net_device *, char *, size_t ) ;
   void (*ndo_add_vxlan_port)(struct net_device *, sa_family_t , __be16 ) ;
   void (*ndo_del_vxlan_port)(struct net_device *, sa_family_t , __be16 ) ;
   void *(*ndo_dfwd_add_station)(struct net_device *, struct net_device *) ;
   void (*ndo_dfwd_del_station)(struct net_device *, void *) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff *, struct net_device *, void *) ;
   int (*ndo_get_lock_subclass)(struct net_device *) ;
   netdev_features_t (*ndo_features_check)(struct sk_buff *, struct net_device *, netdev_features_t ) ;
   int (*ndo_set_tx_maxrate)(struct net_device *, int , u32 ) ;
   int (*ndo_get_iflink)(struct net_device const *) ;
};

#line 1243 
enum ldv_30007 {
    NETREG_UNINITIALIZED = 0,
    NETREG_REGISTERED = 1,
    NETREG_UNREGISTERING = 2,
    NETREG_UNREGISTERED = 3,
    NETREG_RELEASED = 4,
    NETREG_DUMMY = 5
};

#line 1252 
enum ldv_30008 {
    RTNL_LINK_INITIALIZED = 0,
    RTNL_LINK_INITIALIZING = 1
};

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct __anonstruct_adj_list_308 {
   struct list_head upper ;
   struct list_head lower ;
};

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct __anonstruct_all_adj_list_309 {
   struct list_head upper ;
   struct list_head lower ;
};

#line 1257 
struct iw_handler_def;

#line 1257 
struct iw_public_data;

#line 1257 
struct switchdev_ops;

#line 1257 
struct vlan_info;

#line 1257 
struct tipc_bearer;

#line 1257 
struct in_device;

#line 1257 
struct dn_dev;

#line 1257 
struct inet6_dev;

#line 1257 
struct tcf_proto;

#line 1257 
struct cpu_rmap;

#line 1257 
struct pcpu_lstats;

#line 1257 
struct pcpu_sw_netstats;

#line 1257 
struct pcpu_dstats;

#line 1257 
struct pcpu_vstats;

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
union __anonunion_310 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};

#line 1257 
struct garp_port;

#line 1257 
struct mrp_port;

#line 1257 
struct rtnl_link_ops;

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   atomic_t carrier_changes ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct list_head ptype_all ;
   struct list_head ptype_specific ;
   struct __anonstruct_adj_list_308 adj_list ;
   struct __anonstruct_all_adj_list_309 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int group ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   struct iw_handler_def const *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops const *netdev_ops ;
   struct ethtool_ops const *ethtool_ops ;
   struct switchdev_ops const *switchdev_ops ;
   struct header_ops const *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   unsigned char name_assign_type ;
   bool uc_promisc ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   struct wpan_dev *ieee802154_ptr ;
   struct mpls_dev *mpls_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   unsigned long gro_flush_timeout ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct tcf_proto *ingress_cl_list ;
   struct netdev_queue *ingress_queue ;
   struct list_head nf_hooks_ingress ;
   unsigned char broadcast[32U] ;
   struct cpu_rmap *rx_cpu_rmap ;
   struct hlist_node index_hlist ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   int watchdog_timeo ;
   struct xps_dev_maps *xps_maps ;
   unsigned long trans_start ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct list_head link_watch_list ;
   enum ldv_30007 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) reg_state : 8 ;
   bool dismantle ;
   enum ldv_30008 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) rtnl_link_state : 16 ;
   void (*destructor)(struct net_device *) ;
   struct netpoll_info *npinfo ;
   possible_net_t nd_net ;
   union __anonunion_310 __anonCompField_net_device_93 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group const *sysfs_groups[4U] ;
   struct attribute_group const *sysfs_rx_queue_group ;
   struct rtnl_link_ops const *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   u16 gso_min_segs ;
   struct dcbnl_rtnl_ops const *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
};

#line 1978  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct packet_type {
   __be16 type ;
   struct net_device *dev ;
   int (*func)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *) ;
   bool (*id_match)(struct packet_type *, struct sock *) ;
   void *af_packet_priv ;
   struct list_head list ;
};

#line 2025  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_fddi.h"
struct fddi_statistics {
   struct net_device_stats gen ;
   __u8 smt_station_id[8U] ;
   __u32 smt_op_version_id ;
   __u32 smt_hi_version_id ;
   __u32 smt_lo_version_id ;
   __u8 smt_user_data[32U] ;
   __u32 smt_mib_version_id ;
   __u32 smt_mac_cts ;
   __u32 smt_non_master_cts ;
   __u32 smt_master_cts ;
   __u32 smt_available_paths ;
   __u32 smt_config_capabilities ;
   __u32 smt_config_policy ;
   __u32 smt_connection_policy ;
   __u32 smt_t_notify ;
   __u32 smt_stat_rpt_policy ;
   __u32 smt_trace_max_expiration ;
   __u32 smt_bypass_present ;
   __u32 smt_ecm_state ;
   __u32 smt_cf_state ;
   __u32 smt_remote_disconnect_flag ;
   __u32 smt_station_status ;
   __u32 smt_peer_wrap_flag ;
   __u32 smt_time_stamp ;
   __u32 smt_transition_time_stamp ;
   __u32 mac_frame_status_functions ;
   __u32 mac_t_max_capability ;
   __u32 mac_tvx_capability ;
   __u32 mac_available_paths ;
   __u32 mac_current_path ;
   __u8 mac_upstream_nbr[6U] ;
   __u8 mac_downstream_nbr[6U] ;
   __u8 mac_old_upstream_nbr[6U] ;
   __u8 mac_old_downstream_nbr[6U] ;
   __u32 mac_dup_address_test ;
   __u32 mac_requested_paths ;
   __u32 mac_downstream_port_type ;
   __u8 mac_smt_address[6U] ;
   __u32 mac_t_req ;
   __u32 mac_t_neg ;
   __u32 mac_t_max ;
   __u32 mac_tvx_value ;
   __u32 mac_frame_cts ;
   __u32 mac_copied_cts ;
   __u32 mac_transmit_cts ;
   __u32 mac_error_cts ;
   __u32 mac_lost_cts ;
   __u32 mac_frame_error_threshold ;
   __u32 mac_frame_error_ratio ;
   __u32 mac_rmt_state ;
   __u32 mac_da_flag ;
   __u32 mac_una_da_flag ;
   __u32 mac_frame_error_flag ;
   __u32 mac_ma_unitdata_available ;
   __u32 mac_hardware_present ;
   __u32 mac_ma_unitdata_enable ;
   __u32 path_tvx_lower_bound ;
   __u32 path_t_max_lower_bound ;
   __u32 path_max_t_req ;
   __u32 path_configuration[8U] ;
   __u32 port_my_type[2U] ;
   __u32 port_neighbor_type[2U] ;
   __u32 port_connection_policies[2U] ;
   __u32 port_mac_indicated[2U] ;
   __u32 port_current_path[2U] ;
   __u8 port_requested_paths[6U] ;
   __u32 port_mac_placement[2U] ;
   __u32 port_available_paths[2U] ;
   __u32 port_pmd_class[2U] ;
   __u32 port_connection_capabilities[2U] ;
   __u32 port_bs_flag[2U] ;
   __u32 port_lct_fail_cts[2U] ;
   __u32 port_ler_estimate[2U] ;
   __u32 port_lem_reject_cts[2U] ;
   __u32 port_lem_cts[2U] ;
   __u32 port_ler_cutoff[2U] ;
   __u32 port_ler_alarm[2U] ;
   __u32 port_connect_state[2U] ;
   __u32 port_pcm_state[2U] ;
   __u32 port_pc_withhold[2U] ;
   __u32 port_ler_flag[2U] ;
   __u32 port_hardware_present[2U] ;
};

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/resource_ext.h"
struct hotplug_slot;

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/resource_ext.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef int pci_power_t;

#line 137  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned int pci_channel_state_t;

#line 138 
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
};

#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;

#line 192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;

#line 249 
struct pcie_link_state;

#line 250 
struct pci_vpd;

#line 251 
struct pci_sriov;

#line 252 
struct pci_ats;

#line 253 
struct pci_driver;

#line 253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
union __anonunion_316 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};

#line 253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   u8 dma_alias_devfn ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(5))) pme_support : 5 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pme_interrupt : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pme_poll : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d1_support : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d2_support : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_d1d2 : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_d3cold : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d3cold_allowed : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) mmio_always_on : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wakeup_prepared : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) runtime_d3cold : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_hotplug : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) transparent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) multifunction : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_added : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_busmaster : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_msi : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_64bit_msi : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) block_cfg_access : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) broken_parity_status : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) irq_reroute_variant : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) msi_enabled : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) msix_enabled : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ari_enabled : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_managed : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) needs_freset : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_saved : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_physfn : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_virtfn : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) reset_fn : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_hotplug_bridge : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) __aer_firmware_first_valid : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) __aer_firmware_first : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) broken_intx_masking : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) io_window_1k : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) irq_managed : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) has_secondary_link : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct attribute_group const **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion_316 __anonCompField_pci_dev_94 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
};

#line 442 
struct pci_ops;

#line 442 
struct msi_controller;

#line 442  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_controller *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_added : 1 ;
};

#line 565  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_ops {
   void *(*map_bus)(struct pci_bus *, unsigned int , int ) ;
   int (*read)(struct pci_bus *, unsigned int , int , int , u32 *) ;
   int (*write)(struct pci_bus *, unsigned int , int , int , u32 ) ;
};

#line 593  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};

#line 607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned int pci_ers_result_t;

#line 617  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev *, enum pci_channel_state ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev *) ;
   pci_ers_result_t (*link_reset)(struct pci_dev *) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev *) ;
   void (*reset_notify)(struct pci_dev *, bool ) ;
   void (*resume)(struct pci_dev *) ;
};

#line 650  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const *name ;
   struct pci_device_id const *id_table ;
   int (*probe)(struct pci_dev *, struct pci_device_id const *) ;
   void (*remove)(struct pci_dev *) ;
   int (*suspend)(struct pci_dev *, pm_message_t ) ;
   int (*suspend_late)(struct pci_dev *, pm_message_t ) ;
   int (*resume_early)(struct pci_dev *) ;
   int (*resume)(struct pci_dev *) ;
   void (*shutdown)(struct pci_dev *) ;
   int (*sriov_configure)(struct pci_dev *, int ) ;
   struct pci_error_handlers const *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};

#line 1911  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct s_mbuf_pool {
   Mbuf *mb_start ;
   Mbuf *mb_free ;
};

#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/hwmtm.h"
struct hwm_r {
   u_int len ;
   char *mb_pos ;
};

#line 121  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/hwmtm.h"
struct hw_modul {
   struct s_mbuf_pool mbuf_pool ;
   struct hwm_r r ;
   union s_fp_descr volatile *descr_p ;
   u_short pass_SMT ;
   u_short pass_NSA ;
   u_short pass_DB ;
   u_short pass_llc_promisc ;
   Mbuf *llc_rx_pipe ;
   Mbuf *llc_rx_tail ;
   int queued_rx_frames ;
   Mbuf *txd_tx_pipe ;
   Mbuf *txd_tx_tail ;
   int queued_txd_mb ;
   int rx_break ;
   int leave_isr ;
   int isr_flag ;
   struct s_smt_tx_queue *tx_p ;
   u_long tx_descr ;
   int tx_len ;
   Mbuf *tx_mb ;
   char *tx_data ;
   int detec_count ;
   u_long rx_len_error ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/targetos.h"
struct s_smt_os {
   struct net_device *dev ;
   struct net_device *next_module ;
   unsigned int bus_type ;
   struct pci_dev pdev ;
   unsigned long base_addr ;
   unsigned char factory_mac_addr[8U] ;
   ulong SharedMemSize ;
   ulong SharedMemHeap ;
   void *SharedMemAddr ;
   dma_addr_t SharedMemDMA ;
   ulong QueueSkb ;
   struct sk_buff_head SendSkbQueue ;
   ulong MaxFrameSize ;
   unsigned char ResetRequested ;
   struct fddi_statistics MacStat ;
   unsigned char *LocalRxBuffer ;
   dma_addr_t LocalRxBufferDMA ;
   u_long smc_version ;
   struct hw_modul hwm ;
   spinlock_t DriverLock ;
};

#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/targetos.h"
struct s_ess {
   u_char sync_bw_available ;
   u_char local_sba_active ;
   char raf_act_timer_poll ;
   char timer_count ;
   Mbuf *sba_reply_pend ;
   long sync_bw ;
   u_long alloc_trans_id ;
};

#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/sba.h"
struct event_queue {
   u_short class ;
   u_short event ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smc.h"
struct s_queue {
   struct event_queue ev_queue[64U] ;
   struct event_queue *ev_put ;
   struct event_queue *ev_get ;
};

#line 82  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smc.h"
struct s_ecm {
   u_char path_test ;
   u_char sb_flag ;
   u_char DisconnectFlag ;
   u_char ecm_line_state ;
   u_long trace_prop ;
   char ec_pad[2U] ;
   struct smt_timer ecm_timer ;
};

#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smc.h"
struct s_rmt {
   u_char dup_addr_test ;
   u_char da_flag ;
   u_char loop_avail ;
   u_char sm_ma_avail ;
   u_char no_flag ;
   u_char bn_flag ;
   u_char jm_flag ;
   u_char rm_join ;
   u_char rm_loop ;
   long fast_rm_join ;
   struct smt_timer rmt_timer0 ;
   struct smt_timer rmt_timer1 ;
   struct smt_timer rmt_timer2 ;
   u_char timer0_exp ;
   u_char timer1_exp ;
   u_char timer2_exp ;
   u_char rm_pad1[1U] ;
};

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smc.h"
struct s_cfm {
   u_char cf_state ;
   u_char cf_pad[3U] ;
};

#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smc.h"
struct s_pcm {
   u_char pcm_pad[3U] ;
};

#line 193  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smc.h"
struct s_phy {
   struct fddi_mib_p *mib ;
   u_char np ;
   u_char cf_join ;
   u_char cf_loop ;
   u_char wc_flag ;
   u_char pc_mode ;
   u_char pc_lem_fail ;
   u_char lc_test ;
   u_char scrub ;
   char phy_name ;
   u_char pmd_type[2U] ;
   u_char pmd_scramble ;
   u_char curr_ls ;
   u_char ls_flag ;
   u_char rc_flag ;
   u_char tc_flag ;
   u_char td_flag ;
   u_char bitn ;
   u_char tr_flag ;
   u_char twisted ;
   u_char t_val[10U] ;
   u_char r_val[10U] ;
   u_long t_next[10U] ;
   struct smt_timer pcm_timer0 ;
   struct smt_timer pcm_timer1 ;
   struct smt_timer pcm_timer2 ;
   u_char timer0_exp ;
   u_char timer1_exp ;
   u_char timer2_exp ;
   u_char pcm_pad1[1U] ;
   int cem_pst ;
   struct lem_counter lem ;
   struct s_plc plc ;
};

#line 240  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smc.h"
struct s_timer {
   struct smt_timer *st_queue ;
   struct smt_timer st_fast ;
};

#line 250  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smc.h"
struct s_srf {
   u_long SRThreshold ;
   u_char RT_Flag ;
   u_char sr_state ;
   u_char any_report ;
   u_long TSR ;
   u_short ring_status ;
};

#line 283  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smc.h"
struct s_srf_evc {
   u_char evc_code ;
   u_char evc_index ;
   u_char evc_rep_required ;
   u_short evc_para ;
   u_char *evc_cond_state ;
   u_char *evc_multiple ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smc.h"
struct smt_values {
   u_long smt_tvu ;
   u_long smt_tvd ;
   u_long smt_tid ;
   u_long pend[5U] ;
   u_long uniq_time ;
   u_short uniq_ticks ;
   u_short please_reconnect ;
   u_long smt_last_lem ;
   u_long smt_last_notify ;
   struct smt_timer smt_timer ;
   u_long last_tok_time[1U] ;
};

#line 350  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smc.h"
struct smt_config {
   u_char attach_s ;
   u_char sas ;
   u_char build_ring_map ;
   u_char numphys ;
   u_char sc_pad[1U] ;
   u_long pcm_tb_min ;
   u_long pcm_tb_max ;
   u_long pcm_c_min ;
   u_long pcm_t_out ;
   u_long pcm_tl_min ;
   u_long pcm_lc_short ;
   u_long pcm_lc_medium ;
   u_long pcm_lc_long ;
   u_long pcm_lc_extended ;
   u_long pcm_t_next_9 ;
   u_long pcm_ns_max ;
   u_long ecm_i_max ;
   u_long ecm_in_max ;
   u_long ecm_td_min ;
   u_long ecm_test_done ;
   u_long ecm_check_poll ;
   u_long rmt_t_non_op ;
   u_long rmt_t_stuck ;
   u_long rmt_t_direct ;
   u_long rmt_t_jam ;
   u_long rmt_t_announce ;
   u_long rmt_t_poll ;
   u_long rmt_dup_mac_behavior ;
   u_long mac_d_max ;
   u_long lct_short ;
   u_long lct_medium ;
   u_long lct_long ;
   u_long lct_extended ;
};

#line 401  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smc.h"
struct s_smc {
   struct s_smt_os os ;
   struct s_smt_hw hw ;
   struct smt_config s ;
   struct smt_values sm ;
   struct s_ecm e ;
   struct s_rmt r ;
   struct s_cfm cf ;
   struct s_pcm p ;
   struct s_phy y[2U] ;
   struct s_queue q ;
   struct s_timer t ;
   struct s_srf srf ;
   struct s_srf_evc evcs[14U] ;
   struct fddi_mib mib ;
   struct s_ess ess ;
};

#line 410  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/cmtdef.h"
struct s_pcon {
   int pc_len ;
   int pc_err ;
   int pc_badset ;
   void *pc_p ;
};

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/srf.c"
struct evc_init {
   u_char code ;
   u_char index ;
   u_char n ;
   u_short para ;
};

#line 14  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
struct kernel_symbol {
   unsigned long value ;
   char const *name ;
};

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/init.h"
typedef void (*ctor_fn_t)(void);

#line 234  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
struct _ddebug {
   char const *modname ;
   char const *function ;
   char const *filename ;
   char const *format ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))) lineno : 18 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) flags : 8 ;
};

#line 555  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/percpu.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jump_label.h"
struct jump_entry;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/jump_label.h"
typedef u64 jump_label_t;

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/jump_label.h"
struct jump_entry {
   jump_label_t code ;
   jump_label_t target ;
   jump_label_t key ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;

#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};

#line 198  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;

#line 223  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kernel_param;

#line 228  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const *, struct kernel_param const *) ;
   int (*get)(char *, struct kernel_param const *) ;
   void (*free)(void *) ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_string;

#line 62 
struct kparam_array;

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
union __anonunion_2393 {
   void *arg ;
   struct kparam_string const *str ;
   struct kparam_array const *arr ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kernel_param {
   char const *name ;
   struct module *mod ;
   struct kernel_param_ops const *ops ;
   u16 const perm ;
   s8 level ;
   u8 flags ;
   union __anonunion_2393 __anonCompField_kernel_param_49 ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops const *ops ;
   void *elem ;
};

#line 469  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rbtree_latch.h"
struct mod_arch_specific {
   
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_param_attrs;

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute *, struct module_kobject *, char *) ;
   ssize_t (*store)(struct module_attribute *, struct module_kobject *, char const *, size_t ) ;
   void (*setup)(struct module *, char const *) ;
   int (*test)(struct module *) ;
   void (*free)(struct module *) ;
};

#line 74 
struct exception_table_entry;

#line 290 
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
};

#line 297  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};

#line 304 
struct module_sect_attrs;

#line 304 
struct module_notes_attrs;

#line 304 
struct tracepoint;

#line 304 
struct trace_event_call;

#line 304 
struct trace_enum_map;

#line 304  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const *version ;
   char const *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol const *syms ;
   unsigned long const *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol const *gpl_syms ;
   unsigned long const *gpl_crcs ;
   struct kernel_symbol const *unused_syms ;
   unsigned long const *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol const *unused_gpl_syms ;
   unsigned long const *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol const *gpl_future_syms ;
   unsigned long const *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const *tracepoints_ptrs ;
   struct jump_entry *jump_entries ;
   unsigned int num_jump_entries ;
   unsigned int num_trace_bprintk_fmt ;
   char const **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};

#line 796 
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};

#line 191  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_hw_addr {
   struct list_head list ;
   unsigned char addr[32U] ;
   unsigned char type ;
   bool global_use ;
   int sync_cnt ;
   int refcount ;
   int synced ;
   struct callback_head callback_head ;
};

#line 2893 
enum skb_free_reason {
    SKB_REASON_CONSUMED = 0,
    SKB_REASON_DROPPED = 1
};

#line 159  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/hwmtm.h"
struct s_skfp_ioctl {
   unsigned short cmd ;
   unsigned short len ;
   unsigned char *data ;
};

#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/targetos.h"
typedef struct s_smt_os skfddi_priv;

#line 138  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
struct plt {
   int timer ;
   int para ;
};

#line 563  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_1048 {
   u_int p1048_flag ;
   u_int p1048_cf_state ;
};

#line 581  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_208c {
   u_int p208c_flag ;
   u_short p208c_pad ;
   u_short p208c_dupcondition ;
   struct fddi_addr p208c_fddilong ;
   struct fddi_addr p208c_fddiunalong ;
};

#line 595  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_208d {
   u_int p208d_flag ;
   u_int p208d_frame_ct ;
   u_int p208d_error_ct ;
   u_int p208d_lost_ct ;
   u_int p208d_ratio ;
};

#line 604  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_208e {
   u_int p208e_flag ;
   u_int p208e_not_copied ;
   u_int p208e_copied ;
   u_int p208e_not_copied_ratio ;
};

#line 612  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_208f {
   u_int p208f_multiple ;
   u_int p208f_nacondition ;
   struct fddi_addr p208f_old_una ;
   struct fddi_addr p208f_new_una ;
   struct fddi_addr p208f_old_dna ;
   struct fddi_addr p208f_new_dna ;
   u_short p208f_curren_path ;
   struct fddi_addr p208f_smt_address ;
};

#line 625  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_2090 {
   u_int p2090_multiple ;
   u_short p2090_availablepaths ;
   u_short p2090_currentpath ;
   u_int p2090_requestedpaths ;
};

#line 672  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_4050 {
   u_int p4050_flag ;
   u_char p4050_pad ;
   u_char p4050_cutoff ;
   u_char p4050_alarm ;
   u_char p4050_estimate ;
   u_int p4050_reject_ct ;
   u_int p4050_ct ;
};

#line 684  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_4051 {
   u_int p4051_multiple ;
   u_short p4051_porttype ;
   u_short p4051_connectstate ;
   u_short p4051_pc_neighbor ;
   u_short p4051_pc_withhold ;
};

#line 693  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_4052 {
   u_int p4052_flag ;
   u_int p4052_eberrorcount ;
};

#line 699  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_4053 {
   u_int p4053_multiple ;
   u_short p4053_availablepaths ;
   u_short p4053_currentpath ;
   u_int p4053_requestedpaths ;
   u_short p4053_mytype ;
   u_short p4053_neighbortype ;
};

#line 710  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_setcount {
   struct smt_para para ;
   u_int count ;
   u_char timestamp[8U] ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pmf.c"
struct s_p_tab;

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pmf.c"
struct s_p_tab {
   u_short p_num ;
   u_char p_access ;
   u_short p_offset ;
   char p_swap[3U] ;
};

#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_una {
   struct smt_para para ;
   u_short una_pad ;
   struct fddi_addr una_node ;
};

#line 128  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_sde {
   struct smt_para para ;
   u_char sde_type ;
   u_char sde_mac_count ;
   u_char sde_non_master ;
   u_char sde_master ;
};

#line 145  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_state {
   struct smt_para para ;
   u_short st_pad ;
   u_char st_topology ;
   u_char st_dupl_addr ;
};

#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_timestamp {
   struct smt_para para ;
   u_char ts_time[8U] ;
};

#line 178  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_policy {
   struct smt_para para ;
   u_short pl_config ;
   u_short pl_connect ;
};

#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_latency {
   struct smt_para para ;
   u_short lt_phyout_idx1 ;
   u_short lt_latency1 ;
   u_short lt_phyout_idx2 ;
   u_short lt_latency2 ;
};

#line 209  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_neighbor {
   struct smt_para para ;
   u_short nb_mib_index ;
   u_short nb_mac_index ;
   struct fddi_addr nb_una ;
   struct fddi_addr nb_dna ;
};

#line 223  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_phy_rec {
   u_short phy_mib_index ;
   u_char phy_type ;
   u_char phy_connect_state ;
   u_char phy_remote_type ;
   u_char phy_remote_mac ;
   u_short phy_resource_idx ;
};

#line 248  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_mac_rec {
   struct fddi_addr mac_addr ;
   u_short mac_resource_idx ;
};

#line 256  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_path {
   struct smt_para para ;
   struct smt_phy_rec pd_phy[2U] ;
   struct smt_mac_rec pd_mac ;
};

#line 270  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_mac_status {
   struct smt_para para ;
   u_short st_mib_index ;
   u_short st_mac_index ;
   u_int st_t_req ;
   u_int st_t_neg ;
   u_int st_t_max ;
   u_int st_tvx_value ;
   u_int st_t_min ;
   u_int st_sba ;
   u_int st_frame_ct ;
   u_int st_error_ct ;
   u_int st_lost_ct ;
};

#line 291  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_lem {
   struct smt_para para ;
   u_short lem_mib_index ;
   u_short lem_phy_index ;
   u_char lem_pad2 ;
   u_char lem_cutoff ;
   u_char lem_alarm ;
   u_char lem_estimate ;
   u_int lem_reject_ct ;
   u_int lem_ct ;
};

#line 311  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_mac_counter {
   struct smt_para para ;
   u_short mc_mib_index ;
   u_short mc_index ;
   u_int mc_receive_ct ;
   u_int mc_transmit_ct ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_mac_fnc {
   struct smt_para para ;
   u_short nc_mib_index ;
   u_short nc_index ;
   u_int nc_counter ;
};

#line 365  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smp_p_manufacturer {
   struct smt_para para ;
   u_char mf_data[32U] ;
};

#line 376  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smp_p_user {
   struct smt_para para ;
   u_char us_data[32U] ;
};

#line 387  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_echo {
   struct smt_para para ;
   u_char ec_data[4454U] ;
};

#line 411  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_refused {
   struct smt_para para ;
   u_int ref_fc ;
   struct smt_header ref_header ;
};

#line 434  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_version {
   struct smt_para para ;
   u_short v_pad ;
   u_char v_n ;
   u_char v_index ;
   u_short v_version[1U] ;
   u_short v_pad2 ;
};

#line 548  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_p_fsc {
   struct smt_para para ;
   u_short fsc_pad0 ;
   u_short fsc_mac_index ;
   u_short fsc_pad1 ;
   u_short fsc_value ;
};

#line 720  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_nif {
   struct smt_header smt ;
   struct smt_p_una una ;
   struct smt_p_sde sde ;
   struct smt_p_state state ;
   struct smt_p_fsc fsc ;
};

#line 736  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_sif_config {
   struct smt_header smt ;
   struct smt_p_timestamp ts ;
   struct smt_p_sde sde ;
   struct smt_p_version version ;
   struct smt_p_state state ;
   struct smt_p_policy policy ;
   struct smt_p_latency latency ;
   struct smt_p_neighbor neighbor ;
   struct smt_p_setcount setcount ;
   struct smt_p_path path ;
};

#line 756  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_sif_operation {
   struct smt_header smt ;
   struct smt_p_timestamp ts ;
   struct smt_p_mac_status status ;
   struct smt_p_mac_counter mc ;
   struct smt_p_mac_fnc fnc ;
   struct smp_p_manufacturer man ;
   struct smp_p_user user ;
   struct smt_p_setcount setcount ;
   struct smt_p_lem lem[1U] ;
};

#line 773  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_ecf {
   struct smt_header smt ;
   struct smt_p_echo ec_echo ;
};

#line 783  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smt.h"
struct smt_rdf {
   struct smt_header smt ;
   struct smt_p_reason reason ;
   struct smt_p_version version ;
   struct smt_p_refused refused ;
};

#line 1568  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
struct smt_pdef {
   int ptype ;
   int plen ;
   char const *pswap ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/fddi.h"
struct fddi_mac {
   struct fddi_addr mac_dest ;
   struct fddi_addr mac_source ;
   u_char mac_info[4478U] ;
};

#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
struct ldv_list_element {
   void *data ;
   struct ldv_list_element *next ;
};

#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
typedef struct ldv_list_element *ldv_list_ptr;

#line 41  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
struct device_private {
   void *driver_data ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef short s16;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_work;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_worker {
   spinlock_t lock ;
   struct list_head work_list ;
   struct task_struct *task ;
   struct kthread_work *current_work ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_work {
   struct list_head node ;
   void (*func)(struct kthread_work *) ;
   struct kthread_worker *worker ;
};

#line 380  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct dma_chan;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_master;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_device {
   struct device dev ;
   struct spi_master *master ;
   u32 max_speed_hz ;
   u8 chip_select ;
   u8 bits_per_word ;
   u16 mode ;
   int irq ;
   void *controller_state ;
   void *controller_data ;
   char modalias[32U] ;
   int cs_gpio ;
};

#line 151 
struct spi_message;

#line 152 
struct spi_transfer;

#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_master {
   struct device dev ;
   struct list_head list ;
   s16 bus_num ;
   u16 num_chipselect ;
   u16 dma_alignment ;
   u16 mode_bits ;
   u32 bits_per_word_mask ;
   u32 min_speed_hz ;
   u32 max_speed_hz ;
   u16 flags ;
   spinlock_t bus_lock_spinlock ;
   struct mutex bus_lock_mutex ;
   bool bus_lock_flag ;
   int (*setup)(struct spi_device *) ;
   int (*transfer)(struct spi_device *, struct spi_message *) ;
   void (*cleanup)(struct spi_device *) ;
   bool (*can_dma)(struct spi_master *, struct spi_device *, struct spi_transfer *) ;
   bool queued ;
   struct kthread_worker kworker ;
   struct task_struct *kworker_task ;
   struct kthread_work pump_messages ;
   spinlock_t queue_lock ;
   struct list_head queue ;
   struct spi_message *cur_msg ;
   bool idling ;
   bool busy ;
   bool running ;
   bool rt ;
   bool auto_runtime_pm ;
   bool cur_msg_prepared ;
   bool cur_msg_mapped ;
   struct completion xfer_completion ;
   size_t max_dma_len ;
   int (*prepare_transfer_hardware)(struct spi_master *) ;
   int (*transfer_one_message)(struct spi_master *, struct spi_message *) ;
   int (*unprepare_transfer_hardware)(struct spi_master *) ;
   int (*prepare_message)(struct spi_master *, struct spi_message *) ;
   int (*unprepare_message)(struct spi_master *, struct spi_message *) ;
   void (*set_cs)(struct spi_device *, bool ) ;
   int (*transfer_one)(struct spi_master *, struct spi_device *, struct spi_transfer *) ;
   void (*handle_err)(struct spi_master *, struct spi_message *) ;
   int *cs_gpios ;
   struct dma_chan *dma_tx ;
   struct dma_chan *dma_rx ;
   void *dummy_rx ;
   void *dummy_tx ;
};

#line 506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_transfer {
   void const *tx_buf ;
   void *rx_buf ;
   unsigned int len ;
   dma_addr_t tx_dma ;
   dma_addr_t rx_dma ;
   struct sg_table tx_sg ;
   struct sg_table rx_sg ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cs_change : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) tx_nbits : 3 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) rx_nbits : 3 ;
   u8 bits_per_word ;
   u16 delay_usecs ;
   u32 speed_hz ;
   struct list_head transfer_list ;
};

#line 630  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_message {
   struct list_head transfers ;
   struct spi_device *spi ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_dma_mapped : 1 ;
   void (*complete)(void *) ;
   void *context ;
   unsigned int frame_length ;
   unsigned int actual_length ;
   int status ;
   struct list_head queue ;
   void *state ;
};

#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
typedef unsigned long pthread_t;

#line 22  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
union pthread_attr_t {
   char __size[56U] ;
   long __align ;
};

#line 29  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
typedef union pthread_attr_t pthread_attr_t;

#line 3835  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct ldv_struct_free_irq_3 {
   int arg0 ;
   int signal_pending ;
};

#line 17  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_interrupt_scenario_10 {
   enum irqreturn (*arg2)(int , void *) ;
   enum irqreturn (*arg1)(int , void *) ;
   void *arg3 ;
   int arg0 ;
   int signal_pending ;
};

#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_pci_scenario_11 {
   struct pci_driver *arg0 ;
   int signal_pending ;
};

#line 30  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_random_allocationless_scenario_9 {
   struct net_device *arg0 ;
   int signal_pending ;
};

#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
int printk(char const * , ...);


#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
void *memcpy(void *, void const *, size_t);


#line 484  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/cmtdef.h"
Mbuf *smt_build_frame(struct s_smc *smc, int class, int type, int length);


#line 486 
Mbuf *smt_get_mbuf(struct s_smc *smc);


#line 487 
void *sm_to_para(struct s_smc *smc, struct smt_header *sm, int para);


#line 527 
void smt_free_mbuf(struct s_smc *smc, Mbuf *mb);


#line 541 
u_long smt_get_tid(struct s_smc *smc);


#line 546 
int smt_check_para(struct s_smc *smc, struct smt_header *sm, u_short const *list);


#line 575 
void smt_send_frame(struct s_smc *smc, Mbuf *mb, int fc, int local);


#line 581 
void set_formac_tsync(struct s_smc *smc, long sync_bw);


#line 582 
void formac_reinit_tx(struct s_smc *smc);


#line 619 
int ess_raf_received_pack(struct s_smc *smc, Mbuf *mb, struct smt_header *sm, int fs);


#line 621 
void ess_timer_poll(struct s_smc *smc);


#line 622 
void ess_para_change(struct s_smc *smc);


#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/ess.c"
static u_short const plist_raf_alc_res[8U] = {(unsigned short)18U, (unsigned short)12811U, (unsigned short)12815U, (unsigned short)12816U, (unsigned short)25U, (unsigned short)26U, (unsigned short)29U, (unsigned short)0U};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/ess.c"
static u_short const plist_raf_chg_req[5U] = {(unsigned short)12811U, (unsigned short)12815U, (unsigned short)12816U, (unsigned short)26U, (unsigned short)0U};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/ess.c"
static struct fddi_addr const smt_sba_da = {.a = {(unsigned char)128U, (unsigned char)1U, (unsigned char)67U, (unsigned char)0U, (unsigned char)128U, (unsigned char)12U}};

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/ess.c"
static struct fddi_addr const null_addr = {.a = {(unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U}};

#line 83 
static void ess_send_response(struct s_smc *smc, struct smt_header *sm, int sba_cmd);


#line 85 
static void ess_config_fifo(struct s_smc *smc);


#line 86 
static void ess_send_alc_req(struct s_smc *smc);


#line 87 
static void ess_send_frame(struct s_smc *smc, Mbuf *mb);


#line 105 
static int process_bw_alloc(struct s_smc *smc, long payload, long overhead);


#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/ess.c"
int ess_raf_received_pack(struct s_smc *smc, Mbuf *mb, struct smt_header *sm, int fs)
{
  int __retres;
  void *p;
  struct smt_p_0016 *cmd;
  Mbuf *db;
  u_long msg_res_type;
  u_long payload;
  u_long overhead;
  int local;
  int i;
  
#line 131 
  local = (fs & 128) != 0;
  
#line 136 
  p = sm_to_para(smc,sm,21);
  
#line 136 
  if (p == (void *)0) {
    
#line 138 
    __retres = fs;
    
#line 138 
    goto return_label;
  }
  else ;
  
#line 140 
  msg_res_type = (unsigned long)((struct smt_p_0015 *)p)->res_type;
  
#line 145 
  cmd = (struct smt_p_0016 *)sm_to_para(smc,sm,22);
  
#line 145 
  if (cmd == (struct smt_p_0016 *)0) {
    
#line 150 
    __retres = fs;
    
#line 150 
    goto return_label;
  }
  else ;
  
#line 163 
  switch (cmd->sba_cmd) {
    int tmp_0;
    void *tmp_1;
    int tmp_3;
    void *tmp_4;
    int tmp_5;
    case (u_int)1: 
#line 168 
    ;
    
#line 172 
    if ((unsigned int)sm->smt_type == 2U) {
      
#line 177 
      if (local == 0 || smc->mib.fddiESSPayload != 0UL) {
        
#line 178 
        __retres = fs;
        
#line 178 
        goto return_label;
      }
      else ;
      
#line 180 
      p = sm_to_para(smc,sm,25);
      
#line 181 
      i = 0;
      
#line 181 
      goto ldv_46271;
      ldv_46270: 
#line 182 
      ;
      
#line 182 
      if ((unsigned int)((struct smt_p_0019 *)p)->alloc_addr.a[i] != 0U) {
        
#line 183 
        __retres = fs;
        
#line 183 
        goto return_label;
      }
      else ;
      
#line 181 
      i += 1;
      ldv_46271: 
#line 182 
      ;
      
#line 181 
      if (i <= 4) 
#line 183 
                  goto ldv_46270; else 
#line 186 
                                       goto ldv_46272;
      ldv_46272: 
#line 187 
      ;
      
#line 191 
      smc->ess.alloc_trans_id = (unsigned long)sm->smt_tid;
      
#line 193 
      p = sm_to_para(smc,sm,12815);
      
#line 194 
      ((struct smt_p_320f *)p)->mib_payload = (unsigned int)smc->mib.a[0].fddiPATHSbaPayload;
      
#line 196 
      p = sm_to_para(smc,sm,12816);
      
#line 197 
      ((struct smt_p_3210 *)p)->mib_overhead = (unsigned int)smc->mib.a[0].fddiPATHSbaOverhead;
      
#line 199 
      sm->smt_dest = smt_sba_da;
      
#line 201 
      if ((unsigned int)smc->ess.local_sba_active != 0U) {
        
#line 202 
        __retres = fs | 64;
        
#line 202 
        goto return_label;
      }
      else ;
      
#line 204 
      db = smt_get_mbuf(smc);
      
#line 204 
      if (db == (Mbuf *)0) {
        
#line 205 
        __retres = fs;
        
#line 205 
        goto return_label;
      }
      else ;
      
#line 207 
      db->m_len = mb->m_len;
      
#line 208 
      db->m_off = mb->m_off;
      
#line 209 
      memcpy((void *)(& db->m_data) + (int)db->m_off,(void const *)sm,(unsigned long)((int)db->m_len));
      
#line 214 
      smt_send_frame(smc,db,65,0);
      
#line 215 
      __retres = fs;
      
#line 215 
      goto return_label;
    }
    else ;
    
#line 222 
    tmp_0 = smt_check_para(smc,sm,(u_short const *)(& plist_raf_alc_res));
    
#line 222 
    if (tmp_0 != 0) {
      
#line 224 
      __retres = fs;
      
#line 224 
      goto return_label;
    }
    else ;
    
#line 237 
    tmp_1 = sm_to_para(smc,sm,12811);
    
#line 237 
    ;
    
#line 237 
    if ((unsigned int)((struct smt_p_320b *)tmp_1)->path_index != 1U) {
      
#line 245 
      __retres = fs;
      
#line 245 
      goto return_label;
    }
    else 
      
#line 238 
      if (msg_res_type != 1UL) {
        
#line 245 
        __retres = fs;
        
#line 245 
        goto return_label;
      }
      else {
        void *tmp_2;
        
#line 240 
        tmp_2 = sm_to_para(smc,sm,18);
        
#line 239 
        ;
        
#line 239 
        if (((struct smt_p_reason *)tmp_2)->rdf_reason != 3U) {
          
#line 245 
          __retres = fs;
          
#line 245 
          goto return_label;
        }
        else 
          
#line 242 
          if ((unsigned long)sm->smt_tid != smc->ess.alloc_trans_id) {
            
#line 245 
            __retres = fs;
            
#line 245 
            goto return_label;
          }
          else ;
      }
    
#line 251 
    p = sm_to_para(smc,sm,12815);
    
#line 252 
    if (p == (void *)0) {
      
#line 253 
      printk("\001");
      
#line 254 
      __retres = fs;
      
#line 254 
      goto return_label;
    }
    else ;
    
#line 256 
    payload = (unsigned long)((struct smt_p_320f *)p)->mib_payload;
    
#line 257 
    p = sm_to_para(smc,sm,12816);
    
#line 258 
    if (p == (void *)0) {
      
#line 259 
      printk("\001");
      
#line 260 
      __retres = fs;
      
#line 260 
      goto return_label;
    }
    else ;
    
#line 262 
    overhead = (unsigned long)((struct smt_p_3210 *)p)->mib_overhead;
    
#line 269 
    process_bw_alloc(smc,(long)payload,(long)overhead);
    
#line 271 
    __retres = fs;
    
#line 271 
    goto return_label;
    case (u_int)3: 
#line 277 
    ;
    
#line 281 
    if ((unsigned int)sm->smt_type != 2U) {
      
#line 283 
      __retres = fs;
      
#line 283 
      goto return_label;
    }
    else ;
    
#line 289 
    tmp_3 = smt_check_para(smc,sm,(u_short const *)(& plist_raf_chg_req));
    
#line 289 
    if (tmp_3 != 0) {
      
#line 291 
      __retres = fs;
      
#line 291 
      goto return_label;
    }
    else ;
    
#line 300 
    tmp_4 = sm_to_para(smc,sm,12811);
    
#line 300 
    ;
    
#line 300 
    if ((unsigned int)((struct smt_p_320b *)tmp_4)->path_index != 1U) {
      
#line 303 
      __retres = fs;
      
#line 303 
      goto return_label;
    }
    else 
      
#line 301 
      if (msg_res_type != 1UL) {
        
#line 303 
        __retres = fs;
        
#line 303 
        goto return_label;
      }
      else ;
    
#line 309 
    p = sm_to_para(smc,sm,12815);
    
#line 310 
    payload = (unsigned long)((struct smt_p_320f *)p)->mib_payload;
    
#line 311 
    p = sm_to_para(smc,sm,12816);
    
#line 312 
    overhead = (unsigned long)((struct smt_p_3210 *)p)->mib_overhead;
    
#line 321 
    tmp_5 = process_bw_alloc(smc,(long)payload,(long)overhead);
    
#line 321 
    if (tmp_5 == 0) {
      
#line 322 
      __retres = fs;
      
#line 322 
      goto return_label;
    }
    else ;
    
#line 327 
    ess_send_response(smc,sm,3);
    
#line 329 
    __retres = fs;
    
#line 329 
    goto return_label;
    case (u_int)2: 
#line 335 
    ;
    
#line 339 
    if ((unsigned int)sm->smt_type != 2U) {
      
#line 341 
      __retres = fs;
      
#line 341 
      goto return_label;
    }
    else ;
    
#line 350 
    if (msg_res_type != 1UL) {
      
#line 352 
      __retres = fs;
      
#line 352 
      goto return_label;
    }
    else ;
    
#line 358 
    ess_send_response(smc,sm,2);
    
#line 360 
    __retres = fs;
    
#line 360 
    goto return_label;
    default: 
#line 363 
    ;
    
#line 368 
    goto ldv_46276;
  }
  ldv_46276: 
#line 371 
  ;
  
#line 371 
  __retres = fs;
  return_label: 
#line 371 
                return __retres;
}


#line 378  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/ess.c"
static int process_bw_alloc(struct s_smc *smc, long payload, long overhead)
{
  int __retres;
  
#line 429 
  if (payload > 1562L || overhead > 5000L) {
    
#line 431 
    __retres = 0;
    
#line 431 
    goto return_label;
  }
  else ;
  
#line 438 
  if (smc->mib.fddiESSPayload != 0UL && (smc->mib.fddiESSPayload != (unsigned long)payload || smc->mib.fddiESSOverhead != (unsigned long)overhead)) {
    
#line 441 
    smc->ess.raf_act_timer_poll = (char)1;
    
#line 442 
    smc->ess.timer_count = (char)0;
  }
  else ;
  
#line 448 
  if (payload != 0L) {
    
#line 450 
    smc->ess.sync_bw_available = (unsigned char)1U;
    
#line 452 
    smc->ess.sync_bw = ((long)smc->mib.m[0].fddiMACT_Neg * payload) / -1562L + overhead;
  }
  else {
    
#line 458 
    smc->ess.sync_bw_available = (unsigned char)0U;
    
#line 459 
    smc->ess.sync_bw = 0L;
    
#line 460 
    overhead = 0L;
  }
  
#line 463 
  smc->mib.a[0].fddiPATHSbaPayload = (unsigned long)payload;
  
#line 464 
  smc->mib.a[0].fddiPATHSbaOverhead = (unsigned long)overhead;
  
#line 469 
  ess_config_fifo(smc);
  
#line 470 
  set_formac_tsync(smc,smc->ess.sync_bw);
  
#line 471 
  __retres = 1;
  return_label: 
#line 471 
                return __retres;
}


#line 474  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/ess.c"
static void ess_send_response(struct s_smc *smc, struct smt_header *sm, int sba_cmd)
{
  struct smt_sba_chg *chg;
  Mbuf *mb;
  void *p;
  
#line 484 
  if (sba_cmd == 3) {
    
#line 485 
    mb = smt_build_frame(smc,5,3,92);
    
#line 485 
    if (mb == (Mbuf *)0) 
#line 487 
                         goto return_label; else ;
  }
  else {
    
#line 490 
    mb = smt_build_frame(smc,5,3,84);
    
#line 490 
    if (mb == (Mbuf *)0) 
#line 492 
                         goto return_label; else ;
  }
  
#line 495 
  chg = (struct smt_sba_chg *)(& mb->m_data) + (int)mb->m_off;
  
#line 496 
  chg->smt.smt_tid = sm->smt_tid;
  
#line 497 
  chg->smt.smt_dest = sm->smt_source;
  
#line 500 
  chg->s_type.para.p_type = (unsigned short)21U;
  
#line 501 
  chg->s_type.para.p_len = (unsigned short)4U;
  
#line 502 
  chg->s_type.res_type = 1U;
  
#line 505 
  chg->cmd.para.p_type = (unsigned short)22U;
  
#line 506 
  chg->cmd.para.p_len = (unsigned short)4U;
  
#line 507 
  chg->cmd.sba_cmd = (unsigned int)sba_cmd;
  
#line 510 
  chg->path.para.p_type = (unsigned short)12811U;
  
#line 511 
  chg->path.para.p_len = (unsigned short)8U;
  
#line 512 
  chg->path.mib_index = 16777216U;
  
#line 513 
  chg->path.path_pad = (unsigned short)0U;
  
#line 514 
  chg->path.path_index = (unsigned short)1U;
  
#line 517 
  chg->payload.para.p_type = (unsigned short)12815U;
  
#line 518 
  chg->payload.para.p_len = (unsigned short)8U;
  
#line 519 
  chg->payload.mib_index = 16777216U;
  
#line 520 
  chg->payload.mib_payload = (unsigned int)smc->mib.a[0].fddiPATHSbaPayload;
  
#line 523 
  chg->overhead.para.p_type = (unsigned short)12816U;
  
#line 524 
  chg->overhead.para.p_len = (unsigned short)8U;
  
#line 525 
  chg->overhead.mib_index = 16777216U;
  
#line 526 
  chg->overhead.mib_overhead = (unsigned int)smc->mib.a[0].fddiPATHSbaOverhead;
  
#line 528 
  if (sba_cmd == 3) {
    
#line 530 
    chg->cat.para.p_type = (unsigned short)26U;
    
#line 531 
    chg->cat.para.p_len = (unsigned short)4U;
    
#line 532 
    p = sm_to_para(smc,sm,26);
    
#line 533 
    chg->cat.category = ((struct smt_p_001a *)p)->category;
  }
  else ;
  
#line 536 
  ess_send_frame(smc,mb);
  return_label: 
#line 537 
                return;
}


#line 539  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/ess.c"
void ess_timer_poll(struct s_smc *smc)
{
  
#line 541 
  if ((int)smc->ess.raf_act_timer_poll == 0) 
#line 542 
                                             goto return_label; else ;
  
#line 546 
  smc->ess.timer_count = (char)((int)smc->ess.timer_count + 1);
  
#line 547 
  if ((int)smc->ess.timer_count == 10) {
    
#line 548 
    smc->ess.timer_count = (char)0;
    
#line 549 
    ess_send_alc_req(smc);
  }
  else ;
  return_label: 
#line 551 
                return;
}


#line 553  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/ess.c"
static void ess_send_alc_req(struct s_smc *smc)
{
  struct smt_sba_alc_req *req;
  Mbuf *mb;
  u_long tmp;
  
#line 563 
  if (smc->mib.fddiESSPayload == 0UL) 
#line 564 
                                      smc->mib.fddiESSOverhead = 0UL;
  else 
    
#line 567 
    if (smc->mib.fddiESSOverhead == 0UL) 
#line 568 
                                         smc->mib.fddiESSOverhead = 50UL; else ;
  
#line 571 
  if (smc->mib.fddiESSOverhead == smc->mib.a[0].fddiPATHSbaOverhead && smc->mib.fddiESSPayload == smc->mib.a[0].fddiPATHSbaPayload) {
    
#line 575 
    smc->ess.raf_act_timer_poll = (char)0;
    
#line 576 
    smc->ess.timer_count = (char)7;
    
#line 577 
    goto return_label;
  }
  else ;
  
#line 583 
  mb = smt_build_frame(smc,5,2,136);
  
#line 583 
  if (mb == (Mbuf *)0) 
#line 585 
                       goto return_label; else ;
  
#line 586 
  req = (struct smt_sba_alc_req *)(& mb->m_data) + (int)mb->m_off;
  
#line 587 
  tmp = smt_get_tid(smc);
  
#line 587 
  smc->ess.alloc_trans_id = tmp;
  
#line 587 
  req->smt.smt_tid = (unsigned int)tmp;
  
#line 588 
  req->smt.smt_dest = smt_sba_da;
  
#line 591 
  req->s_type.para.p_type = (unsigned short)21U;
  
#line 592 
  req->s_type.para.p_len = (unsigned short)4U;
  
#line 593 
  req->s_type.res_type = 1U;
  
#line 596 
  req->cmd.para.p_type = (unsigned short)22U;
  
#line 597 
  req->cmd.para.p_len = (unsigned short)4U;
  
#line 598 
  req->cmd.sba_cmd = 1U;
  
#line 606 
  req->path.para.p_type = (unsigned short)12811U;
  
#line 607 
  req->path.para.p_len = (unsigned short)8U;
  
#line 608 
  req->path.mib_index = 16777216U;
  
#line 609 
  req->path.path_pad = (unsigned short)0U;
  
#line 610 
  req->path.path_index = (unsigned short)1U;
  
#line 613 
  req->pl_req.para.p_type = (unsigned short)23U;
  
#line 614 
  req->pl_req.para.p_len = (unsigned short)4U;
  
#line 615 
  req->pl_req.sba_pl_req = (int)(smc->mib.fddiESSPayload - smc->mib.a[0].fddiPATHSbaPayload);
  
#line 619 
  req->ov_req.para.p_type = (unsigned short)24U;
  
#line 620 
  req->ov_req.para.p_len = (unsigned short)4U;
  
#line 621 
  req->ov_req.sba_ov_req = (int)(smc->mib.fddiESSOverhead - smc->mib.a[0].fddiPATHSbaOverhead);
  
#line 625 
  req->payload.para.p_type = (unsigned short)12815U;
  
#line 626 
  req->payload.para.p_len = (unsigned short)8U;
  
#line 627 
  req->payload.mib_index = 16777216U;
  
#line 628 
  req->payload.mib_payload = (unsigned int)smc->mib.a[0].fddiPATHSbaPayload;
  
#line 631 
  req->overhead.para.p_type = (unsigned short)12816U;
  
#line 632 
  req->overhead.para.p_len = (unsigned short)8U;
  
#line 633 
  req->overhead.mib_index = 16777216U;
  
#line 634 
  req->overhead.mib_overhead = (unsigned int)smc->mib.a[0].fddiPATHSbaOverhead;
  
#line 637 
  req->a_addr.para.p_type = (unsigned short)25U;
  
#line 638 
  req->a_addr.para.p_len = (unsigned short)8U;
  
#line 639 
  req->a_addr.sba_pad = (unsigned short)0U;
  
#line 640 
  req->a_addr.alloc_addr = null_addr;
  
#line 643 
  req->cat.para.p_type = (unsigned short)26U;
  
#line 644 
  req->cat.para.p_len = (unsigned short)4U;
  
#line 645 
  req->cat.category = (unsigned int)smc->mib.fddiESSCategory;
  
#line 648 
  req->tneg.para.p_type = (unsigned short)27U;
  
#line 649 
  req->tneg.para.p_len = (unsigned short)4U;
  
#line 650 
  req->tneg.max_t_neg = (unsigned int)smc->mib.fddiESSMaxTNeg;
  
#line 653 
  req->segm.para.p_type = (unsigned short)28U;
  
#line 654 
  req->segm.para.p_len = (unsigned short)4U;
  
#line 655 
  req->segm.min_seg_siz = (unsigned int)smc->mib.fddiESSMinSegmentSize;
  
#line 658 
  ess_send_frame(smc,mb);
  return_label: 
#line 659 
                return;
}


#line 661  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/ess.c"
static void ess_send_frame(struct s_smc *smc, Mbuf *mb)
{
  
#line 666 
  if ((unsigned int)smc->ess.local_sba_active != 0U) 
    
#line 671 
    if (smc->ess.sba_reply_pend == (Mbuf *)0) 
#line 672 
                                              smc->ess.sba_reply_pend = mb; else 
                                                                    
#line 675 
                                                                    smt_free_mbuf(smc,mb);
  else 
#line 683 
       smt_send_frame(smc,mb,65,0);
  
#line 684 
  return;
}


#line 687  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/ess.c"
void ess_para_change(struct s_smc *smc)
{
  
#line 689 
  process_bw_alloc(smc,(long)smc->mib.a[0].fddiPATHSbaPayload,(long)smc->mib.a[0].fddiPATHSbaOverhead);
  
#line 691 
  return;
}


#line 693  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/ess.c"
static void ess_config_fifo(struct s_smc *smc)
{
  
#line 698 
  if (smc->mib.a[0].fddiPATHSbaPayload != 0UL) {
    
#line 699 
    if (((int)smc->hw.fp.fifo.fifo_config_mode & 2) != 0 && ((int)smc->hw.fp.fifo.fifo_config_mode & 1) == (int)smc->mib.fddiESSSynchTxMode) 
      
#line 702 
      goto return_label; else ;
  }
  else 
    
#line 706 
    if (((int)smc->hw.fp.fifo.fifo_config_mode & 2) == 0) 
#line 707 
                                                          goto return_label; else ;
  
#line 714 
  formac_reinit_tx(smc);
  return_label: 
#line 715 
                return;
}


#line 494  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/cmtdef.h"
void queue_event(struct s_smc *smc, int class, int event);


#line 495 
void ecm(struct s_smc *smc, int event);


#line 496 
void ecm_init(struct s_smc *smc);


#line 503 
void smt_timer_start(struct s_smc *smc, struct smt_timer *timer, u_long time, u_long token);


#line 505 
void smt_timer_stop(struct s_smc *smc, struct smt_timer *timer);


#line 511 
void sm_pm_ls_latch(struct s_smc *smc, int phy, int on_off);


#line 512 
void sm_ma_control(struct s_smc *smc, int mode);


#line 528 
void sm_pm_bypass_req(struct s_smc *smc, int mode);


#line 559 
void ecm_state_change(struct s_smc *smc, int e_state);


#line 560 
int sm_pm_bypass_present(struct s_smc *smc);


#line 563 
int sm_pm_get_ls(struct s_smc *smc, int phy);


#line 564 
int pcm_get_s_port(struct s_smc *smc);


#line 566 
int cfm_get_mac_input(struct s_smc *smc);


#line 567 
int cfm_get_mac_output(struct s_smc *smc);


#line 588 
void ring_status_indication(struct s_smc *smc, u_long status);


#line 97  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/ecm.c"
static void ecm_fsm(struct s_smc *smc, int cmd);


#line 98 
static void start_ecm_timer(struct s_smc *smc, u_long value, int event);


#line 99 
static void stop_ecm_timer(struct s_smc *smc);


#line 100 
static void prop_actions(struct s_smc *smc);


#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/ecm.c"
void ecm_init(struct s_smc *smc)
{
  
#line 108 
  smc->e.path_test = (unsigned char)2U;
  
#line 109 
  smc->e.trace_prop = 0UL;
  
#line 110 
  smc->e.sb_flag = (unsigned char)0U;
  
#line 111 
  smc->mib.fddiSMTECMState = (unsigned short)16U;
  
#line 112 
  smc->e.ecm_line_state = (unsigned char)0U;
  
#line 113 
  return;
}


#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/ecm.c"
void ecm(struct s_smc *smc, int event)
{
  int state;
  ldv_46246: 
#line 127 
  ;
  
#line 133 
  state = (int)smc->mib.fddiSMTECMState;
  
#line 134 
  ecm_fsm(smc,event);
  
#line 135 
  event = 0;
  
#line 136 
  if ((int)smc->mib.fddiSMTECMState != state) 
#line 138 
                                              goto ldv_46246; else 
#line 141 
                                                                   goto ldv_46247;
  ldv_46247: 
#line 142 
  ;
  
#line 137 
  ecm_state_change(smc,(int)smc->mib.fddiSMTECMState);
  
#line 138 
  return;
}


#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/ecm.c"
static void ecm_fsm(struct s_smc *smc, int cmd)
{
  int ls_a;
  int ls_b;
  int p;
  int tmp;
  
#line 150 
  tmp = sm_pm_bypass_present(smc);
  
#line 150 
  smc->mib.fddiSMTBypassPresent = (unsigned char)tmp;
  
#line 151 
  if (cmd == 1) 
#line 152 
                smc->mib.fddiSMTRemoteDisconnectFlag = (unsigned char)0U; else ;
  
#line 156 
  int tmp_2 = (cmd == 2 && (unsigned int)smc->mib.fddiSMTRemoteDisconnectFlag == 1U) != 0;
  
#line 163 
  if (cmd == 1) 
#line 164 
                smc->e.DisconnectFlag = (unsigned char)0U;
  else 
    
#line 166 
    if (cmd == 2) 
#line 167 
                  smc->e.DisconnectFlag = (unsigned char)1U; else ;
  
#line 170 
  switch ((int)smc->mib.fddiSMTECMState) {
    case 16: 
#line 171 
    ;
    
#line 175 
    smc->e.path_test = (unsigned char)2U;
    
#line 176 
    smc->e.ecm_line_state = (unsigned char)0U;
    
#line 177 
    stop_ecm_timer(smc);
    
#line 178 
    smc->mib.fddiSMTECMState = (unsigned short)((unsigned int)smc->mib.fddiSMTECMState & 65519U);
    
#line 179 
    goto ldv_46256;
    case 0: 
#line 180 
    ;
    
#line 182 
    if ((cmd == 1 && (unsigned int)smc->mib.fddiSMTBypassPresent == 0U) && (unsigned int)smc->e.path_test == 2U) {
      
#line 184 
      smc->mib.fddiSMTECMState = (unsigned short)17U;
      
#line 185 
      goto ldv_46256;
    }
    else 
      
#line 188 
      if (((cmd == 1 && (unsigned int)smc->e.path_test == 2U) && (unsigned int)smc->mib.fddiSMTBypassPresent != 0U) && (unsigned int)smc->s.sas == 0U) {
        
#line 191 
        smc->mib.fddiSMTECMState = (unsigned short)21U;
        
#line 192 
        goto ldv_46256;
      }
      else ;
    
#line 194 
    goto ldv_46256;
    case 17: 
#line 195 
    ;
    
#line 196 
    stop_ecm_timer(smc);
    
#line 197 
    smc->e.trace_prop = 0UL;
    
#line 198 
    sm_ma_control(smc,4);
    
#line 199 
    p = 0;
    
#line 199 
    goto ldv_46260;
    ldv_46259: 
#line 200 
    ;
    
#line 200 
    if ((unsigned int)smc->mib.p[p].fddiPORTHardwarePresent != 0U) 
#line 201 
                                                                   queue_event(smc,p + 5,1); else ;
    
#line 199 
    p += 1;
    ldv_46260: 
#line 200 
    ;
    
#line 199 
    if (p <= 1) 
#line 201 
                goto ldv_46259; else 
#line 204 
                                     goto ldv_46261;
    ldv_46261: 
#line 205 
    ;
    
#line 202 
    smc->mib.fddiSMTECMState = (unsigned short)((unsigned int)smc->mib.fddiSMTECMState & 65519U);
    
#line 203 
    goto ldv_46256;
    case 1: 
#line 204 
    ;
    
#line 206 
    if (cmd == 3) {
      
#line 207 
      prop_actions(smc);
      
#line 208 
      smc->mib.fddiSMTECMState = (unsigned short)18U;
      
#line 209 
      goto ldv_46256;
    }
    else 
      
#line 212 
      if (cmd == 2) {
        
#line 213 
        smc->mib.fddiSMTECMState = (unsigned short)19U;
        
#line 214 
        goto ldv_46256;
      }
      else ;
    
#line 216 
    goto ldv_46256;
    case 18: 
#line 217 
    ;
    
#line 218 
    start_ecm_timer(smc,smc->mib.fddiSMTTrace_MaxExpiration / 12UL,6);
    
#line 220 
    smc->mib.fddiSMTECMState = (unsigned short)((unsigned int)smc->mib.fddiSMTECMState & 65519U);
    
#line 221 
    goto ldv_46256;
    case 2: 
#line 222 
    ;
    
#line 224 
    if (cmd == 3) {
      
#line 225 
      prop_actions(smc);
      
#line 226 
      smc->mib.fddiSMTECMState = (unsigned short)18U;
      
#line 227 
      goto ldv_46256;
    }
    else 
      
#line 230 
      if (cmd == 2) {
        
#line 231 
        smc->e.path_test = (unsigned char)5U;
        
#line 232 
        smc->mib.fddiSMTECMState = (unsigned short)19U;
        
#line 233 
        goto ldv_46256;
      }
      else 
        
#line 236 
        if ((unsigned int)smc->e.path_test == 4U) {
          
#line 237 
          smc->mib.fddiSMTECMState = (unsigned short)19U;
          
#line 238 
          goto ldv_46256;
        }
        else 
          
#line 241 
          if (cmd == 6) {
            
#line 247 
            smc->e.path_test = (unsigned char)4U;
            
#line 248 
            smc->mib.fddiSMTECMState = (unsigned short)19U;
            
#line 249 
            goto ldv_46256;
          }
          else ;
    
#line 251 
    goto ldv_46256;
    case 19: 
#line 252 
    ;
    
#line 253 
    start_ecm_timer(smc,smc->s.ecm_td_min,5);
    
#line 254 
    p = 0;
    
#line 254 
    goto ldv_46267;
    ldv_46266: 
#line 255 
    ;
    
#line 255 
    queue_event(smc,p + 5,2);
    
#line 254 
    p += 1;
    ldv_46267: 
#line 255 
    ;
    
#line 254 
    if (p <= 1) 
#line 256 
                goto ldv_46266; else 
#line 259 
                                     goto ldv_46268;
    ldv_46268: 
#line 260 
    ;
    
#line 256 
    smc->mib.fddiSMTECMState = (unsigned short)((unsigned int)smc->mib.fddiSMTECMState & 65519U);
    
#line 257 
    goto ldv_46256;
    case 3: 
#line 258 
    ;
    
#line 260 
    if ((cmd == 5 && (unsigned int)smc->mib.fddiSMTBypassPresent == 0U) && (unsigned int)smc->e.path_test != 4U) {
      
#line 262 
      smc->mib.fddiSMTECMState = (unsigned short)16U;
      
#line 263 
      goto ldv_46256;
    }
    else 
      
#line 266 
      if (cmd == 5 && (unsigned int)smc->e.path_test == 4U) {
        
#line 268 
        smc->mib.fddiSMTECMState = (unsigned short)20U;
        
#line 269 
        goto ldv_46256;
      }
      else 
        
#line 272 
        if (cmd == 1 && (unsigned int)smc->e.path_test == 2U) {
          
#line 273 
          smc->mib.fddiSMTECMState = (unsigned short)17U;
          
#line 274 
          goto ldv_46256;
        }
        else 
          
#line 277 
          if (cmd == 2 && (unsigned int)smc->e.path_test == 4U) 
#line 279 
                                                                smc->e.path_test = (unsigned char)5U;
          else 
            
#line 285 
            if ((cmd == 5 && (unsigned int)smc->mib.fddiSMTBypassPresent != 0U) && (unsigned int)smc->e.path_test != 4U) {
              
#line 288 
              smc->mib.fddiSMTECMState = (unsigned short)23U;
              
#line 289 
              goto ldv_46256;
            }
            else ;
    
#line 291 
    goto ldv_46256;
    case 20: 
#line 292 
    ;
    
#line 293 
    stop_ecm_timer(smc);
    
#line 294 
    smc->e.path_test = (unsigned char)1U;
    
#line 295 
    start_ecm_timer(smc,smc->s.ecm_test_done,9);
    
#line 297 
    smc->mib.fddiSMTECMState = (unsigned short)((unsigned int)smc->mib.fddiSMTECMState & 65519U);
    
#line 298 
    goto ldv_46256;
    case 4: 
#line 299 
    ;
    
#line 301 
    if (cmd == 9) 
#line 302 
                  smc->e.path_test = (unsigned char)2U; else ;
    
#line 304 
    if ((unsigned int)smc->e.path_test == 3U) {
      u_short tmp_0;
      
#line 305 
      tmp_0 = (unsigned short)((unsigned int)smc->srf.ring_status | 2048U);
      
#line 305 
      smc->srf.ring_status = tmp_0;
      
#line 305 
      ;
      
#line 305 
      ring_status_indication(smc,(unsigned long)tmp_0);
    }
    else ;
    
#line 308 
    if ((unsigned int)smc->e.path_test == 3U && (unsigned int)smc->mib.fddiSMTBypassPresent == 0U) {
      
#line 310 
      smc->mib.fddiSMTECMState = (unsigned short)16U;
      
#line 311 
      goto ldv_46256;
    }
    else 
      
#line 314 
      if (cmd == 2 && (unsigned int)smc->mib.fddiSMTBypassPresent == 0U) {
        
#line 316 
        smc->mib.fddiSMTECMState = (unsigned short)16U;
        
#line 317 
        goto ldv_46256;
      }
      else 
        
#line 320 
        if ((unsigned int)smc->e.path_test == 2U) {
          
#line 321 
          smc->mib.fddiSMTECMState = (unsigned short)17U;
          
#line 322 
          goto ldv_46256;
        }
        else 
          
#line 325 
          if ((unsigned int)smc->e.path_test == 3U && (unsigned int)smc->mib.fddiSMTBypassPresent != 0U) {
            
#line 327 
            smc->mib.fddiSMTECMState = (unsigned short)23U;
            
#line 328 
            goto ldv_46256;
          }
          else 
            
#line 331 
            if (cmd == 2 && (unsigned int)smc->mib.fddiSMTBypassPresent != 0U) {
              
#line 333 
              smc->mib.fddiSMTECMState = (unsigned short)23U;
              
#line 334 
              goto ldv_46256;
            }
            else ;
    
#line 336 
    goto ldv_46256;
    case 21: 
#line 337 
    ;
    
#line 338 
    sm_pm_bypass_req(smc,1);
    
#line 339 
    start_ecm_timer(smc,smc->s.ecm_in_max,8);
    
#line 340 
    smc->mib.fddiSMTECMState = (unsigned short)((unsigned int)smc->mib.fddiSMTECMState & 65519U);
    
#line 341 
    goto ldv_46256;
    case 5: 
#line 342 
    ;
    
#line 344 
    if (cmd == 8) {
      
#line 345 
      smc->mib.fddiSMTECMState = (unsigned short)22U;
      
#line 346 
      goto ldv_46256;
    }
    else 
      
#line 349 
      if (cmd == 2) {
        
#line 350 
        smc->mib.fddiSMTECMState = (unsigned short)23U;
        
#line 351 
        goto ldv_46256;
      }
      else ;
    
#line 353 
    goto ldv_46256;
    case 22: 
#line 354 
    ;
    
#line 359 
    start_ecm_timer(smc,smc->s.ecm_check_poll,0);
    
#line 360 
    smc->e.ecm_line_state = (unsigned char)1U;
    
#line 361 
    sm_pm_ls_latch(smc,0,1);
    
#line 362 
    sm_pm_ls_latch(smc,1,1);
    
#line 363 
    smc->mib.fddiSMTECMState = (unsigned short)((unsigned int)smc->mib.fddiSMTECMState & 65519U);
    
#line 364 
    goto ldv_46256;
    case 6: 
#line 365 
    ;
    
#line 366 
    ls_a = sm_pm_get_ls(smc,0);
    
#line 367 
    ls_b = sm_pm_get_ls(smc,1);
    
#line 370 
    if ((ls_a == 12 || ls_a == 15) && (ls_b == 12 || ls_b == 15)) {
      
#line 372 
      smc->e.sb_flag = (unsigned char)0U;
      
#line 373 
      smc->e.ecm_line_state = (unsigned char)0U;
      
#line 374 
      smc->mib.fddiSMTECMState = (unsigned short)17U;
      
#line 375 
      goto ldv_46256;
    }
    else 
      
#line 378 
      if ((unsigned int)smc->e.sb_flag == 0U && ((ls_a == 13 && ls_b == 12) || (ls_a == 12 && ls_b == 13))) 
        
#line 381 
        smc->e.sb_flag = (unsigned char)1U;
      else 
        
#line 388 
        if (cmd == 2) {
          
#line 389 
          smc->e.ecm_line_state = (unsigned char)0U;
          
#line 390 
          smc->mib.fddiSMTECMState = (unsigned short)23U;
          
#line 391 
          goto ldv_46256;
        }
        else 
#line 397 
             start_ecm_timer(smc,smc->s.ecm_check_poll,0);
    
#line 399 
    goto ldv_46256;
    case 23: 
#line 400 
    ;
    
#line 401 
    sm_pm_bypass_req(smc,0);
    
#line 402 
    start_ecm_timer(smc,smc->s.ecm_i_max,7);
    
#line 403 
    smc->mib.fddiSMTECMState = (unsigned short)((unsigned int)smc->mib.fddiSMTECMState & 65519U);
    
#line 404 
    goto ldv_46256;
    case 7: 
#line 405 
    ;
    
#line 407 
    if (cmd == 7) {
      
#line 408 
      smc->mib.fddiSMTECMState = (unsigned short)16U;
      
#line 409 
      goto ldv_46256;
    }
    else 
      
#line 412 
      if (cmd == 1 && (unsigned int)smc->e.path_test == 2U) {
        
#line 413 
        smc->mib.fddiSMTECMState = (unsigned short)21U;
        
#line 414 
        goto ldv_46256;
      }
      else ;
    
#line 416 
    goto ldv_46256;
    default: 
#line 417 
    ;
    
#line 418 
    printk("\001",107,(char *)"ECM : invalid state");
    
#line 419 
    goto ldv_46256;
  }
  ldv_46256: 
#line 421 
  ;
  
#line 422 
  return;
}


#line 427  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/ecm.c"
static void prop_actions(struct s_smc *smc)
{
  u_short tmp;
  
#line 429 
  int port_in = 0;
  
#line 430 
  int port_out = 0;
  
#line 432 
  tmp = (unsigned short)((unsigned int)smc->srf.ring_status | 4U);
  
#line 432 
  smc->srf.ring_status = tmp;
  
#line 432 
  ;
  
#line 432 
  ring_status_indication(smc,(unsigned long)tmp);
  
#line 433 
  switch ((int)smc->s.sas) {
    case 1: 
#line 434 
    ;
    
#line 435 
    port_out = pcm_get_s_port(smc);
    
#line 435 
    port_in = port_out;
    
#line 436 
    goto ldv_46285;
    case 0: 
#line 437 
    ;
    
#line 438 
    port_in = cfm_get_mac_input(smc);
    
#line 439 
    port_out = cfm_get_mac_output(smc);
    
#line 440 
    goto ldv_46285;
    case 2: 
#line 441 
    ;
    
#line 442 
    printk("\001",108,(char *)"prop_actions : NAC in DAS CFM");
    
#line 443 
    goto return_label;
  }
  ldv_46285: 
#line 446 
  ;
  
#line 449 
  if ((smc->e.trace_prop & 4UL) != 0UL) 
#line 452 
                                        queue_event(smc,port_in + 5,8);
  else 
    
#line 454 
    if ((smc->e.trace_prop & 1UL) != 0UL && port_out != 0) 
#line 458 
                                                           queue_event(smc,6,8);
    else 
      
#line 460 
      if ((smc->e.trace_prop & 2UL) != 0UL && port_out != 1) 
#line 464 
                                                             queue_event(smc,5,8); else 
                                                                    
#line 469 
                                                                    smc->e.path_test = (unsigned char)4U;
  
#line 471 
  smc->e.trace_prop = 0UL;
  return_label: 
#line 472 
                return;
}


#line 523  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/ecm.c"
static void start_ecm_timer(struct s_smc *smc, u_long value, int event)
{
  
#line 525 
  smt_timer_start(smc,& smc->e.ecm_timer,value,(unsigned long)(event | 65536));
  
#line 526 
  return;
}


#line 532  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/ecm.c"
static void stop_ecm_timer(struct s_smc *smc)
{
  
#line 534 
  if ((unsigned int)smc->e.ecm_timer.tm_active != 0U) 
#line 535 
                                                      smt_timer_stop(smc,& smc->e.ecm_timer); else ;
  
#line 536 
  return;
}


#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
void *memset(void *, int, size_t);


#line 518  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/cmtdef.h"
void smt_add_para(struct s_smc *smc, struct s_pcon *pcon, u_short para, int index, int local);


#line 540 
u_long smt_get_time(void);


#line 576 
void smt_set_timestamp(struct s_smc *smc, u_char *p);


#line 626 
void smt_init_evc(struct s_smc *smc);


#line 627 
void smt_srf_event(struct s_smc *smc, int code, int index, int cond);


#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/srf.c"
static void clear_all_rep(struct s_smc *smc);


#line 42 
static void clear_reported(struct s_smc *smc);


#line 43 
static void smt_send_srf(struct s_smc *smc);


#line 44 
static struct s_srf_evc *smt_get_evc(struct s_smc *smc, int code, int index);


#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/srf.c"
static struct evc_init const evc_inits[10U] = {{.code = (unsigned char)5U, .index = (unsigned char)0U, .n = (unsigned char)1U, .para = (unsigned short)4168U}, {.code = (unsigned char)8U, .index = (unsigned char)1U, .n = (unsigned char)1U, .para = (unsigned short)8332U}, {.code = (unsigned char)7U, .index = (unsigned char)1U, .n = (unsigned char)1U, .para = (unsigned short)8333U}, {.code = (unsigned char)9U, .index = (unsigned char)1U, .n = (unsigned char)1U, .para = (unsigned short)8334U}, {.code = (unsigned char)2U, .index = (unsigned char)1U, .n = (unsigned char)1U, .para = (unsigned short)8335U}, {.code = (unsigned char)1U, .index = (unsigned char)1U, .n = (unsigned char)1U, .para = (unsigned short)8336U}, {.code = (unsigned char)11U, .index = (unsigned char)1U, .n = (unsigned char)2U, .para = (unsigned short)16464U}, {.code = (unsigned char)10U, .index = (unsigned char)1U, .n = (unsigned char)2U, .para = (unsigned short)16466U}, {.code = (unsigned char)4U, .index = (unsigned char)1U, .n = (unsigned char)2U, .para = (unsigned short)16465U}, {.code = (unsigned char)3U, .index = (unsigned char)1U, .n = (unsigned char)2U, .para = (unsigned short)16467U}};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/srf.c"
void smt_init_evc(struct s_smc *smc)
{
  struct s_srf_evc *evc;
  struct evc_init const *init;
  unsigned int i;
  int index;
  int offset;
  
#line 80 
  u_char fail_safe = (unsigned char)0U;
  
#line 82 
  memset((void *)(& smc->evcs),0,336UL);
  
#line 84 
  evc = (struct s_srf_evc *)(& smc->evcs);
  
#line 85 
  init = (struct evc_init const *)(& evc_inits);
  
#line 87 
  i = 0U;
  
#line 87 
  goto ldv_46259;
  ldv_46258: 
#line 88 
  ;
  
#line 88 
  index = 0;
  
#line 88 
  goto ldv_46256;
  ldv_46255: 
#line 89 
  ;
  
#line 89 
  evc->evc_code = init->code;
  
#line 90 
  evc->evc_para = init->para;
  
#line 91 
  evc->evc_index = (unsigned char)((int)init->index + (int)((unsigned char)index));
  
#line 93 
  evc->evc_multiple = & fail_safe;
  
#line 94 
  evc->evc_cond_state = & fail_safe;
  
#line 96 
  evc += 1;
  
#line 88 
  index += 1;
  ldv_46256: 
#line 89 
  ;
  
#line 88 
  if ((int)init->n > index) 
#line 90 
                            goto ldv_46255; else 
#line 93 
                                                 goto ldv_46257;
  ldv_46257: 
#line 94 
  ;
  
#line 98 
  init += 1;
  
#line 87 
  i += 1U;
  ldv_46259: 
#line 88 
  ;
  
#line 87 
  if (i <= 9U) 
#line 89 
               goto ldv_46258; else 
#line 92 
                                    goto ldv_46260;
  ldv_46260: 
#line 93 
  ;
  
#line 101 
  if ((unsigned int)(((long)evc - (long)(& smc->evcs)) / 24L) > 14U) 
    
#line 102 
    printk("\001",127,(char *)"sizeof evcs"); else ;
  
#line 108 
  smc->evcs[0].evc_cond_state = & smc->mib.fddiSMTPeerWrapFlag;
  
#line 109 
  smc->evcs[1].evc_cond_state = & smc->mib.m[0].fddiMACDuplicateAddressCond;
  
#line 111 
  smc->evcs[2].evc_cond_state = & smc->mib.m[0].fddiMACFrameErrorFlag;
  
#line 113 
  smc->evcs[3].evc_cond_state = & smc->mib.m[0].fddiMACNotCopiedFlag;
  
#line 119 
  smc->evcs[4].evc_multiple = & smc->mib.m[0].fddiMACMultiple_N;
  
#line 120 
  smc->evcs[5].evc_multiple = & smc->mib.m[0].fddiMACMultiple_P;
  
#line 122 
  offset = 6;
  
#line 123 
  i = 0U;
  
#line 123 
  goto ldv_46265;
  ldv_46264: 
#line 124 
  ;
  
#line 127 
  smc->evcs[offset].evc_cond_state = & smc->mib.p[i].fddiPORTLerFlag;
  
#line 129 
  smc->evcs[offset + 2].evc_cond_state = & smc->mib.p[i].fddiPORTEB_Condition;
  
#line 135 
  smc->evcs[offset + 4].evc_multiple = & smc->mib.p[i].fddiPORTMultiple_U;
  
#line 137 
  smc->evcs[offset + 6].evc_multiple = & smc->mib.p[i].fddiPORTMultiple_P;
  
#line 139 
  offset += 1;
  
#line 123 
  i += 1U;
  ldv_46265: 
#line 124 
  ;
  
#line 123 
  if (i <= 1U) 
#line 125 
               goto ldv_46264; else 
#line 128 
                                    goto ldv_46266;
  ldv_46266: 
#line 129 
  ;
  
#line 157 
  smc->srf.TSR = smt_get_time();
  
#line 158 
  smc->srf.sr_state = (unsigned char)0U;
  
#line 159 
  return;
}


#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/srf.c"
static struct s_srf_evc *smt_get_evc(struct s_smc *smc, int code, int index)
{
  struct s_srf_evc *__retres;
  unsigned int i;
  struct s_srf_evc *evc;
  
#line 166 
  i = 0U;
  
#line 166 
  evc = (struct s_srf_evc *)(& smc->evcs);
  
#line 166 
  goto ldv_46278;
  ldv_46277: 
#line 167 
  ;
  
#line 167 
  if ((int)evc->evc_code == code && (int)evc->evc_index == index) {
    
#line 168 
    __retres = evc;
    
#line 168 
    goto return_label;
  }
  else ;
  
#line 166 
  i += 1U;
  
#line 166 
  evc += 1;
  ldv_46278: 
#line 167 
  ;
  
#line 166 
  if (i <= 13U) 
#line 168 
                goto ldv_46277; else 
#line 171 
                                     goto ldv_46279;
  ldv_46279: 
#line 172 
  ;
  
#line 170 
  __retres = (struct s_srf_evc *)0;
  return_label: 
#line 170 
                return __retres;
}


#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/srf.c"
void smt_srf_event(struct s_smc *smc, int code, int index, int cond)
{
  struct s_srf_evc *evc;
  int tsr;
  u_long tmp_0;
  
#line 190 
  int cond_asserted = 0;
  
#line 191 
  int cond_deasserted = 0;
  
#line 192 
  int event_occurred = 0;
  
#line 194 
  int T_Limit = 500;
  
#line 196 
  if (code == 8 && cond != 0) {
    u_short tmp;
    
#line 197 
    tmp = (unsigned short)((unsigned int)smc->srf.ring_status | 64U);
    
#line 197 
    smc->srf.ring_status = tmp;
    
#line 197 
    ;
    
#line 197 
    ring_status_indication(smc,(unsigned long)tmp);
  }
  else ;
  
#line 200 
  if (code != 0) {
    
#line 203 
    evc = smt_get_evc(smc,code,index);
    
#line 203 
    if (evc == (struct s_srf_evc *)0) 
#line 205 
                                      goto return_label; else ;
    
#line 210 
    if (code > 4) {
      
#line 211 
      if ((int)*(evc->evc_cond_state) == cond) 
#line 212 
                                               goto return_label; else ;
    }
    else ;
    
#line 218 
    smt_set_timestamp(smc,(u_char *)(& smc->mib.fddiSMTTransitionTimeStamp));
    
#line 219 
    if (code > 4) 
      
#line 221 
      if (cond != 0) {
        
#line 222 
        *(evc->evc_cond_state) = (unsigned char)1U;
        
#line 223 
        evc->evc_rep_required = (unsigned char)1U;
        
#line 224 
        smc->srf.any_report = (unsigned char)1U;
        
#line 225 
        cond_asserted = 1;
      }
      else {
        
#line 228 
        *(evc->evc_cond_state) = (unsigned char)0U;
        
#line 229 
        cond_deasserted = 1;
      }
    else {
      
#line 233 
      if ((unsigned int)evc->evc_rep_required != 0U) 
#line 234 
                                                     *(evc->evc_multiple) = (unsigned char)1U;
      else {
        
#line 237 
        evc->evc_rep_required = (unsigned char)1U;
        
#line 238 
        *(evc->evc_multiple) = (unsigned char)0U;
      }
      
#line 240 
      smc->srf.any_report = (unsigned char)1U;
      
#line 241 
      event_occurred = 1;
    }
  }
  else ;
  
#line 247 
  tmp_0 = smt_get_time();
  
#line 247 
  tsr = (int)(tmp_0 - smc->srf.TSR);
  
#line 249 
  switch ((int)smc->srf.sr_state) {
    case 0: 
#line 250 
    ;
    
#line 252 
    if (cond_asserted != 0 && tsr < T_Limit) {
      
#line 253 
      smc->srf.SRThreshold = 500UL;
      
#line 254 
      smc->srf.sr_state = (unsigned char)1U;
      
#line 255 
      goto ldv_46293;
    }
    else ;
    
#line 258 
    if (cond_deasserted != 0 && tsr < T_Limit) {
      
#line 259 
      smc->srf.sr_state = (unsigned char)1U;
      
#line 260 
      goto ldv_46293;
    }
    else ;
    
#line 263 
    if (event_occurred != 0 && tsr < T_Limit) {
      
#line 264 
      smc->srf.sr_state = (unsigned char)1U;
      
#line 265 
      goto ldv_46293;
    }
    else ;
    
#line 268 
    if (cond_asserted != 0 && tsr >= T_Limit) {
      
#line 269 
      smc->srf.SRThreshold = 500UL;
      
#line 270 
      smc->srf.TSR = smt_get_time();
      
#line 271 
      smt_send_srf(smc);
      
#line 272 
      goto ldv_46293;
    }
    else ;
    
#line 275 
    if (cond_deasserted != 0 && tsr >= T_Limit) {
      
#line 276 
      smc->srf.TSR = smt_get_time();
      
#line 277 
      smt_send_srf(smc);
      
#line 278 
      goto ldv_46293;
    }
    else ;
    
#line 281 
    if (event_occurred != 0 && tsr >= T_Limit) {
      
#line 282 
      smc->srf.TSR = smt_get_time();
      
#line 283 
      smt_send_srf(smc);
      
#line 284 
      goto ldv_46293;
    }
    else ;
    
#line 287 
    if ((unsigned int)smc->srf.any_report != 0U && (unsigned long)tsr >= smc->srf.SRThreshold) {
      
#line 289 
      smc->srf.SRThreshold *= 2UL;
      
#line 290 
      if (smc->srf.SRThreshold > 8000UL) 
#line 291 
                                         smc->srf.SRThreshold = 8000UL; else ;
      
#line 292 
      smc->srf.TSR = smt_get_time();
      
#line 293 
      smt_send_srf(smc);
      
#line 294 
      goto ldv_46293;
    }
    else ;
    
#line 297 
    if ((unsigned int)smc->mib.fddiSMTStatRptPolicy == 0U) {
      
#line 298 
      smc->srf.sr_state = (unsigned char)2U;
      
#line 299 
      goto ldv_46293;
    }
    else ;
    
#line 301 
    goto ldv_46293;
    case 1: 
#line 302 
    ;
    
#line 304 
    if (tsr >= T_Limit) {
      
#line 305 
      smc->srf.sr_state = (unsigned char)0U;
      
#line 306 
      smc->srf.TSR = smt_get_time();
      
#line 307 
      smt_send_srf(smc);
      
#line 308 
      goto ldv_46293;
    }
    else ;
    
#line 311 
    if (cond_asserted != 0) 
#line 312 
                            smc->srf.SRThreshold = 500UL; else ;
    
#line 318 
    if ((unsigned int)smc->mib.fddiSMTStatRptPolicy == 0U) {
      
#line 319 
      smc->srf.sr_state = (unsigned char)2U;
      
#line 320 
      goto ldv_46293;
    }
    else ;
    
#line 322 
    goto ldv_46293;
    case 2: 
#line 323 
    ;
    
#line 324 
    if ((unsigned int)smc->mib.fddiSMTStatRptPolicy != 0U) {
      
#line 325 
      smc->srf.sr_state = (unsigned char)0U;
      
#line 326 
      smc->srf.TSR = smt_get_time();
      
#line 327 
      smc->srf.SRThreshold = 500UL;
      
#line 328 
      clear_all_rep(smc);
      
#line 329 
      goto ldv_46293;
    }
    else ;
    
#line 331 
    goto ldv_46293;
  }
  ldv_46293: 
#line 333 
  ;
  return_label: 
#line 334 
                return;
}


#line 335  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/srf.c"
static void clear_all_rep(struct s_smc *smc)
{
  struct s_srf_evc *evc;
  unsigned int i;
  
#line 340 
  i = 0U;
  
#line 340 
  evc = (struct s_srf_evc *)(& smc->evcs);
  
#line 340 
  goto ldv_46305;
  ldv_46304: 
#line 341 
  ;
  
#line 341 
  evc->evc_rep_required = (unsigned char)0U;
  
#line 342 
  if ((unsigned int)evc->evc_code > 4U) 
#line 343 
                                        *(evc->evc_cond_state) = (unsigned char)0U; else ;
  
#line 340 
  i += 1U;
  
#line 340 
  evc += 1;
  ldv_46305: 
#line 341 
  ;
  
#line 340 
  if (i <= 13U) 
#line 342 
                goto ldv_46304; else 
#line 345 
                                     goto ldv_46306;
  ldv_46306: 
#line 346 
  ;
  
#line 345 
  smc->srf.any_report = (unsigned char)0U;
  
#line 346 
  return;
}


#line 348  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/srf.c"
static void clear_reported(struct s_smc *smc)
{
  struct s_srf_evc *evc;
  unsigned int i;
  
#line 353 
  smc->srf.any_report = (unsigned char)0U;
  
#line 354 
  i = 0U;
  
#line 354 
  evc = (struct s_srf_evc *)(& smc->evcs);
  
#line 354 
  goto ldv_46316;
  ldv_46315: 
#line 355 
  ;
  
#line 355 
  if ((unsigned int)evc->evc_code > 4U) 
    
#line 356 
    if ((unsigned int)*(evc->evc_cond_state) == 0U) 
#line 357 
                                                    evc->evc_rep_required = (unsigned char)0U; else 
                                                                    
#line 359 
                                                                    smc->srf.any_report = (unsigned char)1U;
  else {
    
#line 362 
    evc->evc_rep_required = (unsigned char)0U;
    
#line 363 
    *(evc->evc_multiple) = (unsigned char)0U;
  }
  
#line 354 
  i += 1U;
  
#line 354 
  evc += 1;
  ldv_46316: 
#line 355 
  ;
  
#line 354 
  if (i <= 13U) 
#line 356 
                goto ldv_46315; else 
#line 359 
                                     goto ldv_46317;
  ldv_46317: 
#line 360 
  ;
  
#line 361 
  return;
}


#line 371  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/srf.c"
static void smt_send_srf(struct s_smc *smc)
{
  struct smt_header *smt;
  struct s_srf_evc *evc;
  struct s_pcon pcon;
  Mbuf *mb;
  unsigned int i;
  u_short tmp;
  
#line 380 
  struct fddi_addr const SMT_SRF_DA = {.a = {(unsigned char)128U, (unsigned char)1U, (unsigned char)67U, (unsigned char)0U, (unsigned char)128U, (unsigned char)8U}};
  
#line 387 
  if ((unsigned int)smc->r.sm_ma_avail == 0U) 
#line 388 
                                              goto return_label; else ;
  
#line 389 
  mb = smt_build_frame(smc,7,1,0);
  
#line 389 
  if (mb == (Mbuf *)0) 
#line 390 
                       goto return_label; else ;
  
#line 392 
  tmp = (unsigned short)((unsigned int)smc->srf.ring_status | 8192U);
  
#line 392 
  smc->srf.ring_status = tmp;
  
#line 392 
  ;
  
#line 392 
  ring_status_indication(smc,(unsigned long)tmp);
  
#line 394 
  smt = (struct smt_header *)(& mb->m_data) + (int)mb->m_off;
  
#line 395 
  smt->smt_dest = SMT_SRF_DA;
  
#line 400 
  pcon.pc_len = 4332;
  
#line 401 
  pcon.pc_err = 0;
  
#line 402 
  pcon.pc_badset = 0;
  
#line 403 
  pcon.pc_p = (void *)(smt + 1U);
  
#line 405 
  smt_add_para(smc,& pcon,(unsigned short)4147,0,0);
  
#line 406 
  smt_add_para(smc,& pcon,(unsigned short)4148,0,0);
  
#line 408 
  i = 0U;
  
#line 408 
  evc = (struct s_srf_evc *)(& smc->evcs);
  
#line 408 
  goto ldv_46331;
  ldv_46330: 
#line 409 
  ;
  
#line 409 
  if ((unsigned int)evc->evc_rep_required != 0U) 
#line 410 
                                                 smt_add_para(smc,& pcon,(unsigned short)((int)evc->evc_para),(int)evc->evc_index,0); else ;
  
#line 408 
  i += 1U;
  
#line 408 
  evc += 1;
  ldv_46331: 
#line 409 
  ;
  
#line 408 
  if (i <= 13U) 
#line 410 
                goto ldv_46330; else 
#line 413 
                                     goto ldv_46332;
  ldv_46332: 
#line 414 
  ;
  
#line 414 
  smt->smt_len = (unsigned short)(4332U - (unsigned int)((unsigned short)pcon.pc_len));
  
#line 415 
  mb->m_len = (unsigned int)smt->smt_len + 32U;
  
#line 423 
  smt_send_frame(smc,mb,65,0);
  
#line 424 
  clear_reported(smc);
  return_label: 
#line 425 
                return;
}


#line 497  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/cmtdef.h"
void rmt(struct s_smc *smc, int event);


#line 498 
void rmt_init(struct s_smc *smc);


#line 499 
void pcm(struct s_smc *smc, int const np, int event);


#line 500 
void pcm_init(struct s_smc *smc);


#line 501 
void cfm(struct s_smc *smc, int event);


#line 502 
void cfm_init(struct s_smc *smc);


#line 515 
void smt_agent_init(struct s_smc *smc);


#line 516 
void smt_timer_init(struct s_smc *smc);


#line 521 
void ev_init(struct s_smc *smc);


#line 543 
void smt_fixup_mib(struct s_smc *smc);


#line 545 
void smt_agent_task(struct s_smc *smc);


#line 593 
int smt_set_mac_opvalues(struct s_smc *smc);


#line 477  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smc.h"
int init_smt(struct s_smc *smc, u_char *mac_addr);


#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smtinit.c"
void init_fddi_driver(struct s_smc *smc, u_char *mac_addr);


#line 39 
u_char const oem_id[13U];


#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smtinit.c"
static void set_oem_spec_val(struct s_smc *smc)
{
  struct fddi_mib *mib;
  
#line 55 
  mib = & smc->mib;
  
#line 60 
  if ((unsigned int)oem_id[0] == 73U) 
#line 61 
                                      mib->fddiSMTConnectionPolicy = (unsigned short)32768U; else ;
  
#line 62 
  return;
}


#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smtinit.c"
int init_smt(struct s_smc *smc, u_char *mac_addr)
{
  int __retres;
  int p;
  
#line 91 
  p = 0;
  
#line 91 
  goto ldv_46241;
  ldv_46240: 
#line 92 
  ;
  
#line 92 
  smc->y[p].mib = & smc->mib.p[p];
  
#line 91 
  p += 1;
  ldv_46241: 
#line 92 
  ;
  
#line 91 
  if (p <= 1) 
#line 93 
              goto ldv_46240; else 
#line 96 
                                   goto ldv_46242;
  ldv_46242: 
#line 97 
  ;
  
#line 95 
  set_oem_spec_val(smc);
  
#line 96 
  smt_set_mac_opvalues(smc);
  
#line 97 
  init_fddi_driver(smc,mac_addr);
  
#line 98 
  smt_fixup_mib(smc);
  
#line 100 
  ev_init(smc);
  
#line 102 
  smt_init_evc(smc);
  
#line 104 
  smt_timer_init(smc);
  
#line 105 
  smt_agent_init(smc);
  
#line 107 
  pcm_init(smc);
  
#line 108 
  ecm_init(smc);
  
#line 109 
  cfm_init(smc);
  
#line 110 
  rmt_init(smc);
  
#line 112 
  p = 0;
  
#line 112 
  goto ldv_46244;
  ldv_46243: 
#line 113 
  ;
  
#line 113 
  pcm(smc,p,0);
  
#line 112 
  p += 1;
  ldv_46244: 
#line 113 
  ;
  
#line 112 
  if (p <= 1) 
#line 114 
              goto ldv_46243; else 
#line 117 
                                   goto ldv_46245;
  ldv_46245: 
#line 118 
  ;
  
#line 115 
  ecm(smc,0);
  
#line 116 
  cfm(smc,0);
  
#line 117 
  rmt(smc,0);
  
#line 119 
  smt_agent_task(smc);
  
#line 123 
  __retres = 0;
  
#line 123 
  return __retres;
}


#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
char *strcpy(char *, char const *);


#line 544  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/cmtdef.h"
void smt_reset_defaults(struct s_smc *smc, int level);


#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smtdef.c"
static void smt_init_mib(struct s_smc *smc, int level);


#line 77 
static int set_min_max(int maxflag, u_long mib, u_long limit, u_long *oper);


#line 82  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smtdef.c"
void smt_reset_defaults(struct s_smc *smc, int level)
{
  struct smt_config *smt;
  int i;
  u_long smt_boot_time;
  
#line 89 
  smt_init_mib(smc,level);
  
#line 91 
  smc->os.smc_version = 1UL;
  
#line 92 
  smt_boot_time = smt_get_time();
  
#line 93 
  i = 0;
  
#line 93 
  goto ldv_46246;
  ldv_46245: 
#line 94 
  ;
  
#line 94 
  smc->sm.last_tok_time[i] = smt_boot_time;
  
#line 93 
  i += 1;
  ldv_46246: 
#line 94 
  ;
  
#line 93 
  if (i <= 0) 
#line 95 
              goto ldv_46245; else 
#line 98 
                                   goto ldv_46247;
  ldv_46247: 
#line 99 
  ;
  
#line 95 
  smt = & smc->s;
  
#line 96 
  smt->attach_s = (unsigned char)0U;
  
#line 97 
  smt->build_ring_map = (unsigned char)1U;
  
#line 98 
  smt->sas = (unsigned char)0U;
  
#line 99 
  smt->numphys = (unsigned char)2U;
  
#line 100 
  smt->pcm_tb_min = 5000UL;
  
#line 101 
  smt->pcm_tb_max = 50000UL;
  
#line 102 
  smt->pcm_c_min = 1600UL;
  
#line 103 
  smt->pcm_t_out = 105000UL;
  
#line 104 
  smt->pcm_tl_min = 30UL;
  
#line 105 
  smt->pcm_lc_short = 55000UL;
  
#line 106 
  smt->pcm_lc_medium = 520000UL;
  
#line 107 
  smt->pcm_lc_long = 5050000UL;
  
#line 108 
  smt->pcm_lc_extended = 50050000UL;
  
#line 109 
  smt->pcm_t_next_9 = 210000UL;
  
#line 110 
  smt->pcm_ns_max = 1310UL;
  
#line 111 
  smt->ecm_i_max = 25000UL;
  
#line 112 
  smt->ecm_in_max = 40000UL;
  
#line 113 
  smt->ecm_td_min = 5000UL;
  
#line 114 
  smt->ecm_test_done = 1000000UL;
  
#line 115 
  smt->ecm_check_poll = 1000000UL;
  
#line 116 
  smt->rmt_t_non_op = 1000000UL;
  
#line 117 
  smt->rmt_t_stuck = 8000000UL;
  
#line 118 
  smt->rmt_t_direct = 370000UL;
  
#line 119 
  smt->rmt_t_jam = 370000UL;
  
#line 120 
  smt->rmt_t_announce = 2500000UL;
  
#line 121 
  smt->rmt_t_poll = 50000UL;
  
#line 122 
  smt->rmt_dup_mac_behavior = 0UL;
  
#line 123 
  smt->mac_d_max = 1617UL;
  
#line 125 
  smt->lct_short = 1UL;
  
#line 126 
  smt->lct_medium = 3UL;
  
#line 127 
  smt->lct_long = 5UL;
  
#line 128 
  smt->lct_extended = 50UL;
  
#line 132 
  if (level == 0) {
    
#line 133 
    smc->ess.sync_bw_available = (unsigned char)0U;
    
#line 134 
    smc->mib.fddiESSPayload = 0UL;
    
#line 135 
    smc->mib.fddiESSOverhead = 0UL;
    
#line 136 
    smc->mib.fddiESSMaxTNeg = 18446744073709239116UL;
    
#line 137 
    smc->mib.fddiESSMinSegmentSize = 1UL;
    
#line 138 
    smc->mib.fddiESSCategory = 1UL;
    
#line 139 
    smc->mib.fddiESSSynchTxMode = (short)0;
    
#line 140 
    smc->ess.raf_act_timer_poll = (char)0;
    
#line 141 
    smc->ess.timer_count = (char)7;
  }
  else ;
  
#line 143 
  smc->ess.local_sba_active = (unsigned char)0U;
  
#line 144 
  smc->ess.sba_reply_pend = (Mbuf *)0;
  
#line 151 
  if (level == 0) 
#line 152 
                  smc->hw.pci_fix_value = 0UL; else ;
  
#line 153 
  return;
}


#line 160  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smtdef.c"
static char const man_data[32U] = {(char)'x', (char)'x', (char)'x', (char)'S', (char)'K', (char)'-', (char)'N', (char)'E', (char)'T', (char)' ', (char)'F', (char)'D', (char)'D', (char)'I', (char)' ', (char)'S', (char)'M', (char)'T', (char)' ', (char)'7', (char)'.', (char)'3', (char)' ', (char)'-', (char)' ', (char)'V', (char)'2', (char)'.', (char)'8', (char)'.', (char)'8', (char)'\000'};

#line 164  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smtdef.c"
static void smt_init_mib(struct s_smc *smc, int level)
{
  struct fddi_mib *mib;
  struct fddi_mib_p *pm;
  int port;
  int path;
  
#line 171 
  mib = & smc->mib;
  
#line 172 
  if (level == 0) 
#line 177 
                  memset((void *)smc + 5008U,0,3080UL);
  else {
    
#line 183 
    mib->fddiSMTRemoteDisconnectFlag = (unsigned char)0U;
    
#line 184 
    mib->fddiSMTPeerWrapFlag = (unsigned char)0U;
  }
  
#line 187 
  mib->fddiSMTOpVersionId = (unsigned short)2U;
  
#line 188 
  mib->fddiSMTHiVersionId = (unsigned short)2U;
  
#line 189 
  mib->fddiSMTLoVersionId = (unsigned short)2U;
  
#line 190 
  memcpy((void *)(& mib->fddiSMTManufacturerData),(void const *)(& man_data),32UL);
  
#line 191 
  if (level == 0) 
#line 192 
                  strcpy((char *)(& mib->fddiSMTUserData),"SK-NET FDDI V2.0 Userdata"); else ;
  
#line 194 
  mib->fddiSMTMIBVersionId = (unsigned short)1U;
  
#line 195 
  mib->fddiSMTMac_Ct = (unsigned char)1U;
  
#line 196 
  mib->fddiSMTConnectionPolicy = (unsigned short)32801U;
  
#line 202 
  mib->fddiSMTAvailablePaths = (unsigned char)3U;
  
#line 204 
  mib->fddiSMTConfigCapabilities = (unsigned short)0U;
  
#line 205 
  mib->fddiSMTTT_Notify = (unsigned short)10U;
  
#line 206 
  mib->fddiSMTStatRptPolicy = (unsigned char)1U;
  
#line 207 
  mib->fddiSMTTrace_MaxExpiration = 87500000UL;
  
#line 208 
  mib->fddiSMTMACIndexes = (unsigned short)1U;
  
#line 209 
  mib->fddiSMTStationStatus = (unsigned short)1U;
  
#line 211 
  mib->m[0].fddiMACIndex = (unsigned short)1U;
  
#line 212 
  mib->m[0].fddiMACFrameStatusFunctions = (unsigned short)0U;
  
#line 213 
  mib->m[0].fddiMACRequestedPaths = (unsigned short)7U;
  
#line 217 
  mib->m[0].fddiMACAvailablePaths = (unsigned char)1U;
  
#line 218 
  mib->m[0].fddiMACCurrentPath = (unsigned short)3U;
  
#line 219 
  mib->m[0].fddiMACT_MaxCapabilitiy = 18446744073707489116UL;
  
#line 220 
  mib->m[0].fddiMACTVXCapabilitiy = 18446744073709486616UL;
  
#line 221 
  if (level == 0) {
    
#line 222 
    mib->m[0].fddiMACTvxValue = 18446744073709517866UL;
    
#line 223 
    mib->m[0].fddiMACTvxValueMIB = 18446744073709517866UL;
    
#line 224 
    mib->m[0].fddiMACT_Req = 18446744073707489116UL;
    
#line 225 
    mib->m[0].fddiMACT_ReqMIB = 18446744073707489116UL;
    
#line 226 
    mib->m[0].fddiMACT_Max = 18446744073707489116UL;
    
#line 227 
    mib->m[0].fddiMACT_MaxMIB = 18446744073707489116UL;
    
#line 228 
    mib->m[0].fddiMACT_Min = 18446744073709501616UL;
  }
  else ;
  
#line 230 
  mib->m[0].fddiMACHardwarePresent = (unsigned char)1U;
  
#line 231 
  mib->m[0].fddiMACMA_UnitdataEnable = (unsigned char)1U;
  
#line 232 
  mib->m[0].fddiMACFrameErrorThreshold = (unsigned short)1U;
  
#line 233 
  mib->m[0].fddiMACNotCopiedThreshold = (unsigned short)1U;
  
#line 237 
  path = 0;
  
#line 237 
  goto ldv_46258;
  ldv_46257: 
#line 238 
  ;
  
#line 238 
  mib->a[path].fddiPATHIndex = (unsigned short)((unsigned int)((unsigned short)path) + 1U);
  
#line 239 
  if (level == 0) {
    
#line 240 
    mib->a[path].fddiPATHTVXLowerBound = 18446744073709517866UL;
    
#line 242 
    mib->a[path].fddiPATHT_MaxLowerBound = 18446744073707489116UL;
    
#line 244 
    mib->a[path].fddiPATHMaxT_Req = 18446744073707489116UL;
  }
  else ;
  
#line 237 
  path += 1;
  ldv_46258: 
#line 238 
  ;
  
#line 237 
  if (path <= 1) 
#line 239 
                 goto ldv_46257; else 
#line 242 
                                      goto ldv_46259;
  ldv_46259: 
#line 243 
  ;
  
#line 253 
  pm = (struct fddi_mib_p *)(& mib->p);
  
#line 254 
  port = 0;
  
#line 254 
  goto ldv_46261;
  ldv_46260: 
#line 255 
  ;
  
#line 260 
  smc->y[port].mib = (struct fddi_mib_p *)0;
  
#line 261 
  mib->fddiSMTPORTIndexes[port] = (unsigned short)((unsigned int)((unsigned short)port) + 1U);
  
#line 263 
  pm->fddiPORTIndex = (unsigned short)((unsigned int)((unsigned short)port) + 1U);
  
#line 264 
  pm->fddiPORTHardwarePresent = (unsigned char)1U;
  
#line 265 
  if (level == 0) {
    
#line 266 
    pm->fddiPORTLer_Alarm = (unsigned char)8U;
    
#line 267 
    pm->fddiPORTLer_Cutoff = (unsigned char)7U;
  }
  else ;
  
#line 273 
  pm->fddiPORTRequestedPaths[1] = (unsigned char)0U;
  
#line 274 
  pm->fddiPORTRequestedPaths[2] = (unsigned char)0U;
  
#line 275 
  pm->fddiPORTRequestedPaths[3] = (unsigned char)0U;
  
#line 276 
  pm->fddiPORTAvailablePaths = (unsigned char)1U;
  
#line 277 
  pm->fddiPORTPMDClass = (unsigned short)0U;
  
#line 278 
  pm += 1;
  
#line 254 
  port += 1;
  ldv_46261: 
#line 255 
  ;
  
#line 254 
  if (port <= 1) 
#line 256 
                 goto ldv_46260; else 
#line 259 
                                      goto ldv_46262;
  ldv_46262: 
#line 260 
  ;
  
#line 281 
  smt_set_mac_opvalues(smc);
  
#line 282 
  return;
}


#line 284  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smtdef.c"
int smt_set_mac_opvalues(struct s_smc *smc)
{
  int st;
  int st2;
  int tmp;
  
#line 289 
  st = set_min_max(1,smc->mib.m[0].fddiMACTvxValueMIB,smc->mib.a[0].fddiPATHTVXLowerBound,& smc->mib.m[0].fddiMACTvxValue);
  
#line 292 
  tmp = set_min_max(0,smc->mib.m[0].fddiMACT_MaxMIB,smc->mib.a[0].fddiPATHT_MaxLowerBound,& smc->mib.m[0].fddiMACT_Max);
  
#line 294 
  st = tmp | st;
  
#line 295 
  st2 = set_min_max(0,smc->mib.m[0].fddiMACT_ReqMIB,smc->mib.a[0].fddiPATHMaxT_Req,& smc->mib.m[0].fddiMACT_Req);
  
#line 297 
  st = st2 | st;
  
#line 298 
  if (st2 != 0) ; else ;
  
#line 306 
  return st;
}


#line 309  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smtdef.c"
void smt_fixup_mib(struct s_smc *smc)
{
  
#line 325 
  switch ((int)smc->s.sas) {
    case 1: 
#line 326 
    ;
    
#line 327 
    smc->mib.fddiSMTNonMaster_Ct = (unsigned char)1U;
    
#line 328 
    goto ldv_46272;
    case 0: 
#line 329 
    ;
    
#line 330 
    smc->mib.fddiSMTNonMaster_Ct = (unsigned char)2U;
    
#line 331 
    goto ldv_46272;
  }
  ldv_46272: 
#line 333 
  ;
  
#line 333 
  smc->mib.fddiSMTMaster_Ct = (unsigned char)0U;
  
#line 334 
  return;
}


#line 345  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smtdef.c"
static int set_min_max(int maxflag, u_long mib, u_long limit, u_long *oper)
{
  int __retres;
  u_long old;
  
#line 348 
  old = *oper;
  
#line 349 
  if ((limit > mib) != maxflag) 
#line 350 
                                *oper = limit; else 
#line 352 
                                                    *oper = mib;
  
#line 353 
  __retres = *oper != old;
  
#line 353 
  return __retres;
}


#line 514  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/cmtdef.h"
void config_mux(struct s_smc *smc, int mux);


#line 530 
void cfm_state_change(struct s_smc *smc, int c_state);


#line 568 
int cem_build_path(struct s_smc *smc, char *to, int path_index);


#line 472  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smc.h"
void all_selection_criteria(struct s_smc *smc);


#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/cfm.c"
static unsigned char const cf_to_ptype[13U] = {(unsigned char)4U, (unsigned char)4U, (unsigned char)4U, (unsigned char)4U, (unsigned char)4U, (unsigned char)4U, (unsigned char)1U, (unsigned char)1U, (unsigned char)2U, (unsigned char)0U, (unsigned char)1U, (unsigned char)2U, (unsigned char)1U};

#line 99 
static void cfm_fsm(struct s_smc *smc, int cmd);


#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/cfm.c"
void cfm_init(struct s_smc *smc)
{
  
#line 107 
  smc->mib.fddiSMTCF_State = (unsigned short)16U;
  
#line 108 
  smc->r.rm_join = (unsigned char)0U;
  
#line 109 
  smc->r.rm_loop = (unsigned char)0U;
  
#line 110 
  smc->y[0].scrub = (unsigned char)0U;
  
#line 111 
  smc->y[1].scrub = (unsigned char)0U;
  
#line 112 
  smc->y[0].cem_pst = 0;
  
#line 113 
  smc->y[1].cem_pst = 0;
  
#line 114 
  return;
}


#line 120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/cfm.c"
static void selection_criteria(struct s_smc *smc, struct s_phy *phy)
{
  
#line 123 
  switch ((int)(phy->mib)->fddiPORTMy_Type) {
    case 0: 
#line 124 
    ;
    
#line 125 
    if (((unsigned int)smc->y[0].pc_mode == 2U || (unsigned int)smc->y[1].pc_mode == 2U) && (unsigned int)smc->y[1].cf_join != 0U) 
      
#line 126 
      phy->wc_flag = (unsigned char)1U; else 
#line 128 
                                             phy->wc_flag = (unsigned char)0U;
    
#line 131 
    goto ldv_46239;
    case 1: 
#line 132 
    ;
    
#line 134 
    phy->wc_flag = (unsigned char)0U;
    
#line 135 
    goto ldv_46239;
    case 2: 
#line 136 
    ;
    
#line 137 
    phy->wc_flag = (unsigned char)0U;
    
#line 138 
    goto ldv_46239;
    case 3: 
#line 139 
    ;
    
#line 140 
    phy->wc_flag = (unsigned char)0U;
    
#line 141 
    goto ldv_46239;
  }
  ldv_46239: 
#line 144 
  ;
  
#line 145 
  return;
}


#line 146  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/cfm.c"
void all_selection_criteria(struct s_smc *smc)
{
  struct s_phy *phy;
  int p;
  
#line 151 
  p = 0;
  
#line 151 
  phy = (struct s_phy *)(& smc->y);
  
#line 151 
  goto ldv_46249;
  ldv_46248: 
#line 152 
  ;
  
#line 153 
  selection_criteria(smc,phy);
  
#line 151 
  p += 1;
  
#line 151 
  phy += 1;
  ldv_46249: 
#line 152 
  ;
  
#line 151 
  if (p <= 1) 
#line 153 
              goto ldv_46248; else 
#line 156 
                                   goto ldv_46250;
  ldv_46250: 
#line 157 
  ;
  
#line 158 
  return;
}


#line 157  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/cfm.c"
static void cem_priv_state(struct s_smc *smc, int event)
{
  int np;
  int i;
  
#line 164 
  if ((unsigned int)smc->s.sas != 0U) 
#line 165 
                                      goto return_label; else ;
  
#line 167 
  np = event + -3;
  
#line 169 
  if ((unsigned int)np > 1U) 
#line 170 
                             goto return_label; else ;
  
#line 173 
  if ((unsigned int)smc->y[np].cf_join != 0U) 
#line 174 
                                              smc->y[np].cem_pst = 1;
  else 
    
#line 175 
    if ((unsigned int)smc->y[np].wc_flag == 0U) 
#line 177 
                                                smc->y[np].cem_pst = 0; else ;
  
#line 183 
  i = 0;
  
#line 183 
  goto ldv_46258;
  ldv_46257: 
#line 184 
  ;
  
#line 185 
  if (smc->y[i].cem_pst == 2 && (unsigned int)smc->y[i].wc_flag == 0U) {
    
#line 186 
    smc->y[i].cem_pst = 0;
    
#line 187 
    queue_event(smc,i + 5,1);
  }
  else ;
  
#line 189 
  if (smc->y[i].cem_pst == 1 && (unsigned int)smc->y[i].wc_flag != 0U) {
    
#line 190 
    smc->y[i].cem_pst = 2;
    
#line 191 
    queue_event(smc,i + 5,1);
  }
  else ;
  
#line 193 
  if (smc->y[i].cem_pst == 0 && (unsigned int)smc->y[i].wc_flag != 0U) 
    
#line 198 
    smc->y[i].cem_pst = 2; else ;
  
#line 183 
  i += 1;
  ldv_46258: 
#line 184 
  ;
  
#line 183 
  if (i <= 1) 
#line 185 
              goto ldv_46257; else 
#line 188 
                                   goto ldv_46259;
  ldv_46259: 
#line 189 
  ;
  return_label: 
#line 201 
                return;
}


#line 213  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/cfm.c"
void cfm(struct s_smc *smc, int event)
{
  int state;
  int cond;
  int oldstate;
  
#line 225 
  all_selection_criteria(smc);
  
#line 229 
  cem_priv_state(smc,event);
  
#line 231 
  oldstate = (int)smc->mib.fddiSMTCF_State;
  ldv_46267: 
#line 232 
  ;
  
#line 237 
  state = (int)smc->mib.fddiSMTCF_State;
  
#line 238 
  cfm_fsm(smc,event);
  
#line 239 
  event = 0;
  
#line 240 
  if ((int)smc->mib.fddiSMTCF_State != state) 
#line 242 
                                              goto ldv_46267; else 
#line 245 
                                                                   goto ldv_46268;
  ldv_46268: 
#line 246 
  ;
  
#line 246 
  cond = 0;
  
#line 247 
  if ((((unsigned int)smc->mib.fddiSMTCF_State == 9U && (unsigned int)smc->y[0].pc_mode == 1U) || ((unsigned int)smc->mib.fddiSMTCF_State == 10U && (unsigned int)smc->y[1].pc_mode == 1U)) || (((unsigned int)smc->mib.fddiSMTCF_State == 11U && (unsigned int)smc->y[0].pc_mode == 1U) && (unsigned int)(smc->y[0].mib)->fddiPORTNeighborType != 2U)) 
    
#line 254 
    cond = 1; else ;
  
#line 256 
  if ((int)smc->mib.fddiSMTPeerWrapFlag != cond) 
#line 257 
                                                 smt_srf_event(smc,5,0,cond); else ;
  
#line 276 
  smc->mib.m[0].fddiMACDownstreamPORTType = (unsigned short)cf_to_ptype[(int)smc->mib.fddiSMTCF_State];
  
#line 278 
  cfm_state_change(smc,(int)smc->mib.fddiSMTCF_State);
  
#line 279 
  return;
}


#line 285  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/cfm.c"
static void cfm_fsm(struct s_smc *smc, int cmd)
{
  
#line 287 
  switch ((int)smc->mib.fddiSMTCF_State) {
    case 16: 
#line 288 
    ;
    
#line 289 
    smc->mib.p[0].fddiPORTCurrentPath = (unsigned short)0U;
    
#line 290 
    smc->mib.p[1].fddiPORTCurrentPath = (unsigned short)0U;
    
#line 291 
    smc->mib.p[0].fddiPORTMACPlacement = (unsigned short)0U;
    
#line 292 
    smc->mib.p[1].fddiPORTMACPlacement = (unsigned short)0U;
    
#line 293 
    smc->mib.fddiSMTStationStatus = (unsigned short)1U;
    
#line 294 
    config_mux(smc,4);
    
#line 295 
    smc->r.rm_loop = (unsigned char)0U;
    
#line 296 
    smc->r.rm_join = (unsigned char)0U;
    
#line 297 
    queue_event(smc,3,8);
    
#line 299 
    smc->mib.fddiSMTCF_State = (unsigned short)((unsigned int)smc->mib.fddiSMTCF_State & 65519U);
    
#line 301 
    goto ldv_46274;
    case 0: 
#line 302 
    ;
    
#line 305 
    if ((unsigned int)smc->s.sas != 0U && ((((unsigned int)smc->y[0].cf_join != 0U || (unsigned int)smc->y[0].cf_loop != 0U) || (unsigned int)smc->y[1].cf_join != 0U) || (unsigned int)smc->y[1].cf_loop != 0U)) {
      
#line 307 
      smc->mib.fddiSMTCF_State = (unsigned short)27U;
      
#line 308 
      goto ldv_46274;
    }
    else ;
    
#line 311 
    if (((smc->y[0].cem_pst == 1 && (unsigned int)smc->y[0].cf_join != 0U) && (unsigned int)smc->y[0].wc_flag == 0U) || (unsigned int)smc->y[0].cf_loop != 0U) {
      
#line 313 
      smc->mib.fddiSMTCF_State = (unsigned short)25U;
      
#line 314 
      goto ldv_46274;
    }
    else ;
    
#line 317 
    if (((smc->y[1].cem_pst == 1 && (unsigned int)smc->y[1].cf_join != 0U) && (unsigned int)smc->y[1].wc_flag == 0U) || (unsigned int)smc->y[1].cf_loop != 0U) {
      
#line 319 
      smc->mib.fddiSMTCF_State = (unsigned short)26U;
      
#line 320 
      goto ldv_46274;
    }
    else ;
    
#line 322 
    goto ldv_46274;
    case 25: 
#line 323 
    ;
    
#line 324 
    smc->mib.p[0].fddiPORTCurrentPath = (unsigned short)4U;
    
#line 325 
    smc->mib.p[1].fddiPORTCurrentPath = (unsigned short)0U;
    
#line 326 
    smc->mib.p[0].fddiPORTMACPlacement = (unsigned short)1U;
    
#line 327 
    smc->mib.p[1].fddiPORTMACPlacement = (unsigned short)0U;
    
#line 328 
    smc->mib.fddiSMTStationStatus = (unsigned short)0U;
    
#line 329 
    config_mux(smc,2);
    
#line 330 
    if ((unsigned int)smc->y[0].cf_loop != 0U) {
      
#line 331 
      smc->r.rm_join = (unsigned char)0U;
      
#line 332 
      smc->r.rm_loop = (unsigned char)1U;
      
#line 333 
      queue_event(smc,3,9);
    }
    else ;
    
#line 335 
    if ((unsigned int)smc->y[0].cf_join != 0U) {
      
#line 336 
      smc->r.rm_loop = (unsigned char)0U;
      
#line 337 
      smc->r.rm_join = (unsigned char)1U;
      
#line 338 
      queue_event(smc,3,8);
    }
    else ;
    
#line 340 
    smc->mib.fddiSMTCF_State = (unsigned short)((unsigned int)smc->mib.fddiSMTCF_State & 65519U);
    
#line 342 
    goto ldv_46274;
    case 9: 
#line 343 
    ;
    
#line 345 
    if (((unsigned int)smc->y[0].wc_flag != 0U || (unsigned int)smc->y[0].cf_join == 0U) && (unsigned int)smc->y[0].cf_loop == 0U) {
      
#line 347 
      smc->mib.fddiSMTCF_State = (unsigned short)16U;
      
#line 348 
      goto ldv_46274;
    }
    else 
      
#line 351 
      if ((((unsigned int)smc->y[1].cf_loop != 0U && (unsigned int)smc->y[0].cf_join != 0U) && smc->y[0].cem_pst == 1) || (((unsigned int)smc->y[1].cf_loop != 0U || ((unsigned int)smc->y[1].cf_join != 0U && smc->y[1].cem_pst == 1)) && ((unsigned int)smc->y[0].pc_mode == 2U || (unsigned int)smc->y[1].pc_mode == 2U))) {
        
#line 358 
        smc->y[0].scrub = (unsigned char)1U;
        
#line 359 
        smc->mib.fddiSMTCF_State = (unsigned short)26U;
        
#line 360 
        goto ldv_46274;
      }
      else 
        
#line 363 
        if (((((((unsigned int)smc->s.attach_s == 0U && (unsigned int)smc->y[0].cf_join != 0U) && smc->y[0].cem_pst == 1) && (unsigned int)smc->y[0].pc_mode == 1U) && (unsigned int)smc->y[1].cf_join != 0U) && smc->y[1].cem_pst == 1) && (unsigned int)smc->y[1].pc_mode == 1U) {
          
#line 369 
          smc->y[0].scrub = (unsigned char)1U;
          
#line 370 
          smc->y[1].scrub = (unsigned char)1U;
          
#line 371 
          smc->mib.fddiSMTCF_State = (unsigned short)28U;
          
#line 372 
          goto ldv_46274;
        }
        else 
          
#line 375 
          if (((((((unsigned int)smc->s.attach_s != 0U && (unsigned int)smc->y[0].cf_join != 0U) && smc->y[0].cem_pst == 1) && (unsigned int)smc->y[0].pc_mode == 1U) && (unsigned int)smc->y[1].cf_join != 0U) && smc->y[1].cem_pst == 1) && (unsigned int)smc->y[1].pc_mode == 1U) {
            
#line 382 
            smc->y[0].scrub = (unsigned char)1U;
            
#line 383 
            smc->y[1].scrub = (unsigned char)1U;
            
#line 384 
            smc->mib.fddiSMTCF_State = (unsigned short)23U;
            
#line 385 
            goto ldv_46274;
          }
          else ;
    
#line 387 
    goto ldv_46274;
    case 26: 
#line 388 
    ;
    
#line 389 
    smc->mib.p[0].fddiPORTCurrentPath = (unsigned short)0U;
    
#line 390 
    smc->mib.p[1].fddiPORTCurrentPath = (unsigned short)4U;
    
#line 391 
    smc->mib.p[0].fddiPORTMACPlacement = (unsigned short)0U;
    
#line 392 
    smc->mib.p[1].fddiPORTMACPlacement = (unsigned short)1U;
    
#line 393 
    smc->mib.fddiSMTStationStatus = (unsigned short)0U;
    
#line 394 
    config_mux(smc,3);
    
#line 395 
    if ((unsigned int)smc->y[1].cf_loop != 0U) {
      
#line 396 
      smc->r.rm_join = (unsigned char)0U;
      
#line 397 
      smc->r.rm_loop = (unsigned char)1U;
      
#line 398 
      queue_event(smc,3,9);
    }
    else ;
    
#line 400 
    if ((unsigned int)smc->y[1].cf_join != 0U) {
      
#line 401 
      smc->r.rm_loop = (unsigned char)0U;
      
#line 402 
      smc->r.rm_join = (unsigned char)1U;
      
#line 403 
      queue_event(smc,3,8);
    }
    else ;
    
#line 405 
    smc->mib.fddiSMTCF_State = (unsigned short)((unsigned int)smc->mib.fddiSMTCF_State & 65519U);
    
#line 407 
    goto ldv_46274;
    case 10: 
#line 408 
    ;
    
#line 410 
    if ((unsigned int)smc->y[1].cf_join == 0U && (unsigned int)smc->y[1].cf_loop == 0U) {
      
#line 411 
      smc->mib.fddiSMTCF_State = (unsigned short)16U;
      
#line 412 
      goto ldv_46274;
    }
    else 
      
#line 415 
      if ((((unsigned int)smc->y[0].cf_loop != 0U && (unsigned int)smc->y[0].pc_mode == 1U) && (unsigned int)smc->y[1].cf_join != 0U) && (unsigned int)smc->y[1].pc_mode == 1U) {
        
#line 417 
        smc->y[1].scrub = (unsigned char)1U;
        
#line 418 
        smc->mib.fddiSMTCF_State = (unsigned short)25U;
        
#line 419 
        goto ldv_46274;
      }
      else 
        
#line 422 
        if (((((unsigned int)smc->s.attach_s == 0U && (unsigned int)smc->y[0].cf_join != 0U) && (unsigned int)smc->y[0].pc_mode == 1U) && (unsigned int)smc->y[1].cf_join != 0U) && (unsigned int)smc->y[1].pc_mode == 1U) {
          
#line 425 
          smc->y[0].scrub = (unsigned char)1U;
          
#line 426 
          smc->y[1].scrub = (unsigned char)1U;
          
#line 427 
          smc->mib.fddiSMTCF_State = (unsigned short)28U;
          
#line 428 
          goto ldv_46274;
        }
        else 
          
#line 431 
          if (((((unsigned int)smc->s.attach_s != 0U && (unsigned int)smc->y[0].cf_join != 0U) && (unsigned int)smc->y[0].pc_mode == 1U) && (unsigned int)smc->y[1].cf_join != 0U) && (unsigned int)smc->y[1].pc_mode == 1U) {
            
#line 434 
            smc->y[0].scrub = (unsigned char)1U;
            
#line 435 
            smc->y[1].scrub = (unsigned char)1U;
            
#line 436 
            smc->mib.fddiSMTCF_State = (unsigned short)23U;
            
#line 437 
            goto ldv_46274;
          }
          else ;
    
#line 439 
    goto ldv_46274;
    case 28: 
#line 440 
    ;
    
#line 441 
    smc->mib.p[0].fddiPORTCurrentPath = (unsigned short)5U;
    
#line 442 
    smc->mib.p[1].fddiPORTCurrentPath = (unsigned short)5U;
    
#line 443 
    smc->mib.p[0].fddiPORTMACPlacement = (unsigned short)0U;
    
#line 444 
    smc->mib.p[1].fddiPORTMACPlacement = (unsigned short)1U;
    
#line 445 
    smc->mib.fddiSMTStationStatus = (unsigned short)2U;
    
#line 446 
    config_mux(smc,0);
    
#line 447 
    smc->r.rm_loop = (unsigned char)0U;
    
#line 448 
    smc->r.rm_join = (unsigned char)1U;
    
#line 449 
    queue_event(smc,3,8);
    
#line 450 
    smc->mib.fddiSMTCF_State = (unsigned short)((unsigned int)smc->mib.fddiSMTCF_State & 65519U);
    
#line 452 
    goto ldv_46274;
    case 12: 
#line 453 
    ;
    
#line 455 
    if ((unsigned int)smc->y[1].wc_flag != 0U || (unsigned int)smc->y[1].cf_join == 0U) {
      
#line 456 
      smc->y[0].scrub = (unsigned char)1U;
      
#line 457 
      smc->mib.fddiSMTCF_State = (unsigned short)25U;
      
#line 458 
      goto ldv_46274;
    }
    else 
      
#line 461 
      if ((unsigned int)smc->y[0].cf_join == 0U || (unsigned int)smc->y[0].wc_flag != 0U) {
        
#line 462 
        smc->y[1].scrub = (unsigned char)1U;
        
#line 463 
        smc->mib.fddiSMTCF_State = (unsigned short)26U;
        
#line 464 
        goto ldv_46274;
      }
      else 
        
#line 467 
        if ((unsigned int)smc->s.attach_s != 0U) {
          
#line 468 
          smc->y[1].scrub = (unsigned char)1U;
          
#line 469 
          smc->mib.fddiSMTCF_State = (unsigned short)23U;
          
#line 470 
          goto ldv_46274;
        }
        else ;
    
#line 472 
    goto ldv_46274;
    case 23: 
#line 473 
    ;
    
#line 474 
    smc->mib.p[0].fddiPORTCurrentPath = (unsigned short)5U;
    
#line 475 
    smc->mib.p[1].fddiPORTCurrentPath = (unsigned short)5U;
    
#line 476 
    smc->mib.p[0].fddiPORTMACPlacement = (unsigned short)1U;
    
#line 477 
    smc->mib.p[1].fddiPORTMACPlacement = (unsigned short)0U;
    
#line 478 
    smc->mib.fddiSMTStationStatus = (unsigned short)2U;
    
#line 479 
    config_mux(smc,1);
    
#line 480 
    smc->r.rm_loop = (unsigned char)0U;
    
#line 481 
    smc->r.rm_join = (unsigned char)1U;
    
#line 482 
    queue_event(smc,3,8);
    
#line 483 
    smc->mib.fddiSMTCF_State = (unsigned short)((unsigned int)smc->mib.fddiSMTCF_State & 65519U);
    
#line 485 
    goto ldv_46274;
    case 7: 
#line 486 
    ;
    
#line 488 
    if ((unsigned int)smc->y[1].cf_join == 0U || (unsigned int)smc->y[1].wc_flag != 0U) {
      
#line 489 
      smc->y[0].scrub = (unsigned char)1U;
      
#line 490 
      smc->mib.fddiSMTCF_State = (unsigned short)25U;
      
#line 491 
      goto ldv_46274;
    }
    else 
      
#line 494 
      if ((unsigned int)smc->y[0].cf_join == 0U || (unsigned int)smc->y[0].wc_flag != 0U) {
        
#line 495 
        smc->y[1].scrub = (unsigned char)1U;
        
#line 496 
        smc->mib.fddiSMTCF_State = (unsigned short)26U;
        
#line 497 
        goto ldv_46274;
      }
      else 
        
#line 500 
        if ((unsigned int)smc->s.attach_s == 0U) {
          
#line 501 
          smc->y[0].scrub = (unsigned char)1U;
          
#line 502 
          smc->mib.fddiSMTCF_State = (unsigned short)28U;
          
#line 503 
          goto ldv_46274;
        }
        else ;
    
#line 505 
    goto ldv_46274;
    case 27: 
#line 506 
    ;
    
#line 507 
    smc->mib.p[0].fddiPORTCurrentPath = (unsigned short)4U;
    
#line 508 
    smc->mib.p[0].fddiPORTMACPlacement = (unsigned short)1U;
    
#line 509 
    smc->mib.fddiSMTStationStatus = (unsigned short)0U;
    
#line 510 
    config_mux(smc,5);
    
#line 511 
    if ((unsigned int)smc->y[0].cf_loop != 0U || (unsigned int)smc->y[1].cf_loop != 0U) {
      
#line 512 
      smc->r.rm_join = (unsigned char)0U;
      
#line 513 
      smc->r.rm_loop = (unsigned char)1U;
      
#line 514 
      queue_event(smc,3,9);
    }
    else ;
    
#line 516 
    if ((unsigned int)smc->y[0].cf_join != 0U || (unsigned int)smc->y[1].cf_join != 0U) {
      
#line 517 
      smc->r.rm_loop = (unsigned char)0U;
      
#line 518 
      smc->r.rm_join = (unsigned char)1U;
      
#line 519 
      queue_event(smc,3,8);
    }
    else ;
    
#line 521 
    smc->mib.fddiSMTCF_State = (unsigned short)((unsigned int)smc->mib.fddiSMTCF_State & 65519U);
    
#line 523 
    goto ldv_46274;
    case 11: 
#line 524 
    ;
    
#line 526 
    if ((((unsigned int)smc->y[0].cf_join == 0U && (unsigned int)smc->y[0].cf_loop == 0U) && (unsigned int)smc->y[1].cf_join == 0U) && (unsigned int)smc->y[1].cf_loop == 0U) {
      
#line 528 
      smc->mib.fddiSMTCF_State = (unsigned short)16U;
      
#line 529 
      goto ldv_46274;
    }
    else ;
    
#line 531 
    goto ldv_46274;
    default: 
#line 532 
    ;
    
#line 533 
    printk("\001",106,(char *)"CFM : invalid state");
    
#line 534 
    goto ldv_46274;
  }
  ldv_46274: 
#line 536 
  ;
  
#line 537 
  return;
}


#line 543  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/cfm.c"
int cfm_get_mac_input(struct s_smc *smc)
{
  int __retres;
  
#line 546 
  __retres = ((unsigned int)smc->mib.fddiSMTCF_State == 10U || (unsigned int)smc->mib.fddiSMTCF_State == 7U) != 0;
  
#line 546 
  return __retres;
}


#line 554  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/cfm.c"
int cfm_get_mac_output(struct s_smc *smc)
{
  int __retres;
  
#line 557 
  __retres = ((unsigned int)smc->mib.fddiSMTCF_State == 10U || (unsigned int)smc->mib.fddiSMTCF_State == 12U) != 0;
  
#line 557 
  return __retres;
}


#line 560  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/cfm.c"
static char path_iso[24U] = {(char)0, (char)0, (char)0, (char)4, (char)0, (char)1, (char)0, (char)0, (char)0, (char)0, (char)0, (char)2, (char)0, (char)1, (char)0, (char)0, (char)0, (char)0, (char)0, (char)4, (char)0, (char)2, (char)0, (char)0};

#line 566  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/cfm.c"
static char path_wrap_a[24U] = {(char)0, (char)0, (char)0, (char)4, (char)0, (char)1, (char)0, (char)3, (char)0, (char)0, (char)0, (char)2, (char)0, (char)1, (char)0, (char)3, (char)0, (char)0, (char)0, (char)4, (char)0, (char)2, (char)0, (char)0};

#line 572  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/cfm.c"
static char path_wrap_b[24U] = {(char)0, (char)0, (char)0, (char)4, (char)0, (char)2, (char)0, (char)3, (char)0, (char)0, (char)0, (char)2, (char)0, (char)1, (char)0, (char)3, (char)0, (char)0, (char)0, (char)4, (char)0, (char)1, (char)0, (char)0};

#line 578  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/cfm.c"
static char path_thru[24U] = {(char)0, (char)0, (char)0, (char)4, (char)0, (char)1, (char)0, (char)3, (char)0, (char)0, (char)0, (char)2, (char)0, (char)1, (char)0, (char)3, (char)0, (char)0, (char)0, (char)4, (char)0, (char)2, (char)0, (char)3};

#line 584  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/cfm.c"
static char path_wrap_s[16U] = {(char)0, (char)0, (char)0, (char)4, (char)0, (char)1, (char)0, (char)3, (char)0, (char)0, (char)0, (char)2, (char)0, (char)1, (char)0, (char)3};

#line 589  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/cfm.c"
static char path_iso_s[16U] = {(char)0, (char)0, (char)0, (char)4, (char)0, (char)1, (char)0, (char)0, (char)0, (char)0, (char)0, (char)2, (char)0, (char)1, (char)0, (char)0};

#line 594  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/cfm.c"
int cem_build_path(struct s_smc *smc, char *to, int path_index)
{
  char *path;
  int len;
  
#line 599 
  switch ((int)smc->mib.fddiSMTCF_State) {
    default: 
#line 600 
    ;
    case 0: 
#line 601 
    ;
    
#line 602 
    if ((unsigned int)smc->s.sas != 0U) 
#line 602 
                                        path = (char *)(& path_iso_s); else 
                                                                    
#line 602 
                                                                    path = (char *)(& path_iso);
    
#line 603 
    if ((unsigned int)smc->s.sas != 0U) 
#line 603 
                                        len = 16; else 
#line 603 
                                                       len = 24;
    
#line 604 
    goto ldv_46308;
    case 9: 
#line 605 
    ;
    
#line 606 
    path = (char *)(& path_wrap_a);
    
#line 607 
    len = 24;
    
#line 608 
    goto ldv_46308;
    case 10: 
#line 609 
    ;
    
#line 610 
    path = (char *)(& path_wrap_b);
    
#line 611 
    len = 24;
    
#line 612 
    goto ldv_46308;
    case 12: 
#line 613 
    ;
    
#line 614 
    path = (char *)(& path_thru);
    
#line 615 
    len = 24;
    
#line 616 
    goto ldv_46308;
    case 11: 
#line 617 
    ;
    
#line 618 
    path = (char *)(& path_wrap_s);
    
#line 619 
    len = 16;
    
#line 620 
    goto ldv_46308;
  }
  ldv_46308: 
#line 622 
  ;
  
#line 622 
  memcpy((void *)to,(void const *)path,(unsigned long)len);
  
#line 626 
  return len;
}


#line 517  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/cmtdef.h"
void smt_received_pack(struct s_smc *smc, Mbuf *mb, int fs);


#line 526 
void smt_send_mbuf(struct s_smc *smc, Mbuf *mb, int fc);


#line 557 
void ev_dispatcher(struct s_smc *smc);


#line 573 
void smt_force_irq(struct s_smc *smc);


#line 577 
void mac_set_rx_mode(struct s_smc *smc, int mode);


#line 584 
void process_receive(struct s_smc *smc);


#line 585 
void init_driver_fplus(struct s_smc *smc);


#line 586 
void rtm_irq(struct s_smc *smc);


#line 590 
void llc_restart_tx(struct s_smc *smc);


#line 597 
void mac_drv_clear_tx_queue(struct s_smc *smc);


#line 598 
void mac_drv_repair_descr(struct s_smc *smc);


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/iomap.h"
unsigned int ioread16(void *);


#line 31 
unsigned int ioread32(void *);


#line 37 
void iowrite32(u32, void *);


#line 474  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smc.h"
void init_board(struct s_smc *smc, u_char *mac_addr);


#line 475 
int init_fplus(struct s_smc *smc);


#line 476 
void init_plc(struct s_smc *smc);


#line 478 
void mac1_irq(struct s_smc *smc, u_short stu, u_short stl);


#line 479 
void mac2_irq(struct s_smc *smc, u_short code_s2u, u_short code_s2l);


#line 480 
void mac3_irq(struct s_smc *smc, u_short code_s3u, u_short code_s3l);


#line 482 
void plc1_irq(struct s_smc *smc);


#line 483 
void plc2_irq(struct s_smc *smc);


#line 485 
void timer_irq(struct s_smc *smc);


#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwmtm.c"
static void queue_llc_rx(struct s_smc *smc, Mbuf *mb);


#line 79 
static void smt_to_llc(struct s_smc *smc, Mbuf *mb);


#line 80 
static void init_txd_ring(struct s_smc *smc);


#line 81 
static void init_rxd_ring(struct s_smc *smc);


#line 82 
static void queue_txd_mb(struct s_smc *smc, Mbuf *mb);


#line 83 
static u_long init_descr_ring(struct s_smc *smc, union s_fp_descr volatile *start, int count);


#line 85 
static u_long repair_txd_ring(struct s_smc *smc, struct s_smt_tx_queue *queue);


#line 86 
static u_long repair_rxd_ring(struct s_smc *smc, struct s_smt_rx_queue *queue);


#line 87 
static Mbuf *get_llc_rx(struct s_smc *smc);


#line 88 
static Mbuf *get_txd_mb(struct s_smc *smc);


#line 89 
static void mac_drv_clear_txd(struct s_smc *smc);


#line 98 
void *mac_drv_get_space(struct s_smc *smc, unsigned int size);


#line 99 
void *mac_drv_get_desc_mem(struct s_smc *smc, unsigned int size);


#line 100 
void mac_drv_fill_rxd(struct s_smc *smc);


#line 101 
void mac_drv_tx_complete(struct s_smc *smc, struct s_smt_fp_txd volatile *txd);


#line 103 
void mac_drv_rx_complete(struct s_smc *smc, struct s_smt_fp_rxd volatile *rxd, int frag_count, int len);


#line 106 
void mac_drv_requeue_rxd(struct s_smc *smc, struct s_smt_fp_rxd volatile *rxd, int frag_count);


#line 109 
void mac_drv_clear_rxd(struct s_smc *smc, struct s_smt_fp_rxd volatile *rxd, int frag_count);


#line 121 
unsigned long mac_drv_virt2phys(struct s_smc *smc, void *virt);


#line 122 
unsigned long dma_master(struct s_smc *smc, void *virt, int len, int flag);


#line 127 
void dma_complete(struct s_smc *smc, union s_fp_descr volatile *descr, int flag);


#line 131 
int mac_drv_rx_init(struct s_smc *smc, int len, int fc, char *look_ahead, int la_len);


#line 140 
void fddi_isr(struct s_smc *smc);


#line 143 
void mac_drv_rx_mode(struct s_smc *smc, int mode);


#line 146 
void mac_drv_clear_rx_queue(struct s_smc *smc);


#line 147 
void hwm_tx_frag(struct s_smc *smc, char *virt, u_long phys, int len, int frame_status);


#line 149 
void hwm_rx_frag(struct s_smc *smc, char *virt, u_long phys, int len, int frame_status);


#line 152 
int mac_drv_init(struct s_smc *smc);


#line 153 
int hwm_tx_init(struct s_smc *smc, u_char fc, int frag_count, int frame_len, int frame_status);


#line 156 
u_int mac_drv_check_space(void);


#line 229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwmtm.c"
u_int mac_drv_check_space(void)
{
  u_int __retres;
  
#line 241 
  __retres = 20032U;
  
#line 241 
  return __retres;
}


#line 259  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwmtm.c"
int mac_drv_init(struct s_smc *smc)
{
  int __retres;
  union s_fp_descr volatile *tmp;
  Mbuf *tmp_1;
  
#line 271 
  tmp = (union s_fp_descr volatile *)mac_drv_get_desc_mem(smc,1920U);
  
#line 271 
  smc->os.hwm.descr_p = tmp;
  
#line 271 
  if (tmp == (union s_fp_descr volatile *)0) {
    
#line 274 
    __retres = 1;
    
#line 274 
    goto return_label;
  }
  else ;
  
#line 284 
  tmp_1 = (Mbuf *)mac_drv_get_space(smc,18112U);
  
#line 284 
  smc->os.hwm.mbuf_pool.mb_start = tmp_1;
  
#line 284 
  if (tmp_1 == (Mbuf *)0) {
    
#line 286 
    __retres = 1;
    
#line 286 
    goto return_label;
  }
  else ;
  
#line 297 
  __retres = 0;
  return_label: 
#line 297 
                return __retres;
}


#line 309  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwmtm.c"
void init_driver_fplus(struct s_smc *smc)
{
  
#line 311 
  smc->hw.fp.mdr2init = (unsigned short)35203U;
  
#line 314 
  smc->hw.fp.mdr2init = (unsigned short)((unsigned int)smc->hw.fp.mdr2init | 12288U);
  
#line 316 
  smc->hw.fp.mdr3init = (unsigned short)129U;
  
#line 320 
  smc->hw.fp.frselreg_init = (unsigned short)49152U;
  
#line 321 
  return;
}


#line 324  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwmtm.c"
static u_long init_descr_ring(struct s_smc *smc, union s_fp_descr volatile *start, int count)
{
  int i;
  union s_fp_descr volatile *d1;
  union s_fp_descr volatile *d2;
  u_long phys;
  
#line 334 
  i = count + -1;
  
#line 334 
  d1 = start;
  
#line 334 
  goto ldv_46403;
  ldv_46402: 
#line 335 
  ;
  
#line 335 
  d2 = d1;
  
#line 336 
  d1 += 1;
  
#line 337 
  d2->r.rxd_rbctrl = 5570560U;
  
#line 338 
  d2->r.rxd_next = & d1->r;
  
#line 339 
  phys = mac_drv_virt2phys(smc,(void *)d1);
  
#line 340 
  d2->r.rxd_nrdadr = (unsigned int)phys;
  
#line 334 
  i -= 1;
  ldv_46403: 
#line 335 
  ;
  
#line 334 
  if (i != 0) 
#line 336 
              goto ldv_46402; else 
#line 339 
                                   goto ldv_46404;
  ldv_46404: 
#line 340 
  ;
  
#line 343 
  d1->r.rxd_rbctrl = 5570560U;
  
#line 344 
  d1->r.rxd_next = & start->r;
  
#line 345 
  phys = mac_drv_virt2phys(smc,(void *)start);
  
#line 346 
  d1->r.rxd_nrdadr = (unsigned int)phys;
  
#line 348 
  i = count;
  
#line 348 
  d1 = start;
  
#line 348 
  goto ldv_46406;
  ldv_46405: 
#line 349 
  ;
  
#line 350 
  d1 += 1;
  
#line 348 
  i -= 1;
  ldv_46406: 
#line 349 
  ;
  
#line 348 
  if (i != 0) 
#line 350 
              goto ldv_46405; else 
#line 353 
                                   goto ldv_46407;
  ldv_46407: 
#line 354 
  ;
  
#line 352 
  return phys;
}


#line 355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwmtm.c"
static void init_txd_ring(struct s_smc *smc)
{
  struct s_smt_fp_txd volatile *ds;
  struct s_smt_tx_queue *queue;
  u_long phys;
  struct s_smt_fp_txd volatile *tmp;
  struct s_smt_fp_txd volatile *tmp_0;
  
#line 364 
  ds = (struct s_smt_fp_txd volatile *)smc->os.hwm.descr_p + 528U;
  
#line 366 
  queue = smc->hw.fp.tx[1];
  
#line 368 
  init_descr_ring(smc,(union s_fp_descr volatile *)ds,14);
  
#line 370 
  phys = (unsigned long)ds->txd_ntdadr;
  
#line 371 
  ds += 1;
  
#line 372 
  tmp = ds;
  
#line 372 
  queue->tx_curr_get = tmp;
  
#line 372 
  queue->tx_curr_put = tmp;
  
#line 373 
  ds -= 1;
  
#line 374 
  queue->tx_free = (unsigned short)14U;
  
#line 375 
  queue->tx_used = (unsigned short)0U;
  
#line 376 
  iowrite32((unsigned int)phys,smc->hw.iop + 656U);
  
#line 378 
  ds += 672U;
  
#line 380 
  queue = smc->hw.fp.tx[0];
  
#line 382 
  init_descr_ring(smc,(union s_fp_descr volatile *)ds,14);
  
#line 384 
  phys = (unsigned long)ds->txd_ntdadr;
  
#line 385 
  ds += 1;
  
#line 386 
  tmp_0 = ds;
  
#line 386 
  queue->tx_curr_get = tmp_0;
  
#line 386 
  queue->tx_curr_put = tmp_0;
  
#line 387 
  queue->tx_free = (unsigned short)14U;
  
#line 388 
  queue->tx_used = (unsigned short)0U;
  
#line 389 
  iowrite32((unsigned int)phys,smc->hw.iop + 720U);
  
#line 390 
  return;
}


#line 392  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwmtm.c"
static void init_rxd_ring(struct s_smc *smc)
{
  struct s_smt_fp_rxd volatile *ds;
  struct s_smt_rx_queue *queue;
  u_long phys;
  struct s_smt_fp_rxd volatile *tmp;
  
#line 401 
  ds = (struct s_smt_fp_rxd volatile *)smc->os.hwm.descr_p;
  
#line 402 
  queue = smc->hw.fp.rx[0];
  
#line 404 
  init_descr_ring(smc,(union s_fp_descr volatile *)ds,11);
  
#line 406 
  phys = (unsigned long)ds->rxd_nrdadr;
  
#line 407 
  ds += 1;
  
#line 408 
  tmp = ds;
  
#line 408 
  queue->rx_curr_get = tmp;
  
#line 408 
  queue->rx_curr_put = tmp;
  
#line 409 
  queue->rx_free = (unsigned short)11U;
  
#line 410 
  queue->rx_used = (unsigned short)0U;
  
#line 411 
  iowrite32((unsigned int)phys,smc->hw.iop + 528U);
  
#line 412 
  return;
}


#line 422  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwmtm.c"
void init_fddi_driver(struct s_smc *smc, u_char *mac_addr)
{
  Mbuf *mb;
  int i;
  Mbuf *tmp;
  Mbuf *tmp_0;
  u_short tmp_2;
  u_short tmp_1;
  int tmp_3;
  
#line 427 
  init_board(smc,mac_addr);
  
#line 428 
  init_fplus(smc);
  
#line 434 
  mb = smc->os.hwm.mbuf_pool.mb_start;
  
#line 435 
  smc->os.hwm.mbuf_pool.mb_free = (Mbuf *)0;
  
#line 436 
  i = 0;
  
#line 436 
  goto ldv_46427;
  ldv_46426: 
#line 437 
  ;
  
#line 437 
  mb->sm_use_count = 1;
  
#line 438 
  smt_free_mbuf(smc,mb);
  
#line 439 
  mb += 1;
  
#line 436 
  i += 1;
  ldv_46427: 
#line 437 
  ;
  
#line 436 
  if (i <= 3) 
#line 438 
              goto ldv_46426; else 
#line 441 
                                   goto ldv_46428;
  ldv_46428: 
#line 442 
  ;
  
#line 457 
  tmp = (Mbuf *)0;
  
#line 457 
  smc->os.hwm.llc_rx_tail = tmp;
  
#line 457 
  smc->os.hwm.llc_rx_pipe = tmp;
  
#line 458 
  tmp_0 = (Mbuf *)0;
  
#line 458 
  smc->os.hwm.txd_tx_tail = tmp_0;
  
#line 458 
  smc->os.hwm.txd_tx_pipe = tmp_0;
  
#line 459 
  tmp_2 = (unsigned short)0U;
  
#line 459 
  smc->os.hwm.pass_DB = tmp_2;
  
#line 459 
  tmp_1 = tmp_2;
  
#line 459 
  smc->os.hwm.pass_NSA = tmp_1;
  
#line 459 
  smc->os.hwm.pass_SMT = tmp_1;
  
#line 460 
  smc->os.hwm.pass_llc_promisc = (unsigned short)1U;
  
#line 461 
  tmp_3 = 0;
  
#line 461 
  smc->os.hwm.queued_txd_mb = tmp_3;
  
#line 461 
  smc->os.hwm.queued_rx_frames = tmp_3;
  
#line 462 
  smc->os.hwm.detec_count = 0;
  
#line 463 
  smc->os.hwm.rx_break = 0;
  
#line 464 
  smc->os.hwm.rx_len_error = 0UL;
  
#line 465 
  smc->os.hwm.isr_flag = 0;
  
#line 470 
  i = (int)((long)16U - ((long)smc->os.hwm.descr_p & (long)15U));
  
#line 471 
  if (i != 16) 
#line 473 
               smc->os.hwm.descr_p += i; else ;
  
#line 478 
  init_txd_ring(smc);
  
#line 479 
  init_rxd_ring(smc);
  
#line 480 
  mac_drv_fill_rxd(smc);
  
#line 482 
  init_plc(smc);
  
#line 483 
  return;
}


#line 486  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwmtm.c"
Mbuf *smt_get_mbuf(struct s_smc *smc)
{
  register Mbuf *mb;
  
#line 491 
  mb = smc->os.hwm.mbuf_pool.mb_free;
  
#line 495 
  if (mb != (Mbuf *)0) {
    
#line 497 
    smc->os.hwm.mbuf_pool.mb_free = mb->m_next;
    
#line 501 
    mb->m_off = (short)8;
    
#line 502 
    mb->sm_use_count = 1;
  }
  else ;
  
#line 505 
  return mb;
}


#line 508  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwmtm.c"
void smt_free_mbuf(struct s_smc *smc, Mbuf *mb)
{
  
#line 511 
  if (mb != (Mbuf *)0) {
    
#line 512 
    mb->sm_use_count -= 1;
    
#line 519 
    if (mb->sm_use_count == 0) {
      
#line 522 
      mb->m_next = smc->os.hwm.mbuf_pool.mb_free;
      
#line 523 
      smc->os.hwm.mbuf_pool.mb_free = mb;
    }
    else ;
  }
  else 
#line 531 
       printk("\001",503,(char *)"HWM: smt_free_mbuf() called with NULL pointer");
  
#line 532 
  return;
}


#line 554  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwmtm.c"
void mac_drv_repair_descr(struct s_smc *smc)
{
  u_long phys;
  
#line 558 
  if ((unsigned int)smc->hw.hw_state != 0U) {
    
#line 560 
    printk("\001",513,(char *)"HWM: mac_drv_repair_descr was called although the hardware wasn\'t stopped");
    
#line 561 
    goto return_label;
  }
  else ;
  
#line 567 
  phys = repair_txd_ring(smc,smc->hw.fp.tx[1]);
  
#line 568 
  iowrite32((unsigned int)phys,smc->hw.iop + 656U);
  
#line 569 
  if ((unsigned int)smc->hw.fp.tx_q[1].tx_used != 0U) 
#line 570 
                                                      iowrite32(16U,smc->hw.iop + 120U); else ;
  
#line 572 
  phys = repair_txd_ring(smc,smc->hw.fp.tx[0]);
  
#line 573 
  iowrite32((unsigned int)phys,smc->hw.iop + 720U);
  
#line 574 
  if ((unsigned int)smc->hw.fp.tx_q[0].tx_used != 0U) 
#line 575 
                                                      iowrite32(16U,smc->hw.iop + 124U); else ;
  
#line 581 
  phys = repair_rxd_ring(smc,smc->hw.fp.rx[0]);
  
#line 582 
  iowrite32((unsigned int)phys,smc->hw.iop + 528U);
  
#line 583 
  iowrite32(16U,smc->hw.iop + 112U);
  return_label: 
#line 584 
                return;
}


#line 586  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwmtm.c"
static u_long repair_txd_ring(struct s_smc *smc, struct s_smt_tx_queue *queue)
{
  int i;
  int tx_used;
  u_long phys;
  u_long tbctrl;
  struct s_smt_fp_txd volatile *t;
  
#line 596 
  t = queue->tx_curr_get;
  
#line 597 
  tx_used = (int)queue->tx_used;
  
#line 598 
  i = ((int)queue->tx_free + tx_used) + -1;
  
#line 598 
  goto ldv_46451;
  ldv_46450: 
#line 599 
  ;
  
#line 599 
  t = t->txd_next;
  
#line 598 
  i -= 1;
  ldv_46451: 
#line 599 
  ;
  
#line 598 
  if (i != 0) 
#line 600 
              goto ldv_46450; else 
#line 603 
                                   goto ldv_46452;
  ldv_46452: 
#line 604 
  ;
  
#line 601 
  phys = (unsigned long)t->txd_ntdadr;
  
#line 603 
  t = queue->tx_curr_get;
  
#line 604 
  goto ldv_46455;
  ldv_46454: 
#line 605 
  ;
  
#line 606 
  tbctrl = (unsigned long)t->txd_tbctrl;
  
#line 608 
  if ((tbctrl & 2147483648UL) != 0UL) {
    
#line 609 
    if ((tbctrl & 1073741824UL) != 0UL) 
#line 610 
                                        goto ldv_46453; else 
#line 616 
                                                             t->txd_tbctrl &= 2147483647U;
  }
  else ;
  
#line 619 
  phys = (unsigned long)t->txd_ntdadr;
  
#line 621 
  t = t->txd_next;
  
#line 622 
  tx_used -= 1;
  ldv_46455: 
#line 623 
  ;
  
#line 604 
  if (tx_used != 0) 
#line 606 
                    goto ldv_46454; else 
#line 609 
                                         goto ldv_46453;
  ldv_46453: 
#line 610 
  ;
  
#line 624 
  return phys;
}


#line 638  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwmtm.c"
static u_long repair_rxd_ring(struct s_smc *smc, struct s_smt_rx_queue *queue)
{
  int i;
  int rx_used;
  u_long phys;
  u_long rbctrl;
  struct s_smt_fp_rxd volatile *r;
  
#line 648 
  r = queue->rx_curr_get;
  
#line 649 
  rx_used = (int)queue->rx_used;
  
#line 650 
  i = 10;
  
#line 650 
  goto ldv_46466;
  ldv_46465: 
#line 651 
  ;
  
#line 651 
  r = r->rxd_next;
  
#line 650 
  i -= 1;
  ldv_46466: 
#line 651 
  ;
  
#line 650 
  if (i != 0) 
#line 652 
              goto ldv_46465; else 
#line 655 
                                   goto ldv_46467;
  ldv_46467: 
#line 656 
  ;
  
#line 653 
  phys = (unsigned long)r->rxd_nrdadr;
  
#line 655 
  r = queue->rx_curr_get;
  
#line 656 
  goto ldv_46470;
  ldv_46469: 
#line 657 
  ;
  
#line 658 
  rbctrl = (unsigned long)r->rxd_rbctrl;
  
#line 660 
  if ((rbctrl & 2147483648UL) != 0UL) {
    
#line 661 
    if ((rbctrl & 1073741824UL) != 0UL) 
#line 662 
                                        goto ldv_46468; else 
#line 668 
                                                             r->rxd_rbctrl &= 2147483647U;
  }
  else ;
  
#line 671 
  phys = (unsigned long)r->rxd_nrdadr;
  
#line 673 
  r = r->rxd_next;
  
#line 674 
  rx_used -= 1;
  ldv_46470: 
#line 675 
  ;
  
#line 656 
  if (rx_used != 0) 
#line 658 
                    goto ldv_46469; else 
#line 661 
                                         goto ldv_46468;
  ldv_46468: 
#line 662 
  ;
  
#line 676 
  return phys;
}


#line 709  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwmtm.c"
void fddi_isr(struct s_smc *smc)
{
  u_long is;
  u_short stu;
  u_short stl;
  Mbuf *mb;
  unsigned int tmp_5;
  
#line 732 
  smc->os.hwm.isr_flag = 1;
  
#line 742 
  goto ldv_46482;
  ldv_46481: 
#line 743 
  ;
  
#line 746 
  if ((is & 8359953UL) != 0UL) {
    
#line 748 
    if ((is & 1048576UL) != 0UL) 
#line 749 
                                 plc1_irq(smc); else ;
    
#line 751 
    if ((is & 524288UL) != 0UL) 
#line 752 
                                plc2_irq(smc); else ;
    
#line 754 
    if ((is & 65536UL) != 0UL) {
      unsigned int tmp;
      unsigned int tmp_0;
      
#line 755 
      tmp = ioread16(smc->hw.iop + 1024U);
      
#line 755 
      stu = (unsigned short)tmp;
      
#line 756 
      tmp_0 = ioread16(smc->hw.iop + 1028U);
      
#line 756 
      stl = (unsigned short)tmp_0;
      
#line 758 
      mac1_irq(smc,(unsigned short)((int)stu),(unsigned short)((int)stl));
    }
    else ;
    
#line 760 
    if ((is & 131072UL) != 0UL) {
      unsigned int tmp_1;
      unsigned int tmp_2;
      
#line 761 
      tmp_1 = ioread16(smc->hw.iop + 1032U);
      
#line 761 
      stu = (unsigned short)tmp_1;
      
#line 762 
      tmp_2 = ioread16(smc->hw.iop + 1036U);
      
#line 762 
      stl = (unsigned short)tmp_2;
      
#line 765 
      mac2_irq(smc,(unsigned short)((int)stu),(unsigned short)((int)stl));
    }
    else ;
    
#line 767 
    if ((is & 262144UL) != 0UL) {
      unsigned int tmp_3;
      unsigned int tmp_4;
      
#line 768 
      tmp_3 = ioread16(smc->hw.iop + 1412U);
      
#line 768 
      stu = (unsigned short)tmp_3;
      
#line 769 
      tmp_4 = ioread16(smc->hw.iop + 1416U);
      
#line 769 
      stl = (unsigned short)tmp_4;
      
#line 771 
      mac3_irq(smc,(unsigned short)((int)stu),(unsigned short)((int)stl));
    }
    else ;
    
#line 773 
    if ((is & 4194304UL) != 0UL) {
      
#line 774 
      timer_irq(smc);
      
#line 781 
      smc->os.hwm.detec_count += 1;
      
#line 781 
      if (smc->os.hwm.detec_count > 4) 
#line 785 
                                       process_receive(smc); else ;
    }
    else ;
    
#line 788 
    if ((is & 2097152UL) != 0UL) 
#line 789 
                                 rtm_irq(smc); else ;
    
#line 791 
    if ((is & 32768UL) != 0UL) {
      
#line 793 
      iowrite32(8U,smc->hw.iop + 540U);
      
#line 794 
      printk("\001",504,(char *)"HWM: Parity error rx queue 1");
    }
    else ;
    
#line 796 
    if ((is & 4096UL) != 0UL) {
      
#line 798 
      iowrite32(1U,smc->hw.iop + 540U);
      
#line 799 
      printk("\001",505,(char *)"HWM: Encoding error rx queue 1");
    }
    else ;
    
#line 801 
    if ((is & 16UL) != 0UL) {
      
#line 803 
      iowrite32(1U,smc->hw.iop + 668U);
      
#line 804 
      printk("\001",506,(char *)"HWM: Encoding error async tx queue");
    }
    else ;
    
#line 806 
    if ((is & 1UL) != 0UL) {
      
#line 808 
      iowrite32(1U,smc->hw.iop + 732U);
      
#line 809 
      printk("\001",507,(char *)"HWM: Encoding error sync tx queue");
    }
    else ;
  }
  else ;
  
#line 816 
  if ((is & 34UL) != 0UL) {
    
#line 822 
    iowrite32(2U,smc->hw.iop + 732U);
    
#line 823 
    iowrite32(2U,smc->hw.iop + 668U);
    
#line 824 
    mac_drv_clear_txd(smc);
    
#line 825 
    llc_restart_tx(smc);
  }
  else ;
  
#line 831 
  if ((is & 8192UL) != 0UL) {
    
#line 835 
    iowrite32(2U,smc->hw.iop + 540U);
    
#line 836 
    process_receive(smc);
  }
  else ;
  
#line 849 
  goto ldv_46479;
  ldv_46478: 
#line 850 
  ;
  
#line 850 
  smt_to_llc(smc,mb);
  ldv_46479: 
#line 851 
  ;
  
#line 849 
  mb = get_llc_rx(smc);
  
#line 849 
  if (mb != (Mbuf *)0) 
#line 851 
                       goto ldv_46478; else 
#line 854 
                                            goto ldv_46480;
  ldv_46480: 
#line 855 
  ;
  
#line 864 
  if (smc->q.ev_get != smc->q.ev_put) 
#line 866 
                                      ev_dispatcher(smc); else ;
  ldv_46482: 
#line 867 
  ;
  
#line 742 
  tmp_5 = ioread32(smc->hw.iop + 8U);
  
#line 742 
  is = (unsigned long)tmp_5 & 8368179UL;
  
#line 742 
  if (is != 0UL) 
#line 744 
                 goto ldv_46481; else 
#line 747 
                                      goto ldv_46483;
  ldv_46483: 
#line 748 
  ;
  
#line 888 
  smc->os.hwm.isr_flag = 0;
  
#line 889 
  return;
}


#line 992  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwmtm.c"
void mac_drv_rx_mode(struct s_smc *smc, int mode)
{
  
#line 994 
  switch (mode) {
    u_short tmp;
    case 21: 
#line 995 
    ;
    
#line 996 
    smc->os.hwm.pass_SMT = (unsigned short)1U;
    
#line 997 
    goto ldv_46489;
    case 22: 
#line 998 
    ;
    
#line 999 
    smc->os.hwm.pass_SMT = (unsigned short)0U;
    
#line 1000 
    goto ldv_46489;
    case 23: 
#line 1001 
    ;
    
#line 1002 
    smc->os.hwm.pass_NSA = (unsigned short)1U;
    
#line 1003 
    goto ldv_46489;
    case 24: 
#line 1004 
    ;
    
#line 1005 
    smc->os.hwm.pass_NSA = (unsigned short)0U;
    
#line 1006 
    goto ldv_46489;
    case 25: 
#line 1007 
    ;
    
#line 1008 
    smc->os.hwm.pass_DB = (unsigned short)1U;
    
#line 1009 
    goto ldv_46489;
    case 26: 
#line 1010 
    ;
    
#line 1011 
    smc->os.hwm.pass_DB = (unsigned short)0U;
    
#line 1012 
    goto ldv_46489;
    case 27: 
#line 1013 
    ;
    
#line 1014 
    tmp = (unsigned short)0U;
    
#line 1014 
    smc->os.hwm.pass_NSA = tmp;
    
#line 1014 
    smc->os.hwm.pass_SMT = tmp;
    
#line 1015 
    smc->os.hwm.pass_DB = (unsigned short)0U;
    
#line 1016 
    smc->os.hwm.pass_llc_promisc = (unsigned short)1U;
    
#line 1017 
    mac_set_rx_mode(smc,6);
    
#line 1018 
    goto ldv_46489;
    case 28: 
#line 1019 
    ;
    
#line 1020 
    smc->os.hwm.pass_llc_promisc = (unsigned short)0U;
    
#line 1021 
    goto ldv_46489;
    case 29: 
#line 1022 
    ;
    
#line 1023 
    smc->os.hwm.pass_llc_promisc = (unsigned short)1U;
    
#line 1024 
    goto ldv_46489;
    case 1: 
#line 1025 
    ;
    case 2: 
#line 1026 
    ;
    case 3: 
#line 1027 
    ;
    case 4: 
#line 1028 
    ;
    case 5: 
#line 1029 
    ;
    case 6: 
#line 1030 
    ;
    default: 
#line 1031 
    ;
    
#line 1032 
    mac_set_rx_mode(smc,mode);
    
#line 1033 
    goto ldv_46489;
  }
  ldv_46489: 
#line 1035 
  ;
  
#line 1036 
  return;
}


#line 1041  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwmtm.c"
void process_receive(struct s_smc *smc)
{
  int i;
  int n;
  int frag_count;
  int used_frags;
  struct s_smt_rx_queue *queue;
  struct s_smt_fp_rxd volatile *r;
  struct s_smt_fp_rxd volatile *rxd;
  u_long rbctrl;
  u_long rfsw;
  u_short rx_used;
  u_char *virt;
  char *data;
  Mbuf *mb;
  u_char fc;
  int len;
  
#line 1059 
  smc->os.hwm.detec_count = 0;
  
#line 1060 
  queue = smc->hw.fp.rx[0];
  ldv_46542: 
#line 1061 
  ;
  
#line 1063 
  r = queue->rx_curr_get;
  
#line 1064 
  rx_used = queue->rx_used;
  
#line 1065 
  frag_count = 0;
  
#line 1084 
  n = 0;
  ldv_46525: 
#line 1085 
  ;
  
#line 1088 
  rbctrl = (unsigned long)r->rxd_rbctrl;
  
#line 1090 
  if ((rbctrl & 2147483648UL) != 0UL) 
#line 1093 
                                      goto rx_end; else ;
  
#line 1098 
  if ((unsigned int)rx_used == 0U) {
    
#line 1100 
    printk("\001",509,(char *)"HWM: Out of RxD condition detected");
    
#line 1104 
    smc->hw.hw_state = (unsigned short)0U;
    
#line 1105 
    mac_drv_clear_rx_queue(smc);
    
#line 1106 
    smc->hw.hw_state = (unsigned short)1U;
    
#line 1107 
    mac_drv_fill_rxd(smc);
    
#line 1108 
    smc->os.hwm.detec_count = 0;
    
#line 1109 
    goto rx_end;
  }
  else ;
  
#line 1111 
  rfsw = (unsigned long)r->rxd_rfsw;
  
#line 1112 
  if ((((rbctrl << 5) ^ rbctrl) & 1073741824UL) != 0UL) {
    
#line 1128 
    rfsw = 0UL;
    
#line 1129 
    if (frag_count != 0) 
#line 1130 
                         goto ldv_46524; else ;
  }
  else ;
  
#line 1133 
  n = (int)((rbctrl & (unsigned long)65535U) + (unsigned long)n);
  
#line 1134 
  r = r->rxd_next;
  
#line 1135 
  frag_count += 1;
  
#line 1136 
  rx_used = (u_short)((int)rx_used - 1);
  
#line 1137 
  if ((rbctrl & 536870912UL) == 0UL) 
#line 1139 
                                     goto ldv_46525; else 
#line 1142 
                                                          goto ldv_46524;
  ldv_46524: 
#line 1143 
  ;
  
#line 1138 
  used_frags = frag_count;
  
#line 1144 
  goto ldv_46527;
  ldv_46526: 
#line 1145 
  ;
  
#line 1146 
  r = r->rxd_next;
  
#line 1148 
  frag_count += 1;
  
#line 1149 
  rx_used = (u_short)((int)rx_used - 1);
  ldv_46527: 
#line 1150 
  ;
  
#line 1144 
  if ((unsigned int)rx_used != 0U && (r->rxd_rbctrl & 33554432U) == 0U) 
    
#line 1146 
    goto ldv_46526; else 
#line 1149 
                         goto ldv_46528;
  ldv_46528: 
#line 1150 
  ;
  
#line 1156 
  rxd = queue->rx_curr_get;
  
#line 1157 
  queue->rx_curr_get = r;
  
#line 1158 
  queue->rx_free = (unsigned short)((int)queue->rx_free + (int)((unsigned short)frag_count));
  
#line 1159 
  queue->rx_used = rx_used;
  
#line 1164 
  rxd->rxd_rbctrl &= 3221225471U;
  
#line 1166 
  r = rxd;
  
#line 1166 
  i = frag_count;
  
#line 1166 
  goto ldv_46530;
  ldv_46529: 
#line 1167 
  ;
  
#line 1168 
  dma_complete(smc,(union s_fp_descr volatile *)r,2);
  
#line 1166 
  r = r->rxd_next;
  
#line 1166 
  i -= 1;
  ldv_46530: 
#line 1167 
  ;
  
#line 1166 
  if (i != 0) 
#line 1168 
              goto ldv_46529; else 
#line 1171 
                                   goto ldv_46531;
  ldv_46531: 
#line 1172 
  ;
  
#line 1170 
  smc->hw.fp.err_stats.err_valid += 1UL;
  
#line 1171 
  smc->mib.m[0].fddiMACCopied_Ct += 1UL;
  
#line 1174 
  len = (int)((rfsw & (unsigned long)65535U) + (unsigned long)4294967292U);
  
#line 1180 
  if ((rfsw & 1226833920UL) != 0UL) {
    
#line 1181 
    if ((rfsw & 1073741824UL) != 0UL) 
#line 1183 
                                      smc->hw.fp.err_stats.err_abort += 1UL; else ;
    
#line 1188 
    if ((rfsw & 134217728UL) != 0UL) 
#line 1190 
                                     smc->hw.fp.err_stats.err_e_indicator += 1UL; else ;
    
#line 1192 
    if ((rfsw & 16777216UL) != 0UL) 
#line 1194 
                                    smc->hw.fp.err_stats.err_crc += 1UL; else ;
    
#line 1196 
    if ((rfsw & 2097152UL) != 0UL) 
#line 1198 
                                   smc->hw.fp.err_stats.err_imp_frame += 1UL; else ;
    
#line 1200 
    goto abort_frame;
  }
  else ;
  
#line 1202 
  if (len > 4491) {
    
#line 1204 
    smc->hw.fp.err_stats.err_too_long += 1UL;
    
#line 1205 
    goto abort_frame;
  }
  else ;
  
#line 1211 
  if (len <= 4) 
#line 1213 
                goto abort_frame; else ;
  
#line 1216 
  if (n + -4 != len) {
    
#line 1218 
    smc->os.hwm.rx_len_error += 1UL;
    
#line 1219 
    goto abort_frame;
  }
  else ;
  
#line 1225 
  virt = (u_char *)rxd->rxd_virt;
  
#line 1227 
  if ((((((int)*(virt + 12U) == (int)smc->hw.fddi_canon_addr.a[5] && (int)*(virt + 11U) == (int)smc->hw.fddi_canon_addr.a[4]) && (int)*(virt + 10U) == (int)smc->hw.fddi_canon_addr.a[3]) && (int)*(virt + 9U) == (int)smc->hw.fddi_canon_addr.a[2]) && (int)*(virt + 8U) == (int)smc->hw.fddi_canon_addr.a[1]) && ((int)*(virt + 7U) & -2) == (int)smc->hw.fddi_canon_addr.a[0]) 
    
#line 1233 
    goto abort_frame; else ;
  
#line 1239 
  if ((rfsw & 1048576UL) != 0UL) {
    
#line 1245 
    if ((unsigned int)smc->os.hwm.pass_llc_promisc == 0U) {
      
#line 1246 
      if (((int)*(virt + 1U) & 1) == 0) {
        
#line 1247 
        if ((((((int)*(virt + 6U) != (int)smc->hw.fddi_canon_addr.a[5] || (int)*(virt + 5U) != (int)smc->hw.fddi_canon_addr.a[4]) || (int)*(virt + 4U) != (int)smc->hw.fddi_canon_addr.a[3]) || (int)*(virt + 3U) != (int)smc->hw.fddi_canon_addr.a[2]) || (int)*(virt + 2U) != (int)smc->hw.fddi_canon_addr.a[1]) || (int)*(virt + 1U) != (int)smc->hw.fddi_canon_addr.a[0]) 
          
#line 1254 
          goto abort_frame; else ;
      }
      else ;
    }
    else ;
    
#line 1263 
    mac_drv_rx_complete(smc,rxd,frag_count,len);
  }
  else {
    char tmp;
    
#line 1266 
    mb = smt_get_mbuf(smc);
    
#line 1266 
    if (mb == (Mbuf *)0) {
      
#line 1267 
      smc->hw.fp.err_stats.err_no_buf += 1UL;
      
#line 1269 
      goto abort_frame;
    }
    else ;
    
#line 1271 
    data = (char *)(& mb->m_data) + ((unsigned long)mb->m_off + 18446744073709551615U);
    
#line 1279 
    r = rxd;
    
#line 1279 
    i = used_frags;
    
#line 1279 
    goto ldv_46534;
    ldv_46533: 
#line 1280 
    ;
    
#line 1280 
    n = (int)r->rxd_rbctrl & 65535;
    
#line 1282 
    memcpy((void *)data,(void const *)r->rxd_virt,(unsigned long)n);
    
#line 1283 
    data += n;
    
#line 1279 
    r = r->rxd_next;
    
#line 1279 
    i -= 1;
    ldv_46534: 
#line 1280 
    ;
    
#line 1279 
    if (i != 0) 
#line 1281 
                goto ldv_46533; else 
#line 1284 
                                     goto ldv_46535;
    ldv_46535: 
#line 1285 
    ;
    
#line 1285 
    data = (char *)(& mb->m_data) + ((unsigned long)mb->m_off + 18446744073709551615U);
    
#line 1287 
    tmp = *data;
    
#line 1287 
    *((char *)(& mb->m_data)) = tmp;
    
#line 1287 
    fc = (unsigned char)tmp;
    
#line 1288 
    mb->m_len = (unsigned int)(len + -1);
    
#line 1289 
    data += 1;
    
#line 1294 
    switch ((int)fc) {
      case 65: 
#line 1295 
      ;
      
#line 1296 
      smc->hw.fp.err_stats.err_smt_frame += 1UL;
      
#line 1299 
      if ((unsigned int)smc->os.hwm.pass_SMT != 0U) 
#line 1301 
                                                    mac_drv_rx_complete(smc,rxd,frag_count,len); else 
                                                                    
#line 1306 
                                                                    mac_drv_requeue_rxd(smc,rxd,frag_count);
      
#line 1309 
      smt_received_pack(smc,mb,(int)(rfsw >> 25));
      
#line 1310 
      goto ldv_46537;
      case 79: 
#line 1311 
      ;
      
#line 1312 
      smc->hw.fp.err_stats.err_smt_frame += 1UL;
      
#line 1318 
      if ((unsigned int)smc->os.hwm.pass_NSA != 0U || ((unsigned int)smc->os.hwm.pass_SMT != 0U && (rfsw & 67108864UL) == 0UL)) 
        
#line 1322 
        mac_drv_rx_complete(smc,rxd,frag_count,len); else 
#line 1327 
                                                          mac_drv_requeue_rxd(smc,rxd,frag_count);
      
#line 1330 
      smt_received_pack(smc,mb,(int)(rfsw >> 25));
      
#line 1331 
      goto ldv_46537;
      case 194: 
#line 1332 
      ;
      
#line 1333 
      if ((unsigned int)smc->os.hwm.pass_DB != 0U) 
#line 1335 
                                                   mac_drv_rx_complete(smc,rxd,frag_count,len); else 
                                                                    
#line 1340 
                                                                    mac_drv_requeue_rxd(smc,rxd,frag_count);
      
#line 1342 
      smt_free_mbuf(smc,mb);
      
#line 1343 
      goto ldv_46537;
      default: 
#line 1344 
      ;
      
#line 1349 
      smt_free_mbuf(smc,mb);
      
#line 1351 
      mac_drv_requeue_rxd(smc,rxd,frag_count);
      
#line 1352 
      if (((int)fc & 240) == 192) 
#line 1353 
                                  smc->hw.fp.err_stats.err_mac_frame += 1UL; else 
                                                                    
#line 1355 
                                                                    smc->hw.fp.err_stats.err_imp_frame += 1UL;
      
#line 1357 
      goto ldv_46537;
    }
    ldv_46537: 
#line 1359 
    ;
  }
  
#line 1364 
  goto ldv_46541;
  abort_frame: 
#line 1366 
  ;
  
#line 1368 
  mac_drv_requeue_rxd(smc,rxd,frag_count);
  ldv_46541: 
#line 1369 
  ;
  
#line 1063 
  goto ldv_46542;
  rx_end: 
#line 1373 
  ;
  
#line 1377 
  return;
}


#line 1380  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwmtm.c"
static void smt_to_llc(struct s_smc *smc, Mbuf *mb)
{
  u_char fc;
  
#line 1385 
  smc->os.hwm.r.len = mb->m_len;
  
#line 1386 
  smc->os.hwm.r.mb_pos = (char *)(& mb->m_data) + (int)mb->m_off;
  
#line 1387 
  fc = (unsigned char)*(smc->os.hwm.r.mb_pos);
  
#line 1388 
  mac_drv_rx_init(smc,(int)mb->m_len,(int)fc,smc->os.hwm.r.mb_pos,(int)mb->m_len);
  
#line 1390 
  smt_free_mbuf(smc,mb);
  
#line 1391 
  return;
}


#line 1415  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwmtm.c"
void hwm_rx_frag(struct s_smc *smc, char *virt, u_long phys, int len, int frame_status)
{
  struct s_smt_fp_rxd volatile *r;
  __le32 rbctrl;
  
#line 1423 
  r = smc->hw.fp.rx_q[0].rx_curr_put;
  
#line 1424 
  r->rxd_virt = virt;
  
#line 1425 
  r->rxd_rbadr = (unsigned int)phys;
  
#line 1426 
  rbctrl = (((((unsigned int)frame_status << 26) & 1610612736U) | (((unsigned int)frame_status << 21U) & 33554432U)) | (unsigned int)len) | 2287271936U;
  
#line 1430 
  r->rxd_rbctrl = rbctrl;
  
#line 1433 
  iowrite32(16U,smc->hw.iop + 112U);
  
#line 1434 
  smc->hw.fp.rx_q[0].rx_free = (u_short)((int)smc->hw.fp.rx_q[0].rx_free - 1);
  
#line 1435 
  smc->hw.fp.rx_q[0].rx_used = (u_short)((int)smc->hw.fp.rx_q[0].rx_used + 1);
  
#line 1436 
  smc->hw.fp.rx_q[0].rx_curr_put = r->rxd_next;
  
#line 1437 
  return;
}


#line 1463  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwmtm.c"
void mac_drv_clear_rx_queue(struct s_smc *smc)
{
  struct s_smt_fp_rxd volatile *r;
  struct s_smt_fp_rxd volatile *next_rxd;
  struct s_smt_rx_queue *queue;
  int frag_count;
  int i;
  
#line 1471 
  if ((unsigned int)smc->hw.hw_state != 0U) {
    
#line 1473 
    printk("\001",512,(char *)"HWM: mac_drv_clear_rx_queue was called although the hardware wasn\'t stopped");
    
#line 1474 
    goto return_label;
  }
  else ;
  
#line 1477 
  queue = smc->hw.fp.rx[0];
  
#line 1483 
  r = queue->rx_curr_get;
  
#line 1484 
  goto ldv_46572;
  ldv_46571: 
#line 1485 
  ;
  
#line 1487 
  r->rxd_rbctrl &= 2147483647U;
  
#line 1488 
  frag_count = 1;
  
#line 1490 
  r = r->rxd_next;
  
#line 1492 
  goto ldv_46566;
  ldv_46565: 
#line 1493 
  ;
  
#line 1495 
  r->rxd_rbctrl &= 2147483647U;
  
#line 1497 
  r = r->rxd_next;
  
#line 1499 
  frag_count += 1;
  ldv_46566: 
#line 1500 
  ;
  
#line 1492 
  if (queue->rx_curr_put != r && (r->rxd_rbctrl & 33554432U) == 0U) 
#line 1495 
                                                                    goto ldv_46565; else 
                                                                    
#line 1498 
                                                                    goto ldv_46567;
  ldv_46567: 
#line 1499 
  ;
  
#line 1502 
  next_rxd = r;
  
#line 1504 
  r = queue->rx_curr_get;
  
#line 1504 
  i = frag_count;
  
#line 1504 
  goto ldv_46569;
  ldv_46568: 
#line 1505 
  ;
  
#line 1506 
  dma_complete(smc,(union s_fp_descr volatile *)r,2);
  
#line 1504 
  r = r->rxd_next;
  
#line 1504 
  i -= 1;
  ldv_46569: 
#line 1505 
  ;
  
#line 1504 
  if (i != 0) 
#line 1506 
              goto ldv_46568; else 
#line 1509 
                                   goto ldv_46570;
  ldv_46570: 
#line 1510 
  ;
  
#line 1511 
  mac_drv_clear_rxd(smc,queue->rx_curr_get,frag_count);
  
#line 1513 
  queue->rx_curr_get = next_rxd;
  
#line 1514 
  queue->rx_used = (unsigned short)((int)queue->rx_used - (int)((unsigned short)frag_count));
  
#line 1515 
  queue->rx_free = (unsigned short)((int)queue->rx_free + (int)((unsigned short)frag_count));
  ldv_46572: 
#line 1516 
  ;
  
#line 1484 
  if ((unsigned int)queue->rx_used != 0U) 
#line 1486 
                                          goto ldv_46571; else 
#line 1489 
                                                               goto ldv_46573;
  ldv_46573: 
#line 1490 
  ;
  return_label: 
#line 1491 
                return;
}


#line 1550  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwmtm.c"
int hwm_tx_init(struct s_smc *smc, u_char fc, int frag_count, int frame_len, int frame_status)
{
  
#line 1554 
  smc->os.hwm.tx_p = smc->hw.fp.tx[frame_status & 1];
  
#line 1555 
  smc->os.hwm.tx_descr = (((unsigned long)(frame_len + -1) << 27) & 402653184UL) | 1073741824UL;
  
#line 1556 
  smc->os.hwm.tx_len = frame_len;
  
#line 1558 
  if (((int)fc & -136) == 80) 
#line 1559 
                              frame_status |= 32;
  else {
    
#line 1562 
    switch ((int)fc) {
      case 65: 
#line 1563 
      ;
      case 79: 
#line 1564 
      ;
      
#line 1565 
      frame_status |= 32;
      
#line 1566 
      goto ldv_46583;
      case 67: 
#line 1567 
      ;
      
#line 1568 
      frame_status |= 4;
      
#line 1569 
      goto ldv_46583;
      case 66: 
#line 1570 
      ;
      
#line 1571 
      frame_status |= 36;
      
#line 1572 
      goto ldv_46583;
      default: 
#line 1573 
      ;
      
#line 1574 
      printk("\001",510,(char *)"HWM: A protocol layer has tried to send a frame with an invalid frame control");
    }
    ldv_46583: 
#line 1576 
    ;
  }
  
#line 1577 
  if ((unsigned int)smc->hw.mac_ring_is_up == 0U) {
    
#line 1578 
    frame_status &= -33;
    
#line 1579 
    frame_status |= 64;
  }
  else ;
  
#line 1582 
  if ((int)(smc->os.hwm.tx_p)->tx_free < frag_count) {
    
#line 1584 
    mac_drv_clear_txd(smc);
    
#line 1585 
    if ((int)(smc->os.hwm.tx_p)->tx_free < frag_count) {
      
#line 1587 
      frame_status &= -33;
      
#line 1588 
      frame_status |= 128;
    }
    else ;
  }
  else ;
  
#line 1598 
  return frame_status;
}


#line 1628  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwmtm.c"
void hwm_tx_frag(struct s_smc *smc, char *virt, u_long phys, int len, int frame_status)
{
  struct s_smt_fp_txd volatile *t;
  struct s_smt_tx_queue *queue;
  __le32 tbctrl;
  
#line 1635 
  queue = smc->os.hwm.tx_p;
  
#line 1643 
  t = queue->tx_curr_put;
  
#line 1646 
  if ((frame_status & 32) != 0) {
    
#line 1649 
    t->txd_virt = virt;
    
#line 1650 
    t->txd_txdscr = (unsigned int)smc->os.hwm.tx_descr;
    
#line 1651 
    t->txd_tbadr = (unsigned int)phys;
    
#line 1652 
    tbctrl = ((((unsigned int)frame_status << 26) & 1744830464U) | (unsigned int)len) | 2153054208U;
    
#line 1655 
    t->txd_tbctrl = tbctrl;
    
#line 1659 
    iowrite32(16U,queue->tx_bmu_ctl);
    
#line 1669 
    queue->tx_free = (u_short)((int)queue->tx_free - 1);
    
#line 1670 
    queue->tx_used = (u_short)((int)queue->tx_used + 1);
    
#line 1671 
    queue->tx_curr_put = t->txd_next;
    
#line 1672 
    if ((frame_status & 8) != 0) 
#line 1673 
                                 smc->mib.m[0].fddiMACTransmit_Ct += 1UL; else ;
  }
  else ;
  
#line 1676 
  if ((frame_status & 4) != 0) {
    
#line 1678 
    if ((frame_status & 16) != 0) {
      Mbuf *tmp;
      
#line 1679 
      tmp = smt_get_mbuf(smc);
      
#line 1679 
      smc->os.hwm.tx_mb = tmp;
      
#line 1679 
      if (tmp == (Mbuf *)0) 
#line 1680 
                            smc->hw.fp.err_stats.err_no_buf += 1UL; else 
                                                                    
#line 1684 
                                                                    smc->os.hwm.tx_data = (char *)(& (smc->os.hwm.tx_mb)->m_data) + ((unsigned long)(smc->os.hwm.tx_mb)->m_off + 18446744073709551615U);
    }
    else ;
    
#line 1694 
    if (smc->os.hwm.tx_mb != (Mbuf *)0) {
      
#line 1697 
      memcpy((void *)smc->os.hwm.tx_data,(void const *)virt,(unsigned long)len);
      
#line 1698 
      smc->os.hwm.tx_data += len;
      
#line 1700 
      if ((frame_status & 8) != 0) {
        
#line 1714 
        smc->os.hwm.tx_data = (char *)(& (smc->os.hwm.tx_mb)->m_data) + ((unsigned long)(smc->os.hwm.tx_mb)->m_off + 18446744073709551615U);
        
#line 1716 
        *((char *)(& (smc->os.hwm.tx_mb)->m_data)) = *(smc->os.hwm.tx_data);
        
#line 1718 
        smc->os.hwm.tx_data += 1;
        
#line 1719 
        (smc->os.hwm.tx_mb)->m_len = (unsigned int)(smc->os.hwm.tx_len + -1);
        
#line 1722 
        smt_received_pack(smc,smc->os.hwm.tx_mb,128);
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 1726 
  return;
}


#line 1734  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwmtm.c"
static void queue_llc_rx(struct s_smc *smc, Mbuf *mb)
{
  
#line 1737 
  smc->os.hwm.queued_rx_frames += 1;
  
#line 1738 
  mb->m_next = (struct s_mbuf *)0;
  
#line 1739 
  if (smc->os.hwm.llc_rx_pipe == (Mbuf *)0) 
#line 1740 
                                            smc->os.hwm.llc_rx_pipe = mb; else 
                                                                    
#line 1743 
                                                                    (smc->os.hwm.llc_rx_tail)->m_next = mb;
  
#line 1745 
  smc->os.hwm.llc_rx_tail = mb;
  
#line 1750 
  if (smc->os.hwm.isr_flag == 0) 
#line 1751 
                                 smt_force_irq(smc); else ;
  
#line 1752 
  return;
}


#line 1758  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwmtm.c"
static Mbuf *get_llc_rx(struct s_smc *smc)
{
  Mbuf *mb;
  
#line 1762 
  mb = smc->os.hwm.llc_rx_pipe;
  
#line 1762 
  if (mb != (Mbuf *)0) {
    
#line 1763 
    smc->os.hwm.queued_rx_frames -= 1;
    
#line 1764 
    smc->os.hwm.llc_rx_pipe = mb->m_next;
  }
  else ;
  
#line 1767 
  return mb;
}


#line 1774  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwmtm.c"
static void queue_txd_mb(struct s_smc *smc, Mbuf *mb)
{
  
#line 1777 
  smc->os.hwm.queued_txd_mb += 1;
  
#line 1778 
  mb->m_next = (struct s_mbuf *)0;
  
#line 1779 
  if (smc->os.hwm.txd_tx_pipe == (Mbuf *)0) 
#line 1780 
                                            smc->os.hwm.txd_tx_pipe = mb; else 
                                                                    
#line 1783 
                                                                    (smc->os.hwm.txd_tx_tail)->m_next = mb;
  
#line 1785 
  smc->os.hwm.txd_tx_tail = mb;
  
#line 1786 
  return;
}


#line 1791  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwmtm.c"
static Mbuf *get_txd_mb(struct s_smc *smc)
{
  Mbuf *mb;
  
#line 1795 
  mb = smc->os.hwm.txd_tx_pipe;
  
#line 1795 
  if (mb != (Mbuf *)0) {
    
#line 1796 
    smc->os.hwm.queued_txd_mb -= 1;
    
#line 1797 
    smc->os.hwm.txd_tx_pipe = mb->m_next;
  }
  else ;
  
#line 1800 
  return mb;
}


#line 1806  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwmtm.c"
void smt_send_mbuf(struct s_smc *smc, Mbuf *mb, int fc)
{
  char *data;
  int len;
  int n;
  int i;
  int frag_count;
  int frame_status;
  char *virt[3U];
  int frag_len[3U];
  struct s_smt_tx_queue *queue;
  struct s_smt_fp_txd volatile *t;
  u_long phys;
  __le32 tbctrl;
  
#line 1824 
  mb->m_off = (short)((int)mb->m_off - 1);
  
#line 1825 
  mb->m_len += 1U;
  
#line 1826 
  data = (char *)(& mb->m_data) + (int)mb->m_off;
  
#line 1827 
  *data = (char)fc;
  
#line 1828 
  if (fc == 67) 
#line 1829 
                *data = (char)65; else ;
  
#line 1834 
  frag_count = 0;
  
#line 1835 
  len = (int)mb->m_len;
  
#line 1836 
  goto ldv_46631;
  ldv_46630: 
#line 1837 
  ;
  
#line 1837 
  n = (int)((long)4096U - ((long)data & (long)4095U));
  
#line 1838 
  if (n >= len) 
#line 1839 
                n = len; else ;
  
#line 1842 
  virt[frag_count] = data;
  
#line 1843 
  frag_len[frag_count] = n;
  
#line 1844 
  frag_count += 1;
  
#line 1845 
  len -= n;
  
#line 1846 
  data += n;
  ldv_46631: 
#line 1847 
  ;
  
#line 1836 
  if (len != 0) 
#line 1838 
                goto ldv_46630; else 
#line 1841 
                                     goto ldv_46632;
  ldv_46632: 
#line 1842 
  ;
  
#line 1852 
  queue = smc->hw.fp.tx[1];
  
#line 1853 
  if (fc == 194 || fc == 67) 
#line 1854 
                             frame_status = 4;
  else {
    
#line 1857 
    frame_status = 32;
    
#line 1858 
    if (((unsigned int)smc->os.hwm.pass_NSA != 0U && fc == 79) || ((unsigned int)smc->os.hwm.pass_SMT != 0U && fc == 65)) 
      
#line 1860 
      frame_status |= 4; else ;
  }
  
#line 1863 
  if ((unsigned int)smc->hw.mac_ring_is_up == 0U || (int)queue->tx_free < frag_count) {
    
#line 1864 
    frame_status &= -33;
    
#line 1865 
    if (frame_status != 0) ;
    else {
      
#line 1870 
      smt_free_mbuf(smc,mb);
      
#line 1871 
      goto return_label;
    }
  }
  else ;
  
#line 1876 
  if ((frame_status & 32) != 0 && (frame_status & 4) != 0) 
#line 1877 
                                                           mb->sm_use_count = 2; else ;
  
#line 1880 
  if ((frame_status & 32) != 0) {
    
#line 1881 
    t = queue->tx_curr_put;
    
#line 1882 
    frame_status |= 16;
    
#line 1883 
    i = 0;
    
#line 1883 
    goto ldv_46634;
    ldv_46633: 
#line 1884 
    ;
    
#line 1885 
    if (frag_count + -1 == i) {
      
#line 1886 
      frame_status |= 8;
      
#line 1887 
      t->txd_txdscr = (((mb->m_len + 4294967295U) << 27) & 402653184U) | 1073741824U;
    }
    else ;
    
#line 1890 
    t->txd_virt = virt[i];
    
#line 1891 
    phys = dma_master(smc,(void *)virt[i],frag_len[i],129);
    
#line 1893 
    t->txd_tbadr = (unsigned int)phys;
    
#line 1894 
    tbctrl = ((((unsigned int)frame_status << 26) & 1610612736U) | (unsigned int)frag_len[i]) | 2186608640U;
    
#line 1897 
    t->txd_tbctrl = tbctrl;
    
#line 1900 
    iowrite32(16U,queue->tx_bmu_ctl);
    
#line 1905 
    frame_status &= -17;
    
#line 1906 
    t = t->txd_next;
    
#line 1906 
    queue->tx_curr_put = t;
    
#line 1907 
    queue->tx_free = (u_short)((int)queue->tx_free - 1);
    
#line 1908 
    queue->tx_used = (u_short)((int)queue->tx_used + 1);
    
#line 1883 
    i += 1;
    ldv_46634: 
#line 1884 
    ;
    
#line 1883 
    if (i < frag_count) 
#line 1885 
                        goto ldv_46633; else 
#line 1888 
                                             goto ldv_46635;
    ldv_46635: 
#line 1889 
    ;
    
#line 1910 
    smc->mib.m[0].fddiMACTransmit_Ct += 1UL;
    
#line 1911 
    queue_txd_mb(smc,mb);
  }
  else ;
  
#line 1914 
  if ((frame_status & 4) != 0) 
#line 1916 
                               queue_llc_rx(smc,mb); else ;
  
#line 1923 
  mac_drv_clear_txd(smc);
  return_label: 
#line 1924 
                return;
}


#line 1941  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwmtm.c"
static void mac_drv_clear_txd(struct s_smc *smc)
{
  struct s_smt_tx_queue *queue;
  struct s_smt_fp_txd volatile *t1;
  Mbuf *mb;
  u_long tbctrl;
  int i;
  int frag_count;
  int n;
  
#line 1945 
  struct s_smt_fp_txd volatile *t2 = (struct s_smt_fp_txd volatile *)0;
  
#line 1953 
  i = 0;
  
#line 1953 
  goto ldv_46655;
  ldv_46654: 
#line 1954 
  ;
  
#line 1954 
  queue = smc->hw.fp.tx[i];
  
#line 1955 
  t1 = queue->tx_curr_get;
  ldv_46653: 
#line 1956 
  ;
  
#line 1959 
  frag_count = 0;
  ldv_46648: 
#line 1960 
  ;
  
#line 1964 
  tbctrl = (unsigned long)t1->txd_tbctrl;
  
#line 1966 
  if ((tbctrl & 2147483648UL) != 0UL || (unsigned int)queue->tx_used == 0U) 
    
#line 1968 
    goto free_next_queue; else ;
  
#line 1970 
  t1 = t1->txd_next;
  
#line 1971 
  frag_count += 1;
  
#line 1972 
  if ((tbctrl & 536870912UL) == 0UL) 
#line 1974 
                                     goto ldv_46648; else 
#line 1977 
                                                          goto ldv_46649;
  ldv_46649: 
#line 1978 
  ;
  
#line 1974 
  t1 = queue->tx_curr_get;
  
#line 1975 
  n = frag_count;
  
#line 1975 
  goto ldv_46651;
  ldv_46650: 
#line 1976 
  ;
  
#line 1976 
  tbctrl = (unsigned long)t1->txd_tbctrl;
  
#line 1977 
  dma_complete(smc,(union s_fp_descr volatile *)t1,(int)(((tbctrl >> 18) & (unsigned long)128U) | (unsigned long)1U));
  
#line 1981 
  t2 = t1;
  
#line 1982 
  t1 = t1->txd_next;
  
#line 1975 
  n -= 1;
  ldv_46651: 
#line 1976 
  ;
  
#line 1975 
  if (n != 0) 
#line 1977 
              goto ldv_46650; else 
#line 1980 
                                   goto ldv_46652;
  ldv_46652: 
#line 1981 
  ;
  
#line 1985 
  if ((tbctrl & 33554432UL) != 0UL) {
    
#line 1986 
    mb = get_txd_mb(smc);
    
#line 1987 
    smt_free_mbuf(smc,mb);
  }
  else 
#line 1992 
       mac_drv_tx_complete(smc,t2);
  
#line 1999 
  queue->tx_curr_get = t1;
  
#line 2000 
  queue->tx_free = (unsigned short)((int)queue->tx_free + (int)((unsigned short)frag_count));
  
#line 2001 
  queue->tx_used = (unsigned short)((int)queue->tx_used - (int)((unsigned short)frag_count));
  
#line 1959 
  goto ldv_46653;
  free_next_queue: 
#line 2003 
  ;
  
#line 1953 
  i += 1;
  ldv_46655: 
#line 1954 
  ;
  
#line 1953 
  if (i <= 1) 
#line 1955 
              goto ldv_46654; else 
#line 1958 
                                   goto ldv_46656;
  ldv_46656: 
#line 1959 
  ;
  
#line 1960 
  return;
}


#line 2031  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwmtm.c"
void mac_drv_clear_tx_queue(struct s_smc *smc)
{
  struct s_smt_fp_txd volatile *t;
  struct s_smt_tx_queue *queue;
  int tx_used;
  int i;
  
#line 2038 
  if ((unsigned int)smc->hw.hw_state != 0U) {
    
#line 2040 
    printk("\001",511,(char *)"HWM: mac_drv_clear_tx_queue was called although the hardware wasn\'t stopped");
    
#line 2041 
    goto return_label;
  }
  else ;
  
#line 2044 
  i = 0;
  
#line 2044 
  goto ldv_46668;
  ldv_46667: 
#line 2045 
  ;
  
#line 2045 
  queue = smc->hw.fp.tx[i];
  
#line 2051 
  t = queue->tx_curr_get;
  
#line 2052 
  tx_used = (int)queue->tx_used;
  
#line 2053 
  goto ldv_46665;
  ldv_46664: 
#line 2054 
  ;
  
#line 2056 
  t->txd_tbctrl &= 2147483647U;
  
#line 2058 
  t = t->txd_next;
  
#line 2059 
  tx_used -= 1;
  ldv_46665: 
#line 2060 
  ;
  
#line 2053 
  if (tx_used != 0) 
#line 2055 
                    goto ldv_46664; else 
#line 2058 
                                         goto ldv_46666;
  ldv_46666: 
#line 2059 
  ;
  
#line 2044 
  i += 1;
  ldv_46668: 
#line 2045 
  ;
  
#line 2044 
  if (i <= 1) 
#line 2046 
              goto ldv_46667; else 
#line 2049 
                                   goto ldv_46669;
  ldv_46669: 
#line 2050 
  ;
  
#line 2066 
  mac_drv_clear_txd(smc);
  
#line 2068 
  i = 0;
  
#line 2068 
  goto ldv_46671;
  ldv_46670: 
#line 2069 
  ;
  
#line 2069 
  queue = smc->hw.fp.tx[i];
  
#line 2070 
  t = queue->tx_curr_get;
  
#line 2077 
  if (i == 0) 
#line 2078 
              iowrite32(t->txd_ntdadr,smc->hw.iop + 720U); else 
#line 2081 
                                                                iowrite32(t->txd_ntdadr,smc->hw.iop + 656U);
  
#line 2084 
  queue->tx_curr_put = (queue->tx_curr_get)->txd_next;
  
#line 2085 
  queue->tx_curr_get = queue->tx_curr_put;
  
#line 2068 
  i += 1;
  ldv_46671: 
#line 2069 
  ;
  
#line 2068 
  if (i <= 1) 
#line 2070 
              goto ldv_46670; else 
#line 2073 
                                   goto ldv_46672;
  ldv_46672: 
#line 2074 
  ;
  return_label: 
#line 2075 
                return;
}

unsigned short __builtin_bswap16(unsigned short);

void __builtin_unreachable(void);


#line 7  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/fvtp/.tmp_skfddi.c"
void ldv_inline_asm(void);


#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/export.h"
extern struct module __this_module;


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr, unsigned long volatile *addr)
{
  
#line 74 
  if (0 != 0) 
#line 76 
              ldv_inline_asm(); else 
#line 79 
                                     ldv_inline_asm();
  
#line 80 
  return;
}


#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/swab.h"
__inline static __u16 __fswab16(__u16 val)
{
  __u16 tmp;
  
#line 49 
  tmp = __builtin_bswap16((unsigned short)((int)val));
  
#line 49 
  return tmp;
}


#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_debug.h"
void __dynamic_pr_debug(struct _ddebug *, char const * , ...);


#line 248  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
void __might_fault(char const *, int);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/page_64.h"
unsigned long __phys_addr(unsigned long);


#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
void __raw_spin_lock_init(raw_spinlock_t *, char const *, struct lock_class_key *);


#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_api_smp.h"
void _raw_spin_lock(raw_spinlock_t *);


#line 41 
void _raw_spin_unlock(raw_spinlock_t *);


#line 45 
void _raw_spin_unlock_irqrestore(raw_spinlock_t *, unsigned long);


#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock)
{
  raw_spinlock_t *__retres;
  
#line 301 
  __retres = & lock->__anonCompField_spinlock_18.rlock;
  
#line 301 
  return __retres;
}


#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock(spinlock_t *lock)
{
  
#line 312 
  _raw_spin_lock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 313 
  return;
}


#line 358 
static void ldv_spin_lock_78(spinlock_t *lock);


#line 362 
static void ldv_spin_lock_88(spinlock_t *lock);


#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock(spinlock_t *lock)
{
  
#line 365 
  _raw_spin_unlock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 366 
  return;
}


#line 407 
static void ldv_spin_unlock_79(spinlock_t *lock);


#line 411 
static void ldv_spin_unlock_87(spinlock_t *lock);


#line 450  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
{
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
  }
  
#line 452 
  _raw_spin_unlock_irqrestore(& lock->__anonCompField_spinlock_18.rlock,flags);
  
#line 453 
  return;
}


#line 482 
static void ldv_spin_unlock_irqrestore_81(spinlock_t *lock, unsigned long flags);


#line 486 
static void ldv_spin_unlock_irqrestore_83(spinlock_t *lock, unsigned long flags);


#line 490 
static void ldv_spin_unlock_irqrestore_85(spinlock_t *lock, unsigned long flags);


#line 494 
static void ldv_spin_unlock_irqrestore_86(spinlock_t *lock, unsigned long flags);


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
void __ldv_spin_lock(spinlock_t *);


#line 70 
static void ldv___ldv_spin_lock_80(spinlock_t *ldv_func_arg1);


#line 74 
static void ldv___ldv_spin_lock_82(spinlock_t *ldv_func_arg1);


#line 78 
static void ldv___ldv_spin_lock_84(spinlock_t *ldv_func_arg1);


#line 86 
void ldv_spin_model_lock(char *);


#line 87 
void ldv_spin_model_unlock(char *);


#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
static char const * const boot_msg = "SysKonnect FDDI PCI Adapter driver v";

#line 215  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/capability.h"
bool capable(int);


#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
extern unsigned long volatile jiffies;


#line 181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
void *ioremap_nocache(resource_size_t, unsigned long);


#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static void *ioremap(resource_size_t offset, unsigned long size)
{
  void *tmp;
  
#line 192 
  tmp = ioremap_nocache(offset,size);
  
#line 192 
  return tmp;
}


#line 195 
void iounmap(void volatile *);


#line 650  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
unsigned long _copy_from_user(void *, void const *, unsigned int);


#line 652 
unsigned long _copy_to_user(void *, void const *, unsigned int);


#line 662 
void copy_from_user_overflow(void);


#line 664 
void copy_to_user_overflow(void);


#line 672 
void __copy_from_user_overflow(void);


#line 677 
void __copy_to_user_overflow(void);


#line 693  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_from_user(void *to, void const *from, unsigned long n)
{
  
#line 695 
  int sz = -1;
  
#line 697 
  __might_fault("./arch/x86/include/asm/uaccess.h",697);
  
#line 717 
  if ((long)(sz < 0) != 0L || (long)((unsigned long)sz >= n) != 0L) 
#line 718 
                                                                    n = _copy_from_user(to,from,(unsigned int)n);
  else 
    
#line 719 
    if (0 != 0) 
#line 720 
                copy_from_user_overflow(); else 
#line 722 
                                                __copy_from_user_overflow();
  
#line 724 
  return n;
}


#line 728  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_to_user(void *to, void const *from, unsigned long n)
{
  
#line 730 
  int sz = -1;
  
#line 732 
  __might_fault("./arch/x86/include/asm/uaccess.h",732);
  
#line 735 
  if ((long)(sz < 0) != 0L || (long)((unsigned long)sz >= n) != 0L) 
#line 736 
                                                                    n = _copy_to_user(to,from,(unsigned int)n);
  else 
    
#line 737 
    if (0 != 0) 
#line 738 
                copy_to_user_overflow(); else 
#line 740 
                                              __copy_to_user_overflow();
  
#line 742 
  return n;
}


#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
static int ldv_request_irq_76(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev);


#line 153 
static void ldv_free_irq_77(unsigned int ldv_func_arg1, void *ldv_func_arg2);


#line 864  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static void *dev_get_drvdata(struct device const *dev)
{
  void *__retres;
  
#line 866 
  __retres = dev->driver_data;
  
#line 866 
  return __retres;
}


#line 869  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev, void *data)
{
  
#line 871 
  dev->driver_data = data;
  
#line 872 
  return;
}


#line 951  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
int pci_enable_device(struct pci_dev *);


#line 968 
void pci_disable_device(struct pci_dev *);


#line 971 
void pci_set_master(struct pci_dev *);


#line 1094 
int pci_request_regions(struct pci_dev *, char const *);


#line 1096 
void pci_release_regions(struct pci_dev *);


#line 1146 
static int ldv___pci_register_driver_89(struct pci_driver *ldv_func_arg1, struct module *ldv_func_arg2, char const *ldv_func_arg3);


#line 1158 
static void ldv_pci_unregister_driver_90(struct pci_driver *ldv_func_arg1);


#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction)
{
  int __retres;
  
#line 76 
  __retres = (unsigned int)dma_direction <= 2U;
  
#line 76 
  return __retres;
}


#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address, unsigned int n)
{
  
#line 133 
  return;
}


#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-debug.h"
void debug_dma_map_page(struct device *, struct page *, size_t, size_t, int, dma_addr_t, bool);


#line 44 
void debug_dma_unmap_page(struct device *, dma_addr_t, size_t, int, bool);


#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
extern struct dma_map_ops *dma_ops;


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev)
{
  struct dma_map_ops *__retres;
  
#line 37 
  if ((long)(dev == (struct device *)0) != 0L || dev->archdata.dma_ops == (struct dma_map_ops *)0) {
    
#line 38 
    __retres = dma_ops;
    
#line 38 
    goto return_label;
  }
  else {
    
#line 40 
    __retres = dev->archdata.dma_ops;
    
#line 40 
    goto return_label;
  }
  return_label: 
#line 37 
                return __retres;
}


#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_single_attrs(struct device *dev, void *ptr, size_t size, enum dma_data_direction dir, struct dma_attrs *attrs)
{
  dma_addr_t addr;
  int tmp_0;
  unsigned long tmp_1;
  unsigned long tmp_2;
  
#line 15 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 18 
  kmemcheck_mark_initialized(ptr,(unsigned int)size);
  
#line 19 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 19 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 21 
    ldv_inline_asm();
    
#line 19 
    ;
  }
  else ;
  
#line 20 
  ;
  
#line 20 
  ;
  
#line 20 
  ;
  
#line 20 
  ;
  
#line 20 
  tmp_1 = __phys_addr((unsigned long)ptr);
  
#line 20 
  ;
  
#line 20 
  addr = (*(ops->map_page))(dev,(struct page *)(-24189255811072) + (tmp_1 >> 12),(unsigned long)ptr & 4095UL,size,dir,attrs);
  
#line 23 
  ;
  
#line 23 
  ;
  
#line 23 
  ;
  
#line 23 
  ;
  
#line 23 
  tmp_2 = __phys_addr((unsigned long)ptr);
  
#line 23 
  ;
  
#line 23 
  debug_dma_map_page(dev,(struct page *)(-24189255811072) + (tmp_2 >> 12),(unsigned long)ptr & 4095UL,size,(int)dir,addr,(_Bool)1);
  
#line 26 
  return addr;
}


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_single_attrs(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir, struct dma_attrs *attrs)
{
  int tmp_0;
  
#line 34 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 36 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 36 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 38 
    ldv_inline_asm();
    
#line 36 
    ;
  }
  else ;
  
#line 37 
  if (ops->unmap_page != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction , struct dma_attrs *))0) 
    
#line 38 
    (*(ops->unmap_page))(dev,addr,size,dir,attrs); else ;
  
#line 39 
  debug_dma_unmap_page(dev,addr,size,(int)dir,(_Bool)1);
  
#line 40 
  return;
}


#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
void *dma_alloc_attrs(struct device *, size_t, dma_addr_t *, gfp_t, struct dma_attrs *);


#line 136 
void dma_free_attrs(struct device *, size_t, void *, dma_addr_t, struct dma_attrs *);


#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/pci-dma-compat.h"
__inline static void *pci_alloc_consistent(struct pci_dev *hwdev, size_t size, dma_addr_t *dma_handle)
{
  void *tmp_0;
  struct device *tmp;
  
#line 19 
  ;
  
#line 19 
  ;
  
#line 19 
  if (hwdev != (struct pci_dev *)0) 
#line 19 
                                    tmp = & hwdev->dev; else 
#line 19 
                                                             tmp = (struct device *)0;
  
#line 19 
  tmp_0 = dma_alloc_attrs(tmp,size,dma_handle,32U,(struct dma_attrs *)0);
  
#line 19 
  return tmp_0;
}


#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/pci-dma-compat.h"
__inline static void pci_free_consistent(struct pci_dev *hwdev, size_t size, void *vaddr, dma_addr_t dma_handle)
{
  struct device *tmp;
  
#line 34 
  ;
  
#line 34 
  ;
  
#line 34 
  ;
  
#line 34 
  if (hwdev != (struct pci_dev *)0) 
#line 34 
                                    tmp = & hwdev->dev; else 
#line 34 
                                                             tmp = (struct device *)0;
  
#line 34 
  dma_free_attrs(tmp,size,vaddr,dma_handle,(struct dma_attrs *)0);
  
#line 35 
  return;
}


#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/pci-dma-compat.h"
__inline static dma_addr_t pci_map_single(struct pci_dev *hwdev, void *ptr, size_t size, int direction)
{
  dma_addr_t tmp_0;
  struct device *tmp;
  
#line 40 
  ;
  
#line 40 
  ;
  
#line 40 
  ;
  
#line 40 
  if (hwdev != (struct pci_dev *)0) 
#line 40 
                                    tmp = & hwdev->dev; else 
#line 40 
                                                             tmp = (struct device *)0;
  
#line 40 
  tmp_0 = dma_map_single_attrs(tmp,ptr,size,(enum dma_data_direction)direction,(struct dma_attrs *)0);
  
#line 40 
  return tmp_0;
}


#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/pci-dma-compat.h"
__inline static void pci_unmap_single(struct pci_dev *hwdev, dma_addr_t dma_addr, size_t size, int direction)
{
  struct device *tmp;
  
#line 47 
  ;
  
#line 47 
  ;
  
#line 47 
  ;
  
#line 47 
  if (hwdev != (struct pci_dev *)0) 
#line 47 
                                    tmp = & hwdev->dev; else 
#line 47 
                                                             tmp = (struct device *)0;
  
#line 47 
  dma_unmap_single_attrs(tmp,dma_addr,size,(enum dma_data_direction)direction,(struct dma_attrs *)0);
  
#line 48 
  return;
}


#line 1471  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev)
{
  void *tmp;
  
#line 1473 
  tmp = dev_get_drvdata((struct device const *)(& pdev->dev));
  
#line 1473 
  return tmp;
}


#line 1476  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev, void *data)
{
  
#line 1478 
  dev_set_drvdata(& pdev->dev,data);
  
#line 1479 
  return;
}


#line 775  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
void consume_skb(struct sk_buff *);


#line 783 
struct sk_buff *__alloc_skb(unsigned int, gfp_t, int, int);


#line 787  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct sk_buff *alloc_skb(unsigned int size, gfp_t priority)
{
  struct sk_buff *tmp;
  
#line 790 
  tmp = __alloc_skb(size,priority,0,-1);
  
#line 790 
  return tmp;
}


#line 1331  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void __skb_queue_head_init(struct sk_buff_head *list)
{
  struct sk_buff *tmp;
  
#line 1333 
  tmp = (struct sk_buff *)list;
  
#line 1333 
  list->next = tmp;
  
#line 1333 
  list->prev = tmp;
  
#line 1334 
  list->qlen = 0U;
  
#line 1335 
  return;
}


#line 1345  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_queue_head_init(struct sk_buff_head *list)
{
  
#line 1347 
  spinlock_check(& list->lock);
  {
    struct lock_class_key __key;
    
#line 1347 
    __raw_spin_lock_init(& list->lock.__anonCompField_spinlock_18.rlock,"&(&list->lock)->rlock",& __key);
  }
  
#line 1348 
  __skb_queue_head_init(list);
  
#line 1349 
  return;
}


#line 1491 
void skb_queue_head(struct sk_buff_head *, struct sk_buff *);


#line 1508 
void skb_queue_tail(struct sk_buff_head *, struct sk_buff *);


#line 1540 
struct sk_buff *skb_dequeue(struct sk_buff_head *);


#line 1688 
unsigned char *skb_put(struct sk_buff *, unsigned int);


#line 1706 
unsigned char *skb_pull(struct sk_buff *, unsigned int);


#line 1789  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_reserve(struct sk_buff *skb, int len)
{
  
#line 1791 
  skb->data += len;
  
#line 1792 
  skb->tail += (unsigned int)len;
  
#line 1793 
  return;
}


#line 2057 
void skb_trim(struct sk_buff *, unsigned int);


#line 2130 
void skb_queue_purge(struct sk_buff_head *);


#line 2803  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_copy_to_linear_data(struct sk_buff *skb, void const *from, unsigned int const len)
{
  
#line 2807 
  memcpy((void *)skb->data,from,(unsigned long)len);
  
#line 2808 
  return;
}


#line 1822  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static struct netdev_queue *netdev_get_tx_queue(struct net_device const *dev, unsigned int index)
{
  struct netdev_queue *__retres;
  
#line 1825 
  __retres = dev->_tx + index;
  
#line 1825 
  return __retres;
}


#line 1880  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void *netdev_priv(struct net_device const *dev)
{
  void *__retres;
  
#line 1882 
  __retres = (void *)dev + 3008U;
  
#line 1882 
  return __retres;
}


#line 2205 
static void ldv_free_netdev_73(struct net_device *ldv_func_arg1);


#line 2209 
static void ldv_free_netdev_75(struct net_device *ldv_func_arg1);


#line 2515  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_start_queue(struct netdev_queue *dev_queue)
{
  
#line 2517 
  set_bit(0L,(unsigned long volatile *)(& dev_queue->state));
  
#line 2518 
  return;
}


#line 2526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_start_queue(struct net_device *dev)
{
  struct netdev_queue *tmp;
  
#line 2528 
  tmp = netdev_get_tx_queue((struct net_device const *)dev,0U);
  
#line 2528 
  netif_tx_start_queue(tmp);
  
#line 2529 
  return;
}


#line 2899 
void __dev_kfree_skb_irq(struct sk_buff *, enum skb_free_reason);


#line 2921  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void dev_kfree_skb_irq(struct sk_buff *skb)
{
  
#line 2923 
  __dev_kfree_skb_irq(skb,(enum skb_free_reason)SKB_REASON_DROPPED);
  
#line 2924 
  return;
}


#line 2941 
int netif_rx(struct sk_buff *);


#line 3355 
static int ldv_register_netdev_72(struct net_device *ldv_func_arg1);


#line 3360 
static void ldv_unregister_netdev_74(struct net_device *ldv_func_arg1);


#line 28  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fddidevice.h"
__be16 fddi_type_trans(struct sk_buff *, struct net_device *);


#line 29 
int fddi_change_mtu(struct net_device *, int);


#line 30 
struct net_device *alloc_fddidev(int);


#line 538  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/cmtdef.h"
void smt_stat_counter(struct s_smc *smc, int stat);


#line 539 
void smt_timer_poll(struct s_smc *smc);


#line 551 
void drv_reset_indication(struct s_smc *smc);


#line 562 
void rmt_state_change(struct s_smc *smc, int r_state);


#line 572 
u_short smt_online(struct s_smc *smc, int on);


#line 578 
int mac_add_multicast(struct s_smc *smc, struct fddi_addr *addr, int can);


#line 579 
void mac_update_multicast(struct s_smc *smc);


#line 580 
void mac_clear_multicast(struct s_smc *smc);


#line 473  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smc.h"
void card_stop(struct s_smc *smc);


#line 484 
void read_address(struct s_smc *smc, u_char *mac_addr);


#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
static int skfp_driver_init(struct net_device *dev);


#line 103 
static int skfp_open(struct net_device *dev);


#line 104 
static int skfp_close(struct net_device *dev);


#line 105 
static irqreturn_t skfp_interrupt(int irq, void *dev_id);


#line 106 
static struct net_device_stats *skfp_ctl_get_stats(struct net_device *dev);


#line 107 
static void skfp_ctl_set_multicast_list(struct net_device *dev);


#line 108 
static void skfp_ctl_set_multicast_list_wo_lock(struct net_device *dev);


#line 109 
static int skfp_ctl_set_mac_address(struct net_device *dev, void *addr);


#line 110 
static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);


#line 111 
static netdev_tx_t skfp_send_pkt(struct sk_buff *skb, struct net_device *dev);


#line 113 
static void send_queued_packets(struct s_smc *smc);


#line 114 
static void CheckSourceAddress(unsigned char *frame, unsigned char *hw_addr);


#line 115 
static void ResetAdapter(struct s_smc *smc);


#line 152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
static struct pci_device_id const skfddi_pci_tbl[2U] = {{.vendor = 4424U, .device = 16384U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 0U, .device = 0U, .subvendor = 0U, .subdevice = 0U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}};

#line 156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
struct pci_device_id const __mod_pci__skfddi_pci_tbl_device_table[2U];

#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
static int num_boards;

#line 164  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
static struct net_device_ops const skfp_netdev_ops = {.ndo_init = (int (*)(struct net_device *))0, .ndo_uninit = (void (*)(struct net_device *))0, .ndo_open = & skfp_open, .ndo_stop = & skfp_close, .ndo_start_xmit = & skfp_send_pkt, .ndo_select_queue = (u16 (*)(struct net_device *, struct sk_buff *, void *, u16 (*)(struct net_device *, struct sk_buff *)))0, .ndo_change_rx_flags = (void (*)(struct net_device *, int ))0, .ndo_set_rx_mode = & skfp_ctl_set_multicast_list, .ndo_set_mac_address = & skfp_ctl_set_mac_address, .ndo_validate_addr = (int (*)(struct net_device *))0, .ndo_do_ioctl = & skfp_ioctl, .ndo_set_config = (int (*)(struct net_device *, struct ifmap *))0, .ndo_change_mtu = & fddi_change_mtu, .ndo_neigh_setup = (int (*)(struct net_device *, struct neigh_parms *))0, .ndo_tx_timeout = (void (*)(struct net_device *))0, .ndo_get_stats64 = (struct rtnl_link_stats64 *(*)(struct net_device *, struct rtnl_link_stats64 *))0, .ndo_get_stats = & skfp_ctl_get_stats, .ndo_vlan_rx_add_vid = (int (*)(struct net_device *, __be16 , u16 ))0, .ndo_vlan_rx_kill_vid = (int (*)(struct net_device *, __be16 , u16 ))0, .ndo_poll_controller = (void (*)(struct net_device *))0, .ndo_netpoll_setup = (int (*)(struct net_device *, struct netpoll_info *))0, .ndo_netpoll_cleanup = (void (*)(struct net_device *))0, .ndo_busy_poll = (int (*)(struct napi_struct *))0, .ndo_set_vf_mac = (int (*)(struct net_device *, int , u8 *))0, .ndo_set_vf_vlan = (int (*)(struct net_device *, int , u16 , u8 ))0, .ndo_set_vf_rate = (int (*)(struct net_device *, int , int , int ))0, .ndo_set_vf_spoofchk = (int (*)(struct net_device *, int , bool ))0, .ndo_get_vf_config = (int (*)(struct net_device *, int , struct ifla_vf_info *))0, .ndo_set_vf_link_state = (int (*)(struct net_device *, int , int ))0, .ndo_get_vf_stats = (int (*)(struct net_device *, int , struct ifla_vf_stats *))0, .ndo_set_vf_port = (int (*)(struct net_device *, int , struct nlattr **))0, .ndo_get_vf_port = (int (*)(struct net_device *, int , struct sk_buff *))0, .ndo_set_vf_rss_query_en = (int (*)(struct net_device *, int , bool ))0, .ndo_setup_tc = (int (*)(struct net_device *, u8 ))0, .ndo_fcoe_enable = (int (*)(struct net_device *))0, .ndo_fcoe_disable = (int (*)(struct net_device *))0, .ndo_fcoe_ddp_setup = (int (*)(struct net_device *, u16 , struct scatterlist *, unsigned int ))0, .ndo_fcoe_ddp_done = (int (*)(struct net_device *, u16 ))0, .ndo_fcoe_ddp_target = (int (*)(struct net_device *, u16 , struct scatterlist *, unsigned int ))0, .ndo_fcoe_get_hbainfo = (int (*)(struct net_device *, struct netdev_fcoe_hbainfo *))0, .ndo_fcoe_get_wwn = (int (*)(struct net_device *, u64 *, int ))0, .ndo_rx_flow_steer = (int (*)(struct net_device *, struct sk_buff const *, u16 , u32 ))0, .ndo_add_slave = (int (*)(struct net_device *, struct net_device *))0, .ndo_del_slave = (int (*)(struct net_device *, struct net_device *))0, .ndo_fix_features = (netdev_features_t (*)(struct net_device *, netdev_features_t ))0, .ndo_set_features = (int (*)(struct net_device *, netdev_features_t ))0, .ndo_neigh_construct = (int (*)(struct neighbour *))0, .ndo_neigh_destroy = (void (*)(struct neighbour *))0, .ndo_fdb_add = (int (*)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 , u16 ))0, .ndo_fdb_del = (int (*)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 ))0, .ndo_fdb_dump = (int (*)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int ))0, .ndo_bridge_setlink = (int (*)(struct net_device *, struct nlmsghdr *, u16 ))0, .ndo_bridge_getlink = (int (*)(struct sk_buff *, u32 , u32 , struct net_device *, u32 , int ))0, .ndo_bridge_dellink = (int (*)(struct net_device *, struct nlmsghdr *, u16 ))0, .ndo_change_carrier = (int (*)(struct net_device *, bool ))0, .ndo_get_phys_port_id = (int (*)(struct net_device *, struct netdev_phys_item_id *))0, .ndo_get_phys_port_name = (int (*)(struct net_device *, char *, size_t ))0, .ndo_add_vxlan_port = (void (*)(struct net_device *, sa_family_t , __be16 ))0, .ndo_del_vxlan_port = (void (*)(struct net_device *, sa_family_t , __be16 ))0, .ndo_dfwd_add_station = (void *(*)(struct net_device *, struct net_device *))0, .ndo_dfwd_del_station = (void (*)(struct net_device *, void *))0, .ndo_dfwd_start_xmit = (netdev_tx_t (*)(struct sk_buff *, struct net_device *, void *))0, .ndo_get_lock_subclass = (int (*)(struct net_device *))0, .ndo_features_check = (netdev_features_t (*)(struct sk_buff *, struct net_device *, netdev_features_t ))0, .ndo_set_tx_maxrate = (int (*)(struct net_device *, int , u32 ))0, .ndo_get_iflink = (int (*)(struct net_device const *))0};

#line 204  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
static int skfp_init_one(struct pci_dev *pdev, struct pci_device_id const *ent)
{
  int __retres;
  struct net_device *dev;
  struct s_smc *smc;
  void *mem;
  int err;
  {
    
#line 212 
    struct _ddebug descriptor = {.modname = "skfp", .function = "skfp_init_one", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "entering skfp_init_one\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))212U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 212 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 212 
                                                        __dynamic_pr_debug(& descriptor,"entering skfp_init_one\n"); else ;
  }
  
#line 214 
  if (num_boards == 0) 
#line 215 
                       printk("%s\n",boot_msg); else ;
  
#line 217 
  err = pci_enable_device(pdev);
  
#line 218 
  if (err != 0) {
    
#line 219 
    __retres = err;
    
#line 219 
    goto return_label;
  }
  else ;
  
#line 221 
  err = pci_request_regions(pdev,"skfddi");
  
#line 222 
  if (err != 0) 
#line 223 
                goto err_out1; else ;
  
#line 225 
  pci_set_master(pdev);
  
#line 228 
  if ((pdev->resource[0].flags & 512UL) == 0UL) {
    
#line 229 
    printk("\001");
    
#line 230 
    err = -5;
    
#line 231 
    goto err_out2;
  }
  else ;
  
#line 234 
  mem = ioremap(pdev->resource[0].start,16384UL);
  
#line 244 
  if (mem == (void *)0) {
    
#line 245 
    printk("\001");
    
#line 247 
    err = -5;
    
#line 248 
    goto err_out2;
  }
  else ;
  
#line 251 
  dev = alloc_fddidev(8088);
  
#line 252 
  if (dev == (struct net_device *)0) {
    
#line 253 
    printk("\001");
    
#line 255 
    err = -12;
    
#line 256 
    goto err_out3;
  }
  else ;
  
#line 259 
  dev->irq = (int)pdev->irq;
  
#line 260 
  dev->netdev_ops = & skfp_netdev_ops;
  
#line 262 
  dev->dev.parent = & pdev->dev;
  
#line 265 
  smc = (struct s_smc *)netdev_priv((struct net_device const *)dev);
  
#line 266 
  smc->os.dev = dev;
  
#line 267 
  smc->os.bus_type = 0U;
  
#line 268 
  smc->os.pdev = *pdev;
  
#line 269 
  smc->os.QueueSkb = 20UL;
  
#line 270 
  smc->os.MaxFrameSize = 4550UL;
  
#line 271 
  smc->os.dev = dev;
  
#line 272 
  smc->hw.slot = (short)(-1);
  
#line 273 
  smc->hw.iop = mem;
  
#line 274 
  smc->os.ResetRequested = (unsigned char)0U;
  
#line 275 
  skb_queue_head_init(& smc->os.SendSkbQueue);
  
#line 277 
  dev->base_addr = (unsigned long)mem;
  
#line 279 
  err = skfp_driver_init(dev);
  
#line 280 
  if (err != 0) 
#line 281 
                goto err_out4; else ;
  
#line 283 
  err = ldv_register_netdev_72(dev);
  
#line 284 
  if (err != 0) 
#line 285 
                goto err_out5; else ;
  
#line 287 
  num_boards += 1;
  
#line 288 
  pci_set_drvdata(pdev,(void *)dev);
  
#line 290 
  if (((int)pdev->subsystem_device & 65280) == 21760 || ((int)pdev->subsystem_device & 65280) == 22528) 
    
#line 292 
    printk("%s: SysKonnect FDDI PCI adapter",(char *)(& dev->name),(int)pdev->subsystem_device); else 
                                                                    
#line 296 
                                                                    printk("%s: FDDI PCI adapter found\n",(char *)(& dev->name));
  
#line 298 
  __retres = 0;
  
#line 298 
  goto return_label;
  err_out5: 
#line 299 
  ;
  
#line 300 
  if (smc->os.SharedMemAddr != (void *)0) 
#line 301 
                                          pci_free_consistent(pdev,smc->os.SharedMemSize,smc->os.SharedMemAddr,smc->os.SharedMemDMA); else ;
  
#line 304 
  pci_free_consistent(pdev,4550UL,(void *)smc->os.LocalRxBuffer,smc->os.LocalRxBufferDMA);
  err_out4: 
#line 306 
  ;
  
#line 307 
  ldv_free_netdev_73(dev);
  err_out3: 
#line 308 
  ;
  
#line 310 
  iounmap((void volatile *)mem);
  err_out2: 
#line 314 
  ;
  
#line 315 
  pci_release_regions(pdev);
  err_out1: 
#line 316 
  ;
  
#line 317 
  pci_disable_device(pdev);
  
#line 318 
  __retres = err;
  return_label: 
#line 318 
                return __retres;
}


#line 324  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
static void skfp_remove_one(struct pci_dev *pdev)
{
  
#line 326 
  struct net_device *p = pci_get_drvdata(pdev);
  
#line 327 
  struct s_smc *lp = netdev_priv((struct net_device const *)p);
  
#line 329 
  ldv_unregister_netdev_74(p);
  
#line 331 
  if (lp->os.SharedMemAddr != (void *)0) {
    
#line 332 
    pci_free_consistent(& lp->os.pdev,lp->os.SharedMemSize,lp->os.SharedMemAddr,lp->os.SharedMemDMA);
    
#line 336 
    lp->os.SharedMemAddr = (void *)0;
  }
  else ;
  
#line 338 
  if (lp->os.LocalRxBuffer != (unsigned char *)0U) {
    
#line 339 
    pci_free_consistent(& lp->os.pdev,4550UL,(void *)lp->os.LocalRxBuffer,lp->os.LocalRxBufferDMA);
    
#line 343 
    lp->os.LocalRxBuffer = (unsigned char *)0U;
  }
  else ;
  
#line 346 
  iounmap((void volatile *)lp->hw.iop);
  
#line 350 
  pci_release_regions(pdev);
  
#line 351 
  ldv_free_netdev_75(p);
  
#line 353 
  pci_disable_device(pdev);
  
#line 354 
  return;
}


#line 381  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
static int skfp_driver_init(struct net_device *dev)
{
  int __retres;
  u_int tmp_1;
  int tmp_2;
  
#line 383 
  struct s_smc *smc = netdev_priv((struct net_device const *)dev);
  
#line 384 
  skfddi_priv *bp = & smc->os;
  
#line 385 
  int err = -5;
  {
    
#line 387 
    struct _ddebug descriptor = {.modname = "skfp", .function = "skfp_driver_init", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "entering skfp_driver_init\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))387U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 387 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 387 
                                                        __dynamic_pr_debug(& descriptor,"entering skfp_driver_init\n"); else ;
  }
  
#line 390 
  bp->base_addr = dev->base_addr;
  
#line 393 
  smc->hw.irq = (short)dev->irq;
  
#line 395 
  spinlock_check(& bp->DriverLock);
  {
    struct lock_class_key __key;
    
#line 395 
    __raw_spin_lock_init(& bp->DriverLock.__anonCompField_spinlock_18.rlock,"&(&bp->DriverLock)->rlock",& __key);
  }
  
#line 398 
  bp->LocalRxBuffer = (unsigned char *)pci_alloc_consistent(& bp->pdev,4550UL,& bp->LocalRxBufferDMA);
  
#line 399 
  if (bp->LocalRxBuffer == (unsigned char *)0U) {
    
#line 400 
    printk("could not allocate mem for ");
    
#line 401 
    printk("LocalRxBuffer: %d byte\n",4550);
    
#line 402 
    goto fail;
  }
  else ;
  
#line 406 
  tmp_1 = mac_drv_check_space();
  
#line 406 
  bp->SharedMemSize = (unsigned long)tmp_1;
  {
    
#line 407 
    struct _ddebug descriptor_0 = {.modname = "skfp", .function = "skfp_driver_init", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "Memory for HWM: %ld\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))407U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 407 
    if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 407 
                                                          __dynamic_pr_debug(& descriptor_0,"Memory for HWM: %ld\n",bp->SharedMemSize); else ;
  }
  
#line 408 
  if (bp->SharedMemSize != 0UL) {
    
#line 409 
    bp->SharedMemSize += 16UL;
    
#line 411 
    bp->SharedMemAddr = pci_alloc_consistent(& bp->pdev,bp->SharedMemSize,& bp->SharedMemDMA);
    
#line 414 
    if (bp->SharedMemAddr == (void *)0) {
      
#line 415 
      printk("could not allocate mem for ");
      
#line 416 
      printk("hardware module: %ld byte\n",bp->SharedMemSize);
      
#line 418 
      goto fail;
    }
    else ;
    
#line 420 
    bp->SharedMemHeap = 0UL;
  }
  else {
    
#line 423 
    bp->SharedMemAddr = (void *)0;
    
#line 424 
    bp->SharedMemHeap = 0UL;
  }
  
#line 427 
  memset(bp->SharedMemAddr,0,bp->SharedMemSize);
  
#line 429 
  card_stop(smc);
  {
    
#line 431 
    struct _ddebug descriptor_1 = {.modname = "skfp", .function = "skfp_driver_init", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "mac_drv_init()..\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))431U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 431 
    if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) 
#line 431 
                                                          __dynamic_pr_debug(& descriptor_1,"mac_drv_init()..\n"); else ;
  }
  
#line 432 
  tmp_2 = mac_drv_init(smc);
  
#line 432 
  if (tmp_2 != 0) {
    {
      
#line 433 
      struct _ddebug descriptor_2 = {.modname = "skfp", .function = "skfp_driver_init", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "mac_drv_init() failed\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))433U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 433 
      if ((long)(((int)descriptor_2.flags & 1) != 0) != 0L) 
#line 433 
                                                            __dynamic_pr_debug(& descriptor_2,"mac_drv_init() failed\n"); else ;
    }
    
#line 434 
    goto fail;
  }
  else ;
  
#line 436 
  read_address(smc,(u_char *)0U);
  {
    
#line 437 
    struct _ddebug descriptor_3 = {.modname = "skfp", .function = "skfp_driver_init", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "HW-Addr: %pMF\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))437U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 437 
    if ((long)(((int)descriptor_3.flags & 1) != 0) != 0L) 
#line 437 
                                                          __dynamic_pr_debug(& descriptor_3,"HW-Addr: %pMF\n",(u_char *)(& smc->hw.fddi_canon_addr.a)); else ;
  }
  
#line 438 
  memcpy((void *)dev->dev_addr,(void const *)(& smc->hw.fddi_canon_addr.a),6UL);
  
#line 440 
  smt_reset_defaults(smc,0);
  
#line 442 
  __retres = 0;
  
#line 442 
  goto return_label;
  fail: 
#line 444 
  ;
  
#line 445 
  if (bp->SharedMemAddr != (void *)0) {
    
#line 446 
    pci_free_consistent(& bp->pdev,bp->SharedMemSize,bp->SharedMemAddr,bp->SharedMemDMA);
    
#line 450 
    bp->SharedMemAddr = (void *)0;
  }
  else ;
  
#line 452 
  if (bp->LocalRxBuffer != (unsigned char *)0U) {
    
#line 453 
    pci_free_consistent(& bp->pdev,4550UL,(void *)bp->LocalRxBuffer,bp->LocalRxBufferDMA);
    
#line 455 
    bp->LocalRxBuffer = (unsigned char *)0U;
  }
  else ;
  
#line 457 
  __retres = err;
  return_label: 
#line 457 
                return __retres;
}


#line 482  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
static int skfp_open(struct net_device *dev)
{
  int __retres;
  int err;
  
#line 484 
  struct s_smc *smc = netdev_priv((struct net_device const *)dev);
  {
    
#line 487 
    struct _ddebug descriptor = {.modname = "skfp", .function = "skfp_open", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "entering skfp_open\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))487U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 487 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 487 
                                                        __dynamic_pr_debug(& descriptor,"entering skfp_open\n"); else ;
  }
  
#line 489 
  err = ldv_request_irq_76((unsigned int)dev->irq,& skfp_interrupt,128UL,(char const *)(& dev->name),(void *)dev);
  
#line 491 
  if (err != 0) {
    
#line 492 
    __retres = err;
    
#line 492 
    goto return_label;
  }
  else ;
  
#line 504 
  read_address(smc,(u_char *)0U);
  
#line 505 
  memcpy((void *)dev->dev_addr,(void const *)(& smc->hw.fddi_canon_addr.a),6UL);
  
#line 507 
  init_smt(smc,(u_char *)0U);
  
#line 508 
  smt_online(smc,1);
  
#line 509 
  iowrite32((unsigned int)smc->hw.is_imask,smc->hw.iop + 12U);
  
#line 512 
  mac_clear_multicast(smc);
  
#line 515 
  mac_drv_rx_mode(smc,4);
  
#line 517 
  netif_start_queue(dev);
  
#line 518 
  __retres = 0;
  return_label: 
#line 518 
                return __retres;
}


#line 549  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
static int skfp_close(struct net_device *dev)
{
  int __retres;
  
#line 551 
  struct s_smc *smc = netdev_priv((struct net_device const *)dev);
  
#line 552 
  skfddi_priv *bp = & smc->os;
  
#line 554 
  iowrite32(0U,smc->hw.iop + 12U);
  
#line 555 
  smt_reset_defaults(smc,1);
  
#line 556 
  card_stop(smc);
  
#line 557 
  mac_drv_clear_tx_queue(smc);
  
#line 558 
  mac_drv_clear_rx_queue(smc);
  
#line 560 
  netif_start_queue(dev);
  
#line 562 
  ldv_free_irq_77((unsigned int)dev->irq,(void *)dev);
  
#line 564 
  skb_queue_purge(& bp->SendSkbQueue);
  
#line 565 
  bp->QueueSkb = 20UL;
  
#line 567 
  __retres = 0;
  
#line 567 
  return __retres;
}


#line 606  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
static irqreturn_t skfp_interrupt(int irq, void *dev_id)
{
  irqreturn_t __retres;
  struct s_smc *smc;
  skfddi_priv *bp;
  unsigned int tmp_0;
  unsigned int tmp_1;
  
#line 608 
  struct net_device *dev = (struct net_device *)dev_id;
  
#line 612 
  smc = (struct s_smc *)netdev_priv((struct net_device const *)dev);
  
#line 613 
  bp = & smc->os;
  
#line 616 
  tmp_0 = ioread32(smc->hw.iop + 12U);
  
#line 616 
  if (tmp_0 == 0U) {
    
#line 618 
    __retres = IRQ_NONE;
    
#line 618 
    goto return_label;
  }
  else ;
  
#line 621 
  tmp_1 = ioread32(smc->hw.iop + 8U);
  
#line 621 
  ;
  
#line 621 
  if (((unsigned long)tmp_1 & smc->hw.is_imask) == 0UL) {
    
#line 623 
    __retres = IRQ_NONE;
    
#line 623 
    goto return_label;
  }
  else ;
  
#line 625 
  iowrite32(0U,smc->hw.iop + 12U);
  
#line 626 
  ldv_spin_lock_78(& bp->DriverLock);
  
#line 629 
  fddi_isr(smc);
  
#line 631 
  if ((unsigned int)smc->os.ResetRequested != 0U) {
    
#line 632 
    ResetAdapter(smc);
    
#line 633 
    smc->os.ResetRequested = (unsigned char)0U;
  }
  else ;
  
#line 635 
  ldv_spin_unlock_79(& bp->DriverLock);
  
#line 636 
  iowrite32((unsigned int)smc->hw.is_imask,smc->hw.iop + 12U);
  
#line 638 
  __retres = IRQ_HANDLED;
  return_label: 
#line 638 
                return __retres;
}


#line 673  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
static struct net_device_stats *skfp_ctl_get_stats(struct net_device *dev)
{
  struct net_device_stats *__retres;
  
#line 675 
  struct s_smc *bp = netdev_priv((struct net_device const *)dev);
  
#line 679 
  bp->os.MacStat.port_bs_flag[0] = 4660U;
  
#line 680 
  bp->os.MacStat.port_bs_flag[1] = 22136U;
  
#line 796 
  __retres = (struct net_device_stats *)(& bp->os.MacStat);
  
#line 796 
  return __retres;
}


#line 837  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
static void skfp_ctl_set_multicast_list(struct net_device *dev)
{
  unsigned long Flags;
  
#line 839 
  struct s_smc *smc = netdev_priv((struct net_device const *)dev);
  
#line 840 
  skfddi_priv *bp = & smc->os;
  
#line 843 
  ldv___ldv_spin_lock_80(& bp->DriverLock);
  
#line 844 
  skfp_ctl_set_multicast_list_wo_lock(dev);
  
#line 845 
  ldv_spin_unlock_irqrestore_81(& bp->DriverLock,Flags);
  
#line 846 
  return;
}


#line 850  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
static void skfp_ctl_set_multicast_list_wo_lock(struct net_device *dev)
{
  struct netdev_hw_addr *ha;
  
#line 852 
  struct s_smc *smc = netdev_priv((struct net_device const *)dev);
  
#line 856 
  if ((dev->flags & 256U) != 0U) {
    
#line 857 
    mac_drv_rx_mode(smc,3);
    {
      
#line 858 
      struct _ddebug descriptor = {.modname = "skfp", .function = "skfp_ctl_set_multicast_list_wo_lock", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "PROMISCUOUS MODE ENABLED\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))858U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 858 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 858 
                                                          __dynamic_pr_debug(& descriptor,"PROMISCUOUS MODE ENABLED\n"); else ;
    }
  }
  else {
    
#line 862 
    mac_drv_rx_mode(smc,4);
    {
      
#line 863 
      struct _ddebug descriptor_0 = {.modname = "skfp", .function = "skfp_ctl_set_multicast_list_wo_lock", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "PROMISCUOUS MODE DISABLED\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))863U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 863 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 863 
                                                            __dynamic_pr_debug(& descriptor_0,"PROMISCUOUS MODE DISABLED\n"); else ;
    }
    
#line 866 
    mac_clear_multicast(smc);
    
#line 867 
    mac_drv_rx_mode(smc,2);
    
#line 869 
    if ((dev->flags & 512U) != 0U) {
      
#line 870 
      mac_drv_rx_mode(smc,1);
      {
        
#line 871 
        struct _ddebug descriptor_1 = {.modname = "skfp", .function = "skfp_ctl_set_multicast_list_wo_lock", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "ENABLE ALL MC ADDRESSES\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))871U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 871 
        if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) 
#line 871 
                                                              __dynamic_pr_debug(& descriptor_1,"ENABLE ALL MC ADDRESSES\n"); else ;
      }
    }
    else 
      
#line 872 
      if (dev->mc.count != 0) 
        
#line 873 
        if (dev->mc.count <= 32) {
          struct netdev_hw_addr *tmp_0;
          struct netdev_hw_addr *tmp_1;
          {
            
#line 877 
            struct list_head const *__mptr = (struct list_head const *)dev->mc.list.next;
            
#line 877 
            tmp_0 = (struct netdev_hw_addr *)__mptr;
          }
          
#line 877 
          ha = tmp_0;
          
#line 877 
          goto ldv_47440;
          ldv_47439: 
#line 878 
          ;
          
#line 878 
          mac_add_multicast(smc,(struct fddi_addr *)(& ha->addr),1);
          {
            
#line 882 
            struct _ddebug descriptor_2 = {.modname = "skfp", .function = "skfp_ctl_set_multicast_list_wo_lock", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "ENABLE MC ADDRESS: %pMF\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))883U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
            
#line 882 
            if ((long)(((int)descriptor_2.flags & 1) != 0) != 0L) 
#line 882 
                                                                  __dynamic_pr_debug(& descriptor_2,"ENABLE MC ADDRESS: %pMF\n",(unsigned char *)(& ha->addr)); else ;
          }
          {
            
#line 877 
            struct list_head const *__mptr_0 = (struct list_head const *)ha->list.next;
            
#line 877 
            tmp_1 = (struct netdev_hw_addr *)__mptr_0;
          }
          
#line 877 
          ha = tmp_1;
          ldv_47440: 
#line 879 
          ;
          
#line 877 
          if (& ha->list != & dev->mc.list) 
#line 879 
                                            goto ldv_47439; else 
#line 882 
                                                                 goto ldv_47441;
          ldv_47441: 
#line 883 
          ;
        }
        else {
          
#line 888 
          mac_drv_rx_mode(smc,1);
          {
            
#line 889 
            struct _ddebug descriptor_3 = {.modname = "skfp", .function = "skfp_ctl_set_multicast_list_wo_lock", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "ENABLE ALL MC ADDRESSES\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))889U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
            
#line 889 
            if ((long)(((int)descriptor_3.flags & 1) != 0) != 0L) 
#line 889 
                                                                  __dynamic_pr_debug(& descriptor_3,"ENABLE ALL MC ADDRESSES\n"); else ;
          }
        }
      else {
        
#line 893 
        struct _ddebug descriptor_4 = {.modname = "skfp", .function = "skfp_ctl_set_multicast_list_wo_lock", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "DISABLE ALL MC ADDRESSES\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))893U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 893 
        if ((long)(((int)descriptor_4.flags & 1) != 0) != 0L) 
#line 893 
                                                              __dynamic_pr_debug(& descriptor_4,"DISABLE ALL MC ADDRESSES\n"); else ;
      }
    
#line 897 
    mac_update_multicast(smc);
  }
  
#line 899 
  return;
}


#line 921  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
static int skfp_ctl_set_mac_address(struct net_device *dev, void *addr)
{
  int __retres;
  unsigned long Flags;
  
#line 923 
  struct s_smc *smc = netdev_priv((struct net_device const *)dev);
  
#line 924 
  struct sockaddr *p_sockaddr = (struct sockaddr *)addr;
  
#line 925 
  skfddi_priv *bp = & smc->os;
  
#line 929 
  memcpy((void *)dev->dev_addr,(void const *)(& p_sockaddr->sa_data),6UL);
  
#line 930 
  ldv___ldv_spin_lock_82(& bp->DriverLock);
  
#line 931 
  ResetAdapter(smc);
  
#line 932 
  ldv_spin_unlock_irqrestore_83(& bp->DriverLock,Flags);
  
#line 934 
  __retres = 0;
  
#line 934 
  return __retres;
}


#line 961  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
{
  int __retres;
  struct s_skfp_ioctl ioc;
  unsigned long tmp_0;
  
#line 963 
  struct s_smc *smc = netdev_priv((struct net_device const *)dev);
  
#line 964 
  skfddi_priv *lp = & smc->os;
  
#line 966 
  int status = 0;
  
#line 968 
  tmp_0 = copy_from_user((void *)(& ioc),(void const *)rq->ifr_ifru.ifru_data,16UL);
  
#line 968 
  if (tmp_0 != 0UL) {
    
#line 969 
    __retres = -14;
    
#line 969 
    goto return_label;
  }
  else ;
  
#line 971 
  switch ((int)ioc.cmd) {
    unsigned long tmp_2;
    struct net_device_stats *tmp_1;
    int tmp_4;
    bool tmp_3;
    case 5: 
#line 972 
    ;
    
#line 973 
    ioc.len = (unsigned short)672U;
    
#line 974 
    ;
    
#line 974 
    tmp_1 = skfp_ctl_get_stats(dev);
    
#line 974 
    ;
    
#line 974 
    tmp_2 = copy_to_user((void *)ioc.data,(void const *)tmp_1,(unsigned long)ioc.len);
    
#line 974 
    if (tmp_2 != 0UL) 
#line 974 
                      status = -14; else 
#line 974 
                                         status = 0;
    
#line 976 
    goto ldv_47462;
    case 6: 
#line 977 
    ;
    
#line 978 
    tmp_3 = capable(12);
    
#line 978 
    if (tmp_3) 
#line 978 
               tmp_4 = 0; else 
#line 978 
                               tmp_4 = 1;
    
#line 978 
    if (tmp_4) 
#line 979 
               status = -1; else 
#line 981 
                                 memset((void *)(& lp->MacStat),0,672UL);
    
#line 983 
    goto ldv_47462;
    default: 
#line 984 
    ;
    
#line 985 
    printk("ioctl for %s: unknown cmd: %04x\n",(char *)(& dev->name),(int)ioc.cmd);
    
#line 986 
    status = -95;
  }
  ldv_47462: 
#line 990 
  ;
  
#line 990 
  __retres = status;
  return_label: 
#line 990 
                return __retres;
}


#line 1041  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
static netdev_tx_t skfp_send_pkt(struct sk_buff *skb, struct net_device *dev)
{
  netdev_tx_t __retres;
  void *tmp_0;
  
#line 1044 
  struct s_smc *smc = netdev_priv((struct net_device const *)dev);
  
#line 1045 
  skfddi_priv *bp = & smc->os;
  {
    
#line 1047 
    struct _ddebug descriptor = {.modname = "skfp", .function = "skfp_send_pkt", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "skfp_send_pkt\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1047U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1047 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1047 
                                                        __dynamic_pr_debug(& descriptor,"skfp_send_pkt\n"); else ;
  }
  
#line 1058 
  if (skb->len + 4294967283U > 4478U) {
    
#line 1059 
    bp->MacStat.gen.tx_errors += 1UL;
    
#line 1061 
    netif_start_queue(dev);
    
#line 1062 
    consume_skb(skb);
    
#line 1063 
    __retres = NETDEV_TX_OK;
    
#line 1063 
    goto return_label;
  }
  else ;
  
#line 1065 
  if (bp->QueueSkb == 0UL) {
    
#line 1067 
    netif_start_queue(dev);
    
#line 1068 
    __retres = NETDEV_TX_BUSY;
    
#line 1068 
    goto return_label;
  }
  else ;
  
#line 1070 
  bp->QueueSkb -= 1UL;
  
#line 1071 
  skb_queue_tail(& bp->SendSkbQueue,skb);
  
#line 1072 
  tmp_0 = netdev_priv((struct net_device const *)dev);
  
#line 1072 
  send_queued_packets((struct s_smc *)tmp_0);
  
#line 1073 
  if (bp->QueueSkb == 0UL) 
#line 1074 
                           netif_start_queue(dev); else ;
  
#line 1076 
  __retres = NETDEV_TX_OK;
  return_label: 
#line 1076 
                return __retres;
}


#line 1104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
static void send_queued_packets(struct s_smc *smc)
{
  struct sk_buff *skb;
  unsigned char fc;
  int queue;
  struct s_smt_fp_txd *txd;
  dma_addr_t dma_address;
  unsigned long Flags;
  int frame_status;
  
#line 1106 
  skfddi_priv *bp = & smc->os;
  {
    
#line 1116 
    struct _ddebug descriptor = {.modname = "skfp", .function = "send_queued_packets", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "send queued packets\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1116U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1116 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1116 
                                                        __dynamic_pr_debug(& descriptor,"send queued packets\n"); else ;
  }
  ldv_47490: 
#line 1118 
  ;
  
#line 1119 
  skb = skb_dequeue(& bp->SendSkbQueue);
  
#line 1121 
  if (skb == (struct sk_buff *)0) {
    {
      
#line 1122 
      struct _ddebug descriptor_0 = {.modname = "skfp", .function = "send_queued_packets", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "queue empty\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1122U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1122 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 1122 
                                                            __dynamic_pr_debug(& descriptor_0,"queue empty\n"); else ;
    }
    
#line 1123 
    goto return_label;
  }
  else ;
  
#line 1126 
  ldv___ldv_spin_lock_84(& bp->DriverLock);
  
#line 1127 
  fc = *(skb->data);
  
#line 1128 
  queue = (int)fc >= 0;
  
#line 1132 
  if (((int)fc & -136) == 80) {
    
#line 1134 
    if ((unsigned int)smc->ess.sync_bw_available == 0U) 
#line 1135 
                                                        fc = (unsigned char)((unsigned int)fc & 127U);
    else 
      
#line 1139 
      if ((int)smc->mib.fddiESSSynchTxMode != 0) 
#line 1141 
                                                 fc = (unsigned char)((unsigned int)fc | 128U); else ;
  }
  else ;
  
#line 1146 
  frame_status = hwm_tx_init(smc,(unsigned char)((int)fc),1,(int)skb->len,queue);
  
#line 1148 
  if ((frame_status & 36) == 0) {
    
#line 1151 
    if ((frame_status & 64) != 0) {
      
#line 1153 
      struct _ddebug descriptor_1 = {.modname = "skfp", .function = "send_queued_packets", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "Tx attempt while ring down.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1153U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1153 
      if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) 
#line 1153 
                                                            __dynamic_pr_debug(& descriptor_1,"Tx attempt while ring down.\n"); else ;
    }
    else 
      
#line 1154 
      if ((frame_status & 128) != 0) {
        
#line 1155 
        struct _ddebug descriptor_2 = {.modname = "skfp", .function = "send_queued_packets", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "%s: out of TXDs.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1155U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 1155 
        if ((long)(((int)descriptor_2.flags & 1) != 0) != 0L) 
#line 1155 
                                                              __dynamic_pr_debug(& descriptor_2,"%s: out of TXDs.\n",(char *)(& (bp->dev)->name)); else ;
      }
      else {
        
#line 1157 
        struct _ddebug descriptor_3 = {.modname = "skfp", .function = "send_queued_packets", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "%s: out of transmit resources", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1158U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 1157 
        if ((long)(((int)descriptor_3.flags & 1) != 0) != 0L) 
#line 1157 
                                                              __dynamic_pr_debug(& descriptor_3,"%s: out of transmit resources",(char *)(& (bp->dev)->name)); else ;
      }
    
#line 1163 
    skb_queue_head(& bp->SendSkbQueue,skb);
    
#line 1164 
    ldv_spin_unlock_irqrestore_85(& bp->DriverLock,Flags);
    
#line 1165 
    goto return_label;
  }
  else ;
  
#line 1169 
  bp->QueueSkb += 1UL;
  
#line 1172 
  CheckSourceAddress(skb->data,(unsigned char *)(& smc->hw.fddi_canon_addr.a));
  
#line 1174 
  txd = (struct s_smt_fp_txd *)smc->hw.fp.tx_q[queue].tx_curr_put;
  
#line 1176 
  dma_address = pci_map_single(& bp->pdev,(void *)skb->data,(unsigned long)skb->len,1);
  
#line 1178 
  if ((frame_status & 32) != 0) {
    
#line 1179 
    txd->txd_os.skb = skb;
    
#line 1180 
    txd->txd_os.dma_addr = dma_address;
  }
  else ;
  
#line 1182 
  hwm_tx_frag(smc,(char *)skb->data,(unsigned long)dma_address,(int)skb->len,frame_status | 26);
  
#line 1185 
  if ((frame_status & 32) == 0) {
    
#line 1186 
    pci_unmap_single(& bp->pdev,dma_address,(unsigned long)skb->len,1);
    
#line 1188 
    dev_kfree_skb_irq(skb);
  }
  else ;
  
#line 1190 
  ldv_spin_unlock_irqrestore_86(& bp->DriverLock,Flags);
  
#line 1119 
  goto ldv_47490;
  return_label: 
#line 1193 
                return;
}


#line 1205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
static void CheckSourceAddress(unsigned char *frame, unsigned char *hw_addr)
{
  unsigned char SRBit;
  
#line 1209 
  if (((unsigned long)*(frame + 7U) & 18446744073709551614UL) != 0UL) 
    
#line 1211 
    goto return_label; else ;
  
#line 1212 
  if ((unsigned int)*(frame + 11U) != 0U) 
#line 1213 
                                          goto return_label; else ;
  
#line 1214 
  SRBit = (unsigned char)((unsigned int)*(frame + 7U) & 1U);
  
#line 1215 
  memcpy((void *)(frame + 7U),(void const *)hw_addr,6UL);
  
#line 1216 
  *(frame + 8U) = (unsigned char)((int)*(frame + 8U) | (int)SRBit);
  return_label: 
#line 1217 
                return;
}


#line 1231  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
static void ResetAdapter(struct s_smc *smc)
{
  {
    
#line 1234 
    struct _ddebug descriptor = {.modname = "skfp", .function = "ResetAdapter", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "[fddi: ResetAdapter]\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1234U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1234 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1234 
                                                        __dynamic_pr_debug(& descriptor,"[fddi: ResetAdapter]\n"); else ;
  }
  
#line 1238 
  card_stop(smc);
  
#line 1241 
  mac_drv_clear_tx_queue(smc);
  
#line 1242 
  mac_drv_clear_rx_queue(smc);
  
#line 1246 
  smt_reset_defaults(smc,1);
  
#line 1248 
  init_smt(smc,(smc->os.dev)->dev_addr);
  
#line 1250 
  smt_online(smc,1);
  
#line 1251 
  iowrite32((unsigned int)smc->hw.is_imask,smc->hw.iop + 12U);
  
#line 1254 
  skfp_ctl_set_multicast_list_wo_lock(smc->os.dev);
  
#line 1255 
  return;
}


#line 1276  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
void llc_restart_tx(struct s_smc *smc)
{
  
#line 1278 
  skfddi_priv *bp = & smc->os;
  {
    
#line 1280 
    struct _ddebug descriptor = {.modname = "skfp", .function = "llc_restart_tx", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "[llc_restart_tx]\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1280U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1280 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1280 
                                                        __dynamic_pr_debug(& descriptor,"[llc_restart_tx]\n"); else ;
  }
  
#line 1283 
  ldv_spin_unlock_87(& bp->DriverLock);
  
#line 1284 
  send_queued_packets(smc);
  
#line 1285 
  ldv_spin_lock_88(& bp->DriverLock);
  
#line 1286 
  netif_start_queue(bp->dev);
  
#line 1287 
  return;
}


#line 1306  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
void *mac_drv_get_space(struct s_smc *smc, unsigned int size)
{
  void *__retres;
  void *virt;
  {
    
#line 1310 
    struct _ddebug descriptor = {.modname = "skfp", .function = "mac_drv_get_space", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "mac_drv_get_space (%d bytes), ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1310U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1310 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1310 
                                                        __dynamic_pr_debug(& descriptor,"mac_drv_get_space (%d bytes), ",size); else ;
  }
  
#line 1311 
  virt = smc->os.SharedMemAddr + smc->os.SharedMemHeap;
  
#line 1313 
  if (smc->os.SharedMemHeap + (unsigned long)size > smc->os.SharedMemSize) {
    
#line 1314 
    printk("Unexpected SMT memory size requested: %d\n",size);
    
#line 1315 
    __retres = (void *)0;
    
#line 1315 
    goto return_label;
  }
  else ;
  
#line 1317 
  smc->os.SharedMemHeap += (unsigned long)size;
  {
    
#line 1319 
    struct _ddebug descriptor_0 = {.modname = "skfp", .function = "mac_drv_get_space", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "mac_drv_get_space end\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1319U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1319 
    if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 1319 
                                                          __dynamic_pr_debug(& descriptor_0,"mac_drv_get_space end\n"); else ;
  }
  {
    
#line 1320 
    struct _ddebug descriptor_1 = {.modname = "skfp", .function = "mac_drv_get_space", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "virt addr: %lx\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1320U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1320 
    if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) 
#line 1320 
                                                          __dynamic_pr_debug(& descriptor_1,"virt addr: %lx\n",(unsigned long)virt); else ;
  }
  {
    
#line 1321 
    struct _ddebug descriptor_2 = {.modname = "skfp", .function = "mac_drv_get_space", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "bus  addr: %lx\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1323U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1321 
    if ((long)(((int)descriptor_2.flags & 1) != 0) != 0L) 
#line 1321 
                                                          __dynamic_pr_debug(& descriptor_2,"bus  addr: %lx\n",(unsigned long)(smc->os.SharedMemDMA + (unsigned long long)((long)virt - (long)smc->os.SharedMemAddr))); else ;
  }
  
#line 1324 
  __retres = virt;
  return_label: 
#line 1324 
                return __retres;
}


#line 1346  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
void *mac_drv_get_desc_mem(struct s_smc *smc, unsigned int size)
{
  void *__retres;
  char *virt;
  void *tmp_0;
  {
    
#line 1351 
    struct _ddebug descriptor = {.modname = "skfp", .function = "mac_drv_get_desc_mem", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "mac_drv_get_desc_mem\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1351U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1351 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1351 
                                                        __dynamic_pr_debug(& descriptor,"mac_drv_get_desc_mem\n"); else ;
  }
  
#line 1355 
  virt = (char *)mac_drv_get_space(smc,size);
  
#line 1357 
  size = 16U - ((unsigned int)((long)virt) & 15U);
  
#line 1358 
  size &= 15U;
  {
    
#line 1360 
    struct _ddebug descriptor_0 = {.modname = "skfp", .function = "mac_drv_get_desc_mem", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "Allocate %u bytes alignment gap ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1360U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1360 
    if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 1360 
                                                          __dynamic_pr_debug(& descriptor_0,"Allocate %u bytes alignment gap ",size); else ;
  }
  {
    
#line 1361 
    struct _ddebug descriptor_1 = {.modname = "skfp", .function = "mac_drv_get_desc_mem", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "for descriptor memory.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1361U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1361 
    if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) 
#line 1361 
                                                          __dynamic_pr_debug(& descriptor_1,"for descriptor memory.\n"); else ;
  }
  
#line 1363 
  tmp_0 = mac_drv_get_space(smc,size);
  
#line 1363 
  if (tmp_0 == (void *)0) {
    
#line 1364 
    printk("fddi: Unable to align descriptor memory.\n");
    
#line 1365 
    __retres = (void *)0;
    
#line 1365 
    goto return_label;
  }
  else ;
  
#line 1367 
  __retres = (void *)(virt + size);
  return_label: 
#line 1367 
                return __retres;
}


#line 1384  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
unsigned long mac_drv_virt2phys(struct s_smc *smc, void *virt)
{
  unsigned long __retres;
  
#line 1386 
  __retres = (unsigned long)(smc->os.SharedMemDMA + (unsigned long long)((long)virt - (long)smc->os.SharedMemAddr));
  
#line 1386 
  return __retres;
}


#line 1419  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
unsigned long dma_master(struct s_smc *smc, void *virt, int len, int flag)
{
  unsigned long __retres;
  
#line 1421 
  __retres = (unsigned long)(smc->os.SharedMemDMA + (unsigned long long)((long)virt - (long)smc->os.SharedMemAddr));
  
#line 1421 
  return __retres;
}


#line 1447  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
void dma_complete(struct s_smc *smc, union s_fp_descr volatile *descr, int flag)
{
  
#line 1461 
  if ((flag & 2) != 0) {
    
#line 1462 
    skfddi_priv *bp = & smc->os;
    
#line 1463 
    struct s_smt_fp_rxd volatile *r = & descr->r;
    
#line 1466 
    if (r->rxd_os.skb != (struct sk_buff *)0 && r->rxd_os.dma_addr != 0ULL) {
      
#line 1467 
      int MaxFrameSize = (int)bp->MaxFrameSize;
      
#line 1469 
      pci_unmap_single(& bp->pdev,r->rxd_os.dma_addr,(unsigned long)MaxFrameSize,2);
      
#line 1471 
      r->rxd_os.dma_addr = 0ULL;
    }
    else ;
  }
  else ;
  
#line 1474 
  return;
}


#line 1491  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
void mac_drv_tx_complete(struct s_smc *smc, struct s_smt_fp_txd volatile *txd)
{
  struct sk_buff *skb;
  {
    
#line 1495 
    struct _ddebug descriptor = {.modname = "skfp", .function = "mac_drv_tx_complete", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "entering mac_drv_tx_complete\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1495U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1495 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1495 
                                                        __dynamic_pr_debug(& descriptor,"entering mac_drv_tx_complete\n"); else ;
  }
  
#line 1498 
  skb = txd->txd_os.skb;
  
#line 1498 
  if (skb == (struct sk_buff *)0) {
    {
      
#line 1499 
      struct _ddebug descriptor_0 = {.modname = "skfp", .function = "mac_drv_tx_complete", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "TXD with no skb assigned.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1499U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1499 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 1499 
                                                            __dynamic_pr_debug(& descriptor_0,"TXD with no skb assigned.\n"); else ;
    }
    
#line 1500 
    goto return_label;
  }
  else ;
  
#line 1502 
  txd->txd_os.skb = (struct sk_buff *)0;
  
#line 1505 
  pci_unmap_single(& smc->os.pdev,txd->txd_os.dma_addr,(unsigned long)skb->len,1);
  
#line 1507 
  txd->txd_os.dma_addr = 0ULL;
  
#line 1509 
  smc->os.MacStat.gen.tx_packets += 1UL;
  
#line 1510 
  smc->os.MacStat.gen.tx_bytes += (unsigned long)skb->len;
  
#line 1513 
  dev_kfree_skb_irq(skb);
  {
    
#line 1515 
    struct _ddebug descriptor_1 = {.modname = "skfp", .function = "mac_drv_tx_complete", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "leaving mac_drv_tx_complete\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1515U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1515 
    if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) 
#line 1515 
                                                          __dynamic_pr_debug(& descriptor_1,"leaving mac_drv_tx_complete\n"); else ;
  }
  return_label: 
#line 1517 
                return;
}


#line 1573  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
void mac_drv_rx_complete(struct s_smc *smc, struct s_smt_fp_rxd volatile *rxd, int frag_count, int len)
{
  struct sk_buff *skb;
  unsigned char *virt;
  unsigned char *cp;
  unsigned short ri;
  u_int RifLength;
  
#line 1576 
  skfddi_priv *bp = & smc->os;
  {
    
#line 1582 
    struct _ddebug descriptor = {.modname = "skfp", .function = "mac_drv_rx_complete", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "entering mac_drv_rx_complete (len=%d)\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1582U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1582 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1582 
                                                        __dynamic_pr_debug(& descriptor,"entering mac_drv_rx_complete (len=%d)\n",len); else ;
  }
  
#line 1583 
  if (frag_count != 1) {
    
#line 1585 
    printk("fddi: Multi-fragment receive!\n");
    
#line 1586 
    goto RequeueRxd;
  }
  else ;
  
#line 1589 
  skb = rxd->rxd_os.skb;
  
#line 1590 
  if (skb == (struct sk_buff *)0) {
    {
      
#line 1591 
      struct _ddebug descriptor_0 = {.modname = "skfp", .function = "mac_drv_rx_complete", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "No skb in rxd\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1591U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1591 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 1591 
                                                            __dynamic_pr_debug(& descriptor_0,"No skb in rxd\n"); else ;
    }
    
#line 1592 
    smc->os.MacStat.gen.rx_errors += 1UL;
    
#line 1593 
    goto RequeueRxd;
  }
  else ;
  
#line 1595 
  virt = skb->data;
  
#line 1616 
  if (((int)*(virt + 7U) & 1) == 0) 
#line 1617 
                                    RifLength = 0U;
  else {
    int n;
    {
      
#line 1621 
      struct _ddebug descriptor_1 = {.modname = "skfp", .function = "mac_drv_rx_complete", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "RIF found\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1621U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1621 
      if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) 
#line 1621 
                                                            __dynamic_pr_debug(& descriptor_1,"RIF found\n"); else ;
    }
    
#line 1623 
    cp = virt + 13U;
    
#line 1625 
    if (0 != 0) 
#line 1625 
                ri = (unsigned short)(((int)*((__be16 *)cp) << 8) | ((int)*((__be16 *)cp) >> 8)); else 
                                                                    
#line 1625 
                                                                    ri = __fswab16((unsigned short)((int)*((__be16 *)cp)));
    
#line 1626 
    RifLength = (unsigned int)ri & 31U;
    
#line 1627 
    if ((int)(RifLength + 13U) > len) {
      
#line 1628 
      printk("fddi: Invalid RIF.\n");
      
#line 1629 
      goto RequeueRxd;
    }
    else ;
    
#line 1632 
    *(virt + 7U) = (unsigned char)((unsigned int)*(virt + 7U) & 254U);
    
#line 1635 
    virt = cp + RifLength;
    
#line 1636 
    n = 13;
    
#line 1636 
    goto ldv_47572;
    ldv_47571: 
#line 1637 
    ;
    
#line 1637 
    virt -= 1;
    
#line 1637 
    cp -= 1;
    
#line 1637 
    *virt = *cp;
    
#line 1636 
    n -= 1;
    ldv_47572: 
#line 1637 
    ;
    
#line 1636 
    if (n != 0) 
#line 1638 
                goto ldv_47571; else 
#line 1641 
                                     goto ldv_47573;
    ldv_47573: 
#line 1642 
    ;
    
#line 1639 
    skb_pull(skb,RifLength);
    
#line 1640 
    len = (int)((unsigned int)len - RifLength);
    
#line 1641 
    RifLength = 0U;
  }
  
#line 1645 
  smc->os.MacStat.gen.rx_packets += 1UL;
  
#line 1647 
  smc->os.MacStat.gen.rx_bytes += (unsigned long)len;
  
#line 1650 
  if (((int)*(virt + 1U) & 1) != 0) 
#line 1652 
                                    smc->os.MacStat.gen.multicast += 1UL; else ;
  
#line 1656 
  rxd->rxd_os.skb = (struct sk_buff *)0;
  
#line 1657 
  skb_trim(skb,(unsigned int)len);
  
#line 1658 
  skb->protocol = fddi_type_trans(skb,bp->dev);
  
#line 1660 
  netif_rx(skb);
  
#line 1662 
  if ((unsigned int)smc->hw.fp.rx_q[0].rx_used <= 5U) 
#line 1662 
                                                      mac_drv_fill_rxd(smc); else ;
  
#line 1663 
  goto return_label;
  RequeueRxd: 
#line 1665 
  ;
  {
    
#line 1666 
    struct _ddebug descriptor_2 = {.modname = "skfp", .function = "mac_drv_rx_complete", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "Rx: re-queue RXD.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1666U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1666 
    if ((long)(((int)descriptor_2.flags & 1) != 0) != 0L) 
#line 1666 
                                                          __dynamic_pr_debug(& descriptor_2,"Rx: re-queue RXD.\n"); else ;
  }
  
#line 1667 
  mac_drv_requeue_rxd(smc,rxd,frag_count);
  
#line 1668 
  smc->os.MacStat.gen.rx_errors += 1UL;
  return_label: 
#line 1669 
                return;
}


#line 1692  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
void mac_drv_requeue_rxd(struct s_smc *smc, struct s_smt_fp_rxd volatile *rxd, int frag_count)
{
  struct s_smt_fp_rxd volatile *next_rxd;
  struct s_smt_fp_rxd volatile *src_rxd;
  struct sk_buff *skb;
  int MaxFrameSize;
  unsigned char *v_addr;
  dma_addr_t b_addr;
  
#line 1702 
  if (frag_count != 1) 
#line 1704 
                       printk("fddi: Multi-fragment requeue!\n"); else ;
  
#line 1706 
  MaxFrameSize = (int)smc->os.MaxFrameSize;
  
#line 1707 
  src_rxd = rxd;
  
#line 1708 
  goto ldv_47590;
  ldv_47589: 
#line 1709 
  ;
  
#line 1709 
  next_rxd = src_rxd->rxd_next;
  
#line 1710 
  rxd = smc->hw.fp.rx_q[0].rx_curr_put;
  
#line 1712 
  skb = src_rxd->rxd_os.skb;
  
#line 1713 
  if (skb == (struct sk_buff *)0) {
    {
      
#line 1715 
      struct _ddebug descriptor = {.modname = "skfp", .function = "mac_drv_requeue_rxd", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "Requeue with no skb in rxd!\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1715U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1715 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1715 
                                                          __dynamic_pr_debug(& descriptor,"Requeue with no skb in rxd!\n"); else ;
    }
    
#line 1716 
    skb = alloc_skb((unsigned int)(MaxFrameSize + 3),32U);
    
#line 1717 
    if (skb != (struct sk_buff *)0) {
      
#line 1719 
      rxd->rxd_os.skb = skb;
      
#line 1720 
      skb_reserve(skb,3);
      
#line 1721 
      skb_put(skb,(unsigned int)MaxFrameSize);
      
#line 1722 
      v_addr = skb->data;
      
#line 1723 
      b_addr = pci_map_single(& smc->os.pdev,(void *)v_addr,(unsigned long)MaxFrameSize,2);
      
#line 1727 
      rxd->rxd_os.dma_addr = b_addr;
    }
    else {
      {
        
#line 1730 
        struct _ddebug descriptor_0 = {.modname = "skfp", .function = "mac_drv_requeue_rxd", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "Queueing invalid buffer!\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1730U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 1730 
        if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 1730 
                                                              __dynamic_pr_debug(& descriptor_0,"Queueing invalid buffer!\n"); else ;
      }
      
#line 1731 
      rxd->rxd_os.skb = (struct sk_buff *)0;
      
#line 1732 
      v_addr = smc->os.LocalRxBuffer;
      
#line 1733 
      b_addr = smc->os.LocalRxBufferDMA;
    }
  }
  else {
    
#line 1737 
    rxd->rxd_os.skb = skb;
    
#line 1738 
    v_addr = skb->data;
    
#line 1739 
    b_addr = pci_map_single(& smc->os.pdev,(void *)v_addr,(unsigned long)MaxFrameSize,2);
    
#line 1743 
    rxd->rxd_os.dma_addr = b_addr;
  }
  
#line 1745 
  hwm_rx_frag(smc,(char *)v_addr,(unsigned long)b_addr,MaxFrameSize,24);
  
#line 1748 
  src_rxd = next_rxd;
  
#line 1708 
  frag_count -= 1;
  ldv_47590: 
#line 1709 
  ;
  
#line 1708 
  if (frag_count > 0) 
#line 1710 
                      goto ldv_47589; else 
#line 1713 
                                           goto ldv_47591;
  ldv_47591: 
#line 1714 
  ;
  
#line 1715 
  return;
}


#line 1769  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
void mac_drv_fill_rxd(struct s_smc *smc)
{
  int MaxFrameSize;
  unsigned char *v_addr;
  unsigned long b_addr;
  struct sk_buff *skb;
  struct s_smt_fp_rxd volatile *rxd;
  {
    
#line 1777 
    struct _ddebug descriptor = {.modname = "skfp", .function = "mac_drv_fill_rxd", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "entering mac_drv_fill_rxd\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1777U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1777 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1777 
                                                        __dynamic_pr_debug(& descriptor,"entering mac_drv_fill_rxd\n"); else ;
  }
  
#line 1782 
  MaxFrameSize = (int)smc->os.MaxFrameSize;
  
#line 1784 
  goto ldv_47605;
  ldv_47604: 
#line 1785 
  ;
  {
    
#line 1785 
    struct _ddebug descriptor_0 = {.modname = "skfp", .function = "mac_drv_fill_rxd", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = ".\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1785U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1785 
    if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 1785 
                                                          __dynamic_pr_debug(& descriptor_0,".\n"); else ;
  }
  
#line 1787 
  rxd = smc->hw.fp.rx_q[0].rx_curr_put;
  
#line 1788 
  skb = alloc_skb((unsigned int)(MaxFrameSize + 3),32U);
  
#line 1789 
  if (skb != (struct sk_buff *)0) {
    
#line 1791 
    skb_reserve(skb,3);
    
#line 1792 
    skb_put(skb,(unsigned int)MaxFrameSize);
    
#line 1793 
    v_addr = skb->data;
    
#line 1794 
    b_addr = (unsigned long)pci_map_single(& smc->os.pdev,(void *)v_addr,(unsigned long)MaxFrameSize,2);
    
#line 1798 
    rxd->rxd_os.dma_addr = (unsigned long long)b_addr;
  }
  else {
    {
      
#line 1805 
      struct _ddebug descriptor_1 = {.modname = "skfp", .function = "mac_drv_fill_rxd", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "Queueing invalid buffer!\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1805U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1805 
      if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) 
#line 1805 
                                                            __dynamic_pr_debug(& descriptor_1,"Queueing invalid buffer!\n"); else ;
    }
    
#line 1806 
    v_addr = smc->os.LocalRxBuffer;
    
#line 1807 
    b_addr = (unsigned long)smc->os.LocalRxBufferDMA;
  }
  
#line 1810 
  rxd->rxd_os.skb = skb;
  
#line 1813 
  hwm_rx_frag(smc,(char *)v_addr,b_addr,MaxFrameSize,24);
  ldv_47605: 
#line 1814 
  ;
  
#line 1784 
  if ((int)smc->hw.fp.rx_q[0].rx_free + -1 > 0) 
#line 1786 
                                                goto ldv_47604; else 
                                                                  
#line 1789 
                                                                  goto ldv_47606;
  ldv_47606: 
#line 1790 
  ;
  {
    
#line 1816 
    struct _ddebug descriptor_2 = {.modname = "skfp", .function = "mac_drv_fill_rxd", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "leaving mac_drv_fill_rxd\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1816U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1816 
    if ((long)(((int)descriptor_2.flags & 1) != 0) != 0L) 
#line 1816 
                                                          __dynamic_pr_debug(& descriptor_2,"leaving mac_drv_fill_rxd\n"); else ;
  }
  
#line 1818 
  return;
}


#line 1836  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
void mac_drv_clear_rxd(struct s_smc *smc, struct s_smt_fp_rxd volatile *rxd, int frag_count)
{
  struct sk_buff *skb;
  {
    
#line 1842 
    struct _ddebug descriptor = {.modname = "skfp", .function = "mac_drv_clear_rxd", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "entering mac_drv_clear_rxd\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1842U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1842 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1842 
                                                        __dynamic_pr_debug(& descriptor,"entering mac_drv_clear_rxd\n"); else ;
  }
  
#line 1844 
  if (frag_count != 1) 
#line 1846 
                       printk("fddi: Multi-fragment clear!\n"); else ;
  
#line 1848 
  goto ldv_47619;
  ldv_47618: 
#line 1849 
  ;
  
#line 1849 
  skb = rxd->rxd_os.skb;
  
#line 1850 
  if (skb != (struct sk_buff *)0) {
    
#line 1851 
    skfddi_priv *bp = & smc->os;
    
#line 1852 
    int MaxFrameSize = (int)bp->MaxFrameSize;
    
#line 1854 
    pci_unmap_single(& bp->pdev,rxd->rxd_os.dma_addr,(unsigned long)MaxFrameSize,2);
    
#line 1857 
    consume_skb(skb);
    
#line 1858 
    rxd->rxd_os.skb = (struct sk_buff *)0;
  }
  else ;
  
#line 1860 
  rxd = rxd->rxd_next;
  
#line 1848 
  frag_count -= 1;
  ldv_47619: 
#line 1849 
  ;
  
#line 1848 
  if (frag_count > 0) 
#line 1850 
                      goto ldv_47618; else 
#line 1853 
                                           goto ldv_47620;
  ldv_47620: 
#line 1854 
  ;
  
#line 1855 
  return;
}


#line 1893  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
int mac_drv_rx_init(struct s_smc *smc, int len, int fc, char *look_ahead, int la_len)
{
  int __retres;
  struct sk_buff *skb;
  {
    
#line 1898 
    struct _ddebug descriptor = {.modname = "skfp", .function = "mac_drv_rx_init", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "entering mac_drv_rx_init(len=%d)\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1898U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1898 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1898 
                                                        __dynamic_pr_debug(& descriptor,"entering mac_drv_rx_init(len=%d)\n",len); else ;
  }
  
#line 1902 
  if ((len != la_len || len <= 12) || look_ahead == (char *)0) {
    {
      
#line 1903 
      struct _ddebug descriptor_0 = {.modname = "skfp", .function = "mac_drv_rx_init", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "fddi: Discard invalid local SMT frame\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1903U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1903 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 1903 
                                                            __dynamic_pr_debug(& descriptor_0,"fddi: Discard invalid local SMT frame\n"); else ;
    }
    {
      
#line 1904 
      struct _ddebug descriptor_1 = {.modname = "skfp", .function = "mac_drv_rx_init", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "  len=%d, la_len=%d, (ULONG) look_ahead=%08lXh.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1905U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1904 
      if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) 
#line 1904 
                                                            __dynamic_pr_debug(& descriptor_1,"  len=%d, la_len=%d, (ULONG) look_ahead=%08lXh.\n",len,la_len,(unsigned long)look_ahead); else ;
    }
    
#line 1906 
    __retres = 0;
    
#line 1906 
    goto return_label;
  }
  else ;
  
#line 1908 
  skb = alloc_skb((unsigned int)(len + 3),32U);
  
#line 1909 
  if (skb == (struct sk_buff *)0) {
    {
      
#line 1910 
      struct _ddebug descriptor_2 = {.modname = "skfp", .function = "mac_drv_rx_init", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "fddi: Local SMT: skb memory exhausted.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1910U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1910 
      if ((long)(((int)descriptor_2.flags & 1) != 0) != 0L) 
#line 1910 
                                                            __dynamic_pr_debug(& descriptor_2,"fddi: Local SMT: skb memory exhausted.\n"); else ;
    }
    
#line 1911 
    __retres = 0;
    
#line 1911 
    goto return_label;
  }
  else ;
  
#line 1913 
  skb_reserve(skb,3);
  
#line 1914 
  skb_put(skb,(unsigned int)len);
  
#line 1915 
  skb_copy_to_linear_data(skb,(void const *)look_ahead,(unsigned int)len);
  
#line 1918 
  skb->protocol = fddi_type_trans(skb,smc->os.dev);
  
#line 1919 
  netif_rx(skb);
  
#line 1921 
  __retres = 0;
  return_label: 
#line 1921 
                return __retres;
}


#line 1940  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
void smt_timer_poll(struct s_smc *smc)
{
  
#line 1942 
  return;
}


#line 1958  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
void ring_status_indication(struct s_smc *smc, u_long status)
{
  {
    
#line 1960 
    struct _ddebug descriptor = {.modname = "skfp", .function = "ring_status_indication", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "ring_status_indication( ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1960U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1960 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1960 
                                                        __dynamic_pr_debug(& descriptor,"ring_status_indication( "); else ;
  }
  
#line 1961 
  if ((status & 32768UL) != 0UL) {
    
#line 1962 
    struct _ddebug descriptor_0 = {.modname = "skfp", .function = "ring_status_indication", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "RS_RES15 ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1962U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1962 
    if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 1962 
                                                          __dynamic_pr_debug(& descriptor_0,"RS_RES15 "); else ;
  }
  else ;
  
#line 1963 
  if ((status & 16384UL) != 0UL) {
    
#line 1964 
    struct _ddebug descriptor_1 = {.modname = "skfp", .function = "ring_status_indication", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "RS_HARDERROR ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1964U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1964 
    if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) 
#line 1964 
                                                          __dynamic_pr_debug(& descriptor_1,"RS_HARDERROR "); else ;
  }
  else ;
  
#line 1965 
  if ((status & 8192UL) != 0UL) {
    
#line 1966 
    struct _ddebug descriptor_2 = {.modname = "skfp", .function = "ring_status_indication", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "RS_SOFTERROR ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1966U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1966 
    if ((long)(((int)descriptor_2.flags & 1) != 0) != 0L) 
#line 1966 
                                                          __dynamic_pr_debug(& descriptor_2,"RS_SOFTERROR "); else ;
  }
  else ;
  
#line 1967 
  if ((status & 4096UL) != 0UL) {
    
#line 1968 
    struct _ddebug descriptor_3 = {.modname = "skfp", .function = "ring_status_indication", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "RS_BEACON ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1968U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1968 
    if ((long)(((int)descriptor_3.flags & 1) != 0) != 0L) 
#line 1968 
                                                          __dynamic_pr_debug(& descriptor_3,"RS_BEACON "); else ;
  }
  else ;
  
#line 1969 
  if ((status & 2048UL) != 0UL) {
    
#line 1970 
    struct _ddebug descriptor_4 = {.modname = "skfp", .function = "ring_status_indication", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "RS_PATHTEST ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1970U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1970 
    if ((long)(((int)descriptor_4.flags & 1) != 0) != 0L) 
#line 1970 
                                                          __dynamic_pr_debug(& descriptor_4,"RS_PATHTEST "); else ;
  }
  else ;
  
#line 1971 
  if ((status & 1024UL) != 0UL) {
    
#line 1972 
    struct _ddebug descriptor_5 = {.modname = "skfp", .function = "ring_status_indication", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "RS_SELFTEST ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1972U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1972 
    if ((long)(((int)descriptor_5.flags & 1) != 0) != 0L) 
#line 1972 
                                                          __dynamic_pr_debug(& descriptor_5,"RS_SELFTEST "); else ;
  }
  else ;
  
#line 1973 
  if ((status & 512UL) != 0UL) {
    
#line 1974 
    struct _ddebug descriptor_6 = {.modname = "skfp", .function = "ring_status_indication", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "RS_RES9 ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1974U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1974 
    if ((long)(((int)descriptor_6.flags & 1) != 0) != 0L) 
#line 1974 
                                                          __dynamic_pr_debug(& descriptor_6,"RS_RES9 "); else ;
  }
  else ;
  
#line 1975 
  if ((status & 256UL) != 0UL) {
    
#line 1976 
    struct _ddebug descriptor_7 = {.modname = "skfp", .function = "ring_status_indication", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "RS_DISCONNECT ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1976U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1976 
    if ((long)(((int)descriptor_7.flags & 1) != 0) != 0L) 
#line 1976 
                                                          __dynamic_pr_debug(& descriptor_7,"RS_DISCONNECT "); else ;
  }
  else ;
  
#line 1977 
  if ((status & 128UL) != 0UL) {
    
#line 1978 
    struct _ddebug descriptor_8 = {.modname = "skfp", .function = "ring_status_indication", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "RS_RES7 ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1978U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1978 
    if ((long)(((int)descriptor_8.flags & 1) != 0) != 0L) 
#line 1978 
                                                          __dynamic_pr_debug(& descriptor_8,"RS_RES7 "); else ;
  }
  else ;
  
#line 1979 
  if ((status & 64UL) != 0UL) {
    
#line 1980 
    struct _ddebug descriptor_9 = {.modname = "skfp", .function = "ring_status_indication", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "RS_DUPADDR ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1980U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1980 
    if ((long)(((int)descriptor_9.flags & 1) != 0) != 0L) 
#line 1980 
                                                          __dynamic_pr_debug(& descriptor_9,"RS_DUPADDR "); else ;
  }
  else ;
  
#line 1981 
  if ((status & 32UL) != 0UL) {
    
#line 1982 
    struct _ddebug descriptor_10 = {.modname = "skfp", .function = "ring_status_indication", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "RS_NORINGOP ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1982U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1982 
    if ((long)(((int)descriptor_10.flags & 1) != 0) != 0L) 
#line 1982 
                                                           __dynamic_pr_debug(& descriptor_10,"RS_NORINGOP "); else ;
  }
  else ;
  
#line 1983 
  if ((status & 16UL) != 0UL) {
    
#line 1984 
    struct _ddebug descriptor_11 = {.modname = "skfp", .function = "ring_status_indication", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "RS_VERSION ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1984U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1984 
    if ((long)(((int)descriptor_11.flags & 1) != 0) != 0L) 
#line 1984 
                                                           __dynamic_pr_debug(& descriptor_11,"RS_VERSION "); else ;
  }
  else ;
  
#line 1985 
  if ((status & 8UL) != 0UL) {
    
#line 1986 
    struct _ddebug descriptor_12 = {.modname = "skfp", .function = "ring_status_indication", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "RS_STUCKBYPASSS ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1986U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1986 
    if ((long)(((int)descriptor_12.flags & 1) != 0) != 0L) 
#line 1986 
                                                           __dynamic_pr_debug(& descriptor_12,"RS_STUCKBYPASSS "); else ;
  }
  else ;
  
#line 1987 
  if ((status & 4UL) != 0UL) {
    
#line 1988 
    struct _ddebug descriptor_13 = {.modname = "skfp", .function = "ring_status_indication", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "RS_EVENT ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1988U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1988 
    if ((long)(((int)descriptor_13.flags & 1) != 0) != 0L) 
#line 1988 
                                                           __dynamic_pr_debug(& descriptor_13,"RS_EVENT "); else ;
  }
  else ;
  
#line 1989 
  if ((status & 2UL) != 0UL) {
    
#line 1990 
    struct _ddebug descriptor_14 = {.modname = "skfp", .function = "ring_status_indication", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "RS_RINGOPCHANGE ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1990U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1990 
    if ((long)(((int)descriptor_14.flags & 1) != 0) != 0L) 
#line 1990 
                                                           __dynamic_pr_debug(& descriptor_14,"RS_RINGOPCHANGE "); else ;
  }
  else ;
  
#line 1991 
  if ((status & 1UL) != 0UL) {
    
#line 1992 
    struct _ddebug descriptor_15 = {.modname = "skfp", .function = "ring_status_indication", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "RS_RES0 ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1992U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1992 
    if ((long)(((int)descriptor_15.flags & 1) != 0) != 0L) 
#line 1992 
                                                           __dynamic_pr_debug(& descriptor_15,"RS_RES0 "); else ;
  }
  else ;
  {
    
#line 1993 
    struct _ddebug descriptor_16 = {.modname = "skfp", .function = "ring_status_indication", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "]\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1993U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1993 
    if ((long)(((int)descriptor_16.flags & 1) != 0) != 0L) 
#line 1993 
                                                           __dynamic_pr_debug(& descriptor_16,"]\n"); else ;
  }
  
#line 1995 
  return;
}


#line 2012  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
u_long smt_get_time(void)
{
  
#line 2014 
  return jiffies;
}


#line 2032  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
void smt_stat_counter(struct s_smc *smc, int stat)
{
  {
    
#line 2036 
    struct _ddebug descriptor = {.modname = "skfp", .function = "smt_stat_counter", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "smt_stat_counter\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2036U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 2036 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 2036 
                                                        __dynamic_pr_debug(& descriptor,"smt_stat_counter\n"); else ;
  }
  
#line 2037 
  switch (stat) {
    case 0: 
#line 2038 
    ;
    {
      
#line 2039 
      struct _ddebug descriptor_0 = {.modname = "skfp", .function = "smt_stat_counter", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "Ring operational change.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2039U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 2039 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 2039 
                                                            __dynamic_pr_debug(& descriptor_0,"Ring operational change.\n"); else ;
    }
    
#line 2040 
    goto ldv_47671;
    case 1: 
#line 2041 
    ;
    {
      
#line 2042 
      struct _ddebug descriptor_1 = {.modname = "skfp", .function = "smt_stat_counter", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "Receive fifo overflow.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2042U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 2042 
      if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) 
#line 2042 
                                                            __dynamic_pr_debug(& descriptor_1,"Receive fifo overflow.\n"); else ;
    }
    
#line 2043 
    smc->os.MacStat.gen.rx_errors += 1UL;
    
#line 2044 
    goto ldv_47671;
    default: 
#line 2045 
    ;
    {
      
#line 2046 
      struct _ddebug descriptor_2 = {.modname = "skfp", .function = "smt_stat_counter", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "Unknown status (%d).\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2046U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 2046 
      if ((long)(((int)descriptor_2.flags & 1) != 0) != 0L) 
#line 2046 
                                                            __dynamic_pr_debug(& descriptor_2,"Unknown status (%d).\n",stat); else ;
    }
    
#line 2047 
    goto ldv_47671;
  }
  ldv_47671: 
#line 2049 
  ;
  
#line 2050 
  return;
}


#line 2068  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
void cfm_state_change(struct s_smc *smc, int c_state)
{
  
#line 2070 
  return;
}


#line 2126  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
void ecm_state_change(struct s_smc *smc, int e_state)
{
  
#line 2128 
  return;
}


#line 2181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
void rmt_state_change(struct s_smc *smc, int r_state)
{
  
#line 2183 
  return;
}


#line 2233  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
void drv_reset_indication(struct s_smc *smc)
{
  {
    
#line 2235 
    struct _ddebug descriptor = {.modname = "skfp", .function = "drv_reset_indication", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c", .format = "entering drv_reset_indication\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2235U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 2235 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 2235 
                                                        __dynamic_pr_debug(& descriptor,"entering drv_reset_indication\n"); else ;
  }
  
#line 2237 
  smc->os.ResetRequested = (unsigned char)1U;
  
#line 2238 
  return;
}


#line 2241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
static struct pci_driver skfddi_pci_driver = {.node = {.next = (struct list_head *)0, .prev = (struct list_head *)0}, .name = "skfddi", .id_table = (struct pci_device_id const *)(& skfddi_pci_tbl), .probe = & skfp_init_one, .remove = & skfp_remove_one, .suspend = (int (*)(struct pci_dev *, pm_message_t ))0, .suspend_late = (int (*)(struct pci_dev *, pm_message_t ))0, .resume_early = (int (*)(struct pci_dev *))0, .resume = (int (*)(struct pci_dev *))0, .shutdown = (void (*)(struct pci_dev *))0, .sriov_configure = (int (*)(struct pci_dev *, int ))0, .err_handler = (struct pci_error_handlers const *)0, .driver = {.name = (char const *)0, .bus = (struct bus_type *)0, .owner = (struct module *)0, .mod_name = (char const *)0, .suppress_bind_attrs = (_Bool)0, .probe_type = 0, .of_match_table = (struct of_device_id const *)0, .acpi_match_table = (struct acpi_device_id const *)0, .probe = (int (*)(struct device *))0, .remove = (int (*)(struct device *))0, .shutdown = (void (*)(struct device *))0, .suspend = (int (*)(struct device *, pm_message_t ))0, .resume = (int (*)(struct device *))0, .groups = (struct attribute_group const **)0, .pm = (struct dev_pm_ops const *)0, .p = (struct driver_private *)0}, .dynids = {.lock = {.__anonCompField_spinlock_18 = {.rlock = {.raw_lock = {.val = {.counter = 0}}, .magic = 0U, .owner_cpu = 0U, .owner = (void *)0, .dep_map = {.key = (struct lock_class_key *)0, .class_cache = {(struct lock_class *)0, (struct lock_class *)0}, .name = (char const *)0, .cpu = 0, .ip = 0UL}}}}, .list = {.next = (struct list_head *)0, .prev = (struct list_head *)0}}};

#line 2248  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
static int skfddi_pci_driver_init(void)
{
  int tmp;
  
#line 2248 
  tmp = ldv___pci_register_driver_89(& skfddi_pci_driver,& __this_module,"skfp");
  
#line 2248 
  return tmp;
}


#line 2248  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/skfddi.c"
static void skfddi_pci_driver_exit(void)
{
  
#line 2248 
  ldv_pci_unregister_driver_90(& skfddi_pci_driver);
  
#line 2249 
  return;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
int (*ldv_emg_alias_fddi_change_mtu_4)(struct net_device *, int ) = & fddi_change_mtu;

#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
struct pci_driver *ldv_emg_alias_skfddi_pci_driver_2 = & skfddi_pci_driver;

#line 60 
void ldv_emg_unregister_netdev(struct net_device *arg0);


#line 61 
void ldv_emg_free_irq(unsigned int arg0, void *arg1);


#line 62 
void ldv_emg_pci_unregister_driver(struct pci_driver *arg0);


#line 63 
int ldv_emg___pci_register_driver(struct pci_driver *arg0, struct module *arg1, char *arg2);


#line 64 
int ldv_emg_request_irq(unsigned int arg0, enum irqreturn (*arg1)(int , void *), unsigned long arg2, char *arg3, void *arg4);


#line 65 
void ldv_emg_free_netdev(struct net_device *arg0);


#line 66 
int ldv_emg_register_netdev(struct net_device *arg0);


#line 70  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
enum netdev_tx ldv_emg_wrapper_skfp_send_pkt_5(struct sk_buff *arg0, struct net_device *arg1)
{
  enum netdev_tx tmp;
  
#line 71 
  tmp = skfp_send_pkt(arg0,arg1);
  
#line 71 
  return tmp;
}


#line 75  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
int ldv_emg_wrapper_skfp_close_2(struct net_device *arg0)
{
  int tmp;
  
#line 76 
  tmp = skfp_close(arg0);
  
#line 76 
  return tmp;
}


#line 80  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
int ldv_emg_skfddi_pci_driver_init(void)
{
  int tmp;
  
#line 81 
  tmp = skfddi_pci_driver_init();
  
#line 81 
  return tmp;
}


#line 84  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
struct net_device_stats *ldv_emg_wrapper_skfp_ctl_get_stats_2(struct net_device *arg0)
{
  struct net_device_stats *tmp;
  
#line 85 
  tmp = skfp_ctl_get_stats(arg0);
  
#line 85 
  return tmp;
}


#line 89  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
int ldv_emg_wrapper_skfp_init_one_2(struct pci_dev *arg0, struct pci_device_id *arg1)
{
  int tmp;
  
#line 90 
  tmp = skfp_init_one(arg0,(struct pci_device_id const *)arg1);
  
#line 90 
  return tmp;
}


#line 94  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
int ldv_emg_wrapper_skfp_open_2(struct net_device *arg0)
{
  int tmp;
  
#line 95 
  tmp = skfp_open(arg0);
  
#line 95 
  return tmp;
}


#line 99  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
enum irqreturn ldv_emg_wrapper_skfp_interrupt_2(int arg0, void *arg1)
{
  enum irqreturn tmp;
  
#line 100 
  tmp = skfp_interrupt(arg0,arg1);
  
#line 100 
  return tmp;
}


#line 104  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
int ldv_emg_wrapper_skfp_ctl_set_mac_address_6(struct net_device *arg0, void *arg1)
{
  int tmp;
  
#line 105 
  tmp = skfp_ctl_set_mac_address(arg0,arg1);
  
#line 105 
  return tmp;
}


#line 109  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
void ldv_emg_skfddi_pci_driver_exit(void)
{
  
#line 110 
  skfddi_pci_driver_exit();
  
#line 111 
  return;
}


#line 113  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
void ldv_emg_wrapper_skfp_ctl_set_multicast_list_7(struct net_device *arg0)
{
  
#line 114 
  skfp_ctl_set_multicast_list(arg0);
  
#line 115 
  return;
}


#line 118  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
void ldv_emg_wrapper_skfp_remove_one_3(struct pci_dev *arg0)
{
  
#line 119 
  skfp_remove_one(arg0);
  
#line 120 
  return;
}


#line 123  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
int ldv_emg_wrapper_skfp_ioctl_3(struct net_device *arg0, struct ifreq *arg1, int arg2)
{
  int tmp;
  
#line 124 
  tmp = skfp_ioctl(arg0,arg1,arg2);
  
#line 124 
  return tmp;
}


#line 799  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
static int ldv_register_netdev_72(struct net_device *ldv_func_arg1)
{
  int tmp;
  
#line 803 
  tmp = ldv_emg_register_netdev(ldv_func_arg1);
  
#line 803 
  return tmp;
}


#line 807  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
static void ldv_free_netdev_73(struct net_device *ldv_func_arg1)
{
  
#line 811 
  ldv_emg_free_netdev(ldv_func_arg1);
  
#line 812 
  return;
}


#line 815  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
static void ldv_unregister_netdev_74(struct net_device *ldv_func_arg1)
{
  
#line 819 
  ldv_emg_unregister_netdev(ldv_func_arg1);
  
#line 820 
  return;
}


#line 823  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
static void ldv_free_netdev_75(struct net_device *ldv_func_arg1)
{
  
#line 827 
  ldv_emg_free_netdev(ldv_func_arg1);
  
#line 828 
  return;
}


#line 831  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
static int ldv_request_irq_76(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev)
{
  int tmp;
  
#line 835 
  tmp = ldv_emg_request_irq(irq,handler,flags,(char *)name,dev);
  
#line 835 
  return tmp;
}


#line 839  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
static void ldv_free_irq_77(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  
#line 843 
  ldv_emg_free_irq(ldv_func_arg1,ldv_func_arg2);
  
#line 844 
  return;
}


#line 847  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
static void ldv_spin_lock_78(spinlock_t *lock)
{
  
#line 851 
  ldv_spin_model_lock((char *)"DriverLock_of_s_smt_os");
  
#line 853 
  spin_lock(lock);
  
#line 854 
  return;
}


#line 857  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
static void ldv_spin_unlock_79(spinlock_t *lock)
{
  
#line 861 
  ldv_spin_model_unlock((char *)"DriverLock_of_s_smt_os");
  
#line 863 
  spin_unlock(lock);
  
#line 864 
  return;
}


#line 867  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
static void ldv___ldv_spin_lock_80(spinlock_t *ldv_func_arg1)
{
  
#line 871 
  ldv_spin_model_lock((char *)"DriverLock_of_s_smt_os");
  
#line 873 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 874 
  return;
}


#line 877  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
static void ldv_spin_unlock_irqrestore_81(spinlock_t *lock, unsigned long flags)
{
  
#line 881 
  ldv_spin_model_unlock((char *)"DriverLock_of_s_smt_os");
  
#line 883 
  spin_unlock_irqrestore(lock,flags);
  
#line 884 
  return;
}


#line 887  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
static void ldv___ldv_spin_lock_82(spinlock_t *ldv_func_arg1)
{
  
#line 891 
  ldv_spin_model_lock((char *)"DriverLock_of_s_smt_os");
  
#line 893 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 894 
  return;
}


#line 897  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
static void ldv_spin_unlock_irqrestore_83(spinlock_t *lock, unsigned long flags)
{
  
#line 901 
  ldv_spin_model_unlock((char *)"DriverLock_of_s_smt_os");
  
#line 903 
  spin_unlock_irqrestore(lock,flags);
  
#line 904 
  return;
}


#line 907  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
static void ldv___ldv_spin_lock_84(spinlock_t *ldv_func_arg1)
{
  
#line 911 
  ldv_spin_model_lock((char *)"DriverLock_of_s_smt_os");
  
#line 913 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 914 
  return;
}


#line 917  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
static void ldv_spin_unlock_irqrestore_85(spinlock_t *lock, unsigned long flags)
{
  
#line 921 
  ldv_spin_model_unlock((char *)"DriverLock_of_s_smt_os");
  
#line 923 
  spin_unlock_irqrestore(lock,flags);
  
#line 924 
  return;
}


#line 927  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
static void ldv_spin_unlock_irqrestore_86(spinlock_t *lock, unsigned long flags)
{
  
#line 931 
  ldv_spin_model_unlock((char *)"DriverLock_of_s_smt_os");
  
#line 933 
  spin_unlock_irqrestore(lock,flags);
  
#line 934 
  return;
}


#line 937  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
static void ldv_spin_unlock_87(spinlock_t *lock)
{
  
#line 941 
  ldv_spin_model_unlock((char *)"DriverLock_of_s_smt_os");
  
#line 943 
  spin_unlock(lock);
  
#line 944 
  return;
}


#line 947  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
static void ldv_spin_lock_88(spinlock_t *lock)
{
  
#line 951 
  ldv_spin_model_lock((char *)"DriverLock_of_s_smt_os");
  
#line 953 
  spin_lock(lock);
  
#line 954 
  return;
}


#line 957  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
static int ldv___pci_register_driver_89(struct pci_driver *ldv_func_arg1, struct module *ldv_func_arg2, char const *ldv_func_arg3)
{
  int tmp;
  
#line 961 
  tmp = ldv_emg___pci_register_driver(ldv_func_arg1,ldv_func_arg2,(char *)ldv_func_arg3);
  
#line 961 
  return tmp;
}


#line 965  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/weaver/.tmp_skfddi.c.aux"
static void ldv_pci_unregister_driver_90(struct pci_driver *ldv_func_arg1)
{
  
#line 969 
  ldv_emg_pci_unregister_driver(ldv_func_arg1);
  
#line 970 
  return;
}


#line 483  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/cmtdef.h"
void hwt_restart(struct s_smc *smc);


#line 522 
void hwt_init(struct s_smc *smc);


#line 523 
u_long hwt_read(struct s_smc *smc);


#line 524 
void hwt_stop(struct s_smc *smc);


#line 525 
void hwt_start(struct s_smc *smc, u_long time);


#line 599 
u_long hwt_quick_read(struct s_smc *smc);


#line 600 
void hwt_wait_time(struct s_smc *smc, u_long start, long duration);


#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/iomap.h"
void iowrite16(u16, void *);


#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwt.c"
void hwt_start(struct s_smc *smc, u_long time)
{
  u_short cnt;
  
#line 67 
  if (time > 65000UL) 
#line 68 
                      time = 65000UL; else ;
  
#line 70 
  smc->hw.t_start = time;
  
#line 71 
  smc->hw.t_stop = 0UL;
  
#line 73 
  cnt = (unsigned short)time;
  
#line 78 
  if ((unsigned int)cnt == 0U) 
#line 79 
                               cnt = (u_short)((int)cnt + 1); else ;
  
#line 81 
  iowrite32((unsigned int)cnt * 200U,smc->hw.iop + 288U);
  
#line 82 
  iowrite16((unsigned short)4,smc->hw.iop + 296U);
  
#line 84 
  smc->hw.timer_activ = (unsigned short)1U;
  
#line 85 
  return;
}


#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwt.c"
void hwt_stop(struct s_smc *smc)
{
  
#line 103 
  iowrite16((unsigned short)2,smc->hw.iop + 296U);
  
#line 104 
  iowrite16((unsigned short)1,smc->hw.iop + 296U);
  
#line 106 
  smc->hw.timer_activ = (unsigned short)0U;
  
#line 107 
  return;
}


#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwt.c"
void hwt_init(struct s_smc *smc)
{
  
#line 125 
  smc->hw.t_start = 0UL;
  
#line 126 
  smc->hw.t_stop = 0UL;
  
#line 127 
  smc->hw.timer_activ = (unsigned short)0U;
  
#line 129 
  hwt_restart(smc);
  
#line 130 
  return;
}


#line 146  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwt.c"
void hwt_restart(struct s_smc *smc)
{
  
#line 148 
  hwt_stop(smc);
  
#line 149 
  return;
}


#line 164  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwt.c"
u_long hwt_read(struct s_smc *smc)
{
  u_long __retres;
  u_short tr;
  u_long is;
  
#line 169 
  if ((unsigned int)smc->hw.timer_activ != 0U) {
    unsigned int tmp;
    unsigned int tmp_0;
    
#line 170 
    hwt_stop(smc);
    
#line 171 
    tmp = ioread32(smc->hw.iop + 292U);
    
#line 171 
    tr = (unsigned short)(tmp / 200U);
    
#line 173 
    tmp_0 = ioread32(smc->hw.iop + 8U);
    
#line 173 
    is = (unsigned long)tmp_0;
    
#line 175 
    if ((unsigned long)tr > smc->hw.t_start || (is & 4194304UL) != 0UL) {
      
#line 176 
      hwt_restart(smc);
      
#line 177 
      smc->hw.t_stop = smc->hw.t_start;
    }
    else 
#line 180 
         smc->hw.t_stop = smc->hw.t_start - (unsigned long)tr;
  }
  else ;
  
#line 182 
  __retres = smc->hw.t_stop;
  
#line 182 
  return __retres;
}


#line 199  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwt.c"
u_long hwt_quick_read(struct s_smc *smc)
{
  u_long interval;
  u_long time;
  unsigned int tmp;
  unsigned int tmp_0;
  
#line 204 
  tmp = ioread32(smc->hw.iop + 288U);
  
#line 204 
  interval = (unsigned long)tmp;
  
#line 205 
  iowrite16((unsigned short)2,smc->hw.iop + 296U);
  
#line 206 
  tmp_0 = ioread32(smc->hw.iop + 292U);
  
#line 206 
  time = (unsigned long)tmp_0;
  
#line 207 
  iowrite32((unsigned int)time,smc->hw.iop + 288U);
  
#line 208 
  iowrite16((unsigned short)4,smc->hw.iop + 296U);
  
#line 209 
  iowrite32((unsigned int)interval,smc->hw.iop + 288U);
  
#line 211 
  return time;
}


#line 227  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/hwt.c"
void hwt_wait_time(struct s_smc *smc, u_long start, long duration)
{
  long diff;
  long interval;
  int wrapped;
  unsigned int tmp_1;
  
#line 236 
  if ((unsigned int)smc->hw.timer_activ == 0U) 
#line 238 
                                               goto return_label;
  else {
    u_long tmp;
    u_long tmp_0;
    
#line 236 
    tmp = hwt_quick_read(smc);
    
#line 237 
    tmp_0 = hwt_quick_read(smc);
    
#line 236 
    if (tmp == tmp_0) 
#line 238 
                      goto return_label; else ;
  }
  
#line 241 
  tmp_1 = ioread32(smc->hw.iop + 288U);
  
#line 241 
  interval = (long)tmp_1;
  
#line 242 
  if (interval > duration) {
    u_long tmp_2;
    ldv_46259: 
#line 244 
    ;
    
#line 244 
    tmp_2 = hwt_quick_read(smc);
    
#line 244 
    diff = (long)(start - tmp_2);
    
#line 245 
    if (diff < 0L) 
#line 246 
                   diff += interval; else ;
    
#line 248 
    if (diff <= duration) 
#line 250 
                          goto ldv_46259; else 
#line 253 
                                               goto ldv_46260;
    ldv_46260: 
#line 254 
    ;
  }
  else {
    
#line 251 
    diff = interval;
    
#line 252 
    wrapped = 0;
    ldv_46261: 
#line 253 
    ;
    
#line 254 
    if (wrapped == 0) {
      u_long tmp_3;
      
#line 255 
      tmp_3 = hwt_quick_read(smc);
      
#line 255 
      ;
      
#line 255 
      if (tmp_3 >= start) {
        
#line 256 
        diff += interval;
        
#line 257 
        wrapped = 1;
      }
      else ;
    }
    else {
      u_long tmp_4;
      
#line 261 
      tmp_4 = hwt_quick_read(smc);
      
#line 261 
      ;
      
#line 261 
      if (tmp_4 < start) 
#line 262 
                         wrapped = 0; else ;
    }
    
#line 265 
    if (diff <= duration) 
#line 267 
                          goto ldv_46261; else 
#line 270 
                                               goto ldv_46262;
    ldv_46262: 
#line 271 
    ;
  }
  return_label: 
#line 273 
                return;
}


#line 542  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/cmtdef.h"
void smt_timer_done(struct s_smc *smc);


#line 556 
void timer_event(struct s_smc *smc, u_long token);


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smttimer.c"
static void timer_done(struct s_smc *smc, int restart);


#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smttimer.c"
void smt_timer_init(struct s_smc *smc)
{
  
#line 33 
  smc->t.st_queue = (struct smt_timer *)0;
  
#line 34 
  smc->t.st_fast.tm_active = (unsigned short)0U;
  
#line 35 
  smc->t.st_fast.tm_next = (struct smt_timer *)0;
  
#line 36 
  hwt_init(smc);
  
#line 37 
  return;
}


#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smttimer.c"
void smt_timer_stop(struct s_smc *smc, struct smt_timer *timer)
{
  struct smt_timer **prev;
  struct smt_timer *tm;
  
#line 47 
  timer->tm_active = (unsigned short)0U;
  
#line 48 
  if (smc->t.st_queue == timer && timer->tm_next == (struct smt_timer *)0) 
    
#line 49 
    hwt_stop(smc); else ;
  
#line 51 
  prev = & smc->t.st_queue;
  
#line 51 
  goto ldv_46240;
  ldv_46239: 
#line 52 
  ;
  
#line 52 
  if (tm == timer) {
    
#line 53 
    *prev = tm->tm_next;
    
#line 54 
    if (tm->tm_next != (struct smt_timer *)0) 
#line 55 
                                              (tm->tm_next)->tm_delta += tm->tm_delta; else ;
    
#line 57 
    goto return_label;
  }
  else ;
  
#line 51 
  prev = & tm->tm_next;
  ldv_46240: 
#line 52 
  ;
  
#line 51 
  tm = *prev;
  
#line 51 
  if (tm != (struct smt_timer *)0) 
#line 53 
                                   goto ldv_46239; else 
#line 56 
                                                        goto ldv_46241;
  ldv_46241: 
#line 57 
  ;
  return_label: 
#line 58 
                return;
}


#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smttimer.c"
void smt_timer_start(struct s_smc *smc, struct smt_timer *timer, u_long time, u_long token)
{
  struct smt_timer **prev;
  struct smt_timer *tm;
  
#line 67 
  u_long delta = 0UL;
  
#line 69 
  time /= 16UL;
  
#line 70 
  if (time == 0UL) 
#line 71 
                   time = 1UL; else ;
  
#line 72 
  smt_timer_stop(smc,timer);
  
#line 73 
  timer->tm_smc = smc;
  
#line 74 
  timer->tm_token = token;
  
#line 75 
  timer->tm_active = (unsigned short)1U;
  
#line 76 
  if (smc->t.st_queue == (struct smt_timer *)0) {
    
#line 77 
    smc->t.st_queue = timer;
    
#line 78 
    timer->tm_next = (struct smt_timer *)0;
    
#line 79 
    timer->tm_delta = time;
    
#line 80 
    hwt_start(smc,time);
    
#line 81 
    goto return_label;
  }
  else ;
  
#line 86 
  timer_done(smc,0);
  
#line 91 
  delta = 0UL;
  
#line 92 
  prev = & smc->t.st_queue;
  
#line 92 
  goto ldv_46253;
  ldv_46252: 
#line 93 
  ;
  
#line 93 
  if (tm->tm_delta + delta > time) 
#line 94 
                                   goto ldv_46251; else ;
  
#line 96 
  delta = tm->tm_delta + delta;
  
#line 92 
  prev = & tm->tm_next;
  ldv_46253: 
#line 93 
  ;
  
#line 92 
  tm = *prev;
  
#line 92 
  if (tm != (struct smt_timer *)0) 
#line 94 
                                   goto ldv_46252; else 
#line 97 
                                                        goto ldv_46251;
  ldv_46251: 
#line 98 
  ;
  
#line 99 
  *prev = timer;
  
#line 100 
  timer->tm_next = tm;
  
#line 101 
  timer->tm_delta = time - delta;
  
#line 102 
  if (tm != (struct smt_timer *)0) 
#line 103 
                                   tm->tm_delta -= timer->tm_delta; else ;
  
#line 107 
  hwt_start(smc,(smc->t.st_queue)->tm_delta);
  return_label: 
#line 108 
                return;
}


#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smttimer.c"
void smt_force_irq(struct s_smc *smc)
{
  
#line 112 
  smt_timer_start(smc,& smc->t.st_fast,32UL,262146UL);
  
#line 113 
  return;
}


#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smttimer.c"
void smt_timer_done(struct s_smc *smc)
{
  
#line 117 
  timer_done(smc,1);
  
#line 118 
  return;
}


#line 120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smttimer.c"
static void timer_done(struct s_smc *smc, int restart)
{
  u_long delta;
  struct smt_timer *tm;
  struct smt_timer *next;
  struct smt_timer **last;
  
#line 126 
  int done = 0;
  
#line 128 
  delta = hwt_read(smc);
  
#line 129 
  last = & smc->t.st_queue;
  
#line 130 
  tm = smc->t.st_queue;
  
#line 131 
  goto ldv_46270;
  ldv_46269: 
#line 132 
  ;
  
#line 132 
  if (tm->tm_delta <= delta) {
    
#line 133 
    tm->tm_active = (unsigned short)0U;
    
#line 134 
    delta -= tm->tm_delta;
    
#line 135 
    last = & tm->tm_next;
    
#line 136 
    tm = tm->tm_next;
  }
  else {
    
#line 139 
    tm->tm_delta -= delta;
    
#line 140 
    delta = 0UL;
    
#line 141 
    done = 1;
  }
  ldv_46270: 
#line 143 
  ;
  
#line 131 
  if (tm != (struct smt_timer *)0 && done == 0) 
#line 133 
                                                goto ldv_46269; else 
                                                                  
#line 136 
                                                                  goto ldv_46271;
  ldv_46271: 
#line 137 
  ;
  
#line 144 
  *last = (struct smt_timer *)0;
  
#line 145 
  next = smc->t.st_queue;
  
#line 146 
  smc->t.st_queue = tm;
  
#line 148 
  tm = next;
  
#line 148 
  goto ldv_46273;
  ldv_46272: 
#line 149 
  ;
  
#line 149 
  next = tm->tm_next;
  
#line 150 
  timer_event(smc,tm->tm_token);
  
#line 148 
  tm = next;
  ldv_46273: 
#line 149 
  ;
  
#line 148 
  if (tm != (struct smt_timer *)0) 
#line 150 
                                   goto ldv_46272; else 
#line 153 
                                                        goto ldv_46274;
  ldv_46274: 
#line 154 
  ;
  
#line 153 
  if (restart != 0 && smc->t.st_queue != (struct smt_timer *)0) 
#line 154 
                                                                hwt_start(smc,(smc->t.st_queue)->tm_delta); else ;
  
#line 155 
  return;
}


#line 506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/cmtdef.h"
void pcm_status_state(struct s_smc *smc, int np, int *type, int *state, int *remote, int *mac);


#line 508 
void plc_config_mux(struct s_smc *smc, int mux);


#line 509 
void sm_lem_evaluate(struct s_smc *smc);


#line 561 
void pcm_state_change(struct s_smc *smc, int plc, int p_state);


#line 565 
int pcm_rooted_station(struct s_smc *smc);


#line 591 
void plc_clear_irq(struct s_smc *smc, int p);


#line 592 
void plc_irq(struct s_smc *smc, int np, unsigned int cmd);


#line 481  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smc.h"
int pcm_status_twisted(struct s_smc *smc);


#line 136  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
static u_char const plcs_control_c_u[17U] = {(unsigned char)'P', (unsigned char)'L', (unsigned char)'C', (unsigned char)'_', (unsigned char)'C', (unsigned char)'N', (unsigned char)'T', (unsigned char)'R', (unsigned char)'L', (unsigned char)'_', (unsigned char)'C', (unsigned char)'_', (unsigned char)'U', (unsigned char)'=', (unsigned char)'\000', (unsigned char)'\000', (unsigned char)'\000'};

#line 137  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
static u_char const plcs_control_c_s[17U] = {(unsigned char)'P', (unsigned char)'L', (unsigned char)'C', (unsigned char)'_', (unsigned char)'C', (unsigned char)'N', (unsigned char)'T', (unsigned char)'R', (unsigned char)'L', (unsigned char)'_', (unsigned char)'C', (unsigned char)'_', (unsigned char)'S', (unsigned char)'=', (unsigned char)'\001', (unsigned char)'\002', (unsigned char)'\000'};

#line 170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
static struct plt const pltm[8U] = {{.timer = 6, .para = 65048}, {.timer = 7, .para = 65244}, {.timer = 8, .para = 65296}, {.timer = 9, .para = 55771}, {.timer = 11, .para = 63094}, {.timer = 12, .para = 65389}, {.timer = 13, .para = 61473}, {.timer = 0, .para = 0}};

#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
static int const plc_imsk_na = 636;

#line 198  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
static int const plc_imsk_act = 636;

#line 202 
static void pcm_fsm(struct s_smc *smc, struct s_phy *phy, int cmd);


#line 203 
static void pc_rcode_actions(struct s_smc *smc, int bit, struct s_phy *phy);


#line 204 
static void pc_tcode_actions(struct s_smc *smc, int const bit, struct s_phy *phy);


#line 205 
static void reset_lem_struct(struct s_phy *phy);


#line 206 
static void plc_init(struct s_smc *smc, int p);


#line 207 
static void sm_ph_lem_start(struct s_smc *smc, int np, int threshold);


#line 208 
static void sm_ph_lem_stop(struct s_smc *smc, int np);


#line 209 
static void sm_ph_linestate(struct s_smc *smc, int phy, int ls);


#line 210 
static void real_init_plc(struct s_smc *smc);


#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
static void start_pcm_timer0(struct s_smc *smc, u_long value, int event, struct s_phy *phy)
{
  
#line 219 
  phy->timer0_exp = (unsigned char)0U;
  
#line 220 
  smt_timer_start(smc,& phy->pcm_timer0,value,((unsigned long)((int)phy->np + 5) << 16L) | (unsigned long)event);
  
#line 222 
  return;
}


#line 227  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
static void stop_pcm_timer0(struct s_smc *smc, struct s_phy *phy)
{
  
#line 229 
  if ((unsigned int)phy->pcm_timer0.tm_active != 0U) 
#line 230 
                                                     smt_timer_stop(smc,& phy->pcm_timer0); else ;
  
#line 231 
  return;
}


#line 237  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
void pcm_init(struct s_smc *smc)
{
  int i;
  int np;
  struct s_phy *phy;
  struct fddi_mib_p *mib;
  
#line 244 
  np = 0;
  
#line 244 
  phy = (struct s_phy *)(& smc->y);
  
#line 244 
  goto ldv_46351;
  ldv_46350: 
#line 245 
  ;
  
#line 246 
  mib = phy->mib;
  
#line 247 
  mib->fddiPORTPCMState = (unsigned short)32U;
  
#line 248 
  phy->np = (unsigned char)np;
  
#line 249 
  switch ((int)smc->s.sas) {
    case 1: 
#line 262 
    ;
    
#line 263 
    if (np == 0) 
#line 263 
                 mib->fddiPORTMy_Type = (unsigned short)2U; else 
#line 263 
                                                                 mib->fddiPORTMy_Type = (unsigned short)4U;
    
#line 264 
    mib->fddiPORTHardwarePresent = (unsigned char)(np == 0);
    
#line 269 
    (smc->y[1].mib)->fddiPORTPCMState = (unsigned short)0U;
    
#line 271 
    goto ldv_46326;
    case 0: 
#line 272 
    ;
    
#line 273 
    mib->fddiPORTMy_Type = (unsigned short)(np == 1);
    
#line 274 
    goto ldv_46326;
  }
  ldv_46326: 
#line 280 
  ;
  
#line 280 
  phy->pmd_scramble = (unsigned char)0U;
  
#line 281 
  switch ((int)phy->pmd_type[1]) {
    case 80: 
#line 282 
    ;
    
#line 283 
    mib->fddiPORTPMDClass = (unsigned short)0U;
    
#line 284 
    goto ldv_46329;
    case 76: 
#line 285 
    ;
    
#line 286 
    mib->fddiPORTPMDClass = (unsigned short)4U;
    
#line 287 
    goto ldv_46329;
    case 68: 
#line 288 
    ;
    
#line 289 
    mib->fddiPORTPMDClass = (unsigned short)5U;
    
#line 290 
    goto ldv_46329;
    case 83: 
#line 291 
    ;
    
#line 292 
    mib->fddiPORTPMDClass = (unsigned short)5U;
    
#line 293 
    phy->pmd_scramble = (unsigned char)1U;
    
#line 294 
    goto ldv_46329;
    case 85: 
#line 295 
    ;
    
#line 296 
    mib->fddiPORTPMDClass = (unsigned short)5U;
    
#line 297 
    phy->pmd_scramble = (unsigned char)1U;
    
#line 298 
    goto ldv_46329;
    case 49: 
#line 299 
    ;
    
#line 300 
    mib->fddiPORTPMDClass = (unsigned short)1U;
    
#line 301 
    goto ldv_46329;
    case 50: 
#line 302 
    ;
    
#line 303 
    mib->fddiPORTPMDClass = (unsigned short)2U;
    
#line 304 
    goto ldv_46329;
    case 51: 
#line 305 
    ;
    
#line 306 
    mib->fddiPORTPMDClass = (unsigned short)2U;
    
#line 307 
    goto ldv_46329;
    case 52: 
#line 308 
    ;
    
#line 309 
    mib->fddiPORTPMDClass = (unsigned short)1U;
    
#line 310 
    goto ldv_46329;
    case 72: 
#line 311 
    ;
    
#line 312 
    mib->fddiPORTPMDClass = (unsigned short)6U;
    
#line 313 
    goto ldv_46329;
    case 73: 
#line 314 
    ;
    
#line 315 
    mib->fddiPORTPMDClass = (unsigned short)5U;
    
#line 316 
    goto ldv_46329;
    case 71: 
#line 317 
    ;
    
#line 318 
    mib->fddiPORTPMDClass = (unsigned short)5U;
    
#line 319 
    goto ldv_46329;
    default: 
#line 320 
    ;
    
#line 321 
    mib->fddiPORTPMDClass = (unsigned short)6U;
    
#line 322 
    goto ldv_46329;
  }
  ldv_46329: 
#line 327 
  ;
  
#line 327 
  switch ((int)mib->fddiPORTMy_Type) {
    case 0: 
#line 328 
    ;
    
#line 329 
    mib->fddiPORTAvailablePaths = (unsigned char)((unsigned int)mib->fddiPORTAvailablePaths | 2U);
    
#line 330 
    mib->fddiPORTRequestedPaths[1] = (unsigned char)1U;
    
#line 331 
    mib->fddiPORTRequestedPaths[2] = (unsigned char)25U;
    
#line 335 
    mib->fddiPORTRequestedPaths[3] = (unsigned char)153U;
    
#line 340 
    goto ldv_46343;
    case 1: 
#line 341 
    ;
    
#line 342 
    mib->fddiPORTAvailablePaths = (unsigned char)((unsigned int)mib->fddiPORTAvailablePaths | 2U);
    
#line 343 
    mib->fddiPORTRequestedPaths[1] = (unsigned char)1U;
    
#line 344 
    mib->fddiPORTRequestedPaths[2] = (unsigned char)33U;
    
#line 347 
    mib->fddiPORTRequestedPaths[3] = (unsigned char)225U;
    
#line 352 
    goto ldv_46343;
    case 2: 
#line 353 
    ;
    
#line 354 
    mib->fddiPORTAvailablePaths = (unsigned char)((unsigned int)mib->fddiPORTAvailablePaths | 2U);
    
#line 355 
    mib->fddiPORTRequestedPaths[1] = (unsigned char)1U;
    
#line 356 
    mib->fddiPORTRequestedPaths[2] = (unsigned char)41U;
    
#line 360 
    mib->fddiPORTRequestedPaths[3] = (unsigned char)41U;
    
#line 364 
    goto ldv_46343;
    case 3: 
#line 365 
    ;
    
#line 366 
    mib->fddiPORTRequestedPaths[1] = (unsigned char)1U;
    
#line 367 
    mib->fddiPORTRequestedPaths[2] = (unsigned char)7U;
    
#line 371 
    mib->fddiPORTRequestedPaths[3] = (unsigned char)0U;
    
#line 372 
    goto ldv_46343;
  }
  ldv_46343: 
#line 375 
  ;
  
#line 375 
  phy->pc_lem_fail = (unsigned char)0U;
  
#line 376 
  mib->fddiPORTPCMStateX = mib->fddiPORTPCMState;
  
#line 377 
  mib->fddiPORTLCTFail_Ct = 0UL;
  
#line 378 
  mib->fddiPORTBS_Flag = (unsigned char)0U;
  
#line 379 
  mib->fddiPORTCurrentPath = (unsigned short)0U;
  
#line 380 
  mib->fddiPORTNeighborType = (unsigned short)4U;
  
#line 381 
  phy->ls_flag = (unsigned char)0U;
  
#line 382 
  phy->rc_flag = (unsigned char)0U;
  
#line 383 
  phy->tc_flag = (unsigned char)0U;
  
#line 384 
  phy->td_flag = (unsigned char)0U;
  
#line 385 
  if (np > 1) 
#line 386 
              phy->phy_name = (char)((unsigned int)np + 46U); else 
#line 388 
                                                                   phy->phy_name = (char)((unsigned int)np + 65U);
  
#line 389 
  phy->wc_flag = (unsigned char)0U;
  
#line 390 
  memset((void *)(& phy->lem),0,24UL);
  
#line 391 
  reset_lem_struct(phy);
  
#line 392 
  memset((void *)(& phy->plc),0,128UL);
  
#line 393 
  phy->plc.p_state = (unsigned short)0U;
  
#line 394 
  i = 0;
  
#line 394 
  goto ldv_46348;
  ldv_46347: 
#line 395 
  ;
  
#line 395 
  phy->t_next[i] = 0UL;
  
#line 394 
  i += 1;
  ldv_46348: 
#line 395 
  ;
  
#line 394 
  if (i <= 9) 
#line 396 
              goto ldv_46347; else 
#line 399 
                                   goto ldv_46349;
  ldv_46349: 
#line 400 
  ;
  
#line 244 
  np += 1;
  
#line 244 
  phy += 1;
  ldv_46351: 
#line 245 
  ;
  
#line 244 
  if (np <= 1) 
#line 246 
               goto ldv_46350; else 
#line 249 
                                    goto ldv_46352;
  ldv_46352: 
#line 250 
  ;
  
#line 398 
  real_init_plc(smc);
  
#line 399 
  return;
}


#line 401  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
void init_plc(struct s_smc *smc)
{
  
#line 404 
  return;
}


#line 414  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
static void real_init_plc(struct s_smc *smc)
{
  int p;
  
#line 418 
  p = 0;
  
#line 418 
  goto ldv_46361;
  ldv_46360: 
#line 419 
  ;
  
#line 419 
  plc_init(smc,p);
  
#line 418 
  p += 1;
  ldv_46361: 
#line 419 
  ;
  
#line 418 
  if (p <= 1) 
#line 420 
              goto ldv_46360; else 
#line 423 
                                   goto ldv_46362;
  ldv_46362: 
#line 424 
  ;
  
#line 425 
  return;
}


#line 422  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
static void plc_init(struct s_smc *smc, int p)
{
  int i;
  int rev;
  void *tmp;
  void *tmp_0;
  void *tmp_1;
  unsigned int tmp_3;
  void *tmp_2;
  void *tmp_6;
  void *tmp_7;
  void *tmp_8;
  
#line 430 
  if (p == 0) 
#line 430 
              tmp = smc->hw.iop + 1540U; else 
#line 430 
                                              tmp = smc->hw.iop + 900U;
  
#line 430 
  iowrite16((unsigned short)0,tmp);
  
#line 431 
  if (p == 0) 
#line 431 
              tmp_0 = smc->hw.iop + 1540U; else 
#line 431 
                                                tmp_0 = smc->hw.iop + 900U;
  
#line 431 
  iowrite16((unsigned short)3,tmp_0);
  
#line 432 
  if (p == 0) 
#line 432 
              tmp_1 = smc->hw.iop + 1536U; else 
#line 432 
                                                tmp_1 = smc->hw.iop + 896U;
  
#line 432 
  iowrite16((unsigned short)0,tmp_1);
  
#line 438 
  if (p == 0) 
#line 438 
              tmp_2 = smc->hw.iop + 1600U; else 
#line 438 
                                                tmp_2 = smc->hw.iop + 960U;
  
#line 438 
  tmp_3 = ioread16(tmp_2);
  
#line 438 
  rev = (int)tmp_3 & 63488;
  
#line 439 
  if (rev != 0) 
    
#line 442 
    if ((unsigned int)smc->y[p].pmd_scramble != 0U) {
      void *tmp_4;
      
#line 443 
      if (p == 0) 
#line 443 
                  tmp_4 = smc->hw.iop + 1576U; else 
#line 443 
                                                    tmp_4 = smc->hw.iop + 936U;
      
#line 443 
      ;
      
#line 443 
      iowrite16((unsigned short)((int)((unsigned short)((int)plcs_control_c_s[14] | ((int)plcs_control_c_s[15] << 8)))),tmp_4);
    }
    else {
      void *tmp_5;
      
#line 450 
      if (p == 0) 
#line 450 
                  tmp_5 = smc->hw.iop + 1576U; else 
#line 450 
                                                    tmp_5 = smc->hw.iop + 936U;
      
#line 450 
      ;
      
#line 450 
      iowrite16((unsigned short)((int)((unsigned short)((int)plcs_control_c_u[14] | ((int)plcs_control_c_u[15] << 8)))),tmp_5);
    }
  else ;
  
#line 461 
  i = 0;
  
#line 461 
  goto ldv_46370;
  ldv_46369: 
#line 462 
  ;
  
#line 462 
  if (p == 0) 
#line 462 
              tmp_6 = smc->hw.iop + ((pltm[i].timer << 2) | 1536); else 
                                                                    
#line 462 
                                                                    tmp_6 = smc->hw.iop + ((pltm[i].timer << 2) | 896);
  
#line 462 
  ;
  
#line 462 
  iowrite16((unsigned short)((int)((unsigned short)pltm[i].para)),tmp_6);
  
#line 461 
  i += 1;
  ldv_46370: 
#line 462 
  ;
  
#line 461 
  if (pltm[i].timer != 0) 
#line 463 
                          goto ldv_46369; else 
#line 466 
                                               goto ldv_46371;
  ldv_46371: 
#line 467 
  ;
  
#line 464 
  if (p == 0) 
#line 464 
              tmp_7 = smc->hw.iop + 1628U; else 
#line 464 
                                                tmp_7 = smc->hw.iop + 988U;
  
#line 464 
  ioread16(tmp_7);
  
#line 465 
  plc_clear_irq(smc,p);
  
#line 466 
  if (p == 0) 
#line 466 
              tmp_8 = smc->hw.iop + 1544U; else 
#line 466 
                                                tmp_8 = smc->hw.iop + 904U;
  
#line 466 
  ;
  
#line 466 
  iowrite16((unsigned short)((int)((unsigned short)plc_imsk_na)),tmp_8);
  
#line 476 
  if ((unsigned int)smc->s.sas == 1U && p == 0) {
    void *tmp_9;
    
#line 477 
    if (p == 0) 
#line 477 
                tmp_9 = smc->hw.iop + 1540U; else 
#line 477 
                                                  tmp_9 = smc->hw.iop + 900U;
    
#line 477 
    iowrite16((unsigned short)128,tmp_9);
  }
  else ;
  
#line 478 
  return;
}


#line 485  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
static void plc_go_state(struct s_smc *smc, int p, int state)
{
  void *port;
  int val;
  unsigned int tmp;
  
#line 492 
  if (p == 0) 
#line 492 
              port = smc->hw.iop + 1540U; else 
#line 492 
                                               port = smc->hw.iop + 900U;
  
#line 493 
  tmp = ioread16(port);
  
#line 493 
  val = (int)tmp & -8;
  
#line 494 
  iowrite16((unsigned short)((int)((unsigned short)val)),port);
  
#line 495 
  iowrite16((unsigned short)((int)((unsigned short)(val | state))),port);
  
#line 496 
  return;
}


#line 501  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
int sm_pm_get_ls(struct s_smc *smc, int phy)
{
  int state;
  unsigned int tmp_0;
  void *tmp;
  
#line 510 
  if (phy == 0) 
#line 510 
                tmp = smc->hw.iop + 1600U; else 
#line 510 
                                                tmp = smc->hw.iop + 960U;
  
#line 510 
  tmp_0 = ioread16(tmp);
  
#line 510 
  state = (int)tmp_0 & 224;
  
#line 511 
  switch (state) {
    case 128: 
#line 512 
    ;
    
#line 513 
    state = 12;
    
#line 514 
    goto ldv_46385;
    case 160: 
#line 515 
    ;
    
#line 516 
    state = 14;
    
#line 517 
    goto ldv_46385;
    case 192: 
#line 518 
    ;
    
#line 519 
    state = 15;
    
#line 520 
    goto ldv_46385;
    case 96: 
#line 521 
    ;
    case 224: 
#line 522 
    ;
    
#line 523 
    state = 13;
    
#line 524 
    goto ldv_46385;
    case 32: 
#line 525 
    ;
    
#line 526 
    state = 16;
    
#line 527 
    goto ldv_46385;
    default: 
#line 528 
    ;
    
#line 529 
    state = 17;
  }
  ldv_46385: 
#line 531 
  ;
  
#line 531 
  return state;
}


#line 534  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
static int plc_send_bits(struct s_smc *smc, struct s_phy *phy, int len)
{
  int __retres;
  int n;
  int i;
  unsigned int tmp_0;
  void *tmp;
  void *tmp_1;
  void *tmp_2;
  
#line 536 
  int np = (int)phy->np;
  
#line 543 
  i = len + -1;
  
#line 543 
  n = 0;
  
#line 543 
  goto ldv_46401;
  ldv_46400: 
#line 544 
  ;
  
#line 544 
  n = (n << 1) | (int)phy->t_val[(int)phy->bitn + i];
  
#line 543 
  i -= 1;
  ldv_46401: 
#line 544 
  ;
  
#line 543 
  if (i >= 0) 
#line 545 
              goto ldv_46400; else 
#line 548 
                                   goto ldv_46402;
  ldv_46402: 
#line 549 
  ;
  
#line 546 
  if (np == 0) 
#line 546 
               tmp = smc->hw.iop + 1604U; else 
#line 546 
                                               tmp = smc->hw.iop + 964U;
  
#line 546 
  tmp_0 = ioread16(tmp);
  
#line 546 
  if ((tmp_0 & 64U) != 0U) {
    
#line 550 
    __retres = 1;
    
#line 550 
    goto return_label;
  }
  else ;
  
#line 553 
  if (np == 0) 
#line 553 
               tmp_1 = smc->hw.iop + 1552U; else 
#line 553 
                                                 tmp_1 = smc->hw.iop + 912U;
  
#line 553 
  ;
  
#line 553 
  iowrite16((unsigned short)((int)((unsigned int)((unsigned short)len) + 65535U)),tmp_1);
  
#line 554 
  if (np == 0) 
#line 554 
               tmp_2 = smc->hw.iop + 1548U; else 
#line 554 
                                                 tmp_2 = smc->hw.iop + 908U;
  
#line 554 
  ;
  
#line 554 
  iowrite16((unsigned short)((int)((unsigned short)n)),tmp_2);
  
#line 565 
  __retres = 0;
  return_label: 
#line 565 
                return __retres;
}


#line 571  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
void plc_config_mux(struct s_smc *smc, int mux)
{
  unsigned int tmp_3;
  unsigned int tmp_4;
  
#line 573 
  if ((unsigned int)smc->s.sas != 0U) 
#line 574 
                                      goto return_label; else ;
  
#line 575 
  if (mux == 3) {
    unsigned int tmp;
    unsigned int tmp_0;
    
#line 576 
    ;
    
#line 576 
    tmp = ioread16(smc->hw.iop + 1540U);
    
#line 576 
    iowrite16((unsigned short)((int)((unsigned int)((unsigned short)tmp) | 32768U)),smc->hw.iop + 1540U);
    
#line 577 
    ;
    
#line 577 
    tmp_0 = ioread16(smc->hw.iop + 1536U);
    
#line 577 
    iowrite16((unsigned short)((int)((unsigned int)((unsigned short)tmp_0) | 4U)),smc->hw.iop + 1536U);
  }
  else {
    unsigned int tmp_1;
    unsigned int tmp_2;
    
#line 580 
    ;
    
#line 580 
    tmp_1 = ioread16(smc->hw.iop + 1540U);
    
#line 580 
    iowrite16((unsigned short)((int)((unsigned short)tmp_1) & 32767),smc->hw.iop + 1540U);
    
#line 581 
    ;
    
#line 581 
    tmp_2 = ioread16(smc->hw.iop + 1536U);
    
#line 581 
    iowrite16((unsigned short)((int)((unsigned short)tmp_2) & 65531),smc->hw.iop + 1536U);
  }
  
#line 583 
  ;
  
#line 583 
  tmp_3 = ioread16(smc->hw.iop + 900U);
  
#line 583 
  iowrite16((unsigned short)((int)((unsigned short)tmp_3) & 32767),smc->hw.iop + 900U);
  
#line 584 
  ;
  
#line 584 
  tmp_4 = ioread16(smc->hw.iop + 896U);
  
#line 584 
  iowrite16((unsigned short)((int)((unsigned short)tmp_4) & 65531),smc->hw.iop + 896U);
  return_label: 
#line 585 
                return;
}


#line 595  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
void pcm(struct s_smc *smc, int const np, int event)
{
  int state;
  int oldstate;
  struct s_phy *phy;
  struct fddi_mib_p *mib;
  
#line 606 
  if (np != 0 && (unsigned int)smc->s.sas == 1U) 
#line 607 
                                                 goto return_label; else ;
  
#line 609 
  phy = & smc->y[np];
  
#line 610 
  mib = phy->mib;
  
#line 611 
  oldstate = (int)mib->fddiPORTPCMState;
  ldv_46416: 
#line 612 
  ;
  
#line 619 
  state = (int)mib->fddiPORTPCMState;
  
#line 620 
  pcm_fsm(smc,phy,event);
  
#line 621 
  event = 0;
  
#line 622 
  if ((int)mib->fddiPORTPCMState != state) 
#line 624 
                                           goto ldv_46416; else 
#line 627 
                                                                goto ldv_46417;
  ldv_46417: 
#line 628 
  ;
  
#line 629 
  if (state == 5) 
#line 630 
                  mib->fddiPORTPCMStateX = (unsigned short)3U; else 
#line 632 
                                                                    mib->fddiPORTPCMStateX = (unsigned short)state;
  
#line 638 
  if ((int)mib->fddiPORTPCMState != oldstate && (oldstate == 8 || (unsigned int)mib->fddiPORTPCMState == 8U)) 
    
#line 640 
    smt_srf_event(smc,3,(int)phy->np + 1,0); else ;
  
#line 668 
  pcm_state_change(smc,np,state);
  return_label: 
#line 669 
                return;
}


#line 674  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
static void pcm_fsm(struct s_smc *smc, struct s_phy *phy, int cmd)
{
  int i;
  struct s_plc *plc;
  struct fddi_mib_p *mib;
  u_short plc_rev;
  
#line 677 
  int np = (int)phy->np;
  
#line 684 
  plc = & phy->plc;
  
#line 685 
  mib = phy->mib;
  
#line 690 
  switch (cmd) {
    void *tmp;
    unsigned int tmp_1;
    void *tmp_0;
    case 2: 
#line 691 
    ;
    
#line 693 
    if ((unsigned int)mib->fddiPORTPCMState != 9U) 
#line 694 
                                                   mib->fddiPORTPCMState = (unsigned short)32U; else ;
    
#line 699 
    goto return_label;
    case 1: 
#line 700 
    ;
    
#line 702 
    if ((unsigned int)mib->fddiPORTPCMState != 9U) 
#line 703 
                                                   mib->fddiPORTPCMState = (unsigned short)33U; else ;
    
#line 704 
    goto return_label;
    case 11: 
#line 705 
    ;
    
#line 707 
    mib->fddiPORTPCMState = (unsigned short)41U;
    
#line 711 
    goto return_label;
    case 24: 
#line 712 
    ;
    
#line 714 
    stop_pcm_timer0(smc,phy);
    
#line 715 
    if (np == 0) 
#line 715 
                 tmp = smc->hw.iop + 1540U; else 
#line 715 
                                                 tmp = smc->hw.iop + 900U;
    
#line 715 
    if (np == 0) 
#line 715 
                 tmp_0 = smc->hw.iop + 1540U; else 
#line 715 
                                                   tmp_0 = smc->hw.iop + 900U;
    
#line 715 
    tmp_1 = ioread16(tmp_0);
    
#line 715 
    iowrite16((unsigned short)((int)((unsigned short)tmp_1) & 65527),tmp);
    
#line 717 
    goto return_label;
  }
  
#line 720 
  switch ((int)mib->fddiPORTPCMState) {
    void *tmp_2;
    void *tmp_3;
    unsigned int tmp_5;
    void *tmp_4;
    void *tmp_6;
    unsigned int tmp_8;
    void *tmp_7;
    void *tmp_9;
    unsigned int tmp_11;
    void *tmp_10;
    void *tmp_12;
    unsigned int tmp_14;
    void *tmp_13;
    void *tmp_15;
    void *tmp_16;
    unsigned int tmp_18;
    void *tmp_17;
    unsigned int tmp_21;
    void *tmp_20;
    void *tmp_38;
    unsigned int tmp_40;
    void *tmp_39;
    void *tmp_41;
    unsigned int tmp_43;
    void *tmp_42;
    void *tmp_44;
    void *tmp_45;
    unsigned int tmp_47;
    void *tmp_46;
    void *tmp_48;
    unsigned int tmp_50;
    void *tmp_49;
    void *tmp_51;
    unsigned int tmp_53;
    void *tmp_52;
    void *tmp_54;
    unsigned int tmp_56;
    void *tmp_55;
    void *tmp_57;
    case 32: 
#line 721 
    ;
    
#line 722 
    stop_pcm_timer0(smc,phy);
    
#line 723 
    if (np == 0) 
#line 723 
                 tmp_2 = smc->hw.iop + 1536U; else 
#line 723 
                                                   tmp_2 = smc->hw.iop + 896U;
    
#line 723 
    iowrite16((unsigned short)0,tmp_2);
    
#line 724 
    if (np == 0) 
#line 724 
                 tmp_3 = smc->hw.iop + 1540U; else 
#line 724 
                                                   tmp_3 = smc->hw.iop + 900U;
    
#line 724 
    if (np == 0) 
#line 724 
                 tmp_4 = smc->hw.iop + 1540U; else 
#line 724 
                                                   tmp_4 = smc->hw.iop + 900U;
    
#line 724 
    tmp_5 = ioread16(tmp_4);
    
#line 724 
    iowrite16((unsigned short)((int)((unsigned short)tmp_5) & 65519),tmp_3);
    
#line 725 
    if (np == 0) 
#line 725 
                 tmp_6 = smc->hw.iop + 1540U; else 
#line 725 
                                                   tmp_6 = smc->hw.iop + 900U;
    
#line 725 
    if (np == 0) 
#line 725 
                 tmp_7 = smc->hw.iop + 1540U; else 
#line 725 
                                                   tmp_7 = smc->hw.iop + 900U;
    
#line 725 
    tmp_8 = ioread16(tmp_7);
    
#line 725 
    iowrite16((unsigned short)((int)((unsigned short)tmp_8) & 65527),tmp_6);
    
#line 726 
    sm_ph_lem_stop(smc,np);
    
#line 727 
    phy->cf_loop = (unsigned char)0U;
    
#line 728 
    phy->cf_join = (unsigned char)0U;
    
#line 729 
    queue_event(smc,2,np + 3);
    
#line 730 
    plc_go_state(smc,np,3);
    
#line 731 
    mib->fddiPORTConnectState = (unsigned short)0U;
    
#line 732 
    mib->fddiPORTPCMState = (unsigned short)((unsigned int)mib->fddiPORTPCMState & 65503U);
    
#line 733 
    goto ldv_46433;
    case 0: 
#line 734 
    ;
    
#line 736 
    if (cmd == 7) {
      
#line 737 
      mib->fddiPORTPCMState = (unsigned short)41U;
      
#line 738 
      goto ldv_46433;
    }
    else ;
    
#line 740 
    goto ldv_46433;
    case 33: 
#line 741 
    ;
    
#line 743 
    stop_pcm_timer0(smc,phy);
    
#line 744 
    mib->fddiPORTPCMState = (unsigned short)((unsigned int)mib->fddiPORTPCMState & 65503U);
    
#line 745 
    plc_go_state(smc,np,0);
    
#line 746 
    if (np == 0) 
#line 746 
                 tmp_9 = smc->hw.iop + 1540U; else 
#line 746 
                                                   tmp_9 = smc->hw.iop + 900U;
    
#line 746 
    if (np == 0) 
#line 746 
                 tmp_10 = smc->hw.iop + 1540U; else 
#line 746 
                                                    tmp_10 = smc->hw.iop + 900U;
    
#line 746 
    tmp_11 = ioread16(tmp_10);
    
#line 746 
    iowrite16((unsigned short)((int)((unsigned short)tmp_11) & 65519),tmp_9);
    
#line 747 
    if (np == 0) 
#line 747 
                 tmp_12 = smc->hw.iop + 1540U; else 
#line 747 
                                                    tmp_12 = smc->hw.iop + 900U;
    
#line 747 
    if (np == 0) 
#line 747 
                 tmp_13 = smc->hw.iop + 1540U; else 
#line 747 
                                                    tmp_13 = smc->hw.iop + 900U;
    
#line 747 
    tmp_14 = ioread16(tmp_13);
    
#line 747 
    iowrite16((unsigned short)((int)((unsigned short)tmp_14) & 65527),tmp_12);
    
#line 748 
    sm_ph_lem_stop(smc,np);
    
#line 761 
    plc_go_state(smc,np,3);
    
#line 763 
    if ((unsigned int)mib->fddiPORTPC_Withhold == 0U) 
#line 764 
                                                      mib->fddiPORTConnectState = (unsigned short)1U; else ;
    
#line 765 
    phy->cf_loop = (unsigned char)0U;
    
#line 766 
    phy->cf_join = (unsigned char)0U;
    
#line 767 
    queue_event(smc,2,np + 3);
    
#line 768 
    phy->ls_flag = (unsigned char)0U;
    
#line 769 
    phy->pc_mode = (unsigned char)0U;
    
#line 770 
    phy->bitn = (unsigned char)0U;
    
#line 771 
    i = 0;
    
#line 771 
    goto ldv_46437;
    ldv_46436: 
#line 772 
    ;
    
#line 772 
    pc_tcode_actions(smc,i,phy);
    
#line 771 
    i += 1;
    ldv_46437: 
#line 772 
    ;
    
#line 771 
    if (i <= 2) 
#line 773 
                goto ldv_46436; else 
#line 776 
                                     goto ldv_46438;
    ldv_46438: 
#line 777 
    ;
    
#line 775 
    if (np == 0) 
#line 775 
                 tmp_15 = smc->hw.iop + 1544U; else 
#line 775 
                                                    tmp_15 = smc->hw.iop + 904U;
    
#line 775 
    ;
    
#line 775 
    iowrite16((unsigned short)((int)((unsigned short)plc_imsk_na)),tmp_15);
    
#line 782 
    if (np == 0) 
#line 782 
                 tmp_16 = smc->hw.iop + 1628U; else 
#line 782 
                                                    tmp_16 = smc->hw.iop + 988U;
    
#line 782 
    ioread16(tmp_16);
    
#line 785 
    if (np == 0) 
#line 785 
                 tmp_17 = smc->hw.iop + 1600U; else 
#line 785 
                                                    tmp_17 = smc->hw.iop + 960U;
    
#line 785 
    tmp_18 = ioread16(tmp_17);
    
#line 785 
    plc_rev = (unsigned short)((unsigned int)((unsigned short)tmp_18) & 63488U);
    
#line 787 
    if ((unsigned int)plc_rev != 30720U) {
      int tmp_19;
      
#line 794 
      tmp_19 = plc_send_bits(smc,phy,3);
      
#line 794 
      if (tmp_19 != 0) 
#line 795 
                       goto return_label; else ;
    }
    else ;
    
#line 814 
    plc_go_state(smc,np,1);
    
#line 822 
    if (np == 0) 
#line 822 
                 tmp_20 = smc->hw.iop + 1600U; else 
#line 822 
                                                    tmp_20 = smc->hw.iop + 960U;
    
#line 822 
    tmp_21 = ioread16(tmp_20);
    
#line 822 
    if ((tmp_21 & 63488U) != 0U) {
      unsigned int tmp_23;
      void *tmp_22;
      
#line 824 
      if (np == 0) 
#line 824 
                   tmp_22 = smc->hw.iop + 1604U; else 
#line 824 
                                                      tmp_22 = smc->hw.iop + 964U;
      
#line 823 
      tmp_23 = ioread16(tmp_22);
      
#line 823 
      if ((tmp_23 & 64U) == 0U) 
#line 831 
                                plc_send_bits(smc,phy,3); else ;
    }
    else ;
    
#line 837 
    mib->fddiPORTPCMState = (unsigned short)37U;
    
#line 838 
    plc->p_state = (unsigned short)1U;
    
#line 839 
    plc->p_bits = (unsigned short)3U;
    
#line 840 
    plc->p_start = (unsigned short)0U;
    
#line 842 
    goto ldv_46433;
    case 1: 
#line 843 
    ;
    
#line 844 
    goto ldv_46433;
    case 34: 
#line 845 
    ;
    
#line 846 
    plc_go_state(smc,np,2);
    
#line 847 
    mib->fddiPORTPCMState = (unsigned short)((unsigned int)mib->fddiPORTPCMState & 65503U);
    
#line 848 
    goto ldv_46433;
    case 2: 
#line 849 
    ;
    
#line 850 
    goto ldv_46433;
    case 3: 
#line 852 
    ;
    case 4: 
#line 853 
    ;
    
#line 854 
    goto ldv_46433;
    case 37: 
#line 856 
    ;
    
#line 857 
    mib->fddiPORTPCMState = (unsigned short)((unsigned int)mib->fddiPORTPCMState & 65503U);
    case 5: 
#line 858 
    ;
    
#line 859 
    if (cmd != 5 && cmd != 24) 
#line 860 
                               goto ldv_46433; else ;
    
#line 861 
    switch ((int)plc->p_state) {
      int tmp_24;
      int tmp_25;
      unsigned int tmp_27;
      void *tmp_26;
      void *tmp_28;
      void *tmp_29;
      int tmp_30;
      int tmp_31;
      case 1: 
#line 862 
      ;
      
#line 863 
      i = 0;
      
#line 863 
      goto ldv_46448;
      ldv_46447: 
#line 864 
      ;
      
#line 864 
      pc_rcode_actions(smc,i,phy);
      
#line 863 
      i += 1;
      ldv_46448: 
#line 864 
      ;
      
#line 863 
      if (i <= 2) 
#line 865 
                  goto ldv_46447; else 
#line 868 
                                       goto ldv_46449;
      ldv_46449: 
#line 869 
      ;
      
#line 865 
      pc_tcode_actions(smc,3,phy);
      
#line 866 
      plc->p_state = (unsigned short)2U;
      
#line 867 
      plc->p_bits = (unsigned short)1U;
      
#line 868 
      plc->p_start = (unsigned short)3U;
      
#line 869 
      phy->bitn = (unsigned char)3U;
      
#line 870 
      tmp_24 = plc_send_bits(smc,phy,1);
      
#line 870 
      if (tmp_24 != 0) 
#line 871 
                       goto return_label; else ;
      
#line 873 
      goto ldv_46450;
      case 2: 
#line 874 
      ;
      
#line 875 
      pc_rcode_actions(smc,3,phy);
      
#line 876 
      i = 4;
      
#line 876 
      goto ldv_46453;
      ldv_46452: 
#line 877 
      ;
      
#line 877 
      pc_tcode_actions(smc,i,phy);
      
#line 876 
      i += 1;
      ldv_46453: 
#line 877 
      ;
      
#line 876 
      if (i <= 6) 
#line 878 
                  goto ldv_46452; else 
#line 881 
                                       goto ldv_46454;
      ldv_46454: 
#line 882 
      ;
      
#line 878 
      plc->p_state = (unsigned short)3U;
      
#line 879 
      plc->p_bits = (unsigned short)3U;
      
#line 880 
      plc->p_start = (unsigned short)4U;
      
#line 881 
      phy->bitn = (unsigned char)4U;
      
#line 882 
      tmp_25 = plc_send_bits(smc,phy,3);
      
#line 882 
      if (tmp_25 != 0) 
#line 883 
                       goto return_label; else ;
      
#line 885 
      goto ldv_46450;
      case 3: 
#line 886 
      ;
      
#line 887 
      i = 3;
      
#line 887 
      goto ldv_46457;
      ldv_46456: 
#line 888 
      ;
      
#line 888 
      pc_rcode_actions(smc,i,phy);
      
#line 887 
      i += 1;
      ldv_46457: 
#line 888 
      ;
      
#line 887 
      if (i <= 6) 
#line 889 
                  goto ldv_46456; else 
#line 892 
                                       goto ldv_46458;
      ldv_46458: 
#line 893 
      ;
      
#line 889 
      plc->p_state = (unsigned short)4U;
      
#line 890 
      plc->p_bits = (unsigned short)0U;
      
#line 891 
      plc->p_start = (unsigned short)7U;
      
#line 892 
      phy->bitn = (unsigned char)7U;
      
#line 893 
      sm_ph_lem_start(smc,np,(int)smc->s.lct_short);
      
#line 895 
      if (np == 0) 
#line 895 
                   tmp_26 = smc->hw.iop + 1540U; else 
#line 895 
                                                      tmp_26 = smc->hw.iop + 900U;
      
#line 895 
      tmp_27 = ioread16(tmp_26);
      
#line 895 
      i = (int)tmp_27 & -97;
      
#line 896 
      if (np == 0) 
#line 896 
                   tmp_28 = smc->hw.iop + 1540U; else 
#line 896 
                                                      tmp_28 = smc->hw.iop + 900U;
      
#line 896 
      ;
      
#line 896 
      iowrite16((unsigned short)((int)((unsigned short)i)),tmp_28);
      
#line 897 
      if (np == 0) 
#line 897 
                   tmp_29 = smc->hw.iop + 1540U; else 
#line 897 
                                                      tmp_29 = smc->hw.iop + 900U;
      
#line 897 
      ;
      
#line 897 
      iowrite16((unsigned short)((int)((unsigned short)(i | 96))),tmp_29);
      
#line 898 
      goto ldv_46450;
      case 4: 
#line 899 
      ;
      
#line 901 
      pc_tcode_actions(smc,7,phy);
      
#line 905 
      plc->p_state = (unsigned short)5U;
      
#line 906 
      plc->p_bits = (unsigned short)1U;
      
#line 907 
      plc->p_start = (unsigned short)7U;
      
#line 908 
      phy->bitn = (unsigned char)7U;
      
#line 909 
      tmp_30 = plc_send_bits(smc,phy,1);
      
#line 909 
      if (tmp_30 != 0) 
#line 910 
                       goto return_label; else ;
      
#line 912 
      goto ldv_46450;
      case 5: 
#line 913 
      ;
      
#line 915 
      pc_rcode_actions(smc,7,phy);
      
#line 916 
      if ((unsigned int)phy->t_val[7] != 0U || (unsigned int)phy->r_val[7] != 0U) {
        
#line 917 
        plc_go_state(smc,np,3);
        
#line 918 
        mib->fddiPORTPCMState = (unsigned short)33U;
        
#line 919 
        goto ldv_46450;
      }
      else ;
      
#line 921 
      i = 8;
      
#line 921 
      goto ldv_46462;
      ldv_46461: 
#line 922 
      ;
      
#line 922 
      pc_tcode_actions(smc,i,phy);
      
#line 921 
      i += 1;
      ldv_46462: 
#line 922 
      ;
      
#line 921 
      if (i <= 9) 
#line 923 
                  goto ldv_46461; else 
#line 926 
                                       goto ldv_46463;
      ldv_46463: 
#line 927 
      ;
      
#line 923 
      plc->p_state = (unsigned short)6U;
      
#line 924 
      plc->p_bits = (unsigned short)2U;
      
#line 925 
      plc->p_start = (unsigned short)8U;
      
#line 926 
      phy->bitn = (unsigned char)8U;
      
#line 927 
      tmp_31 = plc_send_bits(smc,phy,2);
      
#line 927 
      if (tmp_31 != 0) 
#line 928 
                       goto return_label; else ;
      
#line 930 
      goto ldv_46450;
      case 6: 
#line 931 
      ;
      
#line 932 
      i = 8;
      
#line 932 
      goto ldv_46466;
      ldv_46465: 
#line 933 
      ;
      
#line 933 
      pc_rcode_actions(smc,i,phy);
      
#line 932 
      i += 1;
      ldv_46466: 
#line 933 
      ;
      
#line 932 
      if (i <= 9) 
#line 934 
                  goto ldv_46465; else 
#line 937 
                                       goto ldv_46467;
      ldv_46467: 
#line 938 
      ;
      
#line 934 
      plc->p_state = (unsigned short)7U;
      
#line 935 
      mib->fddiPORTPCMState = (unsigned short)38U;
      
#line 936 
      goto ldv_46450;
    }
    ldv_46450: 
#line 938 
    ;
    
#line 938 
    goto ldv_46433;
    case 38: 
#line 940 
    ;
    
#line 944 
    if (((unsigned int)smc->s.sas == 0U && np == 1) && ((unsigned int)smc->y[0].pc_mode == 2U || (unsigned int)smc->y[1].pc_mode == 2U)) {
      void *tmp_32;
      unsigned int tmp_34;
      void *tmp_33;
      void *tmp_35;
      unsigned int tmp_37;
      void *tmp_36;
      
#line 947 
      if (np == 0) 
#line 947 
                   tmp_32 = smc->hw.iop + 1536U; else 
#line 947 
                                                      tmp_32 = smc->hw.iop + 896U;
      
#line 947 
      if (np == 0) 
#line 947 
                   tmp_33 = smc->hw.iop + 1536U; else 
#line 947 
                                                      tmp_33 = smc->hw.iop + 896U;
      
#line 947 
      tmp_34 = ioread16(tmp_33);
      
#line 947 
      iowrite16((unsigned short)((int)((unsigned int)((unsigned short)tmp_34) | 4U)),tmp_32);
      
#line 949 
      if (np == 0) 
#line 949 
                   tmp_35 = smc->hw.iop + 1540U; else 
#line 949 
                                                      tmp_35 = smc->hw.iop + 900U;
      
#line 949 
      if (np == 0) 
#line 949 
                   tmp_36 = smc->hw.iop + 1540U; else 
#line 949 
                                                      tmp_36 = smc->hw.iop + 900U;
      
#line 949 
      tmp_37 = ioread16(tmp_36);
      
#line 949 
      iowrite16((unsigned short)((int)((unsigned int)((unsigned short)tmp_37) | 32768U)),tmp_35);
    }
    else ;
    
#line 952 
    if (np == 0) 
#line 952 
                 tmp_38 = smc->hw.iop + 1540U; else 
#line 952 
                                                    tmp_38 = smc->hw.iop + 900U;
    
#line 952 
    if (np == 0) 
#line 952 
                 tmp_39 = smc->hw.iop + 1540U; else 
#line 952 
                                                    tmp_39 = smc->hw.iop + 900U;
    
#line 952 
    tmp_40 = ioread16(tmp_39);
    
#line 952 
    iowrite16((unsigned short)((int)((unsigned int)((unsigned short)tmp_40) | 16U)),tmp_38);
    
#line 953 
    if (np == 0) 
#line 953 
                 tmp_41 = smc->hw.iop + 1540U; else 
#line 953 
                                                    tmp_41 = smc->hw.iop + 900U;
    
#line 953 
    if (np == 0) 
#line 953 
                 tmp_42 = smc->hw.iop + 1540U; else 
#line 953 
                                                    tmp_42 = smc->hw.iop + 900U;
    
#line 953 
    tmp_43 = ioread16(tmp_42);
    
#line 953 
    iowrite16((unsigned short)((int)((unsigned int)((unsigned short)tmp_43) | 16U)),tmp_41);
    
#line 954 
    mib->fddiPORTPCMState = (unsigned short)((unsigned int)mib->fddiPORTPCMState & 65503U);
    
#line 955 
    cmd = 0;
    case 6: 
#line 957 
    ;
    
#line 958 
    switch ((int)plc->p_state) {
      case 7: 
#line 959 
      ;
      
#line 961 
      if ((unsigned int)phy->cf_join == 0U) {
        
#line 962 
        phy->cf_join = (unsigned char)1U;
        
#line 963 
        queue_event(smc,2,np + 3);
      }
      else ;
      
#line 965 
      if (cmd == 4) 
#line 966 
                    mib->fddiPORTPCMState = (unsigned short)40U; else ;
      
#line 968 
      if (cmd == 8) {
        
#line 969 
        mib->fddiPORTPCMState = (unsigned short)34U;
        
#line 970 
        goto ldv_46471;
      }
      else ;
      
#line 972 
      goto ldv_46471;
    }
    ldv_46471: 
#line 974 
    ;
    
#line 974 
    goto ldv_46433;
    case 7: 
#line 976 
    ;
    
#line 977 
    goto ldv_46433;
    case 40: 
#line 979 
    ;
    
#line 983 
    sm_ph_lem_start(smc,(int)phy->np,255);
    
#line 985 
    phy->tr_flag = (unsigned char)0U;
    
#line 986 
    mib->fddiPORTConnectState = (unsigned short)3U;
    
#line 989 
    if (np == 0) 
#line 989 
                 tmp_44 = smc->hw.iop + 1544U; else 
#line 989 
                                                    tmp_44 = smc->hw.iop + 904U;
    
#line 989 
    ;
    
#line 989 
    iowrite16((unsigned short)((int)((unsigned short)plc_imsk_act)),tmp_44);
    
#line 991 
    mib->fddiPORTPCMState = (unsigned short)((unsigned int)mib->fddiPORTPCMState & 65503U);
    
#line 992 
    goto ldv_46433;
    case 8: 
#line 993 
    ;
    
#line 996 
    if (cmd == 8) {
      
#line 997 
      mib->fddiPORTPCMState = (unsigned short)34U;
      
#line 998 
      goto ldv_46433;
    }
    else ;
    
#line 1002 
    goto ldv_46433;
    case 41: 
#line 1003 
    ;
    
#line 1004 
    stop_pcm_timer0(smc,phy);
    
#line 1005 
    if (np == 0) 
#line 1005 
                 tmp_45 = smc->hw.iop + 1540U; else 
#line 1005 
                                                    tmp_45 = smc->hw.iop + 900U;
    
#line 1005 
    if (np == 0) 
#line 1005 
                 tmp_46 = smc->hw.iop + 1540U; else 
#line 1005 
                                                    tmp_46 = smc->hw.iop + 900U;
    
#line 1005 
    tmp_47 = ioread16(tmp_46);
    
#line 1005 
    iowrite16((unsigned short)((int)((unsigned short)tmp_47) & 65519),tmp_45);
    
#line 1006 
    if (np == 0) 
#line 1006 
                 tmp_48 = smc->hw.iop + 1540U; else 
#line 1006 
                                                    tmp_48 = smc->hw.iop + 900U;
    
#line 1006 
    if (np == 0) 
#line 1006 
                 tmp_49 = smc->hw.iop + 1540U; else 
#line 1006 
                                                    tmp_49 = smc->hw.iop + 900U;
    
#line 1006 
    tmp_50 = ioread16(tmp_49);
    
#line 1006 
    iowrite16((unsigned short)((int)((unsigned short)tmp_50) & 65527),tmp_48);
    
#line 1007 
    if (np == 0) 
#line 1007 
                 tmp_51 = smc->hw.iop + 1544U; else 
#line 1007 
                                                    tmp_51 = smc->hw.iop + 904U;
    
#line 1007 
    if (np == 0) 
#line 1007 
                 tmp_52 = smc->hw.iop + 1544U; else 
#line 1007 
                                                    tmp_52 = smc->hw.iop + 904U;
    
#line 1007 
    tmp_53 = ioread16(tmp_52);
    
#line 1007 
    iowrite16((unsigned short)((int)((unsigned short)tmp_53) & 57343),tmp_51);
    
#line 1008 
    sm_ph_lem_stop(smc,np);
    
#line 1009 
    phy->cf_loop = (unsigned char)0U;
    
#line 1010 
    phy->cf_join = (unsigned char)0U;
    
#line 1011 
    queue_event(smc,2,np + 3);
    
#line 1012 
    plc_go_state(smc,np,3);
    
#line 1013 
    mib->fddiPORTConnectState = (unsigned short)0U;
    
#line 1014 
    if (np == 0) 
#line 1014 
                 tmp_54 = smc->hw.iop + 1540U; else 
#line 1014 
                                                    tmp_54 = smc->hw.iop + 900U;
    
#line 1014 
    if (np == 0) 
#line 1014 
                 tmp_55 = smc->hw.iop + 1540U; else 
#line 1014 
                                                    tmp_55 = smc->hw.iop + 900U;
    
#line 1014 
    tmp_56 = ioread16(tmp_55);
    
#line 1014 
    iowrite16((unsigned short)((int)((unsigned int)((unsigned short)tmp_56) | 4U)),tmp_54);
    
#line 1015 
    sm_ph_linestate(smc,np,(int)mib->fddiPORTMaint_LS + 12);
    
#line 1016 
    if (np == 0) 
#line 1016 
                 tmp_57 = smc->hw.iop + 1536U; else 
#line 1016 
                                                    tmp_57 = smc->hw.iop + 896U;
    
#line 1016 
    iowrite16((unsigned short)8,tmp_57);
    
#line 1017 
    mib->fddiPORTPCMState = (unsigned short)((unsigned int)mib->fddiPORTPCMState & 65503U);
    
#line 1018 
    goto ldv_46433;
    case 9: 
#line 1019 
    ;
    
#line 1022 
    if (cmd == 10) {
      
#line 1023 
      mib->fddiPORTPCMState = (unsigned short)32U;
      
#line 1024 
      goto ldv_46433;
    }
    else ;
    
#line 1026 
    goto ldv_46433;
    default: 
#line 1028 
    ;
    
#line 1029 
    printk("\001",118,(char *)"PCM : invalid state");
    
#line 1030 
    goto ldv_46433;
  }
  ldv_46433: 
#line 1032 
  ;
  return_label: 
#line 1033 
                return;
}


#line 1037  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
static void sm_ph_linestate(struct s_smc *smc, int phy, int ls)
{
  int cntrl;
  unsigned int tmp_0;
  void *tmp;
  void *tmp_1;
  
#line 1043 
  if (phy == 0) 
#line 1043 
                tmp = smc->hw.iop + 1540U; else 
#line 1043 
                                                tmp = smc->hw.iop + 900U;
  
#line 1044 
  tmp_0 = ioread16(tmp);
  
#line 1043 
  cntrl = (int)((tmp_0 & 4294965496U) | 7U);
  
#line 1045 
  switch (ls) {
    case 12: 
#line 1046 
    ;
    
#line 1047 
    cntrl = cntrl;
    
#line 1048 
    goto ldv_46485;
    case 14: 
#line 1049 
    ;
    
#line 1050 
    cntrl |= 768;
    
#line 1051 
    goto ldv_46485;
    case 15: 
#line 1052 
    ;
    
#line 1053 
    cntrl |= 512;
    
#line 1054 
    goto ldv_46485;
    default: 
#line 1055 
    ;
    case 13: 
#line 1056 
    ;
    
#line 1057 
    cntrl |= 256;
    
#line 1058 
    goto ldv_46485;
    case 16: 
#line 1059 
    ;
    
#line 1060 
    cntrl |= 1536;
    
#line 1061 
    goto ldv_46485;
  }
  ldv_46485: 
#line 1063 
  ;
  
#line 1063 
  if (phy == 0) 
#line 1063 
                tmp_1 = smc->hw.iop + 1540U; else 
#line 1063 
                                                  tmp_1 = smc->hw.iop + 900U;
  
#line 1063 
  ;
  
#line 1063 
  iowrite16((unsigned short)((int)((unsigned short)cntrl)),tmp_1);
  
#line 1064 
  return;
}


#line 1066  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
static void reset_lem_struct(struct s_phy *phy)
{
  
#line 1068 
  struct lem_counter *lem = & phy->lem;
  
#line 1070 
  (phy->mib)->fddiPORTLer_Estimate = (unsigned char)15U;
  
#line 1071 
  lem->lem_float_ber = (unsigned short)1500U;
  
#line 1072 
  return;
}


#line 1077  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
static void lem_evaluate(struct s_smc *smc, struct s_phy *phy)
{
  int ber;
  u_long errors;
  struct fddi_mib_p *mib;
  int cond;
  unsigned int tmp_0;
  void *tmp;
  
#line 1081 
  struct lem_counter *lem = & phy->lem;
  
#line 1085 
  mib = phy->mib;
  
#line 1087 
  if ((unsigned int)lem->lem_on == 0U) 
#line 1088 
                                       goto return_label; else ;
  
#line 1090 
  if ((unsigned int)phy->np == 0U) 
#line 1090 
                                   tmp = smc->hw.iop + 1640U; else 
#line 1090 
                                                                   tmp = smc->hw.iop + 1000U;
  
#line 1090 
  tmp_0 = ioread16(tmp);
  
#line 1090 
  errors = (unsigned long)tmp_0;
  
#line 1091 
  lem->lem_errors += errors;
  
#line 1092 
  mib->fddiPORTLem_Ct += errors;
  
#line 1094 
  errors = lem->lem_errors;
  
#line 1105 
  if (errors == 0UL) 
#line 1105 
                     ber = 15;
  else 
    
#line 1106 
    if (errors <= 9UL) 
#line 1106 
                       ber = 9;
    else 
      
#line 1107 
      if (errors <= 99UL) 
#line 1107 
                          ber = 8;
      else 
        
#line 1108 
        if (errors <= 999UL) 
#line 1108 
                             ber = 7;
        else 
          
#line 1109 
          if (errors <= 9999UL) 
#line 1109 
                                ber = 6;
          else 
            
#line 1110 
            if (errors <= 99999UL) 
#line 1110 
                                   ber = 5;
            else 
              
#line 1111 
              if (errors <= 999999UL) 
#line 1111 
                                      ber = 4;
              else 
                
#line 1112 
                if (errors <= 9999999UL) 
#line 1112 
                                         ber = 3;
                else 
                  
#line 1113 
                  if (errors <= 99999999UL) 
#line 1113 
                                            ber = 2;
                  else 
                    
#line 1114 
                    if (errors <= 999999999UL) 
#line 1114 
                                               ber = 1; else 
#line 1115 
                                                             ber = 0;
  
#line 1120 
  ber *= 100;
  
#line 1121 
  lem->lem_float_ber = (unsigned short)((unsigned int)lem->lem_float_ber * 7U + (unsigned int)((unsigned short)ber) * 3U);
  
#line 1122 
  lem->lem_float_ber = (unsigned short)((unsigned int)lem->lem_float_ber / 10U);
  
#line 1123 
  mib->fddiPORTLer_Estimate = (unsigned char)((unsigned int)lem->lem_float_ber / 100U);
  
#line 1124 
  if ((unsigned int)mib->fddiPORTLer_Estimate <= 3U) 
#line 1125 
                                                     mib->fddiPORTLer_Estimate = (unsigned char)4U; else ;
  
#line 1128 
  if (lem->lem_errors != 0UL) ; else ;
  
#line 1138 
  lem->lem_errors = 0UL;
  
#line 1141 
  cond = (int)mib->fddiPORTLer_Estimate <= (int)mib->fddiPORTLer_Alarm;
  
#line 1146 
  if ((int)mib->fddiPORTLerFlag != cond) 
#line 1147 
                                         smt_srf_event(smc,11,(int)phy->np + 1,cond); else ;
  
#line 1152 
  if ((int)mib->fddiPORTLer_Estimate <= (int)mib->fddiPORTLer_Cutoff) {
    
#line 1153 
    phy->pc_lem_fail = (unsigned char)1U;
    
#line 1154 
    mib->fddiPORTLem_Reject_Ct += 1UL;
    
#line 1159 
    lem->lem_float_ber = (unsigned short)((unsigned int)lem->lem_float_ber + 200U);
    
#line 1169 
    queue_event(smc,(int)phy->np + 5,1);
  }
  else ;
  return_label: 
#line 1171 
                return;
}


#line 1177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
void sm_lem_evaluate(struct s_smc *smc)
{
  int np;
  
#line 1181 
  np = 0;
  
#line 1181 
  goto ldv_46509;
  ldv_46508: 
#line 1182 
  ;
  
#line 1182 
  lem_evaluate(smc,& smc->y[np]);
  
#line 1181 
  np += 1;
  ldv_46509: 
#line 1182 
  ;
  
#line 1181 
  if (np <= 1) 
#line 1183 
               goto ldv_46508; else 
#line 1186 
                                    goto ldv_46510;
  ldv_46510: 
#line 1187 
  ;
  
#line 1188 
  return;
}


#line 1185  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
static void lem_check_lct(struct s_smc *smc, struct s_phy *phy)
{
  struct fddi_mib_p *mib;
  int errors;
  unsigned int tmp_0;
  void *tmp;
  
#line 1187 
  struct lem_counter *lem = & phy->lem;
  
#line 1191 
  mib = phy->mib;
  
#line 1193 
  phy->pc_lem_fail = (unsigned char)0U;
  
#line 1194 
  if ((unsigned int)phy->np == 0U) 
#line 1194 
                                   tmp = smc->hw.iop + 1640U; else 
#line 1194 
                                                                   tmp = smc->hw.iop + 1000U;
  
#line 1194 
  tmp_0 = ioread16(tmp);
  
#line 1194 
  errors = (int)tmp_0;
  
#line 1195 
  lem->lem_errors += (unsigned long)errors;
  
#line 1196 
  mib->fddiPORTLem_Ct += (unsigned long)errors;
  
#line 1197 
  if (lem->lem_errors != 0UL) {
    
#line 1198 
    switch ((int)phy->lc_test) {
      case 1: 
#line 1199 
      ;
      
#line 1200 
      if (lem->lem_errors >= smc->s.lct_short) 
#line 1201 
                                               phy->pc_lem_fail = (unsigned char)1U; else ;
      
#line 1202 
      goto ldv_46519;
      case 2: 
#line 1203 
      ;
      
#line 1204 
      if (lem->lem_errors >= smc->s.lct_medium) 
#line 1205 
                                                phy->pc_lem_fail = (unsigned char)1U; else ;
      
#line 1206 
      goto ldv_46519;
      case 3: 
#line 1207 
      ;
      
#line 1208 
      if (lem->lem_errors >= smc->s.lct_long) 
#line 1209 
                                              phy->pc_lem_fail = (unsigned char)1U; else ;
      
#line 1210 
      goto ldv_46519;
      case 4: 
#line 1211 
      ;
      
#line 1212 
      if (lem->lem_errors >= smc->s.lct_extended) 
#line 1213 
                                                  phy->pc_lem_fail = (unsigned char)1U; else ;
      
#line 1214 
      goto ldv_46519;
    }
    ldv_46519: 
#line 1216 
    ;
  }
  else ;
  
#line 1218 
  if ((unsigned int)phy->pc_lem_fail != 0U) {
    
#line 1219 
    mib->fddiPORTLCTFail_Ct += 1UL;
    
#line 1220 
    mib->fddiPORTLem_Reject_Ct += 1UL;
  }
  else 
#line 1223 
       mib->fddiPORTLCTFail_Ct = 0UL;
  
#line 1224 
  return;
}


#line 1229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
static void sm_ph_lem_start(struct s_smc *smc, int np, int threshold)
{
  void *tmp;
  void *tmp_0;
  void *tmp_1;
  unsigned int tmp_3;
  void *tmp_2;
  
#line 1231 
  struct lem_counter *lem = & smc->y[np].lem;
  
#line 1233 
  lem->lem_on = (unsigned short)1U;
  
#line 1234 
  lem->lem_errors = 0UL;
  
#line 1240 
  if (np == 0) 
#line 1240 
               tmp = smc->hw.iop + 1556U; else 
#line 1240 
                                               tmp = smc->hw.iop + 916U;
  
#line 1240 
  ;
  
#line 1240 
  iowrite16((unsigned short)((int)((unsigned short)threshold)),tmp);
  
#line 1241 
  if (np == 0) 
#line 1241 
               tmp_0 = smc->hw.iop + 1640U; else 
#line 1241 
                                                 tmp_0 = smc->hw.iop + 1000U;
  
#line 1241 
  ioread16(tmp_0);
  
#line 1244 
  if (np == 0) 
#line 1244 
               tmp_1 = smc->hw.iop + 1544U; else 
#line 1244 
                                                 tmp_1 = smc->hw.iop + 904U;
  
#line 1244 
  if (np == 0) 
#line 1244 
               tmp_2 = smc->hw.iop + 1544U; else 
#line 1244 
                                                 tmp_2 = smc->hw.iop + 904U;
  
#line 1244 
  tmp_3 = ioread16(tmp_2);
  
#line 1244 
  iowrite16((unsigned short)((int)((unsigned int)((unsigned short)tmp_3) | 8192U)),tmp_1);
  
#line 1245 
  return;
}


#line 1247  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
static void sm_ph_lem_stop(struct s_smc *smc, int np)
{
  void *tmp;
  unsigned int tmp_1;
  void *tmp_0;
  
#line 1249 
  struct lem_counter *lem = & smc->y[np].lem;
  
#line 1251 
  lem->lem_on = (unsigned short)0U;
  
#line 1252 
  if (np == 0) 
#line 1252 
               tmp = smc->hw.iop + 1544U; else 
#line 1252 
                                               tmp = smc->hw.iop + 904U;
  
#line 1252 
  if (np == 0) 
#line 1252 
               tmp_0 = smc->hw.iop + 1544U; else 
#line 1252 
                                                 tmp_0 = smc->hw.iop + 904U;
  
#line 1252 
  tmp_1 = ioread16(tmp_0);
  
#line 1252 
  iowrite16((unsigned short)((int)((unsigned short)tmp_1) & 57343),tmp);
  
#line 1253 
  return;
}


#line 1256  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
void sm_pm_ls_latch(struct s_smc *smc, int phy, int on_off)
{
  
#line 1261 
  phy = phy;
  
#line 1261 
  on_off = on_off;
  
#line 1262 
  return;
}


#line 1274  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
static void pc_rcode_actions(struct s_smc *smc, int bit, struct s_phy *phy)
{
  struct fddi_mib_p *mib;
  
#line 1278 
  mib = phy->mib;
  
#line 1281 
  bit += 1;
  
#line 1283 
  switch (bit) {
    case 0: 
#line 1284 
    ;
    case 1: 
#line 1285 
    ;
    case 2: 
#line 1286 
    ;
    
#line 1287 
    goto ldv_46548;
    case 3: 
#line 1288 
    ;
    
#line 1289 
    if ((unsigned int)phy->r_val[1] == 0U && (unsigned int)phy->r_val[2] == 0U) 
      
#line 1290 
      mib->fddiPORTNeighborType = (unsigned short)0U;
    else 
      
#line 1291 
      if ((unsigned int)phy->r_val[1] == 0U && (unsigned int)phy->r_val[2] == 1U) 
        
#line 1292 
        mib->fddiPORTNeighborType = (unsigned short)1U;
      else 
        
#line 1293 
        if ((unsigned int)phy->r_val[1] == 1U && (unsigned int)phy->r_val[2] == 0U) 
          
#line 1294 
          mib->fddiPORTNeighborType = (unsigned short)2U;
        else 
          
#line 1295 
          if ((unsigned int)phy->r_val[1] == 1U && (unsigned int)phy->r_val[2] == 1U) 
            
#line 1296 
            mib->fddiPORTNeighborType = (unsigned short)3U; else ;
    
#line 1297 
    goto ldv_46548;
    case 4: 
#line 1298 
    ;
    
#line 1299 
    if ((unsigned int)mib->fddiPORTMy_Type == 3U && (unsigned int)mib->fddiPORTNeighborType == 3U) {
      u_short tmp;
      
#line 1303 
      mib->fddiPORTPC_Withhold = (unsigned short)1U;
      
#line 1304 
      tmp = (unsigned short)((unsigned int)smc->srf.ring_status | 4U);
      
#line 1304 
      smc->srf.ring_status = tmp;
      
#line 1304 
      ;
      
#line 1304 
      ring_status_indication(smc,(unsigned long)tmp);
    }
    else 
      
#line 1306 
      if ((unsigned int)phy->t_val[3] != 0U || (unsigned int)phy->r_val[3] != 0U) {
        
#line 1307 
        mib->fddiPORTPC_Withhold = (unsigned short)0U;
        
#line 1308 
        if ((unsigned int)mib->fddiPORTMy_Type == 3U || (unsigned int)mib->fddiPORTNeighborType == 3U) 
          
#line 1310 
          phy->pc_mode = (unsigned char)2U; else 
#line 1312 
                                                 phy->pc_mode = (unsigned char)1U;
        
#line 1315 
        all_selection_criteria(smc);
        
#line 1317 
        if ((unsigned int)phy->wc_flag != 0U) 
#line 1318 
                                              mib->fddiPORTPC_Withhold = (unsigned short)3U; else ;
      }
      else {
        u_short tmp_0;
        
#line 1322 
        mib->fddiPORTPC_Withhold = (unsigned short)2U;
        
#line 1323 
        tmp_0 = (unsigned short)((unsigned int)smc->srf.ring_status | 4U);
        
#line 1323 
        smc->srf.ring_status = tmp_0;
        
#line 1323 
        ;
        
#line 1323 
        ring_status_indication(smc,(unsigned long)tmp_0);
      }
    
#line 1327 
    phy->twisted = (unsigned char)(((unsigned int)mib->fddiPORTMy_Type + 65534U > 1U && (int)mib->fddiPORTNeighborType == (int)mib->fddiPORTMy_Type) != 0);
    
#line 1331 
    if ((unsigned int)phy->twisted != 0U) ; else ;
    
#line 1335 
    goto ldv_46548;
    case 5: 
#line 1336 
    ;
    
#line 1337 
    goto ldv_46548;
    case 6: 
#line 1338 
    ;
    
#line 1339 
    if ((unsigned int)phy->t_val[4] != 0U || (unsigned int)phy->r_val[4] != 0U) 
      
#line 1340 
      if (((unsigned int)phy->t_val[4] != 0U && (unsigned int)phy->t_val[5] != 0U) || ((unsigned int)phy->r_val[4] != 0U && (unsigned int)phy->r_val[5] != 0U)) 
        
#line 1342 
        phy->lc_test = (unsigned char)4U; else 
#line 1344 
                                               phy->lc_test = (unsigned char)3U;
    else 
      
#line 1346 
      if ((unsigned int)phy->t_val[5] != 0U || (unsigned int)phy->r_val[5] != 0U) 
        
#line 1347 
        phy->lc_test = (unsigned char)2U; else 
#line 1349 
                                               phy->lc_test = (unsigned char)1U;
    
#line 1350 
    switch ((int)phy->lc_test) {
      void *tmp_1;
      void *tmp_2;
      void *tmp_3;
      unsigned int tmp_5;
      void *tmp_4;
      void *tmp_6;
      unsigned int tmp_8;
      void *tmp_7;
      case 1: 
#line 1351 
      ;
      
#line 1352 
      if ((unsigned int)phy->np == 0U) 
#line 1352 
                                       tmp_1 = smc->hw.iop + 1580U; else 
                                                                    
#line 1352 
                                                                    tmp_1 = smc->hw.iop + 940U;
      
#line 1352 
      iowrite16((unsigned short)63094,tmp_1);
      
#line 1353 
      phy->t_next[7] = smc->s.pcm_lc_short;
      
#line 1354 
      goto ldv_46554;
      case 2: 
#line 1355 
      ;
      
#line 1356 
      if ((unsigned int)phy->np == 0U) 
#line 1356 
                                       tmp_2 = smc->hw.iop + 1580U; else 
                                                                    
#line 1356 
                                                                    tmp_2 = smc->hw.iop + 940U;
      
#line 1356 
      iowrite16((unsigned short)41122,tmp_2);
      
#line 1357 
      phy->t_next[7] = smc->s.pcm_lc_medium;
      
#line 1358 
      goto ldv_46554;
      case 3: 
#line 1359 
      ;
      
#line 1360 
      if ((unsigned int)phy->np == 0U) 
#line 1360 
                                       tmp_3 = smc->hw.iop + 1540U; else 
                                                                    
#line 1360 
                                                                    tmp_3 = smc->hw.iop + 900U;
      
#line 1360 
      if ((unsigned int)phy->np == 0U) 
#line 1360 
                                       tmp_4 = smc->hw.iop + 1540U; else 
                                                                    
#line 1360 
                                                                    tmp_4 = smc->hw.iop + 900U;
      
#line 1360 
      tmp_5 = ioread16(tmp_4);
      
#line 1360 
      iowrite16((unsigned short)((int)((unsigned int)((unsigned short)tmp_5) | 8U)),tmp_3);
      
#line 1361 
      phy->t_next[7] = smc->s.pcm_lc_long;
      
#line 1362 
      goto ldv_46554;
      case 4: 
#line 1363 
      ;
      
#line 1364 
      if ((unsigned int)phy->np == 0U) 
#line 1364 
                                       tmp_6 = smc->hw.iop + 1540U; else 
                                                                    
#line 1364 
                                                                    tmp_6 = smc->hw.iop + 900U;
      
#line 1364 
      if ((unsigned int)phy->np == 0U) 
#line 1364 
                                       tmp_7 = smc->hw.iop + 1540U; else 
                                                                    
#line 1364 
                                                                    tmp_7 = smc->hw.iop + 900U;
      
#line 1364 
      tmp_8 = ioread16(tmp_7);
      
#line 1364 
      iowrite16((unsigned short)((int)((unsigned int)((unsigned short)tmp_8) | 8U)),tmp_6);
      
#line 1365 
      phy->t_next[7] = smc->s.pcm_lc_extended;
      
#line 1366 
      goto ldv_46554;
    }
    ldv_46554: 
#line 1368 
    ;
    
#line 1368 
    if (phy->t_next[7] > smc->s.pcm_lc_medium) 
#line 1369 
                                               start_pcm_timer0(smc,phy->t_next[7],24,phy); else ;
    
#line 1372 
    phy->t_next[9] = smc->s.pcm_t_next_9;
    
#line 1373 
    goto ldv_46548;
    case 7: 
#line 1374 
    ;
    
#line 1375 
    if ((unsigned int)phy->t_val[6] != 0U) 
#line 1376 
                                           phy->cf_loop = (unsigned char)1U; else ;
    
#line 1378 
    phy->td_flag = (unsigned char)1U;
    
#line 1379 
    goto ldv_46548;
    case 8: 
#line 1380 
    ;
    
#line 1381 
    if ((unsigned int)phy->t_val[7] != 0U || (unsigned int)phy->r_val[7] != 0U) 
      
#line 1384 
      queue_event(smc,(int)phy->np + 5,1); else ;
    
#line 1386 
    goto ldv_46548;
    case 9: 
#line 1387 
    ;
    
#line 1388 
    if ((unsigned int)phy->t_val[8] != 0U || (unsigned int)phy->r_val[8] != 0U) {
      
#line 1389 
      if ((unsigned int)phy->t_val[8] != 0U) 
#line 1390 
                                             phy->cf_loop = (unsigned char)1U; else ;
      
#line 1391 
      phy->td_flag = (unsigned char)1U;
    }
    else ;
    
#line 1393 
    goto ldv_46548;
    case 10: 
#line 1394 
    ;
    
#line 1395 
    if ((unsigned int)phy->r_val[9] != 0U) 
#line 1397 
                                           mib->fddiPORTMacIndicated.R_val = (unsigned char)1U; else 
                                                                    
#line 1401 
                                                                    mib->fddiPORTMacIndicated.R_val = (unsigned char)0U;
    
#line 1403 
    goto ldv_46548;
  }
  ldv_46548: 
#line 1405 
  ;
  
#line 1406 
  return;
}


#line 1410  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
static void pc_tcode_actions(struct s_smc *smc, int const bit, struct s_phy *phy)
{
  struct fddi_mib_p *mib;
  
#line 1412 
  int np = (int)phy->np;
  
#line 1415 
  mib = phy->mib;
  
#line 1417 
  switch (bit) {
    case 0: 
#line 1418 
    ;
    
#line 1419 
    phy->t_val[0] = (unsigned char)0U;
    
#line 1420 
    goto ldv_46570;
    case 1: 
#line 1421 
    ;
    
#line 1422 
    if ((unsigned int)mib->fddiPORTMy_Type + 65534U <= 1U) 
#line 1423 
                                                           phy->t_val[1] = (unsigned char)1U; else 
                                                                    
#line 1425 
                                                                    phy->t_val[1] = (unsigned char)0U;
    
#line 1426 
    goto ldv_46570;
    case 2: 
#line 1427 
    ;
    
#line 1428 
    if ((unsigned int)mib->fddiPORTMy_Type == 1U || (unsigned int)mib->fddiPORTMy_Type == 3U) 
      
#line 1429 
      phy->t_val[2] = (unsigned char)1U; else 
#line 1431 
                                              phy->t_val[2] = (unsigned char)0U;
    
#line 1432 
    goto ldv_46570;
    case 3: 
#line 1433 
    ;
    {
      int type;
      int ne;
      int policy;
      
#line 1438 
      type = (int)mib->fddiPORTMy_Type;
      
#line 1439 
      ne = (int)mib->fddiPORTNeighborType;
      
#line 1440 
      policy = (int)smc->mib.fddiSMTConnectionPolicy;
      
#line 1442 
      phy->t_val[3] = (unsigned char)1U;
      
#line 1443 
      switch (type) {
        case 0: 
#line 1444 
        ;
        
#line 1445 
        if (((((policy & 1) != 0 && ne == 0) || ((policy & 2) != 0 && ne == 1)) || ((policy & 4) != 0 && ne == 2)) || ((policy & 8) != 0 && ne == 3)) 
          
#line 1450 
          phy->t_val[3] = (unsigned char)0U; else ;
        
#line 1451 
        goto ldv_46578;
        case 1: 
#line 1452 
        ;
        
#line 1453 
        if (((((policy & 16) != 0 && ne == 0) || ((policy & 32) != 0 && ne == 1)) || ((policy & 64) != 0 && ne == 2)) || ((policy & 128) != 0 && ne == 3)) 
          
#line 1458 
          phy->t_val[3] = (unsigned char)0U; else ;
        
#line 1459 
        goto ldv_46578;
        case 2: 
#line 1460 
        ;
        
#line 1461 
        if (((((policy & 256) != 0 && ne == 0) || ((policy & 512) != 0 && ne == 1)) || ((policy & 1024) != 0 && ne == 2)) || ((policy & 2048) != 0 && ne == 3)) 
          
#line 1466 
          phy->t_val[3] = (unsigned char)0U; else ;
        
#line 1467 
        goto ldv_46578;
        case 3: 
#line 1468 
        ;
        
#line 1469 
        if ((((ne == 3 || ((policy & 4096) != 0 && ne == 0)) || ((policy & 8192) != 0 && ne == 1)) || ((policy & 16384) != 0 && ne == 2)) || ((policy & 32768) != 0 && ne == 3)) 
          
#line 1474 
          phy->t_val[3] = (unsigned char)0U; else ;
        
#line 1475 
        goto ldv_46578;
      }
      ldv_46578: 
#line 1481 
      ;
      
#line 1481 
      if (((((type == 0 && (ne == 0 || ne == 2)) || (type == 1 && ne == 1)) || (type == 1 && ne == 2)) || (type == 2 && ne == 0)) || (type == 2 && ne == 1)) 
        
#line 1487 
        smt_srf_event(smc,4,(int)phy->np + 1,0); else ;
    }
    
#line 1492 
    goto ldv_46570;
    case 4: 
#line 1493 
    ;
    
#line 1494 
    if ((unsigned int)mib->fddiPORTPC_Withhold == 0U) {
      
#line 1495 
      if ((unsigned int)phy->pc_lem_fail != 0U) {
        
#line 1496 
        phy->t_val[4] = (unsigned char)1U;
        
#line 1497 
        phy->t_val[5] = (unsigned char)0U;
      }
      else {
        
#line 1500 
        phy->t_val[4] = (unsigned char)0U;
        
#line 1501 
        if (mib->fddiPORTLCTFail_Ct != 0UL) 
#line 1502 
                                            phy->t_val[5] = (unsigned char)1U; else 
                                                                    
#line 1504 
                                                                    phy->t_val[5] = (unsigned char)0U;
        
#line 1511 
        if ((unsigned int)phy->wc_flag != 0U) 
#line 1512 
                                              phy->t_val[5] = (unsigned char)1U; else ;
      }
      
#line 1514 
      mib->fddiPORTConnectState = (unsigned short)1U;
    }
    else {
      
#line 1517 
      mib->fddiPORTConnectState = (unsigned short)2U;
      
#line 1518 
      phy->t_val[4] = (unsigned char)1U;
      
#line 1519 
      phy->t_val[5] = (unsigned char)1U;
    }
    
#line 1521 
    goto ldv_46570;
    case 5: 
#line 1522 
    ;
    
#line 1523 
    goto ldv_46570;
    case 6: 
#line 1524 
    ;
    
#line 1526 
    phy->t_val[6] = (unsigned char)0U;
    
#line 1527 
    goto ldv_46570;
    case 7: 
#line 1528 
    ;
    
#line 1529 
    phy->cf_loop = (unsigned char)0U;
    
#line 1530 
    lem_check_lct(smc,phy);
    
#line 1531 
    if ((unsigned int)phy->pc_lem_fail != 0U) 
#line 1534 
                                              phy->t_val[7] = (unsigned char)1U; else 
                                                                    
#line 1537 
                                                                    phy->t_val[7] = (unsigned char)0U;
    
#line 1538 
    goto ldv_46570;
    case 8: 
#line 1539 
    ;
    
#line 1540 
    phy->t_val[8] = (unsigned char)0U;
    
#line 1541 
    goto ldv_46570;
    case 9: 
#line 1542 
    ;
    
#line 1543 
    phy->cf_loop = (unsigned char)0U;
    
#line 1544 
    if ((unsigned int)mib->fddiPORTPC_Withhold != 0U || ((unsigned int)smc->s.sas == 0U && (unsigned int)phy->wc_flag != 0U)) {
      
#line 1546 
      queue_event(smc,np + 5,1);
      
#line 1547 
      goto ldv_46570;
    }
    else ;
    
#line 1549 
    phy->t_val[9] = (unsigned char)0U;
    
#line 1550 
    switch ((int)smc->s.sas) {
      case 0: 
#line 1551 
      ;
      
#line 1555 
      if ((unsigned int)phy->pc_mode == 2U) {
        
#line 1556 
        if (np == 1 || (np == 0 && (unsigned int)(smc->y[1].mib)->fddiPORTConnectState != 3U)) 
          
#line 1559 
          phy->t_val[9] = (unsigned char)1U; else ;
      }
      else 
        
#line 1562 
        if (np == 1) 
#line 1563 
                     phy->t_val[9] = (unsigned char)1U; else ;
      
#line 1565 
      goto ldv_46589;
      case 1: 
#line 1566 
      ;
      
#line 1567 
      if (np == 0) 
#line 1568 
                   phy->t_val[9] = (unsigned char)1U; else ;
      
#line 1569 
      goto ldv_46589;
    }
    ldv_46589: 
#line 1580 
    ;
    
#line 1580 
    mib->fddiPORTMacIndicated.T_val = phy->t_val[9];
    
#line 1581 
    goto ldv_46570;
  }
  ldv_46570: 
#line 1583 
  ;
  
#line 1584 
  return;
}


#line 1589  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
int pcm_status_twisted(struct s_smc *smc)
{
  int __retres;
  
#line 1591 
  int twist = 0;
  
#line 1592 
  if ((unsigned int)smc->s.sas != 0U) {
    
#line 1593 
    __retres = 0;
    
#line 1593 
    goto return_label;
  }
  else ;
  
#line 1594 
  if ((unsigned int)smc->y[0].twisted != 0U && (unsigned int)(smc->y[0].mib)->fddiPORTPCMState == 8U) 
    
#line 1595 
    twist |= 1; else ;
  
#line 1596 
  if ((unsigned int)smc->y[1].twisted != 0U && (unsigned int)(smc->y[1].mib)->fddiPORTPCMState == 8U) 
    
#line 1597 
    twist |= 2; else ;
  
#line 1598 
  __retres = twist;
  return_label: 
#line 1598 
                return __retres;
}


#line 1608  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
void pcm_status_state(struct s_smc *smc, int np, int *type, int *state, int *remote, int *mac)
{
  struct fddi_mib_p *mib;
  
#line 1611 
  struct s_phy *phy = & smc->y[np];
  
#line 1614 
  mib = phy->mib;
  
#line 1617 
  *mac = 0;
  
#line 1618 
  *type = (int)mib->fddiPORTMy_Type;
  
#line 1619 
  *state = (int)mib->fddiPORTConnectState;
  
#line 1620 
  *remote = (int)mib->fddiPORTNeighborType;
  
#line 1622 
  switch ((int)mib->fddiPORTPCMState) {
    case 8: 
#line 1623 
    ;
    
#line 1624 
    *mac = (int)mib->fddiPORTMacIndicated.R_val;
    
#line 1625 
    goto ldv_46606;
  }
  ldv_46606: 
#line 1627 
  ;
  
#line 1628 
  return;
}


#line 1632  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
int pcm_rooted_station(struct s_smc *smc)
{
  int __retres;
  int n;
  
#line 1636 
  n = 0;
  
#line 1636 
  goto ldv_46612;
  ldv_46611: 
#line 1637 
  ;
  
#line 1637 
  if ((unsigned int)(smc->y[n].mib)->fddiPORTPCMState == 8U && (unsigned int)(smc->y[n].mib)->fddiPORTNeighborType == 3U) {
    
#line 1639 
    __retres = 0;
    
#line 1639 
    goto return_label;
  }
  else ;
  
#line 1636 
  n += 1;
  ldv_46612: 
#line 1637 
  ;
  
#line 1636 
  if (n <= 1) 
#line 1638 
              goto ldv_46611; else 
#line 1641 
                                   goto ldv_46613;
  ldv_46613: 
#line 1642 
  ;
  
#line 1641 
  __retres = 1;
  return_label: 
#line 1641 
                return __retres;
}


#line 1647  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pcmplc.c"
void plc_irq(struct s_smc *smc, int np, unsigned int cmd)
{
  int n;
  int corr_mask;
  int i;
  
#line 1650 
  struct s_phy *phy = & smc->y[np];
  
#line 1651 
  struct s_plc *plc = & phy->plc;
  
#line 1658 
  if ((int)smc->s.numphys <= np) {
    
#line 1659 
    plc->soft_err += 1UL;
    
#line 1660 
    goto return_label;
  }
  else ;
  
#line 1662 
  if ((cmd & 512U) != 0U) {
    
#line 1666 
    if (plc->ebuf_cont == 0UL && (unsigned int)(phy->mib)->fddiPORTPCMState == 8U) 
      
#line 1673 
      (phy->mib)->fddiPORTEBError_Ct += 1UL; else ;
    
#line 1677 
    plc->ebuf_err += 1UL;
    
#line 1678 
    if (plc->ebuf_cont <= 1000UL) 
#line 1683 
                                  plc->ebuf_cont += 1UL; else ;
    
#line 1687 
    if (plc->ebuf_cont == 1000UL) {
      unsigned int tmp_1;
      void *tmp_0;
      
#line 1688 
      if (np == 0) 
#line 1688 
                   tmp_0 = smc->hw.iop + 1600U; else 
#line 1688 
                                                     tmp_0 = smc->hw.iop + 960U;
      
#line 1687 
      tmp_1 = ioread16(tmp_0);
      
#line 1687 
      if ((tmp_1 & 63488U) == 30720U) {
        void *tmp;
        
#line 1699 
        corr_mask = 124;
        
#line 1700 
        if (np == 0) 
#line 1700 
                     tmp = smc->hw.iop + 1544U; else 
#line 1700 
                                                     tmp = smc->hw.iop + 904U;
        
#line 1700 
        ;
        
#line 1700 
        iowrite16((unsigned short)((int)((unsigned short)corr_mask)),tmp);
        
#line 1706 
        queue_event(smc,1,2);
        
#line 1711 
        printk("\001",136,(char *)"Elasticity Buffer hang-up");
        
#line 1716 
        drv_reset_indication(smc);
      }
      else ;
    }
    else ;
  }
  else 
#line 1721 
       plc->ebuf_cont = 0UL;
  
#line 1723 
  if ((cmd & 1024U) != 0U) 
#line 1724 
                           plc->phyinv += 1UL; else ;
  
#line 1726 
  if ((cmd & 2048U) != 0U) 
#line 1727 
                           plc->vsym_ctr += 1UL; else ;
  
#line 1729 
  if ((cmd & 4096U) != 0U) 
#line 1730 
                           plc->mini_ctr += 1UL; else ;
  
#line 1732 
  if ((cmd & 8192U) != 0U) {
    int j;
    unsigned int tmp_3;
    void *tmp_2;
    unsigned int tmp_5;
    void *tmp_4;
    
#line 1738 
    if (np == 0) 
#line 1738 
                 tmp_2 = smc->hw.iop + 1556U; else 
#line 1738 
                                                   tmp_2 = smc->hw.iop + 916U;
    
#line 1738 
    tmp_3 = ioread16(tmp_2);
    
#line 1738 
    j = (int)tmp_3;
    
#line 1739 
    if (np == 0) 
#line 1739 
                 tmp_4 = smc->hw.iop + 1640U; else 
#line 1739 
                                                   tmp_4 = smc->hw.iop + 1000U;
    
#line 1739 
    tmp_5 = ioread16(tmp_4);
    
#line 1739 
    i = (int)tmp_5;
    
#line 1741 
    if (i < j) 
#line 1743 
               i += 256; else ;
    
#line 1746 
    if ((unsigned int)phy->lem.lem_on != 0U) {
      
#line 1750 
      phy->lem.lem_errors += (unsigned long)i;
      
#line 1751 
      (phy->mib)->fddiPORTLem_Ct += (unsigned long)i;
    }
    else ;
  }
  else ;
  
#line 1754 
  if ((cmd & 128U) != 0U) {
    
#line 1755 
    if ((unsigned int)plc->p_state == 4U) ; else ;
    
#line 1761 
    plc->tpc_exp += 1UL;
  }
  else ;
  
#line 1763 
  if ((cmd & 2U) != 0U) {
    unsigned int tmp_7;
    void *tmp_6;
    
#line 1764 
    if (np == 0) 
#line 1764 
                 tmp_6 = smc->hw.iop + 1540U; else 
#line 1764 
                                                   tmp_6 = smc->hw.iop + 900U;
    
#line 1764 
    tmp_7 = ioread16(tmp_6);
    
#line 1764 
    switch (tmp_7 & 30720U) {
      case (unsigned int)2048: 
#line 1765 
      ;
      
#line 1765 
      phy->curr_ls = (unsigned char)13U;
      
#line 1765 
      goto ldv_46626;
      case (unsigned int)4096: 
#line 1766 
      ;
      
#line 1766 
      phy->curr_ls = (unsigned char)15U;
      
#line 1766 
      goto ldv_46626;
      case (unsigned int)8192: 
#line 1767 
      ;
      
#line 1767 
      phy->curr_ls = (unsigned char)14U;
      
#line 1767 
      goto ldv_46626;
      case (unsigned int)16384: 
#line 1768 
      ;
      
#line 1768 
      phy->curr_ls = (unsigned char)12U;
      
#line 1768 
      goto ldv_46626;
    }
    ldv_46626: 
#line 1770 
    ;
  }
  else ;
  
#line 1771 
  if ((cmd & 32U) != 0U) {
    int reason;
    unsigned int tmp_9;
    void *tmp_8;
    
#line 1774 
    if (np == 0) 
#line 1774 
                 tmp_8 = smc->hw.iop + 1604U; else 
#line 1774 
                                                   tmp_8 = smc->hw.iop + 964U;
    
#line 1774 
    tmp_9 = ioread16(tmp_8);
    
#line 1774 
    reason = (int)tmp_9 & 7;
    
#line 1776 
    switch (reason) {
      case 1: 
#line 1777 
      ;
      
#line 1777 
      plc->b_pcs += 1UL;
      
#line 1777 
      goto ldv_46632;
      case 2: 
#line 1778 
      ;
      
#line 1778 
      plc->b_tpc += 1UL;
      
#line 1778 
      goto ldv_46632;
      case 3: 
#line 1779 
      ;
      
#line 1779 
      plc->b_tne += 1UL;
      
#line 1779 
      goto ldv_46632;
      case 4: 
#line 1780 
      ;
      
#line 1780 
      plc->b_qls += 1UL;
      
#line 1780 
      goto ldv_46632;
      case 5: 
#line 1781 
      ;
      
#line 1781 
      plc->b_ils += 1UL;
      
#line 1781 
      goto ldv_46632;
      case 6: 
#line 1782 
      ;
      
#line 1782 
      plc->b_hls += 1UL;
      
#line 1782 
      goto ldv_46632;
    }
    ldv_46632: 
#line 1786 
    ;
    
#line 1787 
    if ((unsigned int)smc->e.DisconnectFlag == 0U) 
#line 1789 
                                                   queue_event(smc,np + 5,1); else ;
    
#line 1794 
    goto return_label;
  }
  else ;
  
#line 1799 
  if ((cmd & 4U) != 0U) {
    unsigned int tmp_11;
    void *tmp_10;
    
#line 1800 
    queue_event(smc,np + 5,5);
    
#line 1801 
    if (np == 0) 
#line 1801 
                 tmp_10 = smc->hw.iop + 1624U; else 
#line 1801 
                                                    tmp_10 = smc->hw.iop + 984U;
    
#line 1801 
    tmp_11 = ioread16(tmp_10);
    
#line 1801 
    n = (int)tmp_11;
    
#line 1802 
    i = 0;
    
#line 1802 
    goto ldv_46639;
    ldv_46638: 
#line 1803 
    ;
    
#line 1803 
    phy->r_val[(int)plc->p_start + i] = (unsigned char)((unsigned int)((unsigned char)n) & 1U);
    
#line 1804 
    n >>= 1;
    
#line 1802 
    i += 1;
    ldv_46639: 
#line 1803 
    ;
    
#line 1802 
    if ((int)plc->p_bits > i) 
#line 1804 
                              goto ldv_46638; else 
#line 1807 
                                                   goto ldv_46640;
    ldv_46640: 
#line 1808 
    ;
  }
  else 
    
#line 1807 
    if ((cmd & 64U) != 0U) 
#line 1808 
                           queue_event(smc,np + 5,4); else ;
  
#line 1810 
  if ((cmd & 8U) != 0U) {
    
#line 1812 
    if ((unsigned int)phy->tr_flag == 0U) {
      
#line 1815 
      phy->tr_flag = (unsigned char)1U;
      
#line 1816 
      smc->e.trace_prop |= (unsigned long)(1 << np);
      
#line 1817 
      queue_event(smc,1,3);
    }
    else ;
  }
  else ;
  
#line 1824 
  if ((cmd & 16U) != 0U && (unsigned int)(phy->mib)->fddiPORTPCMState == 2U) {
    
#line 1826 
    if ((unsigned int)smc->e.path_test == 2U) {
      
#line 1830 
      smc->e.path_test = (unsigned char)4U;
      
#line 1831 
      queue_event(smc,1,4);
    }
    else ;
  }
  else ;
  
#line 1834 
  if ((cmd & 256U) != 0U) {
    
#line 1836 
    if ((unsigned int)(phy->mib)->fddiPORTPCMState == 8U) {
      
#line 1837 
      if ((unsigned int)phy->tr_flag == 0U) {
        
#line 1839 
        queue_event(smc,np + 5,1);
        
#line 1840 
        goto return_label;
      }
      else ;
    }
    else ;
  }
  else ;
  return_label: 
#line 1842 
                return;
}


#line 513  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/cmtdef.h"
void sm_mac_check_beacon_claim(struct s_smc *smc);


#line 529 
void rmt_indication(struct s_smc *smc, int i);


#line 569 
int sm_mac_get_tx_state(struct s_smc *smc);


#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/rmt.c"
static void rmt_fsm(struct s_smc *smc, int cmd);


#line 106 
static void start_rmt_timer0(struct s_smc *smc, u_long value, int event);


#line 107 
static void start_rmt_timer1(struct s_smc *smc, u_long value, int event);


#line 108 
static void start_rmt_timer2(struct s_smc *smc, u_long value, int event);


#line 109 
static void stop_rmt_timer0(struct s_smc *smc);


#line 110 
static void stop_rmt_timer1(struct s_smc *smc);


#line 111 
static void stop_rmt_timer2(struct s_smc *smc);


#line 112 
static void rmt_dup_actions(struct s_smc *smc);


#line 113 
static void rmt_reinsert_actions(struct s_smc *smc);


#line 114 
static void rmt_leave_actions(struct s_smc *smc);


#line 115 
static void rmt_new_dup_actions(struct s_smc *smc);


#line 125  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/rmt.c"
void rmt_init(struct s_smc *smc)
{
  
#line 127 
  smc->mib.m[0].fddiMACRMTState = (unsigned short)16U;
  
#line 128 
  smc->r.dup_addr_test = (unsigned char)0U;
  
#line 129 
  smc->r.da_flag = (unsigned char)0U;
  
#line 130 
  smc->mib.m[0].fddiMACMA_UnitdataAvailable = (unsigned char)0U;
  
#line 131 
  smc->r.sm_ma_avail = (unsigned char)0U;
  
#line 132 
  smc->r.loop_avail = (unsigned char)0U;
  
#line 133 
  smc->r.bn_flag = (unsigned char)0U;
  
#line 134 
  smc->r.jm_flag = (unsigned char)0U;
  
#line 135 
  smc->r.no_flag = (unsigned char)1U;
  
#line 136 
  return;
}


#line 147  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/rmt.c"
void rmt(struct s_smc *smc, int event)
{
  int state;
  ldv_46264: 
#line 150 
  ;
  
#line 156 
  state = (int)smc->mib.m[0].fddiMACRMTState;
  
#line 157 
  rmt_fsm(smc,event);
  
#line 158 
  event = 0;
  
#line 159 
  if ((int)smc->mib.m[0].fddiMACRMTState != state) 
#line 161 
                                                   goto ldv_46264; else 
                                                                    
#line 164 
                                                                    goto ldv_46265;
  ldv_46265: 
#line 165 
  ;
  
#line 160 
  rmt_state_change(smc,(int)smc->mib.m[0].fddiMACRMTState);
  
#line 161 
  return;
}


#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/rmt.c"
static void rmt_fsm(struct s_smc *smc, int cmd)
{
  
#line 171 
  if ((((unsigned int)smc->r.rm_join == 0U && (unsigned int)smc->r.rm_loop == 0U) && (unsigned int)smc->mib.m[0].fddiMACRMTState != 16U) && (unsigned int)smc->mib.m[0].fddiMACRMTState != 0U) {
    u_short tmp;
    
#line 174 
    tmp = (unsigned short)((unsigned int)smc->srf.ring_status | 32U);
    
#line 174 
    smc->srf.ring_status = tmp;
    
#line 174 
    ;
    
#line 174 
    ring_status_indication(smc,(unsigned long)tmp);
    
#line 175 
    rmt_indication(smc,0);
    
#line 176 
    smc->mib.m[0].fddiMACRMTState = (unsigned short)16U;
    
#line 177 
    goto return_label;
  }
  else ;
  
#line 180 
  switch ((int)smc->mib.m[0].fddiMACRMTState) {
    u_short tmp_0;
    u_short tmp_2;
    u_short tmp_4;
    case 16: 
#line 181 
    ;
    
#line 182 
    stop_rmt_timer0(smc);
    
#line 183 
    stop_rmt_timer1(smc);
    
#line 184 
    stop_rmt_timer2(smc);
    
#line 189 
    sm_ma_control(smc,5);
    
#line 190 
    smc->mib.m[0].fddiMACMA_UnitdataAvailable = (unsigned char)0U;
    
#line 191 
    smc->r.loop_avail = (unsigned char)0U;
    
#line 192 
    smc->r.sm_ma_avail = (unsigned char)0U;
    
#line 193 
    smc->r.no_flag = (unsigned char)1U;
    
#line 195 
    smc->mib.m[0].fddiMACRMTState = (unsigned short)((unsigned int)smc->mib.m[0].fddiMACRMTState & 65519U);
    
#line 196 
    goto ldv_46271;
    case 0: 
#line 197 
    ;
    
#line 199 
    if ((unsigned int)smc->r.rm_join != 0U || (unsigned int)smc->r.rm_loop != 0U) {
      
#line 206 
      sm_ma_control(smc,0);
      
#line 207 
      smc->mib.m[0].fddiMACRMTState = (unsigned short)17U;
      
#line 208 
      goto ldv_46271;
    }
    else ;
    
#line 210 
    goto ldv_46271;
    case 17: 
#line 211 
    ;
    
#line 212 
    start_rmt_timer0(smc,smc->s.rmt_t_non_op,12);
    
#line 213 
    stop_rmt_timer1(smc);
    
#line 214 
    stop_rmt_timer2(smc);
    
#line 215 
    sm_ma_control(smc,1);
    
#line 217 
    tmp_0 = (unsigned short)((unsigned int)smc->srf.ring_status | 32U);
    
#line 217 
    smc->srf.ring_status = tmp_0;
    
#line 217 
    ;
    
#line 217 
    ring_status_indication(smc,(unsigned long)tmp_0);
    
#line 218 
    smc->r.sm_ma_avail = (unsigned char)0U;
    
#line 219 
    rmt_indication(smc,0);
    
#line 220 
    smc->mib.m[0].fddiMACRMTState = (unsigned short)((unsigned int)smc->mib.m[0].fddiMACRMTState & 65519U);
    
#line 221 
    goto ldv_46271;
    case 1: 
#line 222 
    ;
    
#line 224 
    if (cmd == 1) {
      u_short tmp_1;
      
#line 225 
      tmp_1 = (unsigned short)((unsigned int)smc->srf.ring_status | 2U);
      
#line 225 
      smc->srf.ring_status = tmp_1;
      
#line 225 
      ;
      
#line 225 
      ring_status_indication(smc,(unsigned long)tmp_1);
      
#line 226 
      smc->mib.m[0].fddiMACRMTState = (unsigned short)18U;
      
#line 227 
      goto ldv_46271;
    }
    else 
      
#line 230 
      if (cmd == 12) {
        
#line 231 
        smc->r.bn_flag = (unsigned char)0U;
        
#line 232 
        smc->r.no_flag = (unsigned char)1U;
        
#line 233 
        smc->mib.m[0].fddiMACRMTState = (unsigned short)19U;
        
#line 234 
        goto ldv_46271;
      }
      else ;
    
#line 236 
    goto ldv_46271;
    case 18: 
#line 237 
    ;
    
#line 238 
    stop_rmt_timer0(smc);
    
#line 239 
    stop_rmt_timer1(smc);
    
#line 240 
    stop_rmt_timer2(smc);
    
#line 241 
    smc->r.no_flag = (unsigned char)0U;
    
#line 242 
    if ((unsigned int)smc->r.rm_loop != 0U) 
#line 243 
                                            smc->r.loop_avail = (unsigned char)1U; else ;
    
#line 244 
    if ((unsigned int)smc->r.rm_join != 0U) {
      
#line 245 
      smc->r.sm_ma_avail = (unsigned char)1U;
      
#line 246 
      if ((unsigned int)smc->mib.m[0].fddiMACMA_UnitdataEnable != 0U) 
        
#line 247 
        smc->mib.m[0].fddiMACMA_UnitdataAvailable = (unsigned char)1U; else 
                                                                    
#line 249 
                                                                    smc->mib.m[0].fddiMACMA_UnitdataAvailable = (unsigned char)0U;
    }
    else ;
    
#line 252 
    smc->srf.ring_status = (unsigned short)((unsigned int)smc->srf.ring_status & 65503U);
    
#line 252 
    ;
    
#line 252 
    ring_status_indication(smc,(unsigned long)smc->srf.ring_status);
    
#line 253 
    tmp_2 = (unsigned short)((unsigned int)smc->srf.ring_status | 2U);
    
#line 253 
    smc->srf.ring_status = tmp_2;
    
#line 253 
    ;
    
#line 253 
    ring_status_indication(smc,(unsigned long)tmp_2);
    
#line 254 
    rmt_indication(smc,1);
    
#line 255 
    smt_stat_counter(smc,0);
    
#line 256 
    smc->mib.m[0].fddiMACRMTState = (unsigned short)((unsigned int)smc->mib.m[0].fddiMACRMTState & 65519U);
    
#line 257 
    goto ldv_46271;
    case 2: 
#line 258 
    ;
    
#line 260 
    if (cmd == 2) {
      u_short tmp_3;
      
#line 261 
      smc->mib.m[0].fddiMACMA_UnitdataAvailable = (unsigned char)0U;
      
#line 262 
      smc->r.loop_avail = (unsigned char)0U;
      
#line 263 
      tmp_3 = (unsigned short)((unsigned int)smc->srf.ring_status | 2U);
      
#line 263 
      smc->srf.ring_status = tmp_3;
      
#line 263 
      ;
      
#line 263 
      ring_status_indication(smc,(unsigned long)tmp_3);
      
#line 264 
      smc->mib.m[0].fddiMACRMTState = (unsigned short)17U;
      
#line 265 
      goto ldv_46271;
    }
    else 
      
#line 268 
      if (cmd == 11) 
        
#line 269 
        if ((unsigned int)smc->mib.m[0].fddiMACMA_UnitdataEnable != 0U) 
          
#line 270 
          smc->mib.m[0].fddiMACMA_UnitdataAvailable = (unsigned char)1U; else 
                                                                    
#line 272 
                                                                    smc->mib.m[0].fddiMACMA_UnitdataAvailable = (unsigned char)0U;
      else 
        
#line 275 
        if ((unsigned int)smc->r.dup_addr_test == 2U) {
          
#line 276 
          smc->mib.m[0].fddiMACMA_UnitdataAvailable = (unsigned char)0U;
          
#line 277 
          smc->r.loop_avail = (unsigned char)0U;
          
#line 278 
          smc->r.da_flag = (unsigned char)1U;
          
#line 279 
          smc->mib.m[0].fddiMACRMTState = (unsigned short)21U;
          
#line 280 
          goto ldv_46271;
        }
        else ;
    
#line 282 
    goto ldv_46271;
    case 19: 
#line 283 
    ;
    
#line 284 
    start_rmt_timer0(smc,smc->s.mac_d_max * 2UL,16);
    
#line 285 
    start_rmt_timer1(smc,smc->s.rmt_t_stuck,13);
    
#line 286 
    start_rmt_timer2(smc,smc->s.rmt_t_poll,17);
    
#line 287 
    sm_mac_check_beacon_claim(smc);
    
#line 289 
    smc->mib.m[0].fddiMACRMTState = (unsigned short)((unsigned int)smc->mib.m[0].fddiMACRMTState & 65519U);
    
#line 290 
    goto ldv_46271;
    case 3: 
#line 291 
    ;
    
#line 292 
    if (cmd == 17) {
      
#line 293 
      start_rmt_timer2(smc,smc->s.rmt_t_poll,17);
      
#line 294 
      sm_mac_check_beacon_claim(smc);
      
#line 295 
      goto ldv_46271;
    }
    else ;
    
#line 297 
    if (cmd == 16) 
#line 298 
                   smc->r.timer0_exp = (unsigned char)1U; else ;
    
#line 306 
    if (cmd == 18) 
#line 307 
                   start_rmt_timer0(smc,smc->s.mac_d_max * 2UL,16); else ;
    
#line 312 
    if (cmd == 1) {
      
#line 313 
      smc->mib.m[0].fddiMACRMTState = (unsigned short)18U;
      
#line 314 
      goto ldv_46271;
    }
    else 
      
#line 317 
      if ((unsigned int)cmd + 4294967293U <= 1U && (unsigned int)smc->r.bn_flag != 0U) 
        
#line 319 
        smc->r.bn_flag = (unsigned char)0U;
      else 
        
#line 322 
        if (cmd == 6 && (unsigned int)smc->r.bn_flag == 0U) {
          int tx;
          
#line 329 
          tx = sm_mac_get_tx_state(smc);
          
#line 329 
          if (tx == 4) 
#line 329 
                       goto _LOR;
          else 
            
#line 329 
            if (tx == 5) {
              _LOR: {
                      
#line 331 
                      smc->r.bn_flag = (unsigned char)1U;
                      
#line 338 
                      start_rmt_timer1(smc,smc->s.rmt_t_stuck,13);
                    }
            }
            else ;
        }
        else 
          
#line 352 
          if (cmd == 5 && (unsigned int)smc->r.timer0_exp != 0U) {
            
#line 353 
            rmt_new_dup_actions(smc);
            
#line 354 
            smc->mib.m[0].fddiMACRMTState = (unsigned short)20U;
            
#line 355 
            goto ldv_46271;
          }
          else 
            
#line 358 
            if (cmd == 3 && (unsigned int)smc->r.timer0_exp != 0U) {
              
#line 359 
              rmt_new_dup_actions(smc);
              
#line 360 
              smc->mib.m[0].fddiMACRMTState = (unsigned short)20U;
              
#line 361 
              goto ldv_46271;
            }
            else 
              
#line 364 
              if (cmd == 7) {
                
#line 365 
                rmt_new_dup_actions(smc);
                
#line 366 
                smc->mib.m[0].fddiMACRMTState = (unsigned short)20U;
                
#line 367 
                goto ldv_46271;
              }
              else 
                
#line 370 
                if ((cmd == 13 && (unsigned int)smc->r.rm_join != 0U) && (unsigned int)smc->r.bn_flag != 0U) {
                  
#line 372 
                  smc->mib.m[0].fddiMACRMTState = (unsigned short)22U;
                  
#line 373 
                  goto ldv_46271;
                }
                else ;
    
#line 375 
    goto ldv_46271;
    case 20: 
#line 376 
    ;
    
#line 377 
    start_rmt_timer0(smc,smc->s.rmt_t_announce,14);
    
#line 378 
    start_rmt_timer1(smc,smc->s.rmt_t_stuck,13);
    
#line 379 
    start_rmt_timer2(smc,smc->s.rmt_t_poll,17);
    
#line 380 
    sm_mac_check_beacon_claim(smc);
    
#line 382 
    smc->mib.m[0].fddiMACRMTState = (unsigned short)((unsigned int)smc->mib.m[0].fddiMACRMTState & 65519U);
    
#line 383 
    goto ldv_46271;
    case 4: 
#line 384 
    ;
    
#line 385 
    if (cmd == 17) {
      
#line 386 
      start_rmt_timer2(smc,smc->s.rmt_t_poll,17);
      
#line 387 
      sm_mac_check_beacon_claim(smc);
      
#line 388 
      goto ldv_46271;
    }
    else ;
    
#line 391 
    if ((unsigned int)smc->r.da_flag == 0U) {
      
#line 392 
      smc->mib.m[0].fddiMACRMTState = (unsigned short)17U;
      
#line 393 
      goto ldv_46271;
    }
    else 
      
#line 396 
      if ((unsigned int)cmd + 4294967293U <= 1U && (unsigned int)smc->r.bn_flag != 0U) 
        
#line 398 
        smc->r.bn_flag = (unsigned char)0U;
      else 
        
#line 401 
        if (cmd == 6 && (unsigned int)smc->r.bn_flag == 0U) {
          int tx_0;
          
#line 408 
          tx_0 = sm_mac_get_tx_state(smc);
          
#line 408 
          if (tx_0 == 4) 
#line 408 
                         goto _LOR_0;
          else 
            
#line 408 
            if (tx_0 == 5) {
              _LOR_0: {
                        
#line 410 
                        smc->r.bn_flag = (unsigned char)1U;
                        
#line 417 
                        start_rmt_timer1(smc,smc->s.rmt_t_stuck,13);
                      }
            }
            else ;
        }
        else 
          
#line 431 
          if (cmd == 14 && (unsigned int)smc->r.bn_flag == 0U) 
#line 432 
                                                               rmt_dup_actions(smc);
          else 
            
#line 435 
            if (cmd == 1) {
              
#line 436 
              smc->r.no_flag = (unsigned char)0U;
              
#line 437 
              smc->mib.m[0].fddiMACRMTState = (unsigned short)21U;
              
#line 438 
              goto ldv_46271;
            }
            else 
              
#line 441 
              if ((cmd == 13 && (unsigned int)smc->r.rm_join != 0U) && (unsigned int)smc->r.bn_flag != 0U) {
                
#line 443 
                smc->mib.m[0].fddiMACRMTState = (unsigned short)22U;
                
#line 444 
                goto ldv_46271;
              }
              else ;
    
#line 446 
    goto ldv_46271;
    case 21: 
#line 447 
    ;
    
#line 448 
    stop_rmt_timer0(smc);
    
#line 449 
    stop_rmt_timer1(smc);
    
#line 450 
    stop_rmt_timer2(smc);
    
#line 452 
    smc->mib.m[0].fddiMACRMTState = (unsigned short)((unsigned int)smc->mib.m[0].fddiMACRMTState & 65519U);
    
#line 453 
    goto ldv_46271;
    case 5: 
#line 454 
    ;
    
#line 456 
    if ((unsigned int)smc->r.dup_addr_test == 1U) {
      
#line 457 
      smc->r.da_flag = (unsigned char)0U;
      
#line 458 
      smc->mib.m[0].fddiMACRMTState = (unsigned short)18U;
      
#line 459 
      goto ldv_46271;
    }
    else 
      
#line 462 
      if (cmd == 2) {
        
#line 463 
        smc->r.jm_flag = (unsigned char)0U;
        
#line 464 
        smc->r.bn_flag = (unsigned char)0U;
        
#line 465 
        smc->mib.m[0].fddiMACRMTState = (unsigned short)20U;
        
#line 466 
        goto ldv_46271;
      }
      else ;
    
#line 468 
    goto ldv_46271;
    case 22: 
#line 469 
    ;
    
#line 470 
    start_rmt_timer0(smc,smc->s.rmt_t_direct,15);
    
#line 471 
    stop_rmt_timer1(smc);
    
#line 472 
    start_rmt_timer2(smc,smc->s.rmt_t_poll,17);
    
#line 473 
    sm_ma_control(smc,3);
    
#line 474 
    tmp_4 = (unsigned short)((unsigned int)smc->srf.ring_status | 4096U);
    
#line 474 
    smc->srf.ring_status = tmp_4;
    
#line 474 
    ;
    
#line 474 
    ring_status_indication(smc,(unsigned long)tmp_4);
    
#line 476 
    smc->mib.m[0].fddiMACRMTState = (unsigned short)((unsigned int)smc->mib.m[0].fddiMACRMTState & 65519U);
    
#line 477 
    goto ldv_46271;
    case 6: 
#line 478 
    ;
    
#line 480 
    if (cmd == 17) {
      
#line 481 
      start_rmt_timer2(smc,smc->s.rmt_t_poll,17);
      
#line 482 
      sm_mac_check_beacon_claim(smc);
      
#line 491 
      goto ldv_46271;
    }
    else ;
    
#line 493 
    if ((unsigned int)cmd + 4294967293U <= 1U && (unsigned int)smc->r.da_flag == 0U) {
      
#line 495 
      smc->r.bn_flag = (unsigned char)0U;
      
#line 496 
      smc->mib.m[0].fddiMACRMTState = (unsigned short)19U;
      
#line 497 
      goto ldv_46271;
    }
    else 
      
#line 500 
      if ((unsigned int)cmd + 4294967293U <= 1U && (unsigned int)smc->r.da_flag != 0U) {
        
#line 502 
        smc->r.bn_flag = (unsigned char)0U;
        
#line 503 
        smc->mib.m[0].fddiMACRMTState = (unsigned short)20U;
        
#line 504 
        goto ldv_46271;
      }
      else 
        
#line 507 
        if (cmd == 15) {
          
#line 508 
          smc->mib.m[0].fddiMACRMTState = (unsigned short)23U;
          
#line 509 
          goto ldv_46271;
        }
        else ;
    
#line 511 
    goto ldv_46271;
    case 23: 
#line 512 
    ;
    
#line 513 
    stop_rmt_timer0(smc);
    
#line 514 
    stop_rmt_timer1(smc);
    
#line 515 
    stop_rmt_timer2(smc);
    
#line 516 
    smc->e.trace_prop |= 4UL;
    
#line 517 
    queue_event(smc,1,3);
    
#line 519 
    smc->mib.m[0].fddiMACRMTState = (unsigned short)((unsigned int)smc->mib.m[0].fddiMACRMTState & 65519U);
    
#line 520 
    goto ldv_46271;
    case 7: 
#line 521 
    ;
    
#line 522 
    goto ldv_46271;
    default: 
#line 523 
    ;
    
#line 524 
    printk("\001",122,(char *)"RMT : invalid state");
    
#line 525 
    goto ldv_46271;
  }
  ldv_46271: 
#line 527 
  ;
  return_label: 
#line 528 
                return;
}


#line 533  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/rmt.c"
static void rmt_dup_actions(struct s_smc *smc)
{
  
#line 535 
  if ((unsigned int)smc->r.jm_flag != 0U) ;
  else 
    
#line 538 
    if (smc->s.rmt_dup_mac_behavior != 0UL) {
      
#line 539 
      printk("\001",138,(char *)"RMT: duplicate MAC address detected. Ring NOT left!");
      
#line 540 
      rmt_reinsert_actions(smc);
    }
    else {
      
#line 543 
      printk("\001",135,(char *)"RMT: duplicate MAC address detected. Ring left!");
      
#line 544 
      rmt_leave_actions(smc);
    }
  
#line 546 
  return;
}


#line 552  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/rmt.c"
static void rmt_reinsert_actions(struct s_smc *smc)
{
  
#line 554 
  queue_event(smc,1,2);
  
#line 555 
  queue_event(smc,1,1);
  
#line 556 
  return;
}


#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/rmt.c"
static void rmt_new_dup_actions(struct s_smc *smc)
{
  
#line 563 
  smc->r.da_flag = (unsigned char)1U;
  
#line 564 
  smc->r.bn_flag = (unsigned char)0U;
  
#line 565 
  smc->r.jm_flag = (unsigned char)0U;
  
#line 572 
  if (smc->s.rmt_dup_mac_behavior != 0UL) {
    
#line 573 
    printk("\001",138,(char *)"RMT: duplicate MAC address detected. Ring NOT left!");
    
#line 574 
    rmt_reinsert_actions(smc);
  }
  else {
    
#line 577 
    printk("\001",135,(char *)"RMT: duplicate MAC address detected. Ring left!");
    
#line 578 
    rmt_leave_actions(smc);
  }
  
#line 580 
  return;
}


#line 586  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/rmt.c"
static void rmt_leave_actions(struct s_smc *smc)
{
  
#line 588 
  queue_event(smc,1,2);
  
#line 589 
  return;
}


#line 599  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/rmt.c"
static void start_rmt_timer0(struct s_smc *smc, u_long value, int event)
{
  
#line 601 
  smc->r.timer0_exp = (unsigned char)0U;
  
#line 602 
  smt_timer_start(smc,& smc->r.rmt_timer0,value,(unsigned long)(event | 196608));
  
#line 603 
  return;
}


#line 609  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/rmt.c"
static void start_rmt_timer1(struct s_smc *smc, u_long value, int event)
{
  
#line 611 
  smc->r.timer1_exp = (unsigned char)0U;
  
#line 612 
  smt_timer_start(smc,& smc->r.rmt_timer1,value,(unsigned long)(event | 196608));
  
#line 613 
  return;
}


#line 619  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/rmt.c"
static void start_rmt_timer2(struct s_smc *smc, u_long value, int event)
{
  
#line 621 
  smc->r.timer2_exp = (unsigned char)0U;
  
#line 622 
  smt_timer_start(smc,& smc->r.rmt_timer2,value,(unsigned long)(event | 196608));
  
#line 623 
  return;
}


#line 629  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/rmt.c"
static void stop_rmt_timer0(struct s_smc *smc)
{
  
#line 631 
  if ((unsigned int)smc->r.rmt_timer0.tm_active != 0U) 
#line 632 
                                                       smt_timer_stop(smc,& smc->r.rmt_timer0); else ;
  
#line 633 
  return;
}


#line 639  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/rmt.c"
static void stop_rmt_timer1(struct s_smc *smc)
{
  
#line 641 
  if ((unsigned int)smc->r.rmt_timer1.tm_active != 0U) 
#line 642 
                                                       smt_timer_stop(smc,& smc->r.rmt_timer1); else ;
  
#line 643 
  return;
}


#line 649  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/rmt.c"
static void stop_rmt_timer2(struct s_smc *smc)
{
  
#line 651 
  if ((unsigned int)smc->r.rmt_timer2.tm_active != 0U) 
#line 652 
                                                       smt_timer_stop(smc,& smc->r.rmt_timer2); else ;
  
#line 653 
  return;
}


#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
int memcmp(void const *, void const *, size_t);


#line 510  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/cmtdef.h"
void mac_update_counter(struct s_smc *smc);


#line 554 
void smt_start_watchdog(struct s_smc *smc);


#line 571 
int smt_action(struct s_smc *smc, int class, int code, int index);


#line 574 
void smt_pmf_received_pack(struct s_smc *smc, Mbuf *mb, int local);


#line 587 
void rtm_set_timer(struct s_smc *smc);


#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pmf.c"
static int smt_authorize(struct s_smc *smc, struct smt_header *sm);


#line 36 
static int smt_check_set_count(struct s_smc *smc, struct smt_header *sm);


#line 37 
static struct s_p_tab const *smt_get_ptab(u_short para);


#line 38 
static int smt_mib_phys(struct s_smc *smc);


#line 39 
static int smt_set_para(struct s_smc *smc, struct smt_para *pa, int index, int local, int set);


#line 43 
static Mbuf *smt_build_pmf_response(struct s_smc *smc, struct smt_header *req, int set, int local);


#line 45 
static int port_to_mib(struct s_smc *smc, int p);


#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pmf.c"
static struct s_p_tab const p_tab[142U] = {{.p_num = (unsigned short)4106U, .p_access = (unsigned char)16U, .p_offset = (unsigned short)0, .p_swap = {(char)0, (char)0, (char)0}}, {.p_num = (unsigned short)4107U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)58U, .p_swap = {(char)'8', (char)'\000'}}, {.p_num = (unsigned short)4109U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)66U, .p_swap = {(char)'S', (char)'\000'}}, {.p_num = (unsigned short)4110U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)68U, .p_swap = {(char)'S', (char)'\000'}}, {.p_num = (unsigned short)4111U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)70U, .p_swap = {(char)'S', (char)'\000'}}, {.p_num = (unsigned short)4112U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)72U, .p_swap = {(char)'D', (char)'\000'}}, {.p_num = (unsigned short)4113U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)104U, .p_swap = {(char)'D', (char)'\000'}}, {.p_num = (unsigned short)4114U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)136U, .p_swap = {(char)'S', (char)'\000'}}, {.p_num = (unsigned short)4116U, .p_access = (unsigned char)16U, .p_offset = (unsigned short)0, .p_swap = {(char)0, (char)0, (char)0}}, {.p_num = (unsigned short)4117U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)138U, .p_swap = {(char)'B', (char)'\000'}}, {.p_num = (unsigned short)4118U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)139U, .p_swap = {(char)'B', (char)'\000'}}, {.p_num = (unsigned short)4119U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)140U, .p_swap = {(char)'B', (char)'\000'}}, {.p_num = (unsigned short)4120U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)141U, .p_swap = {(char)'B', (char)'\000'}}, {.p_num = (unsigned short)4121U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)142U, .p_swap = {(char)'S', (char)'\000'}}, {.p_num = (unsigned short)4122U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)144U, .p_swap = {(char)'w', (char)'S', (char)'\000'}}, {.p_num = (unsigned short)4123U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)146U, .p_swap = {(char)'w', (char)'S', (char)'\000'}}, {.p_num = (unsigned short)4125U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)148U, .p_swap = {(char)'w', (char)'S', (char)'\000'}}, {.p_num = (unsigned short)4126U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)150U, .p_swap = {(char)'b', (char)'B', (char)'\000'}}, {.p_num = (unsigned short)4127U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)152U, .p_swap = {(char)'l', (char)'L', (char)'\000'}}, {.p_num = (unsigned short)4128U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)160U, .p_swap = {(char)'I', (char)'I', (char)'\000'}}, {.p_num = (unsigned short)4129U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)164U, .p_swap = {(char)'I', (char)'\000'}}, {.p_num = (unsigned short)4130U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)166U, .p_swap = {(char)'F', (char)'\000'}}, {.p_num = (unsigned short)4136U, .p_access = (unsigned char)16U, .p_offset = (unsigned short)0, .p_swap = {(char)0, (char)0, (char)0}}, {.p_num = (unsigned short)4137U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)168U, .p_swap = {(char)'E', (char)'\000'}}, {.p_num = (unsigned short)4138U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)170U, .p_swap = {(char)'E', (char)'\000'}}, {.p_num = (unsigned short)4140U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)174U, .p_swap = {(char)'F', (char)'\000'}}, {.p_num = (unsigned short)4141U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)172U, .p_swap = {(char)'E', (char)'\000'}}, {.p_num = (unsigned short)4142U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)175U, .p_swap = {(char)'F', (char)'\000'}}, {.p_num = (unsigned short)4146U, .p_access = (unsigned char)16U, .p_offset = (unsigned short)0, .p_swap = {(char)0, (char)0, (char)0}}, {.p_num = (unsigned short)4147U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)176U, .p_swap = {(char)'P', (char)'\000'}}, {.p_num = (unsigned short)4148U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)184U, .p_swap = {(char)'P', (char)'\000'}}, {.p_num = (unsigned short)4149U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)192U, .p_swap = {(char)'4', (char)'P', (char)'\000'}}, {.p_num = (unsigned short)4150U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)208U, .p_swap = {(char)'8', (char)'\000'}}, {.p_num = (unsigned short)4156U, .p_access = (unsigned char)4U, .p_offset = (unsigned short)0U, .p_swap = {(char)'w', (char)'S', (char)'\000'}}, {.p_num = (unsigned short)4336U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)0U, .p_swap = {(char)'8', (char)'\000'}}, {.p_num = (unsigned short)4337U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)8U, .p_swap = {(char)'8', (char)'\000'}}, {.p_num = (unsigned short)4338U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)16U, .p_swap = {(char)'l', (char)'L', (char)'\000'}}, {.p_num = (unsigned short)4339U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)24U, .p_swap = {(char)'l', (char)'L', (char)'\000'}}, {.p_num = (unsigned short)4340U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)32U, .p_swap = {(char)'l', (char)'L', (char)'\000'}}, {.p_num = (unsigned short)4341U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)40U, .p_swap = {(char)'l', (char)'L', (char)'\000'}}, {.p_num = (unsigned short)4342U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)48U, .p_swap = {(char)'l', (char)'L', (char)'\000'}}, {.p_num = (unsigned short)4343U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)56U, .p_swap = {(char)'w', (char)'S', (char)'\000'}}, {.p_num = (unsigned short)8202U, .p_access = (unsigned char)16U, .p_offset = (unsigned short)0, .p_swap = {(char)0, (char)0, (char)0}}, {.p_num = (unsigned short)8203U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)0U, .p_swap = {(char)'S', (char)'\000'}}, {.p_num = (unsigned short)8205U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)8U, .p_swap = {(char)'T', (char)'\000'}}, {.p_num = (unsigned short)8206U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)16U, .p_swap = {(char)'T', (char)'\000'}}, {.p_num = (unsigned short)8212U, .p_access = (unsigned char)16U, .p_offset = (unsigned short)0, .p_swap = {(char)0, (char)0, (char)0}}, {.p_num = (unsigned short)8214U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)27U, .p_swap = {(char)'B', (char)'\000'}}, {.p_num = (unsigned short)8215U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)28U, .p_swap = {(char)'S', (char)'\000'}}, {.p_num = (unsigned short)8216U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)30U, .p_swap = {(char)'A', (char)'\000'}}, {.p_num = (unsigned short)8217U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)36U, .p_swap = {(char)'A', (char)'\000'}}, {.p_num = (unsigned short)8218U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)42U, .p_swap = {(char)'A', (char)'\000'}}, {.p_num = (unsigned short)8219U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)48U, .p_swap = {(char)'A', (char)'\000'}}, {.p_num = (unsigned short)8221U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)54U, .p_swap = {(char)'E', (char)'\000'}}, {.p_num = (unsigned short)8224U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)56U, .p_swap = {(char)'w', (char)'S', (char)'\000'}}, {.p_num = (unsigned short)8225U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)58U, .p_swap = {(char)'E', (char)'\000'}}, {.p_num = (unsigned short)8226U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)60U, .p_swap = {(char)'S', (char)'\000'}}, {.p_num = (unsigned short)8232U, .p_access = (unsigned char)16U, .p_offset = (unsigned short)0, .p_swap = {(char)0, (char)0, (char)0}}, {.p_num = (unsigned short)8233U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)62U, .p_swap = {(char)'A', (char)'\000'}}, {.p_num = (unsigned short)8242U, .p_access = (unsigned char)16U, .p_offset = (unsigned short)0, .p_swap = {(char)0, (char)0, (char)0}}, {.p_num = (unsigned short)8243U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)88U, .p_swap = {(char)'T', (char)'\000'}}, {.p_num = (unsigned short)8244U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)96U, .p_swap = {(char)'T', (char)'\000'}}, {.p_num = (unsigned short)8245U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)112U, .p_swap = {(char)'T', (char)'\000'}}, {.p_num = (unsigned short)8246U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)128U, .p_swap = {(char)'T', (char)'\000'}}, {.p_num = (unsigned short)8248U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)136U, .p_swap = {(char)'T', (char)'\000'}}, {.p_num = (unsigned short)8249U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)144U, .p_swap = {(char)'T', (char)'\000'}}, {.p_num = (unsigned short)8250U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)152U, .p_swap = {(char)'T', (char)'\000'}}, {.p_num = (unsigned short)8251U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)160U, .p_swap = {(char)'T', (char)'\000'}}, {.p_num = (unsigned short)8252U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)168U, .p_swap = {(char)'T', (char)'\000'}}, {.p_num = (unsigned short)8253U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)176U, .p_swap = {(char)'T', (char)'\000'}}, {.p_num = (unsigned short)8254U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)184U, .p_swap = {(char)'T', (char)'\000'}}, {.p_num = (unsigned short)8262U, .p_access = (unsigned char)16U, .p_offset = (unsigned short)0, .p_swap = {(char)0, (char)0, (char)0}}, {.p_num = (unsigned short)8263U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)192U, .p_swap = {(char)'C', (char)'\000'}}, {.p_num = (unsigned short)8264U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)200U, .p_swap = {(char)'C', (char)'\000'}}, {.p_num = (unsigned short)8265U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)208U, .p_swap = {(char)'C', (char)'\000'}}, {.p_num = (unsigned short)8266U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)216U, .p_swap = {(char)'C', (char)'\000'}}, {.p_num = (unsigned short)8273U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)224U, .p_swap = {(char)'C', (char)'\000'}}, {.p_num = (unsigned short)8274U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)232U, .p_swap = {(char)'C', (char)'\000'}}, {.p_num = (unsigned short)8275U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)240U, .p_swap = {(char)'C', (char)'\000'}}, {.p_num = (unsigned short)8276U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)248U, .p_swap = {(char)'C', (char)'\000'}}, {.p_num = (unsigned short)8278U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)256U, .p_swap = {(char)'C', (char)'\000'}}, {.p_num = (unsigned short)8282U, .p_access = (unsigned char)16U, .p_offset = (unsigned short)0, .p_swap = {(char)0, (char)0, (char)0}}, {.p_num = (unsigned short)8287U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)320U, .p_swap = {(char)'w', (char)'S', (char)'\000'}}, {.p_num = (unsigned short)8288U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)322U, .p_swap = {(char)'S', (char)'\000'}}, {.p_num = (unsigned short)8292U, .p_access = (unsigned char)16U, .p_offset = (unsigned short)0, .p_swap = {(char)0, (char)0, (char)0}}, {.p_num = (unsigned short)8295U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)324U, .p_swap = {(char)'w', (char)'S', (char)'\000'}}, {.p_num = (unsigned short)8297U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)326U, .p_swap = {(char)'S', (char)'\000'}}, {.p_num = (unsigned short)8302U, .p_access = (unsigned char)16U, .p_offset = (unsigned short)0, .p_swap = {(char)0, (char)0, (char)0}}, {.p_num = (unsigned short)8303U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)328U, .p_swap = {(char)'S', (char)'\000'}}, {.p_num = (unsigned short)8304U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)330U, .p_swap = {(char)'F', (char)'\000'}}, {.p_num = (unsigned short)8305U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)331U, .p_swap = {(char)'F', (char)'\000'}}, {.p_num = (unsigned short)8306U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)332U, .p_swap = {(char)'F', (char)'\000'}}, {.p_num = (unsigned short)8307U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)333U, .p_swap = {(char)'F', (char)'\000'}}, {.p_num = (unsigned short)8308U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)334U, .p_swap = {(char)'F', (char)'\000'}}, {.p_num = (unsigned short)8309U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)335U, .p_swap = {(char)'F', (char)'\000'}}, {.p_num = (unsigned short)8310U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)336U, .p_swap = {(char)'b', (char)'F', (char)'\000'}}, {.p_num = (unsigned short)8432U, .p_access = (unsigned char)8U, .p_offset = (unsigned short)0, .p_swap = {(char)0, (char)0, (char)0}}, {.p_num = (unsigned short)8433U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)72U, .p_swap = {(char)'l', (char)'T', (char)'\000'}}, {.p_num = (unsigned short)12810U, .p_access = (unsigned char)16U, .p_offset = (unsigned short)0, .p_swap = {(char)0, (char)0, (char)0}}, {.p_num = (unsigned short)12811U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)0U, .p_swap = {(char)'r', (char)'\000'}}, {.p_num = (unsigned short)12815U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)8U, .p_swap = {(char)'l', (char)'4', (char)'\000'}}, {.p_num = (unsigned short)12816U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)16U, .p_swap = {(char)'l', (char)'4', (char)'\000'}}, {.p_num = (unsigned short)12818U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)0U, .p_swap = {(char)'\000'}}, {.p_num = (unsigned short)12819U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)24U, .p_swap = {(char)'l', (char)'T', (char)'\000'}}, {.p_num = (unsigned short)12820U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)32U, .p_swap = {(char)'l', (char)'L', (char)'\000'}}, {.p_num = (unsigned short)12821U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)40U, .p_swap = {(char)'l', (char)'T', (char)'\000'}}, {.p_num = (unsigned short)12822U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)48U, .p_swap = {(char)'l', (char)'T', (char)'\000'}}, {.p_num = (unsigned short)12823U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)56U, .p_swap = {(char)'l', (char)'T', (char)'\000'}}, {.p_num = (unsigned short)16394U, .p_access = (unsigned char)16U, .p_offset = (unsigned short)0, .p_swap = {(char)0, (char)0, (char)0}}, {.p_num = (unsigned short)16396U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)0U, .p_swap = {(char)'E', (char)'\000'}}, {.p_num = (unsigned short)16397U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)2U, .p_swap = {(char)'E', (char)'\000'}}, {.p_num = (unsigned short)16398U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)4U, .p_swap = {(char)'b', (char)'B', (char)'\000'}}, {.p_num = (unsigned short)16399U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)5U, .p_swap = {(char)'2', (char)'\000'}}, {.p_num = (unsigned short)16400U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)8U, .p_swap = {(char)'E', (char)'\000'}}, {.p_num = (unsigned short)16401U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)10U, .p_swap = {(char)'l', (char)'4', (char)'\000'}}, {.p_num = (unsigned short)16402U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)14U, .p_swap = {(char)'S', (char)'\000'}}, {.p_num = (unsigned short)16403U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)16U, .p_swap = {(char)'B', (char)'\000'}}, {.p_num = (unsigned short)16406U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)18U, .p_swap = {(char)'E', (char)'\000'}}, {.p_num = (unsigned short)16407U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)17U, .p_swap = {(char)'B', (char)'\000'}}, {.p_num = (unsigned short)16413U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)20U, .p_swap = {(char)'R', (char)'\000'}}, {.p_num = (unsigned short)16414U, .p_access = (unsigned char)16U, .p_offset = (unsigned short)0, .p_swap = {(char)0, (char)0, (char)0}}, {.p_num = (unsigned short)16415U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)22U, .p_swap = {(char)'w', (char)'E', (char)'\000'}}, {.p_num = (unsigned short)16417U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)26U, .p_swap = {(char)'F', (char)'\000'}}, {.p_num = (unsigned short)16418U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)24U, .p_swap = {(char)'E', (char)'\000'}}, {.p_num = (unsigned short)16424U, .p_access = (unsigned char)16U, .p_offset = (unsigned short)0, .p_swap = {(char)0, (char)0, (char)0}}, {.p_num = (unsigned short)16425U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)40U, .p_swap = {(char)'C', (char)'\000'}}, {.p_num = (unsigned short)16426U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)32U, .p_swap = {(char)'C', (char)'\000'}}, {.p_num = (unsigned short)16434U, .p_access = (unsigned char)16U, .p_offset = (unsigned short)0, .p_swap = {(char)0, (char)0, (char)0}}, {.p_num = (unsigned short)16435U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)72U, .p_swap = {(char)'F', (char)'\000'}}, {.p_num = (unsigned short)16436U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)56U, .p_swap = {(char)'C', (char)'\000'}}, {.p_num = (unsigned short)16437U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)64U, .p_swap = {(char)'C', (char)'\000'}}, {.p_num = (unsigned short)16442U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)73U, .p_swap = {(char)'b', (char)'B', (char)'\000'}}, {.p_num = (unsigned short)16443U, .p_access = (unsigned char)2U, .p_offset = (unsigned short)74U, .p_swap = {(char)'b', (char)'B', (char)'\000'}}, {.p_num = (unsigned short)16444U, .p_access = (unsigned char)16U, .p_offset = (unsigned short)0, .p_swap = {(char)0, (char)0, (char)0}}, {.p_num = (unsigned short)16445U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)76U, .p_swap = {(char)'E', (char)'\000'}}, {.p_num = (unsigned short)16446U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)80U, .p_swap = {(char)'E', (char)'\000'}}, {.p_num = (unsigned short)16447U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)82U, .p_swap = {(char)'E', (char)'\000'}}, {.p_num = (unsigned short)16448U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)85U, .p_swap = {(char)'F', (char)'\000'}}, {.p_num = (unsigned short)16449U, .p_access = (unsigned char)1U, .p_offset = (unsigned short)84U, .p_swap = {(char)'F', (char)'\000'}}, {.p_num = (unsigned short)16454U, .p_access = (unsigned char)4U, .p_offset = (unsigned short)0U, .p_swap = {(char)'w', (char)'S', (char)'\000'}}, {.p_num = (unsigned short)0U, .p_access = (unsigned char)16U, .p_offset = (unsigned short)0, .p_swap = {(char)0, (char)0, (char)0}}, {.p_num = (unsigned short)0U, .p_access = (unsigned char)0, .p_offset = (unsigned short)0, .p_swap = {(char)0, (char)0, (char)0}}};

#line 281  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pmf.c"
void smt_pmf_received_pack(struct s_smc *smc, Mbuf *mb, int local)
{
  struct smt_header *sm;
  Mbuf *reply;
  
#line 286 
  sm = (struct smt_header *)(& mb->m_data) + (int)mb->m_off;
  
#line 295 
  smt_start_watchdog(smc);
  
#line 297 
  if ((unsigned int)sm->smt_class + 248U <= 1U) {
    
#line 299 
    reply = smt_build_pmf_response(smc,sm,(unsigned int)sm->smt_class == 9U,local);
    
#line 301 
    if (reply != (Mbuf *)0) {
      
#line 302 
      sm = (struct smt_header *)(& reply->m_data) + (int)reply->m_off;
      
#line 306 
      smt_send_frame(smc,reply,65,local);
    }
    else ;
  }
  else ;
  
#line 309 
  return;
}


#line 311  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pmf.c"
static Mbuf *smt_build_pmf_response(struct s_smc *smc, struct smt_header *req, int set, int local)
{
  Mbuf *__retres;
  Mbuf *mb;
  struct smt_header *smt;
  struct smt_para *pa;
  struct smt_p_reason *res;
  struct s_p_tab const *pt;
  int len;
  int index;
  int idx_end;
  int error;
  int range;
  struct s_pcon pcon;
  struct s_pcon set_pcon;
  int tmp_2;
  
#line 330 
  mb = smt_get_mbuf(smc);
  
#line 330 
  if (mb == (Mbuf *)0) {
    
#line 331 
    __retres = mb;
    
#line 331 
    goto return_label;
  }
  else ;
  
#line 333 
  smt = (struct smt_header *)(& mb->m_data) + (int)mb->m_off;
  
#line 334 
  smt->smt_dest = req->smt_source;
  
#line 335 
  smt->smt_class = req->smt_class;
  
#line 336 
  smt->smt_type = (unsigned char)3U;
  
#line 337 
  smt->smt_version = (unsigned short)2U;
  
#line 338 
  smt->smt_tid = req->smt_tid;
  
#line 339 
  smt->smt_pad = (unsigned short)0U;
  
#line 340 
  smt->smt_len = (unsigned short)0U;
  
#line 345 
  pcon.pc_len = 4332;
  
#line 346 
  pcon.pc_err = 0;
  
#line 347 
  pcon.pc_badset = 0;
  
#line 348 
  pcon.pc_p = (void *)(smt + 1U);
  
#line 353 
  error = 0;
  
#line 354 
  if (set != 0) 
    
#line 355 
    if (local == 0) {
      int tmp_0;
      
#line 355 
      tmp_0 = smt_authorize(smc,req);
      
#line 355 
      if (tmp_0 != 0) 
#line 356 
                      error = 9; else 
#line 355 
                                      goto _LAND;
    }
    else {
      int tmp;
      _LAND: 
#line 357 
      tmp = smt_check_set_count(smc,req);
      
#line 357 
      if (tmp != 0) 
#line 358 
                    pcon.pc_badset = 4; else ;
    }
  else ;
  
#line 363 
  res = (struct smt_p_reason *)pcon.pc_p;
  
#line 364 
  smt_add_para(smc,& pcon,(unsigned short)18,0,0);
  
#line 365 
  smt_add_para(smc,& pcon,(unsigned short)4147,0,0);
  
#line 367 
  set_pcon = pcon;
  
#line 368 
  smt_add_para(smc,& pcon,(unsigned short)4149,0,0);
  
#line 369 
  smt_add_para(smc,& pcon,(unsigned short)4150,0,0);
  
#line 371 
  pcon.pc_err = error;
  
#line 372 
  len = (int)req->smt_len;
  
#line 373 
  pa = (struct smt_para *)(req + 1U);
  
#line 377 
  goto ldv_46301;
  ldv_46300: 
#line 378 
  ;
  
#line 378 
  if ((unsigned long)((unsigned short)len) < (unsigned long)pa->p_len + 4UL || ((int)pa->p_len & 3) != 0) {
    
#line 379 
    pcon.pc_err = 10;
    
#line 380 
    goto ldv_46288;
  }
  else ;
  
#line 383 
  range = (int)pa->p_type & 61440;
  
#line 383 
  if (range == 8192) 
#line 383 
                     goto _LOR;
  else 
    
#line 384 
    if (range == 12288 || range == 16384) {
      _LOR: {
              
#line 388 
              index = (int)*((u_char *)pa + 7U);
              
#line 389 
              idx_end = index;
              
#line 390 
              if (set == 0 && (unsigned int)pa->p_len != 4U) {
                
#line 391 
                pcon.pc_err = 10;
                
#line 392 
                goto ldv_46288;
              }
              else ;
              
#line 394 
              if (index == 0 && set == 0) {
                
#line 395 
                switch (range) {
                  case 8192: 
#line 396 
                  ;
                  
#line 397 
                  index = 1;
                  
#line 398 
                  idx_end = index;
                  
#line 399 
                  goto ldv_46290;
                  case 12288: 
#line 400 
                  ;
                  
#line 401 
                  index = 1;
                  
#line 402 
                  idx_end = index + 1;
                  
#line 403 
                  goto ldv_46290;
                  case 16384: 
#line 404 
                  ;
                  
#line 405 
                  index = 1;
                  
#line 406 
                  idx_end = index + 1;
                  
#line 408 
                  if ((unsigned int)smc->s.sas == 1U) 
#line 409 
                                                      idx_end = 1; else ;
                  
#line 411 
                  goto ldv_46290;
                }
                ldv_46290: 
#line 413 
                ;
              }
              else ;
            }
    }
    else {
      
#line 419 
      if (set == 0 && (unsigned int)pa->p_len != 0U) {
        
#line 420 
        pcon.pc_err = 10;
        
#line 421 
        goto ldv_46288;
      }
      else ;
      
#line 423 
      index = 0;
      
#line 424 
      idx_end = 0;
    }
  
#line 426 
  goto ldv_46299;
  ldv_46298: 
#line 427 
  ;
  
#line 431 
  pt = smt_get_ptab((unsigned short)((int)pa->p_type));
  
#line 432 
  if ((pt != (struct s_p_tab const *)0 && (unsigned int)pt->p_access == 16U) && set == 0) {
    
#line 433 
    pt += 1;
    
#line 434 
    goto ldv_46294;
    ldv_46293: 
#line 435 
    ;
    
#line 436 
    smt_add_para(smc,& pcon,(unsigned short)((int)pt->p_num),index,local);
    
#line 438 
    pt += 1;
    ldv_46294: 
#line 439 
    ;
    
#line 434 
    if ((unsigned int)pt->p_access + 255U <= 1U) 
#line 436 
                                                 goto ldv_46293; else 
                                                                   
#line 439 
                                                                   goto ldv_46295;
    ldv_46295: 
#line 440 
    ;
  }
  else 
    
#line 446 
    if ((unsigned int)pa->p_type != 33U && (set == 0 || (unsigned int)pa->p_type != 4149U)) {
      int st;
      
#line 449 
      if (pcon.pc_badset != 0) 
#line 450 
                               smt_add_para(smc,& pcon,(unsigned short)((int)pa->p_type),index,local);
      else 
        
#line 453 
        if (set != 0) {
          
#line 454 
          st = smt_set_para(smc,pa,index,local,1);
          
#line 458 
          smt_add_para(smc,& pcon,(unsigned short)((int)pa->p_type),index,local);
          
#line 460 
          pcon.pc_err = st;
        }
        else {
          
#line 463 
          if (pt != (struct s_p_tab const *)0 && (unsigned int)pt->p_access == 4U) 
            
#line 464 
            pcon.pc_err = 5; else ;
          
#line 467 
          smt_add_para(smc,& pcon,(unsigned short)((int)pa->p_type),index,local);
        }
    }
    else ;
  
#line 471 
  if (pcon.pc_err != 0) 
#line 472 
                        goto ldv_46297; else ;
  
#line 473 
  index += 1;
  ldv_46299: 
#line 474 
  ;
  
#line 426 
  if (index <= idx_end) 
#line 428 
                        goto ldv_46298; else 
#line 431 
                                             goto ldv_46297;
  ldv_46297: 
#line 432 
  ;
  
#line 475 
  len = (int)((unsigned int)(len - (int)pa->p_len) + 4294967292U);
  
#line 476 
  pa += (unsigned int)pa->p_len + 4U;
  ldv_46301: 
#line 477 
  ;
  
#line 377 
  if (pcon.pc_err == 0 && len > 0) 
#line 379 
                                   goto ldv_46300; else 
#line 382 
                                                        goto ldv_46288;
  ldv_46288: 
#line 383 
  ;
  
#line 478 
  smt->smt_len = (unsigned short)(4332U - (unsigned int)((unsigned short)pcon.pc_len));
  
#line 479 
  mb->m_len = (unsigned int)smt->smt_len + 32U;
  
#line 482 
  if (pcon.pc_badset != 0) 
#line 482 
                           tmp_2 = pcon.pc_badset;
  else {
    int tmp_1;
    
#line 482 
    if (pcon.pc_err != 0) 
#line 482 
                          tmp_1 = pcon.pc_err; else 
#line 482 
                                                    tmp_1 = 3;
    
#line 482 
    tmp_2 = tmp_1;
  }
  
#line 482 
  res->rdf_reason = (unsigned int)tmp_2;
  
#line 484 
  if (set != 0 && res->rdf_reason == 3U) {
    
#line 490 
    smc->mib.fddiSMTSetCount.count += 1UL;
    
#line 491 
    smt_set_timestamp(smc,(u_char *)(& smc->mib.fddiSMTSetCount.timestamp));
    
#line 492 
    smc->mib.fddiSMTLastSetStationId = req->smt_sid;
    
#line 493 
    smt_add_para(smc,& set_pcon,(unsigned short)4149,0,0);
    
#line 494 
    smt_add_para(smc,& set_pcon,(unsigned short)4150,0,0);
  }
  else ;
  
#line 496 
  __retres = mb;
  return_label: 
#line 496 
                return __retres;
}


#line 499  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pmf.c"
static int smt_authorize(struct s_smc *smc, struct smt_header *sm)
{
  int __retres;
  struct smt_para *pa;
  int i;
  char *p;
  
#line 508 
  p = (char *)(& smc->mib.fddiPRPMFStation);
  
#line 509 
  i = 0;
  
#line 509 
  goto ldv_46310;
  ldv_46309: 
#line 510 
  ;
  
#line 509 
  i += 1;
  ldv_46310: 
#line 510 
  ;
  
#line 509 
  if (i <= 7 && (int)*(p + i) == 0) 
#line 511 
                                    goto ldv_46309; else 
#line 514 
                                                         goto ldv_46311;
  ldv_46311: 
#line 515 
  ;
  
#line 511 
  if (i != 8) {
    int tmp;
    
#line 512 
    tmp = memcmp((void const *)(& sm->smt_sid),(void const *)(& smc->mib.fddiPRPMFStation),8UL);
    
#line 512 
    if (tmp != 0) {
      
#line 514 
      __retres = 1;
      
#line 514 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 519 
  p = (char *)(& smc->mib.fddiPRPMFPasswd);
  
#line 520 
  i = 0;
  
#line 520 
  goto ldv_46313;
  ldv_46312: 
#line 521 
  ;
  
#line 520 
  i += 1;
  ldv_46313: 
#line 521 
  ;
  
#line 520 
  if (i <= 7 && (int)*(p + i) == 0) 
#line 522 
                                    goto ldv_46312; else 
#line 525 
                                                         goto ldv_46314;
  ldv_46314: 
#line 526 
  ;
  
#line 522 
  if (i != 8) {
    int tmp_1;
    
#line 523 
    pa = (struct smt_para *)sm_to_para(smc,sm,33);
    
#line 524 
    if (pa == (struct smt_para *)0) {
      
#line 525 
      __retres = 1;
      
#line 525 
      goto return_label;
    }
    else ;
    
#line 526 
    if ((unsigned int)pa->p_len != 8U) {
      
#line 527 
      __retres = 1;
      
#line 527 
      goto return_label;
    }
    else ;
    
#line 528 
    tmp_1 = memcmp((void const *)(pa + 1U),(void const *)(& smc->mib.fddiPRPMFPasswd),8UL);
    
#line 528 
    if (tmp_1 != 0) {
      
#line 529 
      __retres = 1;
      
#line 529 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 531 
  __retres = 0;
  return_label: 
#line 531 
                return __retres;
}


#line 534  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pmf.c"
static int smt_check_set_count(struct s_smc *smc, struct smt_header *sm)
{
  int __retres;
  struct smt_para *pa;
  struct smt_p_setcount *sc;
  
#line 539 
  pa = (struct smt_para *)sm_to_para(smc,sm,4149);
  
#line 540 
  if (pa != (struct smt_para *)0) {
    
#line 541 
    sc = (struct smt_p_setcount *)pa;
    
#line 542 
    if (smc->mib.fddiSMTSetCount.count != (unsigned long)sc->count) {
      
#line 545 
      __retres = 1;
      
#line 545 
      goto return_label;
    }
    else {
      int tmp_0;
      
#line 542 
      tmp_0 = memcmp((void const *)(& smc->mib.fddiSMTSetCount.timestamp),(void const *)(& sc->timestamp),8UL);
      
#line 542 
      if (tmp_0 != 0) {
        
#line 545 
        __retres = 1;
        
#line 545 
        goto return_label;
      }
      else ;
    }
  }
  else ;
  
#line 547 
  __retres = 0;
  return_label: 
#line 547 
                return __retres;
}


#line 550  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pmf.c"
void smt_add_para(struct s_smc *smc, struct s_pcon *pcon, u_short para, int index, int local)
{
  struct smt_para *pa;
  struct s_p_tab const *pt;
  int len;
  int plen;
  char *from;
  char *to;
  char const *swap;
  char c;
  int range;
  char *mib_addr;
  int mac;
  int path;
  int port;
  int sp_len;
  char const *tmp_29;
  
#line 555 
  struct fddi_mib_m *mib_m = (struct fddi_mib_m *)0;
  
#line 556 
  struct fddi_mib_p *mib_p = (struct fddi_mib_p *)0;
  
#line 573 
  if (pcon->pc_err != 0) 
#line 574 
                         goto return_label; else ;
  
#line 579 
  pt = smt_get_ptab((unsigned short)((int)para));
  
#line 580 
  if (pt != (struct s_p_tab const *)0 && (unsigned int)pt->p_access == 4U) 
    
#line 581 
    goto return_label; else ;
  
#line 583 
  to = (char *)pcon->pc_p;
  
#line 584 
  len = pcon->pc_len;
  
#line 585 
  plen = len;
  
#line 586 
  pa = (struct smt_para *)to;
  
#line 587 
  to += 4U;
  
#line 588 
  len = (int)((unsigned int)len + 4294967292U);
  
#line 592 
  range = (int)para & 61440;
  
#line 592 
  if (range == 8192) 
#line 592 
                     goto _LOR;
  else 
    
#line 593 
    if (range == 12288 || range == 16384) {
      _LOR: {
              
#line 594 
              if (len <= 3) 
#line 595 
                            goto wrong_error; else ;
              
#line 596 
              *to = (char)0;
              
#line 597 
              *(to + 1U) = (char)0;
              
#line 598 
              *(to + 2U) = (char)0;
              
#line 599 
              *(to + 3U) = (char)index;
              
#line 600 
              len += -4;
              
#line 601 
              to += 4U;
            }
    }
    else ;
  
#line 603 
  mac = index + -1;
  
#line 604 
  path = index + -1;
  
#line 605 
  port = index + -1;
  
#line 609 
  switch (range) {
    int tmp_0;
    case 4096: 
#line 610 
    ;
    default: 
#line 611 
    ;
    
#line 612 
    mib_addr = (char *)(& smc->mib);
    
#line 613 
    goto ldv_46347;
    case 8192: 
#line 614 
    ;
    
#line 615 
    if (mac != 0) {
      
#line 616 
      pcon->pc_err = 6;
      
#line 617 
      goto return_label;
    }
    else ;
    
#line 619 
    mib_addr = (char *)(& smc->mib.m[mac]);
    
#line 620 
    mib_m = (struct fddi_mib_m *)mib_addr;
    
#line 621 
    goto ldv_46347;
    case 12288: 
#line 622 
    ;
    
#line 623 
    if ((unsigned int)path > 1U) {
      
#line 624 
      pcon->pc_err = 6;
      
#line 625 
      goto return_label;
    }
    else ;
    
#line 627 
    mib_addr = (char *)(& smc->mib.a[path]);
    
#line 628 
    goto ldv_46347;
    case 16384: 
#line 629 
    ;
    
#line 630 
    if (port < 0) 
#line 630 
                  goto _LOR_0;
    else {
      int tmp;
      
#line 630 
      tmp = smt_mib_phys(smc);
      
#line 630 
      ;
      
#line 630 
      if (tmp <= port) {
        _LOR_0: {
                  
#line 631 
                  pcon->pc_err = 6;
                  
#line 632 
                  goto return_label;
                }
      }
      else ;
    }
    
#line 634 
    tmp_0 = port_to_mib(smc,port);
    
#line 634 
    mib_addr = (char *)(& smc->mib.p[tmp_0]);
    
#line 635 
    mib_p = (struct fddi_mib_p *)mib_addr;
    
#line 636 
    goto ldv_46347;
  }
  ldv_46347: 
#line 641 
  ;
  
#line 641 
  swap = (char const *)0;
  
#line 642 
  switch ((int)para) {
    int tmp_2;
    int tmp_1;
    case 4336: 
#line 643 
    ;
    case 4337: 
#line 644 
    ;
    case 4338: 
#line 646 
    ;
    case 4339: 
#line 647 
    ;
    case 4340: 
#line 648 
    ;
    case 4341: 
#line 649 
    ;
    case 4342: 
#line 650 
    ;
    case 4343: 
#line 651 
    ;
    case 8433: 
#line 657 
    ;
    
#line 658 
    if (local == 0) {
      
#line 659 
      pcon->pc_err = 6;
      
#line 660 
      goto return_label;
    }
    else ;
    
#line 662 
    goto ldv_46360;
    case 8244: 
#line 663 
    ;
    case 8262: 
#line 664 
    ;
    case 8263: 
#line 665 
    ;
    case 8266: 
#line 666 
    ;
    case 8273: 
#line 667 
    ;
    case 8274: 
#line 668 
    ;
    
#line 669 
    mac_update_counter(smc);
    
#line 670 
    goto ldv_46360;
    case 16418: 
#line 671 
    ;
    
#line 672 
    tmp_1 = port_to_mib(smc,port);
    
#line 672 
    ;
    
#line 672 
    tmp_2 = sm_pm_get_ls(smc,tmp_1);
    
#line 672 
    mib_p->fddiPORTPC_LS = (unsigned short)((unsigned int)((unsigned short)tmp_2) + 65524U);
    
#line 674 
    goto ldv_46360;
    case 18: 
#line 675 
    ;
    
#line 676 
    *((unsigned int *)to) = 0U;
    
#line 677 
    sp_len = 4;
    
#line 678 
    goto sp_done;
    case 4147: 
#line 679 
    ;
    
#line 680 
    smt_set_timestamp(smc,(u_char *)(& smc->mib.fddiSMTTimeStamp));
    
#line 681 
    goto ldv_46360;
    case 4128: 
#line 683 
    ;
    
#line 688 
    if ((unsigned int)smc->s.sas == 1U) 
#line 689 
                                        swap = "I"; else 
#line 691 
                                                         swap = "II";
    
#line 700 
    goto ldv_46360;
    case 12818: 
#line 701 
    ;
    
#line 703 
    sp_len = cem_build_path(smc,to,path);
    
#line 704 
    goto sp_done;
    case 4168: 
#line 706 
    ;
    {
      struct smt_p_1048 *sp;
      
#line 709 
      sp = (struct smt_p_1048 *)to;
      
#line 710 
      sp->p1048_flag = (unsigned int)smc->mib.fddiSMTPeerWrapFlag;
      
#line 711 
      sp->p1048_cf_state = (unsigned int)smc->mib.fddiSMTCF_State;
      
#line 712 
      sp_len = 8;
      
#line 713 
      goto sp_done;
    }
    case 8332: 
#line 715 
    ;
    {
      struct smt_p_208c *sp_0;
      int tmp_3;
      
#line 718 
      sp_0 = (struct smt_p_208c *)to;
      
#line 719 
      sp_0->p208c_flag = (unsigned int)smc->mib.m[0].fddiMACDuplicateAddressCond;
      
#line 722 
      if ((unsigned int)mib_m->fddiMACUNDA_Flag != 0U) 
#line 722 
                                                       tmp_3 = 2; else 
                                                                    
#line 722 
                                                                    tmp_3 = 0;
      
#line 721 
      sp_0->p208c_dupcondition = (unsigned short)(((unsigned int)mib_m->fddiMACDA_Flag != 0U) | tmp_3);
      
#line 724 
      sp_0->p208c_fddilong = mib_m->fddiMACSMTAddress;
      
#line 726 
      sp_0->p208c_fddiunalong = mib_m->fddiMACUpstreamNbr;
      
#line 728 
      sp_0->p208c_pad = (unsigned short)0U;
      
#line 729 
      sp_len = 20;
      
#line 730 
      goto sp_done;
    }
    case 8333: 
#line 732 
    ;
    {
      struct smt_p_208d *sp_1;
      
#line 735 
      sp_1 = (struct smt_p_208d *)to;
      
#line 736 
      sp_1->p208d_flag = (unsigned int)mib_m->fddiMACFrameErrorFlag;
      
#line 738 
      sp_1->p208d_frame_ct = (unsigned int)mib_m->fddiMACFrame_Ct;
      
#line 740 
      sp_1->p208d_error_ct = (unsigned int)mib_m->fddiMACError_Ct;
      
#line 742 
      sp_1->p208d_lost_ct = (unsigned int)mib_m->fddiMACLost_Ct;
      
#line 744 
      sp_1->p208d_ratio = (unsigned int)mib_m->fddiMACFrameErrorRatio;
      
#line 746 
      sp_len = 20;
      
#line 747 
      goto sp_done;
    }
    case 8334: 
#line 749 
    ;
    {
      struct smt_p_208e *sp_2;
      
#line 752 
      sp_2 = (struct smt_p_208e *)to;
      
#line 753 
      sp_2->p208e_flag = (unsigned int)mib_m->fddiMACNotCopiedFlag;
      
#line 755 
      sp_2->p208e_not_copied = (unsigned int)mib_m->fddiMACNotCopied_Ct;
      
#line 757 
      sp_2->p208e_copied = (unsigned int)mib_m->fddiMACCopied_Ct;
      
#line 759 
      sp_2->p208e_not_copied_ratio = (unsigned int)mib_m->fddiMACNotCopiedRatio;
      
#line 761 
      sp_len = 16;
      
#line 762 
      goto sp_done;
    }
    case 8335: 
#line 764 
    ;
    {
      struct smt_p_208f *sp_3;
      
#line 767 
      sp_3 = (struct smt_p_208f *)to;
      
#line 768 
      sp_3->p208f_multiple = (unsigned int)mib_m->fddiMACMultiple_N;
      
#line 770 
      sp_3->p208f_nacondition = (unsigned int)mib_m->fddiMACDuplicateAddressCond;
      
#line 772 
      sp_3->p208f_old_una = mib_m->fddiMACOldUpstreamNbr;
      
#line 774 
      sp_3->p208f_new_una = mib_m->fddiMACUpstreamNbr;
      
#line 776 
      sp_3->p208f_old_dna = mib_m->fddiMACOldDownstreamNbr;
      
#line 778 
      sp_3->p208f_new_dna = mib_m->fddiMACDownstreamNbr;
      
#line 780 
      sp_3->p208f_curren_path = mib_m->fddiMACCurrentPath;
      
#line 782 
      sp_3->p208f_smt_address = mib_m->fddiMACSMTAddress;
      
#line 784 
      sp_len = 40;
      
#line 785 
      goto sp_done;
    }
    case 8336: 
#line 787 
    ;
    {
      struct smt_p_2090 *sp_4;
      
#line 790 
      sp_4 = (struct smt_p_2090 *)to;
      
#line 791 
      sp_4->p2090_multiple = (unsigned int)mib_m->fddiMACMultiple_P;
      
#line 793 
      sp_4->p2090_availablepaths = (unsigned short)mib_m->fddiMACAvailablePaths;
      
#line 795 
      sp_4->p2090_currentpath = mib_m->fddiMACCurrentPath;
      
#line 797 
      sp_4->p2090_requestedpaths = (unsigned int)mib_m->fddiMACRequestedPaths;
      
#line 799 
      sp_len = 12;
      
#line 800 
      goto sp_done;
    }
    case 16464: 
#line 802 
    ;
    {
      struct smt_p_4050 *sp_5;
      
#line 805 
      sp_5 = (struct smt_p_4050 *)to;
      
#line 806 
      sp_5->p4050_flag = (unsigned int)mib_p->fddiPORTLerFlag;
      
#line 808 
      sp_5->p4050_pad = (unsigned char)0U;
      
#line 809 
      sp_5->p4050_cutoff = mib_p->fddiPORTLer_Cutoff;
      
#line 811 
      sp_5->p4050_alarm = mib_p->fddiPORTLer_Alarm;
      
#line 813 
      sp_5->p4050_estimate = mib_p->fddiPORTLer_Estimate;
      
#line 815 
      sp_5->p4050_reject_ct = (unsigned int)mib_p->fddiPORTLem_Reject_Ct;
      
#line 817 
      sp_5->p4050_ct = (unsigned int)mib_p->fddiPORTLem_Ct;
      
#line 819 
      sp_len = 16;
      
#line 820 
      goto sp_done;
    }
    case 16465: 
#line 823 
    ;
    {
      struct smt_p_4051 *sp_6;
      
#line 826 
      sp_6 = (struct smt_p_4051 *)to;
      
#line 827 
      sp_6->p4051_multiple = (unsigned int)mib_p->fddiPORTMultiple_U;
      
#line 829 
      sp_6->p4051_porttype = mib_p->fddiPORTMy_Type;
      
#line 831 
      sp_6->p4051_connectstate = mib_p->fddiPORTConnectState;
      
#line 833 
      sp_6->p4051_pc_neighbor = mib_p->fddiPORTNeighborType;
      
#line 835 
      sp_6->p4051_pc_withhold = mib_p->fddiPORTPC_Withhold;
      
#line 837 
      sp_len = 12;
      
#line 838 
      goto sp_done;
    }
    case 16466: 
#line 840 
    ;
    {
      struct smt_p_4052 *sp_7;
      
#line 843 
      sp_7 = (struct smt_p_4052 *)to;
      
#line 844 
      sp_7->p4052_flag = (unsigned int)mib_p->fddiPORTEB_Condition;
      
#line 846 
      sp_7->p4052_eberrorcount = (unsigned int)mib_p->fddiPORTEBError_Ct;
      
#line 848 
      sp_len = 8;
      
#line 849 
      goto sp_done;
    }
    case 16467: 
#line 851 
    ;
    {
      struct smt_p_4053 *sp_8;
      
#line 854 
      sp_8 = (struct smt_p_4053 *)to;
      
#line 855 
      sp_8->p4053_multiple = (unsigned int)mib_p->fddiPORTMultiple_P;
      
#line 857 
      sp_8->p4053_availablepaths = (unsigned short)mib_p->fddiPORTAvailablePaths;
      
#line 859 
      sp_8->p4053_currentpath = mib_p->fddiPORTCurrentPath;
      
#line 861 
      memcpy((void *)(& sp_8->p4053_requestedpaths),(void const *)(& mib_p->fddiPORTRequestedPaths),4UL);
      
#line 863 
      sp_8->p4053_mytype = mib_p->fddiPORTMy_Type;
      
#line 865 
      sp_8->p4053_neighbortype = mib_p->fddiPORTNeighborType;
      
#line 867 
      sp_len = 16;
      
#line 868 
      goto sp_done;
    }
    default: 
#line 870 
    ;
    
#line 871 
    goto ldv_46360;
  }
  ldv_46360: 
#line 876 
  ;
  
#line 876 
  if (pt == (struct s_p_tab const *)0) {
    
#line 877 
    if (((int)para & 65280) != 0) 
#line 877 
                                  pcon->pc_err = 6; else 
#line 877 
                                                         pcon->pc_err = 5;
    
#line 879 
    goto return_label;
  }
  else ;
  
#line 884 
  switch ((int)pt->p_access) {
    case 1: 
#line 885 
    ;
    case 2: 
#line 886 
    ;
    
#line 887 
    goto ldv_46396;
    default: 
#line 888 
    ;
    
#line 889 
    pcon->pc_err = 5;
    
#line 890 
    goto return_label;
  }
  ldv_46396: 
#line 892 
  ;
  
#line 892 
  from = mib_addr + (int)pt->p_offset;
  
#line 893 
  if (swap == (char const *)0) 
#line 894 
                               swap = (char const *)(& pt->p_swap); else ;
  
#line 899 
  goto ldv_46421;
  ldv_46420: 
#line 900 
  ;
  
#line 900 
  switch ((int)c) {
    char *tmp_8;
    char *tmp_9;
    char *tmp_10;
    char *tmp_11;
    char *tmp_12;
    char *tmp_13;
    char *tmp_14;
    char *tmp_15;
    char *tmp_16;
    char *tmp_17;
    char *tmp_18;
    char *tmp_19;
    char *tmp_20;
    char *tmp_21;
    char *tmp_22;
    char *tmp_23;
    char *tmp_24;
    char *tmp_25;
    char *tmp_26;
    char *tmp_27;
    char *tmp_28;
    case 98: 
#line 901 
    ;
    case 119: 
#line 902 
    ;
    case 108: 
#line 903 
    ;
    
#line 904 
    goto ldv_46401;
    case 83: 
#line 905 
    ;
    case 69: 
#line 906 
    ;
    case 82: 
#line 907 
    ;
    case 114: 
#line 908 
    ;
    
#line 909 
    if (len <= 3) 
#line 910 
                  goto len_error; else ;
    
#line 911 
    *to = (char)0;
    
#line 912 
    *(to + 1U) = (char)0;
    
#line 914 
    if ((int)c == 114) {
      char *tmp_4;
      char *tmp_5;
      
#line 915 
      tmp_4 = from;
      
#line 915 
      from += 1;
      
#line 915 
      *(to + 2U) = *tmp_4;
      
#line 916 
      tmp_5 = from;
      
#line 916 
      from += 1;
      
#line 916 
      *(to + 3U) = *tmp_5;
    }
    else {
      char *tmp_6;
      char *tmp_7;
      
#line 919 
      tmp_6 = from;
      
#line 919 
      from += 1;
      
#line 919 
      *(to + 3U) = *tmp_6;
      
#line 920 
      tmp_7 = from;
      
#line 920 
      from += 1;
      
#line 920 
      *(to + 2U) = *tmp_7;
    }
    
#line 926 
    to += 4U;
    
#line 927 
    len += -4;
    
#line 928 
    goto ldv_46401;
    case 73: 
#line 929 
    ;
    
#line 930 
    if (len <= 1) 
#line 931 
                  goto len_error; else ;
    
#line 933 
    tmp_8 = from;
    
#line 933 
    from += 1;
    
#line 933 
    *(to + 1U) = *tmp_8;
    
#line 934 
    tmp_9 = from;
    
#line 934 
    from += 1;
    
#line 934 
    *to = *tmp_9;
    
#line 939 
    to += 2U;
    
#line 940 
    len += -2;
    
#line 941 
    goto ldv_46401;
    case 70: 
#line 942 
    ;
    case 66: 
#line 943 
    ;
    
#line 944 
    if (len <= 3) 
#line 945 
                  goto len_error; else ;
    
#line 946 
    len += -4;
    
#line 947 
    *to = (char)0;
    
#line 948 
    *(to + 1U) = (char)0;
    
#line 949 
    *(to + 2U) = (char)0;
    
#line 950 
    tmp_10 = from;
    
#line 950 
    from += 1;
    
#line 950 
    *(to + 3U) = *tmp_10;
    
#line 951 
    to += 4U;
    
#line 952 
    goto ldv_46401;
    case 67: 
#line 953 
    ;
    case 84: 
#line 954 
    ;
    case 76: 
#line 955 
    ;
    
#line 956 
    if (len <= 3) 
#line 957 
                  goto len_error; else ;
    
#line 959 
    tmp_11 = from;
    
#line 959 
    from += 1;
    
#line 959 
    *(to + 3U) = *tmp_11;
    
#line 960 
    tmp_12 = from;
    
#line 960 
    from += 1;
    
#line 960 
    *(to + 2U) = *tmp_12;
    
#line 961 
    tmp_13 = from;
    
#line 961 
    from += 1;
    
#line 961 
    *(to + 1U) = *tmp_13;
    
#line 962 
    tmp_14 = from;
    
#line 962 
    from += 1;
    
#line 962 
    *to = *tmp_14;
    
#line 969 
    len += -4;
    
#line 970 
    to += 4U;
    
#line 971 
    goto ldv_46401;
    case 50: 
#line 972 
    ;
    
#line 973 
    if (len <= 3) 
#line 974 
                  goto len_error; else ;
    
#line 975 
    *to = (char)0;
    
#line 976 
    *(to + 1U) = (char)0;
    
#line 977 
    tmp_15 = from;
    
#line 977 
    from += 1;
    
#line 977 
    *(to + 2U) = *tmp_15;
    
#line 978 
    tmp_16 = from;
    
#line 978 
    from += 1;
    
#line 978 
    *(to + 3U) = *tmp_16;
    
#line 979 
    len += -4;
    
#line 980 
    to += 4U;
    
#line 981 
    goto ldv_46401;
    case 52: 
#line 982 
    ;
    
#line 983 
    if (len <= 3) 
#line 984 
                  goto len_error; else ;
    
#line 985 
    tmp_17 = from;
    
#line 985 
    from += 1;
    
#line 985 
    *to = *tmp_17;
    
#line 986 
    tmp_18 = from;
    
#line 986 
    from += 1;
    
#line 986 
    *(to + 1U) = *tmp_18;
    
#line 987 
    tmp_19 = from;
    
#line 987 
    from += 1;
    
#line 987 
    *(to + 2U) = *tmp_19;
    
#line 988 
    tmp_20 = from;
    
#line 988 
    from += 1;
    
#line 988 
    *(to + 3U) = *tmp_20;
    
#line 989 
    len += -4;
    
#line 990 
    to += 4U;
    
#line 991 
    goto ldv_46401;
    case 65: 
#line 992 
    ;
    
#line 993 
    if (len <= 7) 
#line 994 
                  goto len_error; else ;
    
#line 995 
    *to = (char)0;
    
#line 996 
    *(to + 1U) = (char)0;
    
#line 997 
    memcpy((void *)(to + 2U),(void const *)from,6UL);
    
#line 998 
    to += 8U;
    
#line 999 
    from += 8U;
    
#line 1000 
    len += -8;
    
#line 1001 
    goto ldv_46401;
    case 56: 
#line 1002 
    ;
    
#line 1003 
    if (len <= 7) 
#line 1004 
                  goto len_error; else ;
    
#line 1005 
    memcpy((void *)to,(void const *)from,8UL);
    
#line 1006 
    to += 8U;
    
#line 1007 
    from += 8U;
    
#line 1008 
    len += -8;
    
#line 1009 
    goto ldv_46401;
    case 68: 
#line 1010 
    ;
    
#line 1011 
    if (len <= 31) 
#line 1012 
                   goto len_error; else ;
    
#line 1013 
    memcpy((void *)to,(void const *)from,32UL);
    
#line 1014 
    to += 32U;
    
#line 1015 
    from += 32U;
    
#line 1016 
    len += -32;
    
#line 1017 
    goto ldv_46401;
    case 80: 
#line 1018 
    ;
    
#line 1019 
    if (len <= 7) 
#line 1020 
                  goto len_error; else ;
    
#line 1021 
    tmp_21 = from;
    
#line 1021 
    from += 1;
    
#line 1021 
    *to = *tmp_21;
    
#line 1022 
    tmp_22 = from;
    
#line 1022 
    from += 1;
    
#line 1022 
    *(to + 1U) = *tmp_22;
    
#line 1023 
    tmp_23 = from;
    
#line 1023 
    from += 1;
    
#line 1023 
    *(to + 2U) = *tmp_23;
    
#line 1024 
    tmp_24 = from;
    
#line 1024 
    from += 1;
    
#line 1024 
    *(to + 3U) = *tmp_24;
    
#line 1025 
    tmp_25 = from;
    
#line 1025 
    from += 1;
    
#line 1025 
    *(to + 4U) = *tmp_25;
    
#line 1026 
    tmp_26 = from;
    
#line 1026 
    from += 1;
    
#line 1026 
    *(to + 5U) = *tmp_26;
    
#line 1027 
    tmp_27 = from;
    
#line 1027 
    from += 1;
    
#line 1027 
    *(to + 6U) = *tmp_27;
    
#line 1028 
    tmp_28 = from;
    
#line 1028 
    from += 1;
    
#line 1028 
    *(to + 7U) = *tmp_28;
    
#line 1029 
    to += 8U;
    
#line 1030 
    len += -8;
    
#line 1031 
    goto ldv_46401;
    default: 
#line 1032 
    ;
    
#line 1033 
    printk("\001",119,(char *)"smt_add_para");
    
#line 1034 
    goto ldv_46401;
  }
  ldv_46401: 
#line 1036 
  ;
  ldv_46421: 
#line 1037 
  ;
  
#line 899 
  tmp_29 = swap;
  
#line 899 
  swap += 1;
  
#line 899 
  c = *tmp_29;
  
#line 899 
  if ((int)c != 0) 
#line 901 
                   goto ldv_46420; else 
#line 904 
                                        goto ldv_46422;
  ldv_46422: 
#line 905 
  ;
  done: 
#line 1038 
  ;
  
#line 1043 
  if ((len & 3) != 0) {
    
#line 1044 
    *to = (char)0;
    
#line 1045 
    *(to + 1U) = (char)0;
    
#line 1046 
    to += 4 - (len & 3);
    
#line 1047 
    len &= -4;
  }
  else ;
  
#line 1051 
  pa->p_type = para;
  
#line 1052 
  pa->p_len = (unsigned short)((unsigned int)((int)((unsigned short)plen) - (int)((unsigned short)len)) + 65532U);
  
#line 1054 
  pcon->pc_p = (void *)to;
  
#line 1055 
  pcon->pc_len = len;
  
#line 1056 
  goto return_label;
  sp_done: 
#line 1058 
  ;
  
#line 1059 
  len -= sp_len;
  
#line 1060 
  to += sp_len;
  
#line 1061 
  goto done;
  len_error: 
#line 1063 
  ;
  
#line 1065 
  pcon->pc_err = 11;
  
#line 1066 
  goto return_label;
  wrong_error: 
#line 1068 
  ;
  
#line 1069 
  pcon->pc_err = 10;
  return_label: 
#line 1070 
                return;
}


#line 1075  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pmf.c"
static int smt_set_para(struct s_smc *smc, struct smt_para *pa, int index, int local, int set)
{
  int __retres;
  struct s_p_tab const *pt;
  int len;
  char *from;
  char *to;
  char const *swap;
  char c;
  char *mib_addr;
  struct fddi_mib *mib;
  int mac;
  int path;
  int port;
  u_char byte_val;
  u_short word_val;
  u_long long_val;
  
#line 1088 
  struct fddi_mib_m *mib_m = (struct fddi_mib_m *)0;
  
#line 1089 
  struct fddi_mib_a *mib_a = (struct fddi_mib_a *)0;
  
#line 1090 
  struct fddi_mib_p *mib_p = (struct fddi_mib_p *)0;
  
#line 1098 
  mac = index + -1;
  
#line 1099 
  path = index + -1;
  
#line 1100 
  port = index + -1;
  
#line 1101 
  len = (int)pa->p_len;
  
#line 1102 
  from = (char *)(pa + 1U);
  
#line 1104 
  mib = & smc->mib;
  
#line 1105 
  switch ((int)pa->p_type & 61440) {
    int tmp_0;
    case 4096: 
#line 1106 
    ;
    default: 
#line 1107 
    ;
    
#line 1108 
    mib_addr = (char *)mib;
    
#line 1109 
    goto ldv_46450;
    case 8192: 
#line 1110 
    ;
    
#line 1111 
    if (mac != 0) {
      
#line 1112 
      __retres = 6;
      
#line 1112 
      goto return_label;
    }
    else ;
    
#line 1114 
    mib_m = & smc->mib.m[mac];
    
#line 1115 
    mib_addr = (char *)mib_m;
    
#line 1116 
    from += 4U;
    
#line 1117 
    len += -4;
    
#line 1118 
    goto ldv_46450;
    case 12288: 
#line 1119 
    ;
    
#line 1120 
    if ((unsigned int)path > 1U) {
      
#line 1121 
      __retres = 6;
      
#line 1121 
      goto return_label;
    }
    else ;
    
#line 1123 
    mib_a = & smc->mib.a[path];
    
#line 1124 
    mib_addr = (char *)mib_a;
    
#line 1125 
    from += 4U;
    
#line 1126 
    len += -4;
    
#line 1127 
    goto ldv_46450;
    case 16384: 
#line 1128 
    ;
    
#line 1129 
    if (port < 0) {
      
#line 1130 
      __retres = 6;
      
#line 1130 
      goto return_label;
    }
    else {
      int tmp;
      
#line 1129 
      tmp = smt_mib_phys(smc);
      
#line 1129 
      ;
      
#line 1129 
      if (tmp <= port) {
        
#line 1130 
        __retres = 6;
        
#line 1130 
        goto return_label;
      }
      else ;
    }
    
#line 1132 
    tmp_0 = port_to_mib(smc,port);
    
#line 1132 
    mib_p = & smc->mib.p[tmp_0];
    
#line 1133 
    mib_addr = (char *)mib_p;
    
#line 1134 
    from += 4U;
    
#line 1135 
    len += -4;
    
#line 1136 
    goto ldv_46450;
  }
  ldv_46450: 
#line 1138 
  ;
  
#line 1138 
  switch ((int)pa->p_type) {
    case 4336: 
#line 1139 
    ;
    case 4337: 
#line 1140 
    ;
    case 4338: 
#line 1142 
    ;
    case 4339: 
#line 1143 
    ;
    case 4340: 
#line 1144 
    ;
    case 4341: 
#line 1145 
    ;
    case 4342: 
#line 1146 
    ;
    case 4343: 
#line 1147 
    ;
    case 8433: 
#line 1153 
    ;
    
#line 1154 
    if (local == 0) {
      
#line 1155 
      __retres = 6;
      
#line 1155 
      goto return_label;
    }
    else ;
    
#line 1156 
    goto ldv_46463;
  }
  ldv_46463: 
#line 1158 
  ;
  
#line 1158 
  pt = smt_get_ptab((unsigned short)((int)pa->p_type));
  
#line 1159 
  if (pt == (struct s_p_tab const *)0) {
    int tmp_1;
    
#line 1160 
    if (((int)pa->p_type & 65280) != 0) 
#line 1160 
                                        tmp_1 = 6; else 
#line 1160 
                                                        tmp_1 = 5;
    
#line 1160 
    __retres = tmp_1;
    
#line 1160 
    goto return_label;
  }
  else ;
  
#line 1162 
  switch ((int)pt->p_access) {
    case 2: 
#line 1163 
    ;
    case 4: 
#line 1164 
    ;
    
#line 1165 
    goto ldv_46466;
    default: 
#line 1166 
    ;
    
#line 1167 
    __retres = 5;
    
#line 1167 
    goto return_label;
  }
  ldv_46466: 
#line 1169 
  ;
  
#line 1169 
  to = mib_addr + (int)pt->p_offset;
  
#line 1170 
  swap = (char const *)(& pt->p_swap);
  
#line 1172 
  goto ldv_46490;
  ldv_46489: 
#line 1173 
  ;
  
#line 1173 
  switch ((int)c) {
    char *tmp_2;
    char *tmp_3;
    char *tmp_4;
    char *tmp_5;
    case 98: 
#line 1174 
    ;
    
#line 1175 
    to = (char *)(& byte_val);
    
#line 1176 
    goto ldv_46469;
    case 119: 
#line 1177 
    ;
    
#line 1178 
    to = (char *)(& word_val);
    
#line 1179 
    goto ldv_46469;
    case 108: 
#line 1180 
    ;
    
#line 1181 
    to = (char *)(& long_val);
    
#line 1182 
    goto ldv_46469;
    case 83: 
#line 1183 
    ;
    case 69: 
#line 1184 
    ;
    case 82: 
#line 1185 
    ;
    case 114: 
#line 1186 
    ;
    
#line 1187 
    if (len <= 3) 
#line 1188 
                  goto len_error; else ;
    
#line 1190 
    if (((int)((signed char)*from) | (int)((signed char)*(from + 1U))) != 0) 
      
#line 1191 
      goto val_error; else ;
    
#line 1193 
    if ((int)c == 114) {
      
#line 1194 
      *to = *(from + 2U);
      
#line 1195 
      *(to + 1U) = *(from + 3U);
    }
    else {
      
#line 1198 
      *(to + 1U) = *(from + 2U);
      
#line 1199 
      *to = *(from + 3U);
    }
    
#line 1205 
    from += 4U;
    
#line 1206 
    to += 2U;
    
#line 1207 
    len += -4;
    
#line 1208 
    goto ldv_46469;
    case 70: 
#line 1209 
    ;
    case 66: 
#line 1210 
    ;
    
#line 1211 
    if (len <= 3) 
#line 1212 
                  goto len_error; else ;
    
#line 1214 
    if ((((int)((signed char)*from) | (int)((signed char)*(from + 1U))) | (int)((signed char)*(from + 2U))) != 0) 
      
#line 1215 
      goto val_error; else ;
    
#line 1216 
    *to = *(from + 3U);
    
#line 1217 
    len += -4;
    
#line 1218 
    from += 4U;
    
#line 1219 
    to += 4U;
    
#line 1220 
    goto ldv_46469;
    case 67: 
#line 1221 
    ;
    case 84: 
#line 1222 
    ;
    case 76: 
#line 1223 
    ;
    
#line 1224 
    if (len <= 3) 
#line 1225 
                  goto len_error; else ;
    
#line 1228 
    tmp_2 = from;
    
#line 1228 
    from += 1;
    
#line 1228 
    *(to + 3U) = *tmp_2;
    
#line 1229 
    tmp_3 = from;
    
#line 1229 
    from += 1;
    
#line 1229 
    *(to + 2U) = *tmp_3;
    
#line 1230 
    tmp_4 = from;
    
#line 1230 
    from += 1;
    
#line 1230 
    *(to + 1U) = *tmp_4;
    
#line 1231 
    tmp_5 = from;
    
#line 1231 
    from += 1;
    
#line 1231 
    *to = *tmp_5;
    
#line 1238 
    len += -4;
    
#line 1239 
    to += 4U;
    
#line 1240 
    goto ldv_46469;
    case 65: 
#line 1241 
    ;
    
#line 1242 
    if (len <= 7) 
#line 1243 
                  goto len_error; else ;
    
#line 1244 
    if (set != 0) 
#line 1245 
                  memcpy((void *)to,(void const *)(from + 2U),6UL); else ;
    
#line 1246 
    to += 8U;
    
#line 1247 
    from += 8U;
    
#line 1248 
    len += -8;
    
#line 1249 
    goto ldv_46469;
    case 52: 
#line 1250 
    ;
    
#line 1251 
    if (len <= 3) 
#line 1252 
                  goto len_error; else ;
    
#line 1253 
    if (set != 0) 
#line 1254 
                  memcpy((void *)to,(void const *)from,4UL); else ;
    
#line 1255 
    to += 4U;
    
#line 1256 
    from += 4U;
    
#line 1257 
    len += -4;
    
#line 1258 
    goto ldv_46469;
    case 56: 
#line 1259 
    ;
    
#line 1260 
    if (len <= 7) 
#line 1261 
                  goto len_error; else ;
    
#line 1262 
    if (set != 0) 
#line 1263 
                  memcpy((void *)to,(void const *)from,8UL); else ;
    
#line 1264 
    to += 8U;
    
#line 1265 
    from += 8U;
    
#line 1266 
    len += -8;
    
#line 1267 
    goto ldv_46469;
    case 68: 
#line 1268 
    ;
    
#line 1269 
    if (len <= 31) 
#line 1270 
                   goto len_error; else ;
    
#line 1271 
    if (set != 0) 
#line 1272 
                  memcpy((void *)to,(void const *)from,32UL); else ;
    
#line 1273 
    to += 32U;
    
#line 1274 
    from += 32U;
    
#line 1275 
    len += -32;
    
#line 1276 
    goto ldv_46469;
    case 80: 
#line 1277 
    ;
    
#line 1278 
    if (set != 0) {
      char *tmp_6;
      char *tmp_7;
      char *tmp_8;
      char *tmp_9;
      char *tmp_10;
      char *tmp_11;
      char *tmp_12;
      char *tmp_13;
      
#line 1279 
      tmp_6 = from;
      
#line 1279 
      from += 1;
      
#line 1279 
      *to = *tmp_6;
      
#line 1280 
      tmp_7 = from;
      
#line 1280 
      from += 1;
      
#line 1280 
      *(to + 1U) = *tmp_7;
      
#line 1281 
      tmp_8 = from;
      
#line 1281 
      from += 1;
      
#line 1281 
      *(to + 2U) = *tmp_8;
      
#line 1282 
      tmp_9 = from;
      
#line 1282 
      from += 1;
      
#line 1282 
      *(to + 3U) = *tmp_9;
      
#line 1283 
      tmp_10 = from;
      
#line 1283 
      from += 1;
      
#line 1283 
      *(to + 4U) = *tmp_10;
      
#line 1284 
      tmp_11 = from;
      
#line 1284 
      from += 1;
      
#line 1284 
      *(to + 5U) = *tmp_11;
      
#line 1285 
      tmp_12 = from;
      
#line 1285 
      from += 1;
      
#line 1285 
      *(to + 6U) = *tmp_12;
      
#line 1286 
      tmp_13 = from;
      
#line 1286 
      from += 1;
      
#line 1286 
      *(to + 7U) = *tmp_13;
    }
    else ;
    
#line 1288 
    to += 8U;
    
#line 1289 
    len += -8;
    
#line 1290 
    goto ldv_46469;
    default: 
#line 1291 
    ;
    
#line 1292 
    printk("\001",120,(char *)"smt_set_para");
    
#line 1293 
    __retres = 5;
    
#line 1293 
    goto return_label;
  }
  ldv_46469: 
#line 1295 
  ;
  ldv_46490: 
#line 1296 
  ;
  
#line 1172 
  if (swap != (char const *)0) {
    char const *tmp_14;
    
#line 1172 
    tmp_14 = swap;
    
#line 1172 
    swap += 1;
    
#line 1172 
    c = *tmp_14;
    
#line 1172 
    if ((int)c != 0) 
#line 1174 
                     goto ldv_46489; else 
#line 1177 
                                          goto ldv_46491;
  }
  else 
#line 1177 
       goto ldv_46491;
  ldv_46491: 
#line 1178 
  ;
  
#line 1299 
  switch ((int)pa->p_type) {
    int tmp_17;
    int tmp_19;
    int tmp_18;
    case 4122: 
#line 1300 
    ;
    
#line 1301 
    if (((int)word_val & -2) != 0) 
#line 1302 
                                   goto val_error; else ;
    
#line 1303 
    if (set != 0) 
#line 1303 
                  mib->fddiSMTConfigPolicy = word_val; else ;
    
#line 1304 
    goto ldv_46493;
    case 4123: 
#line 1305 
    ;
    
#line 1306 
    if ((int)word_val >= 0) 
#line 1307 
                            goto val_error; else ;
    
#line 1308 
    if (set != 0) 
#line 1308 
                  mib->fddiSMTConnectionPolicy = word_val; else ;
    
#line 1309 
    goto ldv_46493;
    case 4125: 
#line 1310 
    ;
    
#line 1311 
    if ((unsigned int)word_val + 65534U > 28U) 
#line 1312 
                                               goto val_error; else ;
    
#line 1313 
    if (set != 0) 
#line 1313 
                  mib->fddiSMTTT_Notify = word_val; else ;
    
#line 1314 
    goto ldv_46493;
    case 4126: 
#line 1315 
    ;
    
#line 1316 
    if (((int)byte_val & -2) != 0) 
#line 1317 
                                   goto val_error; else ;
    
#line 1318 
    if (set != 0) 
#line 1318 
                  mib->fddiSMTStatRptPolicy = byte_val; else ;
    
#line 1319 
    goto ldv_46493;
    case 4127: 
#line 1320 
    ;
    
#line 1325 
    if (long_val <= 75022160UL) 
#line 1326 
                                goto val_error; else ;
    
#line 1327 
    if (set != 0) 
#line 1327 
                  mib->fddiSMTTrace_MaxExpiration = long_val; else ;
    
#line 1328 
    goto ldv_46493;
    case 4338: 
#line 1330 
    ;
    
#line 1331 
    if (long_val > 1562UL) 
#line 1332 
                           goto val_error; else ;
    
#line 1333 
    if (set != 0 && smc->mib.fddiESSPayload != long_val) {
      
#line 1334 
      smc->ess.raf_act_timer_poll = (char)1;
      
#line 1335 
      smc->mib.fddiESSPayload = long_val;
    }
    else ;
    
#line 1337 
    goto ldv_46493;
    case 4339: 
#line 1338 
    ;
    
#line 1339 
    if (long_val + 18446744073709551566UL > 4950UL) 
#line 1340 
                                                    goto val_error; else ;
    
#line 1341 
    if ((set != 0 && smc->mib.fddiESSPayload != 0UL) && smc->mib.fddiESSOverhead != long_val) {
      
#line 1343 
      smc->ess.raf_act_timer_poll = (char)1;
      
#line 1344 
      smc->mib.fddiESSOverhead = long_val;
    }
    else ;
    
#line 1346 
    goto ldv_46493;
    case 4340: 
#line 1347 
    ;
    
#line 1348 
    if (long_val + 2062500UL > 2000000UL) 
#line 1349 
                                          goto val_error; else ;
    
#line 1350 
    if (set != 0) 
#line 1350 
                  mib->fddiESSMaxTNeg = long_val; else ;
    
#line 1351 
    goto ldv_46493;
    case 4341: 
#line 1352 
    ;
    
#line 1353 
    if (long_val + 18446744073709551615UL > 4477UL) 
#line 1354 
                                                    goto val_error; else ;
    
#line 1355 
    if (set != 0) 
#line 1355 
                  mib->fddiESSMinSegmentSize = long_val; else ;
    
#line 1356 
    goto ldv_46493;
    case 4342: 
#line 1357 
    ;
    
#line 1358 
    if ((long_val & 65535UL) != 1UL) 
#line 1359 
                                     goto val_error; else ;
    
#line 1360 
    if (set != 0) 
#line 1360 
                  mib->fddiESSCategory = long_val; else ;
    
#line 1361 
    goto ldv_46493;
    case 4343: 
#line 1362 
    ;
    
#line 1363 
    if ((unsigned int)word_val > 1U) 
#line 1364 
                                     goto val_error; else ;
    
#line 1365 
    if (set != 0) 
#line 1365 
                  mib->fddiESSSynchTxMode = (short)word_val; else ;
    
#line 1366 
    goto ldv_46493;
    case 8224: 
#line 1380 
    ;
    
#line 1381 
    if (((int)word_val & 36) == 0) 
#line 1383 
                                   goto val_error; else ;
    
#line 1384 
    if (set != 0) 
#line 1384 
                  mib_m->fddiMACRequestedPaths = word_val; else ;
    
#line 1385 
    goto ldv_46493;
    case 8287: 
#line 1386 
    ;
    
#line 1388 
    if (set != 0) 
#line 1388 
                  mib_m->fddiMACFrameErrorThreshold = word_val; else ;
    
#line 1389 
    goto ldv_46493;
    case 8295: 
#line 1390 
    ;
    
#line 1392 
    if (set != 0) 
#line 1392 
                  mib_m->fddiMACNotCopiedThreshold = word_val; else ;
    
#line 1393 
    goto ldv_46493;
    case 8310: 
#line 1394 
    ;
    
#line 1395 
    if (((int)byte_val & -2) != 0) 
#line 1396 
                                   goto val_error; else ;
    
#line 1397 
    if (set != 0) {
      
#line 1398 
      mib_m->fddiMACMA_UnitdataEnable = byte_val;
      
#line 1399 
      queue_event(smc,3,11);
    }
    else ;
    
#line 1401 
    goto ldv_46493;
    case 8433: 
#line 1402 
    ;
    
#line 1403 
    if (set != 0) 
#line 1403 
                  mib_m->fddiMACT_Min = long_val; else ;
    
#line 1404 
    goto ldv_46493;
    case 12815: 
#line 1405 
    ;
    
#line 1406 
    if (long_val > 1562UL) 
#line 1407 
                           goto val_error; else ;
    
#line 1408 
    if (set != 0) 
#line 1408 
                  mib_a->fddiPATHSbaPayload = long_val; else ;
    
#line 1410 
    if (set != 0) 
#line 1411 
                  ess_para_change(smc); else ;
    
#line 1413 
    goto ldv_46493;
    case 12816: 
#line 1414 
    ;
    
#line 1415 
    if (long_val > 5000UL) 
#line 1416 
                           goto val_error; else ;
    
#line 1418 
    if (long_val != 0UL && mib_a->fddiPATHSbaPayload == 0UL) 
#line 1419 
                                                             goto val_error; else ;
    
#line 1421 
    if (set != 0) 
#line 1421 
                  mib_a->fddiPATHSbaOverhead = long_val; else ;
    
#line 1423 
    if (set != 0) 
#line 1424 
                  ess_para_change(smc); else ;
    
#line 1426 
    goto ldv_46493;
    case 12819: 
#line 1427 
    ;
    
#line 1431 
    if (set != 0) {
      
#line 1432 
      mib_a->fddiPATHT_Rmode = long_val;
      
#line 1433 
      rtm_set_timer(smc);
    }
    else ;
    
#line 1435 
    goto ldv_46493;
    case 12820: 
#line 1436 
    ;
    
#line 1437 
    if (long_val > 12500000UL) 
#line 1438 
                               goto val_error; else ;
    
#line 1443 
    if (set != 0) 
#line 1443 
                  mib_a->fddiPATHSbaAvailable = long_val; else ;
    
#line 1444 
    goto ldv_46493;
    case 12821: 
#line 1445 
    ;
    
#line 1446 
    if (set != 0) 
#line 1446 
                  mib_a->fddiPATHTVXLowerBound = long_val; else ;
    
#line 1447 
    goto change_mac_para;
    case 12822: 
#line 1448 
    ;
    
#line 1449 
    if (set != 0) 
#line 1449 
                  mib_a->fddiPATHT_MaxLowerBound = long_val; else ;
    
#line 1450 
    goto change_mac_para;
    case 12823: 
#line 1451 
    ;
    
#line 1452 
    if (set != 0) 
#line 1452 
                  mib_a->fddiPATHMaxT_Req = long_val; else ;
    change_mac_para: 
#line 1454 
    ;
    
#line 1455 
    if (set != 0) {
      int tmp_16;
      
#line 1455 
      tmp_16 = smt_set_mac_opvalues(smc);
      
#line 1455 
      if (tmp_16 != 0) {
        u_short tmp_15;
        
#line 1456 
        tmp_15 = (unsigned short)((unsigned int)smc->srf.ring_status | 4U);
        
#line 1456 
        smc->srf.ring_status = tmp_15;
        
#line 1456 
        ;
        
#line 1456 
        ring_status_indication(smc,(unsigned long)tmp_15);
        
#line 1457 
        smc->sm.please_reconnect = (unsigned short)1U;
        
#line 1458 
        queue_event(smc,1,2);
      }
      else ;
    }
    else ;
    
#line 1460 
    goto ldv_46493;
    case 16398: 
#line 1461 
    ;
    
#line 1462 
    if ((unsigned int)byte_val > 1U) 
#line 1463 
                                     goto val_error; else ;
    
#line 1464 
    if (set != 0) 
#line 1464 
                  mib_p->fddiPORTConnectionPolicies = byte_val; else ;
    
#line 1465 
    goto ldv_46493;
    case 16401: 
#line 1466 
    ;
    
#line 1468 
    if (set != 0) 
#line 1468 
                  memcpy((void *)(& mib_p->fddiPORTRequestedPaths),(void const *)(& long_val),4UL); else ;
    
#line 1470 
    goto ldv_46493;
    case 16415: 
#line 1471 
    ;
    
#line 1472 
    if ((unsigned int)word_val > 4U) 
#line 1473 
                                     goto val_error; else ;
    
#line 1474 
    if (set != 0) 
#line 1474 
                  mib_p->fddiPORTMaint_LS = word_val; else ;
    
#line 1475 
    goto ldv_46493;
    case 16442: 
#line 1476 
    ;
    
#line 1477 
    if ((unsigned int)byte_val + 252U > 11U) 
#line 1478 
                                             goto val_error; else ;
    
#line 1479 
    if (set != 0) 
#line 1479 
                  mib_p->fddiPORTLer_Cutoff = byte_val; else ;
    
#line 1480 
    goto ldv_46493;
    case 16443: 
#line 1481 
    ;
    
#line 1482 
    if ((unsigned int)byte_val + 252U > 11U) 
#line 1483 
                                             goto val_error; else ;
    
#line 1484 
    if (set != 0) 
#line 1484 
                  mib_p->fddiPORTLer_Alarm = byte_val; else ;
    
#line 1485 
    goto ldv_46493;
    case 4156: 
#line 1490 
    ;
    
#line 1491 
    tmp_17 = smt_action(smc,1,(int)word_val,0);
    
#line 1491 
    if (tmp_17 != 0) 
#line 1492 
                     goto val_error; else ;
    
#line 1493 
    goto ldv_46493;
    case 16454: 
#line 1494 
    ;
    
#line 1495 
    tmp_18 = port_to_mib(smc,port);
    
#line 1495 
    ;
    
#line 1495 
    ;
    
#line 1495 
    tmp_19 = smt_action(smc,2,(int)word_val,tmp_18);
    
#line 1495 
    if (tmp_19 != 0) 
#line 1497 
                     goto val_error; else ;
    
#line 1498 
    goto ldv_46493;
    default: 
#line 1499 
    ;
    
#line 1500 
    goto ldv_46493;
  }
  ldv_46493: 
#line 1502 
  ;
  
#line 1502 
  __retres = 0;
  
#line 1502 
  goto return_label;
  val_error: 
#line 1504 
  ;
  
#line 1506 
  __retres = 8;
  
#line 1506 
  goto return_label;
  len_error: 
#line 1508 
  ;
  
#line 1510 
  __retres = 10;
  return_label: 
#line 1510 
                return __retres;
}


#line 1523  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pmf.c"
static struct s_p_tab const *smt_get_ptab(u_short para)
{
  struct s_p_tab const *pt;
  struct s_p_tab const *tmp;
  
#line 1526 
  pt = (struct s_p_tab const *)(& p_tab);
  
#line 1526 
  goto ldv_46530;
  ldv_46529: 
#line 1527 
  ;
  
#line 1526 
  pt += 1;
  ldv_46530: 
#line 1527 
  ;
  
#line 1526 
  if ((unsigned int)pt->p_num != 0U && (int)pt->p_num != (int)para) 
#line 1528 
                                                                    goto ldv_46529; else 
                                                                    
#line 1531 
                                                                    goto ldv_46531;
  ldv_46531: 
#line 1532 
  ;
  
#line 1528 
  if ((unsigned int)pt->p_num != 0U) 
#line 1528 
                                     tmp = pt; else 
#line 1528 
                                                    tmp = (struct s_p_tab const *)0;
  
#line 1528 
  return tmp;
}


#line 1531  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pmf.c"
static int smt_mib_phys(struct s_smc *smc)
{
  int __retres;
  
#line 1538 
  if ((unsigned int)smc->s.sas == 1U) {
    
#line 1539 
    __retres = 1;
    
#line 1539 
    goto return_label;
  }
  else ;
  
#line 1540 
  __retres = 2;
  return_label: 
#line 1540 
                return __retres;
}


#line 1544  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/pmf.c"
static int port_to_mib(struct s_smc *smc, int p)
{
  int __retres;
  
#line 1551 
  if ((unsigned int)smc->s.sas == 1U) {
    
#line 1552 
    __retres = 0;
    
#line 1552 
    goto return_label;
  }
  else ;
  
#line 1553 
  __retres = p;
  return_label: 
#line 1553 
                return __retres;
}


#line 520  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/cmtdef.h"
void smt_swap_para(struct smt_header *sm, int len, int direction);


#line 548 
void driver_get_bia(struct s_smc *smc, struct fddi_addr *bia_addr);


#line 555 
void smt_event(struct s_smc *smc, int event);


#line 634 
void smt_emulate_token_ct(struct s_smc *smc, int mac_index_0);


#line 470  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/smc.h"
struct fddi_addr const fddi_broadcast;


#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitrev.h"
extern unsigned char const byte_rev_table[256U];


#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitrev.h"
__inline static unsigned char __bitrev8(unsigned char byte)
{
  unsigned char __retres;
  
#line 17 
  __retres = byte_rev_table[(int)byte];
  
#line 17 
  return __retres;
}


#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static struct fddi_addr const SMT_Unknown = {.a = {(unsigned char)0U, (unsigned char)0U, (unsigned char)31U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U}};

#line 61 
static int smt_swap_short(u_short s);


#line 63 
static int mac_index(struct s_smc *smc, int mac);


#line 64 
static int phy_index(struct s_smc *smc, int phy);


#line 65 
static int mac_con_resource_index(struct s_smc *smc, int mac);


#line 66 
static int phy_con_resource_index(struct s_smc *smc, int phy);


#line 67 
static void smt_send_rdf(struct s_smc *smc, Mbuf *rej, int fc, int reason, int local);


#line 69 
static void smt_send_nif(struct s_smc *smc, struct fddi_addr const *dest, int fc, u_long tid, int type, int local);


#line 71 
static void smt_send_ecf(struct s_smc *smc, struct fddi_addr *dest, int fc, u_long tid, int type, int len);


#line 73 
static void smt_echo_test(struct s_smc *smc, int dna);


#line 74 
static void smt_send_sif_config(struct s_smc *smc, struct fddi_addr *dest, u_long tid, int local);


#line 76 
static void smt_send_sif_operation(struct s_smc *smc, struct fddi_addr *dest, u_long tid, int local);


#line 79 
static void smt_string_swap(char *data, char const *format, int len);


#line 81 
static void smt_add_frame_len(Mbuf *mb, int len);


#line 82 
static void smt_fill_una(struct s_smc *smc, struct smt_p_una *una);


#line 83 
static void smt_fill_sde(struct s_smc *smc, struct smt_p_sde *sde);


#line 84 
static void smt_fill_state(struct s_smc *smc, struct smt_p_state *state);


#line 85 
static void smt_fill_timestamp(struct s_smc *smc, struct smt_p_timestamp *ts);


#line 86 
static void smt_fill_policy(struct s_smc *smc, struct smt_p_policy *policy);


#line 87 
static void smt_fill_latency(struct s_smc *smc, struct smt_p_latency *latency);


#line 88 
static void smt_fill_neighbor(struct s_smc *smc, struct smt_p_neighbor *neighbor);


#line 89 
static int smt_fill_path(struct s_smc *smc, struct smt_p_path *path);


#line 90 
static void smt_fill_mac_status(struct s_smc *smc, struct smt_p_mac_status *st);


#line 91 
static void smt_fill_lem(struct s_smc *smc, struct smt_p_lem *lem, int phy);


#line 92 
static void smt_fill_version(struct s_smc *smc, struct smt_p_version *vers);


#line 93 
static void smt_fill_fsc(struct s_smc *smc, struct smt_p_fsc *fsc);


#line 94 
static void smt_fill_mac_counter(struct s_smc *smc, struct smt_p_mac_counter *mc);


#line 95 
static void smt_fill_mac_fnc(struct s_smc *smc, struct smt_p_mac_fnc *fnc);


#line 96 
static void smt_fill_manufacturer(struct s_smc *smc, struct smp_p_manufacturer *man);


#line 98 
static void smt_fill_user(struct s_smc *smc, struct smp_p_user *user);


#line 99 
static void smt_fill_setcount(struct s_smc *smc, struct smt_p_setcount *setcount);


#line 100 
static void smt_fill_echo(struct s_smc *smc, struct smt_p_echo *echo, u_long seed, int len);


#line 103 
static void smt_clear_una_dna(struct s_smc *smc);


#line 104 
static void smt_clear_old_una_dna(struct s_smc *smc);


#line 108 
static void update_dac(struct s_smc *smc, int report);


#line 109 
static int div_ratio(u_long upper, u_long lower);


#line 111 
static void hwm_conv_can(struct s_smc *smc, char *data, int len);


#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
__inline static int is_my_addr(struct s_smc const *smc, struct fddi_addr const *addr)
{
  int __retres;
  
#line 124 
  __retres = (((int)*((short *)(& addr->a[0])) == (int)*((short *)(& smc->mib.m[0].fddiMACSMTAddress.a[0])) && (int)*((short *)(& addr->a[2])) == (int)*((short *)(& smc->mib.m[0].fddiMACSMTAddress.a[2]))) && (int)*((short *)(& addr->a[4])) == (int)*((short *)(& smc->mib.m[0].fddiMACSMTAddress.a[4]))) != 0;
  
#line 124 
  return __retres;
}


#line 128  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
__inline static int is_broadcast(struct fddi_addr const *addr)
{
  int __retres;
  
#line 131 
  __retres = (((unsigned int)*((u_short *)(& addr->a[0])) == 65535U && (unsigned int)*((u_short *)(& addr->a[2])) == 65535U) && (unsigned int)*((u_short *)(& addr->a[4])) == 65535U) != 0;
  
#line 131 
  return __retres;
}


#line 135  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
__inline static int is_individual(struct fddi_addr const *addr)
{
  int __retres;
  
#line 137 
  __retres = (int)addr->a[0] >= 0;
  
#line 137 
  return __retres;
}


#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
__inline static int is_equal(struct fddi_addr const *addr1, struct fddi_addr const *addr2)
{
  int __retres;
  
#line 144 
  __retres = (((int)*((u_short *)(& addr1->a[0])) == (int)*((u_short *)(& addr2->a[0])) && (int)*((u_short *)(& addr1->a[2])) == (int)*((u_short *)(& addr2->a[2]))) && (int)*((u_short *)(& addr1->a[4])) == (int)*((u_short *)(& addr2->a[4]))) != 0;
  
#line 144 
  return __retres;
}


#line 151  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static u_short const plist_nif[4U] = {(unsigned short)1U, (unsigned short)2U, (unsigned short)3U, (unsigned short)0U};

#line 156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
void smt_agent_init(struct s_smc *smc)
{
  int i;
  int tmp_2;
  
#line 163 
  smc->mib.m[0].fddiMACSMTAddress = smc->hw.fddi_home_addr;
  
#line 168 
  smc->mib.fddiSMTStationId.sid_oem[0] = (unsigned char)0U;
  
#line 169 
  smc->mib.fddiSMTStationId.sid_oem[1] = (unsigned char)0U;
  
#line 170 
  driver_get_bia(smc,& smc->mib.fddiSMTStationId.sid_node);
  
#line 171 
  i = 0;
  
#line 171 
  goto ldv_46387;
  ldv_46386: 
#line 172 
  ;
  {
    int tmp_1;
    
#line 173 
    unsigned char __x = smc->mib.fddiSMTStationId.sid_node.a[i];
    
#line 173 
    if (0 != 0) {
      unsigned char tmp;
      {
        
#line 173 
        unsigned char __x_0 = __x_0;
        
#line 173 
        __x_0 = (unsigned char)(((int)__x_0 >> 4) | ((int)__x_0 << 4));
        
#line 173 
        __x_0 = (unsigned char)((((int)__x_0 >> 2) & 51) | (((int)__x_0 << 2) & -52));
        
#line 173 
        __x_0 = (unsigned char)((((int)__x_0 >> 1) & 85) | (((int)__x_0 << 1) & -86));
        
#line 173 
        tmp = __x_0;
      }
      
#line 173 
      tmp_1 = (int)tmp;
    }
    else {
      unsigned char tmp_0;
      
#line 173 
      tmp_0 = __bitrev8((unsigned char)((int)__x));
      
#line 173 
      tmp_1 = (int)tmp_0;
    }
    
#line 173 
    tmp_2 = tmp_1;
  }
  
#line 172 
  smc->mib.fddiSMTStationId.sid_node.a[i] = (unsigned char)tmp_2;
  
#line 171 
  i += 1;
  ldv_46387: 
#line 172 
  ;
  
#line 171 
  if (i <= 5) 
#line 173 
              goto ldv_46386; else 
#line 176 
                                   goto ldv_46388;
  ldv_46388: 
#line 177 
  ;
  
#line 175 
  smc->mib.fddiSMTManufacturerData[0] = smc->mib.fddiSMTStationId.sid_node.a[0];
  
#line 177 
  smc->mib.fddiSMTManufacturerData[1] = smc->mib.fddiSMTStationId.sid_node.a[1];
  
#line 179 
  smc->mib.fddiSMTManufacturerData[2] = smc->mib.fddiSMTStationId.sid_node.a[2];
  
#line 181 
  smc->sm.smt_tid = 0UL;
  
#line 182 
  smc->mib.m[0].fddiMACDupAddressTest = (unsigned short)0U;
  
#line 183 
  smc->mib.m[0].fddiMACUNDA_Flag = (unsigned char)0U;
  
#line 185 
  smt_clear_una_dna(smc);
  
#line 186 
  smt_clear_old_una_dna(smc);
  
#line 188 
  i = 0;
  
#line 188 
  goto ldv_46390;
  ldv_46389: 
#line 189 
  ;
  
#line 189 
  smc->sm.pend[i] = 0UL;
  
#line 188 
  i += 1;
  ldv_46390: 
#line 189 
  ;
  
#line 188 
  if (i <= 4) 
#line 190 
              goto ldv_46389; else 
#line 193 
                                   goto ldv_46391;
  ldv_46391: 
#line 194 
  ;
  
#line 190 
  smc->sm.please_reconnect = (unsigned short)0U;
  
#line 191 
  smc->sm.uniq_ticks = (unsigned short)0U;
  
#line 192 
  return;
}


#line 202  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
void smt_agent_task(struct s_smc *smc)
{
  
#line 204 
  smt_timer_start(smc,& smc->sm.smt_timer,1000000UL,262145UL);
  
#line 205 
  return;
}


#line 210  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
void smt_emulate_token_ct(struct s_smc *smc, int mac_index_0)
{
  u_long count;
  u_long time;
  
#line 216 
  time = smt_get_time();
  
#line 217 
  count = ((time - smc->sm.last_tok_time[mac_index_0]) * 100UL) / 250UL;
  
#line 226 
  if ((unsigned int)smc->hw.mac_ring_is_up != 0U) 
#line 227 
                                                  smc->mib.m[mac_index_0].fddiMACToken_Ct += count; else ;
  
#line 231 
  smc->sm.last_tok_time[mac_index_0] = time;
  
#line 232 
  return;
}


#line 237  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
void smt_event(struct s_smc *smc, int event)
{
  u_long time;
  int i;
  
#line 245 
  if ((unsigned int)smc->sm.please_reconnect != 0U) {
    
#line 246 
    smc->sm.please_reconnect = (u_short)((int)smc->sm.please_reconnect - 1);
    
#line 247 
    if ((unsigned int)smc->sm.please_reconnect == 0U) 
#line 249 
                                                      queue_event(smc,1,1); else ;
  }
  else ;
  
#line 253 
  if (event == 2) 
#line 254 
                  goto return_label; else ;
  
#line 262 
  smt_timer_poll(smc);
  
#line 263 
  smt_start_watchdog(smc);
  
#line 267 
  ess_timer_poll(smc);
  
#line 274 
  smt_srf_event(smc,0,0,0);
  
#line 278 
  time = smt_get_time();
  
#line 280 
  if (time - smc->sm.smt_last_lem > 1999UL) {
    struct fddi_mib_m *mib;
    u_long upper;
    u_long lower;
    int cond;
    int port;
    struct s_phy *phy;
    int tmp;
    int tmp_0;
    
#line 294 
    sm_lem_evaluate(smc);
    
#line 295 
    smc->sm.smt_last_lem = time;
    
#line 301 
    mac_update_counter(smc);
    
#line 302 
    mib = (struct fddi_mib_m *)(& smc->mib.m);
    
#line 303 
    upper = (mib->fddiMACLost_Ct - mib->fddiMACOld_Lost_Ct) + (mib->fddiMACError_Ct - mib->fddiMACOld_Error_Ct);
    
#line 306 
    lower = (mib->fddiMACFrame_Ct - mib->fddiMACOld_Frame_Ct) + (mib->fddiMACLost_Ct - mib->fddiMACOld_Lost_Ct);
    
#line 309 
    tmp = div_ratio(upper,lower);
    
#line 309 
    mib->fddiMACFrameErrorRatio = (unsigned short)tmp;
    
#line 311 
    cond = (((unsigned int)mib->fddiMACFrameErrorThreshold == 0U && mib->fddiMACError_Ct != mib->fddiMACOld_Error_Ct) || (int)mib->fddiMACFrameErrorRatio > (int)mib->fddiMACFrameErrorThreshold) != 0;
    
#line 317 
    if ((int)mib->fddiMACFrameErrorFlag != cond) 
#line 318 
                                                 smt_srf_event(smc,7,1,cond); else ;
    
#line 321 
    upper = mib->fddiMACNotCopied_Ct - mib->fddiMACOld_NotCopied_Ct;
    
#line 323 
    lower = (mib->fddiMACCopied_Ct - mib->fddiMACOld_Copied_Ct) + upper;
    
#line 326 
    tmp_0 = div_ratio(upper,lower);
    
#line 326 
    mib->fddiMACNotCopiedRatio = (unsigned short)tmp_0;
    
#line 328 
    cond = (((unsigned int)mib->fddiMACNotCopiedThreshold == 0U && mib->fddiMACNotCopied_Ct != mib->fddiMACOld_NotCopied_Ct) || (int)mib->fddiMACNotCopiedRatio > (int)mib->fddiMACNotCopiedThreshold) != 0;
    
#line 335 
    if ((int)mib->fddiMACNotCopiedFlag != cond) 
#line 336 
                                                smt_srf_event(smc,9,1,cond); else ;
    
#line 342 
    mib->fddiMACOld_Frame_Ct = mib->fddiMACFrame_Ct;
    
#line 343 
    mib->fddiMACOld_Copied_Ct = mib->fddiMACCopied_Ct;
    
#line 344 
    mib->fddiMACOld_Error_Ct = mib->fddiMACError_Ct;
    
#line 345 
    mib->fddiMACOld_Lost_Ct = mib->fddiMACLost_Ct;
    
#line 346 
    mib->fddiMACOld_NotCopied_Ct = mib->fddiMACNotCopied_Ct;
    
#line 351 
    port = 0;
    
#line 351 
    goto ldv_46415;
    ldv_46414: 
#line 352 
    ;
    
#line 352 
    phy = & smc->y[port];
    
#line 354 
    if ((unsigned int)(phy->mib)->fddiPORTHardwarePresent == 0U) 
#line 355 
                                                                 goto ldv_46413; else ;
    
#line 358 
    cond = (phy->mib)->fddiPORTEBError_Ct - (phy->mib)->fddiPORTOldEBError_Ct > 5UL;
    
#line 364 
    smt_srf_event(smc,10,(int)phy->np + 1,cond);
    
#line 370 
    (phy->mib)->fddiPORTOldEBError_Ct = (phy->mib)->fddiPORTEBError_Ct;
    ldv_46413: 
#line 372 
    ;
    
#line 351 
    port += 1;
    ldv_46415: 
#line 352 
    ;
    
#line 351 
    if (port <= 1) 
#line 353 
                   goto ldv_46414; else 
#line 356 
                                        goto ldv_46416;
    ldv_46416: 
#line 357 
    ;
  }
  else ;
  
#line 379 
  if (time - smc->sm.smt_last_notify >= (unsigned long)((int)smc->mib.fddiSMTTT_Notify * 250)) {
    
#line 387 
    if (smc->sm.pend[0] == 0UL) 
#line 388 
                                smc->sm.pend[0] = smt_get_tid(smc); else ;
    
#line 389 
    smt_send_nif(smc,& fddi_broadcast,79,smc->sm.pend[0],2,0);
    
#line 391 
    smc->sm.smt_last_notify = time;
  }
  else ;
  
#line 397 
  if (smc->sm.smt_tvu != 0UL && time - smc->sm.smt_tvu > 57000UL) {
    int tmp_1;
    
#line 400 
    smc->sm.smt_tvu = 0UL;
    
#line 402 
    tmp_1 = is_equal((struct fddi_addr const *)(& smc->mib.m[0].fddiMACUpstreamNbr),& SMT_Unknown);
    
#line 402 
    if (tmp_1 == 0) 
#line 405 
                    smc->mib.m[0].fddiMACOldUpstreamNbr = smc->mib.m[0].fddiMACUpstreamNbr; else ;
    
#line 408 
    smc->mib.m[0].fddiMACUpstreamNbr = SMT_Unknown;
    
#line 409 
    smc->mib.m[0].fddiMACUNDA_Flag = (unsigned char)0U;
    
#line 416 
    update_dac(smc,0);
    
#line 417 
    smt_srf_event(smc,2,1,0);
  }
  else ;
  
#line 420 
  if (smc->sm.smt_tvd != 0UL && time - smc->sm.smt_tvd > 57000UL) {
    int tmp_2;
    
#line 423 
    smc->sm.smt_tvd = 0UL;
    
#line 424 
    tmp_2 = is_equal((struct fddi_addr const *)(& smc->mib.m[0].fddiMACDownstreamNbr),& SMT_Unknown);
    
#line 424 
    if (tmp_2 == 0) 
#line 427 
                    smc->mib.m[0].fddiMACOldDownstreamNbr = smc->mib.m[0].fddiMACDownstreamNbr; else ;
    
#line 430 
    smc->mib.m[0].fddiMACDownstreamNbr = SMT_Unknown;
    
#line 431 
    smt_srf_event(smc,2,1,0);
  }
  else ;
  
#line 442 
  i = 0;
  
#line 442 
  goto ldv_46418;
  ldv_46417: 
#line 443 
  ;
  
#line 443 
  if (time - smc->sm.last_tok_time[i] > 500UL) 
#line 444 
                                               smt_emulate_token_ct(smc,i); else ;
  
#line 442 
  i += 1;
  ldv_46418: 
#line 443 
  ;
  
#line 442 
  if (i <= 0) 
#line 444 
              goto ldv_46417; else 
#line 447 
                                   goto ldv_46419;
  ldv_46419: 
#line 448 
  ;
  
#line 449 
  smt_timer_start(smc,& smc->sm.smt_timer,1000000UL,262145UL);
  return_label: 
#line 450 
                return;
}


#line 453  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static int div_ratio(u_long upper, u_long lower)
{
  int __retres;
  
#line 455 
  if (upper << 16L < upper) 
#line 456 
                            upper = 4294901760UL; else 
#line 458 
                                                       upper <<= 16L;
  
#line 459 
  if (lower == 0UL) {
    
#line 460 
    __retres = 0;
    
#line 460 
    goto return_label;
  }
  else ;
  
#line 461 
  __retres = (int)(upper / lower);
  return_label: 
#line 461 
                return __retres;
}


#line 469  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
void smt_received_pack(struct s_smc *smc, Mbuf *mb, int fs)
{
  struct smt_header *sm;
  int local;
  int tmp;
  
#line 475 
  int illegal = 0;
  
#line 477 
  switch ((int)mb->m_data[0]) {
    case 65: 
#line 478 
    ;
    case 66: 
#line 479 
    ;
    case 67: 
#line 480 
    ;
    case 79: 
#line 481 
    ;
    
#line 482 
    goto ldv_46436;
    default: 
#line 483 
    ;
    
#line 484 
    smt_free_mbuf(smc,mb);
    
#line 485 
    goto return_label;
  }
  ldv_46436: 
#line 488 
  ;
  
#line 488 
  smc->mib.m[0].fddiMACSMTCopied_Ct += 1UL;
  
#line 489 
  sm = (struct smt_header *)(& mb->m_data) + (int)mb->m_off;
  
#line 490 
  local = (fs & 128) != 0;
  
#line 491 
  hwm_conv_can(smc,(char *)sm,12);
  
#line 494 
  tmp = is_individual((struct fddi_addr const *)(& sm->smt_dest));
  
#line 494 
  if (tmp != 0) {
    int tmp_0;
    
#line 494 
    tmp_0 = is_my_addr((struct s_smc const *)smc,(struct fddi_addr const *)(& sm->smt_dest));
    
#line 494 
    if (tmp_0 == 0) {
      
#line 495 
      smt_free_mbuf(smc,mb);
      
#line 496 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 506 
  smt_swap_para(sm,(int)mb->m_len,1);
  
#line 526 
  if ((fs & 2) != 0 && (int)mb->m_data[0] == 79) {
    
#line 529 
    smt_free_mbuf(smc,mb);
    
#line 530 
    goto return_label;
  }
  else ;
  
#line 536 
  if (((unsigned int)sm->smt_class == 4U && (unsigned int)sm->smt_len > 4458U) || ((unsigned int)sm->smt_class != 4U && (unsigned int)sm->smt_len > 4332U)) {
    
#line 538 
    smt_free_mbuf(smc,mb);
    
#line 539 
    goto return_label;
  }
  else ;
  
#line 545 
  switch ((int)sm->smt_class) {
    case 1: 
#line 546 
    ;
    case 2: 
#line 547 
    ;
    case 3: 
#line 548 
    ;
    case 4: 
#line 549 
    ;
    
#line 550 
    if ((unsigned int)sm->smt_version != 1U) 
#line 551 
                                             illegal = 1; else ;
    
#line 552 
    goto ldv_46442;
    default: 
#line 553 
    ;
    
#line 554 
    if ((unsigned int)sm->smt_version != 2U) 
#line 555 
                                             illegal = 1; else ;
    
#line 556 
    goto ldv_46442;
  }
  ldv_46442: 
#line 558 
  ;
  
#line 558 
  if (illegal != 0) {
    
#line 561 
    smt_send_rdf(smc,mb,(int)mb->m_data[0],2,local);
    
#line 562 
    smt_free_mbuf(smc,mb);
    
#line 563 
    goto return_label;
  }
  else ;
  
#line 565 
  if ((unsigned long)sm->smt_len > (unsigned long)mb->m_len + 18446744073709551584UL || (((int)sm->smt_len & 3) != 0 && (unsigned int)sm->smt_class != 4U)) {
    
#line 568 
    smt_send_rdf(smc,mb,(int)mb->m_data[0],10,local);
    
#line 569 
    smt_free_mbuf(smc,mb);
    
#line 570 
    goto return_label;
  }
  else ;
  
#line 572 
  switch ((int)sm->smt_class) {
    int tmp_1;
    case 1: 
#line 573 
    ;
    
#line 574 
    tmp_1 = smt_check_para(smc,sm,(u_short const *)(& plist_nif));
    
#line 574 
    if (tmp_1 != 0) 
#line 576 
                    goto ldv_46445; else ;
    
#line 578 
    switch ((int)sm->smt_type) {
      case 1: 
#line 579 
      ;
      case 2: 
#line 580 
      ;
      
#line 581 
      if ((fs & 1) == 0 && (int)mb->m_data[0] == 79) {
        int tmp_5;
        
#line 582 
        tmp_5 = is_broadcast((struct fddi_addr const *)(& sm->smt_dest));
        
#line 582 
        if (tmp_5 != 0) {
          struct smt_p_state *st;
          int tmp_3;
          
#line 586 
          tmp_3 = is_equal((struct fddi_addr const *)(& smc->mib.m[0].fddiMACUpstreamNbr),(struct fddi_addr const *)(& sm->smt_source));
          
#line 586 
          if (tmp_3 == 0) {
            int tmp_2;
            
#line 591 
            tmp_2 = is_equal((struct fddi_addr const *)(& smc->mib.m[0].fddiMACUpstreamNbr),& SMT_Unknown);
            
#line 591 
            if (tmp_2 == 0) 
#line 594 
                            smc->mib.m[0].fddiMACOldUpstreamNbr = smc->mib.m[0].fddiMACUpstreamNbr; else ;
            
#line 598 
            smc->mib.m[0].fddiMACUpstreamNbr = sm->smt_source;
            
#line 600 
            smt_srf_event(smc,2,1,0);
            
#line 603 
            smt_echo_test(smc,0);
          }
          else ;
          
#line 605 
          smc->sm.smt_tvu = smt_get_time();
          
#line 606 
          st = (struct smt_p_state *)sm_to_para(smc,sm,3);
          
#line 608 
          if (st != (struct smt_p_state *)0) {
            
#line 609 
            smc->mib.m[0].fddiMACUNDA_Flag = (unsigned char)((unsigned int)st->st_dupl_addr & 1U);
            
#line 612 
            update_dac(smc,1);
          }
          else ;
        }
        else ;
      }
      else ;
      
#line 615 
      if ((unsigned int)sm->smt_type == 2U) {
        int tmp_6;
        
#line 615 
        tmp_6 = is_individual((struct fddi_addr const *)(& sm->smt_source));
        
#line 615 
        if (tmp_6 != 0) {
          
#line 616 
          if ((fs & 2) == 0 || (int)mb->m_data[0] != 79) 
#line 621 
                                                         smt_send_nif(smc,(struct fddi_addr const *)(& sm->smt_source),65,(unsigned long)sm->smt_tid,3,local); else ;
        }
        else ;
      }
      else ;
      
#line 626 
      goto ldv_46449;
      case 3: 
#line 627 
      ;
      
#line 630 
      if ((fs & 2) != 0) {
        
#line 631 
        smc->sm.pend[0] = 0UL;
        
#line 633 
        smc->mib.m[0].fddiMACDupAddressTest = (unsigned short)2U;
        
#line 635 
        smc->r.dup_addr_test = (unsigned char)2U;
        
#line 636 
        queue_event(smc,3,10);
        
#line 637 
        smc->mib.m[0].fddiMACDA_Flag = (unsigned char)1U;
        
#line 638 
        update_dac(smc,1);
        
#line 639 
        goto ldv_46449;
      }
      else ;
      
#line 641 
      if ((unsigned long)sm->smt_tid == smc->sm.pend[0]) {
        int tmp_8;
        
#line 642 
        smc->sm.pend[0] = 0UL;
        
#line 644 
        tmp_8 = is_equal((struct fddi_addr const *)(& smc->mib.m[0].fddiMACDownstreamNbr),(struct fddi_addr const *)(& sm->smt_source));
        
#line 644 
        if (tmp_8 == 0) {
          int tmp_7;
          
#line 648 
          tmp_7 = is_equal((struct fddi_addr const *)(& smc->mib.m[0].fddiMACDownstreamNbr),& SMT_Unknown);
          
#line 648 
          if (tmp_7 == 0) 
#line 651 
                          smc->mib.m[0].fddiMACOldDownstreamNbr = smc->mib.m[0].fddiMACDownstreamNbr; else ;
          
#line 655 
          smc->mib.m[0].fddiMACDownstreamNbr = sm->smt_source;
          
#line 657 
          smt_srf_event(smc,2,1,0);
          
#line 660 
          smt_echo_test(smc,1);
        }
        else ;
        
#line 662 
        smc->mib.m[0].fddiMACDA_Flag = (unsigned char)0U;
        
#line 663 
        update_dac(smc,1);
        
#line 664 
        smc->sm.smt_tvd = smt_get_time();
        
#line 665 
        smc->mib.m[0].fddiMACDupAddressTest = (unsigned short)1U;
        
#line 667 
        if ((unsigned int)smc->r.dup_addr_test != 1U) {
          
#line 668 
          smc->r.dup_addr_test = (unsigned char)1U;
          
#line 669 
          queue_event(smc,3,10);
        }
        else ;
      }
      else 
        
#line 672 
        if ((unsigned long)sm->smt_tid == smc->sm.pend[1]) ; else ;
      
#line 680 
      goto ldv_46449;
      default: 
#line 681 
      ;
      
#line 682 
      illegal = 2;
      
#line 683 
      goto ldv_46449;
    }
    ldv_46449: 
#line 685 
    ;
    
#line 685 
    goto ldv_46445;
    case 2: 
#line 686 
    ;
    
#line 687 
    if ((unsigned int)sm->smt_type != 2U) 
#line 688 
                                          goto ldv_46445; else ;
    
#line 691 
    smt_send_sif_config(smc,& sm->smt_source,(unsigned long)sm->smt_tid,local);
    
#line 692 
    goto ldv_46445;
    case 3: 
#line 693 
    ;
    
#line 694 
    if ((unsigned int)sm->smt_type != 2U) 
#line 695 
                                          goto ldv_46445; else ;
    
#line 698 
    smt_send_sif_operation(smc,& sm->smt_source,(unsigned long)sm->smt_tid,local);
    
#line 699 
    goto ldv_46445;
    case 4: 
#line 700 
    ;
    
#line 701 
    switch ((int)sm->smt_type) {
      void *tmp_9;
      case 3: 
#line 702 
      ;
      
#line 703 
      smc->mib.priv.fddiPRIVECF_Reply_Rx += 1UL;
      
#line 706 
      tmp_9 = sm_to_para(smc,sm,17);
      
#line 706 
      if (tmp_9 == (void *)0) 
#line 708 
                              goto ldv_46456; else ;
      
#line 710 
      if ((unsigned long)sm->smt_tid == smc->sm.pend[4]) ;
      else 
        
#line 713 
        if ((unsigned long)sm->smt_tid == smc->sm.pend[2]) ;
        else 
          
#line 716 
          if ((unsigned long)sm->smt_tid == smc->sm.pend[3]) ; else ;
      
#line 724 
      goto ldv_46456;
      case 2: 
#line 725 
      ;
      
#line 726 
      smc->mib.priv.fddiPRIVECF_Req_Rx += 1UL;
      
#line 728 
      if ((unsigned int)sm->smt_len != 0U) {
        void *tmp_10;
        
#line 728 
        tmp_10 = sm_to_para(smc,sm,17);
        
#line 728 
        if (tmp_10 == (void *)0) {
          
#line 730 
          smt_send_rdf(smc,mb,(int)mb->m_data[0],10,local);
          
#line 732 
          goto ldv_46456;
        }
        else ;
      }
      else ;
      
#line 738 
      sm->smt_dest = sm->smt_source;
      
#line 739 
      sm->smt_type = (unsigned char)3U;
      
#line 741 
      smc->mib.priv.fddiPRIVECF_Reply_Tx += 1UL;
      
#line 742 
      smt_send_frame(smc,mb,65,local);
      
#line 743 
      goto return_label;
      default: 
#line 745 
      ;
      
#line 746 
      illegal = 1;
      
#line 747 
      goto ldv_46456;
    }
    ldv_46456: 
#line 749 
    ;
    
#line 749 
    goto ldv_46445;
    case 5: 
#line 751 
    ;
    
#line 754 
    fs = ess_raf_received_pack(smc,mb,sm,fs);
    
#line 761 
    goto ldv_46445;
    case 6: 
#line 762 
    ;
    
#line 763 
    smc->mib.priv.fddiPRIVRDF_Rx += 1UL;
    
#line 764 
    goto ldv_46445;
    case 255: 
#line 765 
    ;
    
#line 766 
    if ((unsigned int)sm->smt_type == 2U) 
#line 768 
                                          smt_send_rdf(smc,mb,(int)mb->m_data[0],1,local); else ;
    
#line 770 
    goto ldv_46445;
    case 8: 
#line 771 
    ;
    case 9: 
#line 772 
    ;
    
#line 773 
    if ((unsigned int)sm->smt_type != 2U) 
#line 774 
                                          goto ldv_46445; else ;
    
#line 776 
    if ((unsigned int)sm->smt_class == 8U) 
#line 777 
                                           smc->mib.priv.fddiPRIVPMF_Get_Rx += 1UL; else 
                                                                    
#line 779 
                                                                    smc->mib.priv.fddiPRIVPMF_Set_Rx += 1UL;
    
#line 783 
    if ((unsigned int)sm->smt_class == 9U) {
      int tmp_11;
      
#line 783 
      tmp_11 = is_individual((struct fddi_addr const *)(& sm->smt_dest));
      
#line 783 
      if (tmp_11 == 0) 
#line 786 
                       goto ldv_46445; else ;
    }
    else ;
    
#line 788 
    smt_pmf_received_pack(smc,mb,local);
    
#line 789 
    goto ldv_46445;
    case 7: 
#line 790 
    ;
    
#line 792 
    goto ldv_46445;
    default: 
#line 793 
    ;
    
#line 794 
    if ((unsigned int)sm->smt_type != 2U) 
#line 795 
                                          goto ldv_46445; else ;
    
#line 804 
    smt_send_rdf(smc,mb,(int)mb->m_data[0],1,local);
    
#line 805 
    goto ldv_46445;
  }
  ldv_46445: 
#line 808 
  ;
  
#line 808 
  if (illegal != 0) ; else ;
  
#line 812 
  smt_free_mbuf(smc,mb);
  return_label: 
#line 813 
                return;
}


#line 815  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static void update_dac(struct s_smc *smc, int report)
{
  int cond;
  
#line 819 
  cond = (unsigned int)((int)smc->mib.m[0].fddiMACUNDA_Flag | (int)smc->mib.m[0].fddiMACDA_Flag) != 0U;
  
#line 821 
  if (report != 0 && (int)smc->mib.m[0].fddiMACDuplicateAddressCond != cond) 
    
#line 822 
    smt_srf_event(smc,8,1,cond); else 
#line 824 
                                      smc->mib.m[0].fddiMACDuplicateAddressCond = (unsigned char)cond;
  
#line 825 
  return;
}


#line 833  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
void smt_send_frame(struct s_smc *smc, Mbuf *mb, int fc, int local)
{
  struct smt_header *sm;
  int tmp;
  
#line 839 
  if ((unsigned int)smc->r.sm_ma_avail == 0U && local == 0) {
    
#line 840 
    smt_free_mbuf(smc,mb);
    
#line 841 
    goto return_label;
  }
  else ;
  
#line 843 
  sm = (struct smt_header *)(& mb->m_data) + (int)mb->m_off;
  
#line 844 
  sm->smt_source = smc->mib.m[0].fddiMACSMTAddress;
  
#line 845 
  sm->smt_sid = smc->mib.fddiSMTStationId;
  
#line 847 
  smt_swap_para(sm,(int)mb->m_len,0);
  
#line 848 
  hwm_conv_can(smc,(char *)sm,12);
  
#line 849 
  smc->mib.m[0].fddiMACSMTTransmit_Ct += 1UL;
  
#line 850 
  if (local == 0) 
#line 850 
                  tmp = fc; else 
#line 850 
                                 tmp = 67;
  
#line 850 
  ;
  
#line 850 
  ;
  
#line 850 
  smt_send_mbuf(smc,mb,tmp);
  return_label: 
#line 851 
                return;
}


#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static void smt_send_rdf(struct s_smc *smc, Mbuf *rej, int fc, int reason, int local)
{
  Mbuf *mb;
  struct smt_header *sm;
  struct smt_rdf *rdf;
  int len;
  int frame_len;
  
#line 868 
  sm = (struct smt_header *)(& rej->m_data) + (int)rej->m_off;
  
#line 869 
  if ((unsigned int)sm->smt_type != 2U) 
#line 870 
                                        goto return_label; else ;
  
#line 880 
  frame_len = (int)rej->m_len;
  
#line 882 
  mb = smt_build_frame(smc,6,3,92);
  
#line 882 
  if (mb == (Mbuf *)0) 
#line 883 
                       goto return_label; else ;
  
#line 884 
  rdf = (struct smt_rdf *)(& mb->m_data) + (int)mb->m_off;
  
#line 885 
  rdf->smt.smt_tid = sm->smt_tid;
  
#line 886 
  rdf->smt.smt_dest = sm->smt_source;
  
#line 889 
  rdf->reason.para.p_type = (unsigned short)18U;
  
#line 890 
  rdf->reason.para.p_len = (unsigned short)4U;
  
#line 891 
  rdf->reason.rdf_reason = (unsigned int)reason;
  
#line 894 
  rdf->version.para.p_type = (unsigned short)20U;
  
#line 895 
  rdf->version.para.p_len = (unsigned short)8U;
  
#line 896 
  rdf->version.v_pad = (unsigned short)0U;
  
#line 897 
  rdf->version.v_n = (unsigned char)1U;
  
#line 898 
  rdf->version.v_index = (unsigned char)1U;
  
#line 899 
  rdf->version.v_version[0] = (unsigned short)2U;
  
#line 900 
  rdf->version.v_pad2 = (unsigned short)0U;
  
#line 903 
  if ((unsigned int)frame_len <= 4304U) 
#line 905 
                                        len = frame_len; else 
#line 907 
                                                              len = 4304;
  
#line 910 
  len &= -4;
  
#line 911 
  rdf->refused.para.p_type = (unsigned short)19U;
  
#line 913 
  rdf->refused.para.p_len = (unsigned short)((unsigned int)((unsigned short)len) + 4U);
  
#line 914 
  rdf->refused.ref_fc = (unsigned int)fc;
  
#line 917 
  smt_swap_para(sm,frame_len,0);
  
#line 919 
  memcpy((void *)(& rdf->refused.ref_header),(void const *)sm,(unsigned long)len);
  
#line 921 
  len = (int)((unsigned int)len + 4294967264U);
  
#line 922 
  mb->m_len += (unsigned int)len;
  
#line 923 
  rdf->smt.smt_len = (unsigned short)((int)rdf->smt.smt_len + (int)((unsigned short)len));
  
#line 926 
  smc->mib.priv.fddiPRIVRDF_Tx += 1UL;
  
#line 927 
  smt_send_frame(smc,mb,65,local);
  return_label: 
#line 928 
                return;
}


#line 933  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static void smt_send_nif(struct s_smc *smc, struct fddi_addr const *dest, int fc, u_long tid, int type, int local)
{
  struct smt_nif *nif;
  Mbuf *mb;
  
#line 943 
  mb = smt_build_frame(smc,1,type,72);
  
#line 943 
  if (mb == (Mbuf *)0) 
#line 944 
                       goto return_label; else ;
  
#line 945 
  nif = (struct smt_nif *)(& mb->m_data) + (int)mb->m_off;
  
#line 946 
  smt_fill_una(smc,& nif->una);
  
#line 947 
  smt_fill_sde(smc,& nif->sde);
  
#line 948 
  smt_fill_state(smc,& nif->state);
  
#line 950 
  smt_fill_fsc(smc,& nif->fsc);
  
#line 952 
  nif->smt.smt_dest = *dest;
  
#line 953 
  nif->smt.smt_tid = (unsigned int)tid;
  
#line 955 
  smt_send_frame(smc,mb,fc,local);
  return_label: 
#line 956 
                return;
}


#line 984  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static void smt_echo_test(struct s_smc *smc, int dna)
{
  u_long tid;
  int tmp;
  LongAddr *tmp_0;
  
#line 988 
  if (dna != 0) 
#line 988 
                tmp = 3; else 
#line 988 
                              tmp = 2;
  
#line 989 
  tid = smt_get_tid(smc);
  
#line 988 
  smc->sm.pend[tmp] = tid;
  
#line 990 
  ;
  
#line 991 
  if (dna != 0) 
#line 991 
                tmp_0 = & smc->mib.m[0].fddiMACDownstreamNbr; else 
#line 991 
                                                                   tmp_0 = & smc->mib.m[0].fddiMACUpstreamNbr;
  
#line 990 
  ;
  
#line 990 
  smt_send_ecf(smc,tmp_0,65,tid,2,4448);
  
#line 993 
  return;
}


#line 999  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static void smt_send_ecf(struct s_smc *smc, struct fddi_addr *dest, int fc, u_long tid, int type, int len)
{
  struct smt_ecf *ecf;
  Mbuf *mb;
  
#line 1010 
  mb = smt_build_frame(smc,4,type,(int)((unsigned int)len + 36U));
  
#line 1010 
  if (mb == (Mbuf *)0) 
#line 1011 
                       goto return_label; else ;
  
#line 1012 
  ecf = (struct smt_ecf *)(& mb->m_data) + (int)mb->m_off;
  
#line 1014 
  smt_fill_echo(smc,& ecf->ec_echo,tid,len);
  
#line 1015 
  ecf->smt.smt_dest = *dest;
  
#line 1016 
  ecf->smt.smt_tid = (unsigned int)tid;
  
#line 1017 
  smc->mib.priv.fddiPRIVECF_Req_Tx += 1UL;
  
#line 1018 
  smt_send_frame(smc,mb,fc,0);
  return_label: 
#line 1019 
                return;
}


#line 1025  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static void smt_send_sif_config(struct s_smc *smc, struct fddi_addr *dest, u_long tid, int local)
{
  struct smt_sif_config *sif;
  Mbuf *mb;
  int len;
  
#line 1033 
  mb = smt_build_frame(smc,2,3,128);
  
#line 1033 
  if (mb == (Mbuf *)0) 
#line 1035 
                       goto return_label; else ;
  
#line 1037 
  sif = (struct smt_sif_config *)(& mb->m_data) + (int)mb->m_off;
  
#line 1038 
  smt_fill_timestamp(smc,& sif->ts);
  
#line 1039 
  smt_fill_sde(smc,& sif->sde);
  
#line 1040 
  smt_fill_version(smc,& sif->version);
  
#line 1041 
  smt_fill_state(smc,& sif->state);
  
#line 1042 
  smt_fill_policy(smc,& sif->policy);
  
#line 1043 
  smt_fill_latency(smc,& sif->latency);
  
#line 1044 
  smt_fill_neighbor(smc,& sif->neighbor);
  
#line 1045 
  smt_fill_setcount(smc,& sif->setcount);
  
#line 1046 
  len = smt_fill_path(smc,& sif->path);
  
#line 1047 
  sif->smt.smt_dest = *dest;
  
#line 1048 
  sif->smt.smt_tid = (unsigned int)tid;
  
#line 1049 
  smt_add_frame_len(mb,len);
  
#line 1051 
  smt_send_frame(smc,mb,65,local);
  return_label: 
#line 1052 
                return;
}


#line 1058  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static void smt_send_sif_operation(struct s_smc *smc, struct fddi_addr *dest, u_long tid, int local)
{
  struct smt_sif_operation *sif;
  Mbuf *mb;
  int ports;
  int i;
  
#line 1068 
  ports = 2;
  
#line 1070 
  if ((unsigned int)smc->s.sas == 1U) 
#line 1071 
                                      ports = 1; else ;
  
#line 1074 
  mb = smt_build_frame(smc,3,3,(int)((unsigned long)ports * (unsigned long)20U + (unsigned long)204U));
  
#line 1074 
  if (mb == (Mbuf *)0) 
#line 1076 
                       goto return_label; else ;
  
#line 1077 
  sif = (struct smt_sif_operation *)(& mb->m_data) + (int)mb->m_off;
  
#line 1078 
  smt_fill_timestamp(smc,& sif->ts);
  
#line 1079 
  smt_fill_mac_status(smc,& sif->status);
  
#line 1080 
  smt_fill_mac_counter(smc,& sif->mc);
  
#line 1081 
  smt_fill_mac_fnc(smc,& sif->fnc);
  
#line 1082 
  smt_fill_manufacturer(smc,& sif->man);
  
#line 1083 
  smt_fill_user(smc,& sif->user);
  
#line 1084 
  smt_fill_setcount(smc,& sif->setcount);
  
#line 1088 
  if (ports == 1) 
#line 1089 
                  smt_fill_lem(smc,(struct smt_p_lem *)(& sif->lem),0);
  else {
    
#line 1092 
    i = 0;
    
#line 1092 
    goto ldv_46535;
    ldv_46534: 
#line 1093 
    ;
    
#line 1093 
    smt_fill_lem(smc,& sif->lem[i],i);
    
#line 1092 
    i += 1;
    ldv_46535: 
#line 1093 
    ;
    
#line 1092 
    if (i < ports) 
#line 1094 
                   goto ldv_46534; else 
#line 1097 
                                        goto ldv_46536;
    ldv_46536: 
#line 1098 
    ;
  }
  
#line 1097 
  sif->smt.smt_dest = *dest;
  
#line 1098 
  sif->smt.smt_tid = (unsigned int)tid;
  
#line 1100 
  smt_send_frame(smc,mb,65,local);
  return_label: 
#line 1101 
                return;
}


#line 1106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
Mbuf *smt_build_frame(struct s_smc *smc, int class, int type, int length)
{
  Mbuf *__retres;
  Mbuf *mb;
  struct smt_header *smt;
  u_long tmp;
  
#line 1117 
  mb = smt_get_mbuf(smc);
  
#line 1117 
  if (mb == (Mbuf *)0) {
    
#line 1118 
    __retres = mb;
    
#line 1118 
    goto return_label;
  }
  else ;
  
#line 1120 
  mb->m_len = (unsigned int)length;
  
#line 1121 
  smt = (struct smt_header *)(& mb->m_data) + (int)mb->m_off;
  
#line 1122 
  smt->smt_dest = fddi_broadcast;
  
#line 1123 
  smt->smt_class = (unsigned char)class;
  
#line 1124 
  smt->smt_type = (unsigned char)type;
  
#line 1125 
  switch (class) {
    case 1: 
#line 1126 
    ;
    case 2: 
#line 1127 
    ;
    case 3: 
#line 1128 
    ;
    case 4: 
#line 1129 
    ;
    
#line 1130 
    smt->smt_version = (unsigned short)1U;
    
#line 1131 
    goto ldv_46549;
    default: 
#line 1132 
    ;
    
#line 1133 
    smt->smt_version = (unsigned short)2U;
    
#line 1134 
    goto ldv_46549;
  }
  ldv_46549: 
#line 1136 
  ;
  
#line 1136 
  tmp = smt_get_tid(smc);
  
#line 1136 
  smt->smt_tid = (unsigned int)tmp;
  
#line 1137 
  smt->smt_pad = (unsigned short)0U;
  
#line 1138 
  smt->smt_len = (unsigned short)((unsigned int)((unsigned short)length) + 65504U);
  
#line 1139 
  __retres = mb;
  return_label: 
#line 1139 
                return __retres;
}


#line 1142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static void smt_add_frame_len(Mbuf *mb, int len)
{
  struct smt_header *smt;
  
#line 1146 
  smt = (struct smt_header *)(& mb->m_data) + (int)mb->m_off;
  
#line 1147 
  smt->smt_len = (unsigned short)((int)smt->smt_len + (int)((unsigned short)len));
  
#line 1148 
  mb->m_len += (unsigned int)len;
  
#line 1149 
  return;
}


#line 1156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static void smt_fill_una(struct s_smc *smc, struct smt_p_una *una)
{
  
#line 1158 
  una->para.p_type = (unsigned short)1U;
  
#line 1158 
  una->para.p_len = (unsigned short)8U;
  
#line 1159 
  una->una_pad = (unsigned short)0U;
  
#line 1160 
  una->una_node = smc->mib.m[0].fddiMACUpstreamNbr;
  
#line 1161 
  return;
}


#line 1166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static void smt_fill_sde(struct s_smc *smc, struct smt_p_sde *sde)
{
  
#line 1168 
  sde->para.p_type = (unsigned short)2U;
  
#line 1168 
  sde->para.p_len = (unsigned short)4U;
  
#line 1169 
  sde->sde_non_master = smc->mib.fddiSMTNonMaster_Ct;
  
#line 1170 
  sde->sde_master = smc->mib.fddiSMTMaster_Ct;
  
#line 1171 
  sde->sde_mac_count = (unsigned char)1U;
  
#line 1175 
  sde->sde_type = (unsigned char)0U;
  
#line 1176 
  return;
}


#line 1182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static void smt_fill_state(struct s_smc *smc, struct smt_p_state *state)
{
  int top;
  int twist;
  int tmp;
  int tmp_0;
  
#line 1187 
  state->para.p_type = (unsigned short)3U;
  
#line 1187 
  state->para.p_len = (unsigned short)4U;
  
#line 1188 
  state->st_pad = (unsigned short)0U;
  
#line 1191 
  top = 0;
  
#line 1192 
  if ((unsigned int)smc->mib.fddiSMTPeerWrapFlag != 0U) 
#line 1193 
                                                        top |= 1; else ;
  
#line 1200 
  twist = pcm_status_twisted(smc);
  
#line 1200 
  if ((twist & 1) != 0) 
#line 1201 
                        top |= 4; else ;
  
#line 1203 
  if ((twist & 2) != 0) 
#line 1204 
                        top |= 8; else ;
  
#line 1207 
  top |= 32;
  
#line 1209 
  tmp = pcm_rooted_station(smc);
  
#line 1209 
  if (tmp != 0) 
#line 1210 
                top |= 16; else ;
  
#line 1211 
  if (smc->mib.a[0].fddiPATHSbaPayload != 0UL) 
#line 1212 
                                               top |= 64; else ;
  
#line 1213 
  state->st_topology = (unsigned char)top;
  
#line 1215 
  if ((unsigned int)smc->mib.m[0].fddiMACUNDA_Flag != 0U) 
#line 1215 
                                                          tmp_0 = 2; else 
                                                                    
#line 1215 
                                                                    tmp_0 = 0;
  
#line 1214 
  state->st_dupl_addr = (unsigned char)(((unsigned int)smc->mib.m[0].fddiMACDA_Flag != 0U) | tmp_0);
  
#line 1217 
  return;
}


#line 1222  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static void smt_fill_timestamp(struct s_smc *smc, struct smt_p_timestamp *ts)
{
  
#line 1225 
  ts->para.p_type = (unsigned short)4U;
  
#line 1225 
  ts->para.p_len = (unsigned short)8U;
  
#line 1226 
  smt_set_timestamp(smc,(u_char *)(& ts->ts_time));
  
#line 1227 
  return;
}


#line 1229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
void smt_set_timestamp(struct s_smc *smc, u_char *p)
{
  u_long time;
  u_long utime;
  
#line 1239 
  utime = smt_get_time();
  
#line 1240 
  time = utime * 100UL;
  
#line 1241 
  time /= 250UL;
  
#line 1242 
  *p = (unsigned char)0U;
  
#line 1243 
  *(p + 1U) = (unsigned char)((unsigned int)((unsigned char)(time >> 31)) & 1U);
  
#line 1244 
  *(p + 2U) = (unsigned char)(time >> 23);
  
#line 1245 
  *(p + 3U) = (unsigned char)(time >> 15);
  
#line 1246 
  *(p + 4U) = (unsigned char)(time >> 7);
  
#line 1247 
  *(p + 5U) = (unsigned char)((int)((unsigned char)time) << 1U);
  
#line 1248 
  *(p + 6U) = (unsigned char)((int)smc->sm.uniq_ticks >> 8);
  
#line 1249 
  *(p + 7U) = (unsigned char)smc->sm.uniq_ticks;
  
#line 1253 
  if (smc->sm.uniq_time != utime) 
#line 1254 
                                  smc->sm.uniq_ticks = (unsigned short)0U; else ;
  
#line 1256 
  smc->sm.uniq_ticks = (u_short)((int)smc->sm.uniq_ticks + 1);
  
#line 1257 
  smc->sm.uniq_time = utime;
  
#line 1258 
  return;
}


#line 1263  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static void smt_fill_policy(struct s_smc *smc, struct smt_p_policy *policy)
{
  int i;
  u_char const *map;
  u_short in;
  u_short out;
  
#line 1274 
  u_char const ansi_weirdness[16U] = {(unsigned char)0U, (unsigned char)7U, (unsigned char)5U, (unsigned char)3U, (unsigned char)8U, (unsigned char)1U, (unsigned char)6U, (unsigned char)4U, (unsigned char)9U, (unsigned char)10U, (unsigned char)2U, (unsigned char)11U, (unsigned char)12U, (unsigned char)13U, (unsigned char)14U, (unsigned char)15U};
  
#line 1277 
  policy->para.p_type = (unsigned short)5U;
  
#line 1277 
  policy->para.p_len = (unsigned short)4U;
  
#line 1279 
  out = (unsigned short)0U;
  
#line 1280 
  in = smc->mib.fddiSMTConnectionPolicy;
  
#line 1281 
  i = 0;
  
#line 1281 
  map = (u_char const *)(& ansi_weirdness);
  
#line 1281 
  goto ldv_46590;
  ldv_46589: 
#line 1282 
  ;
  
#line 1282 
  if (((int)in & 1) != 0) 
#line 1283 
                          out = (unsigned short)((1 << (int)*map) | (int)out); else ;
  
#line 1284 
  in = (unsigned short)((int)in >> 1);
  
#line 1285 
  map += 1;
  
#line 1281 
  i += 1;
  ldv_46590: 
#line 1282 
  ;
  
#line 1281 
  if (i <= 15) 
#line 1283 
               goto ldv_46589; else 
#line 1286 
                                    goto ldv_46591;
  ldv_46591: 
#line 1287 
  ;
  
#line 1287 
  policy->pl_config = smc->mib.fddiSMTConfigPolicy;
  
#line 1288 
  policy->pl_connect = out;
  
#line 1289 
  return;
}


#line 1294  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static void smt_fill_latency(struct s_smc *smc, struct smt_p_latency *latency)
{
  int tmp;
  
#line 1296 
  latency->para.p_type = (unsigned short)6U;
  
#line 1296 
  latency->para.p_len = (unsigned short)8U;
  
#line 1298 
  tmp = phy_index(smc,0);
  
#line 1298 
  latency->lt_phyout_idx1 = (unsigned short)tmp;
  
#line 1299 
  latency->lt_latency1 = (unsigned short)10U;
  
#line 1304 
  if ((unsigned int)smc->s.sas == 0U) {
    int tmp_0;
    
#line 1305 
    tmp_0 = phy_index(smc,1);
    
#line 1305 
    latency->lt_phyout_idx2 = (unsigned short)tmp_0;
    
#line 1306 
    latency->lt_latency2 = (unsigned short)10U;
  }
  else {
    
#line 1309 
    latency->lt_phyout_idx2 = (unsigned short)0U;
    
#line 1310 
    latency->lt_latency2 = (unsigned short)0U;
  }
  
#line 1312 
  return;
}


#line 1317  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static void smt_fill_neighbor(struct s_smc *smc, struct smt_p_neighbor *neighbor)
{
  int tmp;
  
#line 1319 
  neighbor->para.p_type = (unsigned short)7U;
  
#line 1319 
  neighbor->para.p_len = (unsigned short)16U;
  
#line 1321 
  neighbor->nb_mib_index = (unsigned short)1U;
  
#line 1322 
  tmp = mac_index(smc,1);
  
#line 1322 
  neighbor->nb_mac_index = (unsigned short)tmp;
  
#line 1323 
  neighbor->nb_una = smc->mib.m[0].fddiMACUpstreamNbr;
  
#line 1324 
  neighbor->nb_dna = smc->mib.m[0].fddiMACDownstreamNbr;
  
#line 1325 
  return;
}


#line 1336  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static int smt_fill_path(struct s_smc *smc, struct smt_p_path *path)
{
  int type;
  int state;
  int remote;
  int mac;
  int len;
  int p;
  int physp;
  struct smt_phy_rec *phy;
  struct smt_mac_rec *pd_mac;
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  
#line 1350 
  if ((unsigned int)smc->s.sas == 1U) 
#line 1350 
                                      tmp = 1; else 
#line 1350 
                                                    tmp = 2;
  
#line 1348 
  len = (int)((unsigned long)tmp * (unsigned long)8U + (unsigned long)12U);
  
#line 1351 
  path->para.p_type = (unsigned short)8U;
  
#line 1352 
  path->para.p_len = (unsigned short)((unsigned int)((unsigned short)len) + 65532U);
  
#line 1355 
  p = 0;
  
#line 1355 
  phy = (struct smt_phy_rec *)(& path->pd_phy);
  
#line 1355 
  goto ldv_46614;
  ldv_46613: 
#line 1356 
  ;
  
#line 1356 
  physp = p;
  
#line 1358 
  if ((unsigned int)smc->s.sas == 1U) 
#line 1359 
                                      physp = 0; else ;
  
#line 1361 
  pcm_status_state(smc,physp,& type,& state,& remote,& mac);
  
#line 1363 
  tmp_0 = smt_swap_short((unsigned short)((int)((unsigned int)((unsigned short)p) + 1U)));
  
#line 1363 
  phy->phy_mib_index = (unsigned short)tmp_0;
  
#line 1367 
  phy->phy_type = (unsigned char)type;
  
#line 1368 
  phy->phy_connect_state = (unsigned char)state;
  
#line 1369 
  phy->phy_remote_type = (unsigned char)remote;
  
#line 1370 
  phy->phy_remote_mac = (unsigned char)mac;
  
#line 1371 
  tmp_1 = phy_con_resource_index(smc,p);
  
#line 1371 
  phy->phy_resource_idx = (unsigned short)tmp_1;
  
#line 1355 
  p += 1;
  
#line 1355 
  phy += 1;
  ldv_46614: 
#line 1356 
  ;
  
#line 1355 
  if ((unsigned int)smc->s.sas == 1U) 
#line 1355 
                                      tmp_2 = 1; else 
#line 1355 
                                                      tmp_2 = 2;
  
#line 1355 
  ;
  
#line 1355 
  if (tmp_2 > p) 
#line 1357 
                 goto ldv_46613; else 
#line 1360 
                                      goto ldv_46615;
  ldv_46615: 
#line 1361 
  ;
  
#line 1375 
  pd_mac = (struct smt_mac_rec *)phy;
  
#line 1376 
  pd_mac->mac_addr = smc->mib.m[0].fddiMACSMTAddress;
  
#line 1377 
  tmp_3 = mac_con_resource_index(smc,1);
  
#line 1377 
  pd_mac->mac_resource_idx = (unsigned short)tmp_3;
  
#line 1378 
  return len;
}


#line 1384  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static void smt_fill_mac_status(struct s_smc *smc, struct smt_p_mac_status *st)
{
  int tmp;
  
#line 1386 
  st->para.p_type = (unsigned short)9U;
  
#line 1386 
  st->para.p_len = (unsigned short)40U;
  
#line 1388 
  st->st_mib_index = (unsigned short)1U;
  
#line 1389 
  tmp = mac_index(smc,1);
  
#line 1389 
  st->st_mac_index = (unsigned short)tmp;
  
#line 1391 
  mac_update_counter(smc);
  
#line 1396 
  st->st_t_req = (unsigned int)smc->mib.m[0].fddiMACT_Req;
  
#line 1397 
  st->st_t_neg = (unsigned int)smc->mib.m[0].fddiMACT_Neg;
  
#line 1398 
  st->st_t_max = (unsigned int)smc->mib.m[0].fddiMACT_Max;
  
#line 1399 
  st->st_tvx_value = (unsigned int)smc->mib.m[0].fddiMACTvxValue;
  
#line 1400 
  st->st_t_min = (unsigned int)smc->mib.m[0].fddiMACT_Min;
  
#line 1402 
  st->st_sba = (unsigned int)smc->mib.a[0].fddiPATHSbaPayload;
  
#line 1403 
  st->st_frame_ct = (unsigned int)smc->mib.m[0].fddiMACFrame_Ct;
  
#line 1404 
  st->st_error_ct = (unsigned int)smc->mib.m[0].fddiMACError_Ct;
  
#line 1405 
  st->st_lost_ct = (unsigned int)smc->mib.m[0].fddiMACLost_Ct;
  
#line 1406 
  return;
}


#line 1411  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static void smt_fill_lem(struct s_smc *smc, struct smt_p_lem *lem, int phy)
{
  struct fddi_mib_p *mib;
  int tmp;
  
#line 1415 
  mib = smc->y[phy].mib;
  
#line 1417 
  lem->para.p_type = (unsigned short)10U;
  
#line 1417 
  lem->para.p_len = (unsigned short)16U;
  
#line 1418 
  lem->lem_mib_index = (unsigned short)((unsigned int)((unsigned short)phy) + 1U);
  
#line 1419 
  tmp = phy_index(smc,phy);
  
#line 1419 
  lem->lem_phy_index = (unsigned short)tmp;
  
#line 1420 
  lem->lem_pad2 = (unsigned char)0U;
  
#line 1421 
  lem->lem_cutoff = mib->fddiPORTLer_Cutoff;
  
#line 1422 
  lem->lem_alarm = mib->fddiPORTLer_Alarm;
  
#line 1424 
  lem->lem_estimate = mib->fddiPORTLer_Estimate;
  
#line 1426 
  lem->lem_reject_ct = (unsigned int)mib->fddiPORTLem_Reject_Ct;
  
#line 1427 
  lem->lem_ct = (unsigned int)mib->fddiPORTLem_Ct;
  
#line 1428 
  return;
}


#line 1433  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static void smt_fill_version(struct s_smc *smc, struct smt_p_version *vers)
{
  
#line 1436 
  vers->para.p_type = (unsigned short)20U;
  
#line 1436 
  vers->para.p_len = (unsigned short)8U;
  
#line 1437 
  vers->v_pad = (unsigned short)0U;
  
#line 1438 
  vers->v_n = (unsigned char)1U;
  
#line 1439 
  vers->v_index = (unsigned char)1U;
  
#line 1440 
  vers->v_version[0] = (unsigned short)2U;
  
#line 1441 
  vers->v_pad2 = (unsigned short)0U;
  
#line 1442 
  return;
}


#line 1452  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static void smt_fill_fsc(struct s_smc *smc, struct smt_p_fsc *fsc)
{
  int tmp;
  int tmp_0;
  
#line 1455 
  fsc->para.p_type = (unsigned short)8203U;
  
#line 1455 
  fsc->para.p_len = (unsigned short)8U;
  
#line 1456 
  fsc->fsc_pad0 = (unsigned short)0U;
  
#line 1457 
  fsc->fsc_mac_index = (unsigned short)1U;
  
#line 1460 
  fsc->fsc_pad1 = (unsigned short)0U;
  
#line 1461 
  fsc->fsc_value = (unsigned short)0U;
  
#line 1463 
  tmp = smt_swap_short((unsigned short)1);
  
#line 1463 
  fsc->fsc_mac_index = (unsigned short)tmp;
  
#line 1464 
  tmp_0 = smt_swap_short((unsigned short)0);
  
#line 1464 
  fsc->fsc_value = (unsigned short)tmp_0;
  
#line 1465 
  return;
}


#line 1472  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static void smt_fill_mac_counter(struct s_smc *smc, struct smt_p_mac_counter *mc)
{
  int tmp;
  
#line 1474 
  mc->para.p_type = (unsigned short)11U;
  
#line 1474 
  mc->para.p_len = (unsigned short)12U;
  
#line 1475 
  mc->mc_mib_index = (unsigned short)1U;
  
#line 1476 
  tmp = mac_index(smc,1);
  
#line 1476 
  mc->mc_index = (unsigned short)tmp;
  
#line 1477 
  mc->mc_receive_ct = (unsigned int)smc->mib.m[0].fddiMACCopied_Ct;
  
#line 1478 
  mc->mc_transmit_ct = (unsigned int)smc->mib.m[0].fddiMACTransmit_Ct;
  
#line 1479 
  return;
}


#line 1484  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static void smt_fill_mac_fnc(struct s_smc *smc, struct smt_p_mac_fnc *fnc)
{
  int tmp;
  
#line 1486 
  fnc->para.p_type = (unsigned short)12U;
  
#line 1486 
  fnc->para.p_len = (unsigned short)8U;
  
#line 1487 
  fnc->nc_mib_index = (unsigned short)1U;
  
#line 1488 
  tmp = mac_index(smc,1);
  
#line 1488 
  fnc->nc_index = (unsigned short)tmp;
  
#line 1489 
  fnc->nc_counter = (unsigned int)smc->mib.m[0].fddiMACNotCopied_Ct;
  
#line 1490 
  return;
}


#line 1496  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static void smt_fill_manufacturer(struct s_smc *smc, struct smp_p_manufacturer *man)
{
  
#line 1499 
  man->para.p_type = (unsigned short)15U;
  
#line 1499 
  man->para.p_len = (unsigned short)32U;
  
#line 1500 
  memcpy((void *)(& man->mf_data),(void const *)(& smc->mib.fddiSMTManufacturerData),32UL);
  
#line 1502 
  return;
}


#line 1508  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static void smt_fill_user(struct s_smc *smc, struct smp_p_user *user)
{
  
#line 1510 
  user->para.p_type = (unsigned short)16U;
  
#line 1510 
  user->para.p_len = (unsigned short)32U;
  
#line 1511 
  memcpy((void *)(& user->us_data),(void const *)(& smc->mib.fddiSMTUserData),32UL);
  
#line 1513 
  return;
}


#line 1519  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static void smt_fill_setcount(struct s_smc *smc, struct smt_p_setcount *setcount)
{
  
#line 1522 
  setcount->para.p_type = (unsigned short)4149U;
  
#line 1522 
  setcount->para.p_len = (unsigned short)12U;
  
#line 1523 
  setcount->count = (unsigned int)smc->mib.fddiSMTSetCount.count;
  
#line 1524 
  memcpy((void *)(& setcount->timestamp),(void const *)(& smc->mib.fddiSMTSetCount.timestamp),8UL);
  
#line 1526 
  return;
}


#line 1531  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static void smt_fill_echo(struct s_smc *smc, struct smt_p_echo *echo, u_long seed, int len)
{
  u_char *p;
  u_char *tmp;
  
#line 1537 
  echo->para.p_type = (unsigned short)17U;
  
#line 1537 
  echo->para.p_len = (unsigned short)4454U;
  
#line 1538 
  echo->para.p_len = (unsigned short)len;
  
#line 1539 
  p = (u_char *)(& echo->ec_data);
  
#line 1539 
  goto ldv_46662;
  ldv_46661: 
#line 1540 
  ;
  
#line 1540 
  tmp = p;
  
#line 1540 
  p += 1;
  
#line 1540 
  *tmp = (unsigned char)seed;
  
#line 1541 
  seed += 13UL;
  
#line 1539 
  len -= 1;
  ldv_46662: 
#line 1540 
  ;
  
#line 1539 
  if (len != 0) 
#line 1541 
                goto ldv_46661; else 
#line 1544 
                                     goto ldv_46663;
  ldv_46663: 
#line 1545 
  ;
  
#line 1546 
  return;
}


#line 1549  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static void smt_clear_una_dna(struct s_smc *smc)
{
  
#line 1551 
  smc->mib.m[0].fddiMACUpstreamNbr = SMT_Unknown;
  
#line 1552 
  smc->mib.m[0].fddiMACDownstreamNbr = SMT_Unknown;
  
#line 1553 
  return;
}


#line 1555  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static void smt_clear_old_una_dna(struct s_smc *smc)
{
  
#line 1557 
  smc->mib.m[0].fddiMACOldUpstreamNbr = SMT_Unknown;
  
#line 1558 
  smc->mib.m[0].fddiMACOldDownstreamNbr = SMT_Unknown;
  
#line 1559 
  return;
}


#line 1561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
u_long smt_get_tid(struct s_smc *smc)
{
  u_long __retres;
  u_long tid;
  
#line 1564 
  goto ldv_46675;
  ldv_46674: 
#line 1565 
  ;
  ldv_46675: 
#line 1566 
  ;
  
#line 1564 
  smc->sm.smt_tid += 1UL;
  
#line 1564 
  tid = smc->sm.smt_tid ^ 520780604UL;
  
#line 1564 
  if (tid == 0UL) 
#line 1566 
                  goto ldv_46674; else 
#line 1569 
                                       goto ldv_46676;
  ldv_46676: 
#line 1570 
  ;
  
#line 1566 
  __retres = tid & 1073741823UL;
  
#line 1566 
  return __retres;
}


#line 1577  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static struct smt_pdef const smt_pdef[41U] = {{.ptype = 1, .plen = 12, .pswap = "s6"}, {.ptype = 2, .plen = 8, .pswap = "1111"}, {.ptype = 3, .plen = 8, .pswap = "scc"}, {.ptype = 4, .plen = 12, .pswap = "8"}, {.ptype = 5, .plen = 8, .pswap = "ss"}, {.ptype = 6, .plen = 12, .pswap = "ssss"}, {.ptype = 7, .plen = 20, .pswap = "ss66"}, {.ptype = 8, .plen = 28, .pswap = "[6s]"}, {.ptype = 9, .plen = 44, .pswap = "sslllllllll"}, {.ptype = 10, .plen = 20, .pswap = "ssccccll"}, {.ptype = 11, .plen = 16, .pswap = "ssll"}, {.ptype = 12, .plen = 12, .pswap = "ssl"}, {.ptype = 13, .plen = 36, .pswap = "ssl"}, {.ptype = 14, .plen = 12, .pswap = "ssl"}, {.ptype = 15, .plen = 36, .pswap = ""}, {.ptype = 18, .plen = 8, .pswap = "l"}, {.ptype = 19, .plen = 40, .pswap = "l"}, {.ptype = 20, .plen = 12, .pswap = "sccss"}, {.ptype = 21, .plen = 8, .pswap = "l"}, {.ptype = 22, .plen = 8, .pswap = "l"}, {.ptype = 23, .plen = 8, .pswap = "l"}, {.ptype = 24, .plen = 8, .pswap = "l"}, {.ptype = 25, .plen = 12, .pswap = "s6"}, {.ptype = 26, .plen = 8, .pswap = "l"}, {.ptype = 27, .plen = 8, .pswap = "l"}, {.ptype = 28, .plen = 8, .pswap = "l"}, {.ptype = 29, .plen = 8, .pswap = "l"}, {.ptype = 4149, .plen = 0, .pswap = "l8"}, {.ptype = 4168, .plen = 0, .pswap = "ll"}, {.ptype = 8332, .plen = 0, .pswap = "4lss66"}, {.ptype = 8333, .plen = 0, .pswap = "4lllll"}, {.ptype = 8334, .plen = 0, .pswap = "4llll"}, {.ptype = 8335, .plen = 0, .pswap = "4ll6666s6"}, {.ptype = 8336, .plen = 0, .pswap = "4lssl"}, {.ptype = 12811, .plen = 12, .pswap = "42s"}, {.ptype = 12815, .plen = 12, .pswap = "4l"}, {.ptype = 12816, .plen = 12, .pswap = "4l"}, {.ptype = 16464, .plen = 0, .pswap = "4l1111ll"}, {.ptype = 16465, .plen = 0, .pswap = "4lssss"}, {.ptype = 16466, .plen = 0, .pswap = "4ll"}, {.ptype = 16467, .plen = 0, .pswap = "4lsslss"}};

#line 1650  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
int smt_check_para(struct s_smc *smc, struct smt_header *sm, u_short const *list)
{
  int __retres;
  void *tmp;
  
#line 1653 
  u_short const *p = list;
  
#line 1654 
  goto ldv_46689;
  ldv_46688: 
#line 1655 
  ;
  
#line 1655 
  tmp = sm_to_para(smc,sm,(int)*p);
  
#line 1655 
  if (tmp == (void *)0) {
    
#line 1657 
    __retres = -1;
    
#line 1657 
    goto return_label;
  }
  else ;
  
#line 1659 
  p += 1;
  ldv_46689: 
#line 1660 
  ;
  
#line 1654 
  if ((unsigned int)*p != 0U) 
#line 1656 
                              goto ldv_46688; else 
#line 1659 
                                                   goto ldv_46690;
  ldv_46690: 
#line 1660 
  ;
  
#line 1661 
  __retres = 0;
  return_label: 
#line 1661 
                return __retres;
}


#line 1664  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
void *sm_to_para(struct s_smc *smc, struct smt_header *sm, int para)
{
  void *__retres;
  char *p;
  int len;
  int plen;
  
#line 1669 
  void *found = (void *)0;
  
#line 1673 
  len = (int)sm->smt_len;
  
#line 1674 
  p = (char *)(sm + 1U);
  
#line 1675 
  goto ldv_46701;
  ldv_46700: 
#line 1676 
  ;
  
#line 1676 
  if ((int)((struct smt_para *)p)->p_type == para) 
#line 1677 
                                                   found = (void *)p; else ;
  
#line 1678 
  plen = (int)((unsigned int)((struct smt_para *)p)->p_len + 4U);
  
#line 1679 
  p += plen;
  
#line 1680 
  len -= plen;
  
#line 1681 
  if (len < 0) {
    
#line 1683 
    __retres = (void *)0;
    
#line 1683 
    goto return_label;
  }
  else ;
  
#line 1685 
  if ((plen & 3) != 0 && para != 17) {
    
#line 1687 
    __retres = (void *)0;
    
#line 1687 
    goto return_label;
  }
  else ;
  
#line 1689 
  if (found != (void *)0) {
    
#line 1690 
    __retres = found;
    
#line 1690 
    goto return_label;
  }
  else ;
  ldv_46701: 
#line 1691 
  ;
  
#line 1675 
  if (len > 0) 
#line 1677 
               goto ldv_46700; else 
#line 1680 
                                    goto ldv_46702;
  ldv_46702: 
#line 1681 
  ;
  
#line 1692 
  __retres = (void *)0;
  return_label: 
#line 1692 
                return __retres;
}


#line 1742  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static int mac_index(struct s_smc *smc, int mac)
{
  int tmp;
  
#line 1749 
  if ((unsigned int)smc->s.sas == 1U) 
#line 1749 
                                      tmp = 2; else 
#line 1749 
                                                    tmp = 3;
  
#line 1749 
  return tmp;
}


#line 1756  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static int phy_index(struct s_smc *smc, int phy)
{
  int __retres;
  
#line 1759 
  __retres = phy + 1;
  
#line 1759 
  return __retres;
}


#line 1765  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static int mac_con_resource_index(struct s_smc *smc, int mac)
{
  int __retres;
  int tmp;
  
#line 1773 
  switch ((int)smc->mib.fddiSMTCF_State) {
    case 9: 
#line 1774 
    ;
    case 7: 
#line 1775 
    ;
    case 11: 
#line 1776 
    ;
    
#line 1777 
    __retres = 1;
    
#line 1777 
    goto return_label;
    case 10: 
#line 1778 
    ;
    case 12: 
#line 1779 
    ;
    
#line 1780 
    __retres = 2;
    
#line 1780 
    goto return_label;
  }
  
#line 1782 
  if ((unsigned int)smc->s.sas == 1U) 
#line 1782 
                                      tmp = 2; else 
#line 1782 
                                                    tmp = 3;
  
#line 1782 
  __retres = tmp;
  return_label: 
#line 1782 
                return __retres;
}


#line 1789  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static int phy_con_resource_index(struct s_smc *smc, int phy)
{
  int __retres;
  
#line 1794 
  switch ((int)smc->mib.fddiSMTCF_State) {
    int tmp;
    int tmp_0;
    int tmp_1;
    int tmp_2;
    case 9: 
#line 1795 
    ;
    
#line 1796 
    if (phy == 0) 
#line 1796 
                  tmp = 3; else 
#line 1796 
                                tmp = 2;
    
#line 1796 
    __retres = tmp;
    
#line 1796 
    goto return_label;
    case 10: 
#line 1797 
    ;
    
#line 1798 
    if (phy == 0) 
#line 1798 
                  tmp_0 = 1; else 
#line 1798 
                                  tmp_0 = 3;
    
#line 1798 
    __retres = tmp_0;
    
#line 1798 
    goto return_label;
    case 12: 
#line 1799 
    ;
    
#line 1800 
    if (phy == 0) 
#line 1800 
                  tmp_1 = 3; else 
#line 1800 
                                  tmp_1 = 1;
    
#line 1800 
    __retres = tmp_1;
    
#line 1800 
    goto return_label;
    case 7: 
#line 1801 
    ;
    
#line 1802 
    if (phy == 0) 
#line 1802 
                  tmp_2 = 2; else 
#line 1802 
                                  tmp_2 = 3;
    
#line 1802 
    __retres = tmp_2;
    
#line 1802 
    goto return_label;
    case 11: 
#line 1803 
    ;
    
#line 1804 
    __retres = 2;
    
#line 1804 
    goto return_label;
  }
  
#line 1806 
  __retres = phy;
  return_label: 
#line 1806 
                return __retres;
}


#line 1821  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static int smt_swap_short(u_short s)
{
  int __retres;
  
#line 1823 
  __retres = (((int)s >> 8) & 255) | (((int)s << 8) & 65535);
  
#line 1823 
  return __retres;
}


#line 1826  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
void smt_swap_para(struct smt_header *sm, int len, int direction)
{
  struct smt_para *pa;
  struct smt_pdef const *pd;
  char *p;
  int plen;
  int type;
  int i;
  
#line 1839 
  smt_string_swap((char *)sm,"662sl8ss",len);
  
#line 1842 
  len = (int)((unsigned int)len + 4294967264U);
  
#line 1844 
  p = (char *)(sm + 1U);
  
#line 1845 
  goto ldv_46751;
  ldv_46750: 
#line 1846 
  ;
  {
    int tmp;
    int tmp_0;
    
#line 1846 
    pa = (struct smt_para *)p;
    
#line 1847 
    plen = (int)pa->p_len;
    
#line 1848 
    type = (int)pa->p_type;
    
#line 1849 
    tmp = smt_swap_short((unsigned short)((int)pa->p_type));
    
#line 1849 
    pa->p_type = (unsigned short)tmp;
    
#line 1850 
    tmp_0 = smt_swap_short((unsigned short)((int)pa->p_len));
    
#line 1850 
    pa->p_len = (unsigned short)tmp_0;
    
#line 1851 
    if (direction != 0) {
      
#line 1852 
      plen = (int)pa->p_len;
      
#line 1853 
      type = (int)pa->p_type;
    }
    else ;
    
#line 1858 
    if (plen < 0) 
#line 1859 
                  goto ldv_46743; else ;
    
#line 1860 
    plen = (int)((unsigned int)plen + 4U);
    
#line 1861 
    i = 41;
    
#line 1861 
    pd = (struct smt_pdef const *)(& smt_pdef);
    
#line 1861 
    goto ldv_46749;
    ldv_46748: 
#line 1862 
    ;
    
#line 1862 
    if (pd->ptype == type) 
#line 1863 
                           goto ldv_46747; else ;
    
#line 1861 
    i -= 1;
    
#line 1861 
    pd += 1;
    ldv_46749: 
#line 1862 
    ;
    
#line 1861 
    if (i != 0) 
#line 1863 
                goto ldv_46748; else 
#line 1866 
                                     goto ldv_46747;
    ldv_46747: 
#line 1867 
    ;
    
#line 1865 
    if (i != 0 && pd->pswap != (char const *)0) 
#line 1866 
                                                smt_string_swap(p + 4U,pd->pswap,len); else ;
    
#line 1868 
    len -= plen;
    
#line 1869 
    p += plen;
  }
  ldv_46751: 
#line 1871 
  ;
  
#line 1845 
  if (len > 0) 
#line 1847 
               goto ldv_46750; else 
#line 1850 
                                    goto ldv_46743;
  ldv_46743: 
#line 1851 
  ;
  
#line 1852 
  return;
}


#line 1873  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static void smt_string_swap(char *data, char const *format, int len)
{
  int x;
  
#line 1875 
  char const *open_paren = (char const *)0;
  
#line 1878 
  goto ldv_46775;
  ldv_46774: 
#line 1879 
  ;
  
#line 1879 
  switch ((int)*format) {
    case 91: 
#line 1880 
    ;
    
#line 1881 
    open_paren = format;
    
#line 1882 
    goto ldv_46760;
    case 93: 
#line 1883 
    ;
    
#line 1884 
    format = open_paren;
    
#line 1885 
    goto ldv_46760;
    case 49: 
#line 1886 
    ;
    case 50: 
#line 1887 
    ;
    case 51: 
#line 1888 
    ;
    case 52: 
#line 1889 
    ;
    case 53: 
#line 1890 
    ;
    case 54: 
#line 1891 
    ;
    case 55: 
#line 1892 
    ;
    case 56: 
#line 1893 
    ;
    case 57: 
#line 1894 
    ;
    
#line 1895 
    data += (unsigned long)*format + 18446744073709551568U;
    
#line 1896 
    len -= (int)*format + -48;
    
#line 1897 
    goto ldv_46760;
    case 99: 
#line 1898 
    ;
    
#line 1899 
    data += 1;
    
#line 1900 
    len -= 1;
    
#line 1901 
    goto ldv_46760;
    case 115: 
#line 1902 
    ;
    
#line 1903 
    x = (int)*data;
    
#line 1904 
    *data = *(data + 1U);
    
#line 1905 
    *(data + 1U) = (char)x;
    
#line 1906 
    data += 2U;
    
#line 1907 
    len += -2;
    
#line 1908 
    goto ldv_46760;
    case 108: 
#line 1909 
    ;
    
#line 1910 
    x = (int)*data;
    
#line 1911 
    *data = *(data + 3U);
    
#line 1912 
    *(data + 3U) = (char)x;
    
#line 1913 
    x = (int)*(data + 1U);
    
#line 1914 
    *(data + 1U) = *(data + 2U);
    
#line 1915 
    *(data + 2U) = (char)x;
    
#line 1916 
    data += 4U;
    
#line 1917 
    len += -4;
    
#line 1918 
    goto ldv_46760;
  }
  ldv_46760: 
#line 1920 
  ;
  
#line 1920 
  format += 1;
  ldv_46775: 
#line 1921 
  ;
  
#line 1878 
  if (len > 0 && (int)*format != 0) 
#line 1880 
                                    goto ldv_46774; else 
#line 1883 
                                                         goto ldv_46776;
  ldv_46776: 
#line 1884 
  ;
  
#line 1885 
  return;
}


#line 1936  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
int smt_action(struct s_smc *smc, int class, int code, int index)
{
  int __retres;
  int event;
  int port;
  
#line 1941 
  switch (class) {
    case 1: 
#line 1942 
    ;
    
#line 1943 
    switch (code) {
      u_short tmp;
      u_short tmp_2;
      case 0: 
#line 1944 
      ;
      
#line 1945 
      smc->mib.fddiSMTRemoteDisconnectFlag = (unsigned char)0U;
      
#line 1946 
      queue_event(smc,1,1);
      
#line 1947 
      goto ldv_46787;
      case 1: 
#line 1948 
      ;
      
#line 1949 
      queue_event(smc,1,2);
      
#line 1950 
      smc->mib.fddiSMTRemoteDisconnectFlag = (unsigned char)1U;
      
#line 1951 
      tmp = (unsigned short)((unsigned int)smc->srf.ring_status | 256U);
      
#line 1951 
      smc->srf.ring_status = tmp;
      
#line 1951 
      ;
      
#line 1951 
      ring_status_indication(smc,(unsigned long)tmp);
      
#line 1955 
      goto ldv_46787;
      case 2: 
#line 1956 
      ;
      
#line 1960 
      goto ldv_46787;
      case 3: 
#line 1961 
      ;
      
#line 1965 
      goto ldv_46787;
      case 4: 
#line 1966 
      ;
      
#line 1967 
      if ((unsigned int)smc->y[0].pc_mode == 1U) {
        u_short tmp_0;
        
#line 1968 
        tmp_0 = (unsigned short)((unsigned int)smc->srf.ring_status | 4U);
        
#line 1968 
        smc->srf.ring_status = tmp_0;
        
#line 1968 
        ;
        
#line 1968 
        ring_status_indication(smc,(unsigned long)tmp_0);
        
#line 1969 
        queue_event(smc,5,11);
      }
      else ;
      
#line 1971 
      goto ldv_46787;
      case 5: 
#line 1972 
      ;
      
#line 1973 
      if ((unsigned int)smc->y[1].pc_mode == 1U) {
        u_short tmp_1;
        
#line 1974 
        tmp_1 = (unsigned short)((unsigned int)smc->srf.ring_status | 4U);
        
#line 1974 
        smc->srf.ring_status = tmp_1;
        
#line 1974 
        ;
        
#line 1974 
        ring_status_indication(smc,(unsigned long)tmp_1);
        
#line 1975 
        queue_event(smc,6,11);
      }
      else ;
      
#line 1977 
      goto ldv_46787;
      case 6: 
#line 1978 
      ;
      
#line 1979 
      port = 0;
      
#line 1979 
      goto ldv_46796;
      ldv_46795: 
#line 1980 
      ;
      
#line 1980 
      if ((unsigned int)smc->mib.p[port].fddiPORTMy_Type != 3U) 
#line 1981 
                                                                goto ldv_46794; else ;
      
#line 1982 
      tmp_2 = (unsigned short)((unsigned int)smc->srf.ring_status | 4U);
      
#line 1982 
      smc->srf.ring_status = tmp_2;
      
#line 1982 
      ;
      
#line 1982 
      ring_status_indication(smc,(unsigned long)tmp_2);
      
#line 1983 
      queue_event(smc,port + 5,11);
      ldv_46794: 
#line 1984 
      ;
      
#line 1979 
      port += 1;
      ldv_46796: 
#line 1980 
      ;
      
#line 1979 
      if (port <= 1) 
#line 1981 
                     goto ldv_46795; else 
#line 1984 
                                          goto ldv_46797;
      ldv_46797: 
#line 1985 
      ;
      
#line 1985 
      goto ldv_46787;
      default: 
#line 1986 
      ;
      
#line 1987 
      __retres = 1;
      
#line 1987 
      goto return_label;
    }
    ldv_46787: 
#line 1989 
    ;
    
#line 1989 
    goto ldv_46799;
    case 2: 
#line 1990 
    ;
    
#line 1991 
    switch (code) {
      case 1: 
#line 1992 
      ;
      
#line 1993 
      event = 10;
      
#line 1994 
      goto ldv_46802;
      case 2: 
#line 1995 
      ;
      
#line 1996 
      event = 11;
      
#line 1997 
      goto ldv_46802;
      case 0: 
#line 1998 
      ;
      
#line 1999 
      event = 7;
      
#line 2000 
      goto ldv_46802;
      case 3: 
#line 2001 
      ;
      
#line 2002 
      event = 1;
      
#line 2003 
      goto ldv_46802;
      case 4: 
#line 2004 
      ;
      
#line 2005 
      event = 2;
      
#line 2006 
      goto ldv_46802;
      default: 
#line 2007 
      ;
      
#line 2008 
      __retres = 1;
      
#line 2008 
      goto return_label;
    }
    ldv_46802: 
#line 2010 
    ;
    
#line 2010 
    queue_event(smc,index + 5,event);
    
#line 2011 
    goto ldv_46799;
    default: 
#line 2012 
    ;
    
#line 2013 
    __retres = 1;
    
#line 2013 
    goto return_label;
  }
  ldv_46799: 
#line 2015 
  ;
  
#line 2015 
  __retres = 0;
  return_label: 
#line 2015 
                return __retres;
}


#line 2022  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/smt.c"
static void hwm_conv_can(struct s_smc *smc, char *data, int len)
{
  int i;
  int tmp_2;
  
#line 2028 
  i = len;
  
#line 2028 
  goto ldv_46820;
  ldv_46819: 
#line 2029 
  ;
  {
    int tmp_1;
    
#line 2029 
    unsigned char __x = (unsigned char)*data;
    
#line 2029 
    if (0 != 0) {
      unsigned char tmp;
      {
        
#line 2029 
        unsigned char __x_0 = __x_0;
        
#line 2029 
        __x_0 = (unsigned char)(((int)__x_0 >> 4) | ((int)__x_0 << 4));
        
#line 2029 
        __x_0 = (unsigned char)((((int)__x_0 >> 2) & 51) | (((int)__x_0 << 2) & -52));
        
#line 2029 
        __x_0 = (unsigned char)((((int)__x_0 >> 1) & 85) | (((int)__x_0 << 1) & -86));
        
#line 2029 
        tmp = __x_0;
      }
      
#line 2029 
      tmp_1 = (int)tmp;
    }
    else {
      unsigned char tmp_0;
      
#line 2029 
      tmp_0 = __bitrev8((unsigned char)((int)__x));
      
#line 2029 
      tmp_1 = (int)tmp_0;
    }
    
#line 2029 
    tmp_2 = tmp_1;
  }
  
#line 2029 
  *data = (char)tmp_2;
  
#line 2028 
  i -= 1;
  
#line 2028 
  data += 1;
  ldv_46820: 
#line 2029 
  ;
  
#line 2028 
  if (i != 0) 
#line 2030 
              goto ldv_46819; else 
#line 2033 
                                   goto ldv_46821;
  ldv_46821: 
#line 2034 
  ;
  
#line 2035 
  return;
}


#line 583  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/h/cmtdef.h"
void formac_tx_restart(struct s_smc *smc);


#line 589 
void llc_recover_tx(struct s_smc *smc);


#line 596 
void mac_do_pci_fix(struct s_smc *smc);


#line 28  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/iomap.h"
unsigned int ioread8(void *);


#line 34 
void iowrite8(u8, void *);


#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/drvfbi.c"
u_char const oem_id[13U] = {(unsigned char)'x', (unsigned char)'P', (unsigned char)'O', (unsigned char)'S', (unsigned char)'_', (unsigned char)'I', (unsigned char)'D', (unsigned char)':', (unsigned char)'x', (unsigned char)'x', (unsigned char)'x', (unsigned char)'x', (unsigned char)'\000'};

#line 83 
static void smt_stop_watchdog(struct s_smc *smc);


#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/drvfbi.c"
static void card_start(struct s_smc *smc)
{
  int i;
  u_char rev_id;
  u_short word;
  u_long tmp;
  unsigned int tmp_0;
  unsigned int tmp_1;
  unsigned int tmp_2_0;
  
#line 96 
  smt_stop_watchdog(smc);
  
#line 102 
  iowrite16((unsigned short)0,smc->hw.iop + 1088U);
  
#line 103 
  iowrite8((unsigned char)16,smc->hw.iop + 4U);
  
#line 104 
  tmp = hwt_quick_read(smc);
  
#line 104 
  ;
  
#line 104 
  hwt_wait_time(smc,tmp,125000L);
  
#line 108 
  iowrite8((unsigned char)1,smc->hw.iop + 4U);
  
#line 109 
  tmp_0 = ioread8(smc->hw.iop + 4U);
  
#line 109 
  i = (int)tmp_0;
  
#line 110 
  int tmp_2 = i;
  
#line 111 
  iowrite8((unsigned char)2,smc->hw.iop + 4U);
  
#line 116 
  iowrite8((unsigned char)2,smc->hw.iop + 7U);
  
#line 117 
  tmp_1 = ioread16(smc->hw.iop + 390U);
  
#line 117 
  word = (unsigned short)tmp_1;
  
#line 118 
  iowrite16((unsigned short)((int)((unsigned int)word | 59648U)),smc->hw.iop + 390U);
  
#line 119 
  iowrite8((unsigned char)1,smc->hw.iop + 7U);
  
#line 126 
  iowrite8((unsigned char)40,smc->hw.iop + 4U);
  
#line 134 
  tmp_2_0 = ioread8(smc->hw.iop + 392U);
  
#line 134 
  rev_id = (unsigned char)tmp_2_0;
  
#line 135 
  if (((int)rev_id & 240) == 32 || ((int)rev_id & 240) == 48) 
#line 136 
                                                              smc->hw.hw_is_64bit = 1; else 
                                                                    
#line 138 
                                                                    smc->hw.hw_is_64bit = 0;
  
#line 144 
  if (smc->hw.hw_is_64bit == 0) {
    
#line 145 
    iowrite32(24U,smc->hw.iop + 544U);
    
#line 146 
    iowrite32(24U,smc->hw.iop + 672U);
    
#line 147 
    iowrite32(24U,smc->hw.iop + 736U);
  }
  else ;
  
#line 150 
  iowrite8((unsigned char)2,smc->hw.iop + 4U);
  
#line 151 
  iowrite8((unsigned char)25,smc->hw.iop + 6U);
  
#line 154 
  iowrite32(1875000000U,smc->hw.iop + 304U);
  
#line 157 
  smc->hw.is_imask = 8368179UL;
  
#line 158 
  smc->hw.hw_state = (unsigned short)0U;
  
#line 160 
  iowrite32(0U,smc->hw.iop + 272U);
  
#line 161 
  return;
}


#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/drvfbi.c"
void card_stop(struct s_smc *smc)
{
  u_long tmp;
  
#line 165 
  smt_stop_watchdog(smc);
  
#line 166 
  smc->hw.mac_ring_is_up = (unsigned short)0U;
  
#line 172 
  iowrite16((unsigned short)0,smc->hw.iop + 1088U);
  
#line 173 
  iowrite8((unsigned char)16,smc->hw.iop + 4U);
  
#line 174 
  tmp = hwt_quick_read(smc);
  
#line 174 
  ;
  
#line 174 
  hwt_wait_time(smc,tmp,125000L);
  
#line 178 
  iowrite8((unsigned char)1,smc->hw.iop + 4U);
  
#line 179 
  iowrite8((unsigned char)2,smc->hw.iop + 4U);
  
#line 180 
  iowrite8((unsigned char)21,smc->hw.iop + 6U);
  
#line 181 
  smc->hw.hw_state = (unsigned short)0U;
  
#line 182 
  return;
}


#line 186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/drvfbi.c"
void mac1_irq(struct s_smc *smc, u_short stu, u_short stl)
{
  
#line 188 
  int restart_tx = 0;
  again: 
#line 189 
  ;
  
#line 194 
  if (((int)stl & 1792) != 0) 
#line 197 
                              printk("\001",134,(char *)"ST1L.FM_SPCEPDx parity error"); else ;
  
#line 202 
  if (((int)stl & 28672) != 0) 
#line 205 
                               printk("\001",133,(char *)"ST1L.FM_STBURx tx buffer underrun"); else ;
  
#line 208 
  if (((int)stu & 38912) != 0 || ((int)stl & 3) != 0) {
    unsigned int tmp;
    unsigned int tmp_0;
    
#line 213 
    formac_tx_restart(smc);
    
#line 214 
    restart_tx = 1;
    
#line 215 
    tmp = ioread16(smc->hw.iop + 1024U);
    
#line 215 
    stu = (unsigned short)tmp;
    
#line 216 
    tmp_0 = ioread16(smc->hw.iop + 1028U);
    
#line 216 
    stl = (unsigned short)tmp_0;
    
#line 217 
    stu = (unsigned short)((unsigned int)stu & 65500U);
    
#line 218 
    if ((unsigned int)stu != 0U || (unsigned int)stl != 0U) 
#line 219 
                                                            goto again; else ;
  }
  else ;
  
#line 222 
  if (((int)stu & 3) != 0) 
#line 224 
                           restart_tx = 1; else ;
  
#line 227 
  if (restart_tx != 0) 
#line 228 
                       llc_restart_tx(smc); else ;
  
#line 229 
  return;
}


#line 235  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/drvfbi.c"
void plc1_irq(struct s_smc *smc)
{
  unsigned int tmp;
  
#line 237 
  tmp = ioread16(smc->hw.iop + 988U);
  
#line 237 
  u_short st = (unsigned short)tmp;
  
#line 239 
  plc_irq(smc,1,(unsigned int)st);
  
#line 240 
  return;
}


#line 246  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/drvfbi.c"
void plc2_irq(struct s_smc *smc)
{
  unsigned int tmp;
  
#line 248 
  tmp = ioread16(smc->hw.iop + 1628U);
  
#line 248 
  u_short st = (unsigned short)tmp;
  
#line 250 
  plc_irq(smc,0,(unsigned int)st);
  
#line 251 
  return;
}


#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/drvfbi.c"
void timer_irq(struct s_smc *smc)
{
  
#line 259 
  hwt_restart(smc);
  
#line 260 
  smc->hw.t_stop = smc->hw.t_start;
  
#line 261 
  smt_timer_done(smc);
  
#line 262 
  return;
}


#line 267  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/drvfbi.c"
int pcm_get_s_port(struct s_smc *smc)
{
  int __retres;
  
#line 270 
  __retres = 0;
  
#line 270 
  return __retres;
}


#line 284  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/drvfbi.c"
void read_address(struct s_smc *smc, u_char *mac_addr)
{
  char ConnectorType;
  char PmdType;
  int i;
  int tmp_3;
  unsigned int tmp_4;
  unsigned int tmp_5;
  u_char tmp_6;
  u_char tmp_7;
  int tmp_15;
  
#line 291 
  i = 0;
  
#line 291 
  goto ldv_46325;
  ldv_46324: 
#line 292 
  ;
  {
    unsigned int tmp;
    int tmp_2;
    
#line 293 
    tmp = ioread8(smc->hw.iop + (i + 256));
    
#line 293 
    unsigned char __x = (unsigned char)tmp;
    
#line 293 
    if (0 != 0) {
      unsigned char tmp_0;
      {
        
#line 293 
        unsigned char __x_0 = __x_0;
        
#line 293 
        __x_0 = (unsigned char)(((int)__x_0 >> 4) | ((int)__x_0 << 4));
        
#line 293 
        __x_0 = (unsigned char)((((int)__x_0 >> 2) & 51) | (((int)__x_0 << 2) & -52));
        
#line 293 
        __x_0 = (unsigned char)((((int)__x_0 >> 1) & 85) | (((int)__x_0 << 1) & -86));
        
#line 293 
        tmp_0 = __x_0;
      }
      
#line 293 
      tmp_2 = (int)tmp_0;
    }
    else {
      unsigned char tmp_1;
      
#line 293 
      tmp_1 = __bitrev8((unsigned char)((int)__x));
      
#line 293 
      tmp_2 = (int)tmp_1;
    }
    
#line 293 
    tmp_3 = tmp_2;
  }
  
#line 292 
  smc->hw.fddi_phys_addr.a[i] = (unsigned char)tmp_3;
  
#line 291 
  i += 1;
  ldv_46325: 
#line 292 
  ;
  
#line 291 
  if (i <= 5) 
#line 293 
              goto ldv_46324; else 
#line 296 
                                   goto ldv_46326;
  ldv_46326: 
#line 297 
  ;
  
#line 297 
  tmp_4 = ioread8(smc->hw.iop + 264U);
  
#line 297 
  ConnectorType = (char)tmp_4;
  
#line 298 
  tmp_5 = ioread8(smc->hw.iop + 265U);
  
#line 298 
  PmdType = (char)tmp_5;
  
#line 300 
  tmp_6 = (unsigned char)ConnectorType;
  
#line 300 
  smc->y[1].pmd_type[0] = tmp_6;
  
#line 300 
  smc->y[0].pmd_type[0] = tmp_6;
  
#line 302 
  tmp_7 = (unsigned char)PmdType;
  
#line 302 
  smc->y[1].pmd_type[1] = tmp_7;
  
#line 302 
  smc->y[0].pmd_type[1] = tmp_7;
  
#line 305 
  if (mac_addr != (u_char *)0U) {
    int tmp_11;
    
#line 306 
    i = 0;
    
#line 306 
    goto ldv_46332;
    ldv_46331: 
#line 307 
    ;
    
#line 307 
    smc->hw.fddi_canon_addr.a[i] = *(mac_addr + i);
    {
      int tmp_10;
      
#line 308 
      unsigned char __x_1 = *(mac_addr + i);
      
#line 308 
      if (0 != 0) {
        unsigned char tmp_8;
        {
          
#line 308 
          unsigned char __x_2 = __x_2;
          
#line 308 
          __x_2 = (unsigned char)(((int)__x_2 >> 4) | ((int)__x_2 << 4));
          
#line 308 
          __x_2 = (unsigned char)((((int)__x_2 >> 2) & 51) | (((int)__x_2 << 2) & -52));
          
#line 308 
          __x_2 = (unsigned char)((((int)__x_2 >> 1) & 85) | (((int)__x_2 << 1) & -86));
          
#line 308 
          tmp_8 = __x_2;
        }
        
#line 308 
        tmp_10 = (int)tmp_8;
      }
      else {
        unsigned char tmp_9;
        
#line 308 
        tmp_9 = __bitrev8((unsigned char)((int)__x_1));
        
#line 308 
        tmp_10 = (int)tmp_9;
      }
      
#line 308 
      tmp_11 = tmp_10;
    }
    
#line 308 
    smc->hw.fddi_home_addr.a[i] = (unsigned char)tmp_11;
    
#line 306 
    i += 1;
    ldv_46332: 
#line 307 
    ;
    
#line 306 
    if (i <= 5) 
#line 308 
                goto ldv_46331; else 
#line 311 
                                     goto ldv_46333;
    ldv_46333: 
#line 312 
    ;
    
#line 310 
    goto return_label;
  }
  else ;
  
#line 312 
  smc->hw.fddi_home_addr = smc->hw.fddi_phys_addr;
  
#line 314 
  i = 0;
  
#line 314 
  goto ldv_46339;
  ldv_46338: 
#line 315 
  ;
  {
    int tmp_14;
    
#line 316 
    unsigned char __x_3 = smc->hw.fddi_phys_addr.a[i];
    
#line 316 
    if (0 != 0) {
      unsigned char tmp_12;
      {
        
#line 316 
        unsigned char __x_4 = __x_4;
        
#line 316 
        __x_4 = (unsigned char)(((int)__x_4 >> 4) | ((int)__x_4 << 4));
        
#line 316 
        __x_4 = (unsigned char)((((int)__x_4 >> 2) & 51) | (((int)__x_4 << 2) & -52));
        
#line 316 
        __x_4 = (unsigned char)((((int)__x_4 >> 1) & 85) | (((int)__x_4 << 1) & -86));
        
#line 316 
        tmp_12 = __x_4;
      }
      
#line 316 
      tmp_14 = (int)tmp_12;
    }
    else {
      unsigned char tmp_13;
      
#line 316 
      tmp_13 = __bitrev8((unsigned char)((int)__x_3));
      
#line 316 
      tmp_14 = (int)tmp_13;
    }
    
#line 316 
    tmp_15 = tmp_14;
  }
  
#line 315 
  smc->hw.fddi_canon_addr.a[i] = (unsigned char)tmp_15;
  
#line 314 
  i += 1;
  ldv_46339: 
#line 315 
  ;
  
#line 314 
  if (i <= 5) 
#line 316 
              goto ldv_46338; else 
#line 319 
                                   goto ldv_46340;
  ldv_46340: 
#line 320 
  ;
  return_label: 
#line 321 
                return;
}


#line 323  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/drvfbi.c"
void init_board(struct s_smc *smc, u_char *mac_addr)
{
  unsigned int tmp;
  unsigned int tmp_0;
  
#line 325 
  card_start(smc);
  
#line 326 
  read_address(smc,mac_addr);
  
#line 328 
  tmp = ioread8(smc->hw.iop + 5U);
  
#line 328 
  if ((tmp & 8U) == 0U) 
#line 329 
                        smc->s.sas = (unsigned char)1U; else 
#line 331 
                                                             smc->s.sas = (unsigned char)0U;
  
#line 333 
  tmp_0 = ioread8(smc->hw.iop + 5U);
  
#line 333 
  if ((tmp_0 & 4U) == 0U) 
#line 334 
                          smc->mib.fddiSMTBypassPresent = (unsigned char)0U; else 
                                                                    
#line 337 
                                                                    smc->mib.fddiSMTBypassPresent = (unsigned char)1U;
  
#line 338 
  return;
}


#line 344  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/drvfbi.c"
void sm_pm_bypass_req(struct s_smc *smc, int mode)
{
  
#line 349 
  if ((unsigned int)smc->s.sas != 0U) 
#line 350 
                                      goto return_label; else ;
  
#line 353 
  switch (mode) {
    case 1: 
#line 354 
    ;
    
#line 355 
    iowrite8((unsigned char)2,smc->hw.iop + 5U);
    
#line 356 
    goto ldv_46350;
    case 0: 
#line 357 
    ;
    
#line 358 
    iowrite8((unsigned char)1,smc->hw.iop + 5U);
    
#line 359 
    goto ldv_46350;
  }
  ldv_46350: 
#line 362 
  ;
  return_label: 
#line 363 
                return;
}


#line 367  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/drvfbi.c"
int sm_pm_bypass_present(struct s_smc *smc)
{
  int __retres;
  unsigned int tmp;
  
#line 369 
  tmp = ioread8(smc->hw.iop + 5U);
  
#line 369 
  __retres = (tmp & 4U) != 0U;
  
#line 369 
  return __retres;
}


#line 372  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/drvfbi.c"
void plc_clear_irq(struct s_smc *smc, int p)
{
  
#line 377 
  return;
}


#line 391  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/drvfbi.c"
static void led_indication(struct s_smc *smc, int led_event)
{
  u_short led_state;
  struct s_phy *phy;
  struct fddi_mib_p *mib_a;
  struct fddi_mib_p *mib_b;
  
#line 401 
  phy = & smc->y[0];
  
#line 402 
  mib_a = phy->mib;
  
#line 403 
  phy = & smc->y[1];
  
#line 404 
  mib_b = phy->mib;
  
#line 407 
  led_state = (unsigned short)0U;
  
#line 410 
  if (led_event == 17) 
#line 411 
                       led_state = (unsigned short)((unsigned int)led_state | 8U);
  else 
    
#line 413 
    if (led_event == 16) 
#line 414 
                         led_state = (unsigned short)((unsigned int)led_state | 4U);
    else {
      
#line 418 
      if ((unsigned int)mib_a->fddiPORTPCMState == 8U) 
#line 419 
                                                       led_state = (unsigned short)((unsigned int)led_state | 32U); else 
                                                                    
#line 422 
                                                                    led_state = (unsigned short)((unsigned int)led_state | 16U);
      
#line 426 
      if ((unsigned int)mib_b->fddiPORTPCMState == 8U) 
#line 427 
                                                       led_state = (unsigned short)((unsigned int)led_state | 2U); else 
                                                                    
#line 430 
                                                                    led_state = (unsigned short)((unsigned int)led_state | 1U);
    }
  
#line 434 
  iowrite8((unsigned char)((int)((unsigned char)led_state)),smc->hw.iop + 6U);
  
#line 435 
  return;
}


#line 440  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/drvfbi.c"
void pcm_state_change(struct s_smc *smc, int plc, int p_state)
{
  
#line 449 
  led_indication(smc,0);
  
#line 450 
  return;
}


#line 453  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/drvfbi.c"
void rmt_indication(struct s_smc *smc, int i)
{
  int tmp;
  
#line 458 
  if (i != 0) 
#line 458 
              tmp = 16; else 
#line 458 
                             tmp = 17;
  
#line 458 
  ;
  
#line 458 
  led_indication(smc,tmp);
  
#line 459 
  return;
}


#line 465  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/drvfbi.c"
void llc_recover_tx(struct s_smc *smc)
{
  
#line 476 
  return;
}


#line 540  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/drvfbi.c"
void driver_get_bia(struct s_smc *smc, struct fddi_addr *bia_addr)
{
  int i;
  int tmp_2;
  
#line 544 
  i = 0;
  
#line 544 
  goto ldv_46389;
  ldv_46388: 
#line 545 
  ;
  {
    int tmp_1;
    
#line 545 
    unsigned char __x = smc->hw.fddi_phys_addr.a[i];
    
#line 545 
    if (0 != 0) {
      unsigned char tmp;
      {
        
#line 545 
        unsigned char __x_0 = __x_0;
        
#line 545 
        __x_0 = (unsigned char)(((int)__x_0 >> 4) | ((int)__x_0 << 4));
        
#line 545 
        __x_0 = (unsigned char)((((int)__x_0 >> 2) & 51) | (((int)__x_0 << 2) & -52));
        
#line 545 
        __x_0 = (unsigned char)((((int)__x_0 >> 1) & 85) | (((int)__x_0 << 1) & -86));
        
#line 545 
        tmp = __x_0;
      }
      
#line 545 
      tmp_1 = (int)tmp;
    }
    else {
      unsigned char tmp_0;
      
#line 545 
      tmp_0 = __bitrev8((unsigned char)((int)__x));
      
#line 545 
      tmp_1 = (int)tmp_0;
    }
    
#line 545 
    tmp_2 = tmp_1;
  }
  
#line 545 
  bia_addr->a[i] = (unsigned char)tmp_2;
  
#line 544 
  i += 1;
  ldv_46389: 
#line 545 
  ;
  
#line 544 
  if (i <= 5) 
#line 546 
              goto ldv_46388; else 
#line 549 
                                   goto ldv_46390;
  ldv_46390: 
#line 550 
  ;
  
#line 551 
  return;
}


#line 548  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/drvfbi.c"
void smt_start_watchdog(struct s_smc *smc)
{
  
#line 555 
  if ((int)smc->hw.wdog_used != 0) 
#line 556 
                                   iowrite16((unsigned short)4,smc->hw.iop + 312U); else ;
  
#line 557 
  return;
}


#line 563  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/drvfbi.c"
static void smt_stop_watchdog(struct s_smc *smc)
{
  
#line 569 
  if ((int)smc->hw.wdog_used != 0) 
#line 570 
                                   iowrite16((unsigned short)2,smc->hw.iop + 312U); else ;
  
#line 571 
  return;
}


#line 579  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/drvfbi.c"
void mac_do_pci_fix(struct s_smc *smc)
{
  
#line 582 
  return;
}


#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/queue.c"
void ev_init(struct s_smc *smc)
{
  struct event_queue *tmp;
  
#line 36 
  tmp = (struct event_queue *)(& smc->q.ev_queue);
  
#line 36 
  smc->q.ev_get = tmp;
  
#line 36 
  smc->q.ev_put = tmp;
  
#line 37 
  return;
}


#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/queue.c"
void queue_event(struct s_smc *smc, int class, int event)
{
  
#line 45 
  (smc->q.ev_put)->class = (unsigned short)class;
  
#line 46 
  (smc->q.ev_put)->event = (unsigned short)event;
  
#line 47 
  smc->q.ev_put += 1;
  
#line 47 
  ;
  
#line 47 
  if (smc->q.ev_put == & smc->q.ev_queue[64]) 
#line 48 
                                              smc->q.ev_put = (struct event_queue *)(& smc->q.ev_queue); else ;
  
#line 50 
  if (smc->q.ev_put == smc->q.ev_get) 
#line 51 
                                      printk("\001",137,(char *)"SMT: queue overrun"); else ;
  
#line 52 
  return;
}


#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/queue.c"
void timer_event(struct s_smc *smc, u_long token)
{
  
#line 63 
  queue_event(smc,(int)(token >> 16) & 65535,(int)token & 65535);
  
#line 64 
  return;
}


#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/queue.c"
void ev_dispatcher(struct s_smc *smc)
{
  struct event_queue *ev;
  int class;
  
#line 78 
  ev = smc->q.ev_get;
  
#line 80 
  goto ldv_46253;
  ldv_46252: 
#line 81 
  ;
  
#line 82 
  class = (int)ev->class;
  
#line 82 
  switch (class) {
    case 1: 
#line 83 
    ;
    
#line 84 
    ecm(smc,(int)ev->event);
    
#line 85 
    goto ldv_46245;
    case 2: 
#line 86 
    ;
    
#line 87 
    cfm(smc,(int)ev->event);
    
#line 88 
    goto ldv_46245;
    case 3: 
#line 89 
    ;
    
#line 90 
    rmt(smc,(int)ev->event);
    
#line 91 
    goto ldv_46245;
    case 4: 
#line 92 
    ;
    
#line 93 
    smt_event(smc,(int)ev->event);
    
#line 94 
    goto ldv_46245;
    case 5: 
#line 100 
    ;
    case 6: 
#line 101 
    ;
    default: 
#line 102 
    ;
    
#line 103 
    if ((unsigned int)class + 4294967291U <= 1U) {
      
#line 105 
      pcm(smc,class + -5,(int)ev->event);
      
#line 106 
      goto ldv_46245;
    }
    else ;
    
#line 108 
    printk("\001",121,(char *)"invalid event in dispatcher");
    
#line 109 
    goto return_label;
  }
  ldv_46245: 
#line 112 
  ;
  
#line 112 
  ev += 1;
  
#line 112 
  ;
  
#line 112 
  if (ev == & smc->q.ev_queue[64]) 
#line 113 
                                   ev = (struct event_queue *)(& smc->q.ev_queue); else ;
  
#line 116 
  smc->q.ev_get = ev;
  ldv_46253: 
#line 117 
  ;
  
#line 80 
  if (smc->q.ev_put != ev) 
#line 82 
                           goto ldv_46252; else 
#line 85 
                                                goto ldv_46254;
  ldv_46254: 
#line 86 
  ;
  return_label: 
#line 87 
                return;
}


#line 127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/queue.c"
u_short smt_online(struct s_smc *smc, int on)
{
  u_short __retres;
  int tmp;
  
#line 129 
  if (on != 0) 
#line 129 
               tmp = 1; else 
#line 129 
                             tmp = 2;
  
#line 129 
  ;
  
#line 129 
  queue_event(smc,1,tmp);
  
#line 130 
  ev_dispatcher(smc);
  
#line 131 
  __retres = smc->mib.fddiSMTCF_State;
  
#line 131 
  return __retres;
}


#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool ether_addr_equal(unsigned char const *addr1, unsigned char const *addr2)
{
  bool __retres;
  
#line 313 
  unsigned int fold = (*((unsigned int const *)addr1) ^ *((unsigned int const *)addr2)) | (unsigned int)((int)*((unsigned short const *)(addr1 + 4U)) ^ (int)*((unsigned short const *)(addr2 + 4U)));
  
#line 316 
  __retres = (_Bool)(fold == 0U);
  
#line 316 
  return __retres;
}


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static void build_claim_beacon(struct s_smc *smc, u_long t_request);


#line 48 
static int init_mac(struct s_smc *smc, int all);


#line 49 
static void rtm_init(struct s_smc *smc);


#line 50 
static void smt_split_up_fifo(struct s_smc *smc);


#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static char write_mdr_warning[35U] = {(char)'E', (char)'3', (char)'5', (char)'0', (char)' ', (char)'w', (char)'r', (char)'i', (char)'t', (char)'e', (char)'_', (char)'m', (char)'d', (char)'r', (char)'(', (char)')', (char)' ', (char)'F', (char)'M', (char)'_', (char)'S', (char)'N', (char)'P', (char)'P', (char)'N', (char)'D', (char)' ', (char)'i', (char)'s', (char)' ', (char)'s', (char)'e', (char)'t', (char)'\n', (char)'\000'};

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static char cam_warning[27U] = {(char)'E', (char)'_', (char)'S', (char)'M', (char)'T', (char)'_', (char)'0', (char)'0', (char)'4', (char)':', (char)' ', (char)'C', (char)'A', (char)'M', (char)' ', (char)'s', (char)'t', (char)'i', (char)'l', (char)'l', (char)' ', (char)'b', (char)'u', (char)'s', (char)'y', (char)'\n', (char)'\000'};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
struct fddi_addr const fddi_broadcast = {.a = {(unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U}};

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static struct fddi_addr const null_addr_0 = {.a = {(unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U}};

#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static struct fddi_addr const dbeacon_multi = {.a = {(unsigned char)1U, (unsigned char)128U, (unsigned char)194U, (unsigned char)0U, (unsigned char)1U, (unsigned char)0U}};

#line 77  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static u_short const my_said = (unsigned short)65535U;

#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static u_short const my_sagp = (unsigned short)65535U;

#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static u_long mac_get_tneg(struct s_smc *smc)
{
  u_long __retres;
  u_long tneg;
  unsigned int tmp;
  unsigned int tmp_0;
  
#line 115 
  tmp = ioread16(smc->hw.iop + 1120U);
  
#line 115 
  tneg = (unsigned long)((long)tmp << 5);
  
#line 116 
  tmp_0 = ioread16(smc->hw.iop + 1124U);
  
#line 116 
  ;
  
#line 116 
  __retres = (((unsigned long)(tmp_0 >> 10) & 31UL) + tneg) | 4292870144UL;
  
#line 116 
  return __retres;
}


#line 120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
void mac_update_counter(struct s_smc *smc)
{
  unsigned int tmp;
  unsigned int tmp_0;
  unsigned int tmp_1;
  
#line 124 
  tmp = ioread16(smc->hw.iop + 1284U);
  
#line 122 
  smc->mib.m[0].fddiMACFrame_Ct = (smc->mib.m[0].fddiMACFrame_Ct & 4294901760UL) + (unsigned long)((unsigned short)tmp);
  
#line 127 
  tmp_0 = ioread16(smc->hw.iop + 1288U);
  
#line 125 
  smc->mib.m[0].fddiMACLost_Ct = (smc->mib.m[0].fddiMACLost_Ct & 4294901760UL) + (unsigned long)((unsigned short)tmp_0);
  
#line 130 
  tmp_1 = ioread16(smc->hw.iop + 1292U);
  
#line 128 
  smc->mib.m[0].fddiMACError_Ct = (smc->mib.m[0].fddiMACError_Ct & 4294901760UL) + (unsigned long)((unsigned short)tmp_1);
  
#line 131 
  smc->mib.m[0].fddiMACT_Neg = mac_get_tneg(smc);
  
#line 138 
  smt_emulate_token_ct(smc,0);
  
#line 139 
  return;
}


#line 145  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static void write_mdr(struct s_smc *smc, u_long val)
{
  {
    unsigned int tmp;
    
#line 147 
    unsigned int k = 10000U;
    
#line 147 
    goto ldv_46521;
    ldv_46520: 
#line 148 
    ;
    
#line 147 
    k -= 1U;
    ldv_46521: 
#line 148 
    ;
    
#line 147 
    tmp = ioread16(smc->hw.iop + 1092U);
    
#line 147 
    if ((tmp & 8U) != 0U) {
      
#line 147 
      if (k != 0U) 
#line 149 
                   goto ldv_46520; else 
#line 152 
                                        goto ldv_46522;
    }
    else 
#line 152 
         goto ldv_46522;
    ldv_46522: 
#line 153 
    ;
    
#line 147 
    if (k == 0U) 
#line 147 
                 printk("\001",130,(char *)(& write_mdr_warning)); else ;
  }
  
#line 148 
  iowrite16((unsigned short)((int)((unsigned short)(val >> 16))),smc->hw.iop + 1272U);
  
#line 148 
  iowrite16((unsigned short)((int)((unsigned short)val)),smc->hw.iop + 1276U);
  
#line 149 
  return;
}


#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static void init_ram(struct s_smc *smc)
{
  u_short i;
  
#line 178 
  smc->hw.fp.fifo.rbc_ram_start = (unsigned short)0U;
  
#line 179 
  smc->hw.fp.fifo.rbc_ram_end = (unsigned short)((unsigned int)smc->hw.fp.fifo.rbc_ram_start + 32768U);
  {
    unsigned int tmp;
    
#line 181 
    unsigned int k = 10000U;
    
#line 181 
    goto ldv_46529;
    ldv_46528: 
#line 182 
    ;
    
#line 181 
    k -= 1U;
    ldv_46529: 
#line 182 
    ;
    
#line 181 
    tmp = ioread16(smc->hw.iop + 1092U);
    
#line 181 
    if ((tmp & 8U) != 0U) {
      
#line 181 
      if (k != 0U) 
#line 183 
                   goto ldv_46528; else 
#line 186 
                                        goto ldv_46530;
    }
    else 
#line 186 
         goto ldv_46530;
    ldv_46530: 
#line 187 
    ;
    
#line 181 
    if (k == 0U) 
#line 181 
                 printk("\001",130,(char *)(& write_mdr_warning)); else ;
  }
  
#line 182 
  iowrite16((unsigned short)((int)smc->hw.fp.fifo.rbc_ram_start),smc->hw.iop + 1268U);
  
#line 183 
  i = smc->hw.fp.fifo.rbc_ram_start;
  
#line 183 
  goto ldv_46532;
  ldv_46531: 
#line 184 
  ;
  
#line 185 
  write_mdr(smc,0UL);
  
#line 184 
  i = (u_short)((int)i + 1);
  ldv_46532: 
#line 185 
  ;
  
#line 184 
  if ((unsigned int)smc->hw.fp.fifo.rbc_ram_end + 65535U > (unsigned int)i) 
    
#line 186 
    goto ldv_46531; else 
#line 189 
                         goto ldv_46533;
  ldv_46533: 
#line 190 
  ;
  
#line 187 
  write_mdr(smc,0UL);
  
#line 188 
  return;
}


#line 193  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static void set_recvptr(struct s_smc *smc)
{
  
#line 198 
  iowrite16((unsigned short)((int)smc->hw.fp.fifo.rx1_fifo_start),smc->hw.iop + 1204U);
  
#line 199 
  iowrite16((unsigned short)((int)smc->hw.fp.fifo.rx1_fifo_start),smc->hw.iop + 1212U);
  
#line 200 
  iowrite16((unsigned short)((int)smc->hw.fp.fifo.rx1_fifo_start),smc->hw.iop + 1208U);
  
#line 201 
  iowrite16((unsigned short)((int)((unsigned int)smc->hw.fp.fifo.tx_s_start + 65535U)),smc->hw.iop + 1164U);
  
#line 206 
  if ((unsigned int)smc->hw.fp.fifo.rx2_fifo_size != 0U) {
    
#line 207 
    iowrite16((unsigned short)((int)smc->hw.fp.fifo.rx2_fifo_start),smc->hw.iop + 1440U);
    
#line 208 
    iowrite16((unsigned short)((int)smc->hw.fp.fifo.rx2_fifo_start),smc->hw.iop + 1448U);
    
#line 209 
    iowrite16((unsigned short)((int)smc->hw.fp.fifo.rx2_fifo_start),smc->hw.iop + 1444U);
    
#line 210 
    iowrite16((unsigned short)((int)((unsigned int)smc->hw.fp.fifo.rbc_ram_end + 65535U)),smc->hw.iop + 1452U);
  }
  else {
    
#line 213 
    iowrite16((unsigned short)((int)((unsigned int)smc->hw.fp.fifo.rbc_ram_end + 65535U)),smc->hw.iop + 1440U);
    
#line 214 
    iowrite16((unsigned short)((int)((unsigned int)smc->hw.fp.fifo.rbc_ram_end + 65535U)),smc->hw.iop + 1448U);
    
#line 215 
    iowrite16((unsigned short)((int)((unsigned int)smc->hw.fp.fifo.rbc_ram_end + 65535U)),smc->hw.iop + 1444U);
    
#line 216 
    iowrite16((unsigned short)((int)((unsigned int)smc->hw.fp.fifo.rbc_ram_end + 65535U)),smc->hw.iop + 1452U);
  }
  
#line 218 
  return;
}


#line 223  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static void set_txptr(struct s_smc *smc)
{
  
#line 225 
  iowrite16((unsigned short)32,smc->hw.iop + 1028U);
  
#line 230 
  iowrite16((unsigned short)((int)smc->hw.fp.fifo.tx_a0_start),smc->hw.iop + 1252U);
  
#line 231 
  iowrite16((unsigned short)((int)smc->hw.fp.fifo.tx_a0_start),smc->hw.iop + 1236U);
  
#line 232 
  iowrite16((unsigned short)((int)smc->hw.fp.fifo.tx_a0_start),smc->hw.iop + 1220U);
  
#line 233 
  iowrite16((unsigned short)((int)((unsigned int)smc->hw.fp.fifo.rx2_fifo_start + 65535U)),smc->hw.iop + 1172U);
  
#line 238 
  if ((unsigned int)smc->hw.fp.fifo.tx_s_size != 0U) {
    
#line 239 
    iowrite16((unsigned short)((int)smc->hw.fp.fifo.tx_s_start),smc->hw.iop + 1248U);
    
#line 240 
    iowrite16((unsigned short)((int)smc->hw.fp.fifo.tx_s_start),smc->hw.iop + 1232U);
    
#line 241 
    iowrite16((unsigned short)((int)smc->hw.fp.fifo.tx_s_start),smc->hw.iop + 1216U);
    
#line 242 
    iowrite16((unsigned short)((int)((unsigned int)smc->hw.fp.fifo.tx_a0_start + 65535U)),smc->hw.iop + 1168U);
  }
  else {
    
#line 245 
    iowrite16((unsigned short)((int)((unsigned int)smc->hw.fp.fifo.tx_a0_start + 65535U)),smc->hw.iop + 1248U);
    
#line 246 
    iowrite16((unsigned short)((int)((unsigned int)smc->hw.fp.fifo.tx_a0_start + 65535U)),smc->hw.iop + 1232U);
    
#line 247 
    iowrite16((unsigned short)((int)((unsigned int)smc->hw.fp.fifo.tx_a0_start + 65535U)),smc->hw.iop + 1216U);
    
#line 248 
    iowrite16((unsigned short)((int)((unsigned int)smc->hw.fp.fifo.tx_a0_start + 65535U)),smc->hw.iop + 1168U);
  }
  
#line 250 
  return;
}


#line 255  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static void init_rbc(struct s_smc *smc)
{
  u_short rbc_ram_addr;
  
#line 262 
  rbc_ram_addr = (unsigned short)((unsigned int)smc->hw.fp.fifo.rx2_fifo_start + 65535U);
  
#line 264 
  iowrite16((unsigned short)((int)rbc_ram_addr),smc->hw.iop + 1256U);
  
#line 265 
  iowrite16((unsigned short)((int)rbc_ram_addr),smc->hw.iop + 1224U);
  
#line 266 
  iowrite16((unsigned short)((int)rbc_ram_addr),smc->hw.iop + 1240U);
  
#line 267 
  iowrite16((unsigned short)((int)rbc_ram_addr),smc->hw.iop + 1176U);
  
#line 269 
  set_recvptr(smc);
  
#line 270 
  set_txptr(smc);
  
#line 271 
  return;
}


#line 276  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static void init_rx(struct s_smc *smc)
{
  struct s_smt_rx_queue *queue;
  
#line 283 
  queue = & smc->hw.fp.rx_q[0];
  
#line 283 
  smc->hw.fp.rx[0] = queue;
  
#line 284 
  queue->rx_bmu_ctl = smc->hw.iop + 112U;
  
#line 285 
  queue->rx_bmu_dsc = smc->hw.iop + 528U;
  
#line 290 
  queue = & smc->hw.fp.rx_q[1];
  
#line 290 
  smc->hw.fp.rx[1] = queue;
  
#line 291 
  queue->rx_bmu_ctl = smc->hw.iop + 116U;
  
#line 292 
  queue->rx_bmu_dsc = smc->hw.iop + 592U;
  
#line 293 
  return;
}


#line 298  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
void set_formac_tsync(struct s_smc *smc, long sync_bw)
{
  
#line 300 
  iowrite16((unsigned short)((int)((unsigned short)(- sync_bw >> 5))),smc->hw.iop + 1148U);
  
#line 301 
  return;
}


#line 306  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static void init_tx(struct s_smc *smc)
{
  struct s_smt_tx_queue *queue;
  
#line 313 
  queue = & smc->hw.fp.tx_q[0];
  
#line 313 
  smc->hw.fp.tx[0] = queue;
  
#line 314 
  queue->tx_bmu_ctl = smc->hw.iop + 124U;
  
#line 315 
  queue->tx_bmu_dsc = smc->hw.iop + 720U;
  
#line 318 
  set_formac_tsync(smc,smc->ess.sync_bw);
  
#line 324 
  queue = & smc->hw.fp.tx_q[1];
  
#line 324 
  smc->hw.fp.tx[1] = queue;
  
#line 325 
  queue->tx_bmu_ctl = smc->hw.iop + 120U;
  
#line 326 
  queue->tx_bmu_dsc = smc->hw.iop + 656U;
  
#line 329 
  llc_recover_tx(smc);
  
#line 330 
  return;
}


#line 332  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static void mac_counter_init(struct s_smc *smc)
{
  int i;
  u_long *ec;
  u_long *tmp;
  
#line 340 
  iowrite16((unsigned short)0,smc->hw.iop + 1284U);
  
#line 341 
  iowrite16((unsigned short)0,smc->hw.iop + 1288U);
  
#line 342 
  iowrite16((unsigned short)0,smc->hw.iop + 1292U);
  
#line 346 
  ec = (u_long *)(& smc->hw.fp.err_stats);
  
#line 347 
  i = 16;
  
#line 347 
  goto ldv_46562;
  ldv_46561: 
#line 348 
  ;
  
#line 348 
  tmp = ec;
  
#line 348 
  ec += 1;
  
#line 348 
  *tmp = 0UL;
  
#line 347 
  i -= 1;
  ldv_46562: 
#line 348 
  ;
  
#line 347 
  if (i != 0) 
#line 349 
              goto ldv_46561; else 
#line 352 
                                   goto ldv_46563;
  ldv_46563: 
#line 353 
  ;
  
#line 349 
  smc->mib.m[0].fddiMACRingOp_Ct = 0UL;
  
#line 350 
  return;
}


#line 355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static void set_formac_addr(struct s_smc *smc)
{
  
#line 357 
  long t_requ = (long)smc->mib.m[0].fddiMACT_Req;
  
#line 359 
  iowrite16((unsigned short)((int)my_said),smc->hw.iop + 1056U);
  
#line 360 
  iowrite16((unsigned short)(((int)((unsigned short)smc->hw.fddi_home_addr.a[4]) << 8U) + (int)((unsigned short)smc->hw.fddi_home_addr.a[5])),smc->hw.iop + 1068U);
  
#line 362 
  iowrite16((unsigned short)(((int)((unsigned short)smc->hw.fddi_home_addr.a[2]) << 8U) + (int)((unsigned short)smc->hw.fddi_home_addr.a[3])),smc->hw.iop + 1064U);
  
#line 364 
  iowrite16((unsigned short)(((int)((unsigned short)smc->hw.fddi_home_addr.a[0]) << 8U) + (int)((unsigned short)smc->hw.fddi_home_addr.a[1])),smc->hw.iop + 1060U);
  
#line 367 
  iowrite16((unsigned short)((int)my_sagp),smc->hw.iop + 1072U);
  
#line 369 
  iowrite16((unsigned short)(((int)((unsigned short)smc->hw.fp.group_addr.a[4]) << 8U) + (int)((unsigned short)smc->hw.fp.group_addr.a[5])),smc->hw.iop + 1084U);
  
#line 371 
  iowrite16((unsigned short)(((int)((unsigned short)smc->hw.fp.group_addr.a[2]) << 8U) + (int)((unsigned short)smc->hw.fp.group_addr.a[3])),smc->hw.iop + 1080U);
  
#line 373 
  iowrite16((unsigned short)(((int)((unsigned short)smc->hw.fp.group_addr.a[0]) << 8U) + (int)((unsigned short)smc->hw.fp.group_addr.a[1])),smc->hw.iop + 1076U);
  
#line 377 
  iowrite16((unsigned short)((int)((unsigned short)(t_requ >> 16))),smc->hw.iop + 1132U);
  
#line 378 
  iowrite16((unsigned short)((int)((unsigned short)t_requ)),smc->hw.iop + 1128U);
  
#line 379 
  return;
}


#line 381  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static void set_int(char *p, int l)
{
  
#line 383 
  *p = (char)(l >> 24);
  
#line 384 
  *(p + 1U) = (char)(l >> 16);
  
#line 385 
  *(p + 2U) = (char)(l >> 8);
  
#line 386 
  *(p + 3U) = (char)l;
  
#line 387 
  return;
}


#line 397  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static void copy_tx_mac(struct s_smc *smc, u_long td, struct fddi_mac *mac, unsigned int off, int len)
{
  int i;
  __le32 *p;
  {
    unsigned int tmp;
    
#line 407 
    unsigned int k = 10000U;
    
#line 407 
    goto ldv_46583;
    ldv_46582: 
#line 408 
    ;
    
#line 407 
    k -= 1U;
    ldv_46583: 
#line 408 
    ;
    
#line 407 
    tmp = ioread16(smc->hw.iop + 1092U);
    
#line 407 
    if ((tmp & 8U) != 0U) {
      
#line 407 
      if (k != 0U) 
#line 409 
                   goto ldv_46582; else 
#line 412 
                                        goto ldv_46584;
    }
    else 
#line 412 
         goto ldv_46584;
    ldv_46584: 
#line 413 
    ;
    
#line 407 
    if (k == 0U) 
#line 407 
                 printk("\001",130,(char *)(& write_mdr_warning)); else ;
  }
  
#line 408 
  iowrite16((unsigned short)((int)((unsigned short)off)),smc->hw.iop + 1268U);
  
#line 410 
  p = (__le32 *)mac;
  
#line 411 
  i = (len + 3) / 4;
  
#line 411 
  goto ldv_46586;
  ldv_46585: 
#line 412 
  ;
  
#line 412 
  if (i == 1) 
#line 414 
              iowrite16((unsigned short)48,smc->hw.iop + 1028U); else ;
  
#line 416 
  write_mdr(smc,(unsigned long)*p);
  
#line 417 
  p += 1;
  
#line 411 
  i -= 1;
  ldv_46586: 
#line 412 
  ;
  
#line 411 
  if (i != 0) 
#line 413 
              goto ldv_46585; else 
#line 416 
                                   goto ldv_46587;
  ldv_46587: 
#line 417 
  ;
  
#line 420 
  iowrite16((unsigned short)48,smc->hw.iop + 1028U);
  
#line 421 
  write_mdr(smc,td);
  
#line 422 
  return;
}


#line 446  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static void directed_beacon(struct s_smc *smc)
{
  __le32 a[2U];
  
#line 455 
  *((char *)(& a)) = (char)0;
  
#line 456 
  a[1] = 0U;
  
#line 457 
  memcpy((void *)(& a) + 1U,(void const *)(& smc->mib.m[0].fddiMACUpstreamNbr),6UL);
  {
    unsigned int tmp;
    
#line 459 
    unsigned int k = 10000U;
    
#line 459 
    goto ldv_46594;
    ldv_46593: 
#line 460 
    ;
    
#line 459 
    k -= 1U;
    ldv_46594: 
#line 460 
    ;
    
#line 459 
    tmp = ioread16(smc->hw.iop + 1092U);
    
#line 459 
    if ((tmp & 8U) != 0U) {
      
#line 459 
      if (k != 0U) 
#line 461 
                   goto ldv_46593; else 
#line 464 
                                        goto ldv_46595;
    }
    else 
#line 464 
         goto ldv_46595;
    ldv_46595: 
#line 465 
    ;
    
#line 459 
    if (k == 0U) 
#line 459 
                 printk("\001",130,(char *)(& write_mdr_warning)); else ;
  }
  
#line 461 
  iowrite16((unsigned short)((int)((unsigned int)smc->hw.fp.fifo.rbc_ram_start + 28U)),smc->hw.iop + 1268U);
  
#line 462 
  write_mdr(smc,(unsigned long)a[0]);
  
#line 463 
  iowrite16((unsigned short)48,smc->hw.iop + 1028U);
  
#line 464 
  write_mdr(smc,(unsigned long)a[1]);
  
#line 466 
  iowrite16((unsigned short)((int)((unsigned int)smc->hw.fp.fifo.rbc_ram_start + 24U)),smc->hw.iop + 1188U);
  
#line 467 
  return;
}


#line 475  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static void build_claim_beacon(struct s_smc *smc, u_long t_request)
{
  u_int td;
  int len;
  struct fddi_mac_sf *mac;
  struct fddi_addr tmp;
  
#line 484 
  len = 17;
  
#line 485 
  td = ((((unsigned int)len + 4294967295U) << 27) & 402653184U) | 1073741824U;
  
#line 486 
  mac = & smc->hw.fp.mac_sfb;
  
#line 487 
  mac->mac_fc = (unsigned char)195U;
  
#line 489 
  tmp = smc->hw.fddi_canon_addr;
  
#line 489 
  mac->mac_dest = tmp;
  
#line 489 
  mac->mac_source = tmp;
  
#line 491 
  set_int((char *)(& mac->mac_info),(int)t_request);
  
#line 493 
  copy_tx_mac(smc,(unsigned long)td,(struct fddi_mac *)mac,(unsigned int)((int)smc->hw.fp.fifo.rbc_ram_start + 8),len);
  
#line 496 
  iowrite16((unsigned short)((int)((unsigned int)smc->hw.fp.fifo.rbc_ram_start + 8U)),smc->hw.iop + 1184U);
  
#line 501 
  len = 17;
  
#line 502 
  td = ((((unsigned int)len + 4294967295U) << 27) & 402653184U) | 1073741824U;
  
#line 503 
  mac->mac_fc = (unsigned char)194U;
  
#line 504 
  mac->mac_source = smc->hw.fddi_canon_addr;
  
#line 505 
  mac->mac_dest = null_addr_0;
  
#line 506 
  set_int((char *)(& mac->mac_info),0);
  
#line 508 
  copy_tx_mac(smc,(unsigned long)td,(struct fddi_mac *)mac,(unsigned int)((int)smc->hw.fp.fifo.rbc_ram_start + 16),len);
  
#line 511 
  iowrite16((unsigned short)((int)((unsigned int)smc->hw.fp.fifo.rbc_ram_start + 16U)),smc->hw.iop + 1188U);
  
#line 517 
  len = 23;
  
#line 518 
  td = ((((unsigned int)len + 4294967295U) << 27) & 402653184U) | 1073741824U;
  
#line 519 
  mac->mac_fc = (unsigned char)194U;
  
#line 520 
  mac->mac_source = smc->hw.fddi_canon_addr;
  
#line 521 
  mac->mac_dest = dbeacon_multi;
  
#line 522 
  set_int((char *)(& mac->mac_info),16777216);
  
#line 523 
  set_int((char *)(& mac->mac_info) + 4U,0);
  
#line 524 
  set_int((char *)(& mac->mac_info) + 8U,0);
  
#line 526 
  copy_tx_mac(smc,(unsigned long)td,(struct fddi_mac *)mac,(unsigned int)((int)smc->hw.fp.fifo.rbc_ram_start + 24),len);
  
#line 530 
  iowrite16((unsigned short)((int)((unsigned int)smc->hw.fp.fifo.rx1_fifo_start + 65535U)),smc->hw.iop + 1160U);
  
#line 532 
  iowrite16((unsigned short)0,smc->hw.iop + 1192U);
  
#line 533 
  iowrite16((unsigned short)0,smc->hw.iop + 1196U);
  
#line 534 
  return;
}


#line 536  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static void formac_rcv_restart(struct s_smc *smc)
{
  unsigned int tmp;
  
#line 539 
  ;
  
#line 539 
  tmp = ioread16(smc->hw.iop + 1088U);
  
#line 539 
  ;
  
#line 539 
  iowrite16((unsigned short)((int)(((unsigned int)((unsigned short)tmp) & 63695U) | (unsigned int)smc->hw.fp.rx_mode)),smc->hw.iop + 1088U);
  
#line 541 
  iowrite16((unsigned short)32,smc->hw.iop + 1024U);
  
#line 542 
  return;
}


#line 544  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
void formac_tx_restart(struct s_smc *smc)
{
  
#line 546 
  iowrite16((unsigned short)17,smc->hw.iop + 1024U);
  
#line 547 
  iowrite16((unsigned short)18,smc->hw.iop + 1024U);
  
#line 548 
  return;
}


#line 550  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static void enable_formac(struct s_smc *smc)
{
  
#line 553 
  iowrite16((unsigned short)26623,smc->hw.iop + 1040U);
  
#line 554 
  iowrite16((unsigned short)52476,smc->hw.iop + 1044U);
  
#line 555 
  iowrite16((unsigned short)58975,smc->hw.iop + 1048U);
  
#line 556 
  iowrite16((unsigned short)15241,smc->hw.iop + 1052U);
  
#line 557 
  iowrite16((unsigned short)59391,smc->hw.iop + 1420U);
  
#line 558 
  iowrite16((unsigned short)65523,smc->hw.iop + 1424U);
  
#line 559 
  return;
}


#line 641  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static void disable_formac(struct s_smc *smc)
{
  
#line 644 
  iowrite16((unsigned short)65535,smc->hw.iop + 1040U);
  
#line 645 
  iowrite16((unsigned short)65535,smc->hw.iop + 1044U);
  
#line 646 
  iowrite16((unsigned short)65535,smc->hw.iop + 1048U);
  
#line 647 
  iowrite16((unsigned short)65535,smc->hw.iop + 1052U);
  
#line 648 
  iowrite16((unsigned short)65535,smc->hw.iop + 1420U);
  
#line 649 
  iowrite16((unsigned short)65535,smc->hw.iop + 1424U);
  
#line 650 
  return;
}


#line 653  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static void mac_ring_up(struct s_smc *smc, int up_0)
{
  
#line 655 
  if (up_0 != 0) {
    
#line 656 
    formac_rcv_restart(smc);
    
#line 657 
    smc->hw.mac_ring_is_up = (unsigned short)1U;
    
#line 658 
    llc_restart_tx(smc);
  }
  else {
    unsigned int tmp;
    
#line 662 
    ;
    
#line 662 
    tmp = ioread16(smc->hw.iop + 1088U);
    
#line 662 
    iowrite16((unsigned short)((int)(((unsigned int)((unsigned short)tmp) & 63743U) | 1024U)),smc->hw.iop + 1088U);
    
#line 665 
    iowrite16((unsigned short)16,smc->hw.iop + 1028U);
    
#line 667 
    smc->hw.mac_ring_is_up = (unsigned short)0U;
  }
  
#line 669 
  return;
}


#line 680  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
void mac2_irq(struct s_smc *smc, u_short code_s2u, u_short code_s2l)
{
  u_short change_s2l;
  u_short change_s2u;
  
#line 688 
  if (((int)code_s2u & 85) != 0) 
#line 689 
                                 queue_event(smc,3,18);
  else 
    
#line 691 
    if (((int)code_s2l & 4096) != 0) 
#line 692 
                                     queue_event(smc,3,18); else ;
  
#line 698 
  change_s2l = (unsigned short)((int)smc->hw.fp.s2l ^ (int)code_s2l);
  
#line 699 
  change_s2u = (unsigned short)((int)smc->hw.fp.s2u ^ (int)code_s2u);
  
#line 701 
  if ((int)change_s2l < 0 || ((unsigned int)smc->hw.mac_ring_is_up == 0U && (int)code_s2l < 0)) {
    
#line 703 
    if ((int)code_s2l < 0) {
      
#line 704 
      mac_ring_up(smc,1);
      
#line 705 
      queue_event(smc,3,1);
      
#line 706 
      smc->mib.m[0].fddiMACRingOp_Ct += 1UL;
    }
    else {
      
#line 709 
      mac_ring_up(smc,0);
      
#line 710 
      queue_event(smc,3,2);
    }
    
#line 712 
    goto mac2_end;
  }
  else ;
  
#line 714 
  if (((int)code_s2l & 512) != 0) 
#line 715 
                                  smc->mib.m[0].fddiMACNotCopied_Ct += 1UL; else ;
  
#line 717 
  if (((int)code_s2u & 6144) != 0) {
    
#line 719 
    smc->hw.mac_ct.mac_r_restart_counter += 1UL;
    
#line 721 
    smt_stat_counter(smc,1);
  }
  else ;
  
#line 724 
  if (((int)code_s2u & 1) != 0) 
#line 725 
                                queue_event(smc,3,4); else ;
  
#line 726 
  if (((int)code_s2u & 2) != 0) 
#line 727 
                                queue_event(smc,3,3); else ;
  
#line 728 
  if ((((int)change_s2u & (int)code_s2u) & 8) != 0) ; else ;
  
#line 731 
  if (((int)code_s2u & 32) != 0 && ((int)code_s2l & 4) == 0) 
#line 736 
                                                             queue_event(smc,3,5); else ;
  
#line 738 
  if (((int)code_s2l & 4) != 0) 
#line 746 
                                queue_event(smc,3,7); else ;
  
#line 748 
  if ((((int)change_s2u & (int)code_s2u) & 16) != 0) ; else ;
  
#line 751 
  if (((int)code_s2l & 1024) != 0 || ((int)code_s2l & 2) != 0) 
#line 753 
                                                               queue_event(smc,3,6); else ;
  
#line 754 
  if (((int)code_s2l & 16384) != 0) {
    
#line 760 
    smc->r.dup_addr_test = (unsigned char)2U;
    
#line 761 
    queue_event(smc,3,10);
  }
  else ;
  
#line 763 
  if (((int)code_s2u & 4) != 0) 
#line 764 
                                smc->hw.fp.err_stats.err_bec_stat += 1UL; else ;
  
#line 765 
  if (((int)code_s2u & 64) != 0) 
#line 766 
                                 smc->hw.fp.err_stats.err_clm_stat += 1UL; else ;
  
#line 767 
  if (((int)code_s2l & 2048) != 0) 
#line 768 
                                   smc->mib.m[0].fddiMACTvxExpired_Ct += 1UL; else ;
  
#line 769 
  if (((int)code_s2u & 68) != 0) {
    
#line 770 
    if ((int)change_s2l >= 0 && (int)smc->hw.fp.s2l < 0) {
      
#line 771 
      mac_ring_up(smc,0);
      
#line 772 
      queue_event(smc,3,2);
      
#line 774 
      mac_ring_up(smc,1);
      
#line 775 
      queue_event(smc,3,1);
      
#line 776 
      smc->mib.m[0].fddiMACRingOp_Ct += 1UL;
    }
    else ;
  }
  else ;
  
#line 779 
  if (((int)code_s2l & 128) != 0) 
#line 780 
                                  smc->hw.fp.err_stats.err_phinv += 1UL; else ;
  
#line 781 
  if (((int)code_s2l & 8) != 0) 
#line 782 
                                smc->hw.fp.err_stats.err_sifg_det += 1UL; else ;
  
#line 783 
  if (((int)code_s2l & 4096) != 0) 
#line 784 
                                   smc->hw.fp.err_stats.err_tkiss += 1UL; else ;
  
#line 785 
  if (((int)code_s2l & 8192) != 0) 
#line 786 
                                   smc->hw.fp.err_stats.err_tkerr += 1UL; else ;
  
#line 787 
  if (((int)code_s2l & 16) != 0) 
#line 788 
                                 smc->mib.m[0].fddiMACFrame_Ct += 65536UL; else ;
  
#line 789 
  if (((int)code_s2l & 32) != 0) 
#line 790 
                                 smc->mib.m[0].fddiMACError_Ct += 65536UL; else ;
  
#line 791 
  if (((int)code_s2l & 64) != 0) 
#line 792 
                                 smc->mib.m[0].fddiMACLost_Ct += 65536UL; else ;
  
#line 793 
  if (((int)code_s2u & 128) != 0) 
#line 794 
                                  printk("\001",114,(char *)"ST2U.FM_SERRSF error in special frame"); else ;
  mac2_end: 
#line 796 
  ;
  
#line 798 
  smc->hw.fp.s2l = code_s2l;
  
#line 799 
  smc->hw.fp.s2u = code_s2u;
  
#line 800 
  iowrite16((unsigned short)58975,smc->hw.iop + 1048U);
  
#line 801 
  return;
}


#line 806  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
void mac3_irq(struct s_smc *smc, u_short code_s3u, u_short code_s3l)
{
  
#line 810 
  if (((int)code_s3u & 6144) != 0) {
    
#line 812 
    smc->hw.mac_ct.mac_r_restart_counter += 1UL;
    
#line 813 
    smt_stat_counter(smc,1);
  }
  else ;
  
#line 817 
  if (((int)code_s3u & 8) != 0) 
#line 818 
                                printk("\001",115,(char *)"ST3L: parity error in receive queue 2"); else ;
  
#line 820 
  if (((int)code_s3u & 4) != 0) 
#line 821 
                                printk("\001",116,(char *)"ST3L: parity error in receive queue 1"); else ;
  
#line 822 
  return;
}


#line 829  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static void formac_offline(struct s_smc *smc)
{
  unsigned int tmp;
  unsigned int tmp_0;
  
#line 831 
  iowrite16((unsigned short)16,smc->hw.iop + 1028U);
  
#line 834 
  ;
  
#line 834 
  tmp = ioread16(smc->hw.iop + 1088U);
  
#line 834 
  iowrite16((unsigned short)((int)(((unsigned int)((unsigned short)tmp) & 63743U) | 1024U)),smc->hw.iop + 1088U);
  
#line 837 
  ;
  
#line 837 
  tmp_0 = ioread16(smc->hw.iop + 1088U);
  
#line 837 
  iowrite16((unsigned short)((int)((unsigned short)tmp_0) & 36863),smc->hw.iop + 1088U);
  
#line 839 
  disable_formac(smc);
  
#line 840 
  smc->hw.mac_ring_is_up = (unsigned short)0U;
  
#line 841 
  smc->hw.hw_state = (unsigned short)0U;
  
#line 842 
  return;
}


#line 847  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static void formac_online(struct s_smc *smc)
{
  unsigned int tmp;
  
#line 849 
  enable_formac(smc);
  
#line 850 
  ;
  
#line 850 
  tmp = ioread16(smc->hw.iop + 1088U);
  
#line 850 
  ;
  
#line 850 
  iowrite16((unsigned short)((int)((((unsigned int)((unsigned short)tmp) & 34895U) | (unsigned int)smc->hw.fp.rx_mode) | 12416U)),smc->hw.iop + 1088U);
  
#line 851 
  return;
}


#line 857  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
int init_fplus(struct s_smc *smc)
{
  u_short tmp;
  int tmp_0;
  
#line 859 
  smc->hw.fp.nsa_mode = (unsigned short)512U;
  
#line 860 
  smc->hw.fp.rx_mode = (unsigned short)0U;
  
#line 861 
  smc->hw.fp.group_addr = fddi_broadcast;
  
#line 862 
  smc->hw.fp.func_addr = 0UL;
  
#line 863 
  smc->hw.fp.frselreg_init = (unsigned short)0U;
  
#line 865 
  init_driver_fplus(smc);
  
#line 866 
  if ((unsigned int)smc->s.sas == 0U) 
#line 867 
                                      smc->hw.fp.mdr3init = (unsigned short)((unsigned int)smc->hw.fp.mdr3init | 256U); else ;
  
#line 869 
  smc->hw.mac_ct.mac_nobuf_counter = 0UL;
  
#line 870 
  smc->hw.mac_ct.mac_r_restart_counter = 0UL;
  
#line 872 
  smc->hw.fp.fm_st1u = smc->hw.iop + 16U;
  
#line 873 
  smc->hw.fp.fm_st1l = smc->hw.iop + 20U;
  
#line 874 
  smc->hw.fp.fm_st2u = smc->hw.iop + 24U;
  
#line 875 
  smc->hw.fp.fm_st2l = smc->hw.iop + 28U;
  
#line 876 
  smc->hw.fp.fm_st3u = smc->hw.iop + 52U;
  
#line 877 
  smc->hw.fp.fm_st3l = smc->hw.iop + 56U;
  
#line 879 
  tmp = (unsigned short)0U;
  
#line 879 
  smc->hw.fp.s2u = tmp;
  
#line 879 
  smc->hw.fp.s2l = tmp;
  
#line 880 
  smc->hw.mac_ring_is_up = (unsigned short)0U;
  
#line 882 
  mac_counter_init(smc);
  
#line 885 
  smc->hw.mac_pa.t_neg = 0UL;
  
#line 886 
  smc->hw.mac_pa.t_pri = 0UL;
  
#line 889 
  mac_do_pci_fix(smc);
  
#line 891 
  tmp_0 = init_mac(smc,1);
  
#line 891 
  return tmp_0;
}


#line 895  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static int init_mac(struct s_smc *smc, int all)
{
  int __retres;
  u_short t_max;
  u_short x;
  
#line 898 
  u_long time = 0UL;
  
#line 903 
  iowrite16((unsigned short)0,smc->hw.iop + 1088U);
  
#line 904 
  set_formac_addr(smc);
  
#line 905 
  iowrite16((unsigned short)4096,smc->hw.iop + 1088U);
  
#line 907 
  iowrite16((unsigned short)((int)smc->hw.fp.mdr2init),smc->hw.iop + 1152U);
  
#line 909 
  if (all != 0) 
#line 910 
                init_ram(smc);
  else {
    
#line 916 
    iowrite8((unsigned char)16,smc->hw.iop + 4U);
    
#line 917 
    time = hwt_quick_read(smc);
  }
  
#line 923 
  smt_split_up_fifo(smc);
  
#line 925 
  init_tx(smc);
  
#line 926 
  init_rx(smc);
  
#line 927 
  init_rbc(smc);
  
#line 929 
  build_claim_beacon(smc,smc->mib.m[0].fddiMACT_Req);
  
#line 933 
  iowrite16((unsigned short)57344,smc->hw.iop + 1156U);
  
#line 936 
  iowrite16((unsigned short)((int)((unsigned int)smc->hw.fp.rx_mode | 128U)),smc->hw.iop + 1088U);
  
#line 937 
  iowrite16((unsigned short)((int)smc->hw.fp.mdr2init),smc->hw.iop + 1152U);
  
#line 938 
  iowrite16((unsigned short)((int)smc->hw.fp.mdr3init),smc->hw.iop + 1408U);
  
#line 939 
  iowrite16((unsigned short)((int)smc->hw.fp.frselreg_init),smc->hw.iop + 1300U);
  
#line 947 
  t_max = (unsigned short)(smc->mib.m[0].fddiMACT_Max / 32UL);
  
#line 948 
  x = (unsigned short)((unsigned int)t_max / 39U);
  
#line 949 
  x = (unsigned short)((unsigned int)x * 39U);
  
#line 950 
  if ((unsigned int)t_max == 65534U || (int)t_max - (int)x == 22) 
#line 951 
                                                                  t_max = (u_short)((int)t_max - 1); else ;
  
#line 952 
  iowrite16((unsigned short)((int)t_max),smc->hw.iop + 1104U);
  
#line 955 
  if (smc->mib.m[0].fddiMACTvxValue <= 18446744073709486615UL) 
#line 956 
                                                               iowrite16((unsigned short)2,smc->hw.iop + 1108U); else 
                                                                    
#line 958 
                                                                    iowrite16((unsigned short)((int)((unsigned short)(smc->mib.m[0].fddiMACTvxValue / 255UL)) & 255),smc->hw.iop + 1108U);
  
#line 962 
  iowrite16((unsigned short)17,smc->hw.iop + 1024U);
  
#line 963 
  iowrite16((unsigned short)18,smc->hw.iop + 1024U);
  
#line 964 
  iowrite16((unsigned short)32,smc->hw.iop + 1024U);
  
#line 967 
  iowrite16((unsigned short)65535,smc->hw.iop + 1456U);
  
#line 969 
  rtm_init(smc);
  
#line 971 
  if (all == 0) {
    
#line 975 
    hwt_wait_time(smc,time,125000L);
    
#line 976 
    iowrite32(1398016U,smc->hw.iop + 112U);
    
#line 977 
    iowrite32(1398016U,smc->hw.iop + 120U);
    
#line 978 
    iowrite32(1398016U,smc->hw.iop + 124U);
    
#line 979 
    iowrite8((unsigned char)32,smc->hw.iop + 4U);
    
#line 980 
    iowrite32(2796032U,smc->hw.iop + 112U);
    
#line 981 
    iowrite32(2796032U,smc->hw.iop + 120U);
    
#line 982 
    iowrite32(2796032U,smc->hw.iop + 124U);
    
#line 983 
    if (smc->hw.hw_is_64bit == 0) {
      
#line 984 
      iowrite32(24U,smc->hw.iop + 544U);
      
#line 985 
      iowrite32(24U,smc->hw.iop + 672U);
      
#line 986 
      iowrite32(24U,smc->hw.iop + 736U);
    }
    else ;
    
#line 988 
    smc->hw.hw_state = (unsigned short)0U;
    
#line 989 
    mac_drv_repair_descr(smc);
  }
  else ;
  
#line 991 
  smc->hw.hw_state = (unsigned short)1U;
  
#line 993 
  __retres = 0;
  
#line 993 
  return __retres;
}


#line 1000  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
void config_mux(struct s_smc *smc, int mux)
{
  unsigned int tmp;
  
#line 1002 
  plc_config_mux(smc,mux);
  
#line 1004 
  ;
  
#line 1004 
  tmp = ioread16(smc->hw.iop + 1088U);
  
#line 1004 
  iowrite16((unsigned short)((int)((unsigned int)((unsigned short)tmp) | 128U)),smc->hw.iop + 1088U);
  
#line 1005 
  return;
}


#line 1014  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
void sm_mac_check_beacon_claim(struct s_smc *smc)
{
  
#line 1017 
  iowrite16((unsigned short)58880,smc->hw.iop + 1048U);
  
#line 1019 
  formac_rcv_restart(smc);
  
#line 1020 
  process_receive(smc);
  
#line 1021 
  return;
}


#line 1027  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
void sm_ma_control(struct s_smc *smc, int mode)
{
  
#line 1029 
  switch (mode) {
    case 5: 
#line 1030 
    ;
    
#line 1032 
    formac_offline(smc);
    
#line 1033 
    goto ldv_46660;
    case 0: 
#line 1034 
    ;
    
#line 1035 
    init_mac(smc,0);
    
#line 1036 
    goto ldv_46660;
    case 1: 
#line 1037 
    ;
    
#line 1038 
    formac_online(smc);
    
#line 1039 
    goto ldv_46660;
    case 3: 
#line 1040 
    ;
    
#line 1041 
    directed_beacon(smc);
    
#line 1042 
    goto ldv_46660;
    case 4: 
#line 1043 
    ;
    
#line 1047 
    goto ldv_46660;
  }
  ldv_46660: 
#line 1049 
  ;
  
#line 1050 
  return;
}


#line 1051  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
int sm_mac_get_tx_state(struct s_smc *smc)
{
  int __retres;
  unsigned int tmp;
  
#line 1053 
  tmp = ioread16(smc->hw.iop + 1092U);
  
#line 1053 
  __retres = (int)(tmp >> 4) & 7;
  
#line 1053 
  return __retres;
}


#line 1060  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static struct s_fpmc *mac_get_mc_table(struct s_smc *smc, struct fddi_addr *user, struct fddi_addr *own, int del, int can)
{
  struct s_fpmc *__retres;
  struct s_fpmc *tb;
  struct s_fpmc *slot;
  u_char *p;
  int i;
  int tmp_4;
  bool tmp_3;
  
#line 1073 
  *own = *user;
  
#line 1074 
  if (can != 0) {
    int tmp_2;
    
#line 1075 
    p = (u_char *)(& own->a);
    
#line 1076 
    i = 0;
    
#line 1076 
    goto ldv_46684;
    ldv_46683: 
#line 1077 
    ;
    {
      int tmp_1;
      
#line 1077 
      unsigned char __x = *p;
      
#line 1077 
      if (0 != 0) {
        unsigned char tmp;
        {
          
#line 1077 
          unsigned char __x_0 = __x_0;
          
#line 1077 
          __x_0 = (unsigned char)(((int)__x_0 >> 4) | ((int)__x_0 << 4));
          
#line 1077 
          __x_0 = (unsigned char)((((int)__x_0 >> 2) & 51) | (((int)__x_0 << 2) & -52));
          
#line 1077 
          __x_0 = (unsigned char)((((int)__x_0 >> 1) & 85) | (((int)__x_0 << 1) & -86));
          
#line 1077 
          tmp = __x_0;
        }
        
#line 1077 
        tmp_1 = (int)tmp;
      }
      else {
        unsigned char tmp_0;
        
#line 1077 
        tmp_0 = __bitrev8((unsigned char)((int)__x));
        
#line 1077 
        tmp_1 = (int)tmp_0;
      }
      
#line 1077 
      tmp_2 = tmp_1;
    }
    
#line 1077 
    *p = (unsigned char)tmp_2;
    
#line 1076 
    i += 1;
    
#line 1076 
    p += 1;
    ldv_46684: 
#line 1077 
    ;
    
#line 1076 
    if (i <= 5) 
#line 1078 
                goto ldv_46683; else 
#line 1081 
                                     goto ldv_46685;
    ldv_46685: 
#line 1082 
    ;
  }
  else ;
  
#line 1079 
  slot = (struct s_fpmc *)0;
  
#line 1080 
  i = 0;
  
#line 1080 
  tb = (struct s_fpmc *)(& smc->hw.fp.mc.table);
  
#line 1080 
  goto ldv_46688;
  ldv_46687: 
#line 1081 
  ;
  
#line 1081 
  if ((unsigned int)tb->n == 0U) {
    
#line 1082 
    if (del == 0 && slot == (struct s_fpmc *)0) 
#line 1083 
                                                slot = tb; else ;
    
#line 1084 
    goto ldv_46686;
  }
  else ;
  
#line 1086 
  tmp_3 = ether_addr_equal((unsigned char const *)(& tb->a),(unsigned char const *)own);
  
#line 1086 
  if (tmp_3) 
#line 1086 
             tmp_4 = 0; else 
#line 1086 
                             tmp_4 = 1;
  
#line 1086 
  if (tmp_4) 
#line 1087 
             goto ldv_46686; else ;
  
#line 1088 
  __retres = tb;
  
#line 1088 
  goto return_label;
  ldv_46686: 
#line 1089 
  ;
  
#line 1080 
  i += 1;
  
#line 1080 
  tb += 1;
  ldv_46688: 
#line 1081 
  ;
  
#line 1080 
  if (i <= 31) 
#line 1082 
               goto ldv_46687; else 
#line 1085 
                                    goto ldv_46689;
  ldv_46689: 
#line 1086 
  ;
  
#line 1090 
  __retres = slot;
  return_label: 
#line 1090 
                return __retres;
}


#line 1104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
void mac_clear_multicast(struct s_smc *smc)
{
  struct s_fpmc *tb;
  int i;
  
#line 1109 
  smc->hw.fp.os_slots_used = 0;
  
#line 1111 
  i = 0;
  
#line 1111 
  tb = (struct s_fpmc *)(& smc->hw.fp.mc.table);
  
#line 1111 
  goto ldv_46696;
  ldv_46695: 
#line 1112 
  ;
  
#line 1112 
  if ((unsigned int)tb->perm == 0U) 
#line 1113 
                                    tb->n = (unsigned char)0U; else ;
  
#line 1111 
  i += 1;
  
#line 1111 
  tb += 1;
  ldv_46696: 
#line 1112 
  ;
  
#line 1111 
  if (i <= 31) 
#line 1113 
               goto ldv_46695; else 
#line 1116 
                                    goto ldv_46697;
  ldv_46697: 
#line 1117 
  ;
  
#line 1118 
  return;
}


#line 1146  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
int mac_add_multicast(struct s_smc *smc, struct fddi_addr *addr, int can)
{
  int __retres;
  struct fddi_addr own;
  struct s_fpmc *tb;
  
#line 1154 
  if ((can & 128) != 0) {
    
#line 1155 
    if (smc->hw.fp.smt_slots_used > 3) {
      
#line 1156 
      __retres = 1;
      
#line 1156 
      goto return_label;
    }
    else ;
  }
  else 
    
#line 1160 
    if (smc->hw.fp.os_slots_used > 27) {
      
#line 1161 
      __retres = 1;
      
#line 1161 
      goto return_label;
    }
    else ;
  
#line 1168 
  tb = mac_get_mc_table(smc,addr,& own,0,can & -129);
  
#line 1168 
  if (tb == (struct s_fpmc *)0) {
    
#line 1169 
    __retres = 1;
    
#line 1169 
    goto return_label;
  }
  else ;
  
#line 1170 
  tb->n = (u_char)((int)tb->n + 1);
  
#line 1171 
  tb->a = own;
  
#line 1172 
  tb->perm = (unsigned char)((unsigned int)((unsigned char)(can >> 7)) & 1U);
  
#line 1174 
  if ((can & 128) != 0) 
#line 1175 
                        smc->hw.fp.smt_slots_used += 1; else 
#line 1177 
                                                             smc->hw.fp.os_slots_used += 1;
  
#line 1179 
  __retres = 0;
  return_label: 
#line 1179 
                return __retres;
}


#line 1200  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
void mac_update_multicast(struct s_smc *smc)
{
  struct s_fpmc *tb;
  u_char *fu;
  int i;
  
#line 1209 
  iowrite16((unsigned short)0,smc->hw.iop + 1728U);
  
#line 1214 
  if (smc->hw.fp.func_addr != 0UL) {
    
#line 1215 
    fu = (u_char *)(& smc->hw.fp.func_addr);
    
#line 1216 
    iowrite16((unsigned short)65535,smc->hw.iop + 1776U);
    
#line 1217 
    iowrite16((unsigned short)(~ (((int)((unsigned short)*fu) << 8U) + (int)((unsigned short)*(fu + 1U)))),smc->hw.iop + 1784U);
    
#line 1218 
    iowrite16((unsigned short)(~ (((int)((unsigned short)*(fu + 2U)) << 8U) + (int)((unsigned short)*(fu + 3U)))),smc->hw.iop + 1792U);
    
#line 1219 
    iowrite16((unsigned short)3,smc->hw.iop + 1800U);
    
#line 1220 
    iowrite16((unsigned short)49152,smc->hw.iop + 1752U);
    
#line 1221 
    iowrite16((unsigned short)0,smc->hw.iop + 1760U);
    
#line 1222 
    iowrite16((unsigned short)0,smc->hw.iop + 1768U);
    
#line 1223 
    iowrite16((unsigned short)1,smc->hw.iop + 1728U);
  }
  else ;
  
#line 1229 
  iowrite16((unsigned short)65535,smc->hw.iop + 1792U);
  
#line 1230 
  iowrite16((unsigned short)65535,smc->hw.iop + 1784U);
  
#line 1231 
  iowrite16((unsigned short)65535,smc->hw.iop + 1776U);
  
#line 1232 
  iowrite16((unsigned short)3,smc->hw.iop + 1800U);
  
#line 1234 
  i = 0;
  
#line 1234 
  tb = (struct s_fpmc *)(& smc->hw.fp.mc.table);
  
#line 1234 
  goto ldv_46716;
  ldv_46715: 
#line 1235 
  ;
  
#line 1235 
  if ((unsigned int)tb->n != 0U) {
    {
      unsigned int tmp;
      
#line 1236 
      unsigned int k = 10U;
      
#line 1236 
      goto ldv_46713;
      ldv_46712: 
#line 1237 
      ;
      
#line 1236 
      k -= 1U;
      ldv_46713: 
#line 1237 
      ;
      
#line 1236 
      tmp = ioread16(smc->hw.iop + 1736U);
      
#line 1236 
      if ((tmp & 32768U) == 0U) {
        
#line 1236 
        if (k != 0U) 
#line 1238 
                     goto ldv_46712; else 
#line 1241 
                                          goto ldv_46714;
      }
      else 
#line 1241 
           goto ldv_46714;
      ldv_46714: 
#line 1242 
      ;
      
#line 1236 
      if (k == 0U) 
#line 1236 
                   printk("\001",131,(char *)(& cam_warning)); else ;
    }
    
#line 1241 
    iowrite16((unsigned short)(((int)((unsigned short)tb->a.a[0]) << 8U) + (int)((unsigned short)tb->a.a[1])),smc->hw.iop + 1752U);
    
#line 1243 
    iowrite16((unsigned short)(((int)((unsigned short)tb->a.a[2]) << 8U) + (int)((unsigned short)tb->a.a[3])),smc->hw.iop + 1760U);
    
#line 1245 
    iowrite16((unsigned short)(((int)((unsigned short)tb->a.a[4]) << 8U) + (int)((unsigned short)tb->a.a[5])),smc->hw.iop + 1768U);
    
#line 1247 
    iowrite16((unsigned short)1,smc->hw.iop + 1728U);
  }
  else ;
  
#line 1234 
  i += 1;
  
#line 1234 
  tb += 1;
  ldv_46716: 
#line 1235 
  ;
  
#line 1234 
  if (i <= 31) 
#line 1236 
               goto ldv_46715; else 
#line 1239 
                                    goto ldv_46717;
  ldv_46717: 
#line 1240 
  ;
  
#line 1241 
  return;
}


#line 1276  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
void mac_set_rx_mode(struct s_smc *smc, int mode)
{
  unsigned int tmp;
  
#line 1278 
  switch (mode) {
    case 1: 
#line 1279 
    ;
    
#line 1280 
    smc->hw.fp.rx_prom = (unsigned short)((unsigned int)smc->hw.fp.rx_prom | 2U);
    
#line 1281 
    goto ldv_46723;
    case 2: 
#line 1282 
    ;
    
#line 1283 
    smc->hw.fp.rx_prom = (unsigned short)((unsigned int)smc->hw.fp.rx_prom & 65533U);
    
#line 1284 
    goto ldv_46723;
    case 3: 
#line 1285 
    ;
    
#line 1286 
    smc->hw.fp.rx_prom = (unsigned short)((unsigned int)smc->hw.fp.rx_prom | 1U);
    
#line 1287 
    goto ldv_46723;
    case 4: 
#line 1288 
    ;
    
#line 1289 
    smc->hw.fp.rx_prom = (unsigned short)((unsigned int)smc->hw.fp.rx_prom & 65534U);
    
#line 1290 
    goto ldv_46723;
    case 5: 
#line 1291 
    ;
    
#line 1292 
    smc->hw.fp.nsa_mode = (unsigned short)0U;
    
#line 1293 
    smc->hw.fp.rx_mode = (unsigned short)(((int)smc->hw.fp.rx_mode & -1793) | (int)smc->hw.fp.nsa_mode);
    
#line 1295 
    goto ldv_46723;
    case 6: 
#line 1296 
    ;
    
#line 1297 
    smc->hw.fp.nsa_mode = (unsigned short)512U;
    
#line 1298 
    smc->hw.fp.rx_mode = (unsigned short)(((int)smc->hw.fp.rx_mode & -1793) | (int)smc->hw.fp.nsa_mode);
    
#line 1300 
    goto ldv_46723;
  }
  ldv_46723: 
#line 1302 
  ;
  
#line 1302 
  if (((int)smc->hw.fp.rx_prom & 1) != 0) 
#line 1303 
                                          smc->hw.fp.rx_mode = (unsigned short)1536U;
  else 
    
#line 1305 
    if (((int)smc->hw.fp.rx_prom & 2) != 0) 
#line 1306 
                                            smc->hw.fp.rx_mode = (unsigned short)((unsigned int)smc->hw.fp.nsa_mode | 16U); else 
                                                                    
#line 1309 
                                                                    smc->hw.fp.rx_mode = smc->hw.fp.nsa_mode;
  
#line 1310 
  ;
  
#line 1310 
  tmp = ioread16(smc->hw.iop + 1088U);
  
#line 1310 
  ;
  
#line 1310 
  iowrite16((unsigned short)((int)(((unsigned int)((unsigned short)tmp) & 63695U) | (unsigned int)smc->hw.fp.rx_mode)),smc->hw.iop + 1088U);
  
#line 1311 
  mac_update_multicast(smc);
  
#line 1312 
  return;
}


#line 1332  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
void rtm_irq(struct s_smc *smc)
{
  unsigned int tmp;
  
#line 1334 
  iowrite16((unsigned short)1,smc->hw.iop + 328U);
  
#line 1335 
  tmp = ioread16(smc->hw.iop + 328U);
  
#line 1335 
  if ((tmp & 8U) != 0U) 
#line 1336 
                        iowrite16((unsigned short)5,smc->hw.iop + 1024U); else ;
  
#line 1342 
  iowrite16((unsigned short)4,smc->hw.iop + 328U);
  
#line 1343 
  return;
}


#line 1345  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static void rtm_init(struct s_smc *smc)
{
  
#line 1347 
  iowrite32(0U,smc->hw.iop + 320U);
  
#line 1348 
  iowrite16((unsigned short)4,smc->hw.iop + 328U);
  
#line 1349 
  return;
}


#line 1351  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
void rtm_set_timer(struct s_smc *smc)
{
  
#line 1358 
  iowrite32((unsigned int)smc->mib.a[0].fddiPATHT_Rmode,smc->hw.iop + 320U);
  
#line 1359 
  return;
}


#line 1361  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
static void smt_split_up_fifo(struct s_smc *smc)
{
  
#line 1393 
  switch (0) {
    case 0: 
#line 1394 
    ;
    
#line 1395 
    smc->hw.fp.fifo.rx1_fifo_size = (unsigned short)16351U;
    
#line 1396 
    smc->hw.fp.fifo.rx2_fifo_size = (unsigned short)0U;
    
#line 1397 
    goto ldv_46742;
    case 1: 
#line 1398 
    ;
    case 2: 
#line 1399 
    ;
    case 3: 
#line 1400 
    ;
    
#line 1401 
    smc->hw.fp.fifo.rx1_fifo_size = (unsigned short)14047U;
    
#line 1402 
    smc->hw.fp.fifo.rx2_fifo_size = (unsigned short)2304U;
    
#line 1403 
    goto ldv_46742;
    default: 
#line 1404 
    ;
    
#line 1405 
    smc->hw.fp.fifo.rx1_fifo_size = (unsigned short)16351U;
    
#line 1407 
    smc->hw.fp.fifo.rx2_fifo_size = (unsigned short)16384U;
    
#line 1409 
    goto ldv_46742;
  }
  ldv_46742: 
#line 1434 
  ;
  
#line 1434 
  if (smc->mib.a[0].fddiPATHSbaPayload != 0UL) 
#line 1436 
                                               smc->hw.fp.fifo.fifo_config_mode = (unsigned short)((unsigned int)((int)smc->hw.fp.fifo.fifo_config_mode | (int)((unsigned short)smc->mib.fddiESSSynchTxMode)) | 2U); else 
                                                                    
#line 1441 
                                                                    smc->hw.fp.fifo.fifo_config_mode = (unsigned short)((unsigned int)smc->hw.fp.fifo.fifo_config_mode & 65532U);
  
#line 1448 
  if (((int)smc->hw.fp.fifo.fifo_config_mode & 2) != 0) 
    
#line 1449 
    if (((int)smc->hw.fp.fifo.fifo_config_mode & 1) != 0) {
      
#line 1450 
      smc->hw.fp.fifo.tx_s_size = (unsigned short)14080U;
      
#line 1451 
      smc->hw.fp.fifo.tx_a0_size = (unsigned short)2304U;
    }
    else {
      
#line 1454 
      smc->hw.fp.fifo.tx_s_size = (unsigned short)8192U;
      
#line 1455 
      smc->hw.fp.fifo.tx_a0_size = (unsigned short)8192U;
    }
  else {
    
#line 1459 
    smc->hw.fp.fifo.tx_s_size = (unsigned short)0U;
    
#line 1460 
    smc->hw.fp.fifo.tx_a0_size = (unsigned short)16384U;
  }
  
#line 1463 
  smc->hw.fp.fifo.rx1_fifo_start = (unsigned short)((unsigned int)smc->hw.fp.fifo.rbc_ram_start + 33U);
  
#line 1465 
  smc->hw.fp.fifo.tx_s_start = (unsigned short)((int)smc->hw.fp.fifo.rx1_fifo_start + (int)smc->hw.fp.fifo.rx1_fifo_size);
  
#line 1467 
  smc->hw.fp.fifo.tx_a0_start = (unsigned short)((int)smc->hw.fp.fifo.tx_s_start + (int)smc->hw.fp.fifo.tx_s_size);
  
#line 1469 
  smc->hw.fp.fifo.rx2_fifo_start = (unsigned short)((int)smc->hw.fp.fifo.tx_a0_start + (int)smc->hw.fp.fifo.tx_a0_size);
  
#line 1471 
  return;
}


#line 1481  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/fddi/skfp/fplustm.c"
void formac_reinit_tx(struct s_smc *smc)
{
  
#line 1488 
  if ((unsigned int)smc->hw.fp.fifo.tx_s_size == 0U && smc->mib.a[0].fddiPATHSbaPayload != 0UL) 
    
#line 1489 
    init_mac(smc,0); else ;
  
#line 1490 
  return;
}


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_add(int i, atomic_t *v)
{
  
#line 23 
  v->counter += i;
  
#line 24 
  return;
}


#line 27  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_sub(int i, atomic_t *v)
{
  
#line 29 
  v->counter -= i;
  
#line 30 
  return;
}


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_sub_and_test(int i, atomic_t *v)
{
  int __retres;
  
#line 35 
  v->counter -= i;
  
#line 36 
  if (v->counter != 0) {
    
#line 37 
    __retres = 0;
    
#line 37 
    goto return_label;
  }
  else ;
  
#line 39 
  __retres = 1;
  return_label: 
#line 39 
                return __retres;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_inc(atomic_t *v)
{
  
#line 45 
  v->counter += 1;
  
#line 46 
  return;
}


#line 49  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_dec(atomic_t *v)
{
  
#line 51 
  v->counter -= 1;
  
#line 52 
  return;
}


#line 55  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_dec_and_test(atomic_t *v)
{
  int __retres;
  
#line 57 
  v->counter -= 1;
  
#line 58 
  if (v->counter != 0) {
    
#line 59 
    __retres = 0;
    
#line 59 
    goto return_label;
  }
  else ;
  
#line 61 
  __retres = 1;
  return_label: 
#line 61 
                return __retres;
}


#line 65  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_inc_and_test(atomic_t *v)
{
  int __retres;
  
#line 67 
  v->counter += 1;
  
#line 68 
  if (v->counter != 0) {
    
#line 69 
    __retres = 0;
    
#line 69 
    goto return_label;
  }
  else ;
  
#line 71 
  __retres = 1;
  return_label: 
#line 71 
                return __retres;
}


#line 75  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_add_return(int i, atomic_t *v)
{
  int __retres;
  
#line 77 
  v->counter += i;
  
#line 78 
  __retres = v->counter;
  
#line 78 
  return __retres;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_add_negative(int i, atomic_t *v)
{
  int __retres;
  
#line 84 
  v->counter += i;
  
#line 85 
  __retres = v->counter < 0;
  
#line 85 
  return __retres;
}


#line 89  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_inc_short(short *v)
{
  int __retres;
  
#line 91 
  *v = (short)((unsigned int)*v + 1U);
  
#line 92 
  __retres = (int)*v;
  
#line 92 
  return __retres;
}


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/device.h"
void *ldv_dev_get_drvdata(struct device const *dev);


#line 24 
int ldv_dev_set_drvdata(struct device *dev, void *data);


#line 30  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_xmalloc(size_t size);


#line 31 
void *ldv_xzalloc(size_t size);


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
struct ldv_list_element global_list = {.data = (void *)0, .next = (struct ldv_list_element *)0};

#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
__inline static ldv_list_ptr ldv_list_create(void *data)
{
  
#line 35 
  ldv_list_ptr list = (struct ldv_list_element *)0;
  
#line 37 
  list = (ldv_list_ptr)ldv_xmalloc(16UL);
  
#line 39 
  list->data = data;
  
#line 40 
  list->next = (struct ldv_list_element *)0;
  
#line 42 
  return list;
}


#line 45  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
__inline static void ldv_save_pointer(void *data)
{
  ldv_list_ptr element;
  ldv_list_ptr cached;
  
#line 50 
  if (global_list.data == (void *)0) {
    
#line 51 
    element = & global_list;
    
#line 52 
    element->data = data;
  }
  else {
    
#line 54 
    element = ldv_list_create(data);
    
#line 55 
    cached = global_list.next;
    
#line 56 
    global_list.next = element;
    
#line 57 
    element->next = cached;
  }
  
#line 60 
  return;
}


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
void *ldv_dev_get_drvdata(struct device const *dev)
{
  void *__retres;
  
#line 30 
  if (dev != (struct device const *)0 && dev->p != (struct device_private *)0) {
    
#line 31 
    __retres = (dev->p)->driver_data;
    
#line 31 
    goto return_label;
  }
  else ;
  
#line 33 
  __retres = (void *)0;
  return_label: 
#line 33 
                return __retres;
}


#line 42  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
int ldv_dev_set_drvdata(struct device *dev, void *data)
{
  int __retres;
  
#line 44 
  dev->p = (struct device_private *)ldv_xzalloc(8UL);
  
#line 45 
  ldv_save_pointer((void *)dev->p);
  
#line 46 
  (dev->p)->driver_data = data;
  
#line 48 
  __retres = 0;
  
#line 48 
  return __retres;
}


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_zalloc(size_t size);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/spi.c"
struct spi_master *ldv_spi_alloc_master(struct device *host, unsigned int size)
{
  struct spi_master *__retres;
  struct spi_master *master;
  
#line 27 
  master = (struct spi_master *)ldv_zalloc((unsigned long)size + 2192UL);
  
#line 29 
  if (master == (struct spi_master *)0) {
    
#line 30 
    __retres = (struct spi_master *)0;
    
#line 30 
    goto return_label;
  }
  else ;
  
#line 32 
  ldv_dev_set_drvdata(& master->dev,(void *)(master + 1U));
  
#line 34 
  __retres = master;
  return_label: 
#line 34 
                return __retres;
}


#line 27  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/err.h"
long ldv_is_err(void const *ptr);


#line 28 
long ldv_is_err_or_null(void const *ptr);


#line 29 
void *ldv_err_ptr(long error);


#line 30 
long ldv_ptr_err(void const *ptr);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/common.h"
void __VERIFIER_assume(int);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_is_err(void const *ptr)
{
  long __retres;
  
#line 23 
  __retres = (long)((unsigned long)ptr > 4294967295UL);
  
#line 23 
  return __retres;
}


#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
void *ldv_err_ptr(long error)
{
  void *__retres;
  
#line 28 
  __VERIFIER_assume(error < 0L);
  
#line 29 
  __retres = (void *)(4294967295L - error);
  
#line 29 
  return __retres;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_ptr_err(void const *ptr)
{
  long __retres;
  
#line 34 
  __VERIFIER_assume((unsigned long)ptr > 4294967295UL);
  
#line 35 
  __retres = (long)(4294967295UL - (unsigned long)ptr);
  
#line 35 
  return __retres;
}


#line 38  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_is_err_or_null(void const *ptr)
{
  long __retres;
  int tmp_0;
  
#line 40 
  if (ptr == (void const *)0) 
#line 40 
                              tmp_0 = 1;
  else {
    long tmp;
    
#line 40 
    tmp = ldv_is_err(ptr);
    
#line 40 
    if (tmp != 0L) 
#line 40 
                   tmp_0 = 1; else 
#line 40 
                                   tmp_0 = 0;
  }
  
#line 40 
  __retres = (long)tmp_0;
  
#line 40 
  return __retres;
}


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/panic.h"
void ldv_panic(void);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/kernel/panic.c"
void ldv_panic(void)
{
  
#line 23 
  __VERIFIER_assume(0);
  
#line 24 
  return;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.h"
void ldv_switch_to_interrupt_context(void);


#line 42 
void ldv_switch_to_process_context(void);


#line 50 
bool ldv_in_interrupt_context(void);


#line 112 
int ldv_post_init(int init_ret_val);


#line 132 
int ldv_post_probe(int probe_ret_val);


#line 133 
void ldv_check_return_value_probe(int);


#line 141 
int ldv_filter_err_code(int ret_val);


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
static bool __ldv_in_interrupt_context = (_Bool)0;

#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
void ldv_switch_to_interrupt_context(void)
{
  
#line 30 
  __ldv_in_interrupt_context = (_Bool)1;
  
#line 31 
  return;
}


#line 34  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
void ldv_switch_to_process_context(void)
{
  
#line 36 
  __ldv_in_interrupt_context = (_Bool)0;
  
#line 37 
  return;
}


#line 39  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
bool ldv_in_interrupt_context(void)
{
  
#line 41 
  return __ldv_in_interrupt_context;
}


#line 44  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
static int ldv_filter_positive_int(int val)
{
  
#line 46 
  __VERIFIER_assume(val <= 0);
  
#line 47 
  return val;
}


#line 54  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_post_init(int init_ret_val)
{
  int tmp;
  
#line 56 
  tmp = ldv_filter_positive_int(init_ret_val);
  
#line 56 
  return tmp;
}


#line 60  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_post_probe(int probe_ret_val)
{
  int tmp;
  
#line 62 
  ldv_check_return_value_probe(probe_ret_val);
  
#line 63 
  tmp = ldv_filter_positive_int(probe_ret_val);
  
#line 63 
  return tmp;
}


#line 67  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_filter_err_code(int ret_val)
{
  int tmp;
  
#line 69 
  tmp = ldv_filter_positive_int(ret_val);
  
#line 69 
  return tmp;
}


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kzalloc(size_t size, gfp_t flags);


#line 24 
void *ldv_kmalloc(size_t size, gfp_t flags);


#line 25 
void *ldv_kcalloc(size_t n, size_t size, gfp_t flags);


#line 26 
void *ldv_kmalloc_array(size_t n, size_t size, gfp_t flags);


#line 28 
void ldv_check_alloc_flags(gfp_t);


#line 29 
void ldv_after_alloc(void *);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_malloc(size_t size);


#line 24 
void *ldv_calloc(size_t nmemb, size_t size);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc(size_t size, gfp_t flags)
{
  void *res;
  
#line 25 
  ldv_check_alloc_flags(flags);
  
#line 26 
  res = ldv_malloc(size);
  
#line 27 
  ldv_after_alloc(res);
  
#line 29 
  return res;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kcalloc(size_t n, size_t size, gfp_t flags)
{
  void *res;
  
#line 36 
  ldv_check_alloc_flags(flags);
  
#line 37 
  res = ldv_calloc(n,size);
  
#line 38 
  ldv_after_alloc(res);
  
#line 40 
  return res;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kzalloc(size_t size, gfp_t flags)
{
  void *res;
  
#line 47 
  ldv_check_alloc_flags(flags);
  
#line 48 
  res = ldv_zalloc(size);
  
#line 49 
  ldv_after_alloc(res);
  
#line 51 
  return res;
}


#line 54  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc_array(size_t n, size_t size, gfp_t flags)
{
  void *res;
  
#line 58 
  ldv_check_alloc_flags(flags);
  
#line 59 
  res = ldv_malloc(n * size);
  
#line 60 
  ldv_after_alloc(res);
  
#line 62 
  return res;
}


#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void ldv_free(void *s);


#line 35 
void *ldv_malloc_unknown_size(void);


#line 36 
void *ldv_calloc_unknown_size(void);


#line 37 
void *ldv_zalloc_unknown_size(void);


#line 40 
void *ldv_reference_malloc(size_t size);


#line 41 
void *ldv_reference_calloc(size_t nmemb, size_t size);


#line 42 
void *ldv_reference_zalloc(size_t size);


#line 43 
void ldv_reference_free(void *s);


#line 47 
void *ldv_reference_xmalloc(size_t size);


#line 48 
void *ldv_reference_xzalloc(size_t size);


#line 52 
void *ldv_reference_malloc_unknown_size(void);


#line 53 
void *ldv_reference_calloc_unknown_size(void);


#line 54 
void *ldv_reference_zalloc_unknown_size(void);


#line 61 
void *ldv_xmalloc_unknown_size(size_t size);


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_reference_xmalloc_unknown_size(size_t size);


#line 34  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_malloc(size_t size)
{
  void *res;
  
#line 37 
  res = ldv_reference_malloc(size);
  
#line 38 
  if (res != (void *)0) {
    long tmp;
    
#line 39 
    tmp = ldv_is_err((void const *)res);
    
#line 39 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 40 
  return res;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc(size_t nmemb, size_t size)
{
  void *res;
  
#line 46 
  res = ldv_reference_calloc(nmemb,size);
  
#line 47 
  if (res != (void *)0) {
    long tmp;
    
#line 48 
    tmp = ldv_is_err((void const *)res);
    
#line 48 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 49 
  return res;
}


#line 52  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc(size_t size)
{
  void *res;
  
#line 55 
  res = ldv_reference_zalloc(size);
  
#line 56 
  if (res != (void *)0) {
    long tmp;
    
#line 57 
    tmp = ldv_is_err((void const *)res);
    
#line 57 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 58 
  return res;
}


#line 61  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void ldv_free(void *s)
{
  
#line 63 
  ldv_reference_free(s);
  
#line 64 
  return;
}


#line 66  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc(size_t size)
{
  void *res;
  long tmp;
  
#line 69 
  res = ldv_reference_xmalloc(size);
  
#line 70 
  tmp = ldv_is_err((void const *)res);
  
#line 70 
  __VERIFIER_assume(tmp == 0L);
  
#line 71 
  return res;
}


#line 74  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xzalloc(size_t size)
{
  void *res;
  long tmp;
  
#line 77 
  res = ldv_reference_xzalloc(size);
  
#line 78 
  tmp = ldv_is_err((void const *)res);
  
#line 78 
  __VERIFIER_assume(tmp == 0L);
  
#line 79 
  return res;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_malloc_unknown_size(void)
{
  void *res;
  
#line 85 
  res = ldv_reference_malloc_unknown_size();
  
#line 86 
  if (res != (void *)0) {
    long tmp;
    
#line 87 
    tmp = ldv_is_err((void const *)res);
    
#line 87 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 88 
  return res;
}


#line 91  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc_unknown_size(void)
{
  void *res;
  
#line 94 
  res = ldv_reference_calloc_unknown_size();
  
#line 95 
  if (res != (void *)0) {
    long tmp;
    
#line 96 
    tmp = ldv_is_err((void const *)res);
    
#line 96 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 97 
  return res;
}


#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc_unknown_size(void)
{
  void *res;
  
#line 103 
  res = ldv_reference_zalloc_unknown_size();
  
#line 104 
  if (res != (void *)0) {
    long tmp;
    
#line 105 
    tmp = ldv_is_err((void const *)res);
    
#line 105 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 106 
  return res;
}


#line 109  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc_unknown_size(size_t size)
{
  void *res;
  long tmp;
  
#line 112 
  res = ldv_reference_xmalloc_unknown_size(size);
  
#line 113 
  tmp = ldv_is_err((void const *)res);
  
#line 113 
  __VERIFIER_assume(tmp == 0L);
  
#line 114 
  return res;
}

long __builtin_expect(long exp, long c);


#line 22  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/common.h"
void __VERIFIER_error(void);


#line 24  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/gcc.c"
long __builtin_expect(long exp, long c)
{
  
#line 26 
  return exp;
}


#line 35  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/gcc.c"
void __builtin_trap(void)
{
  
#line 37 
  __VERIFIER_error();
  
#line 38 
  return;
}


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
int ldv_undef_int(void);


#line 24 
int ldv_undef_long(void);


#line 25 
unsigned int ldv_undef_uint(void);


#line 26 
unsigned long ldv_undef_ulong(void);


#line 27 
unsigned long long ldv_undef_ulonglong(void);


#line 28 
void *ldv_undef_ptr(void);


#line 31 
int ldv_undef_int_positive(void);


#line 34 
int ldv_undef_int_negative(void);


#line 37 
int ldv_undef_int_nonpositive(void);


#line 40 
void *ldv_undef_ptr_non_null(void);


#line 29  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int __VERIFIER_nondet_int(void);


#line 31 
long __VERIFIER_nondet_long(void);


#line 38 
unsigned int __VERIFIER_nondet_uint(void);


#line 41 
unsigned long __VERIFIER_nondet_ulong(void);


#line 42 
unsigned long long __VERIFIER_nondet_ulonglong(void);


#line 43 
void *__VERIFIER_nondet_pointer(void);


#line 46  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int(void)
{
  int tmp;
  
#line 48 
  tmp = __VERIFIER_nondet_int();
  
#line 48 
  return tmp;
}


#line 51  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_long(void)
{
  int __retres;
  long tmp;
  
#line 53 
  tmp = __VERIFIER_nondet_long();
  
#line 53 
  __retres = (int)tmp;
  
#line 53 
  return __retres;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned int ldv_undef_uint(void)
{
  unsigned int tmp;
  
#line 58 
  tmp = __VERIFIER_nondet_uint();
  
#line 58 
  return tmp;
}


#line 61  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr(void)
{
  void *tmp;
  
#line 63 
  tmp = __VERIFIER_nondet_pointer();
  
#line 63 
  return tmp;
}


#line 66  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long ldv_undef_ulong(void)
{
  unsigned long tmp;
  
#line 68 
  tmp = __VERIFIER_nondet_ulong();
  
#line 68 
  return tmp;
}


#line 71  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long long ldv_undef_ulonglong(void)
{
  unsigned long long tmp;
  
#line 73 
  tmp = __VERIFIER_nondet_ulonglong();
  
#line 73 
  return tmp;
}


#line 76  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_positive(void)
{
  
#line 78 
  int ret = ldv_undef_int();
  
#line 80 
  __VERIFIER_assume(ret > 0);
  
#line 82 
  return ret;
}


#line 85  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_negative(void)
{
  
#line 87 
  int ret = ldv_undef_int();
  
#line 89 
  __VERIFIER_assume(ret < 0);
  
#line 91 
  return ret;
}


#line 94  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_nonpositive(void)
{
  
#line 96 
  int ret = ldv_undef_int();
  
#line 98 
  __VERIFIER_assume(ret <= 0);
  
#line 100 
  return ret;
}


#line 103  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr_non_null(void)
{
  
#line 105 
  void *ret = ldv_undef_ptr();
  
#line 107 
  __VERIFIER_assume(ret != (void *)0);
  
#line 109 
  return ret;
}


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *external_allocated_data(void);


#line 45 
void *ldv_reference_realloc(void *ptr, size_t size);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *malloc(size_t);


#line 24 
void *calloc(size_t, size_t);


#line 25 
void free(void *);


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc(size_t size)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 37 
  tmp = ldv_undef_int();
  
#line 37 
  if (tmp != 0) {
    
#line 39 
    res = malloc(size);
    
#line 40 
    __VERIFIER_assume(res != (void *)0);
    
#line 41 
    __retres = res;
    
#line 41 
    goto return_label;
  }
  else {
    
#line 44 
    __retres = (void *)0;
    
#line 44 
    goto return_label;
  }
  return_label: 
#line 37 
                return __retres;
}


#line 47  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc(size_t nmemb, size_t size)
{
  void *tmp;
  
#line 49 
  tmp = calloc(nmemb,size);
  
#line 49 
  return tmp;
}


#line 52  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc(size_t size)
{
  void *tmp;
  
#line 54 
  tmp = calloc(1UL,size);
  
#line 54 
  return tmp;
}


#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void ldv_reference_free(void *s)
{
  
#line 59 
  free(s);
  
#line 60 
  return;
}


#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_realloc(void *ptr, size_t size)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 66 
  if (ptr != (void *)0 && size == 0UL) {
    
#line 67 
    free(ptr);
    
#line 68 
    __retres = (void *)0;
    
#line 68 
    goto return_label;
  }
  else ;
  
#line 71 
  if (ptr == (void *)0) {
    
#line 72 
    res = malloc(size);
    
#line 73 
    __retres = res;
    
#line 73 
    goto return_label;
  }
  else ;
  
#line 76 
  tmp = ldv_undef_int();
  
#line 76 
  if (tmp != 0) {
    
#line 78 
    res = malloc(size);
    
#line 79 
    __VERIFIER_assume(res != (void *)0);
    
#line 81 
    memcpy(res,(void const *)ptr,size);
    
#line 82 
    free(ptr);
    
#line 84 
    __retres = res;
    
#line 84 
    goto return_label;
  }
  else {
    
#line 87 
    __retres = (void *)0;
    
#line 87 
    goto return_label;
  }
  return_label: 
#line 76 
                return __retres;
}


#line 90  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc(size_t size)
{
  void *res;
  
#line 94 
  res = malloc(size);
  
#line 95 
  __VERIFIER_assume(res != (void *)0);
  
#line 97 
  return res;
}


#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xzalloc(size_t size)
{
  void *res;
  
#line 104 
  res = calloc(1UL,size);
  
#line 105 
  __VERIFIER_assume(res != (void *)0);
  
#line 107 
  return res;
}


#line 110  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc_unknown_size(void)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 114 
  tmp = ldv_undef_int();
  
#line 114 
  if (tmp != 0) {
    
#line 115 
    res = external_allocated_data();
    
#line 116 
    __VERIFIER_assume(res != (void *)0);
    
#line 117 
    __retres = res;
    
#line 117 
    goto return_label;
  }
  else {
    
#line 120 
    __retres = (void *)0;
    
#line 120 
    goto return_label;
  }
  return_label: 
#line 114 
                return __retres;
}


#line 123  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc_unknown_size(void)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 127 
  tmp = ldv_undef_int();
  
#line 127 
  if (tmp != 0) {
    
#line 128 
    res = external_allocated_data();
    
#line 129 
    memset(res,0,8UL);
    
#line 130 
    __VERIFIER_assume(res != (void *)0);
    
#line 131 
    __retres = res;
    
#line 131 
    goto return_label;
  }
  else {
    
#line 134 
    __retres = (void *)0;
    
#line 134 
    goto return_label;
  }
  return_label: 
#line 127 
                return __retres;
}


#line 137  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc_unknown_size(void)
{
  void *tmp;
  
#line 139 
  tmp = ldv_reference_calloc_unknown_size();
  
#line 139 
  return tmp;
}


#line 142  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc_unknown_size(size_t size)
{
  void *res;
  
#line 146 
  res = external_allocated_data();
  
#line 147 
  __VERIFIER_assume(res != (void *)0);
  
#line 149 
  return res;
}


#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.h"
void ldv_initialize(void);


#line 97 
void ldv_failed_register_netdev(void);


#line 123 
void ldv_pre_probe(void);


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
int pthread_create(pthread_t *, pthread_attr_t const *, void *(*)(void *), void *);


#line 37 
int pthread_join(pthread_t, void **);


#line 54  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_deregister_5_1(struct net_device *arg0);


#line 55 
int main(void);


#line 56 
void *ldv_pci_scenario_11(void *arg0);


#line 58 
void *ldv_random_allocationless_scenario_9(void *arg0);


#line 60 
void ldv_dispatch_register_4_4(struct net_device *arg0);


#line 62 
void ldv_dispatch_irq_deregister_3_1(int arg0);


#line 63 
void ldv_dispatch_irq_register_8_3(int arg0, enum irqreturn (*arg1)(int , void *), enum irqreturn (*arg2)(int , void *), void *arg3);


#line 65 
void *ldv_interrupt_scenario_10(void *arg0);


#line 67 
void ldv_dispatch_deregister_7_1(struct pci_driver *arg0);


#line 68 
void ldv_dispatch_register_6_3(struct pci_driver *arg0);


#line 70 
void *ldv_initialization_1(void *arg0);


#line 74  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_10;

#line 75  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_11;

#line 76  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_9;

#line 80  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_deregister_5_1(struct net_device *arg0)
{
  int ret;
  struct ldv_struct_random_allocationless_scenario_9 *cf_arg_9;
  int tmp;
  
#line 83 
  tmp = ldv_undef_int();
  
#line 83 
  switch (tmp) {
    case 0: 
#line 84 
    ;
    
#line 85 
    ret = pthread_join(ldv_thread_9,(void **)0);
    
#line 86 
    __VERIFIER_assume(ret == 0);
    
#line 87 
    goto ldv_44646;
    default: 
#line 89 
    ;
    
#line 89 
    __VERIFIER_assume(0);
  }
  ldv_44646: 
#line 90 
  ;
  
#line 91 
  return;
}


#line 95  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/emg/environment_model.c"
int main(void)
{
  int __retres;
  
#line 98 
  ldv_initialize();
  
#line 101 
  ldv_initialization_1((void *)0);
  
#line 103 
  __retres = 0;
  
#line 103 
  return __retres;
}


#line 108  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_pci_scenario_11(void *arg0)
{
  void *__retres;
  struct pci_dev *ldv_11_resource_1;
  struct pci_device_id *ldv_11_ldv_param_1_2;
  struct pm_message ldv_11_resource_0;
  int tmp_2;
  int tmp_3;
  
#line 113 
  struct pci_driver *ldv_11_container = ldv_emg_alias_skfddi_pci_driver_2;
  
#line 114 
  int ldv_11_ret = ldv_undef_int();
  
#line 117 
  struct ldv_struct_pci_scenario_11 *data = (struct ldv_struct_pci_scenario_11 *)arg0;
  
#line 121 
  ldv_11_ret = ldv_undef_int();
  
#line 124 
  if (data != (struct ldv_struct_pci_scenario_11 *)0) {
    
#line 125 
    ldv_11_container = data->arg0;
    
#line 126 
    ldv_free((void *)data);
  }
  else ;
  
#line 137 
  goto ldv_main_11;
  
#line 139 
  __retres = (void *)0;
  
#line 139 
  goto return_label;
  ldv_main_11: 
#line 142 
  ;
  
#line 145 
  tmp_2 = ldv_undef_int();
  
#line 145 
  if (tmp_2 != 0) {
    int tmp_1;
    
#line 147 
    ldv_11_ldv_param_1_2 = (struct pci_device_id *)ldv_xmalloc_unknown_size(0UL);
    
#line 152 
    ldv_pre_probe();
    
#line 154 
    ldv_11_ret = ldv_emg_wrapper_skfp_init_one_2(ldv_11_resource_1,ldv_11_ldv_param_1_2);
    
#line 156 
    ldv_11_ret = ldv_post_probe(ldv_11_ret);
    
#line 160 
    ldv_free((void *)ldv_11_ldv_param_1_2);
    
#line 163 
    tmp_1 = ldv_undef_int();
    
#line 163 
    if (tmp_1 != 0) {
      
#line 165 
      __VERIFIER_assume(ldv_11_ret == 0);
      
#line 172 
      goto ldv_call_11;
    }
    else {
      
#line 176 
      __VERIFIER_assume(ldv_11_ret != 0);
      
#line 183 
      goto ldv_main_11;
    }
  }
  else {
    
#line 195 
    __retres = (void *)0;
    
#line 195 
    goto return_label;
  }
  
#line 198 
  __retres = (void *)0;
  
#line 198 
  goto return_label;
  ldv_call_11: 
#line 201 
  ;
  
#line 204 
  tmp_3 = ldv_undef_int();
  
#line 204 
  switch (tmp_3) {
    case 1: 
#line 205 
    ;
    
#line 214 
    goto ldv_call_11;
    case 2: 
#line 217 
    ;
    
#line 219 
    if (ldv_11_container->suspend != (int (*)(struct pci_dev *, pm_message_t ))0) {
      
#line 221 
      ldv_11_ret = (*(ldv_11_container->suspend))(ldv_11_resource_1,ldv_11_resource_0);
      
#line 223 
      ldv_11_ret = ldv_filter_err_code(ldv_11_ret);
    }
    else 
#line 225 
         ldv_11_ret = ldv_undef_int();
    
#line 230 
    if (ldv_11_container->suspend_late != (int (*)(struct pci_dev *, pm_message_t ))0) {
      
#line 232 
      ldv_11_ret = (*(ldv_11_container->suspend_late))(ldv_11_resource_1,ldv_11_resource_0);
      
#line 234 
      ldv_11_ret = ldv_filter_err_code(ldv_11_ret);
    }
    else 
#line 236 
         ldv_11_ret = ldv_undef_int();
    
#line 241 
    if (ldv_11_container->resume_early != (int (*)(struct pci_dev *))0) 
      
#line 243 
      (*(ldv_11_container->resume_early))(ldv_11_resource_1); else ;
    
#line 248 
    if (ldv_11_container->resume != (int (*)(struct pci_dev *))0) 
#line 250 
                                                                  (*(ldv_11_container->resume))(ldv_11_resource_1); else ;
    
#line 258 
    goto ldv_call_11;
    case 3: 
#line 261 
    ;
    
#line 263 
    if (ldv_11_container->shutdown != (void (*)(struct pci_dev *))0) 
      
#line 265 
      (*(ldv_11_container->shutdown))(ldv_11_resource_1); else ;
    
#line 271 
    ldv_emg_wrapper_skfp_remove_one_3(ldv_11_resource_1);
    
#line 278 
    goto ldv_main_11;
    default: 
#line 281 
    ;
    
#line 281 
    __VERIFIER_assume(0);
  }
  
#line 284 
  __retres = (void *)0;
  return_label: 
#line 284 
                return __retres;
}


#line 289  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg___pci_register_driver(struct pci_driver *arg0, struct module *arg1, char *arg2)
{
  int __retres;
  int tmp_0;
  
#line 292 
  struct pci_driver *ldv_6_pci_driver = ldv_emg_alias_skfddi_pci_driver_2;
  
#line 296 
  tmp_0 = ldv_undef_int();
  
#line 296 
  if (tmp_0 != 0) {
    
#line 298 
    ldv_6_pci_driver = arg0;
    
#line 302 
    ldv_dispatch_register_6_3(ldv_6_pci_driver);
    
#line 306 
    __retres = 0;
    
#line 306 
    goto return_label;
  }
  else {
    int tmp;
    
#line 313 
    tmp = ldv_undef_int_negative();
    
#line 313 
    __retres = tmp;
    
#line 313 
    goto return_label;
  }
  return_label: 
#line 296 
                return __retres;
}


#line 323  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_random_allocationless_scenario_9(void *arg0)
{
  void *__retres;
  int ldv_9_ldv_param_2_3;
  struct ifreq *ldv_9_ldv_param_1_2;
  struct sk_buff *ldv_9_ldv_param_0_5;
  int ldv_9_ldv_param_1_4;
  struct net_device *ldv_9_container;
  void *ldv_9_ldv_param_1_6;
  int tmp;
  
#line 333 
  struct ldv_struct_random_allocationless_scenario_9 *data = (struct ldv_struct_random_allocationless_scenario_9 *)arg0;
  
#line 338 
  if (data != (struct ldv_struct_random_allocationless_scenario_9 *)0) {
    
#line 339 
    ldv_9_container = data->arg0;
    
#line 340 
    ldv_free((void *)data);
  }
  else ;
  
#line 348 
  goto ldv_call_9;
  
#line 350 
  __retres = (void *)0;
  
#line 350 
  goto return_label;
  ldv_call_9: 
#line 353 
  ;
  
#line 356 
  tmp = ldv_undef_int();
  
#line 356 
  switch (tmp) {
    case 1: 
#line 357 
    ;
    
#line 360 
    ldv_emg_wrapper_skfp_ctl_get_stats_2(ldv_9_container);
    
#line 367 
    goto ldv_call_9;
    case 2: 
#line 370 
    ;
    
#line 373 
    ldv_emg_wrapper_skfp_ctl_set_multicast_list_7(ldv_9_container);
    
#line 380 
    goto ldv_call_9;
    case 3: 
#line 383 
    ;
    
#line 385 
    ldv_9_ldv_param_1_6 = ldv_xmalloc_unknown_size(0UL);
    
#line 390 
    ldv_emg_wrapper_skfp_ctl_set_mac_address_6(ldv_9_container,ldv_9_ldv_param_1_6);
    
#line 394 
    ldv_free(ldv_9_ldv_param_1_6);
    
#line 401 
    goto ldv_call_9;
    case 4: 
#line 404 
    ;
    
#line 406 
    ldv_9_ldv_param_0_5 = (struct sk_buff *)ldv_xmalloc_unknown_size(0UL);
    
#line 411 
    ldv_emg_wrapper_skfp_send_pkt_5(ldv_9_ldv_param_0_5,ldv_9_container);
    
#line 415 
    ldv_free((void *)ldv_9_ldv_param_0_5);
    
#line 422 
    goto ldv_call_9;
    case 5: 
#line 425 
    ;
    
#line 431 
    (*ldv_emg_alias_fddi_change_mtu_4)(ldv_9_container,ldv_9_ldv_param_1_4);
    
#line 441 
    goto ldv_call_9;
    case 6: 
#line 444 
    ;
    
#line 446 
    ldv_9_ldv_param_1_2 = (struct ifreq *)ldv_xmalloc_unknown_size(0UL);
    
#line 451 
    ldv_emg_wrapper_skfp_ioctl_3(ldv_9_container,ldv_9_ldv_param_1_2,ldv_9_ldv_param_2_3);
    
#line 455 
    ldv_free((void *)ldv_9_ldv_param_1_2);
    
#line 462 
    goto ldv_call_9;
    case 7: 
#line 465 
    ;
    
#line 471 
    __retres = (void *)0;
    
#line 471 
    goto return_label;
    default: 
#line 474 
    ;
    
#line 474 
    __VERIFIER_assume(0);
  }
  
#line 477 
  __retres = (void *)0;
  return_label: 
#line 477 
                return __retres;
}


#line 482  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_free_irq(unsigned int arg0, void *arg1)
{
  int ldv_3_line;
  
#line 488 
  ldv_3_line = (int)arg0;
  
#line 492 
  ldv_dispatch_irq_deregister_3_1(ldv_3_line);
  
#line 496 
  goto return_label;
  return_label: 
#line 498 
                return;
}


#line 503  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_register_4_4(struct net_device *arg0)
{
  int ret;
  struct ldv_struct_random_allocationless_scenario_9 *cf_arg_9;
  int tmp;
  
#line 506 
  tmp = ldv_undef_int();
  
#line 506 
  switch (tmp) {
    case 0: 
#line 507 
    ;
    
#line 508 
    cf_arg_9 = (struct ldv_struct_random_allocationless_scenario_9 *)ldv_xmalloc(16UL);
    
#line 509 
    cf_arg_9->arg0 = arg0;
    
#line 510 
    ret = pthread_create(& ldv_thread_9,(pthread_attr_t const *)0,& ldv_random_allocationless_scenario_9,(void *)cf_arg_9);
    
#line 511 
    __VERIFIER_assume(ret == 0);
    
#line 512 
    goto ldv_44702;
    default: 
#line 514 
    ;
    
#line 514 
    __VERIFIER_assume(0);
  }
  ldv_44702: 
#line 515 
  ;
  
#line 516 
  return;
}


#line 520  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_pci_unregister_driver(struct pci_driver *arg0)
{
  
#line 523 
  struct pci_driver *ldv_7_pci_driver = ldv_emg_alias_skfddi_pci_driver_2;
  
#line 526 
  ldv_7_pci_driver = arg0;
  
#line 530 
  ldv_dispatch_deregister_7_1(ldv_7_pci_driver);
  
#line 534 
  goto return_label;
  return_label: 
#line 536 
                return;
}


#line 541  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_irq_deregister_3_1(int arg0)
{
  int ret;
  struct ldv_struct_free_irq_3 *cf_arg_10;
  int tmp;
  
#line 544 
  tmp = ldv_undef_int();
  
#line 544 
  switch (tmp) {
    case 0: 
#line 545 
    ;
    
#line 546 
    ret = pthread_join(ldv_thread_10,(void **)0);
    
#line 547 
    __VERIFIER_assume(ret == 0);
    
#line 548 
    goto ldv_44714;
    default: 
#line 550 
    ;
    
#line 550 
    __VERIFIER_assume(0);
  }
  ldv_44714: 
#line 551 
  ;
  
#line 552 
  return;
}


#line 556  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_irq_register_8_3(int arg0, enum irqreturn (*arg1)(int , void *), enum irqreturn (*arg2)(int , void *), void *arg3)
{
  int ret;
  struct ldv_struct_interrupt_scenario_10 *cf_arg_10;
  int tmp;
  
#line 559 
  tmp = ldv_undef_int();
  
#line 559 
  switch (tmp) {
    case 0: 
#line 560 
    ;
    
#line 561 
    cf_arg_10 = (struct ldv_struct_interrupt_scenario_10 *)ldv_xmalloc(32UL);
    
#line 562 
    cf_arg_10->arg0 = arg0;
    
#line 563 
    cf_arg_10->arg1 = arg1;
    
#line 564 
    cf_arg_10->arg2 = arg2;
    
#line 565 
    cf_arg_10->arg3 = arg3;
    
#line 566 
    ret = pthread_create(& ldv_thread_10,(pthread_attr_t const *)0,& ldv_interrupt_scenario_10,(void *)cf_arg_10);
    
#line 567 
    __VERIFIER_assume(ret == 0);
    
#line 568 
    goto ldv_44729;
    default: 
#line 570 
    ;
    
#line 570 
    __VERIFIER_assume(0);
  }
  ldv_44729: 
#line 571 
  ;
  
#line 572 
  return;
}


#line 576  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_unregister_netdev(struct net_device *arg0)
{
  struct net_device *ldv_5_netdev;
  
#line 582 
  ldv_5_netdev = arg0;
  
#line 587 
  ldv_emg_wrapper_skfp_close_2(ldv_5_netdev);
  
#line 591 
  ldv_dispatch_deregister_5_1(ldv_5_netdev);
  
#line 595 
  goto return_label;
  return_label: 
#line 597 
                return;
}


#line 602  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_interrupt_scenario_10(void *arg0)
{
  void *__retres;
  enum irqreturn ldv_10_ret_val;
  int ldv_10_line;
  void *ldv_10_data;
  enum irqreturn (*ldv_10_thread)(int , void *);
  int tmp;
  
#line 608 
  enum irqreturn (*ldv_10_callback)(int , void *) = & ldv_emg_wrapper_skfp_interrupt_2;
  
#line 611 
  struct ldv_struct_interrupt_scenario_10 *data = (struct ldv_struct_interrupt_scenario_10 *)arg0;
  
#line 616 
  if (data != (struct ldv_struct_interrupt_scenario_10 *)0) {
    
#line 617 
    ldv_10_line = data->arg0;
    
#line 618 
    ldv_10_callback = data->arg1;
    
#line 619 
    ldv_10_thread = data->arg2;
    
#line 620 
    ldv_10_data = data->arg3;
    
#line 621 
    ldv_free((void *)data);
  }
  else ;
  
#line 627 
  ldv_switch_to_interrupt_context();
  
#line 629 
  ldv_10_ret_val = ldv_emg_wrapper_skfp_interrupt_2(ldv_10_line,ldv_10_data);
  
#line 631 
  ldv_switch_to_process_context();
  
#line 634 
  tmp = ldv_undef_int();
  
#line 634 
  if (tmp != 0) {
    
#line 636 
    __VERIFIER_assume(ldv_10_ret_val == (unsigned int)IRQ_WAKE_THREAD);
    
#line 640 
    if (ldv_10_thread != (enum irqreturn (*)(int , void *))0) 
#line 642 
                                                              (*ldv_10_thread)(ldv_10_line,ldv_10_data); else ;
  }
  else 
#line 649 
       __VERIFIER_assume(ldv_10_ret_val != (unsigned int)IRQ_WAKE_THREAD);
  
#line 658 
  __retres = (void *)0;
  
#line 658 
  goto return_label;
  
#line 660 
  __retres = (void *)0;
  return_label: 
#line 660 
                return __retres;
}


#line 665  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_request_irq(unsigned int arg0, enum irqreturn (*arg1)(int , void *), unsigned long arg2, char *arg3, void *arg4)
{
  int __retres;
  int ldv_8_line;
  void *ldv_8_data;
  enum irqreturn (*ldv_8_thread)(int , void *);
  int tmp_0;
  
#line 670 
  enum irqreturn (*ldv_8_callback)(int , void *) = & ldv_emg_wrapper_skfp_interrupt_2;
  
#line 675 
  tmp_0 = ldv_undef_int();
  
#line 675 
  if (tmp_0 != 0) {
    
#line 677 
    ldv_8_line = (int)arg0;
    
#line 678 
    ldv_8_callback = arg1;
    
#line 679 
    ldv_8_thread = (enum irqreturn (*)(int , void *))0;
    
#line 680 
    ldv_8_data = arg4;
    
#line 684 
    ldv_dispatch_irq_register_8_3(ldv_8_line,ldv_8_callback,ldv_8_thread,ldv_8_data);
    
#line 688 
    __retres = 0;
    
#line 688 
    goto return_label;
  }
  else {
    int tmp;
    
#line 695 
    tmp = ldv_undef_int_negative();
    
#line 695 
    __retres = tmp;
    
#line 695 
    goto return_label;
  }
  return_label: 
#line 675 
                return __retres;
}


#line 705  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_deregister_7_1(struct pci_driver *arg0)
{
  int ret;
  struct ldv_struct_pci_scenario_11 *cf_arg_11;
  int tmp;
  
#line 708 
  tmp = ldv_undef_int();
  
#line 708 
  switch (tmp) {
    case 0: 
#line 709 
    ;
    
#line 710 
    ret = pthread_join(ldv_thread_11,(void **)0);
    
#line 711 
    __VERIFIER_assume(ret == 0);
    
#line 712 
    goto ldv_44771;
    default: 
#line 714 
    ;
    
#line 714 
    __VERIFIER_assume(0);
  }
  ldv_44771: 
#line 715 
  ;
  
#line 716 
  return;
}


#line 720  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_register_6_3(struct pci_driver *arg0)
{
  int ret;
  struct ldv_struct_pci_scenario_11 *cf_arg_11;
  int tmp;
  
#line 723 
  tmp = ldv_undef_int();
  
#line 723 
  switch (tmp) {
    case 0: 
#line 724 
    ;
    
#line 725 
    cf_arg_11 = (struct ldv_struct_pci_scenario_11 *)ldv_xmalloc(16UL);
    
#line 726 
    cf_arg_11->arg0 = arg0;
    
#line 727 
    ret = pthread_create(& ldv_thread_11,(pthread_attr_t const *)0,& ldv_pci_scenario_11,(void *)cf_arg_11);
    
#line 728 
    __VERIFIER_assume(ret == 0);
    
#line 729 
    goto ldv_44779;
    default: 
#line 731 
    ;
    
#line 731 
    __VERIFIER_assume(0);
  }
  ldv_44779: 
#line 732 
  ;
  
#line 733 
  return;
}


#line 737  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_free_netdev(struct net_device *arg0)
{
  struct net_device *ldv_2_netdev;
  
#line 743 
  ldv_2_netdev = arg0;
  
#line 744 
  ldv_free((void *)ldv_2_netdev);
  
#line 748 
  goto return_label;
  return_label: 
#line 750 
                return;
}


#line 755  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_initialization_1(void *arg0)
{
  void *__retres;
  int ldv_1_ret;
  int tmp;
  
#line 762 
  ldv_1_ret = ldv_emg_skfddi_pci_driver_init();
  
#line 763 
  ldv_1_ret = ldv_post_init(ldv_1_ret);
  
#line 766 
  tmp = ldv_undef_int();
  
#line 766 
  if (tmp != 0) {
    
#line 768 
    __VERIFIER_assume(ldv_1_ret != 0);
    
#line 772 
    __retres = (void *)0;
    
#line 772 
    goto return_label;
  }
  else {
    
#line 776 
    __VERIFIER_assume(ldv_1_ret == 0);
    
#line 781 
    ldv_emg_skfddi_pci_driver_exit();
    
#line 785 
    __retres = (void *)0;
    
#line 785 
    goto return_label;
  }
  
#line 788 
  __retres = (void *)0;
  return_label: 
#line 788 
                return __retres;
}


#line 793  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/fddi/skfp/skfp.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_register_netdev(struct net_device *arg0)
{
  int __retres;
  struct net_device *ldv_4_netdev;
  int tmp_3;
  
#line 797 
  int ldv_4_ret = ldv_undef_int();
  
#line 800 
  ldv_4_ret = ldv_undef_int();
  
#line 803 
  tmp_3 = ldv_undef_int();
  
#line 803 
  if (tmp_3 != 0) {
    int tmp_1;
    
#line 805 
    ldv_4_netdev = arg0;
    
#line 810 
    ldv_4_ret = ldv_emg_wrapper_skfp_open_2(ldv_4_netdev);
    
#line 813 
    tmp_1 = ldv_undef_int();
    
#line 813 
    if (tmp_1 != 0) {
      
#line 815 
      __VERIFIER_assume(ldv_4_ret == 0);
      
#line 819 
      ldv_dispatch_register_4_4(ldv_4_netdev);
      
#line 823 
      __retres = 0;
      
#line 823 
      goto return_label;
    }
    else {
      int tmp_0;
      
#line 830 
      __VERIFIER_assume(ldv_4_ret != 0);
      
#line 831 
      ldv_failed_register_netdev();
      
#line 832 
      tmp_0 = ldv_undef_int_negative();
      
#line 832 
      __retres = tmp_0;
      
#line 832 
      goto return_label;
    }
  }
  else {
    int tmp_2;
    
#line 840 
    ldv_failed_register_netdev();
    
#line 841 
    tmp_2 = ldv_undef_int_negative();
    
#line 841 
    __retres = tmp_2;
    
#line 841 
    goto return_label;
  }
  return_label: 
#line 803 
                return __retres;
}


