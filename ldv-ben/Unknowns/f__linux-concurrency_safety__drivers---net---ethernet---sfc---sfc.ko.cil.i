/* Generated by Frama-C */

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef short __s16;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef int __s32;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef signed char s8;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned char u8;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned short u16;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef int s32;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned int u32;

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef long long s64;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned long long u64;

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;

#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;

#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u16 __be16;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __le32;

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __be32;

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u64 __le64;

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __wsum;

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u32 __kernel_dev_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_dev_t dev_t;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned short umode_t;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_pid_t pid_t;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_clockid_t clockid_t;

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef _Bool bool;

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_uid32_t uid_t;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_gid32_t gid_t;

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_loff_t loff_t;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_size_t size_t;

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_time_t time_t;

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned char u_char;

#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned long u_long;

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __s32 int32_t;

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u8 uint8_t;

#line 108  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u32 uint32_t;

#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u64 uint64_t;

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned long sector_t;

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned long blkcnt_t;

#line 152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef u64 dma_addr_t;

#line 157  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int gfp_t;

#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int fmode_t;

#line 159  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int oom_flags_t;

#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef u64 phys_addr_t;

#line 167  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef phys_addr_t resource_size_t;

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;

#line 183  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};

#line 188 
struct hlist_node;

#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};

#line 192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};

#line 203  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head *) ;
};

#line 14  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
struct kernel_symbol {
   unsigned long value ;
   char const *name ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/export.h"
struct module;

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct __anonstruct_9 {
   unsigned int a ;
   unsigned int b ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct __anonstruct_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) base1 : 8 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) type : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) s : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) dpl : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) p : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) limit : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) avl : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) l : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) g : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) base2 : 8 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
union __anonunion_8 {
   struct __anonstruct_9 __anonCompField___anonunion_8_4 ;
   struct __anonstruct_10 __anonCompField___anonunion_8_5 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion_8 __anonCompField_desc_struct_6 ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;

#line 361 
struct page;

#line 361  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;

#line 372 
struct file;

#line 385 
struct seq_file;

#line 423 
struct thread_struct;

#line 425 
struct mm_struct;

#line 426 
struct task_struct;

#line 427 
struct cpumask;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/init.h"
typedef void (*ctor_fn_t)(void);

#line 234  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
struct _ddebug {
   char const *modname ;
   char const *function ;
   char const *filename ;
   char const *format ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))) lineno : 18 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) flags : 8 ;
};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_debug.h"
struct device;

#line 54 
struct net_device;

#line 420  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
struct file_operations;

#line 432 
struct completion;

#line 555  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/percpu.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct timespec;

#line 103 
struct compat_timespec;

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_futex_16 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_nanosleep_17 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};

#line 104 
struct pollfd;

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_poll_18 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
union __anonunion_15 {
   struct __anonstruct_futex_16 futex ;
   struct __anonstruct_nanosleep_17 nanosleep ;
   struct __anonstruct_poll_18 poll ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct restart_block {
   long (*fn)(struct restart_block *) ;
   union __anonunion_15 __anonCompField_restart_block_7 ;
};

#line 127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/vm86.h"
union __anonunion_19 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_19 __anonCompField_math_emu_info_8 ;
};

#line 328  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[128U] ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
typedef struct cpumask cpumask_t;

#line 652  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;

#line 260  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct __anonstruct_29 {
   u64 rip ;
   u64 rdp ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct __anonstruct_30 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union __anonunion_28 {
   struct __anonstruct_29 __anonCompField___anonunion_28_12 ;
   struct __anonstruct_30 __anonCompField___anonunion_28_13 ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union __anonunion_31 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_28 __anonCompField_fxregs_state_14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_31 __anonCompField_fxregs_state_15 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};

#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};

#line 179  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
   u8 __padding[4096U] ;
};

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
   union fpregs_state state ;
};

#line 170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
struct seq_operations;

#line 369 
struct perf_event;

#line 370  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   struct fpu fpu ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bottom_half.h"
struct lockdep_map;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};

#line 28  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};

#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const *name ;
   int cpu ;
   unsigned long ip ;
};

#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(13))) class_idx : 13 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) irq_context : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) trylock : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) read : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) check : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hardirqs_off : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))) references : 12 ;
   unsigned int pin_count ;
};

#line 546  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
struct __anonstruct_35 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
union __anonunion_34 {
   struct raw_spinlock rlock ;
   struct __anonstruct_35 __anonCompField___anonunion_34_17 ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_34 __anonCompField_spinlock_18 ;
};

#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_36 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_36 rwlock_t;

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jump_label.h"
struct jump_entry;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/jump_label.h"
typedef u64 jump_label_t;

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/jump_label.h"
struct jump_entry {
   jump_label_t code ;
   jump_label_t target ;
   jump_label_t key ;
};

#line 41  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
struct mutex;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/delay.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ftrace_irq.h"
struct vm_area_struct;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmdebug.h"
struct llist_node;

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/x86_init.h"
struct pci_dev;

#line 152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mpspec.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
typedef struct seqcount seqcount_t;

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
struct __anonstruct_seqlock_t_109 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_109 seqlock_t;

#line 598  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};

#line 437  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ktime.h"
typedef union ktime ktime_t;

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debugobjects.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};

#line 238  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
struct hrtimer;

#line 239 
enum hrtimer_restart;

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
struct __wait_queue;

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t *, unsigned int , int , void *) ;
   struct list_head task_list ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;

#line 1170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};

#line 296  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
struct notifier_block;

#line 1120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};

#line 837  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/sysctl.h"
struct ctl_table;

#line 838 
struct nsproxy;

#line 839 
struct ctl_table_root;

#line 840 
struct ctl_table_header;

#line 841 
struct ctl_dir;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table *, int , void *, size_t *, loff_t *);

#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table {
   char const *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};

#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct __anonstruct_111 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
union __anonunion_110 {
   struct __anonstruct_111 __anonCompField___anonunion_110_19 ;
   struct callback_head rcu ;
};

#line 122 
struct ctl_table_set;

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion_110 __anonCompField_ctl_table_header_20 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};

#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};

#line 149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set *) ;
   struct ctl_dir dir ;
};

#line 154  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root *, struct nsproxy *) ;
   int (*permissions)(struct ctl_table_header *, struct ctl_table *) ;
};

#line 259  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
struct workqueue_struct;

#line 260 
struct work_struct;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct *) ;
   struct lockdep_map lockdep_map ;
};

#line 107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct pm_message {
   int event ;
};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
typedef struct pm_message pm_message_t;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device *) ;
   void (*complete)(struct device *) ;
   int (*suspend)(struct device *) ;
   int (*resume)(struct device *) ;
   int (*freeze)(struct device *) ;
   int (*thaw)(struct device *) ;
   int (*poweroff)(struct device *) ;
   int (*restore)(struct device *) ;
   int (*suspend_late)(struct device *) ;
   int (*resume_early)(struct device *) ;
   int (*freeze_late)(struct device *) ;
   int (*thaw_early)(struct device *) ;
   int (*poweroff_late)(struct device *) ;
   int (*restore_early)(struct device *) ;
   int (*suspend_noirq)(struct device *) ;
   int (*resume_noirq)(struct device *) ;
   int (*freeze_noirq)(struct device *) ;
   int (*thaw_noirq)(struct device *) ;
   int (*poweroff_noirq)(struct device *) ;
   int (*restore_noirq)(struct device *) ;
   int (*runtime_suspend)(struct device *) ;
   int (*runtime_resume)(struct device *) ;
   int (*runtime_idle)(struct device *) ;
};

#line 320 
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
};

#line 327 
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
};

#line 335 
struct wakeup_source;

#line 336 
struct wake_irq;

#line 338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};

#line 553 
struct dev_pm_qos;

#line 553  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) can_wakeup : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) async_suspend : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_prepared : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_noirq_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_late_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_children : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) early_init : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) direct_complete : 1 ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wakeup_path : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) syscore : 1 ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) disable_depth : 3 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) idle_notification : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) request_pending : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) deferred_resume : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) run_wake : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) runtime_auto : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_callbacks : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) irq_safe : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) use_autosuspend : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) timer_autosuspends : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device *, s32 ) ;
   struct dev_pm_qos *qos ;
};

#line 615  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device *, bool ) ;
   int (*activate)(struct device *) ;
   void (*sync)(struct device *) ;
   void (*dismiss)(struct device *) ;
};

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nodemask.h"
struct __anonstruct_nodemask_t_112 {
   unsigned long bits[16U] ;
};

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_112 nodemask_t;

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/topology.h"
struct pci_bus;

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
struct ldt_struct;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_113 {
   struct ldt_struct *ldt ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_113 mm_context_t;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/xen/features.h"
struct bio_vec;

#line 796  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
struct rw_semaphore;

#line 797  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block *, unsigned long , void *) ;
   struct notifier_block *next ;
   int priority ;
};

#line 398  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/irq.h"
struct proc_dir_entry;

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hardirq.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};

#line 50 
struct hrtimer_clock_base;

#line 51 
struct hrtimer_cpu_base;

#line 60 
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer *) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};

#line 156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_hrtirq : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hres_active : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};

#line 466  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct kref {
   atomic_t refcount ;
};

#line 465  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long ) ;
   unsigned long data ;
};

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};

#line 186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
   __u32 cls ;
   __u32 cls_msk ;
};

#line 221  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const *data ;
};

#line 652  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
union __anonunion_151 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};

#line 652  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion_151 __anonCompField_idr_layer_38 ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};

#line 153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};

#line 185 
struct dentry;

#line 186 
struct iattr;

#line 187 
struct super_block;

#line 188 
struct file_system_type;

#line 189 
struct kernfs_open_node;

#line 190 
struct kernfs_iattrs;

#line 213 
struct kernfs_root;

#line 213  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_node;

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};

#line 89 
struct kernfs_ops;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops const *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
union __anonunion_156 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const *name ;
   struct rb_node rb ;
   void const *ns ;
   unsigned int hash ;
   union __anonunion_156 __anonCompField_kernfs_node_39 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};

#line 138  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root *, int *, char *) ;
   int (*show_options)(struct seq_file *, struct kernfs_root *) ;
   int (*mkdir)(struct kernfs_node *, char const *, umode_t ) ;
   int (*rmdir)(struct kernfs_node *) ;
   int (*rename)(struct kernfs_node *, struct kernfs_node *, char const *) ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};

#line 171 
struct vm_operations_struct;

#line 171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct const *vm_ops ;
};

#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file *, void *) ;
   void *(*seq_start)(struct seq_file *, loff_t *) ;
   void *(*seq_next)(struct seq_file *, void *, loff_t *) ;
   void (*seq_stop)(struct seq_file *, void *) ;
   ssize_t (*read)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   int (*mmap)(struct kernfs_open_file *, struct vm_area_struct *) ;
   struct lock_class_key lockdep_key ;
};

#line 281 
struct inode;

#line 477 
struct sock;

#line 478 
struct kobject;

#line 479 
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
};

#line 485  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const *(*netlink_ns)(struct sock *) ;
   void const *(*initial_ns)(void) ;
   void (*drop_ns)(void *) ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/highuid.h"
struct user_namespace;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct __anonstruct_kuid_t_157 {
   uid_t val ;
};

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_157 kuid_t;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct __anonstruct_kgid_t_158 {
   gid_t val ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_158 kgid_t;

#line 139  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/stat.h"
struct bin_attribute;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/stat.h"
struct attribute {
   char const *name ;
   umode_t mode ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_lockdep : 1 ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct attribute_group {
   char const *name ;
   umode_t (*is_visible)(struct kobject *, struct attribute *, int ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};

#line 82  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t , size_t ) ;
   ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t , size_t ) ;
   int (*mmap)(struct file *, struct kobject *, struct bin_attribute *, struct vm_area_struct *) ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject *, struct attribute *, char *) ;
   ssize_t (*store)(struct kobject *, struct attribute *, char const *, size_t ) ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset;

#line 52 
struct kobj_type;

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobject {
   char const *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_initialized : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_in_sysfs : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_add_uevent_sent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_remove_uevent_sent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) uevent_suppress : 1 ;
};

#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject *) ;
   struct sysfs_ops const *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations const *(*child_ns_type)(struct kobject *) ;
   void const *(*namespace)(struct kobject *) ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const filter)(struct kset *, struct kobject *) ;
   char const *(* const name)(struct kset *, struct kobject *) ;
   int (* const uevent)(struct kset *, struct kobject *, struct kobj_uevent_env *) ;
};

#line 148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops const *uevent_ops ;
};

#line 223 
struct klist_node;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};

#line 67 
struct path;

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations const *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file *, loff_t *) ;
   void (*stop)(struct seq_file *, void *) ;
   void *(*next)(struct seq_file *, void *, loff_t *) ;
   int (*show)(struct seq_file *, void *) ;
};

#line 222 
struct pinctrl;

#line 223 
struct pinctrl_state;

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ratelimit.h"
struct dma_map_ops;

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/device.h"
struct device_driver;

#line 16 
struct driver_private;

#line 17 
struct class;

#line 18 
struct subsys_private;

#line 19 
struct bus_type;

#line 20 
struct device_node;

#line 21 
struct fwnode_handle;

#line 23 
struct iommu_group;

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_attribute;

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct bus_type {
   char const *name ;
   char const *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group const **bus_groups ;
   struct attribute_group const **dev_groups ;
   struct attribute_group const **drv_groups ;
   int (*match)(struct device *, struct device_driver *) ;
   int (*uevent)(struct device *, struct kobj_uevent_env *) ;
   int (*probe)(struct device *) ;
   int (*remove)(struct device *) ;
   void (*shutdown)(struct device *) ;
   int (*online)(struct device *) ;
   int (*offline)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct dev_pm_ops const *pm ;
   struct iommu_ops const *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};

#line 139 
struct device_type;

#line 197 
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
};

#line 203  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_driver {
   char const *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id const *of_match_table ;
   struct acpi_device_id const *acpi_match_table ;
   int (*probe)(struct device *) ;
   int (*remove)(struct device *) ;
   void (*shutdown)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct attribute_group const **groups ;
   struct dev_pm_ops const *pm ;
   struct driver_private *p ;
};

#line 353 
struct class_attribute;

#line 353  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct class {
   char const *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group const **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *, struct kobj_uevent_env *) ;
   char *(*devnode)(struct device *, umode_t *) ;
   void (*class_release)(struct class *) ;
   void (*dev_release)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct kobj_ns_type_operations const *ns_type ;
   void const *(*namespace)(struct device *) ;
   struct dev_pm_ops const *pm ;
   struct subsys_private *p ;
};

#line 446  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *, struct class_attribute *, char *) ;
   ssize_t (*store)(struct class *, struct class_attribute *, char const *, size_t ) ;
};

#line 514  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_type {
   char const *name ;
   struct attribute_group const **groups ;
   int (*uevent)(struct device *, struct kobj_uevent_env *) ;
   char *(*devnode)(struct device *, umode_t *, kuid_t *, kgid_t *) ;
   void (*release)(struct device *) ;
   struct dev_pm_ops const *pm ;
};

#line 542  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *, struct device_attribute *, char *) ;
   ssize_t (*store)(struct device *, struct device_attribute *, char const *, size_t ) ;
};

#line 675  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};

#line 684 
struct dma_coherent_mem;

#line 684 
struct cma;

#line 684  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const *init_name ;
   struct device_type const *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group const **groups ;
   void (*release)(struct device *) ;
   struct iommu_group *iommu_group ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) offline_disabled : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) offline : 1 ;
};

#line 830  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct wakeup_source {
   char const *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) active : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) autosleep_enabled : 1 ;
};

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kmemleak.h"
struct kmem_cache;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;

#line 84  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};

#line 66 
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct __anonstruct_165 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct __anonstruct_166 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
union __anonunion_164 {
   struct __anonstruct_165 __anonCompField___anonunion_164_42 ;
   struct __anonstruct_166 __anonCompField___anonunion_164_43 ;
};

#line 73 
struct uprobe;

#line 73 
struct return_instance;

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion_164 __anonCompField_uprobe_task_44 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};

#line 94  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uprobes.h"
struct xol_area;

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};

#line 133 
struct address_space;

#line 134 
struct mem_cgroup;

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
typedef void compound_page_dtor(struct page *);

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_167 {
   struct address_space *mapping ;
   void *s_mem ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_169 {
   unsigned long index ;
   void *freelist ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_173 {
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) inuse : 16 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(15))) objects : 15 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) frozen : 1 ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_172 {
   atomic_t _mapcount ;
   struct __anonstruct_173 __anonCompField___anonunion_172_47 ;
   int units ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_171 {
   union __anonunion_172 __anonCompField___anonstruct_171_48 ;
   atomic_t _count ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_170 {
   unsigned long counters ;
   struct __anonstruct_171 __anonCompField___anonunion_170_49 ;
   unsigned int active ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_168 {
   union __anonunion_169 __anonCompField___anonstruct_168_46 ;
   union __anonunion_170 __anonCompField___anonstruct_168_50 ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_175 {
   struct page *next ;
   int pages ;
   int pobjects ;
};

#line 32 
struct slab;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_176 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_174 {
   struct list_head lru ;
   struct __anonstruct_175 __anonCompField___anonunion_174_52 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct_176 __anonCompField___anonunion_174_53 ;
   pgtable_t pmd_huge_pte ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_177 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion_167 __anonCompField_page_45 ;
   struct __anonstruct_168 __anonCompField_page_51 ;
   union __anonunion_174 __anonCompField_page_54 ;
   union __anonunion_177 __anonCompField_page_55 ;
   struct mem_cgroup *mem_cgroup ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_shared_178 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};

#line 257 
struct anon_vma;

#line 257 
struct mempolicy;

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_178 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct const *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};

#line 331  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};

#line 344  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};

#line 352  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};

#line 357 
struct kioctx_table;

#line 358 
struct linux_binfmt;

#line 358 
struct mmu_notifier_mm;

#line 358  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};

#line 4  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sem.h"
struct sem_undo_list;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};

#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/shm.h"
struct user_struct;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_180 {
   unsigned long sig[1U] ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_180 sigset_t;

#line 25 
struct siginfo;

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int );

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};

#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_182 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_183 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_184 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_185 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_187 {
   void *_lower ;
   void *_upper ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_186 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_187 _addr_bnd ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_188 {
   long _band ;
   int _fd ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_189 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_181 {
   int _pad[28U] ;
   struct __anonstruct__kill_182 _kill ;
   struct __anonstruct__timer_183 _timer ;
   struct __anonstruct__rt_184 _rt ;
   struct __anonstruct__sigchld_185 _sigchld ;
   struct __anonstruct__sigfault_186 _sigfault ;
   struct __anonstruct__sigpoll_188 _sigpoll ;
   struct __anonstruct__sigsys_189 _sigsys ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_181 _sifields ;
};

#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};

#line 243  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};

#line 443 
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
};

#line 450 
struct pid_namespace;

#line 450  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/seccomp.h"
struct seccomp_filter;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rtmutex.h"
struct rt_mutex {
   raw_spinlock_t wait_lock ;
   struct rb_root waiters ;
   struct rb_node *waiters_leftmost ;
   struct task_struct *owner ;
   int save_state ;
   char const *name ;
   char const *file ;
   int line ;
   void *magic ;
};

#line 40 
struct rt_mutex_waiter;

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/resource.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/latencytop.h"
struct assoc_array_ptr;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
typedef int32_t key_serial_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
typedef uint32_t key_perm_t;

#line 35 
struct key;

#line 36 
struct signal_struct;

#line 37 
struct cred;

#line 38 
struct key_type;

#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const *description ;
   size_t desc_len ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_196 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};

#line 123 
struct key_user;

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_197 {
   time_t expiry ;
   time_t revoked_at ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct __anonstruct_199 {
   struct key_type *type ;
   char *description ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_198 {
   struct keyring_index_key index_key ;
   struct __anonstruct_199 __anonCompField___anonunion_198_58 ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_type_data_200 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_payload_202 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_201 {
   union __anonunion_payload_202 payload ;
   struct assoc_array keys ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_196 __anonCompField_key_56 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_197 __anonCompField_key_57 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion_198 __anonCompField_key_59 ;
   union __anonunion_type_data_200 type_data ;
   union __anonunion_201 __anonCompField_key_60 ;
};

#line 358 
struct audit_context;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};

#line 369 
struct percpu_ref;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref *);

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) force_atomic : 1 ;
   struct callback_head rcu ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-rwsem.h"
struct cgroup;

#line 28 
struct cgroup_root;

#line 29 
struct cgroup_subsys;

#line 30 
struct cgroup_taskset;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-rwsem.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};

#line 197  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};

#line 270  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};

#line 306  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state *, struct cftype *) ;
   s64 (*read_s64)(struct cgroup_subsys_state *, struct cftype *) ;
   int (*seq_show)(struct seq_file *, void *) ;
   void *(*seq_start)(struct seq_file *, loff_t *) ;
   void *(*seq_next)(struct seq_file *, void *, loff_t *) ;
   void (*seq_stop)(struct seq_file *, void *) ;
   int (*write_u64)(struct cgroup_subsys_state *, struct cftype *, u64 ) ;
   int (*write_s64)(struct cgroup_subsys_state *, struct cftype *, s64 ) ;
   ssize_t (*write)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   struct lock_class_key lockdep_key ;
};

#line 388  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state *) ;
   int (*css_online)(struct cgroup_subsys_state *) ;
   void (*css_offline)(struct cgroup_subsys_state *) ;
   void (*css_released)(struct cgroup_subsys_state *) ;
   void (*css_free)(struct cgroup_subsys_state *) ;
   void (*css_reset)(struct cgroup_subsys_state *) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state *) ;
   int (*can_attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*cancel_attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*fork)(struct task_struct *) ;
   void (*exit)(struct cgroup_subsys_state *, struct cgroup_subsys_state *, struct task_struct *) ;
   void (*bind)(struct cgroup_subsys_state *) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};

#line 128  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct futex_pi_state;

#line 129 
struct robust_list_head;

#line 130 
struct bio_list;

#line 131 
struct fs_struct;

#line 132 
struct perf_event_context;

#line 133 
struct blk_plug;

#line 135 
struct nameidata;

#line 188 
struct cfs_rq;

#line 189 
struct task_group;

#line 477  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};

#line 516  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};

#line 524  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};

#line 531  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};

#line 543  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};

#line 563  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};

#line 584  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};

#line 620 
struct autogroup;

#line 621 
struct tty_struct;

#line 621 
struct taskstats;

#line 621 
struct tty_audit_buf;

#line 621  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_child_subreaper : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};

#line 802  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};

#line 845 
struct backing_dev_info;

#line 846 
struct reclaim_state;

#line 847  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};

#line 861  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};

#line 909  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};

#line 1138 
struct io_context;

#line 1172 
struct pipe_inode_info;

#line 1173 
struct uts_namespace;

#line 1174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};

#line 1181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};

#line 1206  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};

#line 1241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};

#line 1273 
struct rt_rq;

#line 1273  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};

#line 1289  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};

#line 1355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) may_oom : 1 ;
};

#line 1779 
struct sched_class;

#line 1779 
struct files_struct;

#line 1779 
struct compat_robust_list_head;

#line 1779 
struct numa_group;

#line 1779 
struct ftrace_ret_stack;

#line 1779  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_struct {
   long volatile state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class const *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_execve : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_iowait : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_reset_on_fork : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_contributes_to_load : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_migrated : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) memcg_kmem_skip_account : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred const *real_cred ;
   struct cred const *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void *) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
   struct thread_struct thread ;
};

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/resource_ext.h"
struct hotplug_slot;

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/resource_ext.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef int pci_power_t;

#line 137  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned int pci_channel_state_t;

#line 138 
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
};

#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;

#line 192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;

#line 249 
struct pcie_link_state;

#line 250 
struct pci_vpd;

#line 251 
struct pci_sriov;

#line 252 
struct pci_ats;

#line 253 
struct pci_driver;

#line 253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
union __anonunion_217 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};

#line 253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   u8 dma_alias_devfn ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(5))) pme_support : 5 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pme_interrupt : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pme_poll : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d1_support : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d2_support : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_d1d2 : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_d3cold : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d3cold_allowed : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) mmio_always_on : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wakeup_prepared : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) runtime_d3cold : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_hotplug : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) transparent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) multifunction : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_added : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_busmaster : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_msi : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_64bit_msi : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) block_cfg_access : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) broken_parity_status : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) irq_reroute_variant : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) msi_enabled : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) msix_enabled : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ari_enabled : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_managed : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) needs_freset : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_saved : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_physfn : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_virtfn : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) reset_fn : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_hotplug_bridge : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) __aer_firmware_first_valid : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) __aer_firmware_first : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) broken_intx_masking : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) io_window_1k : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) irq_managed : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) has_secondary_link : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct attribute_group const **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion_217 __anonCompField_pci_dev_64 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
};

#line 442 
struct pci_ops;

#line 442 
struct msi_controller;

#line 442  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_controller *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_added : 1 ;
};

#line 565  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_ops {
   void *(*map_bus)(struct pci_bus *, unsigned int , int ) ;
   int (*read)(struct pci_bus *, unsigned int , int , int , u32 *) ;
   int (*write)(struct pci_bus *, unsigned int , int , int , u32 ) ;
};

#line 593  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};

#line 607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned int pci_ers_result_t;

#line 617  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev *, enum pci_channel_state ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev *) ;
   pci_ers_result_t (*link_reset)(struct pci_dev *) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev *) ;
   void (*reset_notify)(struct pci_dev *, bool ) ;
   void (*resume)(struct pci_dev *) ;
};

#line 650  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const *name ;
   struct pci_device_id const *id_table ;
   int (*probe)(struct pci_dev *, struct pci_device_id const *) ;
   void (*remove)(struct pci_dev *) ;
   int (*suspend)(struct pci_dev *, pm_message_t ) ;
   int (*suspend_late)(struct pci_dev *, pm_message_t ) ;
   int (*resume_early)(struct pci_dev *) ;
   int (*resume)(struct pci_dev *) ;
   void (*shutdown)(struct pci_dev *) ;
   int (*sriov_configure)(struct pci_dev *, int ) ;
   struct pci_error_handlers const *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker *, struct shrink_control *) ;
   unsigned long (*scan_objects)(struct shrinker *, struct shrink_control *) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/page_ext.h"
struct file_ra_state;

#line 65 
struct writeback_control;

#line 66 
struct bdi_writeback;

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};

#line 239  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *) ;
   void (*close)(struct vm_area_struct *) ;
   int (*fault)(struct vm_area_struct *, struct vm_fault *) ;
   void (*map_pages)(struct vm_area_struct *, struct vm_fault *) ;
   int (*page_mkwrite)(struct vm_area_struct *, struct vm_fault *) ;
   int (*pfn_mkwrite)(struct vm_area_struct *, struct vm_fault *) ;
   int (*access)(struct vm_area_struct *, unsigned long , void *, int , int ) ;
   char const *(*name)(struct vm_area_struct *) ;
   int (*set_policy)(struct vm_area_struct *, struct mempolicy *) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct *, unsigned long ) ;
   struct page *(*find_special_page)(struct vm_area_struct *, unsigned long ) ;
};

#line 1249 
struct kvec;

#line 2291  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pci_64.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
};

#line 77  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-attrs.h"
struct dma_map_ops {
   void *(*alloc)(struct device *, size_t , dma_addr_t *, gfp_t , struct dma_attrs *) ;
   void (*free)(struct device *, size_t , void *, dma_addr_t , struct dma_attrs *) ;
   int (*mmap)(struct device *, struct vm_area_struct *, void *, dma_addr_t , size_t , struct dma_attrs *) ;
   int (*get_sgtable)(struct device *, struct sg_table *, void *, dma_addr_t , size_t , struct dma_attrs *) ;
   dma_addr_t (*map_page)(struct device *, struct page *, unsigned long , size_t , enum dma_data_direction , struct dma_attrs *) ;
   void (*unmap_page)(struct device *, dma_addr_t , size_t , enum dma_data_direction , struct dma_attrs *) ;
   int (*map_sg)(struct device *, struct scatterlist *, int , enum dma_data_direction , struct dma_attrs *) ;
   void (*unmap_sg)(struct device *, struct scatterlist *, int , enum dma_data_direction , struct dma_attrs *) ;
   void (*sync_single_for_cpu)(struct device *, dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_single_for_device)(struct device *, dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_sg_for_cpu)(struct device *, struct scatterlist *, int , enum dma_data_direction ) ;
   void (*sync_sg_for_device)(struct device *, struct scatterlist *, int , enum dma_data_direction ) ;
   int (*mapping_error)(struct device *, dma_addr_t ) ;
   int (*dma_supported)(struct device *, u64 ) ;
   int (*set_dma_mask)(struct device *, u64 ) ;
   int is_phys ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;

#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};

#line 198  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elf.h"
struct kernel_param;

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elf.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const *, struct kernel_param const *) ;
   int (*get)(char *, struct kernel_param const *) ;
   void (*free)(void *) ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_string;

#line 62 
struct kparam_array;

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
union __anonunion_222 {
   void *arg ;
   struct kparam_string const *str ;
   struct kparam_array const *arr ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kernel_param {
   char const *name ;
   struct module *mod ;
   struct kernel_param_ops const *ops ;
   u16 const perm ;
   s8 level ;
   u8 flags ;
   union __anonunion_222 __anonCompField_kernel_param_65 ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops const *ops ;
   void *elem ;
};

#line 469  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rbtree_latch.h"
struct mod_arch_specific {
   
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_param_attrs;

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute *, struct module_kobject *, char *) ;
   ssize_t (*store)(struct module_attribute *, struct module_kobject *, char const *, size_t ) ;
   void (*setup)(struct module *, char const *) ;
   int (*test)(struct module *) ;
   void (*free)(struct module *) ;
};

#line 290 
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
};

#line 297  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};

#line 304 
struct module_sect_attrs;

#line 304 
struct module_notes_attrs;

#line 304 
struct tracepoint;

#line 304 
struct trace_event_call;

#line 304 
struct trace_enum_map;

#line 304  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const *version ;
   char const *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol const *syms ;
   unsigned long const *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol const *gpl_syms ;
   unsigned long const *gpl_crcs ;
   struct kernel_symbol const *unused_syms ;
   unsigned long const *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol const *unused_gpl_syms ;
   unsigned long const *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol const *gpl_future_syms ;
   unsigned long const *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const *tracepoints_ptrs ;
   struct jump_entry *jump_entries ;
   unsigned int num_jump_entries ;
   unsigned int num_trace_bprintk_fmt ;
   char const **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/prefetch.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uio.h"
union __anonunion_229 {
   struct iovec const *iov ;
   struct kvec const *kvec ;
   struct bio_vec const *bvec ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion_229 __anonCompField_iov_iter_66 ;
   unsigned long nr_segs ;
};

#line 1182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dmaengine.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};

#line 38 
struct kiocb;

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iov_iter msg_iter ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
   struct kiocb *msg_iocb ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_231 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_231 sync_serial_settings;

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_232 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_232 te1_settings;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_233 {
   unsigned short encoding ;
   unsigned short parity ;
};

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_233 raw_hdlc_proto;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_234 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_234 fr_proto;

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_235 {
   unsigned int dlci ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_235 fr_proto_pvc;

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_236 {
   unsigned int dlci ;
   char master[16U] ;
};

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_236 fr_proto_pvc_info;

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_237 {
   unsigned int interval ;
   unsigned int timeout ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_237 cisco_proto;

#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_238 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_238 ifs_ifsu ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_239 {
   char ifrn_name[16U] ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifr_ifru_240 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_239 ifr_ifrn ;
   union __anonunion_ifr_ifru_240 ifr_ifru ;
};

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kdev_t.h"
struct hlist_bl_node;

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kdev_t.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
struct __anonstruct_245 {
   spinlock_t lock ;
   int count ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
union __anonunion_244 {
   struct __anonstruct_245 __anonCompField___anonunion_244_67 ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
struct lockref {
   union __anonunion_244 __anonCompField_lockref_68 ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct vfsmount;

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct __anonstruct_247 {
   u32 hash ;
   u32 len ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
union __anonunion_246 {
   struct __anonstruct_247 __anonCompField___anonunion_246_69 ;
   u64 hash_len ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct qstr {
   union __anonunion_246 __anonCompField_qstr_70 ;
   unsigned char const *name ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry_operations;

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
union __anonunion_d_u_248 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations const *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_248 d_u ;
};

#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry *, unsigned int ) ;
   int (*d_weak_revalidate)(struct dentry *, unsigned int ) ;
   int (*d_hash)(struct dentry const *, struct qstr *) ;
   int (*d_compare)(struct dentry const *, struct dentry const *, unsigned int , char const *, struct qstr const *) ;
   int (*d_delete)(struct dentry const *) ;
   void (*d_release)(struct dentry *) ;
   void (*d_prune)(struct dentry *) ;
   void (*d_iput)(struct dentry *, struct inode *) ;
   char *(*d_dname)(struct dentry *, char *, int ) ;
   struct vfsmount *(*d_automount)(struct path *) ;
   int (*d_manage)(struct dentry *, bool ) ;
   struct inode *(*d_select_inode)(struct dentry *, unsigned int ) ;
};

#line 586  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/path.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};

#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct __anonstruct_252 {
   struct radix_tree_node *parent ;
   void *private_data ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
union __anonunion_251 {
   struct __anonstruct_252 __anonCompField___anonunion_251_71 ;
   struct callback_head callback_head ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion_251 __anonCompField_radix_tree_node_72 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
};

#line 47 
struct block_device;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/fs.h"
struct export_operations;

#line 62 
struct poll_table_struct;

#line 63 
struct kstatfs;

#line 64 
struct swap_info_struct;

#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};

#line 212  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dqblk_xfs.h"
struct dquot;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
typedef __kernel_uid32_t projid_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
struct __anonstruct_kprojid_t_256 {
   projid_t val ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_256 kprojid_t;

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
typedef long long qsize_t;

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
union __anonunion_257 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct kqid {
   union __anonunion_257 __anonCompField_kqid_74 ;
   enum quota_type type ;
};

#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};

#line 206 
struct quota_format_type;

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};

#line 272  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};

#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *, int ) ;
   int (*read_file_info)(struct super_block *, int ) ;
   int (*write_file_info)(struct super_block *, int ) ;
   int (*free_file_info)(struct super_block *, int ) ;
   int (*read_dqblk)(struct dquot *) ;
   int (*commit_dqblk)(struct dquot *) ;
   int (*release_dqblk)(struct dquot *) ;
};

#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot *) ;
   struct dquot *(*alloc_dquot)(struct super_block *, int ) ;
   void (*destroy_dquot)(struct dquot *) ;
   int (*acquire_dquot)(struct dquot *) ;
   int (*release_dquot)(struct dquot *) ;
   int (*mark_dirty)(struct dquot *) ;
   int (*write_info)(struct super_block *, int ) ;
   qsize_t *(*get_reserved_space)(struct inode *) ;
   int (*get_projid)(struct inode *, kprojid_t *) ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};

#line 348  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};

#line 394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};

#line 405  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};

#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block *, int , int , struct path *) ;
   int (*quota_off)(struct super_block *, int ) ;
   int (*quota_enable)(struct super_block *, unsigned int ) ;
   int (*quota_disable)(struct super_block *, unsigned int ) ;
   int (*quota_sync)(struct super_block *, int ) ;
   int (*set_info)(struct super_block *, int , struct qc_info *) ;
   int (*get_dqblk)(struct super_block *, struct kqid , struct qc_dqblk *) ;
   int (*set_dqblk)(struct super_block *, struct kqid , struct qc_dqblk *) ;
   int (*get_state)(struct super_block *, struct qc_state *) ;
   int (*rm_xquota)(struct super_block *, unsigned int ) ;
};

#line 432  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops const *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};

#line 496  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops const *ops[3U] ;
};

#line 526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb *, long , long ) ;
   void *private ;
   int ki_flags ;
};

#line 366  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page *, struct writeback_control *) ;
   int (*readpage)(struct file *, struct page *) ;
   int (*writepages)(struct address_space *, struct writeback_control *) ;
   int (*set_page_dirty)(struct page *) ;
   int (*readpages)(struct file *, struct address_space *, struct list_head *, unsigned int ) ;
   int (*write_begin)(struct file *, struct address_space *, loff_t , unsigned int , unsigned int , struct page **, void **) ;
   int (*write_end)(struct file *, struct address_space *, loff_t , unsigned int , unsigned int , struct page *, void *) ;
   sector_t (*bmap)(struct address_space *, sector_t ) ;
   void (*invalidatepage)(struct page *, unsigned int , unsigned int ) ;
   int (*releasepage)(struct page *, gfp_t ) ;
   void (*freepage)(struct page *) ;
   ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *, loff_t ) ;
   int (*migratepage)(struct address_space *, struct page *, struct page *, enum migrate_mode ) ;
   int (*launder_page)(struct page *) ;
   int (*is_partially_uptodate)(struct page *, unsigned long , unsigned long ) ;
   void (*is_dirty_writeback)(struct page *, bool *, bool *) ;
   int (*error_remove_page)(struct address_space *, struct page *) ;
   int (*swap_activate)(struct swap_info_struct *, struct file *, sector_t *) ;
   void (*swap_deactivate)(struct file *) ;
};

#line 423  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations const *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};

#line 443 
struct request_queue;

#line 444 
struct hd_struct;

#line 444 
struct gendisk;

#line 444  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};

#line 560 
struct posix_acl;

#line 561 
struct inode_operations;

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_260 {
   unsigned int const i_nlink ;
   unsigned int __i_nlink ;
};

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_261 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};

#line 561 
struct file_lock_context;

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_262 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations const *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_260 __anonCompField_inode_75 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_261 __anonCompField_inode_76 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations const *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion_262 __anonCompField_inode_77 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};

#line 807  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};

#line 815  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};

#line 838  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_f_u_263 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};

#line 838  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file {
   union __anonunion_f_u_263 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations const *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred const *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};

#line 923  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
typedef void *fl_owner_t;

#line 924 
struct file_lock;

#line 925  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock *, struct file_lock *) ;
   void (*fl_release_private)(struct file_lock *) ;
};

#line 931  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock *, struct file_lock *) ;
   unsigned long (*lm_owner_key)(struct file_lock *) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t ) ;
   void (*lm_put_owner)(fl_owner_t ) ;
   void (*lm_notify)(struct file_lock *) ;
   int (*lm_grant)(struct file_lock *, int ) ;
   bool (*lm_break)(struct file_lock *) ;
   int (*lm_change)(struct file_lock *, int , struct list_head *) ;
   void (*lm_setup)(struct file_lock *, void **) ;
};

#line 947 
struct net;

#line 952 
struct nlm_lockowner;

#line 953  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct nfs4_lock_state;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};

#line 19 
struct fasync_struct;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct __anonstruct_afs_265 {
   struct list_head link ;
   int state ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
union __anonunion_fl_u_264 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_265 afs ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations const *fl_ops ;
   struct lock_manager_operations const *fl_lmops ;
   union __anonunion_fl_u_264 fl_u ;
};

#line 1005  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};

#line 1221  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};

#line 1256  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};

#line 1287 
struct super_operations;

#line 1287 
struct xattr_handler;

#line 1287 
struct mtd_info;

#line 1287  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations const *s_op ;
   struct dquot_operations const *dq_op ;
   struct quotactl_ops const *s_qcop ;
   struct export_operations const *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler const **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations const *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};

#line 1526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};

#line 1540 
struct dir_context;

#line 1565  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context *, char const *, int , loff_t , u64 , unsigned int ) ;
   loff_t pos ;
};

#line 1572  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file *, loff_t , int ) ;
   ssize_t (*read)(struct file *, char *, size_t , loff_t *) ;
   ssize_t (*write)(struct file *, char const *, size_t , loff_t *) ;
   ssize_t (*read_iter)(struct kiocb *, struct iov_iter *) ;
   ssize_t (*write_iter)(struct kiocb *, struct iov_iter *) ;
   int (*iterate)(struct file *, struct dir_context *) ;
   unsigned int (*poll)(struct file *, struct poll_table_struct *) ;
   long (*unlocked_ioctl)(struct file *, unsigned int , unsigned long ) ;
   long (*compat_ioctl)(struct file *, unsigned int , unsigned long ) ;
   int (*mmap)(struct file *, struct vm_area_struct *) ;
   int (*mremap)(struct file *, struct vm_area_struct *) ;
   int (*open)(struct inode *, struct file *) ;
   int (*flush)(struct file *, fl_owner_t ) ;
   int (*release)(struct inode *, struct file *) ;
   int (*fsync)(struct file *, loff_t , loff_t , int ) ;
   int (*aio_fsync)(struct kiocb *, int ) ;
   int (*fasync)(int , struct file *, int ) ;
   int (*lock)(struct file *, int , struct file_lock *) ;
   ssize_t (*sendpage)(struct file *, struct page *, int , size_t , loff_t *, int ) ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   int (*check_flags)(int ) ;
   int (*flock)(struct file *, int , struct file_lock *) ;
   ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ) ;
   ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ) ;
   int (*setlease)(struct file *, long , struct file_lock **, void **) ;
   long (*fallocate)(struct file *, int , loff_t , loff_t ) ;
   void (*show_fdinfo)(struct seq_file *, struct file *) ;
};

#line 1633  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode *, struct dentry *, unsigned int ) ;
   char const *(*follow_link)(struct dentry *, void **) ;
   int (*permission)(struct inode *, int ) ;
   struct posix_acl *(*get_acl)(struct inode *, int ) ;
   int (*readlink)(struct dentry *, char *, int ) ;
   void (*put_link)(struct inode *, void *) ;
   int (*create)(struct inode *, struct dentry *, umode_t , bool ) ;
   int (*link)(struct dentry *, struct inode *, struct dentry *) ;
   int (*unlink)(struct inode *, struct dentry *) ;
   int (*symlink)(struct inode *, struct dentry *, char const *) ;
   int (*mkdir)(struct inode *, struct dentry *, umode_t ) ;
   int (*rmdir)(struct inode *, struct dentry *) ;
   int (*mknod)(struct inode *, struct dentry *, umode_t , dev_t ) ;
   int (*rename)(struct inode *, struct dentry *, struct inode *, struct dentry *) ;
   int (*rename2)(struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int ) ;
   int (*setattr)(struct dentry *, struct iattr *) ;
   int (*getattr)(struct vfsmount *, struct dentry *, struct kstat *) ;
   int (*setxattr)(struct dentry *, char const *, void const *, size_t , int ) ;
   ssize_t (*getxattr)(struct dentry *, char const *, void *, size_t ) ;
   ssize_t (*listxattr)(struct dentry *, char *, size_t ) ;
   int (*removexattr)(struct dentry *, char const *) ;
   int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 , u64 ) ;
   int (*update_time)(struct inode *, struct timespec *, int ) ;
   int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned int , umode_t , int *) ;
   int (*tmpfile)(struct inode *, struct dentry *, umode_t ) ;
   int (*set_acl)(struct inode *, struct posix_acl *, int ) ;
};

#line 1687  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *) ;
   void (*destroy_inode)(struct inode *) ;
   void (*dirty_inode)(struct inode *, int ) ;
   int (*write_inode)(struct inode *, struct writeback_control *) ;
   int (*drop_inode)(struct inode *) ;
   void (*evict_inode)(struct inode *) ;
   void (*put_super)(struct super_block *) ;
   int (*sync_fs)(struct super_block *, int ) ;
   int (*freeze_super)(struct super_block *) ;
   int (*freeze_fs)(struct super_block *) ;
   int (*thaw_super)(struct super_block *) ;
   int (*unfreeze_fs)(struct super_block *) ;
   int (*statfs)(struct dentry *, struct kstatfs *) ;
   int (*remount_fs)(struct super_block *, int *, char *) ;
   void (*umount_begin)(struct super_block *) ;
   int (*show_options)(struct seq_file *, struct dentry *) ;
   int (*show_devname)(struct seq_file *, struct dentry *) ;
   int (*show_path)(struct seq_file *, struct dentry *) ;
   int (*show_stats)(struct seq_file *, struct dentry *) ;
   ssize_t (*quota_read)(struct super_block *, int , char *, size_t , loff_t ) ;
   ssize_t (*quota_write)(struct super_block *, int , char const *, size_t , loff_t ) ;
   struct dquot **(*get_dquots)(struct inode *) ;
   int (*bdev_try_to_free_page)(struct super_block *, struct page *, gfp_t ) ;
   long (*nr_cached_objects)(struct super_block *, struct shrink_control *) ;
   long (*free_cached_objects)(struct super_block *, struct shrink_control *) ;
};

#line 1926  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_system_type {
   char const *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type *, int , char const *, void *) ;
   void (*kill_sb)(struct super_block *) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};

#line 276  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};

#line 280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/random.h"
enum ldv_27016 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/net.h"
typedef enum ldv_27016 socket_state;

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/net.h"
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   struct callback_head rcu ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct proto_ops;

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct socket_wq *wq ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops const *ops ;
};

#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket *) ;
   int (*bind)(struct socket *, struct sockaddr *, int ) ;
   int (*connect)(struct socket *, struct sockaddr *, int , int ) ;
   int (*socketpair)(struct socket *, struct socket *) ;
   int (*accept)(struct socket *, struct socket *, int ) ;
   int (*getname)(struct socket *, struct sockaddr *, int *, int ) ;
   unsigned int (*poll)(struct file *, struct socket *, struct poll_table_struct *) ;
   int (*ioctl)(struct socket *, unsigned int , unsigned long ) ;
   int (*compat_ioctl)(struct socket *, unsigned int , unsigned long ) ;
   int (*listen)(struct socket *, int ) ;
   int (*shutdown)(struct socket *, int ) ;
   int (*setsockopt)(struct socket *, int , int , char *, unsigned int ) ;
   int (*getsockopt)(struct socket *, int , int , char *, int *) ;
   int (*compat_setsockopt)(struct socket *, int , int , char *, unsigned int ) ;
   int (*compat_getsockopt)(struct socket *, int , int , char *, int *) ;
   int (*sendmsg)(struct socket *, struct msghdr *, size_t ) ;
   int (*recvmsg)(struct socket *, struct msghdr *, size_t , int ) ;
   int (*mmap)(struct file *, struct socket *, struct vm_area_struct *) ;
   ssize_t (*sendpage)(struct socket *, struct page *, int , size_t , int ) ;
   ssize_t (*splice_read)(struct socket *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ) ;
   int (*set_peek_off)(struct sock *, int ) ;
};

#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/checksum_64.h"
struct in6_addr;

#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/checksum.h"
struct sk_buff;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
typedef u64 netdev_features_t;

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
union __anonunion_in6_u_280 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
struct in6_addr {
   union __anonunion_in6_u_280 in6_u ;
};

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/in6.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow_dissector.h"
struct pipe_buf_operations;

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow_dissector.h"
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
   struct pipe_buf_operations const *ops ;
   unsigned int flags ;
   unsigned long private ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pipe_fs_i.h"
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int nrbufs ;
   unsigned int curbuf ;
   unsigned int buffers ;
   unsigned int readers ;
   unsigned int writers ;
   unsigned int files ;
   unsigned int waiting_writers ;
   unsigned int r_counter ;
   unsigned int w_counter ;
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pipe_fs_i.h"
struct pipe_buf_operations {
   int can_merge ;
   int (*confirm)(struct pipe_inode_info *, struct pipe_buffer *) ;
   void (*release)(struct pipe_inode_info *, struct pipe_buffer *) ;
   int (*steal)(struct pipe_inode_info *, struct pipe_buffer *) ;
   void (*get)(struct pipe_inode_info *, struct pipe_buffer *) ;
};

#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/splice.h"
struct napi_struct;

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/splice.h"
struct nf_conntrack {
   atomic_t use ;
};

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
enum ldv_27417 {
    BRNF_PROTO_UNCHANGED = 0,
    BRNF_PROTO_8021Q = 1,
    BRNF_PROTO_PPPOE = 2
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_285 {
   struct net_device *physoutdev ;
   char neigh_header[8U] ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_286 {
   __be32 ipv4_daddr ;
   struct in6_addr ipv6_daddr ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   enum ldv_27417 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) orig_proto : 8 ;
   bool pkt_otherhost ;
   __u16 frag_max_size ;
   unsigned int mask ;
   struct net_device *physindev ;
   union __anonunion_285 __anonCompField_nf_bridge_info_81 ;
   union __anonunion_286 __anonCompField_nf_bridge_info_82 ;
};

#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};

#line 403  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_289 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_288 {
   u64 v64 ;
   struct __anonstruct_289 __anonCompField___anonunion_288_83 ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_mstamp {
   union __anonunion_288 __anonCompField_skb_mstamp_84 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_292 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_291 {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion_292 __anonCompField___anonstruct_291_85 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_290 {
   struct __anonstruct_291 __anonCompField___anonunion_290_86 ;
   struct rb_node rbnode ;
};

#line 457 
struct sec_path;

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_294 {
   __u16 csum_start ;
   __u16 csum_offset ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_293 {
   __wsum csum ;
   struct __anonstruct_294 __anonCompField___anonunion_293_88 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_295 {
   unsigned int napi_id ;
   unsigned int sender_cpu ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_296 {
   __u32 mark ;
   __u32 reserved_tailroom ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_297 {
   __be16 inner_protocol ;
   __u8 inner_ipproto ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct sk_buff {
   union __anonunion_290 __anonCompField_sk_buff_87 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   void (*destructor)(struct sk_buff *) ;
   struct sec_path *sp ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   __u16 queue_mapping ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cloned : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) nohdr : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) fclone : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) peeked : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) head_frag : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) xmit_more : 1 ;
   __u32 headers_start[0U] ;
   __u8 __pkt_type_offset[0U] ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) pkt_type : 3 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pfmemalloc : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_df : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) nfctinfo : 3 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) nf_trace : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) ip_summed : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ooo_okay : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) l4_hash : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sw_hash : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wifi_acked_valid : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wifi_acked : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_fcs : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) encapsulation : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) encap_hdr_csum : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_valid : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_complete_sw : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) csum_level : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_bad : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) ndisc_nodetype : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ipvs_property : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) inner_protocol_type : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) remcsum_offload : 1 ;
   __u16 tc_index ;
   __u16 tc_verd ;
   union __anonunion_293 __anonCompField_sk_buff_89 ;
   __u32 priority ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   union __anonunion_295 __anonCompField_sk_buff_90 ;
   __u32 secmark ;
   union __anonunion_296 __anonCompField_sk_buff_91 ;
   union __anonunion_297 __anonCompField_sk_buff_92 ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __be16 protocol ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   __u32 headers_end[0U] ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};

#line 718 
struct dst_entry;

#line 767 
struct rtable;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_ether.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};

#line 125  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char erom_version[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};

#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};

#line 233  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_tunable {
   __u32 cmd ;
   __u32 id ;
   __u32 type_id ;
   __u32 len ;
   void *data[0U] ;
};

#line 245  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 267  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 293  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};

#line 322  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};

#line 438  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};

#line 475  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};

#line 503  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};

#line 605  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};

#line 637  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};

#line 679  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};

#line 712  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};

#line 728  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};

#line 748  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};

#line 759  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};

#line 778  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};

#line 828  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};

#line 999  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};

#line 1007  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 1083  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
};

#line 99  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device *, struct ethtool_cmd *) ;
   int (*set_settings)(struct net_device *, struct ethtool_cmd *) ;
   void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *) ;
   int (*get_regs_len)(struct net_device *) ;
   void (*get_regs)(struct net_device *, struct ethtool_regs *, void *) ;
   void (*get_wol)(struct net_device *, struct ethtool_wolinfo *) ;
   int (*set_wol)(struct net_device *, struct ethtool_wolinfo *) ;
   u32 (*get_msglevel)(struct net_device *) ;
   void (*set_msglevel)(struct net_device *, u32 ) ;
   int (*nway_reset)(struct net_device *) ;
   u32 (*get_link)(struct net_device *) ;
   int (*get_eeprom_len)(struct net_device *) ;
   int (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_coalesce)(struct net_device *, struct ethtool_coalesce *) ;
   int (*set_coalesce)(struct net_device *, struct ethtool_coalesce *) ;
   void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *) ;
   int (*set_ringparam)(struct net_device *, struct ethtool_ringparam *) ;
   void (*get_pauseparam)(struct net_device *, struct ethtool_pauseparam *) ;
   int (*set_pauseparam)(struct net_device *, struct ethtool_pauseparam *) ;
   void (*self_test)(struct net_device *, struct ethtool_test *, u64 *) ;
   void (*get_strings)(struct net_device *, u32 , u8 *) ;
   int (*set_phys_id)(struct net_device *, enum ethtool_phys_id_state ) ;
   void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *, u64 *) ;
   int (*begin)(struct net_device *) ;
   void (*complete)(struct net_device *) ;
   u32 (*get_priv_flags)(struct net_device *) ;
   int (*set_priv_flags)(struct net_device *, u32 ) ;
   int (*get_sset_count)(struct net_device *, int ) ;
   int (*get_rxnfc)(struct net_device *, struct ethtool_rxnfc *, u32 *) ;
   int (*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *) ;
   int (*flash_device)(struct net_device *, struct ethtool_flash *) ;
   int (*reset)(struct net_device *, u32 *) ;
   u32 (*get_rxfh_key_size)(struct net_device *) ;
   u32 (*get_rxfh_indir_size)(struct net_device *) ;
   int (*get_rxfh)(struct net_device *, u32 *, u8 *, u8 *) ;
   int (*set_rxfh)(struct net_device *, u32 const *, u8 const *, u8 const ) ;
   void (*get_channels)(struct net_device *, struct ethtool_channels *) ;
   int (*set_channels)(struct net_device *, struct ethtool_channels *) ;
   int (*get_dump_flag)(struct net_device *, struct ethtool_dump *) ;
   int (*get_dump_data)(struct net_device *, struct ethtool_dump *, void *) ;
   int (*set_dump)(struct net_device *, struct ethtool_dump *) ;
   int (*get_ts_info)(struct net_device *, struct ethtool_ts_info *) ;
   int (*get_module_info)(struct net_device *, struct ethtool_modinfo *) ;
   int (*get_module_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_eee)(struct net_device *, struct ethtool_eee *) ;
   int (*set_eee)(struct net_device *, struct ethtool_eee *) ;
   int (*get_tunable)(struct net_device *, struct ethtool_tunable const *, void *) ;
   int (*set_tunable)(struct net_device *, struct ethtool_tunable const *, void const *) ;
};

#line 235  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow.h"
struct prot_inuse;

#line 236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct u64_stats_sync {
   
};

#line 146  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6_mib_device {
   atomic_long_t mibs[6U] ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6msg_mib_device {
   atomic_long_t mibs[512U] ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};

#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[9U] ;
};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[115U] ;
};

#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/packet.h"
struct netns_frags {
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};

#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_frag.h"
struct ipv4_devconf;

#line 185 
struct fib_rules_ops;

#line 186 
struct fib_table;

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
   bool warned ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};

#line 29 
struct inet_peer_base;

#line 29 
struct xt_table;

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   bool fib_offload_disabled ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct inet_peer_base *peers ;
   struct sock **tcp_sk ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_tcp_ecn_fallback ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_ip_nonlocal_bind ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   int sysctl_tcp_mtu_probing ;
   int sysctl_tcp_base_mss ;
   int sysctl_tcp_probe_threshold ;
   u32 sysctl_tcp_probe_interval ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};

#line 113 
struct neighbour;

#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops *) ;
   struct dst_entry *(*check)(struct dst_entry *, __u32 ) ;
   unsigned int (*default_advmss)(struct dst_entry const *) ;
   unsigned int (*mtu)(struct dst_entry const *) ;
   u32 *(*cow_metrics)(struct dst_entry *, unsigned long ) ;
   void (*destroy)(struct dst_entry *) ;
   void (*ifdown)(struct dst_entry *, struct net_device *, int ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry *) ;
   void (*link_failure)(struct sk_buff *) ;
   void (*update_pmtu)(struct dst_entry *, struct sock *, struct sk_buff *, u32 ) ;
   void (*redirect)(struct dst_entry *, struct sock *, struct sk_buff *) ;
   int (*local_out)(struct sk_buff *) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry const *, struct sk_buff *, void const *) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int auto_flowlabels ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
   int idgen_retries ;
   int idgen_delay ;
   int flowlabel_state_ranges ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct ipv6_devconf;

#line 39 
struct rt6_info;

#line 39 
struct rt6_statistics;

#line 39 
struct fib6_table;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t fib6_sernum ;
};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
};

#line 20 
struct sctp_mib;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ieee802154_6lowpan.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netfilter.h"
struct nf_logger;

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger const *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/netfilter.h"
struct ebt_table;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   bool clusterip_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_node;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
};

#line 72 
struct ip_conntrack_stat;

#line 72 
struct nf_ct_event_notifier;

#line 72 
struct nf_exp_event_notifier;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct delayed_work ecache_dwork ;
   bool ecache_dwork_pending ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};

#line 114 
struct nft_af_info;

#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   struct nft_af_info *netdev ;
   unsigned int base_seq ;
   u8 gencursor ;
};

#line 508  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/xfrm.h"
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flowcache.h"
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flowcache.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
   u8 dbits4 ;
   u8 sbits4 ;
   u8 dbits6 ;
   u8 sbits6 ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct xfrm_policy_hthresh {
   struct work_struct work ;
   seqlock_t lock ;
   u8 lbits4 ;
   u8 rbits4 ;
   u8 lbits6 ;
   u8 rbits6 ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[3U] ;
   struct xfrm_policy_hash policy_bydst[3U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct xfrm_policy_hthresh policy_hthresh ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};

#line 88 
struct mpls_route;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct netns_mpls {
   size_t platform_labels ;
   struct mpls_route **platform_label ;
   struct ctl_table_header *ctl ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mpls.h"
struct proc_ns_operations;

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mpls.h"
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations const *ops ;
   unsigned int inum ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ns_common.h"
struct net_generic;

#line 12 
struct netns_ipvs;

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ns_common.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   atomic64_t cookie_gen ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   spinlock_t nsid_lock ;
   struct idr netns_ids ;
   struct ns_common ns ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct netns_mpls mpls ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};

#line 241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
struct __anonstruct_possible_net_t_306 {
   struct net *net ;
};

#line 241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
typedef struct __anonstruct_possible_net_t_306 possible_net_t;

#line 376 
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2,
    FWNODE_PDATA = 3
};

#line 383  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
struct fwnode_handle {
   enum fwnode_type type ;
   struct fwnode_handle *secondary ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
typedef u32 phandle;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
struct device_node {
   char const *name ;
   char const *type ;
   phandle phandle ;
   char const *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
typedef int phy_interface_t;

#line 133 
struct phy_device;

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct mii_bus {
   char const *name ;
   char id[17U] ;
   void *priv ;
   int (*read)(struct mii_bus *, int , int ) ;
   int (*write)(struct mii_bus *, int , int , u16 ) ;
   int (*reset)(struct mii_bus *) ;
   struct mutex mdio_lock ;
   struct device *parent ;
   int state ;
   struct device dev ;
   struct phy_device *phy_map[32U] ;
   u32 phy_mask ;
   u32 phy_ignore_ta_mask ;
   int *irq ;
};

#line 214 
enum phy_state {
    PHY_DOWN = 0,
    PHY_STARTING = 1,
    PHY_READY = 2,
    PHY_PENDING = 3,
    PHY_UP = 4,
    PHY_AN = 5,
    PHY_RUNNING = 6,
    PHY_NOLINK = 7,
    PHY_FORCING = 8,
    PHY_CHANGELINK = 9,
    PHY_HALTED = 10,
    PHY_RESUMING = 11
};

#line 229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_c45_device_ids {
   u32 devices_in_package ;
   u32 device_ids[8U] ;
};

#line 323 
struct phy_driver;

#line 323  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_device {
   struct phy_driver *drv ;
   struct mii_bus *bus ;
   struct device dev ;
   u32 phy_id ;
   struct phy_c45_device_ids c45_ids ;
   bool is_c45 ;
   bool is_internal ;
   bool has_fixups ;
   bool suspended ;
   enum phy_state state ;
   u32 dev_flags ;
   phy_interface_t interface ;
   int addr ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
   int link ;
   u32 interrupts ;
   u32 supported ;
   u32 advertising ;
   u32 lp_advertising ;
   int autoneg ;
   int link_timeout ;
   int irq ;
   void *priv ;
   struct work_struct phy_queue ;
   struct delayed_work state_queue ;
   atomic_t irq_disable ;
   struct mutex lock ;
   struct net_device *attached_dev ;
   void (*adjust_link)(struct net_device *) ;
};

#line 429  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_driver {
   u32 phy_id ;
   char *name ;
   unsigned int phy_id_mask ;
   u32 features ;
   u32 flags ;
   void const *driver_data ;
   int (*soft_reset)(struct phy_device *) ;
   int (*config_init)(struct phy_device *) ;
   int (*probe)(struct phy_device *) ;
   int (*suspend)(struct phy_device *) ;
   int (*resume)(struct phy_device *) ;
   int (*config_aneg)(struct phy_device *) ;
   int (*aneg_done)(struct phy_device *) ;
   int (*read_status)(struct phy_device *) ;
   int (*ack_interrupt)(struct phy_device *) ;
   int (*config_intr)(struct phy_device *) ;
   int (*did_interrupt)(struct phy_device *) ;
   void (*remove)(struct phy_device *) ;
   int (*match_phy_device)(struct phy_device *) ;
   int (*ts_info)(struct phy_device *, struct ethtool_ts_info *) ;
   int (*hwtstamp)(struct phy_device *, struct ifreq *) ;
   bool (*rxtstamp)(struct phy_device *, struct sk_buff *, int ) ;
   void (*txtstamp)(struct phy_device *, struct sk_buff *, int ) ;
   int (*set_wol)(struct phy_device *, struct ethtool_wolinfo *) ;
   void (*get_wol)(struct phy_device *, struct ethtool_wolinfo *) ;
   void (*link_change_notify)(struct phy_device *) ;
   int (*read_mmd_indirect)(struct phy_device *, int , int , int ) ;
   void (*write_mmd_indirect)(struct phy_device *, int , int , int , u32 ) ;
   int (*module_info)(struct phy_device *, struct ethtool_modinfo *) ;
   int (*module_eeprom)(struct phy_device *, struct ethtool_eeprom *, u8 *) ;
   struct device_driver driver ;
};

#line 803  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct fixed_phy_status {
   int link ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy_fixed.h"
enum dsa_tag_protocol {
    DSA_TAG_PROTO_NONE = 0,
    DSA_TAG_PROTO_DSA = 1,
    DSA_TAG_PROTO_TRAILER = 2,
    DSA_TAG_PROTO_EDSA = 3,
    DSA_TAG_PROTO_BRCM = 4
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy_fixed.h"
struct dsa_chip_data {
   struct device *host_dev ;
   int sw_addr ;
   int eeprom_len ;
   struct device_node *of_node ;
   char *port_names[12U] ;
   struct device_node *port_dn[12U] ;
   s8 *rtable ;
};

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   struct net_device *of_netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};

#line 84 
struct packet_type;

#line 85 
struct dsa_switch;

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   int (*rcv)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *) ;
   enum dsa_tag_protocol tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};

#line 123 
struct dsa_switch_driver;

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   enum dsa_tag_protocol tag_protocol ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct device *master_dev ;
   char hwmon_name[24U] ;
   struct device *hwmon_dev ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   u32 phys_mii_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   enum dsa_tag_protocol tag_protocol ;
   int priv_size ;
   char *(*probe)(struct device *, int ) ;
   int (*setup)(struct dsa_switch *) ;
   int (*set_addr)(struct dsa_switch *, u8 *) ;
   u32 (*get_phy_flags)(struct dsa_switch *, int ) ;
   int (*phy_read)(struct dsa_switch *, int , int ) ;
   int (*phy_write)(struct dsa_switch *, int , int , u16 ) ;
   void (*poll_link)(struct dsa_switch *) ;
   void (*adjust_link)(struct dsa_switch *, int , struct phy_device *) ;
   void (*fixed_link_update)(struct dsa_switch *, int , struct fixed_phy_status *) ;
   void (*get_strings)(struct dsa_switch *, int , uint8_t *) ;
   void (*get_ethtool_stats)(struct dsa_switch *, int , uint64_t *) ;
   int (*get_sset_count)(struct dsa_switch *) ;
   void (*get_wol)(struct dsa_switch *, int , struct ethtool_wolinfo *) ;
   int (*set_wol)(struct dsa_switch *, int , struct ethtool_wolinfo *) ;
   int (*suspend)(struct dsa_switch *) ;
   int (*resume)(struct dsa_switch *) ;
   int (*port_enable)(struct dsa_switch *, int , struct phy_device *) ;
   void (*port_disable)(struct dsa_switch *, int , struct phy_device *) ;
   int (*set_eee)(struct dsa_switch *, int , struct phy_device *, struct ethtool_eee *) ;
   int (*get_eee)(struct dsa_switch *, int , struct ethtool_eee *) ;
   int (*get_temp)(struct dsa_switch *, int *) ;
   int (*get_temp_limit)(struct dsa_switch *, int *) ;
   int (*set_temp_limit)(struct dsa_switch *, int ) ;
   int (*get_temp_alarm)(struct dsa_switch *, bool *) ;
   int (*get_eeprom_len)(struct dsa_switch *) ;
   int (*get_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *) ;
   int (*set_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *) ;
   int (*get_regs_len)(struct dsa_switch *, int ) ;
   void (*get_regs)(struct dsa_switch *, int , struct ethtool_regs *, void *) ;
   int (*port_join_bridge)(struct dsa_switch *, int , u32 ) ;
   int (*port_leave_bridge)(struct dsa_switch *, int , u32 ) ;
   int (*port_stp_update)(struct dsa_switch *, int , u8 ) ;
   int (*fdb_add)(struct dsa_switch *, int , unsigned char const *, u16 ) ;
   int (*fdb_del)(struct dsa_switch *, int , unsigned char const *, u16 ) ;
   int (*fdb_getnext)(struct dsa_switch *, int , unsigned char *, bool *) ;
};

#line 320  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_qcn {
   __u8 rpg_enable[8U] ;
   __u32 rppp_max_rps[8U] ;
   __u32 rpg_time_reset[8U] ;
   __u32 rpg_byte_reset[8U] ;
   __u32 rpg_threshold[8U] ;
   __u32 rpg_max_rate[8U] ;
   __u32 rpg_ai_rate[8U] ;
   __u32 rpg_hai_rate[8U] ;
   __u32 rpg_gd[8U] ;
   __u32 rpg_min_dec_fac[8U] ;
   __u32 rpg_min_rate[8U] ;
   __u32 cndd_state_machine[8U] ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_qcn_stats {
   __u64 rppp_rp_centiseconds[8U] ;
   __u32 rppp_created_rps[8U] ;
};

#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};

#line 164  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};

#line 202  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};

#line 236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_setets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_getmaxrate)(struct net_device *, struct ieee_maxrate *) ;
   int (*ieee_setmaxrate)(struct net_device *, struct ieee_maxrate *) ;
   int (*ieee_getqcn)(struct net_device *, struct ieee_qcn *) ;
   int (*ieee_setqcn)(struct net_device *, struct ieee_qcn *) ;
   int (*ieee_getqcnstats)(struct net_device *, struct ieee_qcn_stats *) ;
   int (*ieee_getpfc)(struct net_device *, struct ieee_pfc *) ;
   int (*ieee_setpfc)(struct net_device *, struct ieee_pfc *) ;
   int (*ieee_getapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_setapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_delapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_peer_getets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_peer_getpfc)(struct net_device *, struct ieee_pfc *) ;
   u8 (*getstate)(struct net_device *) ;
   u8 (*setstate)(struct net_device *, u8 ) ;
   void (*getpermhwaddr)(struct net_device *, u8 *) ;
   void (*setpgtccfgtx)(struct net_device *, int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgtx)(struct net_device *, int , u8 ) ;
   void (*setpgtccfgrx)(struct net_device *, int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgrx)(struct net_device *, int , u8 ) ;
   void (*getpgtccfgtx)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *) ;
   void (*getpgbwgcfgtx)(struct net_device *, int , u8 *) ;
   void (*getpgtccfgrx)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *) ;
   void (*getpgbwgcfgrx)(struct net_device *, int , u8 *) ;
   void (*setpfccfg)(struct net_device *, int , u8 ) ;
   void (*getpfccfg)(struct net_device *, int , u8 *) ;
   u8 (*setall)(struct net_device *) ;
   u8 (*getcap)(struct net_device *, int , u8 *) ;
   int (*getnumtcs)(struct net_device *, int , u8 *) ;
   int (*setnumtcs)(struct net_device *, int , u8 ) ;
   u8 (*getpfcstate)(struct net_device *) ;
   void (*setpfcstate)(struct net_device *, u8 ) ;
   void (*getbcncfg)(struct net_device *, int , u32 *) ;
   void (*setbcncfg)(struct net_device *, int , u32 ) ;
   void (*getbcnrp)(struct net_device *, int , u8 *) ;
   void (*setbcnrp)(struct net_device *, int , u8 ) ;
   int (*setapp)(struct net_device *, u8 , u16 , u8 ) ;
   int (*getapp)(struct net_device *, u8 , u16 ) ;
   u8 (*getfeatcfg)(struct net_device *, int , u8 *) ;
   u8 (*setfeatcfg)(struct net_device *, int , u8 ) ;
   u8 (*getdcbx)(struct net_device *) ;
   u8 (*setdcbx)(struct net_device *, u8 ) ;
   int (*peer_getappinfo)(struct net_device *, struct dcb_peer_app_info *, u16 *) ;
   int (*peer_getapptable)(struct net_device *, struct dcb_app *) ;
   int (*cee_peer_getpg)(struct net_device *, struct cee_pg *) ;
   int (*cee_peer_getpfc)(struct net_device *, struct cee_pfc *) ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};

#line 515  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};

#line 97  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/security.h"
struct xfrm_policy;

#line 98 
struct xfrm_state;

#line 114 
struct request_sock;

#line 1628 
struct mnt_namespace;

#line 1629 
struct ipc_namespace;

#line 1630  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};

#line 147  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr const *nlh ;
   int (*dump)(struct sk_buff *, struct netlink_callback *) ;
   int (*done)(struct netlink_callback *) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netlink.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};

#line 643  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_link.h"
struct ifla_vf_stats {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 broadcast ;
   __u64 multicast ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
   __u32 rss_query_en ;
};

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_bonding.h"
struct netpoll_info;

#line 119 
struct wireless_dev;

#line 120 
struct wpan_dev;

#line 121 
struct mpls_dev;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = -2147483648,
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;

#line 129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};

#line 190 
struct neigh_parms;

#line 191  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_hw_addr {
   struct list_head list ;
   unsigned char addr[32U] ;
   unsigned char type ;
   bool global_use ;
   int sync_cnt ;
   int refcount ;
   int synced ;
   struct callback_head callback_head ;
};

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};

#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};

#line 245  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff *, struct net_device *, unsigned short , void const *, void const *, unsigned int ) ;
   int (*parse)(struct sk_buff const *, unsigned char *) ;
   int (*cache)(struct neighbour const *, struct hh_cache *, __be16 ) ;
   void (*cache_update)(struct hh_cache *, struct net_device const *, unsigned char const *) ;
};

#line 295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct *, int ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct hrtimer timer ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};

#line 340 
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
};

#line 388  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;

#line 389  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff **);

#line 537 
struct Qdisc;

#line 537  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
   unsigned long tx_maxrate ;
};

#line 607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};

#line 619  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};

#line 631  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};

#line 683  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};

#line 706  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};

#line 719  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};

#line 730  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};

#line 741  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};

#line 757  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_phys_item_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};

#line 770  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device *) ;
   void (*ndo_uninit)(struct net_device *) ;
   int (*ndo_open)(struct net_device *) ;
   int (*ndo_stop)(struct net_device *) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff *, struct net_device *) ;
   u16 (*ndo_select_queue)(struct net_device *, struct sk_buff *, void *, u16 (*)(struct net_device *, struct sk_buff *)) ;
   void (*ndo_change_rx_flags)(struct net_device *, int ) ;
   void (*ndo_set_rx_mode)(struct net_device *) ;
   int (*ndo_set_mac_address)(struct net_device *, void *) ;
   int (*ndo_validate_addr)(struct net_device *) ;
   int (*ndo_do_ioctl)(struct net_device *, struct ifreq *, int ) ;
   int (*ndo_set_config)(struct net_device *, struct ifmap *) ;
   int (*ndo_change_mtu)(struct net_device *, int ) ;
   int (*ndo_neigh_setup)(struct net_device *, struct neigh_parms *) ;
   void (*ndo_tx_timeout)(struct net_device *) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device *, struct rtnl_link_stats64 *) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device *) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device *, __be16 , u16 ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device *, __be16 , u16 ) ;
   void (*ndo_poll_controller)(struct net_device *) ;
   int (*ndo_netpoll_setup)(struct net_device *, struct netpoll_info *) ;
   void (*ndo_netpoll_cleanup)(struct net_device *) ;
   int (*ndo_busy_poll)(struct napi_struct *) ;
   int (*ndo_set_vf_mac)(struct net_device *, int , u8 *) ;
   int (*ndo_set_vf_vlan)(struct net_device *, int , u16 , u8 ) ;
   int (*ndo_set_vf_rate)(struct net_device *, int , int , int ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device *, int , bool ) ;
   int (*ndo_get_vf_config)(struct net_device *, int , struct ifla_vf_info *) ;
   int (*ndo_set_vf_link_state)(struct net_device *, int , int ) ;
   int (*ndo_get_vf_stats)(struct net_device *, int , struct ifla_vf_stats *) ;
   int (*ndo_set_vf_port)(struct net_device *, int , struct nlattr **) ;
   int (*ndo_get_vf_port)(struct net_device *, int , struct sk_buff *) ;
   int (*ndo_set_vf_rss_query_en)(struct net_device *, int , bool ) ;
   int (*ndo_setup_tc)(struct net_device *, u8 ) ;
   int (*ndo_fcoe_enable)(struct net_device *) ;
   int (*ndo_fcoe_disable)(struct net_device *) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device *, u16 , struct scatterlist *, unsigned int ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device *, u16 ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device *, u16 , struct scatterlist *, unsigned int ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device *, struct netdev_fcoe_hbainfo *) ;
   int (*ndo_fcoe_get_wwn)(struct net_device *, u64 *, int ) ;
   int (*ndo_rx_flow_steer)(struct net_device *, struct sk_buff const *, u16 , u32 ) ;
   int (*ndo_add_slave)(struct net_device *, struct net_device *) ;
   int (*ndo_del_slave)(struct net_device *, struct net_device *) ;
   netdev_features_t (*ndo_fix_features)(struct net_device *, netdev_features_t ) ;
   int (*ndo_set_features)(struct net_device *, netdev_features_t ) ;
   int (*ndo_neigh_construct)(struct neighbour *) ;
   void (*ndo_neigh_destroy)(struct neighbour *) ;
   int (*ndo_fdb_add)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 , u16 ) ;
   int (*ndo_fdb_del)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 ) ;
   int (*ndo_fdb_dump)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int ) ;
   int (*ndo_bridge_setlink)(struct net_device *, struct nlmsghdr *, u16 ) ;
   int (*ndo_bridge_getlink)(struct sk_buff *, u32 , u32 , struct net_device *, u32 , int ) ;
   int (*ndo_bridge_dellink)(struct net_device *, struct nlmsghdr *, u16 ) ;
   int (*ndo_change_carrier)(struct net_device *, bool ) ;
   int (*ndo_get_phys_port_id)(struct net_device *, struct netdev_phys_item_id *) ;
   int (*ndo_get_phys_port_name)(struct net_device *, char *, size_t ) ;
   void (*ndo_add_vxlan_port)(struct net_device *, sa_family_t , __be16 ) ;
   void (*ndo_del_vxlan_port)(struct net_device *, sa_family_t , __be16 ) ;
   void *(*ndo_dfwd_add_station)(struct net_device *, struct net_device *) ;
   void (*ndo_dfwd_del_station)(struct net_device *, void *) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff *, struct net_device *, void *) ;
   int (*ndo_get_lock_subclass)(struct net_device *) ;
   netdev_features_t (*ndo_features_check)(struct sk_buff *, struct net_device *, netdev_features_t ) ;
   int (*ndo_set_tx_maxrate)(struct net_device *, int , u32 ) ;
   int (*ndo_get_iflink)(struct net_device const *) ;
};

#line 1243 
enum ldv_31032 {
    NETREG_UNINITIALIZED = 0,
    NETREG_REGISTERED = 1,
    NETREG_UNREGISTERING = 2,
    NETREG_UNREGISTERED = 3,
    NETREG_RELEASED = 4,
    NETREG_DUMMY = 5
};

#line 1252 
enum ldv_31033 {
    RTNL_LINK_INITIALIZED = 0,
    RTNL_LINK_INITIALIZING = 1
};

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct __anonstruct_adj_list_316 {
   struct list_head upper ;
   struct list_head lower ;
};

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct __anonstruct_all_adj_list_317 {
   struct list_head upper ;
   struct list_head lower ;
};

#line 1257 
struct iw_handler_def;

#line 1257 
struct iw_public_data;

#line 1257 
struct switchdev_ops;

#line 1257 
struct vlan_info;

#line 1257 
struct tipc_bearer;

#line 1257 
struct in_device;

#line 1257 
struct dn_dev;

#line 1257 
struct inet6_dev;

#line 1257 
struct tcf_proto;

#line 1257 
struct pcpu_lstats;

#line 1257 
struct pcpu_sw_netstats;

#line 1257 
struct pcpu_dstats;

#line 1257 
struct pcpu_vstats;

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
union __anonunion_318 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};

#line 1257 
struct garp_port;

#line 1257 
struct mrp_port;

#line 1257 
struct rtnl_link_ops;

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   atomic_t carrier_changes ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct list_head ptype_all ;
   struct list_head ptype_specific ;
   struct __anonstruct_adj_list_316 adj_list ;
   struct __anonstruct_all_adj_list_317 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int group ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   struct iw_handler_def const *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops const *netdev_ops ;
   struct ethtool_ops const *ethtool_ops ;
   struct switchdev_ops const *switchdev_ops ;
   struct header_ops const *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   unsigned char name_assign_type ;
   bool uc_promisc ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   struct wpan_dev *ieee802154_ptr ;
   struct mpls_dev *mpls_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   unsigned long gro_flush_timeout ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct tcf_proto *ingress_cl_list ;
   struct netdev_queue *ingress_queue ;
   struct list_head nf_hooks_ingress ;
   unsigned char broadcast[32U] ;
   struct cpu_rmap *rx_cpu_rmap ;
   struct hlist_node index_hlist ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   int watchdog_timeo ;
   struct xps_dev_maps *xps_maps ;
   unsigned long trans_start ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct list_head link_watch_list ;
   enum ldv_31032 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) reg_state : 8 ;
   bool dismantle ;
   enum ldv_31033 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) rtnl_link_state : 16 ;
   void (*destructor)(struct net_device *) ;
   struct netpoll_info *npinfo ;
   possible_net_t nd_net ;
   union __anonunion_318 __anonCompField_net_device_95 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group const *sysfs_groups[4U] ;
   struct attribute_group const *sysfs_rx_queue_group ;
   struct rtnl_link_ops const *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   u16 gso_min_segs ;
   struct dcbnl_rtnl_ops const *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
};

#line 1978  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct packet_type {
   __be16 type ;
   struct net_device *dev ;
   int (*func)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *) ;
   bool (*id_match)(struct packet_type *, struct sock *) ;
   void *af_packet_priv ;
   struct list_head list ;
};

#line 2025  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mdio.h"
struct mdio_if_info {
   int prtad ;
   u32 mmds ;
   unsigned int mode_support ;
   struct net_device *dev ;
   int (*mdio_read)(struct net_device *, int , int , u16 ) ;
   int (*mdio_write)(struct net_device *, int , int , u16 , u16 ) ;
};

#line 193  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/vmalloc.h"
struct i2c_msg {
   __u16 addr ;
   __u16 flags ;
   __u16 len ;
   __u8 *buf ;
};

#line 82  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/i2c.h"
union i2c_smbus_data {
   __u8 byte ;
   __u16 word ;
   __u8 block[34U] ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/i2c.h"
struct i2c_algorithm;

#line 40 
struct i2c_adapter;

#line 41 
struct i2c_client;

#line 44 
enum i2c_slave_event;

#line 44 
enum i2c_slave_event;

#line 196  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/i2c.h"
struct i2c_client {
   unsigned short flags ;
   unsigned short addr ;
   char name[20U] ;
   struct i2c_adapter *adapter ;
   struct device dev ;
   int irq ;
   struct list_head detected ;
   int (*slave_cb)(struct i2c_client *, enum i2c_slave_event , u8 *) ;
};

#line 251 
enum i2c_slave_event {
    I2C_SLAVE_READ_REQUESTED = 0,
    I2C_SLAVE_WRITE_REQUESTED = 1,
    I2C_SLAVE_READ_PROCESSED = 2,
    I2C_SLAVE_WRITE_RECEIVED = 3,
    I2C_SLAVE_STOP = 4
};

#line 359  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/i2c.h"
struct i2c_algorithm {
   int (*master_xfer)(struct i2c_adapter *, struct i2c_msg *, int ) ;
   int (*smbus_xfer)(struct i2c_adapter *, u16 , unsigned short , char , u8 , int , union i2c_smbus_data *) ;
   u32 (*functionality)(struct i2c_adapter *) ;
   int (*reg_slave)(struct i2c_client *) ;
   int (*unreg_slave)(struct i2c_client *) ;
};

#line 411  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/i2c.h"
struct i2c_bus_recovery_info {
   int (*recover_bus)(struct i2c_adapter *) ;
   int (*get_scl)(struct i2c_adapter *) ;
   void (*set_scl)(struct i2c_adapter *, int ) ;
   int (*get_sda)(struct i2c_adapter *) ;
   void (*prepare_recovery)(struct i2c_adapter *) ;
   void (*unprepare_recovery)(struct i2c_adapter *) ;
   int scl_gpio ;
   int sda_gpio ;
};

#line 451  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/i2c.h"
struct i2c_adapter_quirks {
   u64 flags ;
   int max_num_msgs ;
   u16 max_write_len ;
   u16 max_read_len ;
   u16 max_comb_1st_msg_len ;
   u16 max_comb_2nd_msg_len ;
};

#line 481  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/i2c.h"
struct i2c_adapter {
   struct module *owner ;
   unsigned int class ;
   struct i2c_algorithm const *algo ;
   void *algo_data ;
   struct rt_mutex bus_lock ;
   int timeout ;
   int retries ;
   struct device dev ;
   int nr ;
   char name[48U] ;
   struct completion dev_released ;
   struct mutex userspace_clients_lock ;
   struct list_head userspace_clients ;
   struct i2c_bus_recovery_info *bus_recovery_info ;
   struct i2c_adapter_quirks const *quirks ;
};

#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/mtd/mtd-abi.h"
struct otp_info {
   __u32 start ;
   __u32 length ;
   __u32 locked ;
};

#line 217  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/mtd/mtd-abi.h"
struct nand_oobfree {
   __u32 offset ;
   __u32 length ;
};

#line 239  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/mtd/mtd-abi.h"
struct mtd_ecc_stats {
   __u32 corrected ;
   __u32 failed ;
   __u32 badblocks ;
   __u32 bbtblocks ;
};

#line 283  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/mtd/mtd-abi.h"
struct erase_info {
   struct mtd_info *mtd ;
   uint64_t addr ;
   uint64_t len ;
   uint64_t fail_addr ;
   u_long time ;
   u_long retries ;
   unsigned int dev ;
   unsigned int cell ;
   void (*callback)(struct erase_info *) ;
   u_long priv ;
   u_char state ;
   struct erase_info *next ;
};

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mtd/mtd.h"
struct mtd_erase_region_info {
   uint64_t offset ;
   uint32_t erasesize ;
   uint32_t numblocks ;
   unsigned long *lockmap ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mtd/mtd.h"
struct mtd_oob_ops {
   unsigned int mode ;
   size_t len ;
   size_t retlen ;
   size_t ooblen ;
   size_t oobretlen ;
   uint32_t ooboffs ;
   uint8_t *datbuf ;
   uint8_t *oobbuf ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mtd/mtd.h"
struct nand_ecclayout {
   __u32 eccbytes ;
   __u32 eccpos[640U] ;
   __u32 oobavail ;
   struct nand_oobfree oobfree[32U] ;
};

#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mtd/mtd.h"
struct mtd_info {
   u_char type ;
   uint32_t flags ;
   uint64_t size ;
   uint32_t erasesize ;
   uint32_t writesize ;
   uint32_t writebufsize ;
   uint32_t oobsize ;
   uint32_t oobavail ;
   unsigned int erasesize_shift ;
   unsigned int writesize_shift ;
   unsigned int erasesize_mask ;
   unsigned int writesize_mask ;
   unsigned int bitflip_threshold ;
   char const *name ;
   int index ;
   struct nand_ecclayout *ecclayout ;
   unsigned int ecc_step_size ;
   unsigned int ecc_strength ;
   int numeraseregions ;
   struct mtd_erase_region_info *eraseregions ;
   int (*_erase)(struct mtd_info *, struct erase_info *) ;
   int (*_point)(struct mtd_info *, loff_t , size_t , size_t *, void **, resource_size_t *) ;
   int (*_unpoint)(struct mtd_info *, loff_t , size_t ) ;
   unsigned long (*_get_unmapped_area)(struct mtd_info *, unsigned long , unsigned long , unsigned long ) ;
   int (*_read)(struct mtd_info *, loff_t , size_t , size_t *, u_char *) ;
   int (*_write)(struct mtd_info *, loff_t , size_t , size_t *, u_char const *) ;
   int (*_panic_write)(struct mtd_info *, loff_t , size_t , size_t *, u_char const *) ;
   int (*_read_oob)(struct mtd_info *, loff_t , struct mtd_oob_ops *) ;
   int (*_write_oob)(struct mtd_info *, loff_t , struct mtd_oob_ops *) ;
   int (*_get_fact_prot_info)(struct mtd_info *, size_t , size_t *, struct otp_info *) ;
   int (*_read_fact_prot_reg)(struct mtd_info *, loff_t , size_t , size_t *, u_char *) ;
   int (*_get_user_prot_info)(struct mtd_info *, size_t , size_t *, struct otp_info *) ;
   int (*_read_user_prot_reg)(struct mtd_info *, loff_t , size_t , size_t *, u_char *) ;
   int (*_write_user_prot_reg)(struct mtd_info *, loff_t , size_t , size_t *, u_char *) ;
   int (*_lock_user_prot_reg)(struct mtd_info *, loff_t , size_t ) ;
   int (*_writev)(struct mtd_info *, struct kvec const *, unsigned long , loff_t , size_t *) ;
   void (*_sync)(struct mtd_info *) ;
   int (*_lock)(struct mtd_info *, loff_t , uint64_t ) ;
   int (*_unlock)(struct mtd_info *, loff_t , uint64_t ) ;
   int (*_is_locked)(struct mtd_info *, loff_t , uint64_t ) ;
   int (*_block_isreserved)(struct mtd_info *, loff_t ) ;
   int (*_block_isbad)(struct mtd_info *, loff_t ) ;
   int (*_block_markbad)(struct mtd_info *, loff_t ) ;
   int (*_suspend)(struct mtd_info *) ;
   void (*_resume)(struct mtd_info *) ;
   void (*_reboot)(struct mtd_info *) ;
   int (*_get_device)(struct mtd_info *) ;
   void (*_put_device)(struct mtd_info *) ;
   struct backing_dev_info *backing_dev_info ;
   struct notifier_block reboot_notifier ;
   struct mtd_ecc_stats ecc_stats ;
   int subpage_sft ;
   void *priv ;
   struct module *owner ;
   struct device dev ;
   int usecount ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jhash.h"
struct page_counter {
   atomic_long_t count ;
   unsigned long limit ;
   struct page_counter *parent ;
   unsigned long watermark ;
   unsigned long failcnt ;
};

#line 580  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/memcontrol.h"
struct sock_filter {
   __u16 code ;
   __u8 jt ;
   __u8 jf ;
   __u32 k ;
};

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/filter.h"
struct bpf_insn {
   __u8 code ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) dst_reg : 4 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) src_reg : 4 ;
   __s16 off ;
   __s32 imm ;
};

#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/bpf.h"
enum bpf_prog_type {
    BPF_PROG_TYPE_UNSPEC = 0,
    BPF_PROG_TYPE_SOCKET_FILTER = 1,
    BPF_PROG_TYPE_KPROBE = 2,
    BPF_PROG_TYPE_SCHED_CLS = 3,
    BPF_PROG_TYPE_SCHED_ACT = 4
};

#line 273 
struct bpf_prog_aux;

#line 314  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/filter.h"
struct sock_fprog_kern {
   u16 len ;
   struct sock_filter *filter ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/filter.h"
union __anonunion_337 {
   struct sock_filter insns[0U] ;
   struct bpf_insn insnsi[0U] ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/filter.h"
struct bpf_prog {
   u16 pages ;
   bool jited ;
   bool gpl_compatible ;
   u32 len ;
   enum bpf_prog_type type ;
   struct bpf_prog_aux *aux ;
   struct sock_fprog_kern *orig_prog ;
   unsigned int (*bpf_func)(struct sk_buff const *, struct bpf_insn const *) ;
   union __anonunion_337 __anonCompField_bpf_prog_100 ;
};

#line 342  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/filter.h"
struct sk_filter {
   atomic_t refcnt ;
   struct callback_head rcu ;
   struct bpf_prog *prog ;
};

#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_nulls.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file *, wait_queue_head_t *, struct poll_table_struct *) ;
   unsigned long _key ;
};

#line 183  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/poll.h"
struct nla_policy {
   u16 type ;
   u16 len ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/rtnetlink.h"
struct rtnl_link_ops {
   struct list_head list ;
   char const *kind ;
   size_t priv_size ;
   void (*setup)(struct net_device *) ;
   int maxtype ;
   struct nla_policy const *policy ;
   int (*validate)(struct nlattr **, struct nlattr **) ;
   int (*newlink)(struct net *, struct net_device *, struct nlattr **, struct nlattr **) ;
   int (*changelink)(struct net_device *, struct nlattr **, struct nlattr **) ;
   void (*dellink)(struct net_device *, struct list_head *) ;
   size_t (*get_size)(struct net_device const *) ;
   int (*fill_info)(struct sk_buff *, struct net_device const *) ;
   size_t (*get_xstats_size)(struct net_device const *) ;
   int (*fill_xstats)(struct sk_buff *, struct net_device const *) ;
   unsigned int (*get_num_tx_queues)(void) ;
   unsigned int (*get_num_rx_queues)(void) ;
   int slave_maxtype ;
   struct nla_policy const *slave_policy ;
   int (*slave_validate)(struct nlattr **, struct nlattr **) ;
   int (*slave_changelink)(struct net_device *, struct net_device *, struct nlattr **, struct nlattr **) ;
   size_t (*get_slave_size)(struct net_device const *, struct net_device const *) ;
   int (*fill_slave_info)(struct sk_buff *, struct net_device const *, struct net_device const *) ;
   struct net *(*get_link_net)(struct net_device const *) ;
};

#line 171 
struct neigh_table;

#line 171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/rtnetlink.h"
struct neigh_parms {
   possible_net_t net ;
   struct net_device *dev ;
   struct list_head list ;
   int (*neigh_setup)(struct neighbour *) ;
   void (*neigh_cleanup)(struct neighbour *) ;
   struct neigh_table *tbl ;
   void *sysctl_table ;
   int dead ;
   atomic_t refcnt ;
   struct callback_head callback_head ;
   int reachable_time ;
   int data[13U] ;
   unsigned long data_state[1U] ;
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neigh_statistics {
   unsigned long allocs ;
   unsigned long destroys ;
   unsigned long hash_grows ;
   unsigned long res_failed ;
   unsigned long lookups ;
   unsigned long hits ;
   unsigned long rcv_probes_mcast ;
   unsigned long rcv_probes_ucast ;
   unsigned long periodic_gc_runs ;
   unsigned long forced_gc_runs ;
   unsigned long unres_discards ;
};

#line 129 
struct neigh_ops;

#line 129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neighbour {
   struct neighbour *next ;
   struct neigh_table *tbl ;
   struct neigh_parms *parms ;
   unsigned long confirmed ;
   unsigned long updated ;
   rwlock_t lock ;
   atomic_t refcnt ;
   struct sk_buff_head arp_queue ;
   unsigned int arp_queue_len_bytes ;
   struct timer_list timer ;
   unsigned long used ;
   atomic_t probes ;
   __u8 flags ;
   __u8 nud_state ;
   __u8 type ;
   __u8 dead ;
   seqlock_t ha_lock ;
   unsigned char ha[32U] ;
   struct hh_cache hh ;
   int (*output)(struct neighbour *, struct sk_buff *) ;
   struct neigh_ops const *ops ;
   struct callback_head rcu ;
   struct net_device *dev ;
   u8 primary_key[0U] ;
};

#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neigh_ops {
   int family ;
   void (*solicit)(struct neighbour *, struct sk_buff *) ;
   void (*error_report)(struct neighbour *, struct sk_buff *) ;
   int (*output)(struct neighbour *, struct sk_buff *) ;
   int (*connected_output)(struct neighbour *, struct sk_buff *) ;
};

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct pneigh_entry {
   struct pneigh_entry *next ;
   possible_net_t net ;
   struct net_device *dev ;
   u8 flags ;
   u8 key[0U] ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neigh_hash_table {
   struct neighbour **hash_buckets ;
   unsigned int hash_shift ;
   __u32 hash_rnd[4U] ;
   struct callback_head rcu ;
};

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neigh_table {
   int family ;
   int entry_size ;
   int key_len ;
   __be16 protocol ;
   __u32 (*hash)(void const *, struct net_device const *, __u32 *) ;
   bool (*key_eq)(struct neighbour const *, void const *) ;
   int (*constructor)(struct neighbour *) ;
   int (*pconstructor)(struct pneigh_entry *) ;
   void (*pdestructor)(struct pneigh_entry *) ;
   void (*proxy_redo)(struct sk_buff *) ;
   char *id ;
   struct neigh_parms parms ;
   struct list_head parms_list ;
   int gc_interval ;
   int gc_thresh1 ;
   int gc_thresh2 ;
   int gc_thresh3 ;
   unsigned long last_flush ;
   struct delayed_work gc_work ;
   struct timer_list proxy_timer ;
   struct sk_buff_head proxy_queue ;
   atomic_t entries ;
   rwlock_t lock ;
   unsigned long last_rand ;
   struct neigh_statistics *stats ;
   struct neigh_hash_table *nht ;
   struct pneigh_entry **phash_buckets ;
};

#line 519 
struct dn_route;

#line 519  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
union __anonunion_345 {
   struct dst_entry *next ;
   struct rtable *rt_next ;
   struct rt6_info *rt6_next ;
   struct dn_route *dn_next ;
};

#line 519  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct dst_entry {
   struct callback_head callback_head ;
   struct dst_entry *child ;
   struct net_device *dev ;
   struct dst_ops *ops ;
   unsigned long _metrics ;
   unsigned long expires ;
   struct dst_entry *path ;
   struct dst_entry *from ;
   struct xfrm_state *xfrm ;
   int (*input)(struct sk_buff *) ;
   int (*output)(struct sock *, struct sk_buff *) ;
   unsigned short flags ;
   unsigned short pending_confirm ;
   short error ;
   short obsolete ;
   unsigned short header_len ;
   unsigned short trailer_len ;
   __u32 tclassid ;
   long __pad_to_align_refcnt[2U] ;
   atomic_t __refcnt ;
   int __use ;
   unsigned long lastuse ;
   union __anonunion_345 __anonCompField_dst_entry_101 ;
};

#line 555  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dst.h"
struct hwtstamp_config {
   int flags ;
   int tx_type ;
   int rx_filter ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct __anonstruct_socket_lock_t_346 {
   spinlock_t slock ;
   int owned ;
   wait_queue_head_t wq ;
   struct lockdep_map dep_map ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
typedef struct __anonstruct_socket_lock_t_346 socket_lock_t;

#line 124 
struct proto;

#line 130  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
typedef __u32 __portpair;

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
typedef __u64 __addrpair;

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct __anonstruct_348 {
   __be32 skc_daddr ;
   __be32 skc_rcv_saddr ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_347 {
   __addrpair skc_addrpair ;
   struct __anonstruct_348 __anonCompField___anonunion_347_102 ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_349 {
   unsigned int skc_hash ;
   __u16 skc_u16hashes[2U] ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct __anonstruct_351 {
   __be16 skc_dport ;
   __u16 skc_num ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_350 {
   __portpair skc_portpair ;
   struct __anonstruct_351 __anonCompField___anonunion_350_105 ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_352 {
   struct hlist_node skc_bind_node ;
   struct hlist_nulls_node skc_portaddr_node ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_353 {
   struct hlist_node skc_node ;
   struct hlist_nulls_node skc_nulls_node ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct sock_common {
   union __anonunion_347 __anonCompField_sock_common_103 ;
   union __anonunion_349 __anonCompField_sock_common_104 ;
   union __anonunion_350 __anonCompField_sock_common_106 ;
   unsigned short skc_family ;
   unsigned char volatile skc_state ;
   unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) skc_reuse : 4 ;
   unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) skc_reuseport : 1 ;
   unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) skc_ipv6only : 1 ;
   unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) skc_net_refcnt : 1 ;
   int skc_bound_dev_if ;
   union __anonunion_352 __anonCompField_sock_common_107 ;
   struct proto *skc_prot ;
   possible_net_t skc_net ;
   struct in6_addr skc_v6_daddr ;
   struct in6_addr skc_v6_rcv_saddr ;
   atomic64_t skc_cookie ;
   int skc_dontcopy_begin[0U] ;
   union __anonunion_353 __anonCompField_sock_common_108 ;
   int skc_tx_queue_mapping ;
   atomic_t skc_refcnt ;
   int skc_dontcopy_end[0U] ;
};

#line 219 
struct cg_proto;

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct __anonstruct_sk_backlog_354 {
   atomic_t rmem_alloc ;
   int len ;
   struct sk_buff *head ;
   struct sk_buff *tail ;
};

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct sock {
   struct sock_common __sk_common ;
   socket_lock_t sk_lock ;
   struct sk_buff_head sk_receive_queue ;
   struct __anonstruct_sk_backlog_354 sk_backlog ;
   int sk_forward_alloc ;
   __u32 sk_rxhash ;
   u16 sk_incoming_cpu ;
   __u32 sk_txhash ;
   unsigned int sk_napi_id ;
   unsigned int sk_ll_usec ;
   atomic_t sk_drops ;
   int sk_rcvbuf ;
   struct sk_filter *sk_filter ;
   struct socket_wq *sk_wq ;
   struct xfrm_policy *sk_policy[2U] ;
   unsigned long sk_flags ;
   struct dst_entry *sk_rx_dst ;
   struct dst_entry *sk_dst_cache ;
   spinlock_t sk_dst_lock ;
   atomic_t sk_wmem_alloc ;
   atomic_t sk_omem_alloc ;
   int sk_sndbuf ;
   struct sk_buff_head sk_write_queue ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) sk_shutdown : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sk_no_check_tx : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sk_no_check_rx : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) sk_userlocks : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) sk_protocol : 8 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) sk_type : 16 ;
   int sk_wmem_queued ;
   gfp_t sk_allocation ;
   u32 sk_pacing_rate ;
   u32 sk_max_pacing_rate ;
   netdev_features_t sk_route_caps ;
   netdev_features_t sk_route_nocaps ;
   int sk_gso_type ;
   unsigned int sk_gso_max_size ;
   u16 sk_gso_max_segs ;
   int sk_rcvlowat ;
   unsigned long sk_lingertime ;
   struct sk_buff_head sk_error_queue ;
   struct proto *sk_prot_creator ;
   rwlock_t sk_callback_lock ;
   int sk_err ;
   int sk_err_soft ;
   u32 sk_ack_backlog ;
   u32 sk_max_ack_backlog ;
   __u32 sk_priority ;
   __u32 sk_cgrp_prioidx ;
   struct pid *sk_peer_pid ;
   struct cred const *sk_peer_cred ;
   long sk_rcvtimeo ;
   long sk_sndtimeo ;
   struct timer_list sk_timer ;
   ktime_t sk_stamp ;
   u16 sk_tsflags ;
   u32 sk_tskey ;
   struct socket *sk_socket ;
   void *sk_user_data ;
   struct page_frag sk_frag ;
   struct sk_buff *sk_send_head ;
   __s32 sk_peek_off ;
   int sk_write_pending ;
   void *sk_security ;
   __u32 sk_mark ;
   u32 sk_classid ;
   struct cg_proto *sk_cgrp ;
   void (*sk_state_change)(struct sock *) ;
   void (*sk_data_ready)(struct sock *) ;
   void (*sk_write_space)(struct sock *) ;
   void (*sk_error_report)(struct sock *) ;
   int (*sk_backlog_rcv)(struct sock *, struct sk_buff *) ;
   void (*sk_destruct)(struct sock *) ;
};

#line 914 
struct request_sock_ops;

#line 915 
struct timewait_sock_ops;

#line 916 
struct inet_hashinfo;

#line 917 
struct raw_hashinfo;

#line 932 
struct udp_table;

#line 932  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_h_357 {
   struct inet_hashinfo *hashinfo ;
   struct udp_table *udp_table ;
   struct raw_hashinfo *raw_hash ;
};

#line 932  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct proto {
   void (*close)(struct sock *, long ) ;
   int (*connect)(struct sock *, struct sockaddr *, int ) ;
   int (*disconnect)(struct sock *, int ) ;
   struct sock *(*accept)(struct sock *, int , int *) ;
   int (*ioctl)(struct sock *, int , unsigned long ) ;
   int (*init)(struct sock *) ;
   void (*destroy)(struct sock *) ;
   void (*shutdown)(struct sock *, int ) ;
   int (*setsockopt)(struct sock *, int , int , char *, unsigned int ) ;
   int (*getsockopt)(struct sock *, int , int , char *, int *) ;
   int (*compat_setsockopt)(struct sock *, int , int , char *, unsigned int ) ;
   int (*compat_getsockopt)(struct sock *, int , int , char *, int *) ;
   int (*compat_ioctl)(struct sock *, unsigned int , unsigned long ) ;
   int (*sendmsg)(struct sock *, struct msghdr *, size_t ) ;
   int (*recvmsg)(struct sock *, struct msghdr *, size_t , int , int , int *) ;
   int (*sendpage)(struct sock *, struct page *, int , size_t , int ) ;
   int (*bind)(struct sock *, struct sockaddr *, int ) ;
   int (*backlog_rcv)(struct sock *, struct sk_buff *) ;
   void (*release_cb)(struct sock *) ;
   void (*hash)(struct sock *) ;
   void (*unhash)(struct sock *) ;
   void (*rehash)(struct sock *) ;
   int (*get_port)(struct sock *, unsigned short ) ;
   void (*clear_sk)(struct sock *, int ) ;
   unsigned int inuse_idx ;
   bool (*stream_memory_free)(struct sock const *) ;
   void (*enter_memory_pressure)(struct sock *) ;
   atomic_long_t *memory_allocated ;
   struct percpu_counter *sockets_allocated ;
   int *memory_pressure ;
   long *sysctl_mem ;
   int *sysctl_wmem ;
   int *sysctl_rmem ;
   int max_header ;
   bool no_autobind ;
   struct kmem_cache *slab ;
   unsigned int obj_size ;
   int slab_flags ;
   struct percpu_counter *orphan_count ;
   struct request_sock_ops *rsk_prot ;
   struct timewait_sock_ops *twsk_prot ;
   union __anonunion_h_357 h ;
   struct module *owner ;
   char name[32U] ;
   struct list_head node ;
   int (*init_cgroup)(struct mem_cgroup *, struct cgroup_subsys *) ;
   void (*destroy_cgroup)(struct mem_cgroup *) ;
   struct cg_proto *(*proto_cgroup)(struct mem_cgroup *) ;
};

#line 1054  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct cg_proto {
   struct page_counter memory_allocated ;
   struct percpu_counter sockets_allocated ;
   int memory_pressure ;
   long sysctl_mem[3U] ;
   unsigned long flags ;
   struct mem_cgroup *memcg ;
};

#line 2242  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct request_sock_ops {
   int family ;
   int obj_size ;
   struct kmem_cache *slab ;
   char *slab_name ;
   int (*rtx_syn_ack)(struct sock *, struct request_sock *) ;
   void (*send_ack)(struct sock *, struct sk_buff *, struct request_sock *) ;
   void (*send_reset)(struct sock *, struct sk_buff *) ;
   void (*destructor)(struct request_sock *) ;
   void (*syn_ack_timeout)(struct request_sock const *) ;
};

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/request_sock.h"
struct request_sock {
   struct sock_common __req_common ;
   struct request_sock *dl_next ;
   struct sock *rsk_listener ;
   u16 mss ;
   u8 num_retrans ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cookie_ts : 1 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(7))) num_timeout : 7 ;
   u32 window_clamp ;
   u32 rcv_wnd ;
   u32 ts_recent ;
   struct timer_list rsk_timer ;
   struct request_sock_ops const *rsk_ops ;
   struct sock *sk ;
   u32 *saved_syn ;
   u32 secid ;
   u32 peer_secid ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ipv6.h"
struct ipv6_stable_secret {
   bool initialized ;
   struct in6_addr secret ;
};

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ipv6.h"
struct ipv6_devconf {
   __s32 forwarding ;
   __s32 hop_limit ;
   __s32 mtu6 ;
   __s32 accept_ra ;
   __s32 accept_redirects ;
   __s32 autoconf ;
   __s32 dad_transmits ;
   __s32 rtr_solicits ;
   __s32 rtr_solicit_interval ;
   __s32 rtr_solicit_delay ;
   __s32 force_mld_version ;
   __s32 mldv1_unsolicited_report_interval ;
   __s32 mldv2_unsolicited_report_interval ;
   __s32 use_tempaddr ;
   __s32 temp_valid_lft ;
   __s32 temp_prefered_lft ;
   __s32 regen_max_retry ;
   __s32 max_desync_factor ;
   __s32 max_addresses ;
   __s32 accept_ra_defrtr ;
   __s32 accept_ra_pinfo ;
   __s32 accept_ra_rtr_pref ;
   __s32 rtr_probe_interval ;
   __s32 accept_ra_rt_info_max_plen ;
   __s32 proxy_ndp ;
   __s32 accept_source_route ;
   __s32 accept_ra_from_local ;
   __s32 optimistic_dad ;
   __s32 use_optimistic ;
   __s32 mc_forwarding ;
   __s32 disable_ipv6 ;
   __s32 accept_dad ;
   __s32 force_tllao ;
   __s32 ndisc_notify ;
   __s32 suppress_frag_ndisc ;
   __s32 accept_ra_mtu ;
   struct ipv6_stable_secret stable_secret ;
   void *sysctl ;
};

#line 330  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_connection_sock.h"
struct timewait_sock_ops {
   struct kmem_cache *twsk_slab ;
   char *twsk_slab_name ;
   unsigned int twsk_obj_size ;
   int (*twsk_unique)(struct sock *, struct sock *, void *) ;
   void (*twsk_destructor)(struct sock *) ;
};

#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct ip6_sf_list {
   struct ip6_sf_list *sf_next ;
   struct in6_addr sf_addr ;
   unsigned long sf_count[2U] ;
   unsigned char sf_gsresp ;
   unsigned char sf_oldin ;
   unsigned char sf_crcount ;
};

#line 109  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct ifmcaddr6 {
   struct in6_addr mca_addr ;
   struct inet6_dev *idev ;
   struct ifmcaddr6 *next ;
   struct ip6_sf_list *mca_sources ;
   struct ip6_sf_list *mca_tomb ;
   unsigned int mca_sfmode ;
   unsigned char mca_crcount ;
   unsigned long mca_sfcount[2U] ;
   struct timer_list mca_timer ;
   unsigned int mca_flags ;
   int mca_users ;
   atomic_t mca_refcnt ;
   spinlock_t mca_lock ;
   unsigned long mca_cstamp ;
   unsigned long mca_tstamp ;
};

#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct ifacaddr6 {
   struct in6_addr aca_addr ;
   struct inet6_dev *aca_idev ;
   struct rt6_info *aca_rt ;
   struct ifacaddr6 *aca_next ;
   int aca_users ;
   atomic_t aca_refcnt ;
   unsigned long aca_cstamp ;
   unsigned long aca_tstamp ;
};

#line 152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct ipv6_devstat {
   struct proc_dir_entry *proc_dir_entry ;
   struct ipstats_mib *ipv6 ;
   struct icmpv6_mib_device *icmpv6dev ;
   struct icmpv6msg_mib_device *icmpv6msgdev ;
};

#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct inet6_dev {
   struct net_device *dev ;
   struct list_head addr_list ;
   struct ifmcaddr6 *mc_list ;
   struct ifmcaddr6 *mc_tomb ;
   spinlock_t mc_lock ;
   unsigned char mc_qrv ;
   unsigned char mc_gq_running ;
   unsigned char mc_ifc_count ;
   unsigned char mc_dad_count ;
   unsigned long mc_v1_seen ;
   unsigned long mc_qi ;
   unsigned long mc_qri ;
   unsigned long mc_maxdelay ;
   struct timer_list mc_gq_timer ;
   struct timer_list mc_ifc_timer ;
   struct timer_list mc_dad_timer ;
   struct ifacaddr6 *ac_list ;
   rwlock_t lock ;
   atomic_t refcnt ;
   __u32 if_flags ;
   int dead ;
   u8 rndid[8U] ;
   struct timer_list regen_timer ;
   struct list_head tempaddr_list ;
   struct in6_addr token ;
   struct neigh_parms *nd_parms ;
   struct ipv6_devconf cnf ;
   struct ipv6_devstat stats ;
   struct timer_list rs_timer ;
   __u8 rs_probes ;
   __u8 addr_gen_mode ;
   unsigned long tstamp ;
   struct callback_head rcu ;
};

#line 971  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/ipv6.h"
union __anonunion_377 {
   __be32 a4 ;
   __be32 a6[4U] ;
   struct in6_addr in6 ;
};

#line 971  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/ipv6.h"
struct inetpeer_addr_base {
   union __anonunion_377 __anonCompField_inetpeer_addr_base_110 ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
struct inetpeer_addr {
   struct inetpeer_addr_base addr ;
   __u16 family ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
union __anonunion_378 {
   struct list_head gc_list ;
   struct callback_head gc_rcu ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
struct __anonstruct_380 {
   atomic_t rid ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
union __anonunion_379 {
   struct __anonstruct_380 __anonCompField___anonunion_379_112 ;
   struct callback_head rcu ;
   struct inet_peer *gc_next ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
struct inet_peer {
   struct inet_peer *avl_left ;
   struct inet_peer *avl_right ;
   struct inetpeer_addr daddr ;
   __u32 avl_height ;
   u32 metrics[16U] ;
   u32 rate_tokens ;
   unsigned long rate_last ;
   union __anonunion_378 __anonCompField_inet_peer_111 ;
   union __anonunion_379 __anonCompField_inet_peer_113 ;
   __u32 dtime ;
   atomic_t refcnt ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
struct inet_peer_base {
   struct inet_peer *root ;
   seqlock_t lock ;
   int total ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/route.h"
struct uncached_list;

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/route.h"
struct rtable {
   struct dst_entry dst ;
   int rt_genid ;
   unsigned int rt_flags ;
   __u16 rt_type ;
   __u8 rt_is_input ;
   __u8 rt_uses_gateway ;
   int rt_iif ;
   __be32 rt_gateway ;
   u32 rt_pmtu ;
   struct list_head rt_uncached ;
   struct uncached_list *rt_uncached_list ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/busy_poll.h"
enum efx_loopback_mode {
    LOOPBACK_NONE = 0,
    LOOPBACK_DATA = 1,
    LOOPBACK_GMAC = 2,
    LOOPBACK_XGMII = 3,
    LOOPBACK_XGXS = 4,
    LOOPBACK_XAUI = 5,
    LOOPBACK_GMII = 6,
    LOOPBACK_SGMII = 7,
    LOOPBACK_XGBR = 8,
    LOOPBACK_XFI = 9,
    LOOPBACK_XAUI_FAR = 10,
    LOOPBACK_GMII_FAR = 11,
    LOOPBACK_SGMII_FAR = 12,
    LOOPBACK_XFI_FAR = 13,
    LOOPBACK_GPHY = 14,
    LOOPBACK_PHYXS = 15,
    LOOPBACK_PCS = 16,
    LOOPBACK_PMAPMD = 17,
    LOOPBACK_XPORT = 18,
    LOOPBACK_XGMII_WS = 19,
    LOOPBACK_XAUI_WS = 20,
    LOOPBACK_XAUI_WS_FAR = 21,
    LOOPBACK_XAUI_WS_NEAR = 22,
    LOOPBACK_GMII_WS = 23,
    LOOPBACK_XFI_WS = 24,
    LOOPBACK_XFI_WS_FAR = 25,
    LOOPBACK_PHYXS_WS = 26,
    LOOPBACK_MAX = 27
};

#line 163 
enum reset_type {
    RESET_TYPE_INVISIBLE = 0,
    RESET_TYPE_RECOVER_OR_ALL = 1,
    RESET_TYPE_ALL = 2,
    RESET_TYPE_WORLD = 3,
    RESET_TYPE_RECOVER_OR_DISABLE = 4,
    RESET_TYPE_DATAPATH = 5,
    RESET_TYPE_MC_BIST = 6,
    RESET_TYPE_DISABLE = 7,
    RESET_TYPE_MAX_METHOD = 8,
    RESET_TYPE_TX_WATCHDOG = 9,
    RESET_TYPE_INT_ERROR = 10,
    RESET_TYPE_RX_RECOVERY = 11,
    RESET_TYPE_DMA_ERROR = 12,
    RESET_TYPE_TX_SKIP = 13,
    RESET_TYPE_MC_FAILURE = 14,
    RESET_TYPE_MCDI_TIMEOUT = 15,
    RESET_TYPE_MAX = 16
};

#line 183  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/busy_poll.h"
union efx_dword {
   __le32 u32[1U] ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/bitfield.h"
typedef union efx_dword efx_dword_t;

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/bitfield.h"
union efx_qword {
   __le64 u64[1U] ;
   __le32 u32[2U] ;
   efx_dword_t dword[2U] ;
};

#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/bitfield.h"
typedef union efx_qword efx_qword_t;

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/bitfield.h"
union efx_oword {
   __le64 u64[2U] ;
   efx_qword_t qword[2U] ;
   __le32 u32[4U] ;
   efx_dword_t dword[4U] ;
};

#line 94  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/bitfield.h"
typedef union efx_oword efx_oword_t;

#line 109 
enum efx_filter_priority {
    EFX_FILTER_PRI_HINT = 0,
    EFX_FILTER_PRI_AUTO = 1,
    EFX_FILTER_PRI_MANUAL = 2,
    EFX_FILTER_PRI_REQUIRED = 3
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/bitfield.h"
struct efx_filter_spec {
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))) match_flags : 12 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) priority : 2 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))) flags : 6 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))) dmaq_id : 12 ;
   u32 rss_context ;
   __be16 outer_vid ;
   __be16 inner_vid ;
   u8 loc_mac[6U] ;
   u8 rem_mac[6U] ;
   __be16 ether_type ;
   u8 ip_proto ;
   __be32 loc_host[4U] ;
   __be32 rem_host[4U] ;
   __be16 loc_port ;
   __be16 rem_port ;
};

#line 273  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/filter.h"
struct efx_buffer {
   void *addr ;
   dma_addr_t dma_addr ;
   unsigned int len ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
struct efx_special_buffer {
   struct efx_buffer buf ;
   unsigned int index ;
   unsigned int entries ;
};

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
union __anonunion_382 {
   struct sk_buff const *skb ;
   void *heap_buf ;
};

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
union __anonunion_383 {
   efx_qword_t option ;
   dma_addr_t dma_addr ;
};

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
struct efx_tx_buffer {
   union __anonunion_382 __anonCompField_efx_tx_buffer_115 ;
   union __anonunion_383 __anonCompField_efx_tx_buffer_116 ;
   unsigned short flags ;
   unsigned short len ;
   unsigned short unmap_len ;
   unsigned short dma_offset ;
};

#line 164 
struct efx_nic;

#line 164 
struct efx_channel;

#line 164  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
struct efx_tx_queue {
   struct efx_nic *efx ;
   unsigned int queue ;
   struct efx_channel *channel ;
   struct netdev_queue *core_txq ;
   struct efx_tx_buffer *buffer ;
   struct efx_buffer *tsoh_page ;
   struct efx_special_buffer txd ;
   unsigned int ptr_mask ;
   void *piobuf ;
   unsigned int piobuf_offset ;
   bool initialised ;
   unsigned int read_count ;
   unsigned int old_write_count ;
   unsigned int merge_events ;
   unsigned int bytes_compl ;
   unsigned int pkts_compl ;
   unsigned int insert_count ;
   unsigned int write_count ;
   unsigned int old_read_count ;
   unsigned int tso_bursts ;
   unsigned int tso_long_headers ;
   unsigned int tso_packets ;
   unsigned int pushes ;
   unsigned int pio_packets ;
   unsigned long tx_packets ;
   unsigned int empty_read_count ;
   atomic_t flush_outstanding ;
};

#line 264  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
struct efx_rx_buffer {
   dma_addr_t dma_addr ;
   struct page *page ;
   u16 page_offset ;
   u16 len ;
   u16 flags ;
};

#line 304  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
struct efx_rx_queue {
   struct efx_nic *efx ;
   int core_index ;
   struct efx_rx_buffer *buffer ;
   struct efx_special_buffer rxd ;
   unsigned int ptr_mask ;
   bool refill_enabled ;
   bool flush_pending ;
   unsigned int added_count ;
   unsigned int notified_count ;
   unsigned int removed_count ;
   unsigned int scatter_n ;
   unsigned int scatter_len ;
   struct page **page_ring ;
   unsigned int page_add ;
   unsigned int page_remove ;
   unsigned int page_recycle_count ;
   unsigned int page_recycle_failed ;
   unsigned int page_recycle_full ;
   unsigned int page_ptr_mask ;
   unsigned int max_fill ;
   unsigned int fast_fill_trigger ;
   unsigned int min_fill ;
   unsigned int min_overfill ;
   unsigned int recycle_count ;
   struct timer_list slow_fill ;
   unsigned int slow_fill_count ;
   unsigned long rx_packets ;
};

#line 370 
enum efx_sync_events_state {
    SYNC_EVENTS_DISABLED = 0,
    SYNC_EVENTS_QUIESCENT = 1,
    SYNC_EVENTS_REQUESTED = 2,
    SYNC_EVENTS_VALID = 3
};

#line 377 
struct efx_channel_type;

#line 377  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
struct efx_channel {
   struct efx_nic *efx ;
   int channel ;
   struct efx_channel_type const *type ;
   bool eventq_init ;
   bool enabled ;
   int irq ;
   unsigned int irq_moderation ;
   struct net_device *napi_dev ;
   struct napi_struct napi_str ;
   unsigned int state ;
   spinlock_t state_lock ;
   struct efx_special_buffer eventq ;
   unsigned int eventq_mask ;
   unsigned int eventq_read_ptr ;
   int event_test_cpu ;
   unsigned int irq_count ;
   unsigned int irq_mod_score ;
   unsigned int rfs_filters_added ;
   unsigned int n_rx_tobe_disc ;
   unsigned int n_rx_ip_hdr_chksum_err ;
   unsigned int n_rx_tcp_udp_chksum_err ;
   unsigned int n_rx_mcast_mismatch ;
   unsigned int n_rx_frm_trunc ;
   unsigned int n_rx_overlength ;
   unsigned int n_skbuff_leaks ;
   unsigned int n_rx_nodesc_trunc ;
   unsigned int n_rx_merge_events ;
   unsigned int n_rx_merge_packets ;
   unsigned int rx_pkt_n_frags ;
   unsigned int rx_pkt_index ;
   struct efx_rx_queue rx_queue ;
   struct efx_tx_queue tx_queue[4U] ;
   enum efx_sync_events_state sync_events_state ;
   u32 sync_timestamp_major ;
   u32 sync_timestamp_minor ;
};

#line 571  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
struct efx_msi_context {
   struct efx_nic *efx ;
   unsigned int index ;
   char name[22U] ;
};

#line 625  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
struct efx_channel_type {
   void (*handle_no_channel)(struct efx_nic *) ;
   int (*pre_probe)(struct efx_channel *) ;
   void (*post_remove)(struct efx_channel *) ;
   void (*get_name)(struct efx_channel *, char *, size_t ) ;
   struct efx_channel *(*copy)(struct efx_channel const *) ;
   bool (*receive_skb)(struct efx_channel *, struct sk_buff *) ;
   bool keep_eventq ;
};

#line 648 
enum efx_led_mode {
    EFX_LED_OFF = 0,
    EFX_LED_ON = 1,
    EFX_LED_DEFAULT = 2
};

#line 665 
enum efx_int_mode {
    EFX_INT_MODE_MSIX = 0,
    EFX_INT_MODE_MSI = 1,
    EFX_INT_MODE_LEGACY = 2,
    EFX_INT_MODE_MAX = 3
};

#line 672 
enum nic_state {
    STATE_UNINIT = 0,
    STATE_READY = 1,
    STATE_DISABLED = 2,
    STATE_RECOVERY = 3
};

#line 679  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
struct efx_link_state {
   bool up ;
   bool fd ;
   u8 fc ;
   unsigned int speed ;
};

#line 712  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
struct efx_phy_operations {
   int (*probe)(struct efx_nic *) ;
   int (*init)(struct efx_nic *) ;
   void (*fini)(struct efx_nic *) ;
   void (*remove)(struct efx_nic *) ;
   int (*reconfigure)(struct efx_nic *) ;
   bool (*poll)(struct efx_nic *) ;
   void (*get_settings)(struct efx_nic *, struct ethtool_cmd *) ;
   int (*set_settings)(struct efx_nic *, struct ethtool_cmd *) ;
   void (*set_npage_adv)(struct efx_nic *, u32 ) ;
   int (*test_alive)(struct efx_nic *) ;
   char const *(*test_name)(struct efx_nic *, unsigned int ) ;
   int (*run_tests)(struct efx_nic *, int *, unsigned int ) ;
   int (*get_module_eeprom)(struct efx_nic *, struct ethtool_eeprom *, u8 *) ;
   int (*get_module_info)(struct efx_nic *, struct ethtool_modinfo *) ;
};

#line 751 
enum efx_phy_mode {
    PHY_MODE_NORMAL = 0,
    PHY_MODE_TX_DISABLED = 1,
    PHY_MODE_LOW_POWER = 2,
    PHY_MODE_OFF = 4,
    PHY_MODE_SPECIAL = 8
};

#line 786  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
union efx_multicast_hash {
   u8 byte[32U] ;
   efx_oword_t oword[2U] ;
};

#line 799 
struct efx_nic_type;

#line 799 
struct efx_mcdi_data;

#line 799  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
struct efx_nic {
   char name[16U] ;
   struct list_head node ;
   struct efx_nic *primary ;
   struct list_head secondary_list ;
   struct pci_dev *pci_dev ;
   unsigned int port_num ;
   struct efx_nic_type const *type ;
   int legacy_irq ;
   bool eeh_disabled_legacy_irq ;
   struct workqueue_struct *workqueue ;
   char workqueue_name[16U] ;
   struct work_struct reset_work ;
   resource_size_t membase_phys ;
   void *membase ;
   enum efx_int_mode interrupt_mode ;
   unsigned int timer_quantum_ns ;
   bool irq_rx_adaptive ;
   unsigned int irq_rx_moderation ;
   u32 msg_enable ;
   enum nic_state state ;
   unsigned long reset_pending ;
   struct efx_channel *channel[32U] ;
   struct efx_msi_context msi_context[32U] ;
   struct efx_channel_type const *extra_channel_type[2U] ;
   unsigned int rxq_entries ;
   unsigned int txq_entries ;
   unsigned int txq_stop_thresh ;
   unsigned int txq_wake_thresh ;
   unsigned int tx_dc_base ;
   unsigned int rx_dc_base ;
   unsigned int sram_lim_qw ;
   unsigned int next_buffer_table ;
   unsigned int max_channels ;
   unsigned int n_channels ;
   unsigned int n_rx_channels ;
   unsigned int rss_spread ;
   unsigned int tx_channel_offset ;
   unsigned int n_tx_channels ;
   unsigned int rx_ip_align ;
   unsigned int rx_dma_len ;
   unsigned int rx_buffer_order ;
   unsigned int rx_buffer_truesize ;
   unsigned int rx_page_buf_step ;
   unsigned int rx_bufs_per_page ;
   unsigned int rx_pages_per_batch ;
   unsigned int rx_prefix_size ;
   int rx_packet_hash_offset ;
   int rx_packet_len_offset ;
   int rx_packet_ts_offset ;
   u8 rx_hash_key[40U] ;
   u32 rx_indir_table[128U] ;
   bool rx_scatter ;
   unsigned int int_error_count ;
   unsigned long int_error_expire ;
   bool irq_soft_enabled ;
   struct efx_buffer irq_status ;
   unsigned int irq_zero_count ;
   unsigned int irq_level ;
   struct delayed_work selftest_work ;
   struct list_head mtd_list ;
   void *nic_data ;
   struct efx_mcdi_data *mcdi ;
   struct mutex mac_lock ;
   struct work_struct mac_work ;
   bool port_enabled ;
   bool mc_bist_for_other_fn ;
   bool port_initialized ;
   struct net_device *net_dev ;
   struct efx_buffer stats_buffer ;
   u64 rx_nodesc_drops_total ;
   u64 rx_nodesc_drops_while_down ;
   bool rx_nodesc_drops_prev_state ;
   unsigned int phy_type ;
   struct efx_phy_operations const *phy_op ;
   void *phy_data ;
   struct mdio_if_info mdio ;
   unsigned int mdio_bus ;
   enum efx_phy_mode phy_mode ;
   u32 link_advertising ;
   struct efx_link_state link_state ;
   unsigned int n_link_state_changes ;
   bool unicast_filter ;
   union efx_multicast_hash multicast_hash ;
   u8 wanted_fc ;
   unsigned int fc_disable ;
   atomic_t rx_reset ;
   enum efx_loopback_mode loopback_mode ;
   u64 loopback_modes ;
   void *loopback_selftest ;
   struct rw_semaphore filter_sem ;
   spinlock_t filter_lock ;
   void *filter_state ;
   u32 *rps_flow_id ;
   unsigned int rps_expire_index ;
   atomic_t active_queues ;
   atomic_t rxq_flush_pending ;
   atomic_t rxq_flush_outstanding ;
   wait_queue_head_t flush_wq ;
   unsigned int vf_count ;
   unsigned int vf_init_count ;
   unsigned int vi_scale ;
   struct efx_ptp_data *ptp_data ;
   char *vpd_sn ;
   struct delayed_work monitor_work ;
   spinlock_t biu_lock ;
   int last_irq_cpu ;
   spinlock_t stats_lock ;
   atomic_t n_rx_noskb_drops ;
};

#line 1086  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
struct efx_mtd_partition {
   struct list_head node ;
   struct mtd_info mtd ;
   char const *dev_type_name ;
   char const *type_name ;
   char name[36U] ;
};

#line 1094  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
struct efx_nic_type {
   bool is_vf ;
   unsigned int mem_bar ;
   unsigned int (*mem_map_size)(struct efx_nic *) ;
   int (*probe)(struct efx_nic *) ;
   void (*remove)(struct efx_nic *) ;
   int (*init)(struct efx_nic *) ;
   int (*dimension_resources)(struct efx_nic *) ;
   void (*fini)(struct efx_nic *) ;
   void (*monitor)(struct efx_nic *) ;
   enum reset_type (*map_reset_reason)(enum reset_type ) ;
   int (*map_reset_flags)(u32 *) ;
   int (*reset)(struct efx_nic *, enum reset_type ) ;
   int (*probe_port)(struct efx_nic *) ;
   void (*remove_port)(struct efx_nic *) ;
   bool (*handle_global_event)(struct efx_channel *, efx_qword_t *) ;
   int (*fini_dmaq)(struct efx_nic *) ;
   void (*prepare_flush)(struct efx_nic *) ;
   void (*finish_flush)(struct efx_nic *) ;
   void (*prepare_flr)(struct efx_nic *) ;
   void (*finish_flr)(struct efx_nic *) ;
   size_t (*describe_stats)(struct efx_nic *, u8 *) ;
   size_t (*update_stats)(struct efx_nic *, u64 *, struct rtnl_link_stats64 *) ;
   void (*start_stats)(struct efx_nic *) ;
   void (*pull_stats)(struct efx_nic *) ;
   void (*stop_stats)(struct efx_nic *) ;
   void (*set_id_led)(struct efx_nic *, enum efx_led_mode ) ;
   void (*push_irq_moderation)(struct efx_channel *) ;
   int (*reconfigure_port)(struct efx_nic *) ;
   void (*prepare_enable_fc_tx)(struct efx_nic *) ;
   int (*reconfigure_mac)(struct efx_nic *) ;
   bool (*check_mac_fault)(struct efx_nic *) ;
   void (*get_wol)(struct efx_nic *, struct ethtool_wolinfo *) ;
   int (*set_wol)(struct efx_nic *, u32 ) ;
   void (*resume_wol)(struct efx_nic *) ;
   int (*test_chip)(struct efx_nic *, struct efx_self_tests *) ;
   int (*test_nvram)(struct efx_nic *) ;
   void (*mcdi_request)(struct efx_nic *, efx_dword_t const *, size_t , efx_dword_t const *, size_t ) ;
   bool (*mcdi_poll_response)(struct efx_nic *) ;
   void (*mcdi_read_response)(struct efx_nic *, efx_dword_t *, size_t , size_t ) ;
   int (*mcdi_poll_reboot)(struct efx_nic *) ;
   void (*irq_enable_master)(struct efx_nic *) ;
   void (*irq_test_generate)(struct efx_nic *) ;
   void (*irq_disable_non_ev)(struct efx_nic *) ;
   irqreturn_t (*irq_handle_msi)(int , void *) ;
   irqreturn_t (*irq_handle_legacy)(int , void *) ;
   int (*tx_probe)(struct efx_tx_queue *) ;
   void (*tx_init)(struct efx_tx_queue *) ;
   void (*tx_remove)(struct efx_tx_queue *) ;
   void (*tx_write)(struct efx_tx_queue *) ;
   int (*rx_push_rss_config)(struct efx_nic *, bool , u32 const *) ;
   int (*rx_probe)(struct efx_rx_queue *) ;
   void (*rx_init)(struct efx_rx_queue *) ;
   void (*rx_remove)(struct efx_rx_queue *) ;
   void (*rx_write)(struct efx_rx_queue *) ;
   void (*rx_defer_refill)(struct efx_rx_queue *) ;
   int (*ev_probe)(struct efx_channel *) ;
   int (*ev_init)(struct efx_channel *) ;
   void (*ev_fini)(struct efx_channel *) ;
   void (*ev_remove)(struct efx_channel *) ;
   int (*ev_process)(struct efx_channel *, int ) ;
   void (*ev_read_ack)(struct efx_channel *) ;
   void (*ev_test_generate)(struct efx_channel *) ;
   int (*filter_table_probe)(struct efx_nic *) ;
   void (*filter_table_restore)(struct efx_nic *) ;
   void (*filter_table_remove)(struct efx_nic *) ;
   void (*filter_update_rx_scatter)(struct efx_nic *) ;
   s32 (*filter_insert)(struct efx_nic *, struct efx_filter_spec *, bool ) ;
   int (*filter_remove_safe)(struct efx_nic *, enum efx_filter_priority , u32 ) ;
   int (*filter_get_safe)(struct efx_nic *, enum efx_filter_priority , u32 , struct efx_filter_spec *) ;
   int (*filter_clear_rx)(struct efx_nic *, enum efx_filter_priority ) ;
   u32 (*filter_count_rx_used)(struct efx_nic *, enum efx_filter_priority ) ;
   u32 (*filter_get_rx_id_limit)(struct efx_nic *) ;
   s32 (*filter_get_rx_ids)(struct efx_nic *, enum efx_filter_priority , u32 *, u32 ) ;
   s32 (*filter_rfs_insert)(struct efx_nic *, struct efx_filter_spec *) ;
   bool (*filter_rfs_expire_one)(struct efx_nic *, u32 , unsigned int ) ;
   int (*mtd_probe)(struct efx_nic *) ;
   void (*mtd_rename)(struct efx_mtd_partition *) ;
   int (*mtd_read)(struct mtd_info *, loff_t , size_t , size_t *, u8 *) ;
   int (*mtd_erase)(struct mtd_info *, loff_t , size_t ) ;
   int (*mtd_write)(struct mtd_info *, loff_t , size_t , size_t *, u8 const *) ;
   int (*mtd_sync)(struct mtd_info *) ;
   void (*ptp_write_host_time)(struct efx_nic *, u32 ) ;
   int (*ptp_set_ts_sync_events)(struct efx_nic *, bool , bool ) ;
   int (*ptp_set_ts_config)(struct efx_nic *, struct hwtstamp_config *) ;
   int (*sriov_configure)(struct efx_nic *, int ) ;
   int (*sriov_init)(struct efx_nic *) ;
   void (*sriov_fini)(struct efx_nic *) ;
   bool (*sriov_wanted)(struct efx_nic *) ;
   void (*sriov_reset)(struct efx_nic *) ;
   void (*sriov_flr)(struct efx_nic *, unsigned int ) ;
   int (*sriov_set_vf_mac)(struct efx_nic *, int , u8 *) ;
   int (*sriov_set_vf_vlan)(struct efx_nic *, int , u16 , u8 ) ;
   int (*sriov_set_vf_spoofchk)(struct efx_nic *, int , bool ) ;
   int (*sriov_get_vf_config)(struct efx_nic *, int , struct ifla_vf_info *) ;
   int (*sriov_set_vf_link_state)(struct efx_nic *, int , int ) ;
   int (*sriov_get_phys_port_id)(struct efx_nic *, struct netdev_phys_item_id *) ;
   int (*vswitching_probe)(struct efx_nic *) ;
   int (*vswitching_restore)(struct efx_nic *) ;
   void (*vswitching_remove)(struct efx_nic *) ;
   int (*get_mac_address)(struct efx_nic *, unsigned char *) ;
   int (*set_mac_address)(struct efx_nic *) ;
   int revision ;
   unsigned int txd_ptr_tbl_base ;
   unsigned int rxd_ptr_tbl_base ;
   unsigned int buf_tbl_base ;
   unsigned int evq_ptr_tbl_base ;
   unsigned int evq_rptr_tbl_base ;
   u64 max_dma_mask ;
   unsigned int rx_prefix_size ;
   unsigned int rx_hash_offset ;
   unsigned int rx_ts_offset ;
   unsigned int rx_buffer_padding ;
   bool can_rx_scatter ;
   bool always_rx_scatter ;
   unsigned int max_interrupt_mode ;
   unsigned int timer_period_max ;
   netdev_features_t offload_features ;
   int mcdi_max_ver ;
   unsigned int max_rx_ip_filters ;
   u32 hwtstamp_filters ;
};

#line 269  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
struct i2c_algo_bit_data {
   void *data ;
   void (*setsda)(void *, int ) ;
   void (*setscl)(void *, int ) ;
   int (*getsda)(void *) ;
   int (*getscl)(void *) ;
   int (*pre_xfer)(struct i2c_adapter *) ;
   void (*post_xfer)(struct i2c_adapter *) ;
   int udelay ;
   int timeout ;
};

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/i2c-algo-bit.h"
enum efx_mcdi_state {
    MCDI_STATE_QUIESCENT = 0,
    MCDI_STATE_RUNNING_SYNC = 1,
    MCDI_STATE_RUNNING_ASYNC = 2,
    MCDI_STATE_COMPLETED = 3
};

#line 61 
enum efx_mcdi_mode {
    MCDI_MODE_POLL = 0,
    MCDI_MODE_EVENTS = 1,
    MCDI_MODE_FAIL = 2
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/i2c-algo-bit.h"
struct efx_mcdi_iface {
   struct efx_nic *efx ;
   enum efx_mcdi_state state ;
   enum efx_mcdi_mode mode ;
   wait_queue_head_t wq ;
   spinlock_t iface_lock ;
   bool new_epoch ;
   unsigned int credits ;
   unsigned int seqno ;
   int resprc ;
   size_t resp_hdr_len ;
   size_t resp_data_len ;
   spinlock_t async_lock ;
   struct list_head async_list ;
   struct timer_list async_timer ;
   char *logging_buffer ;
   bool logging_enabled ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.h"
struct efx_mcdi_mon {
   struct efx_buffer dma_buf ;
   struct mutex update_lock ;
   unsigned long last_update ;
   struct device *device ;
   struct efx_mcdi_mon_attribute *attrs ;
   struct attribute_group group ;
   struct attribute_group const *groups[2U] ;
   unsigned int n_attrs ;
};

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.h"
struct efx_mcdi_data {
   struct efx_mcdi_iface iface ;
   struct efx_mcdi_mon hwmon ;
   u32 fn_flags ;
};

#line 152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
struct falcon_board_type {
   u8 id ;
   int (*init)(struct efx_nic *) ;
   void (*init_phy)(struct efx_nic *) ;
   void (*fini)(struct efx_nic *) ;
   void (*set_id_led)(struct efx_nic *, enum efx_led_mode ) ;
   int (*monitor)(struct efx_nic *) ;
};

#line 181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
struct falcon_board {
   struct falcon_board_type const *type ;
   int major ;
   int minor ;
   struct i2c_adapter i2c_adap ;
   struct i2c_algo_bit_data i2c_data ;
   struct i2c_client *hwmon_client ;
   struct i2c_client *ioexp_client ;
};

#line 200  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
struct falcon_spi_device {
   int device_id ;
   unsigned int size ;
   unsigned int addr_len ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) munge_address : 1 ;
   u8 erase_command ;
   unsigned int erase_size ;
   unsigned int block_size ;
};

#line 283  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
struct falcon_nic_data {
   struct pci_dev *pci_dev2 ;
   struct falcon_board board ;
   u64 stats[49U] ;
   unsigned int stats_disable_count ;
   bool stats_pending ;
   struct timer_list stats_timer ;
   struct falcon_spi_device spi_flash ;
   struct falcon_spi_device spi_eeprom ;
   struct mutex spi_lock ;
   struct mutex mdio_lock ;
   bool xmac_poll_required ;
};

#line 378  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
struct siena_nic_data {
   struct efx_nic *efx ;
   int wol_filter_id ;
   u64 stats[59U] ;
   struct siena_vf *vf ;
   struct efx_channel *vfdi_channel ;
   unsigned int vf_buftbl_base ;
   struct efx_buffer vfdi_status ;
   struct list_head local_addr_list ;
   struct list_head local_page_list ;
   struct mutex local_lock ;
   struct work_struct peer_work ;
};

#line 774  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
struct efx_farch_register_test {
   unsigned int address ;
   efx_oword_t mask ;
};

#line 1840  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
enum efx_farch_filter_table_id {
    EFX_FARCH_FILTER_TABLE_RX_IP = 0,
    EFX_FARCH_FILTER_TABLE_RX_MAC = 1,
    EFX_FARCH_FILTER_TABLE_RX_DEF = 2,
    EFX_FARCH_FILTER_TABLE_TX_MAC = 3,
    EFX_FARCH_FILTER_TABLE_COUNT = 4
};

#line 1854  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
struct efx_farch_filter_spec {
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) type : 4 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) priority : 4 ;
   u8 flags ;
   u16 dmaq_id ;
   u32 data[3U] ;
};

#line 1886  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
struct efx_farch_filter_table {
   enum efx_farch_filter_table_id id ;
   u32 offset ;
   unsigned int size ;
   unsigned int step ;
   unsigned int used ;
   unsigned long *used_bitmap ;
   struct efx_farch_filter_spec *spec ;
   unsigned int search_limit[10U] ;
};

#line 1897  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
struct efx_farch_filter_state {
   struct efx_farch_filter_table table[4U] ;
};

#line 797  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
struct txc43128_data {
   unsigned long bug10934_timer ;
   enum efx_phy_mode phy_mode ;
   enum efx_loopback_mode loopback_mode ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u16 __le16;

#line 796  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct __anonstruct_near_1004 {
   u16 index ;
   u16 dist ;
};

#line 796  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct cpu_rmap {
   struct kref refcount ;
   u16 size ;
   u16 used ;
   void **obj ;
   struct __anonstruct_near_1004 near[0U] ;
};

#line 773  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
struct efx_hw_stat_desc {
   char const *name ;
   u16 dma_width ;
   u16 offset ;
};

#line 168  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.c"
struct efx_nic_reg {
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))) offset : 24 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) min_revision : 3 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) max_revision : 3 ;
};

#line 198  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.c"
struct efx_nic_reg_table {
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))) offset : 24 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) min_revision : 3 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) max_revision : 3 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))) step : 6 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(21))) rows : 21 ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u16 __sum16;

#line 1911  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct iphdr {
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) ihl : 4 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) version : 4 ;
   __u8 tos ;
   __be16 tot_len ;
   __be16 id ;
   __be16 frag_off ;
   __u8 ttl ;
   __u8 protocol ;
   __sum16 check ;
   __be32 saddr ;
   __be32 daddr ;
};

#line 274  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_sock.h"
struct udphdr {
   __be16 source ;
   __be16 dest ;
   __be16 len ;
   __sum16 check ;
};

#line 797  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
struct efx_loopback_self_tests {
   int tx_sent[4U] ;
   int tx_done[4U] ;
   int rx_good ;
   int rx_bad ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.h"
struct efx_self_tests {
   int phy_alive ;
   int nvram ;
   int interrupt ;
   int eventq_dma[32U] ;
   int eventq_int[32U] ;
   int memory ;
   int registers ;
   int phy_ext[20U] ;
   struct efx_loopback_self_tests loopback[18U] ;
};

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.h"
struct efx_loopback_payload {
   struct ethhdr header ;
   struct iphdr ip ;
   struct udphdr udp ;
   __be16 iteration ;
   char msg[64U] ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.c"
struct efx_loopback_state {
   bool flush ;
   int packet_count ;
   struct sk_buff **skbs ;
   bool offload_csum ;
   atomic_t rx_good ;
   atomic_t rx_bad ;
   struct efx_loopback_payload payload ;
};

#line 1527  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
struct ef10_vf {
   struct efx_nic *efx ;
   struct pci_dev *pci_dev ;
   unsigned int vport_id ;
   unsigned int vport_assigned ;
   u8 mac[6U] ;
   u16 vlan ;
};

#line 482  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
struct efx_ef10_nic_data {
   struct efx_buffer mcdi_buf ;
   u16 warm_boot_count ;
   unsigned int vi_base ;
   unsigned int n_allocated_vis ;
   bool must_realloc_vis ;
   bool must_restore_filters ;
   unsigned int n_piobufs ;
   void *wc_membase ;
   void *pio_write_base ;
   unsigned int pio_write_vi_base ;
   unsigned int piobuf_handle[16U] ;
   bool must_restore_piobufs ;
   u32 rx_rss_context ;
   bool rx_rss_context_exclusive ;
   u64 stats[73U] ;
   bool workaround_35388 ;
   bool must_check_datapath_caps ;
   u32 datapath_caps ;
   unsigned int rx_dpcpu_fw_id ;
   unsigned int tx_dpcpu_fw_id ;
   unsigned int vport_id ;
   bool must_probe_vswitching ;
   unsigned int pf_index ;
   u8 port_id[6U] ;
   unsigned int vf_index ;
   struct ef10_vf *vf ;
   u8 vport_mac[6U] ;
};

#line 107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u16 uint16_t;

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.h"
struct efx_mcdi_mtd_partition {
   struct efx_mtd_partition common ;
   bool updating ;
   u16 nvram_type ;
   u16 fw_subtype ;
};

#line 779  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
struct siena_nvram_type_info {
   int port ;
   char const *name ;
};

#line 366  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mtd/mtd.h"
struct mtd_partition;

#line 367 
struct mtd_part_parser_data;

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/i2c.h"
struct i2c_board_info;

#line 271  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/i2c.h"
struct i2c_board_info {
   char type[20U] ;
   unsigned short flags ;
   unsigned short addr ;
   void *platform_data ;
   struct dev_archdata *archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   int irq ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/qt202x_phy.c"
struct qt202x_phy_data {
   enum efx_phy_mode phy_mode ;
   bool bug17190_in_bad_state ;
   unsigned long bug17190_timer ;
   u32 firmware_ver ;
};

#line 116  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/bitfield.h"
enum efx_filter_flags {
    EFX_FILTER_FLAG_RX_RSS = 1,
    EFX_FILTER_FLAG_RX_SCATTER = 2,
    EFX_FILTER_FLAG_RX_OVER_AUTO = 4,
    EFX_FILTER_FLAG_RX = 8,
    EFX_FILTER_FLAG_TX = 16
};

#line 797  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
enum ldv_37171 {
    EFX_ETHTOOL_STAT_SOURCE_nic = 0,
    EFX_ETHTOOL_STAT_SOURCE_channel = 1,
    EFX_ETHTOOL_STAT_SOURCE_tx_queue = 2
};

#line 803  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
struct efx_sw_stat_desc {
   char const *name ;
   enum ldv_37171 source ;
   unsigned int offset ;
   u64 (*get_stat)(void *) ;
};

#line 797 
enum efx_hwmon_type {
    EFX_HWMON_UNKNOWN = 0,
    EFX_HWMON_TEMP = 1,
    EFX_HWMON_COOL = 2,
    EFX_HWMON_IN = 3,
    EFX_HWMON_CURR = 4,
    EFX_HWMON_POWER = 5,
    EFX_HWMON_TYPES_COUNT = 6
};

#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_mon.c"
struct __anonstruct_efx_mcdi_sensor_type_4217 {
   char const *label ;
   enum efx_hwmon_type hwmon_type ;
   int port ;
};

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_mon.c"
struct efx_mcdi_mon_attribute {
   struct device_attribute dev_attr ;
   unsigned int index ;
   unsigned int type ;
   enum efx_hwmon_type hwmon_type ;
   unsigned int limit_value ;
   char name[12U] ;
};

#line 215  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_frag_struct;

#line 215  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
typedef struct skb_frag_struct skb_frag_t;

#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_page_4460 {
   struct page *p ;
};

#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_frag_struct {
   struct __anonstruct_page_4460 page ;
   __u32 page_offset ;
   __u32 size ;
};

#line 249  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_shared_hwtstamps {
   ktime_t hwtstamp ;
};

#line 319  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_shared_info {
   unsigned char nr_frags ;
   __u8 tx_flags ;
   unsigned short gso_size ;
   unsigned short gso_segs ;
   unsigned short gso_type ;
   struct sk_buff *frag_list ;
   struct skb_shared_hwtstamps hwtstamps ;
   u32 tskey ;
   __be32 ip6_frag_id ;
   atomic_t dataref ;
   void *destructor_arg ;
   skb_frag_t frags[17U] ;
};

#line 890 
enum pkt_hash_types {
    PKT_HASH_TYPE_NONE = 0,
    PKT_HASH_TYPE_L2 = 1,
    PKT_HASH_TYPE_L3 = 2,
    PKT_HASH_TYPE_L4 = 3
};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ipv6.h"
struct ipv6hdr {
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) priority : 4 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) version : 4 ;
   __u8 flow_lbl[3U] ;
   __be16 payload_len ;
   __u8 nexthdr ;
   __u8 hop_limit ;
   struct in6_addr saddr ;
   struct in6_addr daddr ;
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
struct of_phandle_args {
   struct device_node *np ;
   int args_count ;
   uint32_t args[16U] ;
};

#line 331  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
enum gro_result {
    GRO_MERGED = 0,
    GRO_MERGED_FREE = 1,
    GRO_HELD = 2,
    GRO_NORMAL = 3,
    GRO_DROP = 4
};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum gro_result gro_result_t;

#line 160  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/trace/events/iommu.h"
struct iommu_domain;

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/iommu.h"
struct iommu_domain_geometry {
   dma_addr_t aperture_start ;
   dma_addr_t aperture_end ;
   bool force_aperture ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/iommu.h"
struct iommu_domain {
   unsigned int type ;
   struct iommu_ops const *ops ;
   int (*handler)(struct iommu_domain *, struct device *, unsigned long , int , void *) ;
   void *handler_token ;
   struct iommu_domain_geometry geometry ;
};

#line 85 
enum iommu_cap {
    IOMMU_CAP_CACHE_COHERENCY = 0,
    IOMMU_CAP_INTR_REMAP = 1,
    IOMMU_CAP_NOEXEC = 2
};

#line 91 
enum iommu_attr {
    DOMAIN_ATTR_GEOMETRY = 0,
    DOMAIN_ATTR_PAGING = 1,
    DOMAIN_ATTR_WINDOWS = 2,
    DOMAIN_ATTR_FSL_PAMU_STASH = 3,
    DOMAIN_ATTR_FSL_PAMU_ENABLE = 4,
    DOMAIN_ATTR_FSL_PAMUV1 = 5,
    DOMAIN_ATTR_NESTING = 6,
    DOMAIN_ATTR_MAX = 7
};

#line 130  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/iommu.h"
struct iommu_ops {
   bool (*capable)(enum iommu_cap ) ;
   struct iommu_domain *(*domain_alloc)(unsigned int ) ;
   void (*domain_free)(struct iommu_domain *) ;
   int (*attach_dev)(struct iommu_domain *, struct device *) ;
   void (*detach_dev)(struct iommu_domain *, struct device *) ;
   int (*map)(struct iommu_domain *, unsigned long , phys_addr_t , size_t , int ) ;
   size_t (*unmap)(struct iommu_domain *, unsigned long , size_t ) ;
   size_t (*map_sg)(struct iommu_domain *, unsigned long , struct scatterlist *, unsigned int , int ) ;
   phys_addr_t (*iova_to_phys)(struct iommu_domain *, dma_addr_t ) ;
   int (*add_device)(struct device *) ;
   void (*remove_device)(struct device *) ;
   int (*device_group)(struct device *, unsigned int *) ;
   int (*domain_get_attr)(struct iommu_domain *, enum iommu_attr , void *) ;
   int (*domain_set_attr)(struct iommu_domain *, enum iommu_attr , void *) ;
   void (*get_dm_regions)(struct device *, struct list_head *) ;
   void (*put_dm_regions)(struct device *, struct list_head *) ;
   int (*domain_window_enable)(struct iommu_domain *, u32 , phys_addr_t , u64 , int ) ;
   void (*domain_window_disable)(struct iommu_domain *, u32 ) ;
   int (*domain_set_windows)(struct iommu_domain *, u32 ) ;
   u32 (*domain_get_windows)(struct iommu_domain *) ;
   int (*of_xlate)(struct device *, struct of_phandle_args *) ;
   unsigned long pgsize_bitmap ;
   void *priv ;
};

#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_vlan.h"
struct vlan_hdr {
   __be16 h_vlan_TCI ;
   __be16 h_vlan_encapsulated_proto ;
};

#line 284  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
struct efx_rx_page_state {
   dma_addr_t dma_addr ;
   unsigned int __pad[0U] ;
};

#line 647  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
typedef int ldv_func_ret_type;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/preempt.h"
typedef int pao_T__;

#line 2893  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
enum skb_free_reason {
    SKB_REASON_CONSUMED = 0,
    SKB_REASON_DROPPED = 1
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_timewait_sock.h"
struct tcphdr {
   __be16 source ;
   __be16 dest ;
   __be32 seq ;
   __be32 ack_seq ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) res1 : 4 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) doff : 4 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) fin : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) syn : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) rst : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) psh : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ack : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) urg : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ece : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cwr : 1 ;
   __be16 window ;
   __sum16 check ;
   __be16 urg_ptr ;
};

#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_vlan.h"
struct vlan_ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_vlan_proto ;
   __be16 h_vlan_TCI ;
   __be16 h_vlan_encapsulated_proto ;
};

#line 175  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
struct efx_short_copy_buffer {
   int used ;
   u8 buf[64U] ;
};

#line 775  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
struct tso_state {
   unsigned int out_len ;
   unsigned int seqnum ;
   u16 ipv4_id ;
   unsigned int packet_space ;
   dma_addr_t dma_addr ;
   unsigned int in_len ;
   unsigned int unmap_len ;
   dma_addr_t unmap_addr ;
   unsigned short dma_flags ;
   __be16 protocol ;
   unsigned int ip_off ;
   unsigned int tcp_off ;
   unsigned int header_len ;
   unsigned int ip_base_len ;
   dma_addr_t header_dma_addr ;
   unsigned int header_unmap_len ;
};

#line 154  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.h"
typedef void efx_mcdi_async_completer(struct efx_nic *, unsigned long , int , efx_dword_t *, size_t );

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/phy.h"
struct efx_mcdi_async_param {
   struct list_head list ;
   unsigned int cmd ;
   size_t inlen ;
   size_t outlen ;
   bool quiet ;
   efx_mcdi_async_completer *complete ;
   unsigned long cookie ;
};

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/bitfield.h"
enum efx_filter_match_flags {
    EFX_FILTER_MATCH_REM_HOST = 1,
    EFX_FILTER_MATCH_LOC_HOST = 2,
    EFX_FILTER_MATCH_REM_MAC = 4,
    EFX_FILTER_MATCH_REM_PORT = 8,
    EFX_FILTER_MATCH_LOC_MAC = 16,
    EFX_FILTER_MATCH_LOC_PORT = 32,
    EFX_FILTER_MATCH_ETHER_TYPE = 64,
    EFX_FILTER_MATCH_INNER_VID = 128,
    EFX_FILTER_MATCH_OUTER_VID = 256,
    EFX_FILTER_MATCH_IP_PROTO = 512,
    EFX_FILTER_MATCH_LOC_MAC_IG = 1024
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.h"
struct __anonstruct_entry_6217 {
   unsigned long spec ;
   u64 handle ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.h"
struct __anonstruct_dev_uc_list_6218 {
   u8 addr[6U] ;
   u16 id ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.h"
struct __anonstruct_dev_mc_list_6219 {
   u8 addr[6U] ;
   u16 id ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.h"
struct efx_ef10_filter_table {
   enum efx_filter_match_flags rx_match_flags[61U] ;
   unsigned int rx_match_count ;
   struct __anonstruct_entry_6217 *entry ;
   wait_queue_head_t waitq ;
   struct __anonstruct_dev_uc_list_6218 dev_uc_list[32U] ;
   struct __anonstruct_dev_mc_list_6219 dev_mc_list[256U] ;
   int dev_uc_count ;
   int dev_mc_count ;
};

#line 4116  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
struct efx_ef10_nvram_type_info {
   u16 type ;
   u16 type_mask ;
   u8 port ;
   char const *name ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
enum ldv_12066 {
    WORK_STRUCT_PENDING_BIT = 0,
    WORK_STRUCT_DELAYED_BIT = 1,
    WORK_STRUCT_PWQ_BIT = 2,
    WORK_STRUCT_LINKED_BIT = 3,
    WORK_STRUCT_STATIC_BIT = 4,
    WORK_STRUCT_COLOR_SHIFT = 5,
    WORK_STRUCT_COLOR_BITS = 4,
    WORK_STRUCT_PENDING = 1,
    WORK_STRUCT_DELAYED = 2,
    WORK_STRUCT_PWQ = 4,
    WORK_STRUCT_LINKED = 8,
    WORK_STRUCT_STATIC = 16,
    WORK_NR_COLORS = 15,
    WORK_NO_COLOR = 15,
    WORK_CPU_UNBOUND = 8192,
    WORK_STRUCT_FLAG_BITS = 9,
    WORK_OFFQ_FLAG_BASE = 5,
    __WORK_OFFQ_CANCELING = 5,
    WORK_OFFQ_CANCELING = 32,
    WORK_OFFQ_FLAG_BITS = 1,
    WORK_OFFQ_POOL_SHIFT = 6,
    WORK_OFFQ_LEFT = 58,
    WORK_OFFQ_POOL_BITS = 31,
    WORK_OFFQ_POOL_NONE = 2147483647,
    WORK_STRUCT_FLAG_MASK = 511,
    WORK_STRUCT_WQ_DATA_MASK = -512,
    WORK_STRUCT_NO_POOL = 137438953408,
    WORK_BUSY_PENDING = 1,
    WORK_BUSY_RUNNING = 2,
    WORKER_DESC_LEN = 24
};

#line 1341  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct acpi_device;

#line 1341  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_sysdata {
   int domain ;
   int node ;
   struct acpi_device *companion ;
   void *iommu ;
};

#line 798  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
struct vfdi_status;

#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.h"
struct vfdi_endpoint {
   u8 mac_addr[6U] ;
   __be16 tci ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/vfdi.h"
struct __anonstruct_init_evq_6796 {
   u32 index ;
   u32 buf_count ;
   u64 addr[] ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/vfdi.h"
struct __anonstruct_init_rxq_6797 {
   u32 index ;
   u32 buf_count ;
   u32 evq ;
   u32 label ;
   u32 flags ;
   u32 reserved ;
   u64 addr[] ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/vfdi.h"
struct __anonstruct_init_txq_6798 {
   u32 index ;
   u32 buf_count ;
   u32 evq ;
   u32 label ;
   u32 flags ;
   u32 reserved ;
   u64 addr[] ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/vfdi.h"
struct __anonstruct_mac_filter_6799 {
   u32 rxq ;
   u32 flags ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/vfdi.h"
struct __anonstruct_set_status_page_6800 {
   u64 dma_addr ;
   u64 peer_page_count ;
   u64 peer_page_addr[] ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/vfdi.h"
union __anonunion_u_6795 {
   struct __anonstruct_init_evq_6796 init_evq ;
   struct __anonstruct_init_rxq_6797 init_rxq ;
   struct __anonstruct_init_txq_6798 init_txq ;
   struct __anonstruct_mac_filter_6799 mac_filter ;
   struct __anonstruct_set_status_page_6800 set_status_page ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/vfdi.h"
struct vfdi_req {
   u32 op ;
   u32 reserved1 ;
   s32 rc ;
   u32 reserved2 ;
   union __anonunion_u_6795 u ;
};

#line 210  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/vfdi.h"
struct vfdi_status {
   u32 generation_start ;
   u32 generation_end ;
   u32 version ;
   u32 length ;
   u8 vi_scale ;
   u8 max_tx_channels ;
   u8 rss_rxq_count ;
   u8 reserved1 ;
   u16 peer_count ;
   u16 reserved2 ;
   struct vfdi_endpoint local ;
   struct vfdi_endpoint peers[256U] ;
   u32 timer_quantum_ns ;
};

#line 254 
enum efx_vf_tx_filter_mode {
    VF_TX_FILTER_OFF = 0,
    VF_TX_FILTER_AUTO = 1,
    VF_TX_FILTER_ON = 2
};

#line 260  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/vfdi.h"
struct siena_vf {
   struct efx_nic *efx ;
   unsigned int pci_rid ;
   char pci_name[13U] ;
   unsigned int index ;
   struct work_struct req ;
   u64 req_addr ;
   int req_type ;
   unsigned int req_seqno ;
   unsigned int msg_seqno ;
   bool busy ;
   struct efx_buffer buf ;
   unsigned int buftbl_base ;
   bool rx_filtering ;
   enum efx_filter_flags rx_filter_flags ;
   unsigned int rx_filter_qid ;
   int rx_filter_id ;
   enum efx_vf_tx_filter_mode tx_filter_mode ;
   int tx_filter_id ;
   struct vfdi_endpoint addr ;
   u64 status_addr ;
   struct mutex status_lock ;
   u64 *peer_page_addrs ;
   unsigned int peer_page_count ;
   u64 evq0_addrs[16U] ;
   unsigned int evq0_count ;
   wait_queue_head_t flush_waitq ;
   struct mutex txq_lock ;
   unsigned long txq_mask[1U] ;
   unsigned int txq_count ;
   unsigned long rxq_mask[1U] ;
   unsigned int rxq_count ;
   unsigned long rxq_retry_mask[1U] ;
   atomic_t rxq_retry_count ;
   struct work_struct reset_work ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
struct efx_memcpy_req {
   unsigned int from_rid ;
   void *from_buf ;
   u64 from_addr ;
   unsigned int to_rid ;
   u64 to_addr ;
   unsigned int length ;
};

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
struct efx_local_addr {
   struct list_head link ;
   u8 addr[6U] ;
};

#line 149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
struct efx_endpoint_page {
   struct list_head link ;
   void *ptr ;
   dma_addr_t addr ;
};

#line 860  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
typedef int (*efx_vfdi_op_t)(struct siena_vf *);

#line 493  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
struct __anonstruct_mm_segment_t_7250 {
   unsigned long seg ;
};

#line 493  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
typedef struct __anonstruct_mm_segment_t_7250 mm_segment_t;

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/atomic-long.h"
struct thread_info {
   struct task_struct *task ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int saved_preempt_count ;
   mm_segment_t addr_limit ;
   void *sysenter_return ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sig_on_uaccess_error : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) uaccess_err : 1 ;
};

#line 200  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
struct falcon_nvconfig_board_v2 {
   __le16 nports ;
   u8 port0_phy_addr ;
   u8 port0_phy_type ;
   u8 port1_phy_addr ;
   u8 port1_phy_type ;
   __le16 asic_sub_revision ;
   __le16 board_revision ;
};

#line 258  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
struct falcon_nvconfig_board_v3 {
   __le32 spi_device_type[2U] ;
};

#line 263  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
struct falcon_nvconfig {
   efx_oword_t ee_vpd_cfg_reg ;
   u8 mac_address[2U][8U] ;
   efx_oword_t pcie_sd_ctl0123_reg ;
   efx_oword_t pcie_sd_ctl45_reg ;
   efx_oword_t pcie_pcs_ctl_stat_reg ;
   efx_oword_t hw_init_reg ;
   efx_oword_t nic_stat_reg ;
   efx_oword_t glb_ctl_reg ;
   efx_oword_t srm_cfg_reg ;
   efx_oword_t spare_reg ;
   __le16 board_magic_num ;
   __le16 board_struct_ver ;
   __le16 board_checksum ;
   struct falcon_nvconfig_board_v2 board_v2 ;
   efx_oword_t ee_base_page_reg ;
   struct falcon_nvconfig_board_v3 board_v3 ;
};

#line 643  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
struct falcon_mtd_partition {
   struct efx_mtd_partition common ;
   struct falcon_spi_device const *spi ;
   size_t offset ;
};

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef long long __s64;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
enum ldv_11594 {
    WORK_STRUCT_PENDING_BIT_0 = 0,
    WORK_STRUCT_DELAYED_BIT_0 = 1,
    WORK_STRUCT_PWQ_BIT_0 = 2,
    WORK_STRUCT_LINKED_BIT_0 = 3,
    WORK_STRUCT_STATIC_BIT_0 = 4,
    WORK_STRUCT_COLOR_SHIFT_0 = 5,
    WORK_STRUCT_COLOR_BITS_0 = 4,
    WORK_STRUCT_PENDING_0 = 1,
    WORK_STRUCT_DELAYED_0 = 2,
    WORK_STRUCT_PWQ_0 = 4,
    WORK_STRUCT_LINKED_0 = 8,
    WORK_STRUCT_STATIC_0 = 16,
    WORK_NR_COLORS_0 = 15,
    WORK_NO_COLOR_0 = 15,
    WORK_CPU_UNBOUND_0 = 8192,
    WORK_STRUCT_FLAG_BITS_0 = 9,
    WORK_OFFQ_FLAG_BASE_0 = 5,
    __WORK_OFFQ_CANCELING_0 = 5,
    WORK_OFFQ_CANCELING_0 = 32,
    WORK_OFFQ_FLAG_BITS_0 = 1,
    WORK_OFFQ_POOL_SHIFT_0 = 6,
    WORK_OFFQ_LEFT_0 = 58,
    WORK_OFFQ_POOL_BITS_0 = 31,
    WORK_OFFQ_POOL_NONE_0 = 2147483647,
    WORK_STRUCT_FLAG_MASK_0 = 511,
    WORK_STRUCT_WQ_DATA_MASK_0 = -512,
    WORK_STRUCT_NO_POOL_0 = 137438953408,
    WORK_BUSY_PENDING_0 = 1,
    WORK_BUSY_RUNNING_0 = 2,
    WORKER_DESC_LEN_0 = 24
};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/pps.h"
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations const *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pps_kernel.h"
struct pps_event_time {
   struct timespec ts_real ;
};

#line 135  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pps_kernel.h"
struct ptp_clock_time {
   __s64 sec ;
   __u32 nsec ;
   __u32 reserved ;
};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ptp_clock.h"
struct ptp_extts_request {
   unsigned int index ;
   unsigned int flags ;
   unsigned int rsv[2U] ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ptp_clock.h"
struct ptp_perout_request {
   struct ptp_clock_time start ;
   struct ptp_clock_time period ;
   unsigned int index ;
   unsigned int flags ;
   unsigned int rsv[4U] ;
};

#line 83 
enum ptp_pin_function {
    PTP_PF_NONE = 0,
    PTP_PF_EXTTS = 1,
    PTP_PF_PEROUT = 2,
    PTP_PF_PHYSYNC = 3
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ptp_clock.h"
struct ptp_pin_desc {
   char name[64U] ;
   unsigned int index ;
   unsigned int func ;
   unsigned int chan ;
   unsigned int rsv[5U] ;
};

#line 134 
enum ldv_33863 {
    PTP_CLK_REQ_EXTTS = 0,
    PTP_CLK_REQ_PEROUT = 1,
    PTP_CLK_REQ_PPS = 2
};

#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ptp_clock.h"
union __anonunion_7963 {
   struct ptp_extts_request extts ;
   struct ptp_perout_request perout ;
};

#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ptp_clock.h"
struct ptp_clock_request {
   enum ldv_33863 type ;
   union __anonunion_7963 __anonCompField_ptp_clock_request_109 ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ptp_clock_kernel.h"
struct ptp_clock_info {
   struct module *owner ;
   char name[16U] ;
   s32 max_adj ;
   int n_alarm ;
   int n_ext_ts ;
   int n_per_out ;
   int n_pins ;
   int pps ;
   struct ptp_pin_desc *pin_config ;
   int (*adjfreq)(struct ptp_clock_info *, s32 ) ;
   int (*adjtime)(struct ptp_clock_info *, s64 ) ;
   int (*gettime64)(struct ptp_clock_info *, struct timespec *) ;
   int (*settime64)(struct ptp_clock_info *, struct timespec const *) ;
   int (*enable)(struct ptp_clock_info *, struct ptp_clock_request *, int ) ;
   int (*verify)(struct ptp_clock_info *, unsigned int , enum ptp_pin_function , unsigned int ) ;
};

#line 113 
struct ptp_clock;

#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ptp_clock_kernel.h"
union __anonunion_7964 {
   u64 timestamp ;
   struct pps_event_time pps_times ;
};

#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ptp_clock_kernel.h"
struct ptp_clock_event {
   int type ;
   int index ;
   union __anonunion_7964 __anonCompField_ptp_clock_event_110 ;
};

#line 797  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
enum ptp_packet_state {
    PTP_PACKET_STATE_UNMATCHED = 0,
    PTP_PACKET_STATE_MATCHED = 1,
    PTP_PACKET_STATE_TIMED_OUT = 2,
    PTP_PACKET_STATE_MATCH_UNWANTED = 3
};

#line 804  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
struct efx_ptp_match {
   u32 words[2U] ;
   unsigned long expiry ;
   enum ptp_packet_state state ;
};

#line 180  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
struct efx_ptp_event_rx {
   struct list_head link ;
   u32 seq0 ;
   u32 seq1 ;
   ktime_t hwtimestamp ;
   unsigned long expiry ;
};

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
struct efx_ptp_timeset {
   u32 host_start ;
   u32 major ;
   u32 minor ;
   u32 host_end ;
   u32 wait ;
   u32 window ;
};

#line 214  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
struct __anonstruct_ts_corrections_7988 {
   s32 tx ;
   s32 rx ;
   s32 pps_out ;
   s32 pps_in ;
};

#line 214  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
struct efx_ptp_data {
   struct efx_nic *efx ;
   struct efx_channel *channel ;
   bool rx_ts_inline ;
   struct sk_buff_head rxq ;
   struct sk_buff_head txq ;
   struct list_head evt_list ;
   struct list_head evt_free_list ;
   spinlock_t evt_lock ;
   struct efx_ptp_event_rx rx_evts[8U] ;
   struct workqueue_struct *workwq ;
   struct work_struct work ;
   bool reset_required ;
   u32 rxfilter_event ;
   u32 rxfilter_general ;
   bool rxfilter_installed ;
   struct hwtstamp_config config ;
   bool enabled ;
   unsigned int mode ;
   unsigned int time_format ;
   void (*ns_to_nic_time)(s64 , u32 *, u32 *) ;
   ktime_t (*nic_to_kernel_time)(u32 , u32 , s32 ) ;
   unsigned int min_synchronisation_ns ;
   struct __anonstruct_ts_corrections_7988 ts_corrections ;
   efx_qword_t evt_frags[3U] ;
   int evt_frag_idx ;
   int evt_code ;
   struct efx_buffer start ;
   struct pps_event_time host_time_pps ;
   s64 current_adjfreq ;
   struct ptp_clock *phc_clock ;
   struct ptp_clock_info phc_clock_info ;
   struct work_struct pps_work ;
   struct workqueue_struct *pps_workwq ;
   bool nic_ts_enabled ;
   efx_dword_t txbuf[63U] ;
   unsigned int good_syncs ;
   unsigned int fast_syncs ;
   unsigned int bad_syncs ;
   unsigned int sync_timeouts ;
   unsigned int no_time_syncs ;
   unsigned int invalid_sync_windows ;
   unsigned int undersize_sync_windows ;
   unsigned int oversize_sync_windows ;
   unsigned int rx_no_timestamp ;
   struct efx_ptp_timeset timeset[12U] ;
};

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/phy.h"
struct tenxpress_phy_data {
   enum efx_loopback_mode loopback_mode ;
   enum efx_phy_mode phy_mode ;
   int bad_lp_tries ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
enum ldv_11842 {
    WORK_STRUCT_PENDING_BIT_1 = 0,
    WORK_STRUCT_DELAYED_BIT_1 = 1,
    WORK_STRUCT_PWQ_BIT_1 = 2,
    WORK_STRUCT_LINKED_BIT_1 = 3,
    WORK_STRUCT_STATIC_BIT_1 = 4,
    WORK_STRUCT_COLOR_SHIFT_1 = 5,
    WORK_STRUCT_COLOR_BITS_1 = 4,
    WORK_STRUCT_PENDING_1 = 1,
    WORK_STRUCT_DELAYED_1 = 2,
    WORK_STRUCT_PWQ_1 = 4,
    WORK_STRUCT_LINKED_1 = 8,
    WORK_STRUCT_STATIC_1 = 16,
    WORK_NR_COLORS_1 = 15,
    WORK_NO_COLOR_1 = 15,
    WORK_CPU_UNBOUND_1 = 8192,
    WORK_STRUCT_FLAG_BITS_1 = 9,
    WORK_OFFQ_FLAG_BASE_1 = 5,
    __WORK_OFFQ_CANCELING_1 = 5,
    WORK_OFFQ_CANCELING_1 = 32,
    WORK_OFFQ_FLAG_BITS_1 = 1,
    WORK_OFFQ_POOL_SHIFT_1 = 6,
    WORK_OFFQ_LEFT_1 = 58,
    WORK_OFFQ_POOL_BITS_1 = 31,
    WORK_OFFQ_POOL_NONE_1 = 2147483647,
    WORK_STRUCT_FLAG_MASK_1 = 511,
    WORK_STRUCT_WQ_DATA_MASK_1 = -512,
    WORK_STRUCT_NO_POOL_1 = 137438953408,
    WORK_BUSY_PENDING_1 = 1,
    WORK_BUSY_RUNNING_1 = 2,
    WORKER_DESC_LEN_1 = 24
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dmapool.h"
struct msix_entry {
   u32 vector ;
   u16 entry ;
};

#line 1084  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
struct mii_ioctl_data {
   __u16 phy_id ;
   __u16 reg_num ;
   __u16 val_in ;
   __u16 val_out ;
};

#line 2086  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_notifier_info {
   struct net_device *dev ;
};

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.h"
struct efx_mcdi_phy_data {
   u32 flags ;
   u32 type ;
   u32 supported_cap ;
   u32 channel ;
   u32 port ;
   u32 stats_mask ;
   u8 name[20U] ;
   u32 media ;
   u32 mmd_mask ;
   u8 revision[20U] ;
   u32 forced_cap ;
};

#line 917  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
enum efx_stats_action {
    EFX_STATS_ENABLE = 0,
    EFX_STATS_DISABLE = 1,
    EFX_STATS_PULL = 2
};

#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
struct ldv_list_element {
   void *data ;
   struct ldv_list_element *next ;
};

#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
typedef struct ldv_list_element *ldv_list_ptr;

#line 41  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
struct device_private {
   void *driver_data ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef short s16;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_work;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_worker {
   spinlock_t lock ;
   struct list_head work_list ;
   struct task_struct *task ;
   struct kthread_work *current_work ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_work {
   struct list_head node ;
   void (*func)(struct kthread_work *) ;
   struct kthread_worker *worker ;
};

#line 380  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct dma_chan;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_master;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_device {
   struct device dev ;
   struct spi_master *master ;
   u32 max_speed_hz ;
   u8 chip_select ;
   u8 bits_per_word ;
   u16 mode ;
   int irq ;
   void *controller_state ;
   void *controller_data ;
   char modalias[32U] ;
   int cs_gpio ;
};

#line 151 
struct spi_message;

#line 152 
struct spi_transfer;

#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_master {
   struct device dev ;
   struct list_head list ;
   s16 bus_num ;
   u16 num_chipselect ;
   u16 dma_alignment ;
   u16 mode_bits ;
   u32 bits_per_word_mask ;
   u32 min_speed_hz ;
   u32 max_speed_hz ;
   u16 flags ;
   spinlock_t bus_lock_spinlock ;
   struct mutex bus_lock_mutex ;
   bool bus_lock_flag ;
   int (*setup)(struct spi_device *) ;
   int (*transfer)(struct spi_device *, struct spi_message *) ;
   void (*cleanup)(struct spi_device *) ;
   bool (*can_dma)(struct spi_master *, struct spi_device *, struct spi_transfer *) ;
   bool queued ;
   struct kthread_worker kworker ;
   struct task_struct *kworker_task ;
   struct kthread_work pump_messages ;
   spinlock_t queue_lock ;
   struct list_head queue ;
   struct spi_message *cur_msg ;
   bool idling ;
   bool busy ;
   bool running ;
   bool rt ;
   bool auto_runtime_pm ;
   bool cur_msg_prepared ;
   bool cur_msg_mapped ;
   struct completion xfer_completion ;
   size_t max_dma_len ;
   int (*prepare_transfer_hardware)(struct spi_master *) ;
   int (*transfer_one_message)(struct spi_master *, struct spi_message *) ;
   int (*unprepare_transfer_hardware)(struct spi_master *) ;
   int (*prepare_message)(struct spi_master *, struct spi_message *) ;
   int (*unprepare_message)(struct spi_master *, struct spi_message *) ;
   void (*set_cs)(struct spi_device *, bool ) ;
   int (*transfer_one)(struct spi_master *, struct spi_device *, struct spi_transfer *) ;
   void (*handle_err)(struct spi_master *, struct spi_message *) ;
   int *cs_gpios ;
   struct dma_chan *dma_tx ;
   struct dma_chan *dma_rx ;
   void *dummy_rx ;
   void *dummy_tx ;
};

#line 506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_transfer {
   void const *tx_buf ;
   void *rx_buf ;
   unsigned int len ;
   dma_addr_t tx_dma ;
   dma_addr_t rx_dma ;
   struct sg_table tx_sg ;
   struct sg_table rx_sg ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cs_change : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) tx_nbits : 3 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) rx_nbits : 3 ;
   u8 bits_per_word ;
   u16 delay_usecs ;
   u32 speed_hz ;
   struct list_head transfer_list ;
};

#line 630  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_message {
   struct list_head transfers ;
   struct spi_device *spi ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_dma_mapped : 1 ;
   void (*complete)(void *) ;
   void *context ;
   unsigned int frame_length ;
   unsigned int actual_length ;
   int status ;
   struct list_head queue ;
   void *state ;
};

#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
typedef unsigned long pthread_t;

#line 22  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
union pthread_attr_t {
   char __size[56U] ;
   long __align ;
};

#line 29  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
typedef union pthread_attr_t pthread_attr_t;

#line 3835  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct ldv_struct_devattr_instance_16 {
   struct device_attribute *arg1 ;
   struct device *arg0 ;
   int signal_pending ;
};

#line 22  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_free_irq_8 {
   int arg0 ;
   int signal_pending ;
};

#line 27  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_interrupt_scenario_24 {
   enum irqreturn (*arg2)(int , void *) ;
   enum irqreturn (*arg1)(int , void *) ;
   void *arg3 ;
   int arg0 ;
   int signal_pending ;
};

#line 35  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_pci_scenario_18 {
   struct pci_driver *arg0 ;
   int signal_pending ;
};

#line 40  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_timer_scenario_22 {
   struct timer_list *arg0 ;
   int signal_pending ;
};
unsigned short __builtin_bswap16(unsigned short);

unsigned int __builtin_bswap32(unsigned int);

void __builtin_unreachable(void);


#line 7  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/fvtp/.tmp_farch.c"
void ldv_inline_asm(void);


#line 7  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
void ldv_atomic_inc(atomic_t *v);


#line 8 
void ldv_atomic_dec(atomic_t *v);


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr, unsigned long volatile *addr)
{
  
#line 74 
  if (0 != 0) 
#line 76 
              ldv_inline_asm(); else 
#line 79 
                                     ldv_inline_asm();
  
#line 80 
  return;
}


#line 94  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static void __set_bit(long nr, unsigned long volatile *addr)
{
  
#line 96 
  ldv_inline_asm();
  
#line 97 
  return;
}


#line 204  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr, unsigned long volatile *addr)
{
  int __retres;
  
#line 206 
  ldv_inline_asm();
  
#line 207 
  ldv_inline_asm();
  
#line 206 
  __retres = 0;
  
#line 206 
  goto return_label;
  cc_label: 
#line 206 
  ;
  
#line 206 
  __retres = 1;
  return_label: 
#line 206 
                return __retres;
}


#line 308  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr, unsigned long const volatile *addr)
{
  int __retres;
  
#line 311 
  __retres = ((*(addr + (nr >> 6)) >> (nr & 63L)) & 1UL) != 0UL;
  
#line 311 
  return __retres;
}


#line 314  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(long nr, unsigned long const volatile *addr)
{
  int oldbit;
  
#line 317 
  ldv_inline_asm();
  
#line 323 
  return oldbit;
}


#line 346  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static unsigned long __ffs(unsigned long word)
{
  
#line 348 
  ldv_inline_asm();
  
#line 351 
  return word;
}


#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/swab.h"
__inline static __u16 __fswab16(__u16 val)
{
  __u16 tmp;
  
#line 49 
  tmp = __builtin_bswap16((unsigned short)((int)val));
  
#line 49 
  return tmp;
}


#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/swab.h"
__inline static __u32 __fswab32(__u32 val)
{
  __u32 tmp;
  
#line 60 
  tmp = __builtin_bswap32(val);
  
#line 60 
  return tmp;
}


#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/bitops/le.h"
__inline static void __set_bit_le(int nr, void *addr)
{
  
#line 69 
  __set_bit((long)nr,(unsigned long volatile *)addr);
  
#line 70 
  return;
}


#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_debug.h"
void __dynamic_netdev_dbg(struct _ddebug *, struct net_device const *, char const * , ...);


#line 178  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
void __might_sleep(char const *, int, int);


#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list)
{
  
#line 27 
  list->next = list;
  
#line 28 
  list->prev = list;
  
#line 29 
  return;
}


#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/percpu.h"
void __bad_percpu_size(void);


#line 295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-defs.h"
void __bad_size_call_parameter(void);


#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/bug.h"
void warn_slowpath_null(char const *, int const);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/page_64.h"
unsigned long __phys_addr(unsigned long);


#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
void *memset(void *, int, size_t);


#line 63 
int memcmp(void const *, void const *, size_t);


#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/cmpxchg.h"
void __cmpxchg_wrong_size(void);


#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const *v)
{
  int __retres;
  int const volatile *tmp;
  {
    
#line 27 
    int const __var = 0;
    
#line 27 
    tmp = (int const volatile *)(& v->counter);
  }
  
#line 27 
  __retres = *tmp;
  
#line 27 
  return __retres;
}


#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v, int i)
{
  
#line 39 
  v->counter = i;
  
#line 40 
  return;
}


#line 98 
static void atomic_inc(atomic_t *v);


#line 114 
static void atomic_dec(atomic_t *v);


#line 179  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/atomic.h"
__inline static int atomic_cmpxchg(atomic_t *v, int old, int new)
{
  int tmp;
  {
    int __ret;
    
#line 181 
    int __old = old;
    
#line 181 
    int __new = new;
    
#line 181 
    switch (4UL) {
      case (unsigned long)1: 
#line 181 
      ;
      {
        
#line 181 
        u8 volatile *__ptr = (u8 volatile *)(& v->counter);
        
#line 182 
        ldv_inline_asm();
        
#line 181 
        goto ldv_5991;
      }
      case (unsigned long)2: 
#line 181 
      ;
      {
        
#line 181 
        u16 volatile *__ptr_0 = (u16 volatile *)(& v->counter);
        
#line 182 
        ldv_inline_asm();
        
#line 181 
        goto ldv_5991;
      }
      case (unsigned long)4: 
#line 181 
      ;
      {
        
#line 181 
        u32 volatile *__ptr_1 = (u32 volatile *)(& v->counter);
        
#line 182 
        ldv_inline_asm();
        
#line 181 
        goto ldv_5991;
      }
      case (unsigned long)8: 
#line 181 
      ;
      {
        
#line 181 
        u64 volatile *__ptr_2 = (u64 volatile *)(& v->counter);
        
#line 182 
        ldv_inline_asm();
        
#line 181 
        goto ldv_5991;
      }
      default: 
#line 181 
      ;
      
#line 181 
      __cmpxchg_wrong_size();
    }
    ldv_5991: 
#line 181 
    ;
    
#line 181 
    tmp = __ret;
  }
  
#line 181 
  return tmp;
}


#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_api_smp.h"
void _raw_spin_lock(raw_spinlock_t *);


#line 30 
void _raw_spin_lock_bh(raw_spinlock_t *);


#line 41 
void _raw_spin_unlock(raw_spinlock_t *);


#line 42 
void _raw_spin_unlock_bh(raw_spinlock_t *);


#line 45 
void _raw_spin_unlock_irqrestore(raw_spinlock_t *, unsigned long);


#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock(spinlock_t *lock)
{
  
#line 312 
  _raw_spin_lock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 313 
  return;
}


#line 346 
static void ldv_spin_lock_62(spinlock_t *lock);


#line 350 
static void ldv_spin_lock_67(spinlock_t *lock);


#line 355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_bh(spinlock_t *lock)
{
  
#line 357 
  _raw_spin_lock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 358 
  return;
}


#line 379 
static void ldv_spin_lock_bh_71(spinlock_t *lock);


#line 407 
static void ldv_spin_lock_bh_97(spinlock_t *lock);


#line 411 
static void ldv_spin_lock_bh_98(spinlock_t *lock);


#line 415 
static void ldv_spin_lock_bh_100(spinlock_t *lock);


#line 419 
static void ldv_spin_lock_bh_102(spinlock_t *lock);


#line 423 
static void ldv_spin_lock_bh_104(spinlock_t *lock);


#line 427 
static void ldv_spin_lock_bh_106(spinlock_t *lock);


#line 431 
static void ldv_spin_lock_bh_108(spinlock_t *lock);


#line 435 
static void ldv_spin_lock_bh_110(spinlock_t *lock);


#line 439 
static void ldv_spin_lock_bh_112(spinlock_t *lock);


#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock(spinlock_t *lock)
{
  
#line 365 
  _raw_spin_unlock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 366 
  return;
}


#line 395 
static void ldv_spin_unlock_65(spinlock_t *lock);


#line 399 
static void ldv_spin_unlock_68(spinlock_t *lock);


#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_bh(spinlock_t *lock)
{
  
#line 406 
  _raw_spin_unlock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 407 
  return;
}


#line 428 
static void ldv_spin_unlock_bh_73(spinlock_t *lock);


#line 460 
static void ldv_spin_unlock_bh_99(spinlock_t *lock);


#line 464 
static void ldv_spin_unlock_bh_101(spinlock_t *lock);


#line 468 
static void ldv_spin_unlock_bh_103(spinlock_t *lock);


#line 472 
static void ldv_spin_unlock_bh_105(spinlock_t *lock);


#line 476 
static void ldv_spin_unlock_bh_107(spinlock_t *lock);


#line 480 
static void ldv_spin_unlock_bh_109(spinlock_t *lock);


#line 484 
static void ldv_spin_unlock_bh_111(spinlock_t *lock);


#line 488 
static void ldv_spin_unlock_bh_113(spinlock_t *lock);


#line 502  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
{
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
  }
  
#line 504 
  _raw_spin_unlock_irqrestore(& lock->__anonCompField_spinlock_18.rlock,flags);
  
#line 505 
  return;
}


#line 534 
static void ldv_spin_unlock_irqrestore_88(spinlock_t *lock, unsigned long flags);


#line 538 
static void ldv_spin_unlock_irqrestore_90(spinlock_t *lock, unsigned long flags);


#line 542 
static void ldv_spin_unlock_irqrestore_92(spinlock_t *lock, unsigned long flags);


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
void __ldv_spin_lock(spinlock_t *);


#line 70 
static void ldv___ldv_spin_lock_87(spinlock_t *ldv_func_arg1);


#line 74 
static void ldv___ldv_spin_lock_89(spinlock_t *ldv_func_arg1);


#line 78 
static void ldv___ldv_spin_lock_91(spinlock_t *ldv_func_arg1);


#line 94 
void ldv_spin_model_lock(char *);


#line 95 
void ldv_spin_model_unlock(char *);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kzalloc(size_t size, gfp_t flags);


#line 25 
void *ldv_kcalloc(size_t n, size_t size, gfp_t flags);


#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
extern unsigned long volatile jiffies;


#line 292 
unsigned long __msecs_to_jiffies(unsigned int const);


#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
__inline static unsigned long _msecs_to_jiffies(unsigned int const m)
{
  unsigned long __retres;
  
#line 301 
  __retres = (unsigned long)(((long)m + 3L) / 4L);
  
#line 301 
  return __retres;
}


#line 354  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
__inline static unsigned long msecs_to_jiffies(unsigned int const m)
{
  unsigned long __retres;
  
#line 356 
  if (0 != 0) {
    unsigned long tmp;
    
#line 357 
    if ((int)m < 0) {
      
#line 358 
      __retres = 4611686018427387902UL;
      
#line 358 
      goto return_label;
    }
    else ;
    
#line 359 
    tmp = _msecs_to_jiffies(m);
    
#line 359 
    __retres = tmp;
    
#line 359 
    goto return_label;
  }
  else {
    unsigned long tmp_0;
    
#line 361 
    tmp_0 = __msecs_to_jiffies(m);
    
#line 361 
    __retres = tmp_0;
    
#line 361 
    goto return_label;
  }
  return_label: 
#line 356 
                return __retres;
}


#line 149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
void __wake_up(wait_queue_head_t *, unsigned int, int, void *);


#line 926 
long prepare_to_wait_event(wait_queue_head_t *, wait_queue_t *, int);


#line 927 
void finish_wait(wait_queue_head_t *, wait_queue_t *);


#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static unsigned int __readl(void const volatile *addr)
{
  unsigned int ret;
  
#line 63 
  ldv_inline_asm();
  
#line 62 
  return ret;
}


#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static void __writel(unsigned int val, void volatile *addr)
{
  
#line 72 
  ldv_inline_asm();
  
#line 73 
  return;
}


#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static void writeq(unsigned long val, void volatile *addr)
{
  
#line 93 
  ldv_inline_asm();
  
#line 94 
  return;
}


#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static phys_addr_t virt_to_phys(void volatile *address)
{
  phys_addr_t tmp;
  
#line 120 
  tmp = (phys_addr_t)__phys_addr((unsigned long)address);
  
#line 120 
  return tmp;
}


#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
void disable_irq_nosync(unsigned int);


#line 402  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist.h"
void __compiletime_assert_402(void);


#line 421  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
long schedule_timeout(long);


#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
void kfree(void const *);


#line 542 
static void *kcalloc(size_t n, size_t size, gfp_t flags);


#line 581 
static void *kzalloc(size_t size, gfp_t flags);


#line 972  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
void pci_clear_master(struct pci_dev *);


#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/crc32.h"
u32 crc32_le(u32, unsigned char const *, size_t);


#line 391  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
void __napi_schedule(struct napi_struct *);


#line 394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool napi_disable_pending(struct napi_struct *n)
{
  bool __retres;
  int tmp;
  
#line 396 
  tmp = constant_test_bit(1L,(unsigned long const volatile *)(& n->state));
  
#line 396 
  __retres = (_Bool)(tmp != 0);
  
#line 396 
  return __retres;
}


#line 408  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool napi_schedule_prep(struct napi_struct *n)
{
  bool __retres;
  int tmp_2;
  int tmp_0;
  bool tmp;
  
#line 410 
  tmp = napi_disable_pending(n);
  
#line 410 
  if (tmp) 
#line 410 
           tmp_0 = 0; else 
#line 410 
                           tmp_0 = 1;
  
#line 410 
  if (tmp_0) {
    int tmp_1;
    
#line 410 
    tmp_1 = test_and_set_bit(0L,(unsigned long volatile *)(& n->state));
    
#line 410 
    if (tmp_1 == 0) 
#line 410 
                    tmp_2 = 1; else 
#line 410 
                                    tmp_2 = 0;
  }
  else 
#line 410 
       tmp_2 = 0;
  
#line 410 
  __retres = (_Bool)(tmp_2 != 0);
  
#line 410 
  return __retres;
}


#line 421  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void napi_schedule(struct napi_struct *n)
{
  bool tmp;
  
#line 423 
  tmp = napi_schedule_prep(n);
  
#line 423 
  if ((int)tmp != 0) 
#line 424 
                     __napi_schedule(n); else ;
  
#line 425 
  return;
}


#line 682 
bool rps_may_expire_flow(struct net_device *, u16, u32, u16);


#line 1822  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static struct netdev_queue *netdev_get_tx_queue(struct net_device const *dev, unsigned int index)
{
  struct netdev_queue *__retres;
  
#line 1825 
  __retres = dev->_tx + index;
  
#line 1825 
  return __retres;
}


#line 2505 
void netif_schedule_queue(struct netdev_queue *);


#line 3170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void __netif_tx_lock(struct netdev_queue *txq, int cpu)
{
  
#line 3172 
  ldv_spin_lock_62(& txq->_xmit_lock);
  
#line 3173 
  txq->xmit_lock_owner = cpu;
  
#line 3174 
  return;
}


#line 3190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void __netif_tx_unlock(struct netdev_queue *txq)
{
  
#line 3192 
  txq->xmit_lock_owner = -1;
  
#line 3193 
  ldv_spin_unlock_65(& txq->_xmit_lock);
  
#line 3194 
  return;
}


#line 3214  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_lock(struct net_device *dev)
{
  unsigned int i;
  int cpu;
  int tmp_3;
  
#line 3219 
  ldv_spin_lock_67(& dev->tx_global_lock);
  {
    int pscr_ret__;
    {
      
#line 3220 
      void const *__vpp_verify = (void const *)0;
      
#line 3220 
      void const *tmp = __vpp_verify;
    }
    
#line 3220 
    switch (4UL) {
      int tmp_0;
      int tmp_0_0;
      int tmp_1;
      int tmp_2;
      case (unsigned long)1: 
#line 3220 
      ;
      {
        int pfo_ret__;
        
#line 3220 
        switch (4UL) {
          case (unsigned long)1: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45472;
          case (unsigned long)2: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45472;
          case (unsigned long)4: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45472;
          case (unsigned long)8: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45472;
          default: 
#line 3220 
          ;
          
#line 3220 
          __bad_percpu_size();
        }
        ldv_45472: 
#line 3220 
        ;
        
#line 3220 
        tmp_0 = pfo_ret__;
      }
      
#line 3220 
      pscr_ret__ = tmp_0;
      
#line 3220 
      goto ldv_45478;
      case (unsigned long)2: 
#line 3220 
      ;
      {
        int pfo_ret___0;
        
#line 3220 
        switch (4UL) {
          case (unsigned long)1: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45482;
          case (unsigned long)2: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45482;
          case (unsigned long)4: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45482;
          case (unsigned long)8: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45482;
          default: 
#line 3220 
          ;
          
#line 3220 
          __bad_percpu_size();
        }
        ldv_45482: 
#line 3220 
        ;
        
#line 3220 
        tmp_0_0 = pfo_ret___0;
      }
      
#line 3220 
      pscr_ret__ = tmp_0_0;
      
#line 3220 
      goto ldv_45478;
      case (unsigned long)4: 
#line 3220 
      ;
      {
        int pfo_ret___1;
        
#line 3220 
        switch (4UL) {
          case (unsigned long)1: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45491;
          case (unsigned long)2: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45491;
          case (unsigned long)4: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45491;
          case (unsigned long)8: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45491;
          default: 
#line 3220 
          ;
          
#line 3220 
          __bad_percpu_size();
        }
        ldv_45491: 
#line 3220 
        ;
        
#line 3220 
        tmp_1 = pfo_ret___1;
      }
      
#line 3220 
      pscr_ret__ = tmp_1;
      
#line 3220 
      goto ldv_45478;
      case (unsigned long)8: 
#line 3220 
      ;
      {
        int pfo_ret___2;
        
#line 3220 
        switch (4UL) {
          case (unsigned long)1: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45500;
          case (unsigned long)2: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45500;
          case (unsigned long)4: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45500;
          case (unsigned long)8: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45500;
          default: 
#line 3220 
          ;
          
#line 3220 
          __bad_percpu_size();
        }
        ldv_45500: 
#line 3220 
        ;
        
#line 3220 
        tmp_2 = pfo_ret___2;
      }
      
#line 3220 
      pscr_ret__ = tmp_2;
      
#line 3220 
      goto ldv_45478;
      default: 
#line 3220 
      ;
      
#line 3220 
      __bad_size_call_parameter();
      
#line 3220 
      goto ldv_45478;
    }
    ldv_45478: 
#line 3220 
    ;
    
#line 3220 
    tmp_3 = pscr_ret__;
  }
  
#line 3220 
  cpu = tmp_3;
  
#line 3221 
  i = 0U;
  
#line 3221 
  goto ldv_45510;
  ldv_45509: 
#line 3222 
  ;
  {
    
#line 3222 
    struct netdev_queue *txq = netdev_get_tx_queue((struct net_device const *)dev,i);
    
#line 3230 
    __netif_tx_lock(txq,cpu);
    
#line 3231 
    set_bit(2L,(unsigned long volatile *)(& txq->state));
    
#line 3232 
    __netif_tx_unlock(txq);
  }
  
#line 3221 
  i += 1U;
  ldv_45510: 
#line 3222 
  ;
  
#line 3221 
  if (dev->num_tx_queues > i) 
#line 3223 
                              goto ldv_45509; else 
#line 3226 
                                                   goto ldv_45511;
  ldv_45511: 
#line 3227 
  ;
  
#line 3228 
  return;
}


#line 3242  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_unlock(struct net_device *dev)
{
  unsigned int i;
  
#line 3246 
  i = 0U;
  
#line 3246 
  goto ldv_45521;
  ldv_45520: 
#line 3247 
  ;
  {
    
#line 3247 
    struct netdev_queue *txq = netdev_get_tx_queue((struct net_device const *)dev,i);
    
#line 3253 
    set_bit(2L,(unsigned long volatile *)(& txq->state));
    
#line 3254 
    netif_schedule_queue(txq);
  }
  
#line 3246 
  i += 1U;
  ldv_45521: 
#line 3247 
  ;
  
#line 3246 
  if (dev->num_tx_queues > i) 
#line 3248 
                              goto ldv_45520; else 
#line 3251 
                                                   goto ldv_45522;
  ldv_45522: 
#line 3252 
  ;
  
#line 3256 
  ldv_spin_unlock_68(& dev->tx_global_lock);
  
#line 3257 
  return;
}


#line 3314  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_addr_lock_bh(struct net_device *dev)
{
  
#line 3316 
  ldv_spin_lock_bh_71(& dev->addr_list_lock);
  
#line 3317 
  return;
}


#line 3324  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_addr_unlock_bh(struct net_device *dev)
{
  
#line 3326 
  ldv_spin_unlock_bh_73(& dev->addr_list_lock);
  
#line 3327 
  return;
}


#line 3819 
void netdev_printk(char const *, struct net_device const *, char const * , ...);


#line 3828 
void netdev_err(struct net_device const *, char const * , ...);


#line 3834 
void netdev_info(struct net_device const *, char const * , ...);


#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool is_multicast_ether_addr(u8 const *addr)
{
  bool __retres;
  
#line 114 
  u32 a = *((u32 const *)addr);
  
#line 121 
  __retres = (_Bool)((a & 1U) != 0U);
  
#line 121 
  return __retres;
}


#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/vmalloc.h"
void *vzalloc(unsigned long);


#line 83 
void vfree(void const *);


#line 1664  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
void __compiletime_assert_1664(void);


#line 1077  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
__inline static int efx_dev_registered(struct efx_nic *efx)
{
  int __retres;
  
#line 1079 
  __retres = (unsigned int)(efx->net_dev)->reg_state == 1U;
  
#line 1079 
  return __retres;
}


#line 1391  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
__inline static struct efx_channel *efx_get_channel(struct efx_nic *efx, unsigned int index)
{
  struct efx_channel *__retres;
  
#line 1394 
  __retres = efx->channel[index];
  
#line 1394 
  return __retres;
}


#line 1412  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
__inline static struct efx_tx_queue *efx_get_tx_queue(struct efx_nic *efx, unsigned int index, unsigned int type)
{
  struct efx_tx_queue *__retres;
  
#line 1416 
  __retres = & (efx->channel[efx->tx_channel_offset + index])->tx_queue[type];
  
#line 1416 
  return __retres;
}


#line 1419  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
__inline static bool efx_channel_has_tx_queues(struct efx_channel *channel)
{
  bool __retres;
  
#line 1421 
  __retres = (_Bool)((unsigned int)channel->channel - (channel->efx)->tx_channel_offset < (channel->efx)->n_tx_channels);
  
#line 1421 
  return __retres;
}


#line 1426  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
__inline static struct efx_tx_queue *efx_channel_get_tx_queue(struct efx_channel *channel, unsigned int type)
{
  struct efx_tx_queue *__retres;
  
#line 1430 
  __retres = & channel->tx_queue[type];
  
#line 1430 
  return __retres;
}


#line 1433  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
__inline static bool efx_tx_queue_used(struct efx_tx_queue *tx_queue)
{
  bool __retres;
  
#line 1435 
  __retres = (_Bool)(((unsigned int)((tx_queue->efx)->net_dev)->num_tc > 1U || (tx_queue->queue & 2U) == 0U) != 0);
  
#line 1435 
  return __retres;
}


#line 1458  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
__inline static bool efx_channel_has_rx_queue(struct efx_channel *channel)
{
  bool __retres;
  
#line 1460 
  __retres = (_Bool)(channel->rx_queue.core_index >= 0);
  
#line 1460 
  return __retres;
}


#line 1464  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
__inline static struct efx_rx_queue *efx_channel_get_rx_queue(struct efx_channel *channel)
{
  struct efx_rx_queue *__retres;
  
#line 1467 
  __retres = & channel->rx_queue;
  
#line 1467 
  return __retres;
}


#line 1480  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
__inline static struct efx_channel *efx_rx_queue_channel(struct efx_rx_queue *rx_queue)
{
  struct efx_channel *tmp;
  {
    
#line 1482 
    struct efx_rx_queue const *__mptr = (struct efx_rx_queue const *)rx_queue;
    
#line 1482 
    tmp = (struct efx_channel *)__mptr + 18446744073709551104U;
  }
  
#line 1482 
  return tmp;
}


#line 1485  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
__inline static int efx_rx_queue_index(struct efx_rx_queue *rx_queue)
{
  int __retres;
  struct efx_channel *tmp;
  
#line 1487 
  tmp = efx_rx_queue_channel(rx_queue);
  
#line 1487 
  __retres = tmp->channel;
  
#line 1487 
  return __retres;
}


#line 1493  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
__inline static struct efx_rx_buffer *efx_rx_buffer(struct efx_rx_queue *rx_queue, unsigned int index)
{
  struct efx_rx_buffer *__retres;
  
#line 1496 
  __retres = rx_queue->buffer + index;
  
#line 1496 
  return __retres;
}


#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
void efx_xmit_done(struct efx_tx_queue *tx_queue, unsigned int index);


#line 46 
void efx_fast_push_rx_descriptors(struct efx_rx_queue *rx_queue, bool atomic);


#line 49 
void efx_rx_packet(struct efx_rx_queue *rx_queue, unsigned int index, unsigned int n_frags, unsigned int len, u16 flags);


#line 196 
int efx_try_recovery(struct efx_nic *efx);


#line 199 
void efx_schedule_reset(struct efx_nic *efx, enum reset_type type);


#line 232  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
__inline static unsigned int efx_vf_size(struct efx_nic *efx)
{
  unsigned int __retres;
  
#line 234 
  __retres = (unsigned int)(1 << efx->vi_scale);
  
#line 234 
  return __retres;
}


#line 238  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
__inline static void efx_schedule_channel(struct efx_channel *channel)
{
  
#line 240 
  if (0) {
    
#line 240 
    if (((channel->efx)->msg_enable & 512U) != 0U) {
      int tmp_3;
      {
        int pscr_ret__;
        {
          
#line 240 
          void const *__vpp_verify = (void const *)0;
          
#line 240 
          void const *tmp = __vpp_verify;
        }
        
#line 240 
        switch (4UL) {
          int tmp_0;
          int tmp_0_0;
          int tmp_1;
          int tmp_2;
          case (unsigned long)1: 
#line 240 
          ;
          {
            int pfo_ret__;
            
#line 240 
            switch (4UL) {
              case (unsigned long)1: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55570;
              case (unsigned long)2: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55570;
              case (unsigned long)4: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55570;
              case (unsigned long)8: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55570;
              default: 
#line 240 
              ;
              
#line 240 
              __bad_percpu_size();
            }
            ldv_55570: 
#line 240 
            ;
            
#line 240 
            tmp_0 = pfo_ret__;
          }
          
#line 240 
          pscr_ret__ = tmp_0;
          
#line 240 
          goto ldv_55576;
          case (unsigned long)2: 
#line 240 
          ;
          {
            int pfo_ret___0;
            
#line 240 
            switch (4UL) {
              case (unsigned long)1: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55580;
              case (unsigned long)2: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55580;
              case (unsigned long)4: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55580;
              case (unsigned long)8: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55580;
              default: 
#line 240 
              ;
              
#line 240 
              __bad_percpu_size();
            }
            ldv_55580: 
#line 240 
            ;
            
#line 240 
            tmp_0_0 = pfo_ret___0;
          }
          
#line 240 
          pscr_ret__ = tmp_0_0;
          
#line 240 
          goto ldv_55576;
          case (unsigned long)4: 
#line 240 
          ;
          {
            int pfo_ret___1;
            
#line 240 
            switch (4UL) {
              case (unsigned long)1: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55589;
              case (unsigned long)2: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55589;
              case (unsigned long)4: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55589;
              case (unsigned long)8: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55589;
              default: 
#line 240 
              ;
              
#line 240 
              __bad_percpu_size();
            }
            ldv_55589: 
#line 240 
            ;
            
#line 240 
            tmp_1 = pfo_ret___1;
          }
          
#line 240 
          pscr_ret__ = tmp_1;
          
#line 240 
          goto ldv_55576;
          case (unsigned long)8: 
#line 240 
          ;
          {
            int pfo_ret___2;
            
#line 240 
            switch (4UL) {
              case (unsigned long)1: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55598;
              case (unsigned long)2: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55598;
              case (unsigned long)4: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55598;
              case (unsigned long)8: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55598;
              default: 
#line 240 
              ;
              
#line 240 
              __bad_percpu_size();
            }
            ldv_55598: 
#line 240 
            ;
            
#line 240 
            tmp_2 = pfo_ret___2;
          }
          
#line 240 
          pscr_ret__ = tmp_2;
          
#line 240 
          goto ldv_55576;
          default: 
#line 240 
          ;
          
#line 240 
          __bad_size_call_parameter();
          
#line 240 
          goto ldv_55576;
        }
        ldv_55576: 
#line 240 
        ;
        
#line 240 
        tmp_3 = pscr_ret__;
      }
      
#line 240 
      ;
      
#line 240 
      ;
      
#line 240 
      netdev_printk("\001",(struct net_device const *)(channel->efx)->net_dev,"channel %d scheduling NAPI poll on CPU%d\n",channel->channel,tmp_3);
    }
    else ;
  }
  else ;
  
#line 244 
  napi_schedule(& channel->napi_str);
  
#line 245 
  return;
}


#line 247  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
__inline static void efx_schedule_channel_irq(struct efx_channel *channel)
{
  int tmp_3;
  {
    int pscr_ret__;
    {
      
#line 249 
      void const *__vpp_verify = (void const *)0;
      
#line 249 
      void const *tmp = __vpp_verify;
    }
    
#line 249 
    switch (4UL) {
      int tmp_0;
      int tmp_0_0;
      int tmp_1;
      int tmp_2;
      case (unsigned long)1: 
#line 249 
      ;
      {
        int pfo_ret__;
        
#line 249 
        switch (4UL) {
          case (unsigned long)1: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55615;
          case (unsigned long)2: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55615;
          case (unsigned long)4: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55615;
          case (unsigned long)8: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55615;
          default: 
#line 249 
          ;
          
#line 249 
          __bad_percpu_size();
        }
        ldv_55615: 
#line 249 
        ;
        
#line 249 
        tmp_0 = pfo_ret__;
      }
      
#line 249 
      pscr_ret__ = tmp_0;
      
#line 249 
      goto ldv_55621;
      case (unsigned long)2: 
#line 249 
      ;
      {
        int pfo_ret___0;
        
#line 249 
        switch (4UL) {
          case (unsigned long)1: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55625;
          case (unsigned long)2: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55625;
          case (unsigned long)4: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55625;
          case (unsigned long)8: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55625;
          default: 
#line 249 
          ;
          
#line 249 
          __bad_percpu_size();
        }
        ldv_55625: 
#line 249 
        ;
        
#line 249 
        tmp_0_0 = pfo_ret___0;
      }
      
#line 249 
      pscr_ret__ = tmp_0_0;
      
#line 249 
      goto ldv_55621;
      case (unsigned long)4: 
#line 249 
      ;
      {
        int pfo_ret___1;
        
#line 249 
        switch (4UL) {
          case (unsigned long)1: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55634;
          case (unsigned long)2: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55634;
          case (unsigned long)4: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55634;
          case (unsigned long)8: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55634;
          default: 
#line 249 
          ;
          
#line 249 
          __bad_percpu_size();
        }
        ldv_55634: 
#line 249 
        ;
        
#line 249 
        tmp_1 = pfo_ret___1;
      }
      
#line 249 
      pscr_ret__ = tmp_1;
      
#line 249 
      goto ldv_55621;
      case (unsigned long)8: 
#line 249 
      ;
      {
        int pfo_ret___2;
        
#line 249 
        switch (4UL) {
          case (unsigned long)1: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55643;
          case (unsigned long)2: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55643;
          case (unsigned long)4: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55643;
          case (unsigned long)8: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55643;
          default: 
#line 249 
          ;
          
#line 249 
          __bad_percpu_size();
        }
        ldv_55643: 
#line 249 
        ;
        
#line 249 
        tmp_2 = pfo_ret___2;
      }
      
#line 249 
      pscr_ret__ = tmp_2;
      
#line 249 
      goto ldv_55621;
      default: 
#line 249 
      ;
      
#line 249 
      __bad_size_call_parameter();
      
#line 249 
      goto ldv_55621;
    }
    ldv_55621: 
#line 249 
    ;
    
#line 249 
    tmp_3 = pscr_ret__;
  }
  
#line 249 
  channel->event_test_cpu = tmp_3;
  
#line 250 
  efx_schedule_channel(channel);
  
#line 251 
  return;
}


#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.h"
void efx_mcdi_process_event(struct efx_channel *channel, efx_qword_t *event);


#line 334 
int efx_mcdi_flush_rxqs(struct efx_nic *efx);


#line 28  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
__inline static int efx_nic_rev(struct efx_nic *efx)
{
  int __retres;
  
#line 30 
  __retres = (efx->type)->revision;
  
#line 30 
  return __retres;
}


#line 33 
u32 efx_farch_fpga_ver(struct efx_nic *efx);


#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
__inline static bool efx_nic_is_dual_func(struct efx_nic *efx)
{
  bool __retres;
  int tmp;
  
#line 38 
  tmp = efx_nic_rev(efx);
  
#line 38 
  __retres = (_Bool)(tmp <= 1);
  
#line 38 
  return __retres;
}


#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
__inline static efx_qword_t *efx_event(struct efx_channel *channel, unsigned int index)
{
  efx_qword_t *__retres;
  
#line 45 
  __retres = (efx_qword_t *)channel->eventq.buf.addr + (channel->eventq_mask & index);
  
#line 45 
  return __retres;
}


#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
__inline static int efx_event_present(efx_qword_t *event)
{
  int __retres;
  
#line 61 
  __retres = (event->dword[0].u32[0] != 4294967295U && event->dword[1].u32[0] != 4294967295U) != 0;
  
#line 61 
  return __retres;
}


#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
__inline static efx_qword_t *efx_tx_desc(struct efx_tx_queue *tx_queue, unsigned int index)
{
  efx_qword_t *__retres;
  
#line 71 
  __retres = (efx_qword_t *)tx_queue->txd.buf.addr + index;
  
#line 71 
  return __retres;
}


#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
__inline static bool __efx_nic_tx_is_empty(struct efx_tx_queue *tx_queue, unsigned int write_count)
{
  bool __retres;
  unsigned int volatile *tmp;
  {
    
#line 89 
    unsigned int __var = 0U;
    
#line 89 
    tmp = (unsigned int volatile *)(& tx_queue->empty_read_count);
  }
  
#line 89 
  unsigned int empty_read_count = *tmp;
  
#line 91 
  if (empty_read_count == 0U) {
    
#line 92 
    __retres = (_Bool)0;
    
#line 92 
    goto return_label;
  }
  else ;
  
#line 94 
  __retres = (_Bool)(((empty_read_count ^ write_count) & 2147483647U) == 0U);
  return_label: 
#line 94 
                return __retres;
}


#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
__inline static bool efx_nic_may_push_tx_desc(struct efx_tx_queue *tx_queue, unsigned int write_count)
{
  bool __retres;
  
#line 122 
  bool was_empty = __efx_nic_tx_is_empty(tx_queue,write_count);
  
#line 124 
  tx_queue->empty_read_count = 0U;
  
#line 125 
  __retres = (_Bool)(((int)was_empty != 0 && tx_queue->write_count - write_count == 1U) != 0);
  
#line 125 
  return __retres;
}


#line 130  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
__inline static efx_qword_t *efx_rx_desc(struct efx_rx_queue *rx_queue, unsigned int index)
{
  efx_qword_t *__retres;
  
#line 132 
  __retres = (efx_qword_t *)rx_queue->rxd.buf.addr + index;
  
#line 132 
  return __retres;
}


#line 667 
int efx_farch_tx_probe(struct efx_tx_queue *tx_queue);


#line 668 
void efx_farch_tx_init(struct efx_tx_queue *tx_queue);


#line 669 
void efx_farch_tx_fini(struct efx_tx_queue *tx_queue);


#line 670 
void efx_farch_tx_remove(struct efx_tx_queue *tx_queue);


#line 671 
void efx_farch_tx_write(struct efx_tx_queue *tx_queue);


#line 672 
int efx_farch_rx_probe(struct efx_rx_queue *rx_queue);


#line 673 
void efx_farch_rx_init(struct efx_rx_queue *rx_queue);


#line 674 
void efx_farch_rx_fini(struct efx_rx_queue *rx_queue);


#line 675 
void efx_farch_rx_remove(struct efx_rx_queue *rx_queue);


#line 676 
void efx_farch_rx_write(struct efx_rx_queue *rx_queue);


#line 677 
void efx_farch_rx_defer_refill(struct efx_rx_queue *rx_queue);


#line 678 
int efx_farch_ev_probe(struct efx_channel *channel);


#line 679 
int efx_farch_ev_init(struct efx_channel *channel);


#line 680 
void efx_farch_ev_fini(struct efx_channel *channel);


#line 681 
void efx_farch_ev_remove(struct efx_channel *channel);


#line 682 
int efx_farch_ev_process(struct efx_channel *channel, int budget);


#line 683 
void efx_farch_ev_read_ack(struct efx_channel *channel);


#line 684 
void efx_farch_ev_test_generate(struct efx_channel *channel);


#line 687 
int efx_farch_filter_table_probe(struct efx_nic *efx);


#line 688 
void efx_farch_filter_table_restore(struct efx_nic *efx);


#line 689 
void efx_farch_filter_table_remove(struct efx_nic *efx);


#line 690 
void efx_farch_filter_update_rx_scatter(struct efx_nic *efx);


#line 691 
s32 efx_farch_filter_insert(struct efx_nic *efx, struct efx_filter_spec *gen_spec, bool replace_equal);


#line 693 
int efx_farch_filter_remove_safe(struct efx_nic *efx, enum efx_filter_priority priority, u32 filter_id);


#line 696 
int efx_farch_filter_get_safe(struct efx_nic *efx, enum efx_filter_priority priority, u32 filter_id, struct efx_filter_spec *spec_buf);


#line 699 
int efx_farch_filter_clear_rx(struct efx_nic *efx, enum efx_filter_priority priority);


#line 701 
u32 efx_farch_filter_count_rx_used(struct efx_nic *efx, enum efx_filter_priority priority);


#line 703 
u32 efx_farch_filter_get_rx_id_limit(struct efx_nic *efx);


#line 704 
s32 efx_farch_filter_get_rx_ids(struct efx_nic *efx, enum efx_filter_priority priority, u32 *buf, u32 size);


#line 708 
s32 efx_farch_filter_rfs_insert(struct efx_nic *efx, struct efx_filter_spec *gen_spec);


#line 710 
bool efx_farch_filter_rfs_expire_one(struct efx_nic *efx, u32 flow_id, unsigned int index);


#line 713 
void efx_farch_filter_sync_rx_mode(struct efx_nic *efx);


#line 741 
void efx_farch_irq_enable_master(struct efx_nic *efx);


#line 742 
void efx_farch_irq_test_generate(struct efx_nic *efx);


#line 743 
void efx_farch_irq_disable_master(struct efx_nic *efx);


#line 744 
irqreturn_t efx_farch_msi_interrupt(int irq, void *dev_id);


#line 745 
irqreturn_t efx_farch_legacy_interrupt(int irq, void *dev_id);


#line 746 
irqreturn_t efx_farch_fatal_interrupt(struct efx_nic *efx);


#line 760 
int efx_farch_fini_dmaq(struct efx_nic *efx);


#line 761 
void efx_farch_finish_flr(struct efx_nic *efx);


#line 766 
void efx_farch_dimension_resources(struct efx_nic *efx, unsigned int sram_lim_qw);


#line 767 
void efx_farch_init_common(struct efx_nic *efx);


#line 769 
void efx_farch_rx_push_indir_table(struct efx_nic *efx);


#line 771 
int efx_nic_alloc_buffer(struct efx_nic *efx, struct efx_buffer *buffer, unsigned int len, gfp_t gfp_flags);


#line 773 
void efx_nic_free_buffer(struct efx_nic *efx, struct efx_buffer *buffer);


#line 780 
int efx_farch_test_registers(struct efx_nic *efx, struct efx_farch_register_test const *regs, size_t n_regs);


#line 796 
void efx_farch_generate_event(struct efx_nic *efx, unsigned int evq, efx_qword_t *event);


#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.h"
__inline static bool efx_siena_sriov_enabled(struct efx_nic *efx)
{
  bool __retres;
  
#line 64 
  __retres = (_Bool)(efx->vf_init_count != 0U);
  
#line 64 
  return __retres;
}


#line 74 
void efx_siena_sriov_tx_flush_done(struct efx_nic *efx, efx_qword_t *event);


#line 75 
void efx_siena_sriov_rx_flush_done(struct efx_nic *efx, efx_qword_t *event);


#line 76 
void efx_siena_sriov_event(struct efx_channel *channel, efx_qword_t *event);


#line 77 
void efx_siena_sriov_desc_fetch_err(struct efx_nic *efx, unsigned int dmaq);


#line 82  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/io.h"
__inline static void _efx_writeq(struct efx_nic *efx, __le64 value, unsigned int reg)
{
  
#line 85 
  writeq((unsigned long)value,(void volatile *)(efx->membase + reg));
  
#line 86 
  return;
}


#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/io.h"
__inline static void _efx_writed(struct efx_nic *efx, __le32 value, unsigned int reg)
{
  
#line 96 
  __writel(value,(void volatile *)(efx->membase + reg));
  
#line 97 
  return;
}


#line 98  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/io.h"
__inline static __le32 _efx_readd(struct efx_nic *efx, unsigned int reg)
{
  __le32 tmp;
  
#line 100 
  tmp = __readl((void const volatile *)(efx->membase + reg));
  
#line 100 
  return tmp;
}


#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/io.h"
__inline static void efx_writeo(struct efx_nic *efx, efx_oword_t const *value, unsigned int reg)
{
  unsigned long flags;
  
#line 113 
  ldv___ldv_spin_lock_87(& efx->biu_lock);
  
#line 115 
  _efx_writeq(efx,value->u64[0],reg);
  
#line 116 
  _efx_writeq(efx,value->u64[1],reg + 8U);
  
#line 117 
  ldv_inline_asm();
  
#line 124 
  ldv_spin_unlock_irqrestore_88(& efx->biu_lock,flags);
  
#line 125 
  return;
}


#line 128  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/io.h"
__inline static void efx_sram_writeq(struct efx_nic *efx, void *membase, efx_qword_t const *value, unsigned int index)
{
  unsigned long flags;
  
#line 131 
  unsigned int addr = index * 8U;
  
#line 138 
  ldv___ldv_spin_lock_89(& efx->biu_lock);
  
#line 140 
  writeq((unsigned long)value->u64[0],(void volatile *)(membase + addr));
  
#line 141 
  ldv_inline_asm();
  
#line 146 
  ldv_spin_unlock_irqrestore_90(& efx->biu_lock,flags);
  
#line 147 
  return;
}


#line 150  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/io.h"
__inline static void efx_writed(struct efx_nic *efx, efx_dword_t const *value, unsigned int reg)
{
  
#line 158 
  _efx_writed(efx,value->u32[0],reg);
  
#line 159 
  return;
}


#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/io.h"
__inline static void efx_reado(struct efx_nic *efx, efx_oword_t *value, unsigned int reg)
{
  unsigned long flags;
  
#line 167 
  ldv___ldv_spin_lock_91(& efx->biu_lock);
  
#line 168 
  value->u32[0] = _efx_readd(efx,reg);
  
#line 169 
  value->u32[1] = _efx_readd(efx,reg + 4U);
  
#line 170 
  value->u32[2] = _efx_readd(efx,reg + 8U);
  
#line 171 
  value->u32[3] = _efx_readd(efx,reg + 12U);
  
#line 172 
  ldv_spin_unlock_irqrestore_92(& efx->biu_lock,flags);
  
#line 176 
  return;
}


#line 201  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/io.h"
__inline static void efx_readd(struct efx_nic *efx, efx_dword_t *value, unsigned int reg)
{
  
#line 204 
  value->u32[0] = _efx_readd(efx,reg);
  
#line 207 
  return;
}


#line 212  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/io.h"
__inline static void efx_writeo_table(struct efx_nic *efx, efx_oword_t const *value, unsigned int reg, unsigned int index)
{
  
#line 215 
  efx_writeo(efx,value,index * 16U + reg);
  
#line 216 
  return;
}


#line 219  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/io.h"
__inline static void efx_reado_table(struct efx_nic *efx, efx_oword_t *value, unsigned int reg, unsigned int index)
{
  
#line 222 
  efx_reado(efx,value,index * 16U + reg);
  
#line 223 
  return;
}


#line 233  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/io.h"
__inline static void _efx_writeo_page(struct efx_nic *efx, efx_oword_t *value, unsigned int reg, unsigned int page)
{
  
#line 236 
  reg = page * 8192U + reg;
  
#line 243 
  _efx_writeq(efx,value->u64[0],reg);
  
#line 244 
  _efx_writeq(efx,value->u64[1],reg + 8U);
  
#line 245 
  return;
}


#line 262  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/io.h"
__inline static void _efx_writed_page(struct efx_nic *efx, efx_dword_t const *value, unsigned int reg, unsigned int page)
{
  
#line 265 
  efx_writed(efx,value,page * 8192U + reg);
  
#line 266 
  return;
}


#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static void efx_farch_magic_event(struct efx_channel *channel, u32 magic);


#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
__inline static void efx_write_buf_tbl(struct efx_nic *efx, efx_qword_t *value, unsigned int index)
{
  
#line 92 
  efx_sram_writeq(efx,efx->membase + (efx->type)->buf_tbl_base,(efx_qword_t const *)value,index);
  
#line 93 
  return;
}


#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static bool efx_masked_compare_oword(efx_oword_t const *a, efx_oword_t const *b, efx_oword_t const *mask)
{
  bool __retres;
  
#line 99 
  __retres = (_Bool)((((a->u64[0] ^ b->u64[0]) & mask->u64[0]) != 0ULL || ((a->u64[1] ^ b->u64[1]) & mask->u64[1]) != 0ULL) != 0);
  
#line 99 
  return __retres;
}


#line 103  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
int efx_farch_test_registers(struct efx_nic *efx, struct efx_farch_register_test const *regs, size_t n_regs)
{
  int __retres;
  unsigned int i;
  unsigned int j;
  efx_oword_t mask;
  efx_oword_t imask;
  efx_oword_t original;
  efx_oword_t reg;
  efx_oword_t buf;
  unsigned int tmp_0;
  unsigned int tmp_2;
  unsigned int tmp_4;
  unsigned int tmp_6;
  unsigned int tmp_8;
  unsigned int tmp_10;
  unsigned int tmp_12;
  unsigned int tmp_14;
  bool tmp_15;
  unsigned int tmp_17;
  unsigned int tmp_19;
  unsigned int tmp_21;
  unsigned int tmp_23;
  bool tmp_24;
  
#line 107 
  unsigned int address = 0U;
  
#line 110 
  i = 0U;
  
#line 110 
  goto ldv_56747;
  ldv_56746: 
#line 111 
  ;
  
#line 111 
  address = (regs + i)->address;
  
#line 112 
  imask = (regs + i)->mask;
  
#line 112 
  mask = imask;
  
#line 113 
  imask.u64[0] = ~ imask.u64[0];
  
#line 113 
  imask.u64[1] = ~ imask.u64[1];
  
#line 115 
  efx_reado(efx,& original,address);
  
#line 118 
  j = 0U;
  
#line 118 
  goto ldv_56744;
  ldv_56743: 
#line 119 
  ;
  
#line 119 
  if (j <= 31U) {
    unsigned int tmp;
    
#line 119 
    if (j != 0U) 
#line 119 
                 tmp = mask.u32[0] >> j; else 
#line 119 
                                              tmp = mask.u32[0] << - j;
    
#line 119 
    tmp_0 = tmp;
  }
  else 
#line 119 
       tmp_0 = 0U;
  
#line 119 
  if (j + 4294967264U <= 31U) {
    unsigned int tmp_1;
    
#line 119 
    if (j > 32U) 
#line 119 
                 tmp_1 = mask.u32[1] >> (j + 4294967264U); else 
#line 119 
                                                                tmp_1 = mask.u32[1] << (32U - j);
    
#line 119 
    tmp_2 = tmp_1;
  }
  else 
#line 119 
       tmp_2 = 0U;
  
#line 119 
  if (j + 4294967232U <= 31U) {
    unsigned int tmp_3;
    
#line 119 
    if (j > 64U) 
#line 119 
                 tmp_3 = mask.u32[2] >> (j + 4294967232U); else 
#line 119 
                                                                tmp_3 = mask.u32[2] << (64U - j);
    
#line 119 
    tmp_4 = tmp_3;
  }
  else 
#line 119 
       tmp_4 = 0U;
  
#line 119 
  if (j + 4294967200U <= 31U) {
    unsigned int tmp_5;
    
#line 119 
    if (j > 96U) 
#line 119 
                 tmp_5 = mask.u32[3] >> (j + 4294967200U); else 
#line 119 
                                                                tmp_5 = mask.u32[3] << (96U - j);
    
#line 119 
    tmp_6 = tmp_5;
  }
  else 
#line 119 
       tmp_6 = 0U;
  
#line 119 
  if (((((tmp_0 | tmp_2) | tmp_4) | tmp_6) & 1U) == 0U) 
#line 120 
                                                        goto ldv_56741; else ;
  
#line 123 
  reg.u64[0] = original.u64[0] & mask.u64[0];
  
#line 123 
  reg.u64[1] = original.u64[1] & mask.u64[1];
  
#line 124 
  if (j <= 31U) {
    unsigned int tmp_7;
    
#line 124 
    if (j != 0U) 
#line 124 
                 tmp_7 = 1U << j; else 
#line 124 
                                       tmp_7 = 1U >> - j;
    
#line 124 
    tmp_8 = tmp_7;
  }
  else 
#line 124 
       tmp_8 = 0U;
  
#line 124 
  reg.u32[0] = tmp_8;
  
#line 124 
  if (j + 4294967264U <= 31U) {
    unsigned int tmp_9;
    
#line 124 
    if (j > 32U) 
#line 124 
                 tmp_9 = 1U << (j + 4294967264U); else 
#line 124 
                                                       tmp_9 = 1U >> (32U - j);
    
#line 124 
    tmp_10 = tmp_9;
  }
  else 
#line 124 
       tmp_10 = 0U;
  
#line 124 
  reg.u32[1] = tmp_10;
  
#line 124 
  if (j + 4294967232U <= 31U) {
    unsigned int tmp_11;
    
#line 124 
    if (j > 64U) 
#line 124 
                 tmp_11 = 1U << (j + 4294967232U); else 
#line 124 
                                                        tmp_11 = 1U >> (64U - j);
    
#line 124 
    tmp_12 = tmp_11;
  }
  else 
#line 124 
       tmp_12 = 0U;
  
#line 124 
  reg.u32[2] = tmp_12;
  
#line 124 
  if (j + 4294967200U <= 31U) {
    unsigned int tmp_13;
    
#line 124 
    if (j > 96U) 
#line 124 
                 tmp_13 = 1U << (j + 4294967200U); else 
#line 124 
                                                        tmp_13 = 1U >> (96U - j);
    
#line 124 
    tmp_14 = tmp_13;
  }
  else 
#line 124 
       tmp_14 = 0U;
  
#line 124 
  reg.u32[3] = tmp_14;
  
#line 126 
  efx_writeo(efx,(efx_oword_t const *)(& reg),address);
  
#line 127 
  efx_reado(efx,& buf,address);
  
#line 129 
  tmp_15 = efx_masked_compare_oword((efx_oword_t const *)(& reg),(efx_oword_t const *)(& buf),(efx_oword_t const *)(& mask));
  
#line 129 
  if ((int)tmp_15 != 0) 
#line 130 
                        goto fail; else ;
  
#line 133 
  reg.u64[0] = original.u64[0] | mask.u64[0];
  
#line 133 
  reg.u64[1] = original.u64[1] | mask.u64[1];
  
#line 134 
  if (j <= 31U) {
    unsigned int tmp_16;
    
#line 134 
    if (j != 0U) 
#line 134 
                 tmp_16 = 1U << j; else 
#line 134 
                                        tmp_16 = 1U >> - j;
    
#line 134 
    tmp_17 = tmp_16;
  }
  else 
#line 134 
       tmp_17 = 0U;
  
#line 134 
  reg.u32[0] &= tmp_17;
  
#line 134 
  if (j + 4294967264U <= 31U) {
    unsigned int tmp_18;
    
#line 134 
    if (j > 32U) 
#line 134 
                 tmp_18 = 1U << (j + 4294967264U); else 
#line 134 
                                                        tmp_18 = 1U >> (32U - j);
    
#line 134 
    tmp_19 = tmp_18;
  }
  else 
#line 134 
       tmp_19 = 0U;
  
#line 134 
  reg.u32[1] &= tmp_19;
  
#line 134 
  if (j + 4294967232U <= 31U) {
    unsigned int tmp_20;
    
#line 134 
    if (j > 64U) 
#line 134 
                 tmp_20 = 1U << (j + 4294967232U); else 
#line 134 
                                                        tmp_20 = 1U >> (64U - j);
    
#line 134 
    tmp_21 = tmp_20;
  }
  else 
#line 134 
       tmp_21 = 0U;
  
#line 134 
  reg.u32[2] &= tmp_21;
  
#line 134 
  if (j + 4294967200U <= 31U) {
    unsigned int tmp_22;
    
#line 134 
    if (j > 96U) 
#line 134 
                 tmp_22 = 1U << (j + 4294967200U); else 
#line 134 
                                                        tmp_22 = 1U >> (96U - j);
    
#line 134 
    tmp_23 = tmp_22;
  }
  else 
#line 134 
       tmp_23 = 0U;
  
#line 134 
  reg.u32[3] &= tmp_23;
  
#line 136 
  efx_writeo(efx,(efx_oword_t const *)(& reg),address);
  
#line 137 
  efx_reado(efx,& buf,address);
  
#line 139 
  tmp_24 = efx_masked_compare_oword((efx_oword_t const *)(& reg),(efx_oword_t const *)(& buf),(efx_oword_t const *)(& mask));
  
#line 139 
  if ((int)tmp_24 != 0) 
#line 140 
                        goto fail; else ;
  ldv_56741: 
#line 141 
  ;
  
#line 118 
  j += 1U;
  ldv_56744: 
#line 119 
  ;
  
#line 118 
  if (j <= 127U) 
#line 120 
                 goto ldv_56743; else 
#line 123 
                                      goto ldv_56745;
  ldv_56745: 
#line 124 
  ;
  
#line 143 
  efx_writeo(efx,(efx_oword_t const *)(& original),address);
  
#line 110 
  i += 1U;
  ldv_56747: 
#line 111 
  ;
  
#line 110 
  if ((unsigned long)i < n_regs) 
#line 112 
                                 goto ldv_56746; else 
#line 115 
                                                      goto ldv_56748;
  ldv_56748: 
#line 116 
  ;
  
#line 146 
  __retres = 0;
  
#line 146 
  goto return_label;
  fail: 
#line 148 
  ;
  
#line 149 
  if ((efx->msg_enable & 8192U) != 0U) 
#line 149 
                                       netdev_err((struct net_device const *)efx->net_dev,"wrote ",reg.u32[3],reg.u32[2],reg.u32[1],reg.u32[0],buf.u32[3],buf.u32[2],buf.u32[1],buf.u32[0],address,mask.u32[3],mask.u32[2],mask.u32[1],mask.u32[0]); else ;
  
#line 153 
  __retres = -5;
  return_label: 
#line 153 
                return __retres;
}


#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static void efx_init_special_buffer(struct efx_nic *efx, struct efx_special_buffer *buffer)
{
  efx_qword_t buf_desc;
  unsigned int index;
  dma_addr_t dma_addr;
  int i;
  
#line 182 
  i = 0;
  
#line 182 
  goto ldv_56760;
  ldv_56759: 
#line 183 
  ;
  
#line 183 
  index = buffer->index + (unsigned int)i;
  
#line 184 
  dma_addr = buffer->buf.dma_addr + (unsigned long long)(i * 4096);
  
#line 185 
  if ((efx->msg_enable & 2U) != 0U) {
    
#line 185 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_init_special_buffer", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c", .format = "mapping special buffer %d at %llx\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))187U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 185 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 185 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"mapping special buffer %d at %llx\n",index,dma_addr); else ;
  }
  else ;
  
#line 188 
  buf_desc.u64[0] = (dma_addr >> 12) << 14;
  
#line 192 
  efx_write_buf_tbl(efx,& buf_desc,index);
  
#line 182 
  i += 1;
  ldv_56760: 
#line 183 
  ;
  
#line 182 
  if (buffer->entries > (unsigned int)i) 
#line 184 
                                         goto ldv_56759; else 
#line 187 
                                                              goto ldv_56761;
  ldv_56761: 
#line 188 
  ;
  
#line 189 
  return;
}


#line 198  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static void efx_fini_special_buffer(struct efx_nic *efx, struct efx_special_buffer *buffer)
{
  efx_oword_t buf_tbl_upd;
  
#line 201 
  unsigned int start = buffer->index;
  
#line 202 
  unsigned int end = (buffer->index + buffer->entries) + 4294967295U;
  
#line 204 
  if (buffer->entries == 0U) 
#line 205 
                             goto return_label; else ;
  
#line 207 
  if ((efx->msg_enable & 8192U) != 0U) {
    
#line 207 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_fini_special_buffer", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c", .format = "unmapping special buffers %d-%d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))208U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 207 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 207 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"unmapping special buffers %d-%d\n",buffer->index,(buffer->index + buffer->entries) + 4294967295U); else ;
  }
  else ;
  
#line 210 
  buf_tbl_upd.u64[0] = (((unsigned long long)end << 32) | (unsigned long long)start) | 4611686018427387904ULL;
  
#line 210 
  buf_tbl_upd.u64[1] = 0ULL;
  
#line 215 
  efx_writeo(efx,(efx_oword_t const *)(& buf_tbl_upd),1616U);
  return_label: 
#line 216 
                return;
}


#line 227  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static int efx_alloc_special_buffer(struct efx_nic *efx, struct efx_special_buffer *buffer, unsigned int len)
{
  int __retres;
  int tmp;
  bool tmp_0;
  
#line 232 
  struct siena_nic_data *nic_data = (struct siena_nic_data *)efx->nic_data;
  
#line 234 
  len = (len + 4095U) & 4294963200U;
  
#line 236 
  tmp = efx_nic_alloc_buffer(efx,& buffer->buf,len,208U);
  
#line 236 
  if (tmp != 0) {
    
#line 237 
    __retres = -12;
    
#line 237 
    goto return_label;
  }
  else ;
  
#line 238 
  buffer->entries = len / 4096U;
  
#line 239 
  if ((long)((buffer->buf.dma_addr & 4095ULL) != 0ULL) != 0L) {
    
#line 241 
    ldv_inline_asm();
    
#line 239 
    ;
  }
  else ;
  
#line 242 
  buffer->index = efx->next_buffer_table;
  
#line 243 
  efx->next_buffer_table += buffer->entries;
  
#line 245 
  tmp_0 = efx_siena_sriov_enabled(efx);
  
#line 245 
  if ((long)((int)tmp_0 != 0) != 0L) {
    
#line 245 
    if ((long)(nic_data->vf_buftbl_base < efx->next_buffer_table) != 0L) {
      
#line 247 
      ldv_inline_asm();
      
#line 245 
      ;
    }
    else ;
  }
  else ;
  
#line 249 
  if ((efx->msg_enable & 2U) != 0U) {
    
#line 249 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_alloc_special_buffer", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c", .format = "allocating special buffers %d-%d at %llx+%x ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))254U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 249 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      phys_addr_t tmp_1;
      
#line 249 
      tmp_1 = virt_to_phys((void volatile *)buffer->buf.addr);
      
#line 249 
      ;
      
#line 249 
      ;
      
#line 249 
      ;
      
#line 249 
      ;
      
#line 249 
      ;
      
#line 249 
      ;
      
#line 249 
      __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"allocating special buffers %d-%d at %llx+%x ",buffer->index,(buffer->index + buffer->entries) + 4294967295U,buffer->buf.dma_addr,len,buffer->buf.addr,tmp_1);
    }
    else ;
  }
  else ;
  
#line 256 
  __retres = 0;
  return_label: 
#line 256 
                return __retres;
}


#line 260  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static void efx_free_special_buffer(struct efx_nic *efx, struct efx_special_buffer *buffer)
{
  
#line 262 
  if (buffer->buf.addr == (void *)0) 
#line 263 
                                     goto return_label; else ;
  
#line 265 
  if ((efx->msg_enable & 8192U) != 0U) {
    
#line 265 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_free_special_buffer", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c", .format = "deallocating special buffers %d-%d at %llx+%x ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))270U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 265 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      phys_addr_t tmp;
      
#line 265 
      tmp = virt_to_phys((void volatile *)buffer->buf.addr);
      
#line 265 
      ;
      
#line 265 
      ;
      
#line 265 
      ;
      
#line 265 
      ;
      
#line 265 
      ;
      
#line 265 
      ;
      
#line 265 
      __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"deallocating special buffers %d-%d at %llx+%x ",buffer->index,(buffer->index + buffer->entries) + 4294967295U,buffer->buf.dma_addr,buffer->buf.len,buffer->buf.addr,tmp);
    }
    else ;
  }
  else ;
  
#line 272 
  efx_nic_free_buffer(efx,& buffer->buf);
  
#line 273 
  buffer->entries = 0U;
  return_label: 
#line 274 
                return;
}


#line 283  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
__inline static void efx_farch_notify_tx_desc(struct efx_tx_queue *tx_queue)
{
  unsigned int write_ptr;
  efx_dword_t reg;
  
#line 288 
  write_ptr = tx_queue->write_count & tx_queue->ptr_mask;
  
#line 289 
  reg.u32[0] = write_ptr;
  
#line 290 
  _efx_writed_page(tx_queue->efx,(efx_dword_t const *)(& reg),2588U,tx_queue->queue);
  
#line 291 
  return;
}


#line 301 
void __compiletime_assert_301(void);


#line 302 
void __compiletime_assert_302(void);


#line 295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
__inline static void efx_farch_push_tx_desc(struct efx_tx_queue *tx_queue, efx_qword_t const *txd)
{
  unsigned int write_ptr;
  efx_oword_t reg;
  {
    
#line 301 
    bool __cond = (_Bool)0;
    
#line 301 
    if ((int)__cond != 0) 
#line 301 
                          __compiletime_assert_301(); else ;
  }
  {
    
#line 302 
    bool __cond_0 = (_Bool)0;
    
#line 302 
    if ((int)__cond_0 != 0) 
#line 302 
                            __compiletime_assert_302(); else ;
  }
  
#line 304 
  write_ptr = tx_queue->write_count & tx_queue->ptr_mask;
  
#line 305 
  reg.u64[0] = 0ULL;
  
#line 305 
  reg.u64[1] = ((unsigned long long)write_ptr << 32) | 2147483648ULL;
  
#line 307 
  reg.qword[0] = *txd;
  
#line 308 
  _efx_writeo_page(tx_queue->efx,& reg,2576U,tx_queue->queue);
  
#line 309 
  return;
}


#line 335 
void __compiletime_assert_335(void);


#line 317  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
void efx_farch_tx_write(struct efx_tx_queue *tx_queue)
{
  struct efx_tx_buffer *buffer;
  efx_qword_t *txd;
  unsigned int write_ptr;
  bool tmp;
  
#line 322 
  unsigned int old_write_count = tx_queue->write_count;
  
#line 324 
  if ((long)(tx_queue->write_count == tx_queue->insert_count) != 0L) {
    
#line 326 
    ldv_inline_asm();
    
#line 324 
    ;
  }
  else ;
  ldv_56842: 
#line 326 
  ;
  
#line 327 
  write_ptr = tx_queue->write_count & tx_queue->ptr_mask;
  
#line 328 
  buffer = tx_queue->buffer + write_ptr;
  
#line 329 
  txd = efx_tx_desc(tx_queue,write_ptr);
  
#line 330 
  tx_queue->write_count += 1U;
  {
    
#line 335 
    bool __cond = (_Bool)0;
    
#line 335 
    if ((int)__cond != 0) 
#line 335 
                          __compiletime_assert_335(); else ;
  }
  
#line 336 
  txd->u64[0] = ((((unsigned long long)buffer->flags << 62) & 4611686018427387904ULL) | ((unsigned long long)buffer->len << 48)) | buffer->__anonCompField_efx_tx_buffer_116.dma_addr;
  
#line 342 
  if (tx_queue->write_count != tx_queue->insert_count) 
#line 344 
                                                       goto ldv_56842; else 
                                                                    
#line 347 
                                                                    goto ldv_56843;
  ldv_56843: 
#line 348 
  ;
  
#line 349 
  ldv_inline_asm();
  
#line 346 
  tmp = efx_nic_may_push_tx_desc(tx_queue,old_write_count);
  
#line 346 
  if ((int)tmp != 0) {
    
#line 347 
    txd = efx_tx_desc(tx_queue,tx_queue->ptr_mask & old_write_count);
    
#line 349 
    efx_farch_push_tx_desc(tx_queue,(efx_qword_t const *)txd);
    
#line 350 
    tx_queue->pushes += 1U;
  }
  else 
#line 352 
       efx_farch_notify_tx_desc(tx_queue);
  
#line 353 
  return;
}


#line 357  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
int efx_farch_tx_probe(struct efx_tx_queue *tx_queue)
{
  unsigned int entries;
  int tmp;
  
#line 359 
  struct efx_nic *efx = tx_queue->efx;
  
#line 362 
  entries = tx_queue->ptr_mask + 1U;
  
#line 363 
  tmp = efx_alloc_special_buffer(efx,& tx_queue->txd,entries * 8U);
  
#line 363 
  return tmp;
}


#line 367  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
void efx_farch_tx_init(struct efx_tx_queue *tx_queue)
{
  efx_oword_t reg;
  unsigned long tmp;
  int tmp_2;
  int tmp_3;
  int tmp_5;
  
#line 369 
  struct efx_nic *efx = tx_queue->efx;
  
#line 373 
  efx_init_special_buffer(efx,& tx_queue->txd);
  
#line 376 
  tmp = __ffs((unsigned long)tx_queue->txd.entries);
  
#line 376 
  reg.u64[0] = ((((unsigned long long)tx_queue->txd.index << 36) | ((unsigned long long)(tx_queue->channel)->channel << 24)) | ((unsigned long long)tx_queue->queue << 5)) | ((unsigned long long)tmp << 3);
  
#line 376 
  reg.u64[1] = 150994944ULL;
  
#line 390 
  tmp_2 = efx_nic_rev(efx);
  
#line 390 
  if (tmp_2 > 1) {
    unsigned long long tmp_0;
    unsigned long long tmp_1;
    
#line 391 
    int csum = (int)tx_queue->queue & 1;
    
#line 392 
    reg.u64[0] = reg.u64[0];
    
#line 392 
    if (csum == 0) 
#line 392 
                   tmp_0 = 67108864ULL; else 
#line 392 
                                             tmp_0 = 0ULL;
    
#line 392 
    reg.u64[1] = (reg.u64[1] & 18446744073642442751ULL) | tmp_0;
    
#line 393 
    reg.u64[0] = reg.u64[0];
    
#line 393 
    if (csum == 0) 
#line 393 
                   tmp_1 = 33554432ULL; else 
#line 393 
                                             tmp_1 = 0ULL;
    
#line 393 
    reg.u64[1] = (reg.u64[1] & 18446744073675997183ULL) | tmp_1;
  }
  else ;
  
#line 397 
  efx_writeo_table(efx,(efx_oword_t const *)(& reg),(efx->type)->txd_ptr_tbl_base,tx_queue->queue);
  
#line 400 
  tmp_3 = efx_nic_rev(efx);
  
#line 400 
  if (tmp_3 <= 1) {
    {
      
#line 402 
      bool __cond = (_Bool)0;
      
#line 402 
      if ((int)__cond != 0) 
#line 402 
                            __compiletime_assert_402(); else ;
    }
    
#line 404 
    efx_reado(efx,& reg,2608U);
    
#line 405 
    if ((tx_queue->queue & 1U) != 0U) 
#line 406 
                                      __set_bit_le((int)tx_queue->queue,(void *)(& reg)); else 
                                                                    
#line 408 
                                                                    __set_bit_le((int)tx_queue->queue,(void *)(& reg));
    
#line 409 
    efx_writeo(efx,(efx_oword_t const *)(& reg),2608U);
  }
  else ;
  
#line 412 
  tmp_5 = efx_nic_rev(efx);
  
#line 412 
  if (tmp_5 > 1) {
    int tmp_4;
    
#line 413 
    if ((tx_queue->queue & 2U) != 0U) 
#line 413 
                                      tmp_4 = 0; else 
#line 413 
                                                      tmp_4 = 21;
    
#line 413 
    reg.u64[0] = (unsigned long long)tmp_4;
    
#line 413 
    reg.u64[1] = 0ULL;
    
#line 418 
    efx_writeo_table(efx,(efx_oword_t const *)(& reg),16252928U,tx_queue->queue);
  }
  else ;
  
#line 421 
  return;
}


#line 423  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static void efx_farch_flush_tx_queue(struct efx_tx_queue *tx_queue)
{
  efx_oword_t tx_flush_descq;
  
#line 425 
  struct efx_nic *efx = tx_queue->efx;
  {
    int tmp;
    
#line 428 
    tmp = atomic_read((atomic_t const *)(& tx_queue->flush_outstanding));
    
#line 428 
    int __ret_warn_on = tmp != 0;
    
#line 428 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 428 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c",428); else ;
    
#line 428 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 429 
  atomic_set(& tx_queue->flush_outstanding,1);
  
#line 431 
  tx_flush_descq.u64[0] = (unsigned long long)(tx_queue->queue | 4096U);
  
#line 431 
  tx_flush_descq.u64[1] = 0ULL;
  
#line 434 
  efx_writeo(efx,(efx_oword_t const *)(& tx_flush_descq),2560U);
  
#line 435 
  return;
}


#line 437  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
void efx_farch_tx_fini(struct efx_tx_queue *tx_queue)
{
  efx_oword_t tx_desc_ptr;
  
#line 439 
  struct efx_nic *efx = tx_queue->efx;
  
#line 443 
  tx_desc_ptr.u64[0] = 0ULL;
  
#line 443 
  tx_desc_ptr.u64[1] = 0ULL;
  
#line 444 
  efx_writeo_table(efx,(efx_oword_t const *)(& tx_desc_ptr),(efx->type)->txd_ptr_tbl_base,tx_queue->queue);
  
#line 448 
  efx_fini_special_buffer(efx,& tx_queue->txd);
  
#line 449 
  return;
}


#line 452  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
void efx_farch_tx_remove(struct efx_tx_queue *tx_queue)
{
  
#line 454 
  efx_free_special_buffer(tx_queue->efx,& tx_queue->txd);
  
#line 455 
  return;
}


#line 465  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
__inline static void efx_farch_build_rx_desc(struct efx_rx_queue *rx_queue, unsigned int index)
{
  struct efx_rx_buffer *rx_buf;
  efx_qword_t *rxd;
  
#line 470 
  rxd = efx_rx_desc(rx_queue,index);
  
#line 471 
  rx_buf = efx_rx_buffer(rx_queue,index);
  
#line 472 
  rxd->u64[0] = ((unsigned long long)((unsigned int)rx_buf->len - ((rx_queue->efx)->type)->rx_buffer_padding) << 48) | rx_buf->dma_addr;
  
#line 473 
  return;
}


#line 483  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
void efx_farch_rx_write(struct efx_rx_queue *rx_queue)
{
  efx_dword_t reg;
  unsigned int write_ptr;
  int tmp;
  
#line 485 
  struct efx_nic *efx = rx_queue->efx;
  
#line 489 
  goto ldv_56887;
  ldv_56886: 
#line 490 
  ;
  
#line 490 
  efx_farch_build_rx_desc(rx_queue,rx_queue->notified_count & rx_queue->ptr_mask);
  
#line 493 
  rx_queue->notified_count += 1U;
  ldv_56887: 
#line 494 
  ;
  
#line 489 
  if (rx_queue->notified_count != rx_queue->added_count) 
#line 491 
                                                         goto ldv_56886; else 
                                                                    
#line 494 
                                                                    goto ldv_56888;
  ldv_56888: 
#line 495 
  ;
  
#line 496 
  ldv_inline_asm();
  
#line 497 
  write_ptr = rx_queue->added_count & rx_queue->ptr_mask;
  
#line 498 
  reg.u32[0] = write_ptr;
  
#line 499 
  tmp = efx_rx_queue_index(rx_queue);
  
#line 499 
  ;
  
#line 499 
  _efx_writed_page(efx,(efx_dword_t const *)(& reg),2108U,(unsigned int)tmp);
  
#line 500 
  return;
}


#line 503  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
int efx_farch_rx_probe(struct efx_rx_queue *rx_queue)
{
  unsigned int entries;
  int tmp;
  
#line 505 
  struct efx_nic *efx = rx_queue->efx;
  
#line 508 
  entries = rx_queue->ptr_mask + 1U;
  
#line 509 
  tmp = efx_alloc_special_buffer(efx,& rx_queue->rxd,entries * 8U);
  
#line 509 
  return tmp;
}


#line 513  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
void efx_farch_rx_init(struct efx_rx_queue *rx_queue)
{
  efx_oword_t rx_desc_ptr;
  int tmp;
  bool jumbo_en;
  struct efx_channel *tmp_1;
  int tmp_2;
  unsigned long tmp_3;
  int tmp_4;
  
#line 516 
  struct efx_nic *efx = rx_queue->efx;
  
#line 517 
  tmp = efx_nic_rev(efx);
  
#line 517 
  bool is_b0 = (_Bool)(tmp > 1);
  
#line 518 
  bool iscsi_digest_en = is_b0;
  
#line 526 
  jumbo_en = (_Bool)((! is_b0 || (int)efx->rx_scatter != 0) != 0);
  
#line 528 
  if ((efx->msg_enable & 8192U) != 0U) {
    
#line 528 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_farch_rx_init", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c", .format = "RX queue %d ring in special buffers %d-%d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))531U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 528 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      int tmp_0;
      
#line 528 
      ;
      
#line 528 
      ;
      
#line 528 
      tmp_0 = efx_rx_queue_index(rx_queue);
      
#line 528 
      ;
      
#line 528 
      __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"RX queue %d ring in special buffers %d-%d\n",tmp_0,rx_queue->rxd.index,(rx_queue->rxd.index + rx_queue->rxd.entries) + 4294967295U);
    }
    else ;
  }
  else ;
  
#line 533 
  rx_queue->scatter_n = 0U;
  
#line 536 
  efx_init_special_buffer(efx,& rx_queue->rxd);
  
#line 539 
  tmp_1 = efx_rx_queue_channel(rx_queue);
  
#line 539 
  tmp_2 = efx_rx_queue_index(rx_queue);
  
#line 539 
  tmp_3 = __ffs((unsigned long)rx_queue->rxd.entries);
  
#line 539 
  rx_desc_ptr.u64[0] = ((((((unsigned long long)rx_queue->rxd.index << 36) | ((unsigned long long)tmp_1->channel << 24)) | ((unsigned long long)tmp_2 << 5)) | ((unsigned long long)tmp_3 << 3)) | ((unsigned long long)jumbo_en << 1)) | 1ULL;
  
#line 539 
  rx_desc_ptr.u64[1] = ((unsigned long long)iscsi_digest_en << 24) | ((unsigned long long)iscsi_digest_en << 23);
  
#line 554 
  tmp_4 = efx_rx_queue_index(rx_queue);
  
#line 553 
  ;
  
#line 553 
  ;
  
#line 553 
  efx_writeo_table(efx,(efx_oword_t const *)(& rx_desc_ptr),(efx->type)->rxd_ptr_tbl_base,(unsigned int)tmp_4);
  
#line 555 
  return;
}


#line 557  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static void efx_farch_flush_rx_queue(struct efx_rx_queue *rx_queue)
{
  efx_oword_t rx_flush_descq;
  int tmp;
  
#line 559 
  struct efx_nic *efx = rx_queue->efx;
  
#line 562 
  tmp = efx_rx_queue_index(rx_queue);
  
#line 562 
  rx_flush_descq.u64[0] = (unsigned long long)(tmp | 16777216);
  
#line 562 
  rx_flush_descq.u64[1] = 0ULL;
  
#line 566 
  efx_writeo(efx,(efx_oword_t const *)(& rx_flush_descq),2080U);
  
#line 567 
  return;
}


#line 569  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
void efx_farch_rx_fini(struct efx_rx_queue *rx_queue)
{
  efx_oword_t rx_desc_ptr;
  int tmp;
  
#line 572 
  struct efx_nic *efx = rx_queue->efx;
  
#line 575 
  rx_desc_ptr.u64[0] = 0ULL;
  
#line 575 
  rx_desc_ptr.u64[1] = 0ULL;
  
#line 577 
  tmp = efx_rx_queue_index(rx_queue);
  
#line 576 
  ;
  
#line 576 
  ;
  
#line 576 
  efx_writeo_table(efx,(efx_oword_t const *)(& rx_desc_ptr),(efx->type)->rxd_ptr_tbl_base,(unsigned int)tmp);
  
#line 580 
  efx_fini_special_buffer(efx,& rx_queue->rxd);
  
#line 581 
  return;
}


#line 584  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
void efx_farch_rx_remove(struct efx_rx_queue *rx_queue)
{
  
#line 586 
  efx_free_special_buffer(rx_queue->efx,& rx_queue->rxd);
  
#line 587 
  return;
}


#line 598  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static bool efx_farch_flush_wake(struct efx_nic *efx)
{
  bool __retres;
  int tmp_2;
  int tmp;
  
#line 600 
  ldv_inline_asm();
  
#line 603 
  tmp = atomic_read((atomic_t const *)(& efx->active_queues));
  
#line 603 
  if (tmp == 0) 
#line 603 
                tmp_2 = 1;
  else {
    int tmp_0;
    
#line 603 
    tmp_0 = atomic_read((atomic_t const *)(& efx->rxq_flush_outstanding));
    
#line 603 
    if (tmp_0 <= 3) {
      int tmp_1;
      
#line 605 
      tmp_1 = atomic_read((atomic_t const *)(& efx->rxq_flush_pending));
      
#line 605 
      if (tmp_1 > 0) 
#line 603 
                     tmp_2 = 1; else 
#line 603 
                                     tmp_2 = 0;
    }
    else 
#line 603 
         tmp_2 = 0;
  }
  
#line 603 
  __retres = (_Bool)(tmp_2 != 0);
  
#line 603 
  return __retres;
}


#line 608  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static bool efx_check_tx_flush_complete(struct efx_nic *efx)
{
  efx_oword_t txd_ptr_tbl;
  struct efx_channel *channel;
  struct efx_tx_queue *tx_queue;
  int tmp_2;
  bool tmp_1;
  
#line 610 
  bool i = (_Bool)1;
  
#line 615 
  channel = efx->channel[0];
  
#line 615 
  goto ldv_56958;
  ldv_56957: 
#line 616 
  ;
  
#line 616 
  tmp_1 = efx_channel_has_tx_queues(channel);
  
#line 616 
  if (tmp_1) 
#line 616 
             tmp_2 = 0; else 
#line 616 
                             tmp_2 = 1;
  
#line 616 
  if (tmp_2) ;
  else {
    
#line 616 
    tx_queue = (struct efx_tx_queue *)(& channel->tx_queue);
    
#line 616 
    goto ldv_56955;
    ldv_56954: 
#line 617 
    ;
    
#line 617 
    efx_reado_table(efx,& txd_ptr_tbl,16056320U,tx_queue->queue);
    
#line 619 
    if ((txd_ptr_tbl.u64[0] & 1ULL) != 0ULL || (txd_ptr_tbl.u64[1] & 16777216ULL) != 0ULL) {
      
#line 623 
      if ((efx->msg_enable & 8192U) != 0U) {
        
#line 623 
        struct _ddebug descriptor = {.modname = "sfc", .function = "efx_check_tx_flush_complete", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c", .format = "flush did not complete on TXQ %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))625U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 623 
        if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 623 
                                                            __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"flush did not complete on TXQ %d\n",tx_queue->queue); else ;
      }
      else ;
      
#line 626 
      i = (_Bool)0;
    }
    else {
      int tmp;
      
#line 627 
      tmp = atomic_cmpxchg(& tx_queue->flush_outstanding,1,0);
      
#line 627 
      if (tmp != 0) {
        
#line 632 
        if ((efx->msg_enable & 8192U) != 0U) {
          
#line 632 
          struct _ddebug descriptor_0 = {.modname = "sfc", .function = "efx_check_tx_flush_complete", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c", .format = "flush complete on TXQ %d, so drain ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))634U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
          
#line 632 
          if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 632 
                                                                __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)efx->net_dev,"flush complete on TXQ %d, so drain ",tx_queue->queue); else ;
        }
        else ;
        
#line 639 
        efx_farch_magic_event(channel,tx_queue->queue | 66560U);
      }
      else ;
    }
    
#line 616 
    tx_queue += 1;
    ldv_56955: 
#line 617 
    ;
    
#line 616 
    if ((struct efx_tx_queue *)(& channel->tx_queue) + 4U > tx_queue) {
      bool tmp_0;
      
#line 616 
      tmp_0 = efx_tx_queue_used(tx_queue);
      
#line 616 
      if ((int)tmp_0 != 0) 
#line 618 
                           goto ldv_56954; else 
#line 621 
                                                goto ldv_56956;
    }
    else 
#line 621 
         goto ldv_56956;
    ldv_56956: 
#line 622 
    ;
  }
  
#line 615 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 615 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 615 
                                                                    channel = (struct efx_channel *)0;
  ldv_56958: 
#line 616 
  ;
  
#line 615 
  if (channel != (struct efx_channel *)0) 
#line 617 
                                          goto ldv_56957; else 
#line 620 
                                                               goto ldv_56959;
  ldv_56959: 
#line 621 
  ;
  
#line 646 
  return i;
}


#line 652  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static int efx_farch_do_flush(struct efx_nic *efx)
{
  unsigned long tmp;
  struct efx_channel *channel;
  struct efx_rx_queue *rx_queue;
  struct efx_tx_queue *tx_queue;
  int tmp_2;
  bool tmp_1;
  int tmp_4;
  bool tmp_3;
  bool tmp_5;
  int tmp_8;
  bool tmp_7;
  long tmp_15;
  int tmp_20;
  
#line 654 
  tmp = msecs_to_jiffies(5000U);
  
#line 654 
  unsigned int timeout = (unsigned int)tmp;
  
#line 658 
  int rc = 0;
  
#line 660 
  channel = efx->channel[0];
  
#line 660 
  goto ldv_56975;
  ldv_56974: 
#line 661 
  ;
  
#line 661 
  tmp_1 = efx_channel_has_tx_queues(channel);
  
#line 661 
  if (tmp_1) 
#line 661 
             tmp_2 = 0; else 
#line 661 
                             tmp_2 = 1;
  
#line 661 
  if (tmp_2) ;
  else {
    
#line 661 
    tx_queue = (struct efx_tx_queue *)(& channel->tx_queue);
    
#line 661 
    goto ldv_56969;
    ldv_56968: 
#line 662 
    ;
    
#line 662 
    efx_farch_flush_tx_queue(tx_queue);
    
#line 661 
    tx_queue += 1;
    ldv_56969: 
#line 662 
    ;
    
#line 661 
    if ((struct efx_tx_queue *)(& channel->tx_queue) + 4U > tx_queue) {
      bool tmp_0;
      
#line 661 
      tmp_0 = efx_tx_queue_used(tx_queue);
      
#line 661 
      if ((int)tmp_0 != 0) 
#line 663 
                           goto ldv_56968; else 
#line 666 
                                                goto ldv_56970;
    }
    else 
#line 666 
         goto ldv_56970;
    ldv_56970: 
#line 667 
    ;
  }
  
#line 664 
  tmp_3 = efx_channel_has_rx_queue(channel);
  
#line 664 
  if (tmp_3) 
#line 664 
             tmp_4 = 0; else 
#line 664 
                             tmp_4 = 1;
  
#line 664 
  if (tmp_4) ;
  else {
    
#line 664 
    rx_queue = & channel->rx_queue;
    
#line 664 
    goto ldv_56972;
    ldv_56971: 
#line 665 
    ;
    
#line 665 
    rx_queue->flush_pending = (_Bool)1;
    
#line 666 
    atomic_inc(& efx->rxq_flush_pending);
    
#line 664 
    rx_queue = (struct efx_rx_queue *)0;
    ldv_56972: 
#line 665 
    ;
    
#line 664 
    if (rx_queue != (struct efx_rx_queue *)0) 
#line 666 
                                              goto ldv_56971; else 
#line 669 
                                                                   goto ldv_56973;
    ldv_56973: 
#line 670 
    ;
  }
  
#line 660 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 660 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 660 
                                                                    channel = (struct efx_channel *)0;
  ldv_56975: 
#line 661 
  ;
  
#line 660 
  if (channel != (struct efx_channel *)0) 
#line 662 
                                          goto ldv_56974; else 
#line 665 
                                                               goto ldv_56976;
  ldv_56976: 
#line 666 
  ;
  
#line 670 
  goto ldv_56998;
  ldv_56997: 
#line 671 
  ;
  
#line 675 
  tmp_5 = efx_siena_sriov_enabled(efx);
  
#line 675 
  if ((int)tmp_5 != 0) {
    
#line 676 
    rc = efx_mcdi_flush_rxqs(efx);
    
#line 677 
    if (rc == 0) 
#line 678 
                 goto wait; else ;
  }
  else ;
  
#line 685 
  channel = efx->channel[0];
  
#line 685 
  goto ldv_56982;
  ldv_56981: 
#line 686 
  ;
  
#line 686 
  tmp_7 = efx_channel_has_rx_queue(channel);
  
#line 686 
  if (tmp_7) 
#line 686 
             tmp_8 = 0; else 
#line 686 
                             tmp_8 = 1;
  
#line 686 
  if (tmp_8) ;
  else {
    int tmp_6;
    
#line 686 
    rx_queue = & channel->rx_queue;
    
#line 686 
    goto ldv_56980;
    ldv_56979: 
#line 687 
    ;
    
#line 687 
    tmp_6 = atomic_read((atomic_t const *)(& efx->rxq_flush_outstanding));
    
#line 687 
    if (tmp_6 > 3) 
#line 689 
                   goto ldv_56978; else ;
    
#line 691 
    if ((int)rx_queue->flush_pending != 0) {
      
#line 692 
      rx_queue->flush_pending = (_Bool)0;
      
#line 693 
      atomic_dec(& efx->rxq_flush_pending);
      
#line 694 
      atomic_inc(& efx->rxq_flush_outstanding);
      
#line 695 
      efx_farch_flush_rx_queue(rx_queue);
    }
    else ;
    
#line 686 
    rx_queue = (struct efx_rx_queue *)0;
    ldv_56980: 
#line 687 
    ;
    
#line 686 
    if (rx_queue != (struct efx_rx_queue *)0) 
#line 688 
                                              goto ldv_56979; else 
#line 691 
                                                                   goto ldv_56978;
    ldv_56978: 
#line 692 
    ;
  }
  
#line 685 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 685 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 685 
                                                                    channel = (struct efx_channel *)0;
  ldv_56982: 
#line 686 
  ;
  
#line 685 
  if (channel != (struct efx_channel *)0) 
#line 687 
                                          goto ldv_56981; else 
#line 690 
                                                               goto ldv_56983;
  ldv_56983: 
#line 691 
  ;
  wait: 
#line 700 
  ;
  {
    
#line 701 
    long __ret = (long)timeout;
    
#line 701 
    __might_sleep("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c",703,0);
    {
      int tmp_14;
      {
        
#line 701 
        bool __cond_0 = efx_farch_flush_wake(efx);
        
#line 701 
        if ((int)__cond_0 != 0 && __ret == 0L) 
#line 701 
                                               __ret = 1L; else ;
        
#line 701 
        tmp_14 = ((int)__cond_0 != 0 || __ret == 0L) != 0;
      }
      
#line 701 
      if (tmp_14 == 0) {
        long tmp_12;
        {
          wait_queue_t __wait;
          
#line 701 
          long __ret_0 = (long)timeout;
          
#line 701 
          INIT_LIST_HEAD(& __wait.task_list);
          
#line 701 
          __wait.flags = 0U;
          ldv_56994: 
#line 704 
          ;
          {
            int tmp_11;
            
#line 701 
            long __int = prepare_to_wait_event(& efx->flush_wq,& __wait,2);
            {
              
#line 701 
              bool __cond = efx_farch_flush_wake(efx);
              
#line 701 
              if ((int)__cond != 0 && __ret_0 == 0L) 
#line 701 
                                                     __ret_0 = 1L; else ;
              
#line 701 
              tmp_11 = ((int)__cond != 0 || __ret_0 == 0L) != 0;
            }
            
#line 701 
            if (tmp_11 != 0) 
#line 701 
                             goto ldv_56993; else ;
            
#line 701 
            __ret_0 = schedule_timeout(__ret_0);
          }
          
#line 701 
          goto ldv_56994;
          ldv_56993: 
#line 702 
          ;
          
#line 701 
          finish_wait(& efx->flush_wq,& __wait);
          __out_0: 
#line 701 
          ;
          
#line 701 
          tmp_12 = __ret_0;
        }
        
#line 701 
        __ret = tmp_12;
      }
      else ;
    }
    
#line 701 
    tmp_15 = __ret;
  }
  
#line 701 
  timeout = (unsigned int)tmp_15;
  ldv_56998: 
#line 703 
  ;
  
#line 670 
  if (timeout != 0U) {
    int tmp_16;
    
#line 670 
    tmp_16 = atomic_read((atomic_t const *)(& efx->active_queues));
    
#line 670 
    if (tmp_16 > 0) 
#line 672 
                    goto ldv_56997; else 
#line 675 
                                         goto ldv_56999;
  }
  else 
#line 675 
       goto ldv_56999;
  ldv_56999: 
#line 676 
  ;
  
#line 706 
  tmp_20 = atomic_read((atomic_t const *)(& efx->active_queues));
  
#line 706 
  if (tmp_20 != 0) {
    int tmp_22;
    bool tmp_21;
    
#line 707 
    tmp_21 = efx_check_tx_flush_complete(efx);
    
#line 707 
    if (tmp_21) 
#line 707 
                tmp_22 = 0; else 
#line 707 
                                 tmp_22 = 1;
    
#line 707 
    if (tmp_22) {
      
#line 708 
      if ((efx->msg_enable & 8192U) != 0U) {
        int tmp_17;
        int tmp_18;
        int tmp_19;
        
#line 708 
        tmp_17 = atomic_read((atomic_t const *)(& efx->rxq_flush_pending));
        
#line 708 
        tmp_18 = atomic_read((atomic_t const *)(& efx->rxq_flush_outstanding));
        
#line 708 
        tmp_19 = atomic_read((atomic_t const *)(& efx->active_queues));
        
#line 708 
        ;
        
#line 708 
        netdev_err((struct net_device const *)efx->net_dev,"failed to flush %d queues ",tmp_19,tmp_18,tmp_17);
      }
      else ;
      
#line 712 
      rc = -110;
      
#line 714 
      atomic_set(& efx->active_queues,0);
      
#line 715 
      atomic_set(& efx->rxq_flush_pending,0);
      
#line 716 
      atomic_set(& efx->rxq_flush_outstanding,0);
    }
    else ;
  }
  else ;
  
#line 719 
  return rc;
}


#line 722  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
int efx_farch_fini_dmaq(struct efx_nic *efx)
{
  struct efx_channel *channel;
  struct efx_tx_queue *tx_queue;
  struct efx_rx_queue *rx_queue;
  
#line 727 
  int rc = 0;
  
#line 730 
  if (efx->state != (unsigned int)STATE_RECOVERY) {
    int tmp_0;
    bool tmp;
    int tmp_3;
    bool tmp_2;
    
#line 732 
    if ((unsigned int)*((unsigned char *)efx->pci_dev + 2529UL) != 0U) {
      
#line 733 
      (*((efx->type)->prepare_flush))(efx);
      
#line 734 
      rc = efx_farch_do_flush(efx);
      
#line 735 
      (*((efx->type)->finish_flush))(efx);
    }
    else ;
    
#line 738 
    channel = efx->channel[0];
    
#line 738 
    goto ldv_57014;
    ldv_57013: 
#line 739 
    ;
    
#line 739 
    tmp = efx_channel_has_rx_queue(channel);
    
#line 739 
    if (tmp) 
#line 739 
             tmp_0 = 0; else 
#line 739 
                             tmp_0 = 1;
    
#line 739 
    if (tmp_0) ;
    else {
      
#line 739 
      rx_queue = & channel->rx_queue;
      
#line 739 
      goto ldv_57008;
      ldv_57007: 
#line 740 
      ;
      
#line 740 
      efx_farch_rx_fini(rx_queue);
      
#line 739 
      rx_queue = (struct efx_rx_queue *)0;
      ldv_57008: 
#line 740 
      ;
      
#line 739 
      if (rx_queue != (struct efx_rx_queue *)0) 
#line 741 
                                                goto ldv_57007; else 
                                                                  
#line 744 
                                                                  goto ldv_57009;
      ldv_57009: 
#line 745 
      ;
    }
    
#line 741 
    tmp_2 = efx_channel_has_tx_queues(channel);
    
#line 741 
    if (tmp_2) 
#line 741 
               tmp_3 = 0; else 
#line 741 
                               tmp_3 = 1;
    
#line 741 
    if (tmp_3) ;
    else {
      
#line 741 
      tx_queue = (struct efx_tx_queue *)(& channel->tx_queue);
      
#line 741 
      goto ldv_57011;
      ldv_57010: 
#line 742 
      ;
      
#line 742 
      efx_farch_tx_fini(tx_queue);
      
#line 741 
      tx_queue += 1;
      ldv_57011: 
#line 742 
      ;
      
#line 741 
      if ((struct efx_tx_queue *)(& channel->tx_queue) + 4U > tx_queue) {
        bool tmp_1;
        
#line 741 
        tmp_1 = efx_tx_queue_used(tx_queue);
        
#line 741 
        if ((int)tmp_1 != 0) 
#line 743 
                             goto ldv_57010; else 
#line 746 
                                                  goto ldv_57012;
      }
      else 
#line 746 
           goto ldv_57012;
      ldv_57012: 
#line 747 
      ;
    }
    
#line 738 
    if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 738 
                                                                channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 738 
                                                                    channel = (struct efx_channel *)0;
    ldv_57014: 
#line 739 
    ;
    
#line 738 
    if (channel != (struct efx_channel *)0) 
#line 740 
                                            goto ldv_57013; else 
#line 743 
                                                                 goto ldv_57015;
    ldv_57015: 
#line 744 
    ;
  }
  else ;
  
#line 746 
  return rc;
}


#line 763  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
void efx_farch_finish_flr(struct efx_nic *efx)
{
  
#line 765 
  atomic_set(& efx->rxq_flush_pending,0);
  
#line 766 
  atomic_set(& efx->rxq_flush_outstanding,0);
  
#line 767 
  atomic_set(& efx->active_queues,0);
  
#line 768 
  return;
}


#line 783  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
void efx_farch_ev_read_ack(struct efx_channel *channel)
{
  efx_dword_t reg;
  
#line 786 
  struct efx_nic *efx = channel->efx;
  
#line 788 
  reg.u32[0] = channel->eventq_read_ptr & channel->eventq_mask;
  
#line 794 
  efx_writed(efx,(efx_dword_t const *)(& reg),(efx->type)->evq_rptr_tbl_base + (unsigned int)(channel->channel * 16));
  
#line 797 
  return;
}


#line 805 
void __compiletime_assert_806(void);


#line 800  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
void efx_farch_generate_event(struct efx_nic *efx, unsigned int evq, efx_qword_t *event)
{
  efx_oword_t drv_ev_reg;
  {
    
#line 805 
    bool __cond = (_Bool)0;
    
#line 805 
    if ((int)__cond != 0) 
#line 805 
                          __compiletime_assert_806(); else ;
  }
  
#line 807 
  drv_ev_reg.u32[0] = event->u32[0];
  
#line 808 
  drv_ev_reg.u32[1] = event->u32[1];
  
#line 809 
  drv_ev_reg.u32[2] = 0U;
  
#line 810 
  drv_ev_reg.u32[3] = 0U;
  
#line 811 
  drv_ev_reg.u64[0] = drv_ev_reg.u64[0];
  
#line 811 
  drv_ev_reg.u64[1] = (drv_ev_reg.u64[1] & 18446744073709547520ULL) | (unsigned long long)evq;
  
#line 812 
  efx_writeo(efx,(efx_oword_t const *)(& drv_ev_reg),1088U);
  
#line 813 
  return;
}


#line 815  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static void efx_farch_magic_event(struct efx_channel *channel, u32 magic)
{
  efx_qword_t event;
  
#line 819 
  event.u64[0] = (unsigned long long)magic | 8070450532247928832ULL;
  
#line 822 
  efx_farch_generate_event(channel->efx,(unsigned int)channel->channel,& event);
  
#line 823 
  return;
}


#line 831  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static int efx_farch_handle_tx_event(struct efx_channel *channel, efx_qword_t *event)
{
  int __retres;
  unsigned int tx_ev_desc_ptr;
  unsigned int tx_ev_q_label;
  struct efx_tx_queue *tx_queue;
  unsigned long volatile *tmp;
  
#line 836 
  struct efx_nic *efx = channel->efx;
  
#line 837 
  int tx_packets = 0;
  {
    
#line 839 
    unsigned long __var = 0UL;
    
#line 839 
    tmp = (unsigned long volatile *)(& efx->reset_pending);
  }
  
#line 839 
  ;
  
#line 839 
  if ((long)(*tmp != 0UL) != 0L) {
    
#line 840 
    __retres = 0;
    
#line 840 
    goto return_label;
  }
  else ;
  
#line 842 
  if ((long)((event->u64[0] & 4096ULL) != 0ULL) != 0L) {
    
#line 844 
    tx_ev_desc_ptr = (unsigned int)event->u64[0] & 4095U;
    
#line 845 
    tx_ev_q_label = (unsigned int)(event->u64[0] >> 32) & 31U;
    
#line 846 
    tx_queue = efx_channel_get_tx_queue(channel,tx_ev_q_label & 3U);
    
#line 848 
    tx_packets = (int)((tx_ev_desc_ptr - tx_queue->read_count) & tx_queue->ptr_mask);
    
#line 850 
    efx_xmit_done(tx_queue,tx_ev_desc_ptr);
  }
  else 
    
#line 851 
    if ((event->u64[0] & 32768ULL) != 0ULL) {
      
#line 853 
      tx_ev_q_label = (unsigned int)(event->u64[0] >> 32) & 31U;
      
#line 854 
      tx_queue = efx_channel_get_tx_queue(channel,tx_ev_q_label & 3U);
      
#line 857 
      netif_tx_lock(efx->net_dev);
      
#line 858 
      efx_farch_notify_tx_desc(tx_queue);
      
#line 859 
      netif_tx_unlock(efx->net_dev);
    }
    else 
      
#line 860 
      if ((event->u64[0] & 274877906944ULL) != 0ULL) 
#line 861 
                                                     efx_schedule_reset(efx,(enum reset_type)RESET_TYPE_DMA_ERROR);
      else 
        
#line 863 
        if ((efx->msg_enable & 128U) != 0U) 
#line 863 
                                            netdev_err((struct net_device const *)efx->net_dev,"channel %d unexpected TX event ",channel->channel,event->u32[1],event->u32[0]); else ;
  
#line 869 
  __retres = tx_packets;
  return_label: 
#line 869 
                return __retres;
}


#line 873  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static u16 efx_farch_handle_rx_not_ok(struct efx_rx_queue *rx_queue, efx_qword_t const *event)
{
  u16 __retres;
  bool rx_ev_buf_owner_id_err;
  bool rx_ev_ip_hdr_chksum_err;
  bool rx_ev_tcp_udp_chksum_err;
  bool rx_ev_eth_crc_err;
  bool rx_ev_frm_trunc;
  bool rx_ev_drib_nib;
  bool rx_ev_tobe_disc;
  bool rx_ev_other_err;
  bool rx_ev_pause_frm;
  bool rx_ev_hdr_type;
  bool rx_ev_mcast_pkt;
  unsigned int rx_ev_pkt_type;
  int tmp_1;
  int tmp_0;
  unsigned int tmp_2;
  
#line 876 
  struct efx_channel *channel = efx_rx_queue_channel(rx_queue);
  
#line 877 
  struct efx_nic *efx = rx_queue->efx;
  
#line 885 
  rx_ev_hdr_type = (_Bool)(((event->u64[0] >> 42) & 3ULL) != 0ULL);
  
#line 886 
  rx_ev_mcast_pkt = (_Bool)(((event->u64[0] >> 39) & 1ULL) != 0ULL);
  
#line 887 
  rx_ev_tobe_disc = (_Bool)(((event->u64[0] >> 47) & 1ULL) != 0ULL);
  
#line 888 
  rx_ev_pkt_type = (unsigned int)(event->u64[0] >> 44) & 7U;
  
#line 889 
  rx_ev_buf_owner_id_err = (_Bool)(((event->u64[0] >> 54) & 1ULL) != 0ULL);
  
#line 891 
  rx_ev_ip_hdr_chksum_err = (_Bool)(((event->u64[0] >> 52) & 1ULL) != 0ULL);
  
#line 893 
  rx_ev_tcp_udp_chksum_err = (_Bool)(((event->u64[0] >> 51) & 1ULL) != 0ULL);
  
#line 895 
  rx_ev_eth_crc_err = (_Bool)(((event->u64[0] >> 50) & 1ULL) != 0ULL);
  
#line 896 
  rx_ev_frm_trunc = (_Bool)(((event->u64[0] >> 49) & 1ULL) != 0ULL);
  
#line 898 
  tmp_0 = efx_nic_rev(efx);
  
#line 898 
  if (tmp_0 <= 1) 
#line 898 
                  tmp_1 = ((event->u64[0] >> 49) & 1ULL) != 0ULL; else 
                                                                    
#line 898 
                                                                    tmp_1 = 0;
  
#line 897 
  rx_ev_drib_nib = (_Bool)(tmp_1 != 0);
  
#line 899 
  rx_ev_pause_frm = (_Bool)(((event->u64[0] >> 55) & 1ULL) != 0ULL);
  
#line 902 
  rx_ev_other_err = (_Bool)(((((((int)rx_ev_drib_nib | (int)rx_ev_tcp_udp_chksum_err) | (int)rx_ev_buf_owner_id_err) | (int)rx_ev_eth_crc_err) | (int)rx_ev_frm_trunc) | (int)rx_ev_ip_hdr_chksum_err) != 0);
  
#line 908 
  if ((int)rx_ev_frm_trunc != 0) 
#line 909 
                                 channel->n_rx_frm_trunc += 1U;
  else 
    
#line 910 
    if ((int)rx_ev_tobe_disc != 0) 
#line 911 
                                   channel->n_rx_tobe_disc += 1U;
    else 
      
#line 912 
      if (efx->loopback_selftest == (void *)0) {
        
#line 913 
        if ((int)rx_ev_ip_hdr_chksum_err != 0) 
#line 914 
                                               channel->n_rx_ip_hdr_chksum_err += 1U;
        else 
          
#line 915 
          if ((int)rx_ev_tcp_udp_chksum_err != 0) 
#line 916 
                                                  channel->n_rx_tcp_udp_chksum_err += 1U; else ;
      }
      else ;
  
#line 945 
  if ((((((int)rx_ev_eth_crc_err | (int)rx_ev_frm_trunc) | (int)rx_ev_drib_nib) | (int)rx_ev_tobe_disc) | (int)rx_ev_pause_frm) != 0) 
    
#line 945 
    tmp_2 = 4U; else 
#line 945 
                     tmp_2 = 0U;
  
#line 945 
  __retres = (unsigned short)tmp_2;
  
#line 945 
  return __retres;
}


#line 953  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static bool efx_farch_handle_rx_bad_index(struct efx_rx_queue *rx_queue, unsigned int index)
{
  bool __retres;
  unsigned int expected;
  unsigned int dropped;
  int tmp_1;
  int tmp_0;
  
#line 955 
  struct efx_channel *channel = efx_rx_queue_channel(rx_queue);
  
#line 956 
  struct efx_nic *efx = rx_queue->efx;
  
#line 959 
  if (rx_queue->scatter_n != 0U && (((rx_queue->removed_count + rx_queue->scatter_n) + 4294967295U) & rx_queue->ptr_mask) == index) {
    
#line 962 
    channel->n_rx_nodesc_trunc += 1U;
    
#line 963 
    __retres = (_Bool)1;
    
#line 963 
    goto return_label;
  }
  else ;
  
#line 966 
  expected = rx_queue->removed_count & rx_queue->ptr_mask;
  
#line 967 
  dropped = (index - expected) & rx_queue->ptr_mask;
  
#line 968 
  if ((efx->msg_enable & 64U) != 0U) 
#line 968 
                                     netdev_info((struct net_device const *)efx->net_dev,"dropped %d events (index=%d expected=%d)\n",dropped,index,expected); else ;
  
#line 973 
  tmp_0 = efx_nic_rev(efx);
  
#line 973 
  if (tmp_0 <= 1) 
#line 973 
                  tmp_1 = 11; else 
#line 973 
                                   tmp_1 = 7;
  
#line 972 
  ;
  
#line 972 
  efx_schedule_reset(efx,(enum reset_type)tmp_1);
  
#line 974 
  __retres = (_Bool)0;
  return_label: 
#line 974 
                return __retres;
}


#line 985  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static void efx_farch_handle_rx_event(struct efx_channel *channel, efx_qword_t const *event)
{
  unsigned int rx_ev_desc_ptr;
  unsigned int rx_ev_byte_cnt;
  unsigned int rx_ev_hdr_type;
  unsigned int rx_ev_mcast_pkt;
  unsigned int expected_ptr;
  bool rx_ev_pkt_ok;
  bool rx_ev_sop;
  bool rx_ev_cont;
  u16 flags;
  struct efx_rx_queue *rx_queue;
  unsigned long volatile *tmp;
  
#line 993 
  struct efx_nic *efx = channel->efx;
  {
    
#line 995 
    unsigned long __var = 0UL;
    
#line 995 
    tmp = (unsigned long volatile *)(& efx->reset_pending);
  }
  
#line 995 
  ;
  
#line 995 
  if ((long)(*tmp != 0UL) != 0L) 
#line 996 
                                 goto return_label; else ;
  
#line 998 
  rx_ev_cont = (_Bool)(((event->u64[0] >> 31) & 1ULL) != 0ULL);
  
#line 999 
  rx_ev_sop = (_Bool)(((event->u64[0] >> 15) & 1ULL) != 0ULL);
  {
    
#line 1000 
    int __ret_warn_on = ((event->u64[0] >> 32) & 31ULL) != (unsigned long long)channel->channel;
    
#line 1000 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 1000 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c",1001); else ;
    
#line 1000 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 1003 
  rx_queue = efx_channel_get_rx_queue(channel);
  
#line 1005 
  rx_ev_desc_ptr = (unsigned int)event->u64[0] & 4095U;
  
#line 1006 
  expected_ptr = (rx_queue->removed_count + rx_queue->scatter_n) & rx_queue->ptr_mask;
  
#line 1010 
  if ((long)(rx_ev_desc_ptr != expected_ptr) != 0L || (long)((int)rx_ev_sop != (rx_queue->scatter_n == 0U)) != 0L) {
    
#line 1012 
    if (rx_ev_desc_ptr != expected_ptr) {
      int tmp_1;
      bool tmp_0;
      
#line 1013 
      tmp_0 = efx_farch_handle_rx_bad_index(rx_queue,rx_ev_desc_ptr);
      
#line 1013 
      if (tmp_0) 
#line 1013 
                 tmp_1 = 0; else 
#line 1013 
                                 tmp_1 = 1;
      
#line 1013 
      if (tmp_1) 
#line 1014 
                 goto return_label; else ;
    }
    else ;
    
#line 1017 
    if (rx_queue->scatter_n != 0U) {
      
#line 1018 
      efx_rx_packet(rx_queue,rx_queue->removed_count & rx_queue->ptr_mask,rx_queue->scatter_n,0U,(unsigned short)4);
      
#line 1022 
      rx_queue->removed_count += rx_queue->scatter_n;
      
#line 1023 
      rx_queue->scatter_n = 0U;
    }
    else ;
    
#line 1027 
    if (rx_ev_desc_ptr != expected_ptr) 
#line 1028 
                                        goto return_label; else ;
    
#line 1031 
    if (! rx_ev_sop) {
      
#line 1032 
      efx_rx_packet(rx_queue,rx_queue->removed_count & rx_queue->ptr_mask,1U,0U,(unsigned short)4);
      
#line 1036 
      rx_queue->removed_count += 1U;
      
#line 1037 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 1041 
  rx_queue->scatter_n += 1U;
  
#line 1042 
  if ((int)rx_ev_cont != 0) 
#line 1043 
                            goto return_label; else ;
  
#line 1045 
  rx_ev_byte_cnt = (unsigned int)(event->u64[0] >> 16) & 16383U;
  
#line 1046 
  rx_ev_pkt_ok = (_Bool)(((event->u64[0] >> 56) & 1ULL) != 0ULL);
  
#line 1047 
  rx_ev_hdr_type = (unsigned int)(event->u64[0] >> 42) & 3U;
  
#line 1049 
  if ((long)((int)rx_ev_pkt_ok != 0) != 0L) {
    
#line 1053 
    flags = (unsigned short)0U;
    
#line 1054 
    switch (rx_ev_hdr_type) {
      case (unsigned int)0: 
#line 1055 
      ;
      
#line 1056 
      flags = (unsigned short)((unsigned int)flags | 64U);
      case (unsigned int)1: 
#line 1058 
      ;
      
#line 1059 
      flags = (unsigned short)((unsigned int)flags | 2U);
      case (unsigned int)2: 
#line 1061 
      ;
      case (unsigned int)3: 
#line 1062 
      ;
      
#line 1063 
      goto ldv_57099;
    }
    ldv_57099: 
#line 1065 
    ;
  }
  else 
#line 1066 
       flags = efx_farch_handle_rx_not_ok(rx_queue,event);
  
#line 1070 
  rx_ev_mcast_pkt = (unsigned int)(event->u64[0] >> 39) & 1U;
  
#line 1071 
  if (rx_ev_mcast_pkt != 0U) {
    
#line 1072 
    unsigned int rx_ev_mcast_hash_match = (unsigned int)(event->u64[0] >> 40) & 1U;
    
#line 1075 
    if ((long)(rx_ev_mcast_hash_match == 0U) != 0L) {
      
#line 1076 
      channel->n_rx_mcast_mismatch += 1U;
      
#line 1077 
      flags = (unsigned short)((unsigned int)flags | 4U);
    }
    else ;
  }
  else ;
  
#line 1081 
  channel->irq_mod_score += 2U;
  
#line 1084 
  efx_rx_packet(rx_queue,rx_queue->removed_count & rx_queue->ptr_mask,rx_queue->scatter_n,rx_ev_byte_cnt,(unsigned short)((int)flags));
  
#line 1087 
  rx_queue->removed_count += rx_queue->scatter_n;
  
#line 1088 
  rx_queue->scatter_n = 0U;
  return_label: 
#line 1089 
                return;
}


#line 1096  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static void efx_farch_handle_tx_flush_done(struct efx_nic *efx, efx_qword_t *event)
{
  struct efx_tx_queue *tx_queue;
  int qid;
  
#line 1101 
  qid = (int)event->u64[0] & 16383;
  
#line 1102 
  if (efx->n_tx_channels * 4U > (unsigned int)qid) {
    int tmp;
    
#line 1103 
    tx_queue = efx_get_tx_queue(efx,(unsigned int)(qid / 4),(unsigned int)(qid % 4));
    
#line 1105 
    tmp = atomic_cmpxchg(& tx_queue->flush_outstanding,1,0);
    
#line 1105 
    if (tmp != 0) 
#line 1106 
                  efx_farch_magic_event(tx_queue->channel,tx_queue->queue | 66560U); else ;
  }
  else ;
  
#line 1109 
  return;
}


#line 1117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static void efx_farch_handle_rx_flush_done(struct efx_nic *efx, efx_qword_t *event)
{
  struct efx_channel *channel;
  struct efx_rx_queue *rx_queue;
  int qid;
  bool failed;
  int tmp_0;
  bool tmp;
  bool tmp_3;
  
#line 1124 
  qid = (int)event->u64[0] & 4095;
  
#line 1125 
  failed = (_Bool)(((event->u64[0] >> 12) & 1ULL) != 0ULL);
  
#line 1126 
  if (efx->n_channels <= (unsigned int)qid) 
#line 1127 
                                            goto return_label; else ;
  
#line 1128 
  channel = efx_get_channel(efx,(unsigned int)qid);
  
#line 1129 
  tmp = efx_channel_has_rx_queue(channel);
  
#line 1129 
  if (tmp) 
#line 1129 
           tmp_0 = 0; else 
#line 1129 
                           tmp_0 = 1;
  
#line 1129 
  if (tmp_0) 
#line 1130 
             goto return_label; else ;
  
#line 1131 
  rx_queue = efx_channel_get_rx_queue(channel);
  
#line 1133 
  if ((int)failed != 0) {
    
#line 1134 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 1134 
                                         netdev_info((struct net_device const *)efx->net_dev,"RXQ %d flush retry\n",qid); else ;
    
#line 1136 
    rx_queue->flush_pending = (_Bool)1;
    
#line 1137 
    atomic_inc(& efx->rxq_flush_pending);
  }
  else {
    int tmp_1;
    struct efx_channel *tmp_2;
    
#line 1140 
    tmp_1 = efx_rx_queue_index(rx_queue);
    
#line 1139 
    tmp_2 = efx_rx_queue_channel(rx_queue);
    
#line 1139 
    efx_farch_magic_event(tmp_2,(unsigned int)(tmp_1 | 66304));
  }
  
#line 1142 
  atomic_dec(& efx->rxq_flush_outstanding);
  
#line 1143 
  tmp_3 = efx_farch_flush_wake(efx);
  
#line 1143 
  if ((int)tmp_3 != 0) 
#line 1144 
                       __wake_up(& efx->flush_wq,3U,1,(void *)0); else ;
  return_label: 
#line 1145 
                return;
}


#line 1148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static void efx_farch_handle_drain_event(struct efx_channel *channel)
{
  bool tmp_0;
  
#line 1150 
  struct efx_nic *efx = channel->efx;
  {
    int tmp;
    
#line 1152 
    tmp = atomic_read((atomic_t const *)(& efx->active_queues));
    
#line 1152 
    int __ret_warn_on = tmp == 0;
    
#line 1152 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 1152 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c",1152); else ;
    
#line 1152 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 1153 
  atomic_dec(& efx->active_queues);
  
#line 1154 
  tmp_0 = efx_farch_flush_wake(efx);
  
#line 1154 
  if ((int)tmp_0 != 0) 
#line 1155 
                       __wake_up(& efx->flush_wq,3U,1,(void *)0); else ;
  
#line 1156 
  return;
}


#line 1158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static void efx_farch_handle_generated_event(struct efx_channel *channel, efx_qword_t *event)
{
  struct efx_rx_queue *tmp_1;
  bool tmp;
  unsigned int magic;
  unsigned int code;
  
#line 1161 
  struct efx_nic *efx = channel->efx;
  
#line 1162 
  tmp = efx_channel_has_rx_queue(channel);
  
#line 1162 
  if ((int)tmp != 0) 
#line 1163 
                     tmp_1 = efx_channel_get_rx_queue(channel); else 
                                                                  
#line 1162 
                                                                  tmp_1 = (struct efx_rx_queue *)0;
  
#line 1162 
  struct efx_rx_queue *rx_queue = tmp_1;
  
#line 1167 
  magic = (unsigned int)event->u64[0];
  
#line 1168 
  code = magic >> 8;
  
#line 1170 
  if ((unsigned int)(channel->channel | 65792) == magic) {
    int tmp_6;
    {
      int pscr_ret__;
      {
        
#line 1171 
        void const *__vpp_verify = (void const *)0;
        
#line 1171 
        void const *tmp_2 = __vpp_verify;
      }
      
#line 1171 
      switch (4UL) {
        int tmp_2_0;
        int tmp_3;
        int tmp_4;
        int tmp_5;
        case (unsigned long)1: 
#line 1171 
        ;
        {
          int pfo_ret__;
          
#line 1171 
          switch (4UL) {
            case (unsigned long)1: 
#line 1171 
            ;
            
#line 1172 
            ldv_inline_asm();
            
#line 1171 
            goto ldv_57134;
            case (unsigned long)2: 
#line 1171 
            ;
            
#line 1172 
            ldv_inline_asm();
            
#line 1171 
            goto ldv_57134;
            case (unsigned long)4: 
#line 1171 
            ;
            
#line 1172 
            ldv_inline_asm();
            
#line 1171 
            goto ldv_57134;
            case (unsigned long)8: 
#line 1171 
            ;
            
#line 1172 
            ldv_inline_asm();
            
#line 1171 
            goto ldv_57134;
            default: 
#line 1171 
            ;
            
#line 1171 
            __bad_percpu_size();
          }
          ldv_57134: 
#line 1171 
          ;
          
#line 1171 
          tmp_2_0 = pfo_ret__;
        }
        
#line 1171 
        pscr_ret__ = tmp_2_0;
        
#line 1171 
        goto ldv_57140;
        case (unsigned long)2: 
#line 1171 
        ;
        {
          int pfo_ret___0;
          
#line 1171 
          switch (4UL) {
            case (unsigned long)1: 
#line 1171 
            ;
            
#line 1172 
            ldv_inline_asm();
            
#line 1171 
            goto ldv_57144;
            case (unsigned long)2: 
#line 1171 
            ;
            
#line 1172 
            ldv_inline_asm();
            
#line 1171 
            goto ldv_57144;
            case (unsigned long)4: 
#line 1171 
            ;
            
#line 1172 
            ldv_inline_asm();
            
#line 1171 
            goto ldv_57144;
            case (unsigned long)8: 
#line 1171 
            ;
            
#line 1172 
            ldv_inline_asm();
            
#line 1171 
            goto ldv_57144;
            default: 
#line 1171 
            ;
            
#line 1171 
            __bad_percpu_size();
          }
          ldv_57144: 
#line 1171 
          ;
          
#line 1171 
          tmp_3 = pfo_ret___0;
        }
        
#line 1171 
        pscr_ret__ = tmp_3;
        
#line 1171 
        goto ldv_57140;
        case (unsigned long)4: 
#line 1171 
        ;
        {
          int pfo_ret___1;
          
#line 1171 
          switch (4UL) {
            case (unsigned long)1: 
#line 1171 
            ;
            
#line 1172 
            ldv_inline_asm();
            
#line 1171 
            goto ldv_57153;
            case (unsigned long)2: 
#line 1171 
            ;
            
#line 1172 
            ldv_inline_asm();
            
#line 1171 
            goto ldv_57153;
            case (unsigned long)4: 
#line 1171 
            ;
            
#line 1172 
            ldv_inline_asm();
            
#line 1171 
            goto ldv_57153;
            case (unsigned long)8: 
#line 1171 
            ;
            
#line 1172 
            ldv_inline_asm();
            
#line 1171 
            goto ldv_57153;
            default: 
#line 1171 
            ;
            
#line 1171 
            __bad_percpu_size();
          }
          ldv_57153: 
#line 1171 
          ;
          
#line 1171 
          tmp_4 = pfo_ret___1;
        }
        
#line 1171 
        pscr_ret__ = tmp_4;
        
#line 1171 
        goto ldv_57140;
        case (unsigned long)8: 
#line 1171 
        ;
        {
          int pfo_ret___2;
          
#line 1171 
          switch (4UL) {
            case (unsigned long)1: 
#line 1171 
            ;
            
#line 1172 
            ldv_inline_asm();
            
#line 1171 
            goto ldv_57162;
            case (unsigned long)2: 
#line 1171 
            ;
            
#line 1172 
            ldv_inline_asm();
            
#line 1171 
            goto ldv_57162;
            case (unsigned long)4: 
#line 1171 
            ;
            
#line 1172 
            ldv_inline_asm();
            
#line 1171 
            goto ldv_57162;
            case (unsigned long)8: 
#line 1171 
            ;
            
#line 1172 
            ldv_inline_asm();
            
#line 1171 
            goto ldv_57162;
            default: 
#line 1171 
            ;
            
#line 1171 
            __bad_percpu_size();
          }
          ldv_57162: 
#line 1171 
          ;
          
#line 1171 
          tmp_5 = pfo_ret___2;
        }
        
#line 1171 
        pscr_ret__ = tmp_5;
        
#line 1171 
        goto ldv_57140;
        default: 
#line 1171 
        ;
        
#line 1171 
        __bad_size_call_parameter();
        
#line 1171 
        goto ldv_57140;
      }
      ldv_57140: 
#line 1171 
      ;
      
#line 1171 
      tmp_6 = pscr_ret__;
    }
    
#line 1171 
    channel->event_test_cpu = tmp_6;
  }
  else 
    
#line 1172 
    if (rx_queue != (struct efx_rx_queue *)0) {
      int tmp_8;
      
#line 1172 
      tmp_8 = efx_rx_queue_index(rx_queue);
      
#line 1172 
      ;
      
#line 1172 
      if ((unsigned int)(tmp_8 | 66048) == magic) 
#line 1176 
                                                  efx_fast_push_rx_descriptors(rx_queue,(_Bool)1); else 
                                                                    
#line 1172 
                                                                    goto _LAND_0;
    }
    else {
      _LAND_0: 
#line 1177 
      ;
      
#line 1177 
      if (rx_queue != (struct efx_rx_queue *)0) {
        int tmp_7;
        
#line 1177 
        tmp_7 = efx_rx_queue_index(rx_queue);
        
#line 1177 
        ;
        
#line 1177 
        if ((unsigned int)(tmp_7 | 66304) == magic) 
#line 1178 
                                                    efx_farch_handle_drain_event(channel); else 
                                                                    
#line 1177 
                                                                    goto _LAND;
      }
      else {
        _LAND: 
#line 1179 
        ;
        
#line 1179 
        if (code == 260U) 
#line 1180 
                          efx_farch_handle_drain_event(channel);
        else 
          
#line 1182 
          if ((efx->msg_enable & 8192U) != 0U) {
            
#line 1182 
            struct _ddebug descriptor = {.modname = "sfc", .function = "efx_farch_handle_generated_event", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c", .format = "channel %d received ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1184U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
            
#line 1182 
            if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1182 
                                                                __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"channel %d received ",channel->channel,event->u32[1],event->u32[0]); else ;
          }
          else ;
      }
    }
  
#line 1184 
  return;
}


#line 1189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static void efx_farch_handle_driver_event(struct efx_channel *channel, efx_qword_t *event)
{
  unsigned int ev_sub_code;
  unsigned int ev_sub_data;
  
#line 1191 
  struct efx_nic *efx = channel->efx;
  
#line 1195 
  ev_sub_code = (unsigned int)(event->u64[0] >> 56) & 15U;
  
#line 1196 
  ev_sub_data = (unsigned int)event->u64[0] & 16383U;
  
#line 1198 
  switch (ev_sub_code) {
    int tmp_0;
    int tmp;
    case (unsigned int)0: 
#line 1199 
    ;
    
#line 1202 
    efx_farch_handle_tx_flush_done(efx,event);
    
#line 1204 
    efx_siena_sriov_tx_flush_done(efx,event);
    
#line 1206 
    goto ldv_57181;
    case (unsigned int)1: 
#line 1207 
    ;
    
#line 1210 
    efx_farch_handle_rx_flush_done(efx,event);
    
#line 1212 
    efx_siena_sriov_rx_flush_done(efx,event);
    
#line 1214 
    goto ldv_57181;
    case (unsigned int)2: 
#line 1215 
    ;
    
#line 1216 
    if ((efx->msg_enable & 8192U) != 0U) {
      
#line 1216 
      struct _ddebug descriptor = {.modname = "sfc", .function = "efx_farch_handle_driver_event", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c", .format = "channel %d EVQ %d initialised\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1218U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1216 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1216 
                                                          __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"channel %d EVQ %d initialised\n",channel->channel,ev_sub_data); else ;
    }
    else ;
    
#line 1219 
    goto ldv_57181;
    case (unsigned int)5: 
#line 1220 
    ;
    
#line 1223 
    goto ldv_57181;
    case (unsigned int)6: 
#line 1224 
    ;
    
#line 1228 
    goto ldv_57181;
    case (unsigned int)10: 
#line 1229 
    ;
    
#line 1233 
    goto ldv_57181;
    case (unsigned int)11: 
#line 1234 
    ;
    
#line 1235 
    if ((efx->msg_enable & 64U) != 0U) 
#line 1235 
                                       netdev_err((struct net_device const *)efx->net_dev,"channel %d seen DRIVER RX_RESET event. ",channel->channel); else ;
    
#line 1238 
    atomic_inc(& efx->rx_reset);
    
#line 1241 
    tmp = efx_nic_rev(efx);
    
#line 1241 
    if (tmp <= 1) 
#line 1241 
                  tmp_0 = 11; else 
#line 1241 
                                   tmp_0 = 7;
    
#line 1239 
    ;
    
#line 1239 
    efx_schedule_reset(efx,(enum reset_type)tmp_0);
    
#line 1243 
    goto ldv_57181;
    case (unsigned int)14: 
#line 1244 
    ;
    
#line 1245 
    if (ev_sub_data <= 127U) {
      
#line 1246 
      if ((efx->msg_enable & 64U) != 0U) 
#line 1246 
                                         netdev_err((struct net_device const *)efx->net_dev,"RX DMA Q %d reports descriptor fetch error.",ev_sub_data,ev_sub_data); else ;
      
#line 1250 
      efx_schedule_reset(efx,(enum reset_type)RESET_TYPE_DMA_ERROR);
    }
    else 
#line 1254 
         efx_siena_sriov_desc_fetch_err(efx,ev_sub_data);
    
#line 1256 
    goto ldv_57181;
    case (unsigned int)15: 
#line 1257 
    ;
    
#line 1258 
    if (ev_sub_data <= 127U) {
      
#line 1259 
      if ((efx->msg_enable & 128U) != 0U) 
#line 1259 
                                          netdev_err((struct net_device const *)efx->net_dev,"TX DMA Q %d reports descriptor fetch error.",ev_sub_data,ev_sub_data); else ;
      
#line 1263 
      efx_schedule_reset(efx,(enum reset_type)RESET_TYPE_DMA_ERROR);
    }
    else 
#line 1267 
         efx_siena_sriov_desc_fetch_err(efx,ev_sub_data);
    
#line 1269 
    goto ldv_57181;
    default: 
#line 1270 
    ;
    
#line 1275 
    goto ldv_57181;
  }
  ldv_57181: 
#line 1277 
  ;
  
#line 1278 
  return;
}


#line 1279  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
int efx_farch_ev_process(struct efx_channel *channel, int budget)
{
  int __retres;
  unsigned int read_ptr;
  efx_qword_t event;
  efx_qword_t *p_event;
  int ev_code;
  int tmp;
  
#line 1281 
  struct efx_nic *efx = channel->efx;
  
#line 1285 
  int tx_packets = 0;
  
#line 1286 
  int spent = 0;
  
#line 1288 
  if (budget <= 0) {
    
#line 1289 
    __retres = spent;
    
#line 1289 
    goto return_label;
  }
  else ;
  
#line 1291 
  read_ptr = channel->eventq_read_ptr;
  ldv_57221: 
#line 1292 
  ;
  
#line 1294 
  p_event = efx_event(channel,read_ptr);
  
#line 1295 
  event = *p_event;
  
#line 1297 
  tmp = efx_event_present(& event);
  
#line 1297 
  if (tmp == 0) 
#line 1299 
                goto ldv_57209; else ;
  
#line 1306 
  p_event->u64[0] = 18446744073709551615ULL;
  
#line 1308 
  read_ptr += 1U;
  
#line 1310 
  ev_code = (int)(event.u64[0] >> 60);
  
#line 1312 
  switch (ev_code) {
    int tmp_0;
    case 0: 
#line 1313 
    ;
    
#line 1314 
    efx_farch_handle_rx_event(channel,(efx_qword_t const *)(& event));
    
#line 1315 
    spent += 1;
    
#line 1315 
    ;
    
#line 1315 
    if (spent == budget) 
#line 1316 
                         goto out; else ;
    
#line 1317 
    goto ldv_57213;
    case 2: 
#line 1318 
    ;
    
#line 1319 
    tmp_0 = efx_farch_handle_tx_event(channel,& event);
    
#line 1320 
    tx_packets = tmp_0 + tx_packets;
    
#line 1321 
    if (efx->txq_entries < (unsigned int)tx_packets) {
      
#line 1322 
      spent = budget;
      
#line 1323 
      goto out;
    }
    else ;
    
#line 1325 
    goto ldv_57213;
    case 7: 
#line 1326 
    ;
    
#line 1327 
    efx_farch_handle_generated_event(channel,& event);
    
#line 1328 
    goto ldv_57213;
    case 5: 
#line 1329 
    ;
    
#line 1330 
    efx_farch_handle_driver_event(channel,& event);
    
#line 1331 
    goto ldv_57213;
    case 8: 
#line 1333 
    ;
    
#line 1334 
    efx_siena_sriov_event(channel,& event);
    
#line 1335 
    goto ldv_57213;
    case 12: 
#line 1337 
    ;
    
#line 1338 
    efx_mcdi_process_event(channel,& event);
    
#line 1339 
    goto ldv_57213;
    case 6: 
#line 1340 
    ;
    
#line 1341 
    if ((efx->type)->handle_global_event != (bool (*)(struct efx_channel *, efx_qword_t *))0) {
      bool tmp_1;
      
#line 1341 
      tmp_1 = (*((efx->type)->handle_global_event))(channel,& event);
      
#line 1341 
      if ((int)tmp_1 != 0) 
#line 1343 
                           goto ldv_57213; else ;
    }
    else ;
    default: 
#line 1345 
    ;
    
#line 1346 
    if (((channel->efx)->msg_enable & 8192U) != 0U) 
#line 1346 
                                                    netdev_err((struct net_device const *)(channel->efx)->net_dev,"channel %d unknown event type %d (data ",channel->channel,ev_code,event.u32[1],event.u32[0]); else ;
  }
  ldv_57213: 
#line 1351 
  ;
  
#line 1294 
  goto ldv_57221;
  ldv_57209: 
#line 1295 
  ;
  out: 
#line 1353 
  ;
  
#line 1354 
  channel->eventq_read_ptr = read_ptr;
  
#line 1355 
  __retres = spent;
  return_label: 
#line 1355 
                return __retres;
}


#line 1359  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
int efx_farch_ev_probe(struct efx_channel *channel)
{
  unsigned int entries;
  int tmp;
  
#line 1361 
  struct efx_nic *efx = channel->efx;
  
#line 1364 
  entries = channel->eventq_mask + 1U;
  
#line 1365 
  tmp = efx_alloc_special_buffer(efx,& channel->eventq,entries * 8U);
  
#line 1365 
  return tmp;
}


#line 1369  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
int efx_farch_ev_init(struct efx_channel *channel)
{
  int __retres;
  efx_oword_t reg;
  int tmp;
  unsigned long tmp_0;
  
#line 1372 
  struct efx_nic *efx = channel->efx;
  
#line 1374 
  if ((efx->msg_enable & 8192U) != 0U) {
    
#line 1374 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_farch_ev_init", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c", .format = "channel %d event queue in special buffers %d-%d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1377U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1374 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1374 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"channel %d event queue in special buffers %d-%d\n",channel->channel,channel->eventq.index,(channel->eventq.index + channel->eventq.entries) + 4294967295U); else ;
  }
  else ;
  
#line 1379 
  tmp = efx_nic_rev(efx);
  
#line 1379 
  if (tmp > 2) {
    
#line 1380 
    reg.u64[0] = 8589934592ULL;
    
#line 1380 
    reg.u64[1] = 0ULL;
    
#line 1384 
    efx_writeo_table(efx,(efx_oword_t const *)(& reg),16187392U,(unsigned int)channel->channel);
  }
  else ;
  
#line 1388 
  efx_init_special_buffer(efx,& channel->eventq);
  
#line 1391 
  memset(channel->eventq.buf.addr,255,(unsigned long)channel->eventq.buf.len);
  
#line 1394 
  tmp_0 = __ffs((unsigned long)channel->eventq.entries);
  
#line 1394 
  reg.u64[0] = (((unsigned long long)tmp_0 << 20) | (unsigned long long)channel->eventq.index) | 8388608ULL;
  
#line 1394 
  reg.u64[1] = 0ULL;
  
#line 1398 
  efx_writeo_table(efx,(efx_oword_t const *)(& reg),(efx->type)->evq_ptr_tbl_base,(unsigned int)channel->channel);
  
#line 1401 
  __retres = 0;
  
#line 1401 
  return __retres;
}


#line 1404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
void efx_farch_ev_fini(struct efx_channel *channel)
{
  efx_oword_t reg;
  int tmp;
  
#line 1407 
  struct efx_nic *efx = channel->efx;
  
#line 1410 
  reg.u64[0] = 0ULL;
  
#line 1410 
  reg.u64[1] = 0ULL;
  
#line 1411 
  efx_writeo_table(efx,(efx_oword_t const *)(& reg),(efx->type)->evq_ptr_tbl_base,(unsigned int)channel->channel);
  
#line 1413 
  tmp = efx_nic_rev(efx);
  
#line 1413 
  if (tmp > 2) 
#line 1414 
               efx_writeo_table(efx,(efx_oword_t const *)(& reg),16187392U,(unsigned int)channel->channel); else ;
  
#line 1417 
  efx_fini_special_buffer(efx,& channel->eventq);
  
#line 1418 
  return;
}


#line 1421  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
void efx_farch_ev_remove(struct efx_channel *channel)
{
  
#line 1423 
  efx_free_special_buffer(channel->efx,& channel->eventq);
  
#line 1424 
  return;
}


#line 1427  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
void efx_farch_ev_test_generate(struct efx_channel *channel)
{
  
#line 1429 
  efx_farch_magic_event(channel,(unsigned int)(channel->channel | 65792));
  
#line 1430 
  return;
}


#line 1432  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
void efx_farch_rx_defer_refill(struct efx_rx_queue *rx_queue)
{
  int tmp;
  struct efx_channel *tmp_0;
  
#line 1435 
  tmp = efx_rx_queue_index(rx_queue);
  
#line 1434 
  tmp_0 = efx_rx_queue_channel(rx_queue);
  
#line 1434 
  efx_farch_magic_event(tmp_0,(unsigned int)(tmp | 66048));
  
#line 1436 
  return;
}


#line 1447  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
__inline static void efx_farch_interrupts(struct efx_nic *efx, bool enabled, bool force)
{
  efx_oword_t int_en_reg_ker;
  
#line 1452 
  int_en_reg_ker.u64[0] = (((unsigned long long)efx->irq_level << 8) | ((unsigned long long)force << 3)) | (unsigned long long)enabled;
  
#line 1452 
  int_en_reg_ker.u64[1] = 0ULL;
  
#line 1456 
  efx_writeo(efx,(efx_oword_t const *)(& int_en_reg_ker),16U);
  
#line 1457 
  return;
}


#line 1459  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
void efx_farch_irq_enable_master(struct efx_nic *efx)
{
  
#line 1461 
  ((efx_oword_t *)efx->irq_status.addr)->u64[0] = 0ULL;
  
#line 1461 
  ((efx_oword_t *)efx->irq_status.addr)->u64[1] = 0ULL;
  
#line 1462 
  ldv_inline_asm();
  
#line 1464 
  efx_farch_interrupts(efx,(_Bool)1,(_Bool)0);
  
#line 1465 
  return;
}


#line 1467  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
void efx_farch_irq_disable_master(struct efx_nic *efx)
{
  
#line 1470 
  efx_farch_interrupts(efx,(_Bool)0,(_Bool)0);
  
#line 1471 
  return;
}


#line 1477  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
void efx_farch_irq_test_generate(struct efx_nic *efx)
{
  
#line 1479 
  efx_farch_interrupts(efx,(_Bool)1,(_Bool)1);
  
#line 1480 
  return;
}


#line 1485  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
irqreturn_t efx_farch_fatal_interrupt(struct efx_nic *efx)
{
  irqreturn_t __retres;
  efx_oword_t fatal_intr;
  int error;
  int mem_perr;
  bool tmp_0;
  
#line 1487 
  struct falcon_nic_data *nic_data = (struct falcon_nic_data *)efx->nic_data;
  
#line 1488 
  efx_oword_t *int_ker = (efx_oword_t *)efx->irq_status.addr;
  
#line 1492 
  efx_reado(efx,& fatal_intr,560U);
  
#line 1493 
  error = (int)fatal_intr.u64[0] & 4095;
  
#line 1495 
  if ((efx->msg_enable & 8192U) != 0U) {
    char *tmp;
    
#line 1495 
    if (error != 0) 
#line 1495 
                    tmp = (char *)"disabling bus mastering"; else 
#line 1495 
                                                                  tmp = (char *)"no recognised error";
    
#line 1495 
    ;
    
#line 1495 
    ;
    
#line 1495 
    ;
    
#line 1495 
    ;
    
#line 1495 
    ;
    
#line 1495 
    ;
    
#line 1495 
    ;
    
#line 1495 
    ;
    
#line 1495 
    ;
    
#line 1495 
    netdev_err((struct net_device const *)efx->net_dev,"SYSTEM ERROR ",int_ker->u32[3],int_ker->u32[2],int_ker->u32[1],int_ker->u32[0],fatal_intr.u32[3],fatal_intr.u32[2],fatal_intr.u32[1],fatal_intr.u32[0],tmp);
  }
  else ;
  
#line 1501 
  mem_perr = ((fatal_intr.u64[0] & 256ULL) != 0ULL || (fatal_intr.u64[0] & 1ULL) != 0ULL) != 0;
  
#line 1503 
  if (mem_perr != 0) {
    efx_oword_t reg;
    
#line 1505 
    efx_reado(efx,& reg,608U);
    
#line 1506 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 1506 
                                         netdev_err((struct net_device const *)efx->net_dev,"SYSTEM ERROR: memory parity error ",reg.u32[3],reg.u32[2],reg.u32[1],reg.u32[0]); else ;
  }
  else ;
  
#line 1512 
  pci_clear_master(efx->pci_dev);
  
#line 1513 
  tmp_0 = efx_nic_is_dual_func(efx);
  
#line 1513 
  if ((int)tmp_0 != 0) 
#line 1514 
                       pci_clear_master(nic_data->pci_dev2); else ;
  
#line 1515 
  efx_farch_irq_disable_master(efx);
  
#line 1518 
  if (efx->int_error_count == 0U) 
#line 1518 
                                  goto _LOR;
  else {
    int tmp_1;
    {
      unsigned long __dummy;
      unsigned long volatile __dummy2;
      
#line 1519 
      tmp_1 = 1;
    }
    
#line 1518 
    if (tmp_1 != 0) {
      int tmp_2;
      {
        unsigned long __dummy_0;
        unsigned long __dummy2_0;
        
#line 1519 
        tmp_2 = 1;
      }
      
#line 1519 
      if (tmp_2 != 0) {
        
#line 1519 
        if ((long)(efx->int_error_expire - jiffies) < 0L) {
          _LOR: {
                  
#line 1520 
                  efx->int_error_count = 0U;
                  
#line 1521 
                  efx->int_error_expire = jiffies + 900000UL;
                }
        }
        else ;
      }
      else ;
    }
    else ;
  }
  
#line 1524 
  efx->int_error_count += 1U;
  
#line 1524 
  if (efx->int_error_count <= 4U) {
    
#line 1525 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 1525 
                                         netdev_err((struct net_device const *)efx->net_dev,"SYSTEM ERROR - reset scheduled\n"); else ;
    
#line 1527 
    efx_schedule_reset(efx,(enum reset_type)RESET_TYPE_INT_ERROR);
  }
  else {
    
#line 1529 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 1529 
                                         netdev_err((struct net_device const *)efx->net_dev,"SYSTEM ERROR - max number of errors seen."); else ;
    
#line 1532 
    efx_schedule_reset(efx,(enum reset_type)RESET_TYPE_DISABLE);
  }
  
#line 1535 
  __retres = IRQ_HANDLED;
  
#line 1535 
  return __retres;
}


#line 1541  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
irqreturn_t efx_farch_legacy_interrupt(int irq, void *dev_id)
{
  irqreturn_t __retres;
  bool volatile *tmp;
  struct efx_channel *channel;
  efx_dword_t reg;
  u32 queues;
  int syserr;
  
#line 1543 
  struct efx_nic *efx = (struct efx_nic *)dev_id;
  {
    
#line 1544 
    bool __var = (_Bool)0;
    
#line 1544 
    tmp = (bool volatile *)(& efx->irq_soft_enabled);
  }
  
#line 1544 
  bool soft_enabled = *tmp;
  
#line 1545 
  efx_oword_t *int_ker = (efx_oword_t *)efx->irq_status.addr;
  
#line 1546 
  irqreturn_t result = IRQ_NONE;
  
#line 1553 
  efx_readd(efx,& reg,144U);
  
#line 1554 
  queues = reg.u32[0];
  
#line 1560 
  if (reg.u32[0] == 4294967295U) {
    int tmp_0;
    
#line 1560 
    tmp_0 = efx_try_recovery(efx);
    
#line 1560 
    if (tmp_0 != 0) {
      
#line 1561 
      if (! efx->eeh_disabled_legacy_irq) {
        
#line 1562 
        disable_irq_nosync((unsigned int)efx->legacy_irq);
        
#line 1563 
        efx->eeh_disabled_legacy_irq = (_Bool)1;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 1567 
  if (((1U << efx->irq_level) & queues) != 0U && (int)soft_enabled != 0) {
    int tmp_6;
    
#line 1568 
    syserr = (int)int_ker->u64[1] & 1;
    
#line 1569 
    if ((long)(syserr != 0) != 0L) {
      irqreturn_t tmp_1;
      
#line 1570 
      tmp_1 = efx_farch_fatal_interrupt(efx);
      
#line 1570 
      __retres = tmp_1;
      
#line 1570 
      goto return_label;
    }
    else ;
    {
      int pscr_ret__;
      {
        
#line 1571 
        void const *__vpp_verify = (void const *)0;
        
#line 1571 
        void const *tmp_2 = __vpp_verify;
      }
      
#line 1571 
      switch (4UL) {
        int tmp_2_0;
        int tmp_3;
        int tmp_4;
        int tmp_5;
        case (unsigned long)1: 
#line 1571 
        ;
        {
          int pfo_ret__;
          
#line 1571 
          switch (4UL) {
            case (unsigned long)1: 
#line 1571 
            ;
            
#line 1572 
            ldv_inline_asm();
            
#line 1571 
            goto ldv_57297;
            case (unsigned long)2: 
#line 1571 
            ;
            
#line 1572 
            ldv_inline_asm();
            
#line 1571 
            goto ldv_57297;
            case (unsigned long)4: 
#line 1571 
            ;
            
#line 1572 
            ldv_inline_asm();
            
#line 1571 
            goto ldv_57297;
            case (unsigned long)8: 
#line 1571 
            ;
            
#line 1572 
            ldv_inline_asm();
            
#line 1571 
            goto ldv_57297;
            default: 
#line 1571 
            ;
            
#line 1571 
            __bad_percpu_size();
          }
          ldv_57297: 
#line 1571 
          ;
          
#line 1571 
          tmp_2_0 = pfo_ret__;
        }
        
#line 1571 
        pscr_ret__ = tmp_2_0;
        
#line 1571 
        goto ldv_57303;
        case (unsigned long)2: 
#line 1571 
        ;
        {
          int pfo_ret___0;
          
#line 1571 
          switch (4UL) {
            case (unsigned long)1: 
#line 1571 
            ;
            
#line 1572 
            ldv_inline_asm();
            
#line 1571 
            goto ldv_57307;
            case (unsigned long)2: 
#line 1571 
            ;
            
#line 1572 
            ldv_inline_asm();
            
#line 1571 
            goto ldv_57307;
            case (unsigned long)4: 
#line 1571 
            ;
            
#line 1572 
            ldv_inline_asm();
            
#line 1571 
            goto ldv_57307;
            case (unsigned long)8: 
#line 1571 
            ;
            
#line 1572 
            ldv_inline_asm();
            
#line 1571 
            goto ldv_57307;
            default: 
#line 1571 
            ;
            
#line 1571 
            __bad_percpu_size();
          }
          ldv_57307: 
#line 1571 
          ;
          
#line 1571 
          tmp_3 = pfo_ret___0;
        }
        
#line 1571 
        pscr_ret__ = tmp_3;
        
#line 1571 
        goto ldv_57303;
        case (unsigned long)4: 
#line 1571 
        ;
        {
          int pfo_ret___1;
          
#line 1571 
          switch (4UL) {
            case (unsigned long)1: 
#line 1571 
            ;
            
#line 1572 
            ldv_inline_asm();
            
#line 1571 
            goto ldv_57316;
            case (unsigned long)2: 
#line 1571 
            ;
            
#line 1572 
            ldv_inline_asm();
            
#line 1571 
            goto ldv_57316;
            case (unsigned long)4: 
#line 1571 
            ;
            
#line 1572 
            ldv_inline_asm();
            
#line 1571 
            goto ldv_57316;
            case (unsigned long)8: 
#line 1571 
            ;
            
#line 1572 
            ldv_inline_asm();
            
#line 1571 
            goto ldv_57316;
            default: 
#line 1571 
            ;
            
#line 1571 
            __bad_percpu_size();
          }
          ldv_57316: 
#line 1571 
          ;
          
#line 1571 
          tmp_4 = pfo_ret___1;
        }
        
#line 1571 
        pscr_ret__ = tmp_4;
        
#line 1571 
        goto ldv_57303;
        case (unsigned long)8: 
#line 1571 
        ;
        {
          int pfo_ret___2;
          
#line 1571 
          switch (4UL) {
            case (unsigned long)1: 
#line 1571 
            ;
            
#line 1572 
            ldv_inline_asm();
            
#line 1571 
            goto ldv_57325;
            case (unsigned long)2: 
#line 1571 
            ;
            
#line 1572 
            ldv_inline_asm();
            
#line 1571 
            goto ldv_57325;
            case (unsigned long)4: 
#line 1571 
            ;
            
#line 1572 
            ldv_inline_asm();
            
#line 1571 
            goto ldv_57325;
            case (unsigned long)8: 
#line 1571 
            ;
            
#line 1572 
            ldv_inline_asm();
            
#line 1571 
            goto ldv_57325;
            default: 
#line 1571 
            ;
            
#line 1571 
            __bad_percpu_size();
          }
          ldv_57325: 
#line 1571 
          ;
          
#line 1571 
          tmp_5 = pfo_ret___2;
        }
        
#line 1571 
        pscr_ret__ = tmp_5;
        
#line 1571 
        goto ldv_57303;
        default: 
#line 1571 
        ;
        
#line 1571 
        __bad_size_call_parameter();
        
#line 1571 
        goto ldv_57303;
      }
      ldv_57303: 
#line 1571 
      ;
      
#line 1571 
      tmp_6 = pscr_ret__;
    }
    
#line 1571 
    efx->last_irq_cpu = tmp_6;
  }
  else ;
  
#line 1574 
  if (queues != 0U) {
    
#line 1575 
    efx->irq_zero_count = 0U;
    
#line 1578 
    if ((long)((int)soft_enabled != 0) != 0L) {
      
#line 1579 
      channel = efx->channel[0];
      
#line 1579 
      goto ldv_57334;
      ldv_57333: 
#line 1580 
      ;
      
#line 1580 
      if ((queues & 1U) != 0U) 
#line 1581 
                               efx_schedule_channel_irq(channel); else ;
      
#line 1582 
      queues >>= 1;
      
#line 1579 
      if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 1579 
                                                                  channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 1579 
                                                                    channel = (struct efx_channel *)0;
      ldv_57334: 
#line 1580 
      ;
      
#line 1579 
      if (channel != (struct efx_channel *)0) 
#line 1581 
                                              goto ldv_57333; else 
#line 1584 
                                                                   goto ldv_57335;
      ldv_57335: 
#line 1585 
      ;
    }
    else ;
    
#line 1585 
    result = IRQ_HANDLED;
  }
  else {
    efx_qword_t *event;
    unsigned int tmp_7;
    
#line 1594 
    tmp_7 = efx->irq_zero_count;
    
#line 1594 
    efx->irq_zero_count += 1U;
    
#line 1594 
    ;
    
#line 1594 
    if (tmp_7 == 0U) 
#line 1595 
                     result = IRQ_HANDLED; else ;
    
#line 1598 
    if ((long)((int)soft_enabled != 0) != 0L) {
      int tmp_8;
      
#line 1599 
      channel = efx->channel[0];
      
#line 1599 
      goto ldv_57338;
      ldv_57337: 
#line 1600 
      ;
      
#line 1600 
      event = efx_event(channel,channel->eventq_read_ptr);
      
#line 1602 
      tmp_8 = efx_event_present(event);
      
#line 1602 
      if (tmp_8 != 0) 
#line 1603 
                      efx_schedule_channel_irq(channel); else 
#line 1605 
                                                              efx_farch_ev_read_ack(channel);
      
#line 1599 
      if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 1599 
                                                                  channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 1599 
                                                                    channel = (struct efx_channel *)0;
      ldv_57338: 
#line 1600 
      ;
      
#line 1599 
      if (channel != (struct efx_channel *)0) 
#line 1601 
                                              goto ldv_57337; else 
#line 1604 
                                                                   goto ldv_57339;
      ldv_57339: 
#line 1605 
      ;
    }
    else ;
  }
  
#line 1610 
  if (result == (unsigned int)IRQ_HANDLED) {
    
#line 1611 
    if (0) {
      
#line 1611 
      if ((efx->msg_enable & 512U) != 0U) {
        int tmp_13;
        
#line 1611 
        ;
        {
          int pscr_ret___0;
          {
            
#line 1611 
            void const *__vpp_verify_0 = (void const *)0;
            
#line 1611 
            void const *tmp_9 = __vpp_verify_0;
          }
          
#line 1611 
          switch (4UL) {
            int tmp_9_0;
            int tmp_10;
            int tmp_11;
            int tmp_12;
            case (unsigned long)1: 
#line 1611 
            ;
            {
              int pfo_ret___3;
              
#line 1611 
              switch (4UL) {
                case (unsigned long)1: 
#line 1611 
                ;
                
#line 1612 
                ldv_inline_asm();
                
#line 1611 
                goto ldv_57345;
                case (unsigned long)2: 
#line 1611 
                ;
                
#line 1612 
                ldv_inline_asm();
                
#line 1611 
                goto ldv_57345;
                case (unsigned long)4: 
#line 1611 
                ;
                
#line 1612 
                ldv_inline_asm();
                
#line 1611 
                goto ldv_57345;
                case (unsigned long)8: 
#line 1611 
                ;
                
#line 1612 
                ldv_inline_asm();
                
#line 1611 
                goto ldv_57345;
                default: 
#line 1611 
                ;
                
#line 1611 
                __bad_percpu_size();
              }
              ldv_57345: 
#line 1611 
              ;
              
#line 1611 
              tmp_9_0 = pfo_ret___3;
            }
            
#line 1611 
            pscr_ret___0 = tmp_9_0;
            
#line 1611 
            goto ldv_57351;
            case (unsigned long)2: 
#line 1611 
            ;
            {
              int pfo_ret___4;
              
#line 1611 
              switch (4UL) {
                case (unsigned long)1: 
#line 1611 
                ;
                
#line 1612 
                ldv_inline_asm();
                
#line 1611 
                goto ldv_57355;
                case (unsigned long)2: 
#line 1611 
                ;
                
#line 1612 
                ldv_inline_asm();
                
#line 1611 
                goto ldv_57355;
                case (unsigned long)4: 
#line 1611 
                ;
                
#line 1612 
                ldv_inline_asm();
                
#line 1611 
                goto ldv_57355;
                case (unsigned long)8: 
#line 1611 
                ;
                
#line 1612 
                ldv_inline_asm();
                
#line 1611 
                goto ldv_57355;
                default: 
#line 1611 
                ;
                
#line 1611 
                __bad_percpu_size();
              }
              ldv_57355: 
#line 1611 
              ;
              
#line 1611 
              tmp_10 = pfo_ret___4;
            }
            
#line 1611 
            pscr_ret___0 = tmp_10;
            
#line 1611 
            goto ldv_57351;
            case (unsigned long)4: 
#line 1611 
            ;
            {
              int pfo_ret___5;
              
#line 1611 
              switch (4UL) {
                case (unsigned long)1: 
#line 1611 
                ;
                
#line 1612 
                ldv_inline_asm();
                
#line 1611 
                goto ldv_57364;
                case (unsigned long)2: 
#line 1611 
                ;
                
#line 1612 
                ldv_inline_asm();
                
#line 1611 
                goto ldv_57364;
                case (unsigned long)4: 
#line 1611 
                ;
                
#line 1612 
                ldv_inline_asm();
                
#line 1611 
                goto ldv_57364;
                case (unsigned long)8: 
#line 1611 
                ;
                
#line 1612 
                ldv_inline_asm();
                
#line 1611 
                goto ldv_57364;
                default: 
#line 1611 
                ;
                
#line 1611 
                __bad_percpu_size();
              }
              ldv_57364: 
#line 1611 
              ;
              
#line 1611 
              tmp_11 = pfo_ret___5;
            }
            
#line 1611 
            pscr_ret___0 = tmp_11;
            
#line 1611 
            goto ldv_57351;
            case (unsigned long)8: 
#line 1611 
            ;
            {
              int pfo_ret___6;
              
#line 1611 
              switch (4UL) {
                case (unsigned long)1: 
#line 1611 
                ;
                
#line 1612 
                ldv_inline_asm();
                
#line 1611 
                goto ldv_57373;
                case (unsigned long)2: 
#line 1611 
                ;
                
#line 1612 
                ldv_inline_asm();
                
#line 1611 
                goto ldv_57373;
                case (unsigned long)4: 
#line 1611 
                ;
                
#line 1612 
                ldv_inline_asm();
                
#line 1611 
                goto ldv_57373;
                case (unsigned long)8: 
#line 1611 
                ;
                
#line 1612 
                ldv_inline_asm();
                
#line 1611 
                goto ldv_57373;
                default: 
#line 1611 
                ;
                
#line 1611 
                __bad_percpu_size();
              }
              ldv_57373: 
#line 1611 
              ;
              
#line 1611 
              tmp_12 = pfo_ret___6;
            }
            
#line 1611 
            pscr_ret___0 = tmp_12;
            
#line 1611 
            goto ldv_57351;
            default: 
#line 1611 
            ;
            
#line 1611 
            __bad_size_call_parameter();
            
#line 1611 
            goto ldv_57351;
          }
          ldv_57351: 
#line 1611 
          ;
          
#line 1611 
          tmp_13 = pscr_ret___0;
        }
        
#line 1611 
        ;
        
#line 1611 
        ;
        
#line 1611 
        netdev_printk("\001",(struct net_device const *)efx->net_dev,"IRQ %d on CPU %d status ",irq,tmp_13,reg.u32[0]);
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 1615 
  __retres = result;
  return_label: 
#line 1615 
                return __retres;
}


#line 1625  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
irqreturn_t efx_farch_msi_interrupt(int irq, void *dev_id)
{
  irqreturn_t __retres;
  int syserr;
  bool volatile *tmp_4;
  
#line 1627 
  struct efx_msi_context *context = (struct efx_msi_context *)dev_id;
  
#line 1628 
  struct efx_nic *efx = context->efx;
  
#line 1629 
  efx_oword_t *int_ker = (efx_oword_t *)efx->irq_status.addr;
  
#line 1632 
  if (0) {
    
#line 1632 
    if ((efx->msg_enable & 512U) != 0U) {
      int tmp_3;
      
#line 1632 
      ;
      
#line 1632 
      ;
      
#line 1632 
      ;
      
#line 1632 
      ;
      {
        int pscr_ret__;
        {
          
#line 1632 
          void const *__vpp_verify = (void const *)0;
          
#line 1632 
          void const *tmp = __vpp_verify;
        }
        
#line 1632 
        switch (4UL) {
          int tmp_0;
          int tmp_0_0;
          int tmp_1;
          int tmp_2;
          case (unsigned long)1: 
#line 1632 
          ;
          {
            int pfo_ret__;
            
#line 1632 
            switch (4UL) {
              case (unsigned long)1: 
#line 1632 
              ;
              
#line 1633 
              ldv_inline_asm();
              
#line 1632 
              goto ldv_57395;
              case (unsigned long)2: 
#line 1632 
              ;
              
#line 1633 
              ldv_inline_asm();
              
#line 1632 
              goto ldv_57395;
              case (unsigned long)4: 
#line 1632 
              ;
              
#line 1633 
              ldv_inline_asm();
              
#line 1632 
              goto ldv_57395;
              case (unsigned long)8: 
#line 1632 
              ;
              
#line 1633 
              ldv_inline_asm();
              
#line 1632 
              goto ldv_57395;
              default: 
#line 1632 
              ;
              
#line 1632 
              __bad_percpu_size();
            }
            ldv_57395: 
#line 1632 
            ;
            
#line 1632 
            tmp_0 = pfo_ret__;
          }
          
#line 1632 
          pscr_ret__ = tmp_0;
          
#line 1632 
          goto ldv_57401;
          case (unsigned long)2: 
#line 1632 
          ;
          {
            int pfo_ret___0;
            
#line 1632 
            switch (4UL) {
              case (unsigned long)1: 
#line 1632 
              ;
              
#line 1633 
              ldv_inline_asm();
              
#line 1632 
              goto ldv_57405;
              case (unsigned long)2: 
#line 1632 
              ;
              
#line 1633 
              ldv_inline_asm();
              
#line 1632 
              goto ldv_57405;
              case (unsigned long)4: 
#line 1632 
              ;
              
#line 1633 
              ldv_inline_asm();
              
#line 1632 
              goto ldv_57405;
              case (unsigned long)8: 
#line 1632 
              ;
              
#line 1633 
              ldv_inline_asm();
              
#line 1632 
              goto ldv_57405;
              default: 
#line 1632 
              ;
              
#line 1632 
              __bad_percpu_size();
            }
            ldv_57405: 
#line 1632 
            ;
            
#line 1632 
            tmp_0_0 = pfo_ret___0;
          }
          
#line 1632 
          pscr_ret__ = tmp_0_0;
          
#line 1632 
          goto ldv_57401;
          case (unsigned long)4: 
#line 1632 
          ;
          {
            int pfo_ret___1;
            
#line 1632 
            switch (4UL) {
              case (unsigned long)1: 
#line 1632 
              ;
              
#line 1633 
              ldv_inline_asm();
              
#line 1632 
              goto ldv_57414;
              case (unsigned long)2: 
#line 1632 
              ;
              
#line 1633 
              ldv_inline_asm();
              
#line 1632 
              goto ldv_57414;
              case (unsigned long)4: 
#line 1632 
              ;
              
#line 1633 
              ldv_inline_asm();
              
#line 1632 
              goto ldv_57414;
              case (unsigned long)8: 
#line 1632 
              ;
              
#line 1633 
              ldv_inline_asm();
              
#line 1632 
              goto ldv_57414;
              default: 
#line 1632 
              ;
              
#line 1632 
              __bad_percpu_size();
            }
            ldv_57414: 
#line 1632 
            ;
            
#line 1632 
            tmp_1 = pfo_ret___1;
          }
          
#line 1632 
          pscr_ret__ = tmp_1;
          
#line 1632 
          goto ldv_57401;
          case (unsigned long)8: 
#line 1632 
          ;
          {
            int pfo_ret___2;
            
#line 1632 
            switch (4UL) {
              case (unsigned long)1: 
#line 1632 
              ;
              
#line 1633 
              ldv_inline_asm();
              
#line 1632 
              goto ldv_57423;
              case (unsigned long)2: 
#line 1632 
              ;
              
#line 1633 
              ldv_inline_asm();
              
#line 1632 
              goto ldv_57423;
              case (unsigned long)4: 
#line 1632 
              ;
              
#line 1633 
              ldv_inline_asm();
              
#line 1632 
              goto ldv_57423;
              case (unsigned long)8: 
#line 1632 
              ;
              
#line 1633 
              ldv_inline_asm();
              
#line 1632 
              goto ldv_57423;
              default: 
#line 1632 
              ;
              
#line 1632 
              __bad_percpu_size();
            }
            ldv_57423: 
#line 1632 
            ;
            
#line 1632 
            tmp_2 = pfo_ret___2;
          }
          
#line 1632 
          pscr_ret__ = tmp_2;
          
#line 1632 
          goto ldv_57401;
          default: 
#line 1632 
          ;
          
#line 1632 
          __bad_size_call_parameter();
          
#line 1632 
          goto ldv_57401;
        }
        ldv_57401: 
#line 1632 
        ;
        
#line 1632 
        tmp_3 = pscr_ret__;
      }
      
#line 1632 
      ;
      
#line 1632 
      ;
      
#line 1632 
      netdev_printk("\001",(struct net_device const *)efx->net_dev,"IRQ %d on CPU %d status ",irq,tmp_3,int_ker->u32[3],int_ker->u32[2],int_ker->u32[1],int_ker->u32[0]);
    }
    else ;
  }
  else ;
  {
    
#line 1636 
    bool __var = (_Bool)0;
    
#line 1636 
    tmp_4 = (bool volatile *)(& efx->irq_soft_enabled);
  }
  
#line 1636 
  ;
  
#line 1636 
  if ((long)((int)*tmp_4 != 0) == 0L) {
    
#line 1637 
    __retres = IRQ_HANDLED;
    
#line 1637 
    goto return_label;
  }
  else ;
  
#line 1640 
  if (context->index == efx->irq_level) {
    int tmp_10;
    
#line 1641 
    syserr = (int)int_ker->u64[1] & 1;
    
#line 1642 
    if ((long)(syserr != 0) != 0L) {
      irqreturn_t tmp_5;
      
#line 1643 
      tmp_5 = efx_farch_fatal_interrupt(efx);
      
#line 1643 
      __retres = tmp_5;
      
#line 1643 
      goto return_label;
    }
    else ;
    {
      int pscr_ret___0;
      {
        
#line 1644 
        void const *__vpp_verify_0 = (void const *)0;
        
#line 1644 
        void const *tmp_6 = __vpp_verify_0;
      }
      
#line 1644 
      switch (4UL) {
        int tmp_6_0;
        int tmp_7;
        int tmp_8;
        int tmp_9;
        case (unsigned long)1: 
#line 1644 
        ;
        {
          int pfo_ret___3;
          
#line 1644 
          switch (4UL) {
            case (unsigned long)1: 
#line 1644 
            ;
            
#line 1645 
            ldv_inline_asm();
            
#line 1644 
            goto ldv_57439;
            case (unsigned long)2: 
#line 1644 
            ;
            
#line 1645 
            ldv_inline_asm();
            
#line 1644 
            goto ldv_57439;
            case (unsigned long)4: 
#line 1644 
            ;
            
#line 1645 
            ldv_inline_asm();
            
#line 1644 
            goto ldv_57439;
            case (unsigned long)8: 
#line 1644 
            ;
            
#line 1645 
            ldv_inline_asm();
            
#line 1644 
            goto ldv_57439;
            default: 
#line 1644 
            ;
            
#line 1644 
            __bad_percpu_size();
          }
          ldv_57439: 
#line 1644 
          ;
          
#line 1644 
          tmp_6_0 = pfo_ret___3;
        }
        
#line 1644 
        pscr_ret___0 = tmp_6_0;
        
#line 1644 
        goto ldv_57445;
        case (unsigned long)2: 
#line 1644 
        ;
        {
          int pfo_ret___4;
          
#line 1644 
          switch (4UL) {
            case (unsigned long)1: 
#line 1644 
            ;
            
#line 1645 
            ldv_inline_asm();
            
#line 1644 
            goto ldv_57449;
            case (unsigned long)2: 
#line 1644 
            ;
            
#line 1645 
            ldv_inline_asm();
            
#line 1644 
            goto ldv_57449;
            case (unsigned long)4: 
#line 1644 
            ;
            
#line 1645 
            ldv_inline_asm();
            
#line 1644 
            goto ldv_57449;
            case (unsigned long)8: 
#line 1644 
            ;
            
#line 1645 
            ldv_inline_asm();
            
#line 1644 
            goto ldv_57449;
            default: 
#line 1644 
            ;
            
#line 1644 
            __bad_percpu_size();
          }
          ldv_57449: 
#line 1644 
          ;
          
#line 1644 
          tmp_7 = pfo_ret___4;
        }
        
#line 1644 
        pscr_ret___0 = tmp_7;
        
#line 1644 
        goto ldv_57445;
        case (unsigned long)4: 
#line 1644 
        ;
        {
          int pfo_ret___5;
          
#line 1644 
          switch (4UL) {
            case (unsigned long)1: 
#line 1644 
            ;
            
#line 1645 
            ldv_inline_asm();
            
#line 1644 
            goto ldv_57458;
            case (unsigned long)2: 
#line 1644 
            ;
            
#line 1645 
            ldv_inline_asm();
            
#line 1644 
            goto ldv_57458;
            case (unsigned long)4: 
#line 1644 
            ;
            
#line 1645 
            ldv_inline_asm();
            
#line 1644 
            goto ldv_57458;
            case (unsigned long)8: 
#line 1644 
            ;
            
#line 1645 
            ldv_inline_asm();
            
#line 1644 
            goto ldv_57458;
            default: 
#line 1644 
            ;
            
#line 1644 
            __bad_percpu_size();
          }
          ldv_57458: 
#line 1644 
          ;
          
#line 1644 
          tmp_8 = pfo_ret___5;
        }
        
#line 1644 
        pscr_ret___0 = tmp_8;
        
#line 1644 
        goto ldv_57445;
        case (unsigned long)8: 
#line 1644 
        ;
        {
          int pfo_ret___6;
          
#line 1644 
          switch (4UL) {
            case (unsigned long)1: 
#line 1644 
            ;
            
#line 1645 
            ldv_inline_asm();
            
#line 1644 
            goto ldv_57467;
            case (unsigned long)2: 
#line 1644 
            ;
            
#line 1645 
            ldv_inline_asm();
            
#line 1644 
            goto ldv_57467;
            case (unsigned long)4: 
#line 1644 
            ;
            
#line 1645 
            ldv_inline_asm();
            
#line 1644 
            goto ldv_57467;
            case (unsigned long)8: 
#line 1644 
            ;
            
#line 1645 
            ldv_inline_asm();
            
#line 1644 
            goto ldv_57467;
            default: 
#line 1644 
            ;
            
#line 1644 
            __bad_percpu_size();
          }
          ldv_57467: 
#line 1644 
          ;
          
#line 1644 
          tmp_9 = pfo_ret___6;
        }
        
#line 1644 
        pscr_ret___0 = tmp_9;
        
#line 1644 
        goto ldv_57445;
        default: 
#line 1644 
        ;
        
#line 1644 
        __bad_size_call_parameter();
        
#line 1644 
        goto ldv_57445;
      }
      ldv_57445: 
#line 1644 
      ;
      
#line 1644 
      tmp_10 = pscr_ret___0;
    }
    
#line 1644 
    efx->last_irq_cpu = tmp_10;
  }
  else ;
  
#line 1648 
  efx_schedule_channel_irq(efx->channel[context->index]);
  
#line 1650 
  __retres = IRQ_HANDLED;
  return_label: 
#line 1650 
                return __retres;
}


#line 1656  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
void efx_farch_rx_push_indir_table(struct efx_nic *efx)
{
  efx_dword_t dword;
  int tmp;
  
#line 1658 
  size_t i = 0UL;
  
#line 1661 
  tmp = efx_nic_rev(efx);
  
#line 1661 
  if ((long)(tmp <= 1) != 0L) {
    
#line 1663 
    ldv_inline_asm();
    
#line 1661 
    ;
  }
  else ;
  {
    
#line 1663 
    bool __cond = (_Bool)0;
    
#line 1663 
    if ((int)__cond != 0) 
#line 1663 
                          __compiletime_assert_1664(); else ;
  }
  
#line 1666 
  i = 0UL;
  
#line 1666 
  goto ldv_57488;
  ldv_57487: 
#line 1667 
  ;
  
#line 1667 
  dword.u32[0] = efx->rx_indir_table[i];
  
#line 1669 
  efx_writed(efx,(efx_dword_t const *)(& dword),(unsigned int)(i + 1028096UL) * 16U);
  
#line 1666 
  i += 1UL;
  ldv_57488: 
#line 1667 
  ;
  
#line 1666 
  if (i <= 127UL) 
#line 1668 
                  goto ldv_57487; else 
#line 1671 
                                       goto ldv_57489;
  ldv_57489: 
#line 1672 
  ;
  
#line 1673 
  return;
}


#line 1684  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
void efx_farch_dimension_resources(struct efx_nic *efx, unsigned int sram_lim_qw)
{
  unsigned int vi_count;
  unsigned int buftbl_min;
  unsigned int tmp_0;
  
#line 1689 
  struct siena_nic_data *nic_data = (struct siena_nic_data *)efx->nic_data;
  
#line 1695 
  buftbl_min = (unsigned int)(((((unsigned long)efx->n_rx_channels + (unsigned long)(efx->n_tx_channels * 4U)) + (unsigned long)efx->n_channels * 4UL) * 32768UL) / 4096UL);
  {
    unsigned int tmp;
    
#line 1699 
    unsigned int _max1 = efx->n_channels;
    
#line 1699 
    unsigned int _max2 = efx->n_tx_channels * 4U;
    
#line 1699 
    if (_max1 > _max2) 
#line 1699 
                       tmp = _max1; else 
#line 1699 
                                         tmp = _max2;
    
#line 1699 
    tmp_0 = tmp;
  }
  
#line 1699 
  vi_count = tmp_0;
  
#line 1702 
  if ((efx->type)->sriov_wanted != (bool (*)(struct efx_nic *))0) {
    bool tmp_7;
    
#line 1703 
    tmp_7 = (*((efx->type)->sriov_wanted))(efx);
    
#line 1703 
    if ((int)tmp_7 != 0) {
      unsigned int vi_dc_entries;
      unsigned int buftbl_free;
      unsigned int entries_per_vf;
      unsigned int vf_limit;
      unsigned int tmp_2;
      unsigned int tmp_3;
      unsigned int tmp_5;
      unsigned int tmp_6;
      
#line 1707 
      nic_data->vf_buftbl_base = buftbl_min;
      
#line 1709 
      vi_dc_entries = 80U;
      {
        unsigned int tmp_1;
        
#line 1710 
        unsigned int _max1_0 = vi_count;
        
#line 1710 
        unsigned int _max2_0 = 128U;
        
#line 1710 
        if (_max1_0 > _max2_0) 
#line 1710 
                               tmp_1 = _max1_0; else 
#line 1710 
                                                     tmp_1 = _max2_0;
        
#line 1710 
        tmp_2 = tmp_1;
      }
      
#line 1710 
      vi_count = tmp_2;
      
#line 1711 
      buftbl_free = (sram_lim_qw - buftbl_min) - vi_count * vi_dc_entries;
      
#line 1714 
      tmp_3 = efx_vf_size(efx);
      
#line 1714 
      entries_per_vf = (vi_dc_entries + 32U) * tmp_3;
      {
        unsigned int tmp_4;
        
#line 1717 
        unsigned int _min1 = buftbl_free / entries_per_vf;
        
#line 1717 
        unsigned int _min2 = 896U >> efx->vi_scale;
        
#line 1717 
        if (_min1 < _min2) 
#line 1717 
                           tmp_4 = _min1; else 
#line 1717 
                                               tmp_4 = _min2;
        
#line 1717 
        tmp_5 = tmp_4;
      }
      
#line 1717 
      vf_limit = tmp_5;
      
#line 1720 
      if (efx->vf_count > vf_limit) {
        
#line 1721 
        if ((efx->msg_enable & 2U) != 0U) 
#line 1721 
                                          netdev_err((struct net_device const *)efx->net_dev,"Reducing VF count from from %d to %d\n",efx->vf_count,vf_limit); else ;
        
#line 1724 
        efx->vf_count = vf_limit;
      }
      else ;
      
#line 1726 
      tmp_6 = efx_vf_size(efx);
      
#line 1726 
      vi_count = efx->vf_count * tmp_6 + vi_count;
    }
    else ;
  }
  else ;
  
#line 1731 
  efx->tx_dc_base = sram_lim_qw - vi_count * 16U;
  
#line 1732 
  efx->rx_dc_base = efx->tx_dc_base - vi_count * 64U;
  
#line 1733 
  return;
}


#line 1735  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
u32 efx_farch_fpga_ver(struct efx_nic *efx)
{
  u32 __retres;
  efx_oword_t altera_build;
  
#line 1738 
  efx_reado(efx,& altera_build,768U);
  
#line 1739 
  __retres = (unsigned int)altera_build.u64[0];
  
#line 1739 
  return __retres;
}


#line 1753 
void __compiletime_assert_1753(void);


#line 1760 
void __compiletime_assert_1760(void);


#line 1742  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
void efx_farch_init_common(struct efx_nic *efx)
{
  efx_oword_t temp;
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  
#line 1747 
  temp.u64[0] = (unsigned long long)efx->tx_dc_base;
  
#line 1747 
  temp.u64[1] = 0ULL;
  
#line 1748 
  efx_writeo(efx,(efx_oword_t const *)(& temp),1568U);
  
#line 1749 
  temp.u64[0] = (unsigned long long)efx->rx_dc_base;
  
#line 1749 
  temp.u64[1] = 0ULL;
  
#line 1750 
  efx_writeo(efx,(efx_oword_t const *)(& temp),1552U);
  {
    
#line 1753 
    bool __cond = (_Bool)0;
    
#line 1753 
    if ((int)__cond != 0) 
#line 1753 
                          __compiletime_assert_1753(); else ;
  }
  
#line 1754 
  temp.u64[0] = 1ULL;
  
#line 1754 
  temp.u64[1] = 0ULL;
  
#line 1755 
  efx_writeo(efx,(efx_oword_t const *)(& temp),2592U);
  {
    
#line 1760 
    bool __cond_0 = (_Bool)0;
    
#line 1760 
    if ((int)__cond_0 != 0) 
#line 1760 
                            __compiletime_assert_1760(); else ;
  }
  
#line 1761 
  temp.u64[0] = 3ULL;
  
#line 1761 
  temp.u64[1] = 0ULL;
  
#line 1762 
  efx_writeo(efx,(efx_oword_t const *)(& temp),2112U);
  
#line 1763 
  temp.u64[0] = 56ULL;
  
#line 1763 
  temp.u64[1] = 0ULL;
  
#line 1764 
  efx_writeo(efx,(efx_oword_t const *)(& temp),2128U);
  
#line 1767 
  temp.u64[0] = efx->irq_status.dma_addr;
  
#line 1767 
  temp.u64[1] = (unsigned long long)(efx->interrupt_mode <= (unsigned int)EFX_INT_MODE_MSI);
  
#line 1771 
  efx_writeo(efx,(efx_oword_t const *)(& temp),48U);
  
#line 1773 
  tmp = efx_nic_rev(efx);
  
#line 1773 
  if (tmp == 3) 
    
#line 1773 
    if (efx->interrupt_mode > (unsigned int)EFX_INT_MODE_MSI) 
#line 1775 
                                                              efx->irq_level = 31U; else 
                                                                    
#line 1778 
                                                                    efx->irq_level = 0U;
  else 
#line 1778 
       efx->irq_level = 0U;
  
#line 1786 
  temp.u64[0] = 833223655424ULL;
  
#line 1786 
  temp.u64[1] = 0ULL;
  
#line 1790 
  tmp_0 = efx_nic_rev(efx);
  
#line 1790 
  if (tmp_0 > 2) {
    
#line 1791 
    temp.u64[0] |= 17592186044416ULL;
    
#line 1791 
    temp.u64[1] = temp.u64[1];
  }
  else ;
  
#line 1792 
  temp.u64[0] = ~ temp.u64[0];
  
#line 1792 
  temp.u64[1] = ~ temp.u64[1];
  
#line 1793 
  efx_writeo(efx,(efx_oword_t const *)(& temp),560U);
  
#line 1798 
  efx_reado(efx,& temp,2688U);
  
#line 1799 
  temp.u64[0] = temp.u64[0];
  
#line 1799 
  temp.u64[1] = (temp.u64[1] & 18446744073709551360ULL) | 254ULL;
  
#line 1800 
  temp.u64[0] |= 144115188075855872ULL;
  
#line 1800 
  temp.u64[1] = temp.u64[1];
  
#line 1801 
  temp.u64[0] |= 262144ULL;
  
#line 1801 
  temp.u64[1] = temp.u64[1];
  
#line 1802 
  temp.u64[0] = temp.u64[0];
  
#line 1802 
  temp.u64[1] |= 33554432ULL;
  
#line 1803 
  temp.u64[0] |= 131072ULL;
  
#line 1803 
  temp.u64[1] = temp.u64[1];
  
#line 1805 
  temp.u64[0] |= 576460752303423488ULL;
  
#line 1805 
  temp.u64[1] = temp.u64[1];
  
#line 1807 
  temp.u64[0] = (temp.u64[0] & 18446744073707978751ULL) | 1048576ULL;
  
#line 1807 
  temp.u64[1] = temp.u64[1];
  
#line 1809 
  temp.u64[0] |= 17592181850112ULL;
  
#line 1809 
  temp.u64[1] = temp.u64[1];
  
#line 1811 
  tmp_1 = efx_nic_rev(efx);
  
#line 1811 
  if (tmp_1 > 1) {
    
#line 1812 
    temp.u64[0] |= 128ULL;
    
#line 1812 
    temp.u64[1] = temp.u64[1];
  }
  else ;
  
#line 1813 
  efx_writeo(efx,(efx_oword_t const *)(& temp),2688U);
  
#line 1815 
  tmp_2 = efx_nic_rev(efx);
  
#line 1815 
  if (tmp_2 > 1) {
    
#line 1816 
    temp.u64[0] = 11015701ULL;
    
#line 1816 
    temp.u64[1] = 0ULL;
    
#line 1825 
    efx_writeo(efx,(efx_oword_t const *)(& temp),2704U);
  }
  else ;
  
#line 1827 
  return;
}


#line 1903 
static void efx_farch_filter_table_clear_entry(struct efx_nic *efx, struct efx_farch_filter_table *table, unsigned int filter_idx);


#line 1909  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static u16 efx_farch_filter_hash(u32 key)
{
  u16 __retres;
  u16 tmp;
  
#line 1914 
  tmp = (unsigned short)((unsigned int)((unsigned short)(key >> 16)) ^ 8191U);
  
#line 1915 
  tmp = (unsigned short)((((int)tmp >> 3) ^ (int)tmp) ^ ((int)tmp >> 6));
  
#line 1916 
  tmp = (unsigned short)(((int)tmp >> 9) ^ (int)tmp);
  
#line 1918 
  tmp = (unsigned short)((int)((unsigned short)(((int)tmp << 13) ^ (int)tmp)) ^ (int)((unsigned short)key));
  
#line 1919 
  tmp = (unsigned short)((((int)tmp >> 3) ^ (int)tmp) ^ ((int)tmp >> 6));
  
#line 1920 
  __retres = (unsigned short)(((int)tmp >> 9) ^ (int)tmp);
  
#line 1920 
  return __retres;
}


#line 1925  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static u16 efx_farch_filter_increment(u32 key)
{
  u16 __retres;
  
#line 1927 
  __retres = (unsigned short)((unsigned int)((unsigned short)key) * 2U + 65535U);
  
#line 1927 
  return __retres;
}


#line 1933 
void __compiletime_assert_1934(void);


#line 1935 
void __compiletime_assert_1936(void);


#line 1937 
void __compiletime_assert_1938(void);


#line 1939 
void __compiletime_assert_1940(void);


#line 1941 
void __compiletime_assert_1942(void);


#line 1943 
void __compiletime_assert_1944(void);


#line 1945 
void __compiletime_assert_1946(void);


#line 1931  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static enum efx_farch_filter_table_id efx_farch_filter_spec_table_id(struct efx_farch_filter_spec const *spec)
{
  enum efx_farch_filter_table_id __retres;
  {
    
#line 1933 
    bool __cond = (_Bool)0;
    
#line 1933 
    if ((int)__cond != 0) 
#line 1933 
                          __compiletime_assert_1934(); else ;
  }
  {
    
#line 1935 
    bool __cond_0 = (_Bool)0;
    
#line 1935 
    if ((int)__cond_0 != 0) 
#line 1935 
                            __compiletime_assert_1936(); else ;
  }
  {
    
#line 1937 
    bool __cond_1 = (_Bool)0;
    
#line 1937 
    if ((int)__cond_1 != 0) 
#line 1937 
                            __compiletime_assert_1938(); else ;
  }
  {
    
#line 1939 
    bool __cond_2 = (_Bool)0;
    
#line 1939 
    if ((int)__cond_2 != 0) 
#line 1939 
                            __compiletime_assert_1940(); else ;
  }
  {
    
#line 1941 
    bool __cond_3 = (_Bool)0;
    
#line 1941 
    if ((int)__cond_3 != 0) 
#line 1941 
                            __compiletime_assert_1942(); else ;
  }
  {
    
#line 1943 
    bool __cond_4 = (_Bool)0;
    
#line 1943 
    if ((int)__cond_4 != 0) 
#line 1943 
                            __compiletime_assert_1944(); else ;
  }
  {
    
#line 1945 
    bool __cond_5 = (_Bool)0;
    
#line 1945 
    if ((int)__cond_5 != 0) 
#line 1945 
                            __compiletime_assert_1946(); else ;
  }
  
#line 1947 
  __retres = (enum efx_farch_filter_table_id)(((int)spec->type >> 2) + (((int)spec->flags >> 3) & 2));
  
#line 1947 
  return __retres;
}


#line 1950  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static void efx_farch_filter_push_rx_config(struct efx_nic *efx)
{
  struct efx_farch_filter_table *table;
  efx_oword_t filter_ctl;
  
#line 1952 
  struct efx_farch_filter_state *state = (struct efx_farch_filter_state *)efx->filter_state;
  
#line 1956 
  efx_reado(efx,& filter_ctl,2064U);
  
#line 1958 
  table = & state->table[0];
  
#line 1959 
  filter_ctl.u64[0] = (filter_ctl.u64[0] & 18446744073709551360ULL) | (unsigned long long)(table->search_limit[0] + 1U);
  
#line 1959 
  filter_ctl.u64[1] = filter_ctl.u64[1];
  
#line 1962 
  filter_ctl.u64[0] = (filter_ctl.u64[0] & 18446744073709486335ULL) | ((unsigned long long)(table->search_limit[1] + 3U) << 8);
  
#line 1962 
  filter_ctl.u64[1] = filter_ctl.u64[1];
  
#line 1965 
  filter_ctl.u64[0] = (filter_ctl.u64[0] & 18446742978492891135ULL) | ((unsigned long long)(table->search_limit[2] + 1U) << 32);
  
#line 1965 
  filter_ctl.u64[1] = filter_ctl.u64[1];
  
#line 1968 
  filter_ctl.u64[0] = (filter_ctl.u64[0] & 18446744073692839935ULL) | ((unsigned long long)(table->search_limit[3] + 3U) << 16);
  
#line 1968 
  filter_ctl.u64[1] = filter_ctl.u64[1];
  
#line 1972 
  table = & state->table[1];
  
#line 1973 
  if (table->size != 0U) {
    
#line 1974 
    filter_ctl.u64[0] = filter_ctl.u64[0];
    
#line 1974 
    filter_ctl.u64[1] = (filter_ctl.u64[1] & 18446744072640004095ULL) | ((unsigned long long)(table->search_limit[4] + 1U) << 22);
    
#line 1978 
    filter_ctl.u64[0] = filter_ctl.u64[0];
    
#line 1978 
    filter_ctl.u64[1] = (filter_ctl.u64[1] & 18446743799905386495ULL) | ((unsigned long long)(table->search_limit[5] + 3U) << 30);
  }
  else ;
  
#line 1984 
  table = & state->table[2];
  
#line 1985 
  if (table->size != 0U) {
    
#line 1986 
    filter_ctl.u64[0] = (filter_ctl.u64[0] & 18410724072783609855ULL) | ((unsigned long long)(table->spec)->dmaq_id << 43);
    
#line 1986 
    filter_ctl.u64[1] = filter_ctl.u64[1];
    
#line 1989 
    filter_ctl.u64[0] = (filter_ctl.u64[0] & 18446739675663040511ULL) | (((unsigned long long)(table->spec)->flags << 42) & 4398046511104ULL);
    
#line 1989 
    filter_ctl.u64[1] = filter_ctl.u64[1];
    
#line 1993 
    filter_ctl.u64[0] = (filter_ctl.u64[0] & 144115188075855871ULL) | ((unsigned long long)(table->spec + 1U)->dmaq_id << 57);
    
#line 1993 
    filter_ctl.u64[1] = (filter_ctl.u64[1] & 18446744073709551584ULL) | (unsigned long long)((int)(table->spec + 1U)->dmaq_id >> 7);
    
#line 1996 
    filter_ctl.u64[0] = (filter_ctl.u64[0] & 18374686479671623679ULL) | (((unsigned long long)(table->spec + 1U)->flags << 56) & 72057594037927936ULL);
    
#line 1996 
    filter_ctl.u64[1] = filter_ctl.u64[1];
    
#line 2005 
    filter_ctl.u64[0] = (filter_ctl.u64[0] & 18446742974197923839ULL) | (((unsigned long long)((int)(table->spec)->flags & (int)(table->spec + 1U)->flags) << 39) & 1099511627776ULL);
    
#line 2005 
    filter_ctl.u64[1] = filter_ctl.u64[1];
  }
  else {
    int tmp;
    
#line 2010 
    tmp = efx_nic_rev(efx);
    
#line 2010 
    if (tmp > 1) {
      
#line 2016 
      filter_ctl.u64[0] = (filter_ctl.u64[0] & 18446742974197923839ULL) | ((unsigned long long)efx->rx_scatter << 40);
      
#line 2016 
      filter_ctl.u64[1] = filter_ctl.u64[1];
    }
    else ;
  }
  
#line 2021 
  efx_writeo(efx,(efx_oword_t const *)(& filter_ctl),2064U);
  
#line 2022 
  return;
}


#line 2024  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static void efx_farch_filter_push_tx_limits(struct efx_nic *efx)
{
  struct efx_farch_filter_table *table;
  efx_oword_t tx_cfg;
  
#line 2026 
  struct efx_farch_filter_state *state = (struct efx_farch_filter_state *)efx->filter_state;
  
#line 2030 
  efx_reado(efx,& tx_cfg,2640U);
  
#line 2032 
  table = & state->table[3];
  
#line 2033 
  if (table->size != 0U) {
    
#line 2034 
    tx_cfg.u64[0] = tx_cfg.u64[0];
    
#line 2034 
    tx_cfg.u64[1] = (tx_cfg.u64[1] & 18446741883276230655ULL) | ((unsigned long long)(table->search_limit[4] + 1U) << 33);
    
#line 2038 
    tx_cfg.u64[0] = tx_cfg.u64[0];
    
#line 2038 
    tx_cfg.u64[1] = (tx_cfg.u64[1] & 18446183322779385855ULL) | ((unsigned long long)(table->search_limit[5] + 3U) << 41);
  }
  else ;
  
#line 2044 
  efx_writeo(efx,(efx_oword_t const *)(& tx_cfg),2640U);
  
#line 2045 
  return;
}


#line 2048  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static int efx_farch_filter_from_gen_spec(struct efx_farch_filter_spec *spec, struct efx_filter_spec const *gen_spec)
{
  int __retres;
  
#line 2051 
  bool is_full = (_Bool)0;
  
#line 2053 
  if (((int)gen_spec->flags & 1) != 0 && gen_spec->rss_context != 4294967295U) {
    
#line 2055 
    __retres = -22;
    
#line 2055 
    goto return_label;
  }
  else ;
  
#line 2057 
  spec->priority = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))gen_spec->priority;
  
#line 2058 
  spec->flags = (unsigned char)gen_spec->flags;
  
#line 2059 
  spec->dmaq_id = (unsigned short)gen_spec->dmaq_id;
  
#line 2061 
  switch ((int)gen_spec->match_flags) {
    int tmp_10;
    bool tmp_11;
    case 619: 
#line 2062 
    ;
    
#line 2065 
    is_full = (_Bool)1;
    case 610: 
#line 2067 
    ;
    {
      __be32 rhost;
      __be32 host1;
      __be32 host2;
      __be16 rport;
      __be16 port1;
      __be16 port2;
      unsigned int tmp_0;
      int tmp_2;
      int tmp_4;
      unsigned int tmp_6;
      
#line 2074 
      if ((unsigned int)gen_spec->ether_type != 8U) {
        
#line 2075 
        __retres = -93;
        
#line 2075 
        goto return_label;
      }
      else ;
      
#line 2076 
      if ((unsigned int)gen_spec->loc_port == 0U || ((int)is_full != 0 && (unsigned int)gen_spec->rem_port == 0U)) {
        
#line 2078 
        __retres = -99;
        
#line 2078 
        goto return_label;
      }
      else ;
      
#line 2079 
      switch ((int)gen_spec->ip_proto) {
        case 6: 
#line 2080 
        ;
        
#line 2081 
        spec->type = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))(! is_full);
        
#line 2083 
        goto ldv_57632;
        case 17: 
#line 2084 
        ;
        
#line 2085 
        if ((int)is_full != 0) 
#line 2085 
                               spec->type = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))2U; else 
                                                                    
#line 2085 
                                                                    spec->type = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))3U;
        
#line 2087 
        goto ldv_57632;
        default: 
#line 2088 
        ;
        
#line 2089 
        __retres = -93;
        
#line 2089 
        goto return_label;
      }
      ldv_57632: 
#line 2097 
      ;
      
#line 2097 
      if ((int)is_full != 0) 
#line 2097 
                             rhost = gen_spec->rem_host[0]; else 
#line 2097 
                                                                 rhost = 0U;
      
#line 2098 
      if ((int)is_full != 0) 
#line 2098 
                             rport = gen_spec->rem_port; else 
#line 2098 
                                                              rport = (unsigned short)0U;
      
#line 2099 
      host1 = rhost;
      
#line 2100 
      host2 = gen_spec->loc_host[0];
      
#line 2101 
      if (! is_full && (unsigned int)gen_spec->ip_proto == 17U) {
        
#line 2102 
        port1 = gen_spec->loc_port;
        
#line 2103 
        port2 = rport;
      }
      else {
        
#line 2105 
        port1 = rport;
        
#line 2106 
        port2 = gen_spec->loc_port;
      }
      
#line 2108 
      if (0 != 0) 
#line 2108 
                  tmp_0 = ((((host1 << 24) | ((host1 << 8) & 16711680U)) | ((host1 >> 8) & 65280U)) | (host1 >> 24)) << 16;
      else {
        __u32 tmp;
        
#line 2108 
        tmp = __fswab32(host1);
        
#line 2108 
        tmp_0 = tmp << 16;
      }
      
#line 2108 
      if (0 != 0) 
#line 2108 
                  tmp_2 = (int)((unsigned short)(((int)port1 << 8) | ((int)port1 >> 8)));
      else {
        __u16 tmp_1;
        
#line 2108 
        tmp_1 = __fswab16((unsigned short)((int)port1));
        
#line 2108 
        tmp_2 = (int)tmp_1;
      }
      
#line 2108 
      spec->data[0] = tmp_0 | (unsigned int)tmp_2;
      
#line 2109 
      if (0 != 0) 
#line 2109 
                  tmp_4 = (int)((unsigned short)(((int)port2 << 8) | ((int)port2 >> 8))) << 16;
      else {
        __u16 tmp_3;
        
#line 2109 
        tmp_3 = __fswab16((unsigned short)((int)port2));
        
#line 2109 
        tmp_4 = (int)tmp_3 << 16;
      }
      
#line 2109 
      if (0 != 0) 
#line 2109 
                  tmp_6 = ((((host1 << 24) | ((host1 << 8) & 16711680U)) | ((host1 >> 8) & 65280U)) | (host1 >> 24)) >> 16;
      else {
        __u32 tmp_5;
        
#line 2109 
        tmp_5 = __fswab32(host1);
        
#line 2109 
        tmp_6 = tmp_5 >> 16;
      }
      
#line 2109 
      spec->data[1] = (unsigned int)tmp_4 | tmp_6;
      
#line 2110 
      if (0 != 0) 
#line 2110 
                  spec->data[2] = (((host2 << 24) | ((host2 << 8) & 16711680U)) | ((host2 >> 8) & 65280U)) | (host2 >> 24); else 
                                                                    
#line 2110 
                                                                    spec->data[2] = __fswab32(host2);
      
#line 2112 
      goto ldv_57635;
    }
    case 272: 
#line 2115 
    ;
    
#line 2116 
    is_full = (_Bool)1;
    case 16: 
#line 2118 
    ;
    
#line 2119 
    if ((int)is_full != 0) 
#line 2119 
                           spec->type = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))4U; else 
                                                                    
#line 2119 
                                                                    spec->type = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))5U;
    
#line 2121 
    if ((int)is_full != 0) {
      int tmp_9;
      
#line 2121 
      if (0 != 0) 
#line 2121 
                  tmp_9 = (int)((unsigned short)(((int)gen_spec->outer_vid << 8) | ((int)gen_spec->outer_vid >> 8)));
      else {
        __u16 tmp_8;
        
#line 2121 
        tmp_8 = __fswab16((unsigned short)((int)gen_spec->outer_vid));
        
#line 2121 
        tmp_9 = (int)tmp_8;
      }
      
#line 2121 
      tmp_10 = tmp_9;
    }
    else 
#line 2121 
         tmp_10 = 0;
    
#line 2121 
    spec->data[0] = (unsigned int)tmp_10;
    
#line 2122 
    spec->data[1] = (unsigned int)(((((int)gen_spec->loc_mac[2] << 24) | ((int)gen_spec->loc_mac[3] << 16)) | ((int)gen_spec->loc_mac[4] << 8)) | (int)gen_spec->loc_mac[5]);
    
#line 2126 
    spec->data[2] = (unsigned int)(((int)gen_spec->loc_mac[0] << 8) | (int)gen_spec->loc_mac[1]);
    
#line 2128 
    goto ldv_57635;
    case 1024: 
#line 2130 
    ;
    
#line 2131 
    tmp_11 = is_multicast_ether_addr((u8 const *)(& gen_spec->loc_mac));
    
#line 2131 
    if ((int)tmp_11 != 0) 
#line 2131 
                          spec->type = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))9U; else 
                                                                    
#line 2131 
                                                                    spec->type = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))8U;
    
#line 2134 
    memset((void *)(& spec->data),0,12UL);
    
#line 2135 
    goto ldv_57635;
    default: 
#line 2137 
    ;
    
#line 2138 
    __retres = -93;
    
#line 2138 
    goto return_label;
  }
  ldv_57635: 
#line 2141 
  ;
  
#line 2141 
  __retres = 0;
  return_label: 
#line 2141 
                return __retres;
}


#line 2145  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static void efx_farch_filter_to_gen_spec(struct efx_filter_spec *gen_spec, struct efx_farch_filter_spec const *spec)
{
  
#line 2148 
  bool is_full = (_Bool)0;
  
#line 2154 
  memset((void *)gen_spec,0,64UL);
  
#line 2156 
  gen_spec->priority = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))spec->priority;
  
#line 2157 
  gen_spec->flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))spec->flags;
  
#line 2158 
  gen_spec->dmaq_id = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))))spec->dmaq_id;
  
#line 2160 
  switch ((int)spec->type) {
    case 0: 
#line 2161 
    ;
    case 2: 
#line 2162 
    ;
    
#line 2163 
    is_full = (_Bool)1;
    case 1: 
#line 2165 
    ;
    case 3: 
#line 2166 
    ;
    {
      __be32 host1;
      __be32 host2;
      __be16 port1;
      __be16 port2;
      
#line 2170 
      gen_spec->match_flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))))610U;
      
#line 2174 
      if ((int)is_full != 0) 
#line 2175 
                             gen_spec->match_flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))))((unsigned int)gen_spec->match_flags | 9U); else ;
      
#line 2177 
      gen_spec->ether_type = (unsigned short)8U;
      
#line 2178 
      if ((unsigned int)*((unsigned char *)spec + 0UL) <= 1U) 
#line 2178 
                                                              gen_spec->ip_proto = (unsigned char)6U; else 
                                                                    
#line 2178 
                                                                    gen_spec->ip_proto = (unsigned char)17U;
      
#line 2183 
      if (0 != 0) 
#line 2183 
                  host1 = (((((spec->data[0] >> 16) | (spec->data[1] << 16)) << 24) | ((((spec->data[0] >> 16) | (spec->data[1] << 16)) << 8) & 16711680U)) | ((((spec->data[0] >> 16) | (spec->data[1] << 16)) >> 8) & 65280U)) | (((spec->data[0] >> 16) | (spec->data[1] << 16)) >> 24); else 
                                                                    
#line 2183 
                                                                    host1 = __fswab32((spec->data[0] >> 16) | (spec->data[1] << 16));
      
#line 2184 
      if (0 != 0) 
#line 2184 
                  port1 = (unsigned short)(((int)((unsigned short)spec->data[0]) << 8) | ((int)((unsigned short)spec->data[0]) >> 8)); else 
                                                                    
#line 2184 
                                                                    port1 = __fswab16((unsigned short)((int)((unsigned short)spec->data[0])));
      
#line 2185 
      if (0 != 0) 
#line 2185 
                  host2 = (((spec->data[2] << 24) | ((spec->data[2] << 8) & 16711680U)) | ((spec->data[2] >> 8) & 65280U)) | (spec->data[2] >> 24); else 
                                                                    
#line 2185 
                                                                    host2 = __fswab32(spec->data[2]);
      
#line 2186 
      if (0 != 0) 
#line 2186 
                  port2 = (unsigned short)(((int)((unsigned short)(spec->data[1] >> 16)) << 8) | ((int)((unsigned short)(spec->data[1] >> 16)) >> 8)); else 
                                                                    
#line 2186 
                                                                    port2 = __fswab16((unsigned short)((int)((unsigned short)(spec->data[1] >> 16))));
      
#line 2187 
      if (((int)spec->flags & 16) != 0) {
        
#line 2188 
        gen_spec->loc_host[0] = host1;
        
#line 2189 
        gen_spec->rem_host[0] = host2;
      }
      else {
        
#line 2191 
        gen_spec->loc_host[0] = host2;
        
#line 2192 
        gen_spec->rem_host[0] = host1;
      }
      
#line 2194 
      if ((((int)gen_spec->flags & 16) != 0) ^ (int)((_Bool)((! is_full && (unsigned int)gen_spec->ip_proto == 17U) != 0))) {
        
#line 2196 
        gen_spec->loc_port = port1;
        
#line 2197 
        gen_spec->rem_port = port2;
      }
      else {
        
#line 2199 
        gen_spec->loc_port = port2;
        
#line 2200 
        gen_spec->rem_port = port1;
      }
      
#line 2203 
      goto ldv_57653;
    }
    case 4: 
#line 2206 
    ;
    
#line 2207 
    is_full = (_Bool)1;
    case 5: 
#line 2209 
    ;
    
#line 2210 
    gen_spec->match_flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))))16U;
    
#line 2211 
    if ((int)is_full != 0) 
#line 2212 
                           gen_spec->match_flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))))((unsigned int)gen_spec->match_flags | 256U); else ;
    
#line 2213 
    gen_spec->loc_mac[0] = (unsigned char)(spec->data[2] >> 8);
    
#line 2214 
    gen_spec->loc_mac[1] = (unsigned char)spec->data[2];
    
#line 2215 
    gen_spec->loc_mac[2] = (unsigned char)(spec->data[1] >> 24);
    
#line 2216 
    gen_spec->loc_mac[3] = (unsigned char)(spec->data[1] >> 16);
    
#line 2217 
    gen_spec->loc_mac[4] = (unsigned char)(spec->data[1] >> 8);
    
#line 2218 
    gen_spec->loc_mac[5] = (unsigned char)spec->data[1];
    
#line 2219 
    if (0 != 0) 
#line 2219 
                gen_spec->outer_vid = (unsigned short)(((int)((unsigned short)spec->data[0]) << 8) | ((int)((unsigned short)spec->data[0]) >> 8)); else 
                                                                    
#line 2219 
                                                                    gen_spec->outer_vid = __fswab16((unsigned short)((int)((unsigned short)spec->data[0])));
    
#line 2220 
    goto ldv_57653;
    case 8: 
#line 2222 
    ;
    case 9: 
#line 2223 
    ;
    
#line 2224 
    gen_spec->match_flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))))1024U;
    
#line 2225 
    gen_spec->loc_mac[0] = (unsigned char)((unsigned int)*((unsigned char *)spec + 0UL) == 9U);
    
#line 2226 
    goto ldv_57653;
    default: 
#line 2228 
    ;
    {
      
#line 2229 
      int __ret_warn_on = 1;
      
#line 2229 
      if ((long)(__ret_warn_on != 0) != 0L) 
#line 2229 
                                            warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c",2229); else ;
      
#line 2229 
      long tmp_4 = (long)(__ret_warn_on != 0);
    }
    
#line 2230 
    goto ldv_57653;
  }
  ldv_57653: 
#line 2232 
  ;
  
#line 2233 
  return;
}


#line 2235  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static void efx_farch_filter_init_rx_auto(struct efx_nic *efx, struct efx_farch_filter_spec *spec)
{
  int tmp;
  int tmp_0;
  
#line 2241 
  spec->priority = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))1U;
  
#line 2243 
  if (efx->n_rx_channels > 1U) 
#line 2243 
                               tmp = 9; else 
#line 2243 
                                             tmp = 8;
  
#line 2243 
  if ((int)efx->rx_scatter != 0) 
#line 2243 
                                 tmp_0 = 2; else 
#line 2243 
                                                 tmp_0 = 0;
  
#line 2242 
  spec->flags = (unsigned char)(tmp | tmp_0);
  
#line 2245 
  spec->dmaq_id = (unsigned short)0U;
  
#line 2246 
  return;
}


#line 2249  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static u32 efx_farch_filter_build(efx_oword_t *filter, struct efx_farch_filter_spec *spec)
{
  u32 __retres;
  u32 data3;
  enum efx_farch_filter_table_id tmp;
  
#line 2254 
  tmp = efx_farch_filter_spec_table_id((struct efx_farch_filter_spec const *)spec);
  
#line 2254 
  switch ((unsigned int)tmp) {
    case (unsigned int)0: 
#line 2255 
    ;
    {
      
#line 2256 
      bool is_udp = (_Bool)((unsigned int)*((unsigned char *)spec + 0UL) + 254U <= 1U);
      
#line 2258 
      filter->u64[0] = ((unsigned long long)spec->data[1] << 32) | (unsigned long long)spec->data[0];
      
#line 2258 
      filter->u64[1] = ((((((unsigned long long)spec->flags << 46) & 70368744177664ULL) | (((unsigned long long)spec->flags << 44) & 35184372088832ULL)) | ((unsigned long long)is_udp << 44)) | ((unsigned long long)spec->dmaq_id << 32)) | (unsigned long long)spec->data[2];
      
#line 2269 
      data3 = (unsigned int)is_udp;
      
#line 2270 
      goto ldv_57672;
    }
    case (unsigned int)1: 
#line 2273 
    ;
    {
      
#line 2274 
      bool is_wild = (_Bool)((unsigned int)*((unsigned char *)spec + 0UL) == 5U);
      
#line 2275 
      filter->u64[0] = (((((unsigned long long)spec->dmaq_id << 61) | ((unsigned long long)is_wild << 60)) | ((unsigned long long)spec->data[2] << 44)) | ((unsigned long long)spec->data[1] << 12)) | (unsigned long long)spec->data[0];
      
#line 2275 
      filter->u64[1] = ((((unsigned long long)spec->flags << 11) & 2048ULL) | (((unsigned long long)spec->flags << 9) & 1024ULL)) | (unsigned long long)((int)spec->dmaq_id >> 3);
      
#line 2286 
      data3 = (unsigned int)is_wild;
      
#line 2287 
      goto ldv_57672;
    }
    case (unsigned int)3: 
#line 2290 
    ;
    {
      
#line 2291 
      bool is_wild_0 = (_Bool)((unsigned int)*((unsigned char *)spec + 0UL) == 5U);
      
#line 2292 
      filter->u64[0] = (((((unsigned long long)spec->dmaq_id << 61) | ((unsigned long long)is_wild_0 << 60)) | ((unsigned long long)spec->data[2] << 44)) | ((unsigned long long)spec->data[1] << 12)) | (unsigned long long)spec->data[0];
      
#line 2292 
      filter->u64[1] = (unsigned long long)((int)spec->dmaq_id >> 3);
      
#line 2298 
      data3 = (unsigned int)((int)is_wild_0 | ((int)spec->dmaq_id << 1));
      
#line 2299 
      goto ldv_57672;
    }
    default: 
#line 2302 
    ;
    
#line 2303 
    ldv_inline_asm();
    
#line 2303 
    ;
  }
  ldv_57672: 
#line 2306 
  ;
  
#line 2306 
  __retres = ((spec->data[0] ^ spec->data[1]) ^ spec->data[2]) ^ data3;
  
#line 2306 
  return __retres;
}


#line 2309  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static bool efx_farch_filter_equal(struct efx_farch_filter_spec const *left, struct efx_farch_filter_spec const *right)
{
  bool __retres;
  
#line 2312 
  if (((unsigned int)((int)*((unsigned char *)left + 0UL) ^ (int)*((unsigned char *)right + 0UL)) & 15U) != 0U) {
    
#line 2314 
    __retres = (_Bool)0;
    
#line 2314 
    goto return_label;
  }
  else {
    int tmp;
    
#line 2312 
    tmp = memcmp((void const *)(& left->data),(void const *)(& right->data),12UL);
    
#line 2312 
    if (tmp != 0) {
      
#line 2314 
      __retres = (_Bool)0;
      
#line 2314 
      goto return_label;
    }
    else ;
  }
  
#line 2316 
  if (((int)left->flags & 16) != 0 && (int)left->dmaq_id != (int)right->dmaq_id) {
    
#line 2318 
    __retres = (_Bool)0;
    
#line 2318 
    goto return_label;
  }
  else ;
  
#line 2320 
  __retres = (_Bool)1;
  return_label: 
#line 2320 
                return __retres;
}


#line 2334  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static u8 const efx_farch_filter_type_match_pri[10U] = {(unsigned char)0U, (unsigned char)1U, (unsigned char)0U, (unsigned char)1U, (unsigned char)2U, (unsigned char)3U, [8] = (unsigned char)4U, (unsigned char)4U};

#line 2345  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static enum efx_farch_filter_table_id const efx_farch_filter_range_table[7U] = {EFX_FARCH_FILTER_TABLE_RX_IP, EFX_FARCH_FILTER_TABLE_RX_IP, EFX_FARCH_FILTER_TABLE_RX_MAC, EFX_FARCH_FILTER_TABLE_RX_MAC, EFX_FARCH_FILTER_TABLE_RX_DEF, EFX_FARCH_FILTER_TABLE_TX_MAC, EFX_FARCH_FILTER_TABLE_TX_MAC};

#line 2359  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
__inline static u32 efx_farch_filter_make_id(struct efx_farch_filter_spec const *spec, unsigned int index)
{
  u32 __retres;
  unsigned int range;
  
#line 2364 
  range = (unsigned int)efx_farch_filter_type_match_pri[(int)spec->type];
  
#line 2365 
  if (((int)spec->flags & 8) == 0) 
#line 2366 
                                   range += 5U; else ;
  
#line 2368 
  __retres = (range << 13) | index;
  
#line 2368 
  return __retres;
}


#line 2372  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
__inline static enum efx_farch_filter_table_id efx_farch_filter_id_table_id(u32 id)
{
  enum efx_farch_filter_table_id __retres;
  
#line 2374 
  unsigned int range = id >> 13;
  
#line 2376 
  if (range <= 6U) {
    
#line 2377 
    __retres = efx_farch_filter_range_table[range];
    
#line 2377 
    goto return_label;
  }
  else {
    
#line 2379 
    __retres = EFX_FARCH_FILTER_TABLE_COUNT;
    
#line 2379 
    goto return_label;
  }
  return_label: 
#line 2376 
                return __retres;
}


#line 2382  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
__inline static unsigned int efx_farch_filter_id_index(u32 id)
{
  unsigned int __retres;
  
#line 2384 
  __retres = id & 8191U;
  
#line 2384 
  return __retres;
}


#line 2387  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
u32 efx_farch_filter_get_rx_id_limit(struct efx_nic *efx)
{
  u32 __retres;
  enum efx_farch_filter_table_id table_id;
  unsigned int tmp;
  
#line 2389 
  struct efx_farch_filter_state *state = (struct efx_farch_filter_state *)efx->filter_state;
  
#line 2390 
  unsigned int range = 4U;
  ldv_57705: 
#line 2392 
  ;
  
#line 2394 
  table_id = efx_farch_filter_range_table[range];
  
#line 2395 
  if (state->table[(unsigned int)table_id].size != 0U) {
    
#line 2396 
    __retres = (range << 13) | state->table[(unsigned int)table_id].size;
    
#line 2396 
    goto return_label;
  }
  else ;
  
#line 2398 
  tmp = range;
  
#line 2398 
  range -= 1U;
  
#line 2398 
  ;
  
#line 2398 
  if (tmp != 0U) 
#line 2400 
                 goto ldv_57705; else 
#line 2403 
                                      goto ldv_57706;
  ldv_57706: 
#line 2404 
  ;
  
#line 2400 
  __retres = 0U;
  return_label: 
#line 2400 
                return __retres;
}


#line 2429 
void __compiletime_assert_2429(void);


#line 2430 
void __compiletime_assert_2431(void);


#line 2403  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
s32 efx_farch_filter_insert(struct efx_nic *efx, struct efx_filter_spec *gen_spec, bool replace_equal)
{
  s32 __retres;
  struct efx_farch_filter_table *table;
  struct efx_farch_filter_spec spec;
  efx_oword_t filter;
  int rep_index;
  int ins_index;
  int rc;
  enum efx_farch_filter_table_id tmp;
  u32 tmp_8;
  
#line 2407 
  struct efx_farch_filter_state *state = (struct efx_farch_filter_state *)efx->filter_state;
  
#line 2412 
  unsigned int depth = 0U;
  
#line 2415 
  rc = efx_farch_filter_from_gen_spec(& spec,(struct efx_filter_spec const *)gen_spec);
  
#line 2416 
  if (rc != 0) {
    
#line 2417 
    __retres = rc;
    
#line 2417 
    goto return_label;
  }
  else ;
  
#line 2419 
  tmp = efx_farch_filter_spec_table_id((struct efx_farch_filter_spec const *)(& spec));
  
#line 2419 
  table = & state->table[(unsigned int)tmp];
  
#line 2420 
  if (table->size == 0U) {
    
#line 2421 
    __retres = -22;
    
#line 2421 
    goto return_label;
  }
  else ;
  
#line 2427 
  if (table->id == (unsigned int)EFX_FARCH_FILTER_TABLE_RX_DEF) {
    {
      
#line 2429 
      bool __cond = (_Bool)0;
      
#line 2429 
      if ((int)__cond != 0) 
#line 2429 
                            __compiletime_assert_2429(); else ;
    }
    {
      
#line 2430 
      bool __cond_0 = (_Bool)0;
      
#line 2430 
      if ((int)__cond_0 != 0) 
#line 2430 
                              __compiletime_assert_2431(); else ;
    }
    
#line 2432 
    rep_index = (int)spec.type + -8;
    
#line 2433 
    ins_index = rep_index;
    
#line 2435 
    ldv_spin_lock_bh_97(& efx->filter_lock);
  }
  else {
    u16 tmp_1;
    u16 tmp_2;
    int tmp_3;
    int tmp_7;
    
#line 2452 
    u32 key = efx_farch_filter_build(& filter,& spec);
    
#line 2453 
    tmp_1 = efx_farch_filter_hash(key);
    
#line 2453 
    unsigned int hash = (unsigned int)tmp_1;
    
#line 2454 
    tmp_2 = efx_farch_filter_increment(key);
    
#line 2454 
    unsigned int incr = (unsigned int)tmp_2;
    
#line 2455 
    unsigned int max_rep_depth = table->search_limit[(int)spec.type];
    
#line 2458 
    if ((unsigned int)*((unsigned char *)(& spec) + 0UL) == 0U) 
#line 2458 
                                                                tmp_3 = 5; else 
                                                                    
#line 2458 
                                                                    tmp_3 = 200;
    
#line 2456 
    unsigned int max_ins_depth = (unsigned int)tmp_3;
    
#line 2460 
    unsigned int i = (table->size + 4294967295U) & hash;
    
#line 2462 
    ins_index = -1;
    
#line 2463 
    depth = 1U;
    
#line 2465 
    ldv_spin_lock_bh_98(& efx->filter_lock);
    ldv_57738: 
#line 2466 
    ;
    
#line 2468 
    if (0 != 0) {
      int tmp_5;
      
#line 2468 
      tmp_5 = constant_test_bit((long)i,(unsigned long const volatile *)table->used_bitmap);
      
#line 2468 
      tmp_7 = tmp_5 == 0;
    }
    else {
      int tmp_6;
      
#line 2468 
      tmp_6 = variable_test_bit((long)i,(unsigned long const volatile *)table->used_bitmap);
      
#line 2468 
      tmp_7 = tmp_6 == 0;
    }
    
#line 2468 
    if (tmp_7) {
      
#line 2469 
      if (ins_index < 0) 
#line 2470 
                         ins_index = (int)i; else ;
    }
    else {
      bool tmp_4;
      
#line 2471 
      tmp_4 = efx_farch_filter_equal((struct efx_farch_filter_spec const *)(& spec),(struct efx_farch_filter_spec const *)(table->spec + i));
      
#line 2471 
      if ((int)tmp_4 != 0) {
        
#line 2474 
        if (ins_index < 0) 
#line 2475 
                           ins_index = (int)i; else ;
        
#line 2476 
        rep_index = (int)i;
        
#line 2477 
        goto ldv_57736;
      }
      else ;
    }
    
#line 2480 
    if (depth >= max_rep_depth && (ins_index >= 0 || depth >= max_ins_depth)) {
      
#line 2483 
      if (ins_index < 0) {
        
#line 2484 
        rc = -16;
        
#line 2485 
        goto out;
      }
      else ;
      
#line 2487 
      rep_index = -1;
      
#line 2488 
      goto ldv_57736;
    }
    else ;
    
#line 2491 
    i = (i + incr) & (table->size + 4294967295U);
    
#line 2492 
    depth += 1U;
    
#line 2468 
    goto ldv_57738;
    ldv_57736: 
#line 2469 
    ;
  }
  
#line 2499 
  if (rep_index >= 0) {
    
#line 2500 
    struct efx_farch_filter_spec *saved_spec = table->spec + rep_index;
    
#line 2503 
    if (((unsigned int)((int)*((unsigned char *)(& spec) + 0UL) ^ (int)*((unsigned char *)saved_spec + 0UL)) & 240U) == 0U && ! replace_equal) {
      
#line 2504 
      rc = -17;
      
#line 2505 
      goto out;
    }
    else ;
    
#line 2507 
    if ((int)spec.priority < (int)saved_spec->priority) {
      
#line 2508 
      rc = -1;
      
#line 2509 
      goto out;
    }
    else ;
    
#line 2511 
    if ((unsigned int)*((unsigned char *)saved_spec + 0UL) == 16U || ((int)saved_spec->flags & 4) != 0) 
      
#line 2513 
      spec.flags = (unsigned char)((unsigned int)spec.flags | 4U); else ;
  }
  else ;
  
#line 2517 
  if (ins_index != rep_index) {
    
#line 2518 
    __set_bit((long)ins_index,(unsigned long volatile *)table->used_bitmap);
    
#line 2519 
    table->used += 1U;
  }
  else ;
  
#line 2521 
  *(table->spec + ins_index) = spec;
  
#line 2523 
  if (table->id == (unsigned int)EFX_FARCH_FILTER_TABLE_RX_DEF) 
#line 2524 
                                                                efx_farch_filter_push_rx_config(efx);
  else {
    
#line 2526 
    if (table->search_limit[(int)spec.type] < depth) {
      
#line 2527 
      table->search_limit[(int)spec.type] = depth;
      
#line 2528 
      if (((int)spec.flags & 16) != 0) 
#line 2529 
                                       efx_farch_filter_push_tx_limits(efx); else 
                                                                    
#line 2531 
                                                                    efx_farch_filter_push_rx_config(efx);
    }
    else ;
    
#line 2534 
    efx_writeo(efx,(efx_oword_t const *)(& filter),table->offset + table->step * (unsigned int)ins_index);
    
#line 2540 
    if (ins_index != rep_index && rep_index >= 0) 
#line 2541 
                                                  efx_farch_filter_table_clear_entry(efx,table,(unsigned int)rep_index); else ;
  }
  
#line 2548 
  tmp_8 = efx_farch_filter_make_id((struct efx_farch_filter_spec const *)(& spec),(unsigned int)ins_index);
  
#line 2548 
  rc = (int)tmp_8;
  out: 
#line 2550 
  ;
  
#line 2551 
  ldv_spin_unlock_bh_99(& efx->filter_lock);
  
#line 2552 
  __retres = rc;
  return_label: 
#line 2552 
                return __retres;
}


#line 2556  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static void efx_farch_filter_table_clear_entry(struct efx_nic *efx, struct efx_farch_filter_table *table, unsigned int filter_idx)
{
  efx_oword_t filter;
  
#line 2563 
  if ((long)(table->offset == 0U) != 0L) {
    
#line 2565 
    ldv_inline_asm();
    
#line 2563 
    ;
  }
  else ;
  
#line 2565 
  __set_bit((long)filter_idx,(unsigned long volatile *)table->used_bitmap);
  
#line 2566 
  table->used -= 1U;
  
#line 2567 
  memset((void *)(table->spec + filter_idx),0,16UL);
  
#line 2569 
  efx_writeo(efx,(efx_oword_t const *)(& filter),table->offset + table->step * filter_idx);
  
#line 2577 
  if ((long)(table->used == 0U) != 0L) {
    
#line 2578 
    memset((void *)(& table->search_limit),0,40UL);
    
#line 2579 
    if (table->id == (unsigned int)EFX_FARCH_FILTER_TABLE_TX_MAC) 
#line 2580 
                                                                  efx_farch_filter_push_tx_limits(efx); else 
                                                                    
#line 2582 
                                                                    efx_farch_filter_push_rx_config(efx);
  }
  else ;
  
#line 2584 
  return;
}


#line 2586  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static int efx_farch_filter_remove(struct efx_nic *efx, struct efx_farch_filter_table *table, unsigned int filter_idx, enum efx_filter_priority priority)
{
  int __retres;
  int tmp_1;
  
#line 2591 
  struct efx_farch_filter_spec *spec = table->spec + filter_idx;
  
#line 2593 
  if (0 != 0) {
    int tmp;
    
#line 2593 
    tmp = constant_test_bit((long)filter_idx,(unsigned long const volatile *)table->used_bitmap);
    
#line 2593 
    tmp_1 = tmp == 0;
  }
  else {
    int tmp_0;
    
#line 2593 
    tmp_0 = variable_test_bit((long)filter_idx,(unsigned long const volatile *)table->used_bitmap);
    
#line 2593 
    tmp_1 = tmp_0 == 0;
  }
  
#line 2593 
  if (tmp_1) {
    
#line 2595 
    __retres = -2;
    
#line 2595 
    goto return_label;
  }
  else 
    
#line 2594 
    if ((unsigned int)spec->priority != (unsigned int)priority) {
      
#line 2595 
      __retres = -2;
      
#line 2595 
      goto return_label;
    }
    else ;
  
#line 2597 
  if (((int)spec->flags & 4) != 0) {
    
#line 2598 
    efx_farch_filter_init_rx_auto(efx,spec);
    
#line 2599 
    efx_farch_filter_push_rx_config(efx);
  }
  else 
#line 2601 
       efx_farch_filter_table_clear_entry(efx,table,filter_idx);
  
#line 2604 
  __retres = 0;
  return_label: 
#line 2604 
                return __retres;
}


#line 2607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
int efx_farch_filter_remove_safe(struct efx_nic *efx, enum efx_filter_priority priority, u32 filter_id)
{
  int __retres;
  enum efx_farch_filter_table_id table_id;
  struct efx_farch_filter_table *table;
  unsigned int filter_idx;
  struct efx_farch_filter_spec *spec;
  int rc;
  
#line 2611 
  struct efx_farch_filter_state *state = (struct efx_farch_filter_state *)efx->filter_state;
  
#line 2618 
  table_id = efx_farch_filter_id_table_id(filter_id);
  
#line 2619 
  if (table_id > (unsigned int)EFX_FARCH_FILTER_TABLE_TX_MAC) {
    
#line 2620 
    __retres = -2;
    
#line 2620 
    goto return_label;
  }
  else ;
  
#line 2621 
  table = & state->table[(unsigned int)table_id];
  
#line 2623 
  filter_idx = efx_farch_filter_id_index(filter_id);
  
#line 2624 
  if (table->size <= filter_idx) {
    
#line 2625 
    __retres = -2;
    
#line 2625 
    goto return_label;
  }
  else ;
  
#line 2626 
  spec = table->spec + filter_idx;
  
#line 2628 
  ldv_spin_lock_bh_100(& efx->filter_lock);
  
#line 2629 
  rc = efx_farch_filter_remove(efx,table,filter_idx,priority);
  
#line 2630 
  ldv_spin_unlock_bh_101(& efx->filter_lock);
  
#line 2632 
  __retres = rc;
  return_label: 
#line 2632 
                return __retres;
}


#line 2635  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
int efx_farch_filter_get_safe(struct efx_nic *efx, enum efx_filter_priority priority, u32 filter_id, struct efx_filter_spec *spec_buf)
{
  int __retres;
  enum efx_farch_filter_table_id table_id;
  struct efx_farch_filter_table *table;
  struct efx_farch_filter_spec *spec;
  unsigned int filter_idx;
  int rc;
  int tmp_1;
  
#line 2639 
  struct efx_farch_filter_state *state = (struct efx_farch_filter_state *)efx->filter_state;
  
#line 2646 
  table_id = efx_farch_filter_id_table_id(filter_id);
  
#line 2647 
  if (table_id > (unsigned int)EFX_FARCH_FILTER_TABLE_TX_MAC) {
    
#line 2648 
    __retres = -2;
    
#line 2648 
    goto return_label;
  }
  else ;
  
#line 2649 
  table = & state->table[(unsigned int)table_id];
  
#line 2651 
  filter_idx = efx_farch_filter_id_index(filter_id);
  
#line 2652 
  if (table->size <= filter_idx) {
    
#line 2653 
    __retres = -2;
    
#line 2653 
    goto return_label;
  }
  else ;
  
#line 2654 
  spec = table->spec + filter_idx;
  
#line 2656 
  ldv_spin_lock_bh_102(& efx->filter_lock);
  
#line 2658 
  if (0 != 0) {
    int tmp;
    
#line 2658 
    tmp = constant_test_bit((long)filter_idx,(unsigned long const volatile *)table->used_bitmap);
    
#line 2658 
    tmp_1 = tmp != 0;
  }
  else {
    int tmp_0;
    
#line 2658 
    tmp_0 = variable_test_bit((long)filter_idx,(unsigned long const volatile *)table->used_bitmap);
    
#line 2658 
    tmp_1 = tmp_0 != 0;
  }
  
#line 2658 
  if (tmp_1) 
    
#line 2659 
    if ((unsigned int)spec->priority == (unsigned int)priority) {
      
#line 2660 
      efx_farch_filter_to_gen_spec(spec_buf,(struct efx_farch_filter_spec const *)spec);
      
#line 2661 
      rc = 0;
    }
    else 
#line 2663 
         rc = -2;
  else 
#line 2663 
       rc = -2;
  
#line 2666 
  ldv_spin_unlock_bh_103(& efx->filter_lock);
  
#line 2668 
  __retres = rc;
  return_label: 
#line 2668 
                return __retres;
}


#line 2672  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
static void efx_farch_filter_table_clear(struct efx_nic *efx, enum efx_farch_filter_table_id table_id, enum efx_filter_priority priority)
{
  unsigned int filter_idx;
  
#line 2676 
  struct efx_farch_filter_state *state = (struct efx_farch_filter_state *)efx->filter_state;
  
#line 2677 
  struct efx_farch_filter_table *table = & state->table[(unsigned int)table_id];
  
#line 2680 
  ldv_spin_lock_bh_104(& efx->filter_lock);
  
#line 2681 
  filter_idx = 0U;
  
#line 2681 
  goto ldv_57786;
  ldv_57785: 
#line 2682 
  ;
  
#line 2682 
  if ((unsigned int)*((unsigned char *)(table->spec + filter_idx) + 0UL) != 16U) 
    
#line 2683 
    efx_farch_filter_remove(efx,table,filter_idx,priority); else ;
  
#line 2681 
  filter_idx += 1U;
  ldv_57786: 
#line 2682 
  ;
  
#line 2681 
  if (table->size > filter_idx) 
#line 2683 
                                goto ldv_57785; else 
#line 2686 
                                                     goto ldv_57787;
  ldv_57787: 
#line 2687 
  ;
  
#line 2686 
  ldv_spin_unlock_bh_105(& efx->filter_lock);
  
#line 2687 
  return;
}


#line 2689  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
int efx_farch_filter_clear_rx(struct efx_nic *efx, enum efx_filter_priority priority)
{
  int __retres;
  
#line 2692 
  efx_farch_filter_table_clear(efx,(enum efx_farch_filter_table_id)EFX_FARCH_FILTER_TABLE_RX_IP,priority);
  
#line 2694 
  efx_farch_filter_table_clear(efx,(enum efx_farch_filter_table_id)EFX_FARCH_FILTER_TABLE_RX_MAC,priority);
  
#line 2696 
  efx_farch_filter_table_clear(efx,(enum efx_farch_filter_table_id)EFX_FARCH_FILTER_TABLE_RX_DEF,priority);
  
#line 2698 
  __retres = 0;
  
#line 2698 
  return __retres;
}


#line 2701  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
u32 efx_farch_filter_count_rx_used(struct efx_nic *efx, enum efx_filter_priority priority)
{
  enum efx_farch_filter_table_id table_id;
  struct efx_farch_filter_table *table;
  unsigned int filter_idx;
  int tmp_1;
  
#line 2704 
  struct efx_farch_filter_state *state = (struct efx_farch_filter_state *)efx->filter_state;
  
#line 2708 
  u32 count = 0U;
  
#line 2710 
  ldv_spin_lock_bh_106(& efx->filter_lock);
  
#line 2712 
  table_id = EFX_FARCH_FILTER_TABLE_RX_IP;
  
#line 2712 
  goto ldv_57805;
  ldv_57804: 
#line 2713 
  ;
  
#line 2715 
  table = & state->table[(unsigned int)table_id];
  
#line 2716 
  filter_idx = 0U;
  
#line 2716 
  goto ldv_57802;
  ldv_57801: 
#line 2717 
  ;
  
#line 2717 
  if (0 != 0) {
    int tmp;
    
#line 2717 
    tmp = constant_test_bit((long)filter_idx,(unsigned long const volatile *)table->used_bitmap);
    
#line 2717 
    tmp_1 = tmp != 0;
  }
  else {
    int tmp_0;
    
#line 2717 
    tmp_0 = variable_test_bit((long)filter_idx,(unsigned long const volatile *)table->used_bitmap);
    
#line 2717 
    tmp_1 = tmp_0 != 0;
  }
  
#line 2717 
  if (tmp_1) {
    
#line 2718 
    if ((unsigned int)(table->spec + filter_idx)->priority == (unsigned int)priority) 
      
#line 2719 
      count += 1U; else ;
  }
  else ;
  
#line 2716 
  filter_idx += 1U;
  ldv_57802: 
#line 2717 
  ;
  
#line 2716 
  if (table->size > filter_idx) 
#line 2718 
                                goto ldv_57801; else 
#line 2721 
                                                     goto ldv_57803;
  ldv_57803: 
#line 2722 
  ;
  
#line 2714 
  table_id += 1U;
  ldv_57805: 
#line 2715 
  ;
  
#line 2712 
  if (table_id <= (unsigned int)EFX_FARCH_FILTER_TABLE_RX_DEF) 
#line 2715 
                                                               goto ldv_57804; else 
                                                                    
#line 2718 
                                                                    goto ldv_57806;
  ldv_57806: 
#line 2719 
  ;
  
#line 2723 
  ldv_spin_unlock_bh_107(& efx->filter_lock);
  
#line 2725 
  return count;
}


#line 2728  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
s32 efx_farch_filter_get_rx_ids(struct efx_nic *efx, enum efx_filter_priority priority, u32 *buf, u32 size)
{
  enum efx_farch_filter_table_id table_id;
  struct efx_farch_filter_table *table;
  unsigned int filter_idx;
  int tmp_2;
  
#line 2732 
  struct efx_farch_filter_state *state = (struct efx_farch_filter_state *)efx->filter_state;
  
#line 2736 
  s32 count = 0;
  
#line 2738 
  ldv_spin_lock_bh_108(& efx->filter_lock);
  
#line 2740 
  table_id = EFX_FARCH_FILTER_TABLE_RX_IP;
  
#line 2740 
  goto ldv_57823;
  ldv_57822: 
#line 2741 
  ;
  
#line 2743 
  table = & state->table[(unsigned int)table_id];
  
#line 2744 
  filter_idx = 0U;
  
#line 2744 
  goto ldv_57820;
  ldv_57819: 
#line 2745 
  ;
  
#line 2745 
  if (0 != 0) {
    int tmp_0;
    
#line 2745 
    tmp_0 = constant_test_bit((long)filter_idx,(unsigned long const volatile *)table->used_bitmap);
    
#line 2745 
    tmp_2 = tmp_0 != 0;
  }
  else {
    int tmp_1;
    
#line 2745 
    tmp_1 = variable_test_bit((long)filter_idx,(unsigned long const volatile *)table->used_bitmap);
    
#line 2745 
    tmp_2 = tmp_1 != 0;
  }
  
#line 2745 
  if (tmp_2) {
    
#line 2746 
    if ((unsigned int)(table->spec + filter_idx)->priority == (unsigned int)priority) {
      s32 tmp;
      
#line 2747 
      if ((unsigned int)count == size) {
        
#line 2748 
        count = -90;
        
#line 2749 
        goto out;
      }
      else ;
      
#line 2751 
      tmp = count;
      
#line 2751 
      count += 1;
      
#line 2751 
      *(buf + tmp) = efx_farch_filter_make_id((struct efx_farch_filter_spec const *)(table->spec + filter_idx),filter_idx);
    }
    else ;
  }
  else ;
  
#line 2744 
  filter_idx += 1U;
  ldv_57820: 
#line 2745 
  ;
  
#line 2744 
  if (table->size > filter_idx) 
#line 2746 
                                goto ldv_57819; else 
#line 2749 
                                                     goto ldv_57821;
  ldv_57821: 
#line 2750 
  ;
  
#line 2742 
  table_id += 1U;
  ldv_57823: 
#line 2743 
  ;
  
#line 2740 
  if (table_id <= (unsigned int)EFX_FARCH_FILTER_TABLE_RX_DEF) 
#line 2743 
                                                               goto ldv_57822; else 
                                                                    
#line 2746 
                                                                    goto ldv_57824;
  ldv_57824: 
#line 2747 
  ;
  out: 
#line 2756 
  ;
  
#line 2757 
  ldv_spin_unlock_bh_109(& efx->filter_lock);
  
#line 2759 
  return count;
}


#line 2763  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
void efx_farch_filter_table_restore(struct efx_nic *efx)
{
  enum efx_farch_filter_table_id table_id;
  struct efx_farch_filter_table *table;
  efx_oword_t filter;
  unsigned int filter_idx;
  int tmp_1;
  
#line 2765 
  struct efx_farch_filter_state *state = (struct efx_farch_filter_state *)efx->filter_state;
  
#line 2771 
  ldv_spin_lock_bh_110(& efx->filter_lock);
  
#line 2773 
  table_id = EFX_FARCH_FILTER_TABLE_RX_IP;
  
#line 2773 
  goto ldv_57839;
  ldv_57838: 
#line 2774 
  ;
  
#line 2774 
  table = & state->table[(unsigned int)table_id];
  
#line 2777 
  if (table->step == 0U) 
#line 2778 
                         goto ldv_57833; else ;
  
#line 2780 
  filter_idx = 0U;
  
#line 2780 
  goto ldv_57836;
  ldv_57835: 
#line 2781 
  ;
  
#line 2781 
  if (0 != 0) {
    int tmp;
    
#line 2781 
    tmp = constant_test_bit((long)filter_idx,(unsigned long const volatile *)table->used_bitmap);
    
#line 2781 
    tmp_1 = tmp == 0;
  }
  else {
    int tmp_0;
    
#line 2781 
    tmp_0 = variable_test_bit((long)filter_idx,(unsigned long const volatile *)table->used_bitmap);
    
#line 2781 
    tmp_1 = tmp_0 == 0;
  }
  
#line 2781 
  if (tmp_1) 
#line 2782 
             goto ldv_57834; else ;
  
#line 2783 
  efx_farch_filter_build(& filter,table->spec + filter_idx);
  
#line 2784 
  efx_writeo(efx,(efx_oword_t const *)(& filter),table->offset + table->step * filter_idx);
  ldv_57834: 
#line 2786 
  ;
  
#line 2780 
  filter_idx += 1U;
  ldv_57836: 
#line 2781 
  ;
  
#line 2780 
  if (table->size > filter_idx) 
#line 2782 
                                goto ldv_57835; else 
#line 2785 
                                                     goto ldv_57837;
  ldv_57837: 
#line 2786 
  ;
  ldv_57833: 
#line 2787 
  ;
  
#line 2773 
  table_id += 1U;
  ldv_57839: 
#line 2774 
  ;
  
#line 2773 
  if (table_id <= (unsigned int)EFX_FARCH_FILTER_TABLE_TX_MAC) 
#line 2775 
                                                               goto ldv_57838; else 
                                                                    
#line 2778 
                                                                    goto ldv_57840;
  ldv_57840: 
#line 2779 
  ;
  
#line 2789 
  efx_farch_filter_push_rx_config(efx);
  
#line 2790 
  efx_farch_filter_push_tx_limits(efx);
  
#line 2792 
  ldv_spin_unlock_bh_111(& efx->filter_lock);
  
#line 2793 
  return;
}


#line 2795  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
void efx_farch_filter_table_remove(struct efx_nic *efx)
{
  enum efx_farch_filter_table_id table_id;
  
#line 2797 
  struct efx_farch_filter_state *state = (struct efx_farch_filter_state *)efx->filter_state;
  
#line 2800 
  table_id = EFX_FARCH_FILTER_TABLE_RX_IP;
  
#line 2800 
  goto ldv_57847;
  ldv_57846: 
#line 2801 
  ;
  
#line 2801 
  kfree((void const *)state->table[(unsigned int)table_id].used_bitmap);
  
#line 2802 
  vfree((void const *)state->table[(unsigned int)table_id].spec);
  
#line 2800 
  table_id += 1U;
  ldv_57847: 
#line 2801 
  ;
  
#line 2800 
  if (table_id <= (unsigned int)EFX_FARCH_FILTER_TABLE_TX_MAC) 
#line 2802 
                                                               goto ldv_57846; else 
                                                                    
#line 2805 
                                                                    goto ldv_57848;
  ldv_57848: 
#line 2806 
  ;
  
#line 2804 
  kfree((void const *)state);
  
#line 2805 
  return;
}


#line 2807  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
int efx_farch_filter_table_probe(struct efx_nic *efx)
{
  int __retres;
  struct efx_farch_filter_state *state;
  struct efx_farch_filter_table *table;
  unsigned int table_id;
  int tmp_0;
  int tmp_1;
  
#line 2813 
  state = (struct efx_farch_filter_state *)kzalloc(320UL,208U);
  
#line 2814 
  if (state == (struct efx_farch_filter_state *)0) {
    
#line 2815 
    __retres = -12;
    
#line 2815 
    goto return_label;
  }
  else ;
  
#line 2816 
  efx->filter_state = (void *)state;
  
#line 2818 
  tmp_0 = efx_nic_rev(efx);
  
#line 2818 
  if (tmp_0 > 1) {
    
#line 2819 
    table = & state->table[0];
    
#line 2820 
    table->id = EFX_FARCH_FILTER_TABLE_RX_IP;
    
#line 2821 
    table->offset = 15728640U;
    
#line 2822 
    table->size = 8192U;
    
#line 2823 
    table->step = 32U;
  }
  else ;
  
#line 2826 
  tmp_1 = efx_nic_rev(efx);
  
#line 2826 
  if (tmp_1 > 2) {
    
#line 2827 
    table = & state->table[1];
    
#line 2828 
    table->id = EFX_FARCH_FILTER_TABLE_RX_MAC;
    
#line 2829 
    table->offset = 15728656U;
    
#line 2830 
    table->size = 512U;
    
#line 2831 
    table->step = 32U;
    
#line 2833 
    table = & state->table[2];
    
#line 2834 
    table->id = EFX_FARCH_FILTER_TABLE_RX_DEF;
    
#line 2835 
    table->size = 2U;
    
#line 2837 
    table = & state->table[3];
    
#line 2838 
    table->id = EFX_FARCH_FILTER_TABLE_TX_MAC;
    
#line 2839 
    table->offset = 16646144U;
    
#line 2840 
    table->size = 512U;
    
#line 2841 
    table->step = 16U;
  }
  else ;
  
#line 2844 
  table_id = 0U;
  
#line 2844 
  goto ldv_57858;
  ldv_57857: 
#line 2845 
  ;
  
#line 2845 
  table = & state->table[table_id];
  
#line 2846 
  if (table->size == 0U) 
#line 2847 
                         goto ldv_57855; else ;
  
#line 2848 
  table->used_bitmap = (unsigned long *)kcalloc(((unsigned long)table->size + 63UL) / 64UL,8UL,208U);
  
#line 2851 
  if (table->used_bitmap == (unsigned long *)0UL) 
#line 2852 
                                                  goto fail; else ;
  
#line 2853 
  table->spec = (struct efx_farch_filter_spec *)vzalloc((unsigned long)table->size * 16UL);
  
#line 2854 
  if (table->spec == (struct efx_farch_filter_spec *)0) 
#line 2855 
                                                        goto fail; else ;
  ldv_57855: 
#line 2856 
  ;
  
#line 2844 
  table_id += 1U;
  ldv_57858: 
#line 2845 
  ;
  
#line 2844 
  if (table_id <= 3U) 
#line 2846 
                      goto ldv_57857; else 
#line 2849 
                                           goto ldv_57859;
  ldv_57859: 
#line 2850 
  ;
  
#line 2858 
  table = & state->table[2];
  
#line 2859 
  if (table->size != 0U) {
    struct efx_farch_filter_spec *spec;
    unsigned int i;
    
#line 2864 
    i = 0U;
    
#line 2864 
    goto ldv_57863;
    ldv_57862: 
#line 2865 
    ;
    
#line 2865 
    spec = table->spec + i;
    
#line 2866 
    spec->type = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))((unsigned int)((unsigned char)i) + 8U);
    
#line 2867 
    efx_farch_filter_init_rx_auto(efx,spec);
    
#line 2868 
    __set_bit((long)i,(unsigned long volatile *)table->used_bitmap);
    
#line 2864 
    i += 1U;
    ldv_57863: 
#line 2865 
    ;
    
#line 2864 
    if (i <= 1U) 
#line 2866 
                 goto ldv_57862; else 
#line 2869 
                                      goto ldv_57864;
    ldv_57864: 
#line 2870 
    ;
  }
  else ;
  
#line 2872 
  efx_farch_filter_push_rx_config(efx);
  
#line 2874 
  __retres = 0;
  
#line 2874 
  goto return_label;
  fail: 
#line 2876 
  ;
  
#line 2877 
  efx_farch_filter_table_remove(efx);
  
#line 2878 
  __retres = -12;
  return_label: 
#line 2878 
                return __retres;
}


#line 2882  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
void efx_farch_filter_update_rx_scatter(struct efx_nic *efx)
{
  enum efx_farch_filter_table_id table_id;
  struct efx_farch_filter_table *table;
  efx_oword_t filter;
  unsigned int filter_idx;
  int tmp_1;
  
#line 2884 
  struct efx_farch_filter_state *state = (struct efx_farch_filter_state *)efx->filter_state;
  
#line 2890 
  ldv_spin_lock_bh_112(& efx->filter_lock);
  
#line 2892 
  table_id = EFX_FARCH_FILTER_TABLE_RX_IP;
  
#line 2892 
  goto ldv_57878;
  ldv_57877: 
#line 2893 
  ;
  
#line 2895 
  table = & state->table[(unsigned int)table_id];
  
#line 2897 
  filter_idx = 0U;
  
#line 2897 
  goto ldv_57875;
  ldv_57874: 
#line 2898 
  ;
  
#line 2898 
  if (0 != 0) {
    int tmp;
    
#line 2898 
    tmp = constant_test_bit((long)filter_idx,(unsigned long const volatile *)table->used_bitmap);
    
#line 2898 
    tmp_1 = tmp == 0;
  }
  else {
    int tmp_0;
    
#line 2898 
    tmp_0 = variable_test_bit((long)filter_idx,(unsigned long const volatile *)table->used_bitmap);
    
#line 2898 
    tmp_1 = tmp_0 == 0;
  }
  
#line 2898 
  if (tmp_1) 
#line 2898 
             goto _LOR;
  else 
    
#line 2899 
    if ((unsigned int)(table->spec + filter_idx)->dmaq_id >= efx->n_rx_channels) 
      _LOR: 
#line 2901 
            goto ldv_57873; else ;
  
#line 2903 
  if ((int)efx->rx_scatter != 0) 
#line 2904 
                                 (table->spec + filter_idx)->flags = (unsigned char)((unsigned int)(table->spec + filter_idx)->flags | 2U); else 
                                                                    
#line 2907 
                                                                    (table->spec + filter_idx)->flags = (unsigned char)((unsigned int)(table->spec + filter_idx)->flags & 253U);
  
#line 2910 
  if (table_id == (unsigned int)EFX_FARCH_FILTER_TABLE_RX_DEF) 
#line 2912 
                                                               goto ldv_57873; else ;
  
#line 2914 
  efx_farch_filter_build(& filter,table->spec + filter_idx);
  
#line 2915 
  efx_writeo(efx,(efx_oword_t const *)(& filter),table->offset + table->step * filter_idx);
  ldv_57873: 
#line 2917 
  ;
  
#line 2897 
  filter_idx += 1U;
  ldv_57875: 
#line 2898 
  ;
  
#line 2897 
  if (table->size > filter_idx) 
#line 2899 
                                goto ldv_57874; else 
#line 2902 
                                                     goto ldv_57876;
  ldv_57876: 
#line 2903 
  ;
  
#line 2894 
  table_id += 1U;
  ldv_57878: 
#line 2895 
  ;
  
#line 2892 
  if (table_id <= (unsigned int)EFX_FARCH_FILTER_TABLE_RX_DEF) 
#line 2895 
                                                               goto ldv_57877; else 
                                                                    
#line 2898 
                                                                    goto ldv_57879;
  ldv_57879: 
#line 2899 
  ;
  
#line 2920 
  efx_farch_filter_push_rx_config(efx);
  
#line 2922 
  ldv_spin_unlock_bh_113(& efx->filter_lock);
  
#line 2923 
  return;
}


#line 2927  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
s32 efx_farch_filter_rfs_insert(struct efx_nic *efx, struct efx_filter_spec *gen_spec)
{
  s32 tmp;
  
#line 2930 
  tmp = efx_farch_filter_insert(efx,gen_spec,(_Bool)1);
  
#line 2930 
  return tmp;
}


#line 2933  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
bool efx_farch_filter_rfs_expire_one(struct efx_nic *efx, u32 flow_id, unsigned int index)
{
  bool __retres;
  int tmp_1;
  
#line 2936 
  struct efx_farch_filter_state *state = (struct efx_farch_filter_state *)efx->filter_state;
  
#line 2937 
  struct efx_farch_filter_table *table = & state->table[0];
  
#line 2940 
  if (0 != 0) {
    int tmp;
    
#line 2940 
    tmp = constant_test_bit((long)index,(unsigned long const volatile *)table->used_bitmap);
    
#line 2940 
    tmp_1 = tmp != 0;
  }
  else {
    int tmp_0;
    
#line 2940 
    tmp_0 = variable_test_bit((long)index,(unsigned long const volatile *)table->used_bitmap);
    
#line 2940 
    tmp_1 = tmp_0 != 0;
  }
  
#line 2940 
  if (tmp_1) {
    
#line 2940 
    if ((unsigned int)*((unsigned char *)(table->spec + index) + 0UL) == 0U) {
      bool tmp_2;
      
#line 2941 
      tmp_2 = rps_may_expire_flow(efx->net_dev,(unsigned short)((int)(table->spec + index)->dmaq_id),flow_id,(unsigned short)((int)((unsigned short)index)));
      
#line 2941 
      if ((int)tmp_2 != 0) {
        
#line 2944 
        efx_farch_filter_table_clear_entry(efx,table,index);
        
#line 2945 
        __retres = (_Bool)1;
        
#line 2945 
        goto return_label;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 2948 
  __retres = (_Bool)0;
  return_label: 
#line 2948 
                return __retres;
}


#line 2953  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/farch.c"
void efx_farch_filter_sync_rx_mode(struct efx_nic *efx)
{
  struct netdev_hw_addr *ha;
  u32 crc;
  int bit;
  int tmp;
  
#line 2955 
  struct net_device *net_dev = efx->net_dev;
  
#line 2957 
  union efx_multicast_hash *mc_hash = & efx->multicast_hash;
  
#line 2961 
  tmp = efx_dev_registered(efx);
  
#line 2961 
  if (tmp == 0) 
#line 2962 
                goto return_label; else ;
  
#line 2964 
  netif_addr_lock_bh(net_dev);
  
#line 2966 
  efx->unicast_filter = (_Bool)((net_dev->flags & 256U) == 0U);
  
#line 2969 
  if ((net_dev->flags & 768U) != 0U) 
#line 2970 
                                     memset((void *)mc_hash,255,32UL);
  else {
    struct netdev_hw_addr *tmp_0;
    struct netdev_hw_addr *tmp_1;
    
#line 2972 
    memset((void *)mc_hash,0,32UL);
    {
      
#line 2973 
      struct list_head const *__mptr = (struct list_head const *)net_dev->mc.list.next;
      
#line 2973 
      tmp_0 = (struct netdev_hw_addr *)__mptr;
    }
    
#line 2973 
    ha = tmp_0;
    
#line 2973 
    goto ldv_57904;
    ldv_57903: 
#line 2974 
    ;
    
#line 2974 
    crc = crc32_le(4294967295U,(unsigned char const *)(& ha->addr),6UL);
    
#line 2975 
    bit = (int)crc & 255;
    
#line 2976 
    __set_bit_le(bit,(void *)mc_hash);
    {
      
#line 2973 
      struct list_head const *__mptr_0 = (struct list_head const *)ha->list.next;
      
#line 2973 
      tmp_1 = (struct netdev_hw_addr *)__mptr_0;
    }
    
#line 2973 
    ha = tmp_1;
    ldv_57904: 
#line 2975 
    ;
    
#line 2973 
    if (& ha->list != & net_dev->mc.list) 
#line 2975 
                                          goto ldv_57903; else 
#line 2978 
                                                               goto ldv_57905;
    ldv_57905: 
#line 2979 
    ;
    
#line 2983 
    __set_bit_le(255,(void *)mc_hash);
  }
  
#line 2986 
  netif_addr_unlock_bh(net_dev);
  return_label: 
#line 2987 
                return;
}


#line 125  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void atomic_inc(atomic_t *v)
{
  
#line 128 
  ldv_atomic_inc(v);
  
#line 129 
  return;
}


#line 132  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void atomic_dec(atomic_t *v)
{
  
#line 135 
  ldv_atomic_dec(v);
  
#line 136 
  return;
}


#line 505  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void *kcalloc(size_t n, size_t size, gfp_t flags)
{
  void *tmp;
  
#line 508 
  tmp = ldv_kcalloc(n,size,flags);
  
#line 508 
  return tmp;
}


#line 512  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void *kzalloc(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 515 
  tmp = ldv_kzalloc(size,flags);
  
#line 515 
  return tmp;
}


#line 625  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void ldv_spin_lock_62(spinlock_t *lock)
{
  
#line 629 
  ldv_spin_model_lock((char *)"_xmit_lock_of_netdev_queue");
  
#line 631 
  spin_lock(lock);
  
#line 632 
  return;
}


#line 668  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void ldv_spin_unlock_65(spinlock_t *lock)
{
  
#line 672 
  ldv_spin_model_unlock((char *)"_xmit_lock_of_netdev_queue");
  
#line 674 
  spin_unlock(lock);
  
#line 675 
  return;
}


#line 688  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void ldv_spin_lock_67(spinlock_t *lock)
{
  
#line 692 
  ldv_spin_model_lock((char *)"tx_global_lock_of_net_device");
  
#line 694 
  spin_lock(lock);
  
#line 695 
  return;
}


#line 698  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void ldv_spin_unlock_68(spinlock_t *lock)
{
  
#line 702 
  ldv_spin_model_unlock((char *)"tx_global_lock_of_net_device");
  
#line 704 
  spin_unlock(lock);
  
#line 705 
  return;
}


#line 728  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void ldv_spin_lock_bh_71(spinlock_t *lock)
{
  
#line 732 
  ldv_spin_model_lock((char *)"addr_list_lock_of_net_device");
  
#line 734 
  spin_lock_bh(lock);
  
#line 735 
  return;
}


#line 748  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void ldv_spin_unlock_bh_73(spinlock_t *lock)
{
  
#line 752 
  ldv_spin_model_unlock((char *)"addr_list_lock_of_net_device");
  
#line 754 
  spin_unlock_bh(lock);
  
#line 755 
  return;
}


#line 888  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void ldv___ldv_spin_lock_87(spinlock_t *ldv_func_arg1)
{
  
#line 892 
  ldv_spin_model_lock((char *)"biu_lock_of_efx_nic");
  
#line 894 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 895 
  return;
}


#line 898  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void ldv_spin_unlock_irqrestore_88(spinlock_t *lock, unsigned long flags)
{
  
#line 902 
  ldv_spin_model_unlock((char *)"biu_lock_of_efx_nic");
  
#line 904 
  spin_unlock_irqrestore(lock,flags);
  
#line 905 
  return;
}


#line 908  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void ldv___ldv_spin_lock_89(spinlock_t *ldv_func_arg1)
{
  
#line 912 
  ldv_spin_model_lock((char *)"biu_lock_of_efx_nic");
  
#line 914 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 915 
  return;
}


#line 918  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void ldv_spin_unlock_irqrestore_90(spinlock_t *lock, unsigned long flags)
{
  
#line 922 
  ldv_spin_model_unlock((char *)"biu_lock_of_efx_nic");
  
#line 924 
  spin_unlock_irqrestore(lock,flags);
  
#line 925 
  return;
}


#line 928  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void ldv___ldv_spin_lock_91(spinlock_t *ldv_func_arg1)
{
  
#line 932 
  ldv_spin_model_lock((char *)"biu_lock_of_efx_nic");
  
#line 934 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 935 
  return;
}


#line 938  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void ldv_spin_unlock_irqrestore_92(spinlock_t *lock, unsigned long flags)
{
  
#line 942 
  ldv_spin_model_unlock((char *)"biu_lock_of_efx_nic");
  
#line 944 
  spin_unlock_irqrestore(lock,flags);
  
#line 945 
  return;
}


#line 988  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void ldv_spin_lock_bh_97(spinlock_t *lock)
{
  
#line 992 
  ldv_spin_model_lock((char *)"filter_lock_of_efx_nic");
  
#line 994 
  spin_lock_bh(lock);
  
#line 995 
  return;
}


#line 998  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void ldv_spin_lock_bh_98(spinlock_t *lock)
{
  
#line 1002 
  ldv_spin_model_lock((char *)"filter_lock_of_efx_nic");
  
#line 1004 
  spin_lock_bh(lock);
  
#line 1005 
  return;
}


#line 1008  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void ldv_spin_unlock_bh_99(spinlock_t *lock)
{
  
#line 1012 
  ldv_spin_model_unlock((char *)"filter_lock_of_efx_nic");
  
#line 1014 
  spin_unlock_bh(lock);
  
#line 1015 
  return;
}


#line 1018  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void ldv_spin_lock_bh_100(spinlock_t *lock)
{
  
#line 1022 
  ldv_spin_model_lock((char *)"filter_lock_of_efx_nic");
  
#line 1024 
  spin_lock_bh(lock);
  
#line 1025 
  return;
}


#line 1028  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void ldv_spin_unlock_bh_101(spinlock_t *lock)
{
  
#line 1032 
  ldv_spin_model_unlock((char *)"filter_lock_of_efx_nic");
  
#line 1034 
  spin_unlock_bh(lock);
  
#line 1035 
  return;
}


#line 1038  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void ldv_spin_lock_bh_102(spinlock_t *lock)
{
  
#line 1042 
  ldv_spin_model_lock((char *)"filter_lock_of_efx_nic");
  
#line 1044 
  spin_lock_bh(lock);
  
#line 1045 
  return;
}


#line 1048  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void ldv_spin_unlock_bh_103(spinlock_t *lock)
{
  
#line 1052 
  ldv_spin_model_unlock((char *)"filter_lock_of_efx_nic");
  
#line 1054 
  spin_unlock_bh(lock);
  
#line 1055 
  return;
}


#line 1058  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void ldv_spin_lock_bh_104(spinlock_t *lock)
{
  
#line 1062 
  ldv_spin_model_lock((char *)"filter_lock_of_efx_nic");
  
#line 1064 
  spin_lock_bh(lock);
  
#line 1065 
  return;
}


#line 1068  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void ldv_spin_unlock_bh_105(spinlock_t *lock)
{
  
#line 1072 
  ldv_spin_model_unlock((char *)"filter_lock_of_efx_nic");
  
#line 1074 
  spin_unlock_bh(lock);
  
#line 1075 
  return;
}


#line 1078  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void ldv_spin_lock_bh_106(spinlock_t *lock)
{
  
#line 1082 
  ldv_spin_model_lock((char *)"filter_lock_of_efx_nic");
  
#line 1084 
  spin_lock_bh(lock);
  
#line 1085 
  return;
}


#line 1088  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void ldv_spin_unlock_bh_107(spinlock_t *lock)
{
  
#line 1092 
  ldv_spin_model_unlock((char *)"filter_lock_of_efx_nic");
  
#line 1094 
  spin_unlock_bh(lock);
  
#line 1095 
  return;
}


#line 1098  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void ldv_spin_lock_bh_108(spinlock_t *lock)
{
  
#line 1102 
  ldv_spin_model_lock((char *)"filter_lock_of_efx_nic");
  
#line 1104 
  spin_lock_bh(lock);
  
#line 1105 
  return;
}


#line 1108  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void ldv_spin_unlock_bh_109(spinlock_t *lock)
{
  
#line 1112 
  ldv_spin_model_unlock((char *)"filter_lock_of_efx_nic");
  
#line 1114 
  spin_unlock_bh(lock);
  
#line 1115 
  return;
}


#line 1118  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void ldv_spin_lock_bh_110(spinlock_t *lock)
{
  
#line 1122 
  ldv_spin_model_lock((char *)"filter_lock_of_efx_nic");
  
#line 1124 
  spin_lock_bh(lock);
  
#line 1125 
  return;
}


#line 1128  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void ldv_spin_unlock_bh_111(spinlock_t *lock)
{
  
#line 1132 
  ldv_spin_model_unlock((char *)"filter_lock_of_efx_nic");
  
#line 1134 
  spin_unlock_bh(lock);
  
#line 1135 
  return;
}


#line 1138  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void ldv_spin_lock_bh_112(spinlock_t *lock)
{
  
#line 1142 
  ldv_spin_model_lock((char *)"filter_lock_of_efx_nic");
  
#line 1144 
  spin_lock_bh(lock);
  
#line 1145 
  return;
}


#line 1148  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_farch.c.aux"
static void ldv_spin_unlock_bh_113(spinlock_t *lock)
{
  
#line 1152 
  ldv_spin_model_unlock((char *)"filter_lock_of_efx_nic");
  
#line 1154 
  spin_unlock_bh(lock);
  
#line 1155 
  return;
}


#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/delay.h"
void __const_udelay(unsigned long);


#line 581  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kzalloc_0(size_t size, gfp_t flags);


#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mdio.h"
int mdio_set_flag(struct mdio_if_info const *, int, int, u16, int, bool);


#line 70 
void mdio45_ethtool_gset_npage(struct mdio_if_info const *, struct ethtool_cmd *, u32, u32);


#line 84  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mdio.h"
__inline static void mdio45_ethtool_gset(struct mdio_if_info const *mdio, struct ethtool_cmd *ecmd)
{
  
#line 87 
  mdio45_ethtool_gset_npage(mdio,ecmd,0U,0U);
  
#line 88 
  return;
}


#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mdio_10g.h"
__inline static int efx_mdio_read(struct efx_nic *efx, int devad, int addr)
{
  int tmp;
  
#line 27 
  tmp = (*(efx->mdio.mdio_read))(efx->net_dev,efx->mdio.prtad,devad,(unsigned short)((int)((unsigned short)addr)));
  
#line 27 
  return tmp;
}


#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mdio_10g.h"
__inline static void efx_mdio_write(struct efx_nic *efx, int devad, int addr, int value)
{
  
#line 33 
  (*(efx->mdio.mdio_write))(efx->net_dev,efx->mdio.prtad,devad,(unsigned short)((int)((unsigned short)addr)),(unsigned short)((int)((unsigned short)value)));
  
#line 34 
  return;
}


#line 67 
int efx_mdio_reset_mmd(struct efx_nic *port, int mmd, int spins, int spintime);


#line 70 
int efx_mdio_check_mmds(struct efx_nic *efx, unsigned int mmd_mask);


#line 73 
bool efx_mdio_links_ok(struct efx_nic *efx, unsigned int mmd_mask);


#line 76 
void efx_mdio_transmit_disable(struct efx_nic *efx);


#line 79 
void efx_mdio_phy_reconfigure(struct efx_nic *efx);


#line 82 
void efx_mdio_set_mmds_lpower(struct efx_nic *efx, int low_power, unsigned int mmd_mask);


#line 86 
int efx_mdio_set_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd);


#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mdio_10g.h"
__inline static void efx_mdio_set_flag(struct efx_nic *efx, int devad, int addr, int mask, bool state)
{
  
#line 104 
  mdio_set_flag((struct mdio_if_info const *)(& efx->mdio),efx->mdio.prtad,devad,(unsigned short)((int)((unsigned short)addr)),mask,(_Bool)((bool)((int)state) != 0));
  
#line 105 
  return;
}


#line 108 
int efx_mdio_test_alive(struct efx_nic *efx);


#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/phy.h"
struct efx_phy_operations const falcon_txc_phy_ops;


#line 47 
void falcon_txc_set_gpio_dir(struct efx_nic *efx, int pin, int dir);


#line 48 
void falcon_txc_set_gpio_val(struct efx_nic *efx, int pin, int on);


#line 312  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
__inline static struct falcon_board *falcon_board(struct efx_nic *efx)
{
  struct falcon_board *__retres;
  
#line 314 
  struct falcon_nic_data *data = (struct falcon_nic_data *)efx->nic_data;
  
#line 315 
  __retres = & data->board;
  
#line 315 
  return __retres;
}


#line 765 
int falcon_reset_xaui(struct efx_nic *efx);


#line 171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/txc43128_phy.c"
static void txc_reset_logic(struct efx_nic *efx);


#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/txc43128_phy.c"
void falcon_txc_set_gpio_val(struct efx_nic *efx, int pin, int on)
{
  
#line 176 
  efx_mdio_set_flag(efx,4,49990,1 << pin,(_Bool)(on != 0));
  
#line 177 
  return;
}


#line 180  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/txc43128_phy.c"
void falcon_txc_set_gpio_dir(struct efx_nic *efx, int pin, int dir)
{
  
#line 182 
  efx_mdio_set_flag(efx,4,49992,1 << pin,(_Bool)(dir != 0));
  
#line 183 
  return;
}


#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/txc43128_phy.c"
static int txc_reset_phy(struct efx_nic *efx)
{
  int __retres;
  
#line 189 
  int rc = efx_mdio_reset_mmd(efx,1,50,10);
  
#line 192 
  if (rc < 0) 
#line 193 
              goto fail; else ;
  
#line 196 
  rc = efx_mdio_check_mmds(efx,26U);
  
#line 197 
  if (rc < 0) 
#line 198 
              goto fail; else ;
  
#line 200 
  __retres = 0;
  
#line 200 
  goto return_label;
  fail: 
#line 202 
  ;
  
#line 203 
  if ((efx->msg_enable & 8192U) != 0U) 
#line 203 
                                       netdev_err((struct net_device const *)efx->net_dev,"TXC43128"); else ;
  
#line 204 
  __retres = rc;
  return_label: 
#line 204 
                return __retres;
}


#line 208  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/txc43128_phy.c"
static int txc_bist_one(struct efx_nic *efx, int mmd, int test)
{
  int ctrl;
  int bctl;
  int lane;
  
#line 212 
  int rc = 0;
  
#line 215 
  ctrl = efx_mdio_read(efx,3,49999);
  
#line 216 
  ctrl |= 1024;
  
#line 217 
  efx_mdio_write(efx,3,49999,ctrl);
  
#line 221 
  bctl = test << 10;
  
#line 222 
  efx_mdio_write(efx,mmd,49792,bctl);
  
#line 225 
  bctl |= 8192;
  
#line 226 
  efx_mdio_write(efx,mmd,49792,bctl);
  
#line 229 
  efx_mdio_write(efx,mmd,49792,bctl | 32768);
  
#line 233 
  __const_udelay(214750UL);
  
#line 236 
  bctl |= 16384;
  
#line 237 
  efx_mdio_write(efx,mmd,49792,bctl);
  
#line 240 
  goto ldv_55590;
  ldv_55589: 
#line 241 
  ;
  
#line 241 
  bctl = efx_mdio_read(efx,mmd,49792);
  ldv_55590: 
#line 242 
  ;
  
#line 240 
  if ((bctl & 16384) != 0) 
#line 242 
                           goto ldv_55589; else 
#line 245 
                                                goto ldv_55591;
  ldv_55591: 
#line 246 
  ;
  
#line 245 
  lane = 0;
  
#line 245 
  goto ldv_55594;
  ldv_55593: 
#line 246 
  ;
  {
    
#line 246 
    int count = efx_mdio_read(efx,mmd,lane + 49798);
    
#line 247 
    if (count != 0) {
      
#line 248 
      if ((efx->msg_enable & 8192U) != 0U) 
#line 248 
                                           netdev_err((struct net_device const *)efx->net_dev,"TXC43128",lane,count); else ;
      
#line 250 
      rc = -5;
    }
    else ;
    
#line 252 
    count = efx_mdio_read(efx,mmd,lane + 49794);
    
#line 253 
    if (count == 0) {
      
#line 254 
      if ((efx->msg_enable & 8192U) != 0U) 
#line 254 
                                           netdev_err((struct net_device const *)efx->net_dev,"TXC43128",lane); else ;
      
#line 256 
      rc = -5;
    }
    else ;
  }
  
#line 245 
  lane += 1;
  ldv_55594: 
#line 246 
  ;
  
#line 245 
  if (lane <= 3) 
#line 247 
                 goto ldv_55593; else 
#line 250 
                                      goto ldv_55595;
  ldv_55595: 
#line 251 
  ;
  
#line 260 
  if (rc == 0) {
    
#line 261 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 261 
                                         netdev_info((struct net_device const *)efx->net_dev,"TXC43128"); else ;
  }
  else ;
  
#line 264 
  efx_mdio_write(efx,mmd,49792,0);
  
#line 267 
  ctrl &= -1025;
  
#line 268 
  efx_mdio_write(efx,3,49999,ctrl);
  
#line 270 
  return rc;
}


#line 273  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/txc43128_phy.c"
static int txc_bist(struct efx_nic *efx)
{
  int tmp;
  
#line 275 
  tmp = txc_bist_one(efx,3,0);
  
#line 275 
  return tmp;
}


#line 280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/txc43128_phy.c"
static void txc_apply_defaults(struct efx_nic *efx)
{
  int mctrl;
  struct falcon_board *tmp;
  
#line 290 
  efx_mdio_write(efx,4,49219,0);
  
#line 291 
  efx_mdio_write(efx,4,49220,0);
  
#line 294 
  efx_mdio_write(efx,4,49217,51400);
  
#line 296 
  efx_mdio_write(efx,4,49218,51400);
  
#line 302 
  efx_mdio_write(efx,1,49219,4112);
  
#line 304 
  efx_mdio_write(efx,1,49220,4112);
  
#line 306 
  efx_mdio_write(efx,1,49217,24672);
  
#line 308 
  efx_mdio_write(efx,1,49218,24672);
  
#line 312 
  mctrl = efx_mdio_read(efx,4,49984);
  
#line 315 
  mctrl &= -24577;
  
#line 316 
  efx_mdio_write(efx,4,49984,mctrl);
  
#line 319 
  txc_reset_logic(efx);
  
#line 321 
  tmp = falcon_board(efx);
  
#line 321 
  (*((tmp->type)->init_phy))(efx);
  
#line 322 
  return;
}


#line 324  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/txc43128_phy.c"
static int txc43128_phy_probe(struct efx_nic *efx)
{
  int __retres;
  struct txc43128_data *phy_data;
  
#line 329 
  phy_data = (struct txc43128_data *)kzalloc_0(16UL,208U);
  
#line 330 
  if (phy_data == (struct txc43128_data *)0) {
    
#line 331 
    __retres = -12;
    
#line 331 
    goto return_label;
  }
  else ;
  
#line 332 
  efx->phy_data = (void *)phy_data;
  
#line 333 
  phy_data->phy_mode = efx->phy_mode;
  
#line 335 
  efx->mdio.mmds = 26U;
  
#line 336 
  efx->mdio.mode_support = 6U;
  
#line 338 
  efx->loopback_modes = 67305528ULL;
  
#line 340 
  __retres = 0;
  return_label: 
#line 340 
                return __retres;
}


#line 344  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/txc43128_phy.c"
static int txc43128_phy_init(struct efx_nic *efx)
{
  int __retres;
  int rc;
  
#line 348 
  rc = txc_reset_phy(efx);
  
#line 349 
  if (rc < 0) {
    
#line 350 
    __retres = rc;
    
#line 350 
    goto return_label;
  }
  else ;
  
#line 352 
  rc = txc_bist(efx);
  
#line 353 
  if (rc < 0) {
    
#line 354 
    __retres = rc;
    
#line 354 
    goto return_label;
  }
  else ;
  
#line 356 
  txc_apply_defaults(efx);
  
#line 358 
  __retres = 0;
  return_label: 
#line 358 
                return __retres;
}


#line 362  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/txc43128_phy.c"
static void txc_glrgs_lane_power(struct efx_nic *efx, int mmd)
{
  
#line 364 
  int pd = 96;
  
#line 365 
  int ctl = efx_mdio_read(efx,mmd,49156);
  
#line 367 
  if (((unsigned int)efx->phy_mode & 2U) == 0U) 
#line 368 
                                                ctl = ~ pd & ctl; else 
                                                                    
#line 370 
                                                                    ctl |= pd;
  
#line 372 
  efx_mdio_write(efx,mmd,49156,ctl);
  
#line 373 
  return;
}


#line 376  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/txc43128_phy.c"
static void txc_analog_lane_power(struct efx_nic *efx, int mmd)
{
  
#line 378 
  int txpd = 61440;
  
#line 380 
  int rxpd = 61440;
  
#line 382 
  int txctl = efx_mdio_read(efx,mmd,49216);
  
#line 383 
  int rxctl = efx_mdio_read(efx,mmd,49221);
  
#line 385 
  if (((unsigned int)efx->phy_mode & 2U) == 0U) {
    
#line 386 
    txctl = ~ txpd & txctl;
    
#line 387 
    rxctl = ~ rxpd & rxctl;
  }
  else {
    
#line 389 
    txctl |= txpd;
    
#line 390 
    rxctl |= rxpd;
  }
  
#line 393 
  efx_mdio_write(efx,mmd,49216,txctl);
  
#line 394 
  efx_mdio_write(efx,mmd,49221,rxctl);
  
#line 395 
  return;
}


#line 397  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/txc43128_phy.c"
static void txc_set_power(struct efx_nic *efx)
{
  
#line 400 
  efx_mdio_set_mmds_lpower(efx,((unsigned int)efx->phy_mode & 2U) != 0U,26U);
  
#line 406 
  txc_glrgs_lane_power(efx,3);
  
#line 407 
  txc_glrgs_lane_power(efx,4);
  
#line 410 
  txc_analog_lane_power(efx,1);
  
#line 411 
  txc_analog_lane_power(efx,4);
  
#line 412 
  return;
}


#line 414  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/txc43128_phy.c"
static void txc_reset_logic_mmd(struct efx_nic *efx, int mmd)
{
  int tmp_0;
  
#line 416 
  int val = efx_mdio_read(efx,mmd,49156);
  
#line 417 
  int tries = 50;
  
#line 419 
  val |= 16384;
  
#line 420 
  efx_mdio_write(efx,mmd,49156,val);
  
#line 421 
  goto ldv_55636;
  ldv_55635: 
#line 422 
  ;
  
#line 422 
  val = efx_mdio_read(efx,mmd,49156);
  
#line 423 
  if ((val & 16384) == 0) 
#line 424 
                          goto ldv_55634; else ;
  
#line 425 
  __const_udelay(4295UL);
  ldv_55636: 
#line 427 
  ;
  
#line 421 
  tmp_0 = tries;
  
#line 421 
  tries -= 1;
  
#line 421 
  ;
  
#line 421 
  if (tmp_0 != 0) 
#line 423 
                  goto ldv_55635; else 
#line 426 
                                       goto ldv_55634;
  ldv_55634: 
#line 427 
  ;
  
#line 427 
  if (tries == 0) {
    
#line 428 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 428 
                                         netdev_info((struct net_device const *)efx->net_dev,"TXC43128"); else ;
  }
  else ;
  
#line 429 
  return;
}


#line 434  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/txc43128_phy.c"
static void txc_reset_logic(struct efx_nic *efx)
{
  
#line 439 
  txc_reset_logic_mmd(efx,3);
  
#line 440 
  return;
}


#line 442  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/txc43128_phy.c"
static bool txc43128_phy_read_link(struct efx_nic *efx)
{
  bool tmp;
  
#line 444 
  tmp = efx_mdio_links_ok(efx,26U);
  
#line 444 
  return tmp;
}


#line 447  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/txc43128_phy.c"
static int txc43128_phy_reconfigure(struct efx_nic *efx)
{
  int __retres;
  
#line 449 
  struct txc43128_data *phy_data = (struct txc43128_data *)efx->phy_data;
  
#line 450 
  enum efx_phy_mode mode_change = (unsigned int)efx->phy_mode ^ (unsigned int)phy_data->phy_mode;
  
#line 451 
  bool loop_change = (_Bool)((((1 << (unsigned int)phy_data->loopback_mode) ^ (1 << (unsigned int)efx->loopback_mode)) & 67305472) != 0);
  
#line 453 
  if ((((unsigned int)efx->phy_mode & (unsigned int)mode_change) & 1U) != 0U) {
    
#line 454 
    txc_reset_phy(efx);
    
#line 455 
    txc_apply_defaults(efx);
    
#line 456 
    falcon_reset_xaui(efx);
    
#line 457 
    mode_change = (enum efx_phy_mode)((unsigned int)mode_change & 4294967294U);
  }
  else ;
  
#line 460 
  efx_mdio_transmit_disable(efx);
  
#line 461 
  efx_mdio_phy_reconfigure(efx);
  
#line 462 
  if (((unsigned int)mode_change & 2U) != 0U) 
#line 463 
                                              txc_set_power(efx); else ;
  
#line 469 
  if ((int)loop_change != 0 || mode_change != (unsigned int)PHY_MODE_NORMAL) 
    
#line 470 
    txc_reset_logic(efx); else ;
  
#line 472 
  phy_data->phy_mode = efx->phy_mode;
  
#line 473 
  phy_data->loopback_mode = efx->loopback_mode;
  
#line 475 
  __retres = 0;
  
#line 475 
  return __retres;
}


#line 478  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/txc43128_phy.c"
static void txc43128_phy_fini(struct efx_nic *efx)
{
  
#line 481 
  efx_mdio_write(efx,1,36866,0);
  
#line 482 
  return;
}


#line 484  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/txc43128_phy.c"
static void txc43128_phy_remove(struct efx_nic *efx)
{
  
#line 486 
  kfree((void const *)efx->phy_data);
  
#line 487 
  efx->phy_data = (void *)0;
  
#line 488 
  return;
}


#line 492  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/txc43128_phy.c"
static bool txc43128_phy_poll(struct efx_nic *efx)
{
  bool __retres;
  
#line 494 
  struct txc43128_data *data = (struct txc43128_data *)efx->phy_data;
  
#line 495 
  bool was_up = efx->link_state.up;
  
#line 497 
  efx->link_state.up = txc43128_phy_read_link(efx);
  
#line 498 
  efx->link_state.speed = 10000U;
  
#line 499 
  efx->link_state.fd = (_Bool)1;
  
#line 500 
  efx->link_state.fc = efx->wanted_fc;
  
#line 502 
  if ((int)efx->link_state.up != 0 || efx->loopback_mode != (unsigned int)LOOPBACK_NONE) 
    
#line 503 
    data->bug10934_timer = jiffies;
  else {
    int tmp;
    {
      unsigned long __dummy;
      unsigned long volatile __dummy2;
      
#line 505 
      tmp = 1;
    }
    
#line 505 
    if (tmp != 0) {
      int tmp_0;
      {
        unsigned long __dummy_0;
        unsigned long __dummy2_0;
        
#line 505 
        tmp_0 = 1;
      }
      
#line 505 
      if (tmp_0 != 0) {
        
#line 505 
        if ((long)((jiffies - data->bug10934_timer) + 18446744073709550366UL) >= 0L) {
          
#line 507 
          data->bug10934_timer = jiffies;
          
#line 508 
          txc_reset_logic(efx);
        }
        else ;
      }
      else ;
    }
    else ;
  }
  
#line 512 
  __retres = (_Bool)((int)efx->link_state.up != (int)was_up);
  
#line 512 
  return __retres;
}


#line 515  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/txc43128_phy.c"
static char const * const txc43128_test_names[1U] = {"bist"};

#line 519  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/txc43128_phy.c"
static char const *txc43128_test_name(struct efx_nic *efx, unsigned int index)
{
  char const *__retres;
  
#line 521 
  if (index == 0U) {
    
#line 522 
    __retres = txc43128_test_names[index];
    
#line 522 
    goto return_label;
  }
  else ;
  
#line 523 
  __retres = (char const *)0;
  return_label: 
#line 523 
                return __retres;
}


#line 526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/txc43128_phy.c"
static int txc43128_run_tests(struct efx_nic *efx, int *results, unsigned int flags)
{
  int __retres;
  int rc;
  
#line 530 
  if ((flags & 1U) == 0U) {
    
#line 531 
    __retres = 0;
    
#line 531 
    goto return_label;
  }
  else ;
  
#line 533 
  rc = txc_reset_phy(efx);
  
#line 534 
  if (rc < 0) {
    
#line 535 
    __retres = rc;
    
#line 535 
    goto return_label;
  }
  else ;
  
#line 537 
  rc = txc_bist(efx);
  
#line 538 
  txc_apply_defaults(efx);
  
#line 539 
  if (rc != 0) 
#line 539 
               *results = -1; else 
#line 539 
                                   *results = 1;
  
#line 540 
  __retres = rc;
  return_label: 
#line 540 
                return __retres;
}


#line 543  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/txc43128_phy.c"
static void txc43128_get_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd)
{
  
#line 545 
  mdio45_ethtool_gset((struct mdio_if_info const *)(& efx->mdio),ecmd);
  
#line 546 
  return;
}


#line 548  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/txc43128_phy.c"
struct efx_phy_operations const falcon_txc_phy_ops = {.probe = & txc43128_phy_probe, .init = & txc43128_phy_init, .fini = & txc43128_phy_fini, .remove = & txc43128_phy_remove, .reconfigure = & txc43128_phy_reconfigure, .poll = & txc43128_phy_poll, .get_settings = & txc43128_get_settings, .set_settings = & efx_mdio_set_settings, .set_npage_adv = (void (*)(struct efx_nic *, u32 ))0, .test_alive = & efx_mdio_test_alive, .test_name = & txc43128_test_name, .run_tests = & txc43128_run_tests, .get_module_eeprom = (int (*)(struct efx_nic *, struct ethtool_eeprom *, u8 *))0, .get_module_info = (int (*)(struct efx_nic *, struct ethtool_modinfo *))0};

#line 441  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_txc43128_phy.c.aux"
static void *kzalloc_0(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 444 
  tmp = ldv_kzalloc(size,flags);
  
#line 444 
  return tmp;
}


#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/bitops/find.h"
unsigned long find_next_bit(unsigned long const *, unsigned long, unsigned long);


#line 42 
unsigned long find_first_bit(unsigned long const *, unsigned long);


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/byteorder/little_endian.h"
__inline static __u64 __le64_to_cpup(__le64 const *p)
{
  __u64 __retres;
  
#line 49 
  __retres = *p;
  
#line 49 
  return __retres;
}


#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/byteorder/little_endian.h"
__inline static __u32 __le32_to_cpup(__le32 const *p)
{
  __u32 __retres;
  
#line 57 
  __retres = *p;
  
#line 57 
  return __retres;
}


#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/byteorder/little_endian.h"
__inline static __u16 __le16_to_cpup(__le16 const *p)
{
  __u16 __retres;
  
#line 65 
  __retres = *p;
  
#line 65 
  return __retres;
}


#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/string.h"
size_t strlcpy(char *, char const *, size_t);


#line 470  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_irqrestore_0(spinlock_t *lock, unsigned long flags)
{
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
  }
  
#line 472 
  _raw_spin_unlock_irqrestore(& lock->__anonCompField_spinlock_18.rlock,flags);
  
#line 473 
  return;
}


#line 510 
static void ldv_spin_unlock_irqrestore_92_0(spinlock_t *lock, unsigned long flags);


#line 514 
static void ldv_spin_unlock_irqrestore_94(spinlock_t *lock, unsigned long flags);


#line 78  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_nic.c.aux"
static void ldv___ldv_spin_lock_91_0(spinlock_t *ldv_func_arg1);


#line 82 
static void ldv___ldv_spin_lock_93(spinlock_t *ldv_func_arg1);


#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static unsigned long readq(void const volatile *addr)
{
  unsigned long ret;
  
#line 91 
  ldv_inline_asm();
  
#line 90 
  return ret;
}


#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
static int ldv_request_irq_97(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev);


#line 145 
static int ldv_request_irq_98(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev);


#line 157 
static void ldv_free_irq_99(unsigned int ldv_func_arg1, void *ldv_func_arg2);


#line 161 
static void ldv_free_irq_100(unsigned int ldv_func_arg1, void *ldv_func_arg2);


#line 165 
static void ldv_free_irq_101(unsigned int ldv_func_arg1, void *ldv_func_arg2);


#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
void *dma_alloc_attrs(struct device *, size_t, dma_addr_t *, gfp_t, struct dma_attrs *);


#line 136 
void dma_free_attrs(struct device *, size_t, void *, dma_addr_t, struct dma_attrs *);


#line 183  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
__inline static void *dma_zalloc_coherent(struct device *dev, size_t size, dma_addr_t *dma_handle, gfp_t flag)
{
  
#line 186 
  void *ret = dma_alloc_attrs(dev,size,dma_handle,flag | 32768U,(struct dma_attrs *)0);
  
#line 188 
  return ret;
}


#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpu_rmap.h"
struct cpu_rmap *alloc_cpu_rmap(unsigned int, gfp_t);


#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpu_rmap.h"
__inline static struct cpu_rmap *alloc_irq_cpu_rmap(unsigned int size)
{
  struct cpu_rmap *tmp;
  
#line 63 
  tmp = alloc_cpu_rmap(size,208U);
  
#line 63 
  return tmp;
}


#line 65 
void free_irq_cpu_rmap(struct cpu_rmap *);


#line 67 
int irq_cpu_rmap_add(struct cpu_rmap *, int);


#line 664  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
void efx_nic_event_test_start(struct efx_channel *channel);


#line 715 
bool efx_nic_event_present(struct efx_channel *channel);


#line 736 
int efx_nic_init_interrupt(struct efx_nic *efx);


#line 737 
void efx_nic_irq_test_start(struct efx_nic *efx);


#line 738 
void efx_nic_fini_interrupt(struct efx_nic *efx);


#line 784 
size_t efx_nic_get_regs_len(struct efx_nic *efx);


#line 785 
void efx_nic_get_regs(struct efx_nic *efx, void *buf);


#line 787 
size_t efx_nic_describe_stats(struct efx_hw_stat_desc const *desc, size_t count, unsigned long const *mask, u8 *names);


#line 789 
void efx_nic_update_stats(struct efx_hw_stat_desc const *desc, size_t count, unsigned long const *mask, u64 *stats, void const *dma_buf, bool accumulate);


#line 792 
void efx_nic_fix_nodesc_drop_stat(struct efx_nic *efx, u64 *rx_nodesc_drops);


#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/io.h"
__inline static void efx_reado_0(struct efx_nic *efx, efx_oword_t *value, unsigned int reg)
{
  unsigned long flags;
  
#line 167 
  ldv___ldv_spin_lock_91_0(& efx->biu_lock);
  
#line 168 
  value->u32[0] = _efx_readd(efx,reg);
  
#line 169 
  value->u32[1] = _efx_readd(efx,reg + 4U);
  
#line 170 
  value->u32[2] = _efx_readd(efx,reg + 8U);
  
#line 171 
  value->u32[3] = _efx_readd(efx,reg + 12U);
  
#line 172 
  ldv_spin_unlock_irqrestore_92_0(& efx->biu_lock,flags);
  
#line 176 
  return;
}


#line 180  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/io.h"
__inline static void efx_sram_readq(struct efx_nic *efx, void *membase, efx_qword_t *value, unsigned int index)
{
  unsigned long flags;
  
#line 183 
  unsigned int addr = index * 8U;
  
#line 186 
  ldv___ldv_spin_lock_93(& efx->biu_lock);
  
#line 188 
  value->u64[0] = (__le64)readq((void const volatile *)(membase + addr));
  
#line 193 
  ldv_spin_unlock_irqrestore_94(& efx->biu_lock,flags);
  
#line 197 
  return;
}


#line 219  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/io.h"
__inline static void efx_reado_table_0(struct efx_nic *efx, efx_oword_t *value, unsigned int reg, unsigned int index)
{
  
#line 222 
  efx_reado_0(efx,value,index * 16U + reg);
  
#line 223 
  return;
}


#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.c"
int efx_nic_alloc_buffer(struct efx_nic *efx, struct efx_buffer *buffer, unsigned int len, gfp_t gfp_flags)
{
  int __retres;
  
#line 37 
  buffer->addr = dma_zalloc_coherent(& (efx->pci_dev)->dev,(unsigned long)len,& buffer->dma_addr,gfp_flags);
  
#line 39 
  if (buffer->addr == (void *)0) {
    
#line 40 
    __retres = -12;
    
#line 40 
    goto return_label;
  }
  else ;
  
#line 41 
  buffer->len = len;
  
#line 42 
  __retres = 0;
  return_label: 
#line 42 
                return __retres;
}


#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.c"
void efx_nic_free_buffer(struct efx_nic *efx, struct efx_buffer *buffer)
{
  
#line 47 
  if (buffer->addr != (void *)0) {
    
#line 48 
    dma_free_attrs(& (efx->pci_dev)->dev,(unsigned long)buffer->len,buffer->addr,buffer->dma_addr,(struct dma_attrs *)0);
    
#line 50 
    buffer->addr = (void *)0;
  }
  else ;
  
#line 52 
  return;
}


#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.c"
bool efx_nic_event_present(struct efx_channel *channel)
{
  bool __retres;
  int tmp_0;
  efx_qword_t *tmp;
  
#line 59 
  tmp = efx_event(channel,channel->eventq_read_ptr);
  
#line 59 
  tmp_0 = efx_event_present(tmp);
  
#line 59 
  __retres = (_Bool)(tmp_0 != 0);
  
#line 59 
  return __retres;
}


#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.c"
void efx_nic_event_test_start(struct efx_channel *channel)
{
  
#line 64 
  channel->event_test_cpu = -1;
  
#line 65 
  ldv_inline_asm();
  
#line 66 
  (*(((channel->efx)->type)->ev_test_generate))(channel);
  
#line 67 
  return;
}


#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.c"
void efx_nic_irq_test_start(struct efx_nic *efx)
{
  
#line 71 
  efx->last_irq_cpu = -1;
  
#line 72 
  ldv_inline_asm();
  
#line 73 
  (*((efx->type)->irq_test_generate))(efx);
  
#line 74 
  return;
}


#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.c"
int efx_nic_init_interrupt(struct efx_nic *efx)
{
  int __retres;
  struct efx_channel *channel;
  unsigned int n_irqs;
  int rc;
  unsigned int tmp;
  
#line 85 
  if (efx->interrupt_mode > (unsigned int)EFX_INT_MODE_MSI) {
    
#line 86 
    rc = ldv_request_irq_97((unsigned int)efx->legacy_irq,(efx->type)->irq_handle_legacy,128UL,(char const *)(& efx->name),(void *)efx);
    
#line 89 
    if (rc != 0) {
      
#line 90 
      if ((efx->msg_enable & 1U) != 0U) 
#line 90 
                                        netdev_err((struct net_device const *)efx->net_dev,"failed to hook legacy IRQ %d\n",(efx->pci_dev)->irq); else ;
      
#line 93 
      goto fail1;
    }
    else ;
    
#line 95 
    __retres = 0;
    
#line 95 
    goto return_label;
  }
  else ;
  
#line 99 
  if (efx->interrupt_mode == (unsigned int)EFX_INT_MODE_MSIX) {
    
#line 100 
    (efx->net_dev)->rx_cpu_rmap = alloc_irq_cpu_rmap(efx->n_rx_channels);
    
#line 102 
    if ((efx->net_dev)->rx_cpu_rmap == (struct cpu_rmap *)0) {
      
#line 103 
      rc = -12;
      
#line 104 
      goto fail1;
    }
    else ;
  }
  else ;
  
#line 110 
  n_irqs = 0U;
  
#line 111 
  channel = efx->channel[0];
  
#line 111 
  goto ldv_56642;
  ldv_56641: 
#line 112 
  ;
  
#line 112 
  rc = ldv_request_irq_98((unsigned int)channel->irq,(efx->type)->irq_handle_msi,256UL,(char const *)(& efx->msi_context[channel->channel].name),(void *)(& efx->msi_context[channel->channel]));
  
#line 116 
  if (rc != 0) {
    
#line 117 
    if ((efx->msg_enable & 1U) != 0U) 
#line 117 
                                      netdev_err((struct net_device const *)efx->net_dev,"failed to hook IRQ %d\n",channel->irq); else ;
    
#line 119 
    goto fail2;
  }
  else ;
  
#line 121 
  n_irqs += 1U;
  
#line 124 
  if (efx->interrupt_mode == (unsigned int)EFX_INT_MODE_MSIX && (unsigned int)channel->channel < efx->n_rx_channels) {
    
#line 126 
    rc = irq_cpu_rmap_add((efx->net_dev)->rx_cpu_rmap,channel->irq);
    
#line 128 
    if (rc != 0) 
#line 129 
                 goto fail2; else ;
  }
  else ;
  
#line 111 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 111 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 111 
                                                                    channel = (struct efx_channel *)0;
  ldv_56642: 
#line 112 
  ;
  
#line 111 
  if (channel != (struct efx_channel *)0) 
#line 113 
                                          goto ldv_56641; else 
#line 116 
                                                               goto ldv_56643;
  ldv_56643: 
#line 117 
  ;
  
#line 134 
  __retres = 0;
  
#line 134 
  goto return_label;
  fail2: 
#line 136 
  ;
  
#line 138 
  free_irq_cpu_rmap((efx->net_dev)->rx_cpu_rmap);
  
#line 139 
  (efx->net_dev)->rx_cpu_rmap = (struct cpu_rmap *)0;
  
#line 141 
  channel = efx->channel[0];
  
#line 141 
  goto ldv_56646;
  ldv_56645: 
#line 142 
  ;
  
#line 142 
  tmp = n_irqs;
  
#line 142 
  n_irqs -= 1U;
  
#line 142 
  ;
  
#line 142 
  if (tmp == 0U) 
#line 143 
                 goto ldv_56644; else ;
  
#line 144 
  ldv_free_irq_99((unsigned int)channel->irq,(void *)(& efx->msi_context[channel->channel]));
  
#line 141 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 141 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 141 
                                                                    channel = (struct efx_channel *)0;
  ldv_56646: 
#line 142 
  ;
  
#line 141 
  if (channel != (struct efx_channel *)0) 
#line 143 
                                          goto ldv_56645; else 
#line 146 
                                                               goto ldv_56644;
  ldv_56644: 
#line 147 
  ;
  fail1: 
#line 146 
  ;
  
#line 147 
  __retres = rc;
  return_label: 
#line 147 
                return __retres;
}


#line 150  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.c"
void efx_nic_fini_interrupt(struct efx_nic *efx)
{
  struct efx_channel *channel;
  
#line 155 
  free_irq_cpu_rmap((efx->net_dev)->rx_cpu_rmap);
  
#line 156 
  (efx->net_dev)->rx_cpu_rmap = (struct cpu_rmap *)0;
  
#line 159 
  if (efx->interrupt_mode <= (unsigned int)EFX_INT_MODE_MSI) {
    
#line 161 
    channel = efx->channel[0];
    
#line 161 
    goto ldv_56652;
    ldv_56651: 
#line 162 
    ;
    
#line 162 
    ldv_free_irq_100((unsigned int)channel->irq,(void *)(& efx->msi_context[channel->channel]));
    
#line 161 
    if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 161 
                                                                channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 161 
                                                                    channel = (struct efx_channel *)0;
    ldv_56652: 
#line 162 
    ;
    
#line 161 
    if (channel != (struct efx_channel *)0) 
#line 163 
                                            goto ldv_56651; else 
#line 166 
                                                                 goto ldv_56653;
    ldv_56653: 
#line 167 
    ;
  }
  else 
#line 166 
       ldv_free_irq_101((unsigned int)efx->legacy_irq,(void *)efx);
  
#line 167 
  return;
}


#line 197  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.c"
static struct efx_nic_reg const efx_nic_regs[86U] = {{.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))0U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))16U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))32U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))48U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))64U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))192U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))256U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))256U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))272U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))288U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))304U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))320U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))512U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))528U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))544U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))592U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))608U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))624U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))768U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))784U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))800U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))816U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))832U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))1104U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))1120U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))1136U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))1536U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))1552U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))1568U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))1584U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))1632U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))1648U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))2048U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))2064U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))2112U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))2128U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))2144U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))2192U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))2256U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))2272U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))2288U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))2592U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))2608U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))2640U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))2688U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))2704U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))2784U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))2800U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))3072U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))3088U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))3104U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))3120U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))3136U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))3168U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))3200U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))3216U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))3232U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))3248U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))3584U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))3600U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))3648U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))3840U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))3856U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))3872U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))3888U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))3904U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))3920U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))3936U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))3952U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))4352U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))4608U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))4624U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))4640U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))4656U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))4672U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))4688U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))4720U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))4752U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))4816U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))4832U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))4864U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))4880U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))4896U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))0U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))512U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))516U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U}};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.c"
static struct efx_nic_reg_table const efx_nic_reg_tables[23U] = {{.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))2816U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .step = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))16U, .rows = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(21))))16U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))4096U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .step = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))16U, .rows = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(21))))16U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))71680U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .step = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))16U, .rows = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(21))))4U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))15990784U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .step = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))16U, .rows = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(21))))4096U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))15990784U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .step = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))16U, .rows = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(21))))1024U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))71936U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .step = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))16U, .rows = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(21))))8U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))16056320U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .step = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))16U, .rows = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(21))))4096U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))16056320U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .step = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))16U, .rows = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(21))))1024U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))72192U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .step = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))16U, .rows = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(21))))4U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))16121856U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .step = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))16U, .rows = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(21))))4096U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))16121856U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .step = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))16U, .rows = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(21))))1024U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))98304U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .step = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))8U, .rows = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(21))))1024U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))8388608U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .step = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))8U, .rows = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(21))))1024U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))15728656U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .step = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))32U, .rows = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(21))))512U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))16187392U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .step = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))16U, .rows = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(21))))4096U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))16187392U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .step = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))16U, .rows = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(21))))1024U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))16252928U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .step = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))16U, .rows = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(21))))4096U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))16252928U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .step = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))16U, .rows = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(21))))1024U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))16449536U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .step = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))16U, .rows = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(21))))128U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))16646144U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .step = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))16U, .rows = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(21))))512U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))16711680U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .step = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))4U, .rows = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(21))))512U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))15728640U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .step = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))32U, .rows = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(21))))8192U}, {.offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))))16U, .min_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .max_revision = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .step = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))4U, .rows = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(21))))8U}};

#line 371  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.c"
size_t efx_nic_get_regs_len(struct efx_nic *efx)
{
  struct efx_nic_reg const *reg;
  struct efx_nic_reg_table const *table;
  
#line 375 
  size_t len = 0UL;
  
#line 377 
  reg = (struct efx_nic_reg const *)(& efx_nic_regs);
  
#line 377 
  goto ldv_56678;
  ldv_56677: 
#line 378 
  ;
  
#line 380 
  if ((efx->type)->revision >= (int)reg->min_revision && (efx->type)->revision <= (int)reg->max_revision) 
    
#line 382 
    len += 16UL; else ;
  
#line 379 
  reg += 1;
  ldv_56678: 
#line 380 
  ;
  
#line 377 
  if (reg < (struct efx_nic_reg const *)(& efx_nic_regs) + 86U) 
#line 380 
                                                                goto ldv_56677; else 
                                                                    
#line 383 
                                                                    goto ldv_56679;
  ldv_56679: 
#line 384 
  ;
  
#line 384 
  table = (struct efx_nic_reg_table const *)(& efx_nic_reg_tables);
  
#line 384 
  goto ldv_56687;
  ldv_56686: 
#line 385 
  ;
  
#line 387 
  if ((efx->type)->revision >= (int)table->min_revision && (efx->type)->revision <= (int)table->max_revision) {
    size_t tmp_0;
    {
      size_t tmp;
      
#line 389 
      size_t __min1 = (unsigned long)table->step;
      
#line 389 
      size_t __min2 = 16UL;
      
#line 389 
      if (__min1 < __min2) 
#line 389 
                           tmp = __min1; else 
#line 389 
                                              tmp = __min2;
      
#line 389 
      tmp_0 = tmp;
    }
    
#line 389 
    len = (unsigned long)table->rows * tmp_0 + len;
  }
  else ;
  
#line 386 
  table += 1;
  ldv_56687: 
#line 387 
  ;
  
#line 384 
  if (table < (struct efx_nic_reg_table const *)(& efx_nic_reg_tables) + 23U) 
    
#line 387 
    goto ldv_56686; else 
#line 390 
                         goto ldv_56688;
  ldv_56688: 
#line 391 
  ;
  
#line 391 
  return len;
}


#line 394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.c"
void efx_nic_get_regs(struct efx_nic *efx, void *buf)
{
  struct efx_nic_reg const *reg;
  struct efx_nic_reg_table const *table;
  
#line 399 
  reg = (struct efx_nic_reg const *)(& efx_nic_regs);
  
#line 399 
  goto ldv_56699;
  ldv_56698: 
#line 400 
  ;
  
#line 402 
  if ((efx->type)->revision >= (int)reg->min_revision && (efx->type)->revision <= (int)reg->max_revision) {
    
#line 404 
    efx_reado_0(efx,(efx_oword_t *)buf,(unsigned int)reg->offset);
    
#line 405 
    buf += 16U;
  }
  else ;
  
#line 401 
  reg += 1;
  ldv_56699: 
#line 402 
  ;
  
#line 399 
  if (reg < (struct efx_nic_reg const *)(& efx_nic_regs) + 86U) 
#line 402 
                                                                goto ldv_56698; else 
                                                                    
#line 405 
                                                                    goto ldv_56700;
  ldv_56700: 
#line 406 
  ;
  
#line 409 
  table = (struct efx_nic_reg_table const *)(& efx_nic_reg_tables);
  
#line 409 
  goto ldv_56722;
  ldv_56721: 
#line 410 
  ;
  {
    size_t size;
    size_t i;
    size_t tmp_0;
    
#line 414 
    if ((efx->type)->revision < (int)table->min_revision || (efx->type)->revision > (int)table->max_revision) 
      
#line 416 
      goto ldv_56706; else ;
    {
      size_t tmp;
      
#line 418 
      size_t __min1 = (unsigned long)table->step;
      
#line 418 
      size_t __min2 = 16UL;
      
#line 418 
      if (__min1 < __min2) 
#line 418 
                           tmp = __min1; else 
#line 418 
                                              tmp = __min2;
      
#line 418 
      tmp_0 = tmp;
    }
    
#line 418 
    size = tmp_0;
    
#line 420 
    i = 0UL;
    
#line 420 
    goto ldv_56719;
    ldv_56718: 
#line 421 
    ;
    
#line 421 
    switch ((int)table->step) {
      case 4: 
#line 422 
      ;
      
#line 423 
      efx_readd(efx,(efx_dword_t *)buf,(unsigned int)table->offset + (unsigned int)i * 4U);
      
#line 424 
      goto ldv_56711;
      case 8: 
#line 425 
      ;
      
#line 426 
      efx_sram_readq(efx,efx->membase + (int)table->offset,(efx_qword_t *)buf,(unsigned int)i);
      
#line 429 
      goto ldv_56711;
      case 16: 
#line 430 
      ;
      
#line 431 
      efx_reado_table_0(efx,(efx_oword_t *)buf,(unsigned int)table->offset,(unsigned int)i);
      
#line 432 
      goto ldv_56711;
      case 32: 
#line 433 
      ;
      
#line 434 
      efx_reado_table_0(efx,(efx_oword_t *)buf,(unsigned int)table->offset,(unsigned int)i * 2U);
      
#line 435 
      goto ldv_56711;
      default: 
#line 436 
      ;
      {
        
#line 437 
        int __ret_warn_on = 1;
        
#line 437 
        if ((long)(__ret_warn_on != 0) != 0L) 
#line 437 
                                              warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.c",437); else ;
        
#line 437 
        long tmp_2 = (long)(__ret_warn_on != 0);
      }
      
#line 438 
      goto return_label;
    }
    ldv_56711: 
#line 440 
    ;
    
#line 440 
    buf += size;
    
#line 420 
    i += 1UL;
    ldv_56719: 
#line 421 
    ;
    
#line 420 
    if ((unsigned long)table->rows > i) 
#line 422 
                                        goto ldv_56718; else 
#line 425 
                                                             goto ldv_56720;
    ldv_56720: 
#line 426 
    ;
  }
  ldv_56706: 
#line 428 
  ;
  
#line 411 
  table += 1;
  ldv_56722: 
#line 412 
  ;
  
#line 409 
  if (table < (struct efx_nic_reg_table const *)(& efx_nic_reg_tables) + 23U) 
    
#line 412 
    goto ldv_56721; else 
#line 415 
                         goto ldv_56723;
  ldv_56723: 
#line 416 
  ;
  return_label: 
#line 417 
                return;
}


#line 456  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.c"
size_t efx_nic_describe_stats(struct efx_hw_stat_desc const *desc, size_t count, unsigned long const *mask, u8 *names)
{
  size_t index;
  
#line 459 
  size_t visible = 0UL;
  
#line 462 
  index = find_first_bit(mask,count);
  
#line 462 
  goto ldv_56733;
  ldv_56732: 
#line 463 
  ;
  
#line 463 
  if ((desc + index)->name != (char const *)0) {
    
#line 464 
    if (names != (u8 *)0U) {
      
#line 465 
      strlcpy((char *)names,(desc + index)->name,32UL);
      
#line 467 
      names += 32U;
    }
    else ;
    
#line 469 
    visible += 1UL;
  }
  else ;
  
#line 462 
  index = find_next_bit(mask,count,index + 1UL);
  ldv_56733: 
#line 463 
  ;
  
#line 462 
  if (index < count) 
#line 464 
                     goto ldv_56732; else 
#line 467 
                                          goto ldv_56734;
  ldv_56734: 
#line 468 
  ;
  
#line 473 
  return visible;
}


#line 490  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.c"
void efx_nic_update_stats(struct efx_hw_stat_desc const *desc, size_t count, unsigned long const *mask, u64 *stats, void const *dma_buf, bool accumulate)
{
  size_t index;
  
#line 496 
  index = find_first_bit(mask,count);
  
#line 496 
  goto ldv_56754;
  ldv_56753: 
#line 497 
  ;
  
#line 497 
  if ((unsigned int)(desc + index)->dma_width != 0U) {
    u64 val;
    
#line 498 
    void const *addr = dma_buf + (int)(desc + index)->offset;
    
#line 501 
    switch ((int)(desc + index)->dma_width) {
      __u16 tmp;
      __u32 tmp_0;
      case 16: 
#line 502 
      ;
      
#line 503 
      tmp = __le16_to_cpup((__le16 const *)addr);
      
#line 503 
      val = (unsigned long long)tmp;
      
#line 504 
      goto ldv_56747;
      case 32: 
#line 505 
      ;
      
#line 506 
      tmp_0 = __le32_to_cpup((__le32 const *)addr);
      
#line 506 
      val = (unsigned long long)tmp_0;
      
#line 507 
      goto ldv_56747;
      case 64: 
#line 508 
      ;
      
#line 509 
      val = __le64_to_cpup((__le64 const *)addr);
      
#line 510 
      goto ldv_56747;
      default: 
#line 511 
      ;
      {
        
#line 512 
        int __ret_warn_on = 1;
        
#line 512 
        if ((long)(__ret_warn_on != 0) != 0L) 
#line 512 
                                              warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.c",512); else ;
        
#line 512 
        long tmp_2 = (long)(__ret_warn_on != 0);
      }
      
#line 513 
      val = 0ULL;
      
#line 514 
      goto ldv_56747;
    }
    ldv_56747: 
#line 517 
    ;
    
#line 517 
    if ((int)accumulate != 0) 
#line 518 
                              *(stats + index) += val; else 
#line 520 
                                                            *(stats + index) = val;
  }
  else ;
  
#line 496 
  index = find_next_bit(mask,count,index + 1UL);
  ldv_56754: 
#line 497 
  ;
  
#line 496 
  if (index < count) 
#line 498 
                     goto ldv_56753; else 
#line 501 
                                          goto ldv_56755;
  ldv_56755: 
#line 502 
  ;
  
#line 503 
  return;
}


#line 525  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.c"
void efx_nic_fix_nodesc_drop_stat(struct efx_nic *efx, u64 *rx_nodesc_drops)
{
  
#line 528 
  if (((efx->net_dev)->flags & 1U) == 0U || ! efx->rx_nodesc_drops_prev_state) 
    
#line 529 
    efx->rx_nodesc_drops_while_down += *rx_nodesc_drops - efx->rx_nodesc_drops_total; else ;
  
#line 531 
  efx->rx_nodesc_drops_total = *rx_nodesc_drops;
  
#line 532 
  efx->rx_nodesc_drops_prev_state = (_Bool)(((efx->net_dev)->flags & 1U) != 0U);
  
#line 533 
  *rx_nodesc_drops -= efx->rx_nodesc_drops_while_down;
  
#line 534 
  return;
}


#line 65  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_nic.c.aux"
void ldv_emg_free_irq(unsigned int arg0, void *arg1);


#line 67 
int ldv_emg_request_irq(unsigned int arg0, enum irqreturn (*arg1)(int , void *), unsigned long arg2, char *arg3, void *arg4);


#line 928  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_nic.c.aux"
static void ldv___ldv_spin_lock_91_0(spinlock_t *ldv_func_arg1)
{
  
#line 932 
  ldv_spin_model_lock((char *)"biu_lock_of_efx_nic");
  
#line 934 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 935 
  return;
}


#line 938  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_nic.c.aux"
static void ldv_spin_unlock_irqrestore_92_0(spinlock_t *lock, unsigned long flags)
{
  
#line 942 
  ldv_spin_model_unlock((char *)"biu_lock_of_efx_nic");
  
#line 944 
  spin_unlock_irqrestore_0(lock,flags);
  
#line 945 
  return;
}


#line 948  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_nic.c.aux"
static void ldv___ldv_spin_lock_93(spinlock_t *ldv_func_arg1)
{
  
#line 952 
  ldv_spin_model_lock((char *)"biu_lock_of_efx_nic");
  
#line 954 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 955 
  return;
}


#line 958  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_nic.c.aux"
static void ldv_spin_unlock_irqrestore_94(spinlock_t *lock, unsigned long flags)
{
  
#line 962 
  ldv_spin_model_unlock((char *)"biu_lock_of_efx_nic");
  
#line 964 
  spin_unlock_irqrestore_0(lock,flags);
  
#line 965 
  return;
}


#line 988  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_nic.c.aux"
static int ldv_request_irq_97(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev)
{
  int tmp;
  
#line 992 
  tmp = ldv_emg_request_irq(irq,handler,flags,(char *)name,dev);
  
#line 992 
  return tmp;
}


#line 996  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_nic.c.aux"
static int ldv_request_irq_98(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev)
{
  int tmp;
  
#line 1000 
  tmp = ldv_emg_request_irq(irq,handler,flags,(char *)name,dev);
  
#line 1000 
  return tmp;
}


#line 1004  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_nic.c.aux"
static void ldv_free_irq_99(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  
#line 1008 
  ldv_emg_free_irq(ldv_func_arg1,ldv_func_arg2);
  
#line 1009 
  return;
}


#line 1012  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_nic.c.aux"
static void ldv_free_irq_100(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  
#line 1016 
  ldv_emg_free_irq(ldv_func_arg1,ldv_func_arg2);
  
#line 1017 
  return;
}


#line 1020  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_nic.c.aux"
static void ldv_free_irq_101(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  
#line 1024 
  ldv_emg_free_irq(ldv_func_arg1,ldv_func_arg2);
  
#line 1025 
  return;
}


#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
void *memcpy(void *, void const *, size_t);


#line 98  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/atomic.h"
static void atomic_inc_0(atomic_t *v);


#line 7  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bottom_half.h"
void __local_bh_disable_ip(unsigned long, unsigned int);


#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bottom_half.h"
__inline static void local_bh_disable(void)
{
  __here_0: 
#line 18 
  ;
  
#line 18 
  __local_bh_disable_ip((unsigned long)((void *)0),512U);
  
#line 20 
  return;
}


#line 22 
void __local_bh_enable_ip(unsigned long, unsigned int);


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bottom_half.h"
__inline static void local_bh_enable(void)
{
  __here_0: 
#line 31 
  ;
  
#line 31 
  __local_bh_enable_ip((unsigned long)((void *)0),512U);
  
#line 33 
  return;
}


#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_0(spinlock_t *lock)
{
  
#line 312 
  _raw_spin_lock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 313 
  return;
}


#line 346 
static void ldv_spin_lock_62_0(spinlock_t *lock);


#line 350 
static void ldv_spin_lock_67_0(spinlock_t *lock);


#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_0(spinlock_t *lock)
{
  
#line 365 
  _raw_spin_unlock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 366 
  return;
}


#line 395 
static void ldv_spin_unlock_65_0(spinlock_t *lock);


#line 399 
static void ldv_spin_unlock_68_0(spinlock_t *lock);


#line 37  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_selftest.c.aux"
static void ldv_mutex_lock_87(struct mutex *ldv_func_arg1);


#line 41 
static void ldv_mutex_lock_89(struct mutex *ldv_func_arg1);


#line 45 
static void ldv_mutex_lock_91(struct mutex *ldv_func_arg1);


#line 49 
static void ldv_mutex_lock_93(struct mutex *ldv_func_arg1);


#line 53 
static void ldv_mutex_lock_95(struct mutex *ldv_func_arg1);


#line 57 
static void ldv_mutex_lock_97(struct mutex *ldv_func_arg1);


#line 63 
void ldv_mutex_model_lock(struct mutex *, char *);


#line 65 
void ldv_mutex_model_unlock(struct mutex *, char *);


#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/delay.h"
void msleep(unsigned int);


#line 448  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
bool cancel_delayed_work_sync(struct delayed_work *);


#line 597 
static bool ldv_schedule_delayed_work_99(struct delayed_work *dwork, unsigned long delay);


#line 193  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
static void ldv_mutex_unlock_88(struct mutex *ldv_func_arg1);


#line 197 
static void ldv_mutex_unlock_90(struct mutex *ldv_func_arg1);


#line 201 
static void ldv_mutex_unlock_92(struct mutex *ldv_func_arg1);


#line 205 
static void ldv_mutex_unlock_94(struct mutex *ldv_func_arg1);


#line 209 
static void ldv_mutex_unlock_96(struct mutex *ldv_func_arg1);


#line 213 
static void ldv_mutex_unlock_98(struct mutex *ldv_func_arg1);


#line 424  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
long schedule_timeout_uninterruptible(long);


#line 542  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kcalloc_0(size_t n, size_t size, gfp_t flags);


#line 581 
static void *kzalloc_1(size_t size, gfp_t flags);


#line 772  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
void kfree_skb(struct sk_buff *);


#line 775 
void consume_skb(struct sk_buff *);


#line 783 
struct sk_buff *__alloc_skb(unsigned int, gfp_t, int, int);


#line 787  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct sk_buff *alloc_skb(unsigned int size, gfp_t priority)
{
  struct sk_buff *tmp;
  
#line 790 
  tmp = __alloc_skb(size,priority,0,-1);
  
#line 790 
  return tmp;
}


#line 1085  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct sk_buff *skb_get(struct sk_buff *skb)
{
  
#line 1087 
  atomic_inc_0(& skb->users);
  
#line 1088 
  return skb;
}


#line 1176  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int skb_shared(struct sk_buff const *skb)
{
  int __retres;
  int tmp;
  
#line 1178 
  tmp = atomic_read(& skb->users);
  
#line 1178 
  __retres = tmp != 1;
  
#line 1178 
  return __retres;
}


#line 1688 
unsigned char *skb_put(struct sk_buff *, unsigned int);


#line 3117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
void netif_device_detach(struct net_device *);


#line 3119 
void netif_device_attach(struct net_device *);


#line 3170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void __netif_tx_lock_0(struct netdev_queue *txq, int cpu)
{
  
#line 3172 
  ldv_spin_lock_62_0(& txq->_xmit_lock);
  
#line 3173 
  txq->xmit_lock_owner = cpu;
  
#line 3174 
  return;
}


#line 3190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void __netif_tx_unlock_0(struct netdev_queue *txq)
{
  
#line 3192 
  txq->xmit_lock_owner = -1;
  
#line 3193 
  ldv_spin_unlock_65_0(& txq->_xmit_lock);
  
#line 3194 
  return;
}


#line 3214  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_lock_0(struct net_device *dev)
{
  unsigned int i;
  int cpu;
  int tmp_3;
  
#line 3219 
  ldv_spin_lock_67_0(& dev->tx_global_lock);
  {
    int pscr_ret__;
    {
      
#line 3220 
      void const *__vpp_verify = (void const *)0;
      
#line 3220 
      void const *tmp = __vpp_verify;
    }
    
#line 3220 
    switch (4UL) {
      int tmp_0;
      int tmp_0_0;
      int tmp_1;
      int tmp_2;
      case (unsigned long)1: 
#line 3220 
      ;
      {
        int pfo_ret__;
        
#line 3220 
        switch (4UL) {
          case (unsigned long)1: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_42820;
          case (unsigned long)2: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_42820;
          case (unsigned long)4: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_42820;
          case (unsigned long)8: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_42820;
          default: 
#line 3220 
          ;
          
#line 3220 
          __bad_percpu_size();
        }
        ldv_42820: 
#line 3220 
        ;
        
#line 3220 
        tmp_0 = pfo_ret__;
      }
      
#line 3220 
      pscr_ret__ = tmp_0;
      
#line 3220 
      goto ldv_42826;
      case (unsigned long)2: 
#line 3220 
      ;
      {
        int pfo_ret___0;
        
#line 3220 
        switch (4UL) {
          case (unsigned long)1: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_42830;
          case (unsigned long)2: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_42830;
          case (unsigned long)4: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_42830;
          case (unsigned long)8: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_42830;
          default: 
#line 3220 
          ;
          
#line 3220 
          __bad_percpu_size();
        }
        ldv_42830: 
#line 3220 
        ;
        
#line 3220 
        tmp_0_0 = pfo_ret___0;
      }
      
#line 3220 
      pscr_ret__ = tmp_0_0;
      
#line 3220 
      goto ldv_42826;
      case (unsigned long)4: 
#line 3220 
      ;
      {
        int pfo_ret___1;
        
#line 3220 
        switch (4UL) {
          case (unsigned long)1: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_42839;
          case (unsigned long)2: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_42839;
          case (unsigned long)4: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_42839;
          case (unsigned long)8: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_42839;
          default: 
#line 3220 
          ;
          
#line 3220 
          __bad_percpu_size();
        }
        ldv_42839: 
#line 3220 
        ;
        
#line 3220 
        tmp_1 = pfo_ret___1;
      }
      
#line 3220 
      pscr_ret__ = tmp_1;
      
#line 3220 
      goto ldv_42826;
      case (unsigned long)8: 
#line 3220 
      ;
      {
        int pfo_ret___2;
        
#line 3220 
        switch (4UL) {
          case (unsigned long)1: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_42848;
          case (unsigned long)2: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_42848;
          case (unsigned long)4: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_42848;
          case (unsigned long)8: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_42848;
          default: 
#line 3220 
          ;
          
#line 3220 
          __bad_percpu_size();
        }
        ldv_42848: 
#line 3220 
        ;
        
#line 3220 
        tmp_2 = pfo_ret___2;
      }
      
#line 3220 
      pscr_ret__ = tmp_2;
      
#line 3220 
      goto ldv_42826;
      default: 
#line 3220 
      ;
      
#line 3220 
      __bad_size_call_parameter();
      
#line 3220 
      goto ldv_42826;
    }
    ldv_42826: 
#line 3220 
    ;
    
#line 3220 
    tmp_3 = pscr_ret__;
  }
  
#line 3220 
  cpu = tmp_3;
  
#line 3221 
  i = 0U;
  
#line 3221 
  goto ldv_42858;
  ldv_42857: 
#line 3222 
  ;
  {
    
#line 3222 
    struct netdev_queue *txq = netdev_get_tx_queue((struct net_device const *)dev,i);
    
#line 3230 
    __netif_tx_lock_0(txq,cpu);
    
#line 3231 
    set_bit(2L,(unsigned long volatile *)(& txq->state));
    
#line 3232 
    __netif_tx_unlock_0(txq);
  }
  
#line 3221 
  i += 1U;
  ldv_42858: 
#line 3222 
  ;
  
#line 3221 
  if (dev->num_tx_queues > i) 
#line 3223 
                              goto ldv_42857; else 
#line 3226 
                                                   goto ldv_42859;
  ldv_42859: 
#line 3227 
  ;
  
#line 3228 
  return;
}


#line 3236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_lock_bh(struct net_device *dev)
{
  
#line 3238 
  local_bh_disable();
  
#line 3239 
  netif_tx_lock_0(dev);
  
#line 3240 
  return;
}


#line 3242  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_unlock_0(struct net_device *dev)
{
  unsigned int i;
  
#line 3246 
  i = 0U;
  
#line 3246 
  goto ldv_42869;
  ldv_42868: 
#line 3247 
  ;
  {
    
#line 3247 
    struct netdev_queue *txq = netdev_get_tx_queue((struct net_device const *)dev,i);
    
#line 3253 
    set_bit(2L,(unsigned long volatile *)(& txq->state));
    
#line 3254 
    netif_schedule_queue(txq);
  }
  
#line 3246 
  i += 1U;
  ldv_42869: 
#line 3247 
  ;
  
#line 3246 
  if (dev->num_tx_queues > i) 
#line 3248 
                              goto ldv_42868; else 
#line 3251 
                                                   goto ldv_42870;
  ldv_42870: 
#line 3252 
  ;
  
#line 3256 
  ldv_spin_unlock_68_0(& dev->tx_global_lock);
  
#line 3257 
  return;
}


#line 3259  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_unlock_bh(struct net_device *dev)
{
  
#line 3261 
  netif_tx_unlock_0(dev);
  
#line 3262 
  local_bh_enable();
  
#line 3263 
  return;
}


#line 271  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static void ether_addr_copy(u8 *dst, u8 const *src)
{
  
#line 274 
  *((u32 *)dst) = *((u32 const *)src);
  
#line 275 
  *((u16 *)(dst + 4U)) = *((u16 const *)(src + 4U));
  
#line 276 
  return;
}


#line 658  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
char const * const efx_loopback_mode_names[27U];


#line 659 
unsigned int const efx_loopback_mode_max;


#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
netdev_tx_t efx_enqueue_skb(struct efx_tx_queue *tx_queue, struct sk_buff *skb);


#line 187 
int __efx_reconfigure_port(struct efx_nic *efx);


#line 205 
void efx_stop_eventq(struct efx_channel *channel);


#line 206 
void efx_start_eventq(struct efx_channel *channel);


#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
__inline static void efx_device_detach_sync(struct efx_nic *efx)
{
  
#line 259 
  struct net_device *dev = efx->net_dev;
  
#line 265 
  netif_tx_lock_bh(dev);
  
#line 266 
  netif_device_detach(dev);
  
#line 267 
  netif_tx_unlock_bh(dev);
  
#line 268 
  return;
}


#line 748  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
__inline static int efx_nic_event_test_irq_cpu(struct efx_channel *channel)
{
  int __retres;
  int volatile *tmp;
  {
    
#line 750 
    int __var = 0;
    
#line 750 
    tmp = (int volatile *)(& channel->event_test_cpu);
  }
  
#line 750 
  __retres = *tmp;
  
#line 750 
  return __retres;
}


#line 752  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
__inline static int efx_nic_irq_test_irq_cpu(struct efx_nic *efx)
{
  int __retres;
  int volatile *tmp;
  {
    
#line 754 
    int __var = 0;
    
#line 754 
    tmp = (int volatile *)(& efx->last_irq_cpu);
  }
  
#line 754 
  __retres = *tmp;
  
#line 754 
  return __retres;
}


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.h"
void efx_loopback_rx_packet(struct efx_nic *efx, char const *buf_ptr, int pkt_len);


#line 49 
int efx_selftest(struct efx_nic *efx, struct efx_self_tests *tests, unsigned int flags);


#line 51 
void efx_selftest_async_start(struct efx_nic *efx);


#line 52 
void efx_selftest_async_cancel(struct efx_nic *efx);


#line 53 
void efx_selftest_async_work(struct work_struct *data);


#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.c"
static u8 const payload_source[6U] = {(unsigned char)0U, (unsigned char)15U, (unsigned char)83U, (unsigned char)27U, (unsigned char)27U, (unsigned char)27U};

#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.c"
static char const payload_msg[55U] = {(char)'H', (char)'e', (char)'l', (char)'l', (char)'o', (char)' ', (char)'w', (char)'o', (char)'r', (char)'l', (char)'d', (char)'!', (char)' ', (char)'T', (char)'h', (char)'i', (char)'s', (char)' ', (char)'i', (char)'s', (char)' ', (char)'a', (char)'n', (char)' ', (char)'E', (char)'f', (char)'x', (char)' ', (char)'l', (char)'o', (char)'o', (char)'p', (char)'b', (char)'a', (char)'c', (char)'k', (char)' ', (char)'t', (char)'e', (char)'s', (char)'t', (char)' ', (char)'i', (char)'n', (char)' ', (char)'p', (char)'r', (char)'o', (char)'g', (char)'r', (char)'e', (char)'s', (char)'s', (char)'!', (char)'\000'};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.c"
static char const * const efx_interrupt_mode_names[3U] = {"MSI-X", "MSI", "legacy"};

#line 99  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.c"
static int efx_test_phy_alive(struct efx_nic *efx, struct efx_self_tests *tests)
{
  
#line 101 
  int rc = 0;
  
#line 103 
  if ((efx->phy_op)->test_alive != (int (*)(struct efx_nic *))0) {
    
#line 104 
    rc = (*((efx->phy_op)->test_alive))(efx);
    
#line 105 
    if (rc != 0) 
#line 105 
                 tests->phy_alive = -1; else 
#line 105 
                                             tests->phy_alive = 1;
  }
  else ;
  
#line 108 
  return rc;
}


#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.c"
static int efx_test_nvram(struct efx_nic *efx, struct efx_self_tests *tests)
{
  
#line 113 
  int rc = 0;
  
#line 115 
  if ((efx->type)->test_nvram != (int (*)(struct efx_nic *))0) {
    
#line 116 
    rc = (*((efx->type)->test_nvram))(efx);
    
#line 117 
    if (rc != 0) 
#line 117 
                 tests->nvram = -1; else 
#line 117 
                                         tests->nvram = 1;
  }
  else ;
  
#line 120 
  return rc;
}


#line 130  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.c"
static int efx_test_interrupts(struct efx_nic *efx, struct efx_self_tests *tests)
{
  int __retres;
  unsigned long timeout;
  unsigned long wait;
  int cpu;
  int tmp;
  
#line 136 
  if ((efx->msg_enable & 1U) != 0U) {
    
#line 136 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_test_interrupts", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.c", .format = "testing interrupts\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))136U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 136 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 136 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"testing interrupts\n"); else ;
  }
  else ;
  
#line 137 
  tests->interrupt = -1;
  
#line 139 
  efx_nic_irq_test_start(efx);
  
#line 140 
  timeout = jiffies + 250UL;
  
#line 141 
  wait = 1UL;
  
#line 144 
  if ((efx->msg_enable & 1U) != 0U) {
    
#line 144 
    struct _ddebug descriptor_0 = {.modname = "sfc", .function = "efx_test_interrupts", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.c", .format = "waiting for test interrupt\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))144U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 144 
    if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 144 
                                                          __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)efx->net_dev,"waiting for test interrupt\n"); else ;
  }
  else ;
  ldv_56606: 
#line 146 
  ;
  
#line 146 
  schedule_timeout_uninterruptible((long)wait);
  
#line 147 
  cpu = efx_nic_irq_test_irq_cpu(efx);
  
#line 148 
  if (cpu >= 0) 
#line 149 
                goto success; else ;
  
#line 150 
  wait *= 2UL;
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
#line 151 
    tmp = 1;
  }
  
#line 151 
  if (tmp != 0) {
    int tmp_0;
    {
      unsigned long __dummy_0;
      unsigned long volatile __dummy2_0;
      
#line 151 
      tmp_0 = 1;
    }
    
#line 151 
    if (tmp_0 != 0) {
      
#line 151 
      if ((long)(jiffies - timeout) < 0L) 
#line 153 
                                          goto ldv_56606; else 
#line 156 
                                                               goto ldv_56607;
    }
    else 
#line 156 
         goto ldv_56607;
  }
  else 
#line 156 
       goto ldv_56607;
  ldv_56607: 
#line 157 
  ;
  
#line 153 
  if ((efx->msg_enable & 1U) != 0U) 
#line 153 
                                    netdev_err((struct net_device const *)efx->net_dev,"timed out waiting for interrupt\n"); else ;
  
#line 154 
  __retres = -110;
  
#line 154 
  goto return_label;
  success: 
#line 156 
  ;
  
#line 157 
  if ((efx->msg_enable & 1U) != 0U) {
    
#line 157 
    struct _ddebug descriptor_1 = {.modname = "sfc", .function = "efx_test_interrupts", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.c", .format = "%s test interrupt seen on CPU%d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))158U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 157 
    if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) {
      char const *tmp_1;
      
#line 157 
      ;
      
#line 157 
      if (efx->interrupt_mode <= (unsigned int)EFX_INT_MODE_LEGACY) 
#line 157 
                                                                    tmp_1 = efx_interrupt_mode_names[(unsigned int)efx->interrupt_mode]; else 
                                                                    
#line 157 
                                                                    tmp_1 = "(invalid)";
      
#line 157 
      ;
      
#line 157 
      __dynamic_netdev_dbg(& descriptor_1,(struct net_device const *)efx->net_dev,"%s test interrupt seen on CPU%d\n",tmp_1,cpu);
    }
    else ;
  }
  else ;
  
#line 159 
  tests->interrupt = 1;
  
#line 160 
  __retres = 0;
  return_label: 
#line 160 
                return __retres;
}


#line 172 
void __compiletime_assert_172(void);


#line 164  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.c"
static int efx_test_eventq_irq(struct efx_nic *efx, struct efx_self_tests *tests)
{
  struct efx_channel *channel;
  unsigned int read_ptr[32U];
  unsigned long timeout;
  unsigned long wait;
  int tmp_13;
  
#line 169 
  unsigned long napi_ran = 0UL;
  
#line 169 
  unsigned long dma_pend = 0UL;
  
#line 169 
  unsigned long int_pend = 0UL;
  {
    
#line 172 
    bool __cond = (_Bool)0;
    
#line 172 
    if ((int)__cond != 0) 
#line 172 
                          __compiletime_assert_172(); else ;
  }
  
#line 174 
  channel = efx->channel[0];
  
#line 174 
  goto ldv_56625;
  ldv_56624: 
#line 175 
  ;
  
#line 175 
  read_ptr[channel->channel] = channel->eventq_read_ptr;
  
#line 176 
  set_bit((long)channel->channel,(unsigned long volatile *)(& dma_pend));
  
#line 177 
  set_bit((long)channel->channel,(unsigned long volatile *)(& int_pend));
  
#line 178 
  efx_nic_event_test_start(channel);
  
#line 174 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 174 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 174 
                                                                    channel = (struct efx_channel *)0;
  ldv_56625: 
#line 175 
  ;
  
#line 174 
  if (channel != (struct efx_channel *)0) 
#line 176 
                                          goto ldv_56624; else 
#line 179 
                                                               goto ldv_56626;
  ldv_56626: 
#line 180 
  ;
  
#line 181 
  timeout = jiffies + 250UL;
  
#line 182 
  wait = 1UL;
  ldv_56636: 
#line 183 
  ;
  
#line 188 
  schedule_timeout_uninterruptible((long)wait);
  
#line 190 
  channel = efx->channel[0];
  
#line 190 
  goto ldv_56628;
  ldv_56627: 
#line 191 
  ;
  
#line 191 
  efx_stop_eventq(channel);
  
#line 192 
  if (channel->eventq_read_ptr != read_ptr[channel->channel]) {
    
#line 194 
    set_bit((long)channel->channel,(unsigned long volatile *)(& napi_ran));
    
#line 195 
    set_bit((long)channel->channel,(unsigned long volatile *)(& dma_pend));
    
#line 196 
    set_bit((long)channel->channel,(unsigned long volatile *)(& int_pend));
  }
  else {
    bool tmp;
    int tmp_0;
    
#line 198 
    tmp = efx_nic_event_present(channel);
    
#line 198 
    if ((int)tmp != 0) 
#line 199 
                       set_bit((long)channel->channel,(unsigned long volatile *)(& dma_pend)); else ;
    
#line 200 
    tmp_0 = efx_nic_event_test_irq_cpu(channel);
    
#line 200 
    if (tmp_0 >= 0) 
#line 201 
                    set_bit((long)channel->channel,(unsigned long volatile *)(& int_pend)); else ;
  }
  
#line 203 
  efx_start_eventq(channel);
  
#line 190 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 190 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 190 
                                                                    channel = (struct efx_channel *)0;
  ldv_56628: 
#line 191 
  ;
  
#line 190 
  if (channel != (struct efx_channel *)0) 
#line 192 
                                          goto ldv_56627; else 
#line 195 
                                                               goto ldv_56629;
  ldv_56629: 
#line 196 
  ;
  
#line 206 
  wait *= 2UL;
  
#line 207 
  if (dma_pend != 0UL || int_pend != 0UL) {
    int tmp_1;
    {
      unsigned long __dummy;
      unsigned long __dummy2;
      
#line 207 
      tmp_1 = 1;
    }
    
#line 207 
    if (tmp_1 != 0) {
      int tmp_2;
      {
        unsigned long __dummy_0;
        unsigned long volatile __dummy2_0;
        
#line 207 
        tmp_2 = 1;
      }
      
#line 207 
      if (tmp_2 != 0) {
        
#line 207 
        if ((long)(jiffies - timeout) < 0L) 
#line 209 
                                            goto ldv_56636; else 
#line 212 
                                                                 goto ldv_56637;
      }
      else 
#line 212 
           goto ldv_56637;
    }
    else 
#line 212 
         goto ldv_56637;
  }
  else 
#line 212 
       goto ldv_56637;
  ldv_56637: 
#line 213 
  ;
  
#line 209 
  channel = efx->channel[0];
  
#line 209 
  goto ldv_56643;
  ldv_56642: 
#line 210 
  ;
  {
    int tmp_5;
    int tmp_8;
    
#line 210 
    if (0 != 0) {
      int tmp_3;
      
#line 210 
      tmp_3 = constant_test_bit((long)channel->channel,(unsigned long const volatile *)(& dma_pend));
      
#line 210 
      tmp_5 = tmp_3 == 0;
    }
    else {
      int tmp_4;
      
#line 210 
      tmp_4 = variable_test_bit((long)channel->channel,(unsigned long const volatile *)(& dma_pend));
      
#line 210 
      tmp_5 = tmp_4 == 0;
    }
    
#line 210 
    bool dma_seen = (_Bool)(tmp_5 != 0);
    
#line 211 
    if (0 != 0) {
      int tmp_6;
      
#line 211 
      tmp_6 = constant_test_bit((long)channel->channel,(unsigned long const volatile *)(& int_pend));
      
#line 211 
      tmp_8 = tmp_6 == 0;
    }
    else {
      int tmp_7;
      
#line 211 
      tmp_7 = variable_test_bit((long)channel->channel,(unsigned long const volatile *)(& int_pend));
      
#line 211 
      tmp_8 = tmp_7 == 0;
    }
    
#line 211 
    bool int_seen = (_Bool)(tmp_8 != 0);
    
#line 213 
    if ((int)dma_seen != 0) 
#line 213 
                            tests->eventq_dma[channel->channel] = 1; else 
                                                                    
#line 213 
                                                                    tests->eventq_dma[channel->channel] = -1;
    
#line 214 
    if ((int)int_seen != 0) 
#line 214 
                            tests->eventq_int[channel->channel] = 1; else 
                                                                    
#line 214 
                                                                    tests->eventq_int[channel->channel] = -1;
    
#line 216 
    if ((int)dma_seen != 0 && (int)int_seen != 0) {
      
#line 217 
      if ((efx->msg_enable & 1U) != 0U) {
        
#line 217 
        struct _ddebug descriptor = {.modname = "sfc", .function = "efx_test_eventq_irq", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.c", .format = "channel %d event queue passed (with%s NAPI)\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))221U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 217 
        if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
          char *tmp_12;
          int tmp_11;
          
#line 217 
          if (0 != 0) {
            int tmp_9;
            
#line 217 
            tmp_9 = constant_test_bit((long)channel->channel,(unsigned long const volatile *)(& napi_ran));
            
#line 217 
            tmp_11 = tmp_9 != 0;
          }
          else {
            int tmp_10;
            
#line 217 
            tmp_10 = variable_test_bit((long)channel->channel,(unsigned long const volatile *)(& napi_ran));
            
#line 217 
            tmp_11 = tmp_10 != 0;
          }
          
#line 217 
          if (tmp_11) 
#line 217 
                      tmp_12 = (char *)""; else 
#line 217 
                                                tmp_12 = (char *)"out";
          
#line 217 
          ;
          
#line 217 
          ;
          
#line 217 
          __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"channel %d event queue passed (with%s NAPI)\n",channel->channel,tmp_12);
        }
        else ;
      }
      else ;
    }
    else {
      
#line 226 
      if ((efx->msg_enable & 1U) != 0U) 
#line 226 
                                        netdev_err((struct net_device const *)efx->net_dev,"channel %d timed out waiting for event queue\n",channel->channel); else ;
      
#line 229 
      if ((int)int_seen != 0) {
        
#line 230 
        if ((efx->msg_enable & 1U) != 0U) 
#line 230 
                                          netdev_err((struct net_device const *)efx->net_dev,"channel %d saw interrupt ",channel->channel); else ;
      }
      else ;
      
#line 234 
      if ((int)dma_seen != 0) {
        
#line 235 
        if ((efx->msg_enable & 1U) != 0U) 
#line 235 
                                          netdev_err((struct net_device const *)efx->net_dev,"channel %d event was generated, but ",channel->channel); else ;
      }
      else ;
    }
  }
  
#line 209 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 209 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 209 
                                                                    channel = (struct efx_channel *)0;
  ldv_56643: 
#line 210 
  ;
  
#line 209 
  if (channel != (struct efx_channel *)0) 
#line 211 
                                          goto ldv_56642; else 
#line 214 
                                                               goto ldv_56644;
  ldv_56644: 
#line 215 
  ;
  
#line 242 
  if (dma_pend != 0UL || int_pend != 0UL) 
#line 242 
                                          tmp_13 = -110; else 
#line 242 
                                                              tmp_13 = 0;
  
#line 242 
  return tmp_13;
}


#line 245  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.c"
static int efx_test_phy(struct efx_nic *efx, struct efx_self_tests *tests, unsigned int flags)
{
  int __retres;
  int rc;
  
#line 250 
  if ((efx->phy_op)->run_tests == (int (*)(struct efx_nic *, int *, unsigned int ))0) {
    
#line 251 
    __retres = 0;
    
#line 251 
    goto return_label;
  }
  else ;
  
#line 253 
  ldv_mutex_lock_87(& efx->mac_lock);
  
#line 254 
  rc = (*((efx->phy_op)->run_tests))(efx,(int *)(& tests->phy_ext),flags);
  
#line 255 
  ldv_mutex_unlock_88(& efx->mac_lock);
  
#line 256 
  __retres = rc;
  return_label: 
#line 256 
                return __retres;
}


#line 269  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.c"
void efx_loopback_rx_packet(struct efx_nic *efx, char const *buf_ptr, int pkt_len)
{
  struct efx_loopback_payload *received;
  struct efx_loopback_payload *payload;
  int tmp_1;
  int tmp_4;
  int tmp_6;
  
#line 272 
  struct efx_loopback_state *state = (struct efx_loopback_state *)efx->loopback_selftest;
  
#line 276 
  if ((long)(buf_ptr == (char const *)0) != 0L) {
    
#line 278 
    ldv_inline_asm();
    
#line 276 
    ;
  }
  else ;
  
#line 279 
  if (state == (struct efx_loopback_state *)0 || (int)state->flush != 0) 
    
#line 280 
    goto return_label; else ;
  
#line 282 
  payload = & state->payload;
  
#line 284 
  received = (struct efx_loopback_payload *)buf_ptr;
  
#line 285 
  received->ip.saddr = payload->ip.saddr;
  
#line 286 
  if ((int)state->offload_csum != 0) 
#line 287 
                                     received->ip.check = payload->ip.check; else ;
  
#line 290 
  if ((unsigned int)pkt_len <= 13U) {
    
#line 291 
    if ((efx->msg_enable & 1U) != 0U) {
      char const *tmp;
      
#line 291 
      if ((unsigned int)efx->loopback_mode < efx_loopback_mode_max) 
#line 291 
                                                                    tmp = efx_loopback_mode_names[(unsigned int)efx->loopback_mode]; else 
                                                                    
#line 291 
                                                                    tmp = "(invalid)";
      
#line 291 
      ;
      
#line 291 
      ;
      
#line 291 
      netdev_err((struct net_device const *)efx->net_dev,"saw runt RX packet (length %d) in %s loopback ",pkt_len,tmp);
    }
    else ;
    
#line 294 
    goto err;
  }
  else ;
  
#line 298 
  tmp_1 = memcmp((void const *)(& received->header),(void const *)(& payload->header),14UL);
  
#line 298 
  if (tmp_1 != 0) {
    
#line 299 
    if ((efx->msg_enable & 1U) != 0U) {
      char const *tmp_0;
      
#line 299 
      if ((unsigned int)efx->loopback_mode < efx_loopback_mode_max) 
#line 299 
                                                                    tmp_0 = efx_loopback_mode_names[(unsigned int)efx->loopback_mode]; else 
                                                                    
#line 299 
                                                                    tmp_0 = "(invalid)";
      
#line 299 
      ;
      
#line 299 
      netdev_err((struct net_device const *)efx->net_dev,"saw non-loopback RX packet in %s loopback test\n",tmp_0);
    }
    else ;
    
#line 302 
    goto err;
  }
  else ;
  
#line 306 
  if (pkt_len != 108) {
    
#line 307 
    if ((efx->msg_enable & 1U) != 0U) {
      char const *tmp_2;
      
#line 307 
      if ((unsigned int)efx->loopback_mode < efx_loopback_mode_max) 
#line 307 
                                                                    tmp_2 = efx_loopback_mode_names[(unsigned int)efx->loopback_mode]; else 
                                                                    
#line 307 
                                                                    tmp_2 = "(invalid)";
      
#line 307 
      ;
      
#line 307 
      ;
      
#line 307 
      netdev_err((struct net_device const *)efx->net_dev,"saw incorrect RX packet length %d (wanted %d) in ",pkt_len,108,tmp_2);
    }
    else ;
    
#line 311 
    goto err;
  }
  else ;
  
#line 315 
  tmp_4 = memcmp((void const *)(& received->ip),(void const *)(& payload->ip),20UL);
  
#line 315 
  if (tmp_4 != 0) {
    
#line 316 
    if ((efx->msg_enable & 1U) != 0U) {
      char const *tmp_3;
      
#line 316 
      if ((unsigned int)efx->loopback_mode < efx_loopback_mode_max) 
#line 316 
                                                                    tmp_3 = efx_loopback_mode_names[(unsigned int)efx->loopback_mode]; else 
                                                                    
#line 316 
                                                                    tmp_3 = "(invalid)";
      
#line 316 
      ;
      
#line 316 
      netdev_err((struct net_device const *)efx->net_dev,"saw corrupted IP header in %s loopback test\n",tmp_3);
    }
    else ;
    
#line 319 
    goto err;
  }
  else ;
  
#line 323 
  tmp_6 = memcmp((void const *)(& received->msg),(void const *)(& payload->msg),64UL);
  
#line 323 
  if (tmp_6 != 0) {
    
#line 324 
    if ((efx->msg_enable & 1U) != 0U) {
      char const *tmp_5;
      
#line 324 
      if ((unsigned int)efx->loopback_mode < efx_loopback_mode_max) 
#line 324 
                                                                    tmp_5 = efx_loopback_mode_names[(unsigned int)efx->loopback_mode]; else 
                                                                    
#line 324 
                                                                    tmp_5 = "(invalid)";
      
#line 324 
      ;
      
#line 324 
      netdev_err((struct net_device const *)efx->net_dev,"saw corrupted RX packet in %s loopback test\n",tmp_5);
    }
    else ;
    
#line 327 
    goto err;
  }
  else ;
  
#line 331 
  if ((int)received->iteration != (int)payload->iteration) {
    
#line 332 
    if ((efx->msg_enable & 1U) != 0U) {
      char const *tmp_7;
      int tmp_9;
      int tmp_11;
      
#line 332 
      if ((unsigned int)efx->loopback_mode < efx_loopback_mode_max) 
#line 332 
                                                                    tmp_7 = efx_loopback_mode_names[(unsigned int)efx->loopback_mode]; else 
                                                                    
#line 332 
                                                                    tmp_7 = "(invalid)";
      
#line 332 
      if (0 != 0) 
#line 332 
                  tmp_9 = (int)((unsigned short)(((int)payload->iteration << 8) | ((int)payload->iteration >> 8)));
      else {
        __u16 tmp_8;
        
#line 332 
        tmp_8 = __fswab16((unsigned short)((int)payload->iteration));
        
#line 332 
        tmp_9 = (int)tmp_8;
      }
      
#line 332 
      if (0 != 0) 
#line 332 
                  tmp_11 = (int)((unsigned short)(((int)received->iteration << 8) | ((int)received->iteration >> 8)));
      else {
        __u16 tmp_10;
        
#line 332 
        tmp_10 = __fswab16((unsigned short)((int)received->iteration));
        
#line 332 
        tmp_11 = (int)tmp_10;
      }
      
#line 332 
      ;
      
#line 332 
      netdev_err((struct net_device const *)efx->net_dev,"saw RX packet from iteration %d (wanted %d) in ",tmp_11,tmp_9,tmp_7);
    }
    else ;
    
#line 336 
    goto err;
  }
  else ;
  
#line 343 
  atomic_inc_0(& state->rx_good);
  
#line 344 
  goto return_label;
  err: 
#line 346 
  ;
  
#line 357 
  atomic_inc_0(& state->rx_bad);
  return_label: 
#line 358 
                return;
}


#line 361  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.c"
static void efx_iterate_state(struct efx_nic *efx)
{
  
#line 363 
  struct efx_loopback_state *state = (struct efx_loopback_state *)efx->loopback_selftest;
  
#line 364 
  struct net_device *net_dev = efx->net_dev;
  
#line 365 
  struct efx_loopback_payload *payload = & state->payload;
  
#line 368 
  ether_addr_copy((u8 *)(& payload->header.h_dest),(u8 const *)net_dev->dev_addr);
  
#line 369 
  ether_addr_copy((u8 *)(& payload->header.h_source),(u8 const *)(& payload_source));
  
#line 370 
  payload->header.h_proto = (unsigned short)8U;
  
#line 373 
  payload->ip.daddr = 16777343U;
  
#line 374 
  payload->ip.ihl = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))5U;
  
#line 375 
  payload->ip.check = (unsigned short)44510U;
  
#line 376 
  payload->ip.tot_len = (unsigned short)24064U;
  
#line 377 
  payload->ip.version = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))4U;
  
#line 378 
  payload->ip.protocol = (unsigned char)17U;
  
#line 381 
  payload->udp.source = (unsigned short)0U;
  
#line 382 
  payload->udp.len = (unsigned short)18944U;
  
#line 384 
  payload->udp.check = (unsigned short)0U;
  
#line 387 
  if (0 != 0) {
    unsigned int tmp_2;
    unsigned int tmp_4;
    
#line 387 
    if (0 != 0) 
#line 387 
                tmp_2 = (unsigned int)((unsigned short)(((int)payload->iteration << 8) | ((int)payload->iteration >> 8))) + 1U;
    else {
      __u16 tmp_1;
      
#line 387 
      tmp_1 = __fswab16((unsigned short)((int)payload->iteration));
      
#line 387 
      tmp_2 = (unsigned int)tmp_1 + 1U;
    }
    
#line 387 
    if (0 != 0) 
#line 387 
                tmp_4 = ((unsigned int)((unsigned short)(((int)payload->iteration << 8) | ((int)payload->iteration >> 8))) + 1U) >> 8;
    else {
      __u16 tmp_3;
      
#line 387 
      tmp_3 = __fswab16((unsigned short)((int)payload->iteration));
      
#line 387 
      tmp_4 = ((unsigned int)tmp_3 + 1U) >> 8;
    }
    
#line 387 
    payload->iteration = (unsigned short)((unsigned int)((int)tmp_2 << 8) | tmp_4);
  }
  else {
    __u16 tmp_7;
    unsigned int tmp_6;
    
#line 387 
    if (0 != 0) 
#line 387 
                tmp_6 = (unsigned int)((unsigned short)(((int)payload->iteration << 8) | ((int)payload->iteration >> 8))) + 1U;
    else {
      __u16 tmp_5;
      
#line 387 
      tmp_5 = __fswab16((unsigned short)((int)payload->iteration));
      
#line 387 
      tmp_6 = (unsigned int)tmp_5 + 1U;
    }
    
#line 387 
    tmp_7 = __fswab16((unsigned short)((int)tmp_6));
    
#line 387 
    payload->iteration = tmp_7;
  }
  
#line 388 
  memcpy((void *)(& payload->msg),(void const *)(& payload_msg),55UL);
  
#line 391 
  atomic_set(& state->rx_good,0);
  
#line 392 
  atomic_set(& state->rx_bad,0);
  
#line 393 
  ldv_inline_asm();
  
#line 394 
  return;
}


#line 396  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.c"
static int efx_begin_loopback(struct efx_tx_queue *tx_queue)
{
  int __retres;
  struct efx_loopback_payload *payload;
  struct sk_buff *skb;
  int i;
  netdev_tx_t rc;
  
#line 398 
  struct efx_nic *efx = tx_queue->efx;
  
#line 399 
  struct efx_loopback_state *state = (struct efx_loopback_state *)efx->loopback_selftest;
  
#line 406 
  i = 0;
  
#line 406 
  goto ldv_56677;
  ldv_56676: 
#line 407 
  ;
  
#line 409 
  skb = alloc_skb(108U,208U);
  
#line 410 
  if (skb == (struct sk_buff *)0) {
    
#line 411 
    __retres = -12;
    
#line 411 
    goto return_label;
  }
  else ;
  
#line 412 
  *(state->skbs + i) = skb;
  
#line 413 
  skb_get(skb);
  
#line 417 
  payload = (struct efx_loopback_payload *)skb_put(skb,108U);
  
#line 419 
  memcpy((void *)payload,(void const *)(& state->payload),108UL);
  
#line 420 
  if (0 != 0) 
#line 420 
              payload->ip.saddr = (((((unsigned int)(i << 2) << 24) | (((unsigned int)(i << 2) << 8) & 16711680U)) | (((unsigned int)(i << 2) >> 8) & 65280U)) | ((unsigned int)(i << 2) >> 24)) | 16777343U; else 
                                                                    
#line 420 
                                                                    payload->ip.saddr = __fswab32((unsigned int)((i << 2) | 2130706433));
  
#line 421 
  ldv_inline_asm();
  
#line 426 
  netif_tx_lock_bh(efx->net_dev);
  
#line 427 
  rc = efx_enqueue_skb(tx_queue,skb);
  
#line 428 
  netif_tx_unlock_bh(efx->net_dev);
  
#line 430 
  if (rc != (unsigned int)NETDEV_TX_OK) {
    
#line 431 
    if ((efx->msg_enable & 1U) != 0U) {
      char const *tmp_1;
      
#line 431 
      if ((unsigned int)efx->loopback_mode < efx_loopback_mode_max) 
#line 431 
                                                                    tmp_1 = efx_loopback_mode_names[(unsigned int)efx->loopback_mode]; else 
                                                                    
#line 431 
                                                                    tmp_1 = "(invalid)";
      
#line 431 
      ;
      
#line 431 
      ;
      
#line 431 
      ;
      
#line 431 
      ;
      
#line 431 
      netdev_err((struct net_device const *)efx->net_dev,"TX queue %d could not transmit packet %d of ",tx_queue->queue,i + 1,state->packet_count,tmp_1);
    }
    else ;
    
#line 438 
    kfree_skb(skb);
    
#line 439 
    __retres = -32;
    
#line 439 
    goto return_label;
  }
  else ;
  
#line 406 
  i += 1;
  ldv_56677: 
#line 407 
  ;
  
#line 406 
  if (state->packet_count > i) 
#line 408 
                               goto ldv_56676; else 
#line 411 
                                                    goto ldv_56678;
  ldv_56678: 
#line 412 
  ;
  
#line 443 
  __retres = 0;
  return_label: 
#line 443 
                return __retres;
}


#line 446  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.c"
static int efx_poll_loopback(struct efx_nic *efx)
{
  int __retres;
  int tmp;
  
#line 448 
  struct efx_loopback_state *state = (struct efx_loopback_state *)efx->loopback_selftest;
  
#line 450 
  tmp = atomic_read((atomic_t const *)(& state->rx_good));
  
#line 450 
  ;
  
#line 450 
  __retres = tmp == state->packet_count;
  
#line 450 
  return __retres;
}


#line 453  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.c"
static int efx_end_loopback(struct efx_tx_queue *tx_queue, struct efx_loopback_self_tests *lb_tests)
{
  struct sk_buff *skb;
  int rx_good;
  int rx_bad;
  int i;
  
#line 456 
  struct efx_nic *efx = tx_queue->efx;
  
#line 457 
  struct efx_loopback_state *state = (struct efx_loopback_state *)efx->loopback_selftest;
  
#line 459 
  int tx_done = 0;
  
#line 460 
  int rc = 0;
  
#line 462 
  netif_tx_lock_bh(efx->net_dev);
  
#line 466 
  i = 0;
  
#line 466 
  goto ldv_56696;
  ldv_56695: 
#line 467 
  ;
  
#line 467 
  skb = *(state->skbs + i);
  
#line 468 
  if (skb != (struct sk_buff *)0) {
    int tmp;
    
#line 468 
    tmp = skb_shared((struct sk_buff const *)skb);
    
#line 468 
    if (tmp == 0) 
#line 469 
                  tx_done += 1; else ;
  }
  else ;
  
#line 470 
  consume_skb(skb);
  
#line 466 
  i += 1;
  ldv_56696: 
#line 467 
  ;
  
#line 466 
  if (state->packet_count > i) 
#line 468 
                               goto ldv_56695; else 
#line 471 
                                                    goto ldv_56697;
  ldv_56697: 
#line 472 
  ;
  
#line 473 
  netif_tx_unlock_bh(efx->net_dev);
  
#line 476 
  rx_good = atomic_read((atomic_t const *)(& state->rx_good));
  
#line 477 
  rx_bad = atomic_read((atomic_t const *)(& state->rx_bad));
  
#line 478 
  if (state->packet_count != tx_done) {
    
#line 482 
    if ((efx->msg_enable & 1U) != 0U) {
      char const *tmp_0;
      
#line 482 
      if ((unsigned int)efx->loopback_mode < efx_loopback_mode_max) 
#line 482 
                                                                    tmp_0 = efx_loopback_mode_names[(unsigned int)efx->loopback_mode]; else 
                                                                    
#line 482 
                                                                    tmp_0 = "(invalid)";
      
#line 482 
      ;
      
#line 482 
      ;
      
#line 482 
      ;
      
#line 482 
      ;
      
#line 482 
      netdev_err((struct net_device const *)efx->net_dev,"TX queue %d saw only %d out of an expected %d ",tx_queue->queue,tx_done,state->packet_count,tmp_0);
    }
    else ;
    
#line 487 
    rc = -110;
  }
  else ;
  
#line 492 
  if (state->packet_count != rx_good) {
    
#line 493 
    if ((efx->msg_enable & 1U) != 0U) {
      
#line 493 
      struct _ddebug descriptor = {.modname = "sfc", .function = "efx_end_loopback", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.c", .format = "TX queue %d saw only %d out of an expected %d ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))497U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 493 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
        char const *tmp_1;
        
#line 493 
        if ((unsigned int)efx->loopback_mode < efx_loopback_mode_max) 
          
#line 493 
          tmp_1 = efx_loopback_mode_names[(unsigned int)efx->loopback_mode]; else 
                                                                    
#line 493 
                                                                    tmp_1 = "(invalid)";
        
#line 493 
        ;
        
#line 493 
        ;
        
#line 493 
        ;
        
#line 493 
        ;
        
#line 493 
        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"TX queue %d saw only %d out of an expected %d ",tx_queue->queue,rx_good,state->packet_count,tmp_1);
      }
      else ;
    }
    else ;
    
#line 498 
    rc = -110;
  }
  else ;
  
#line 503 
  lb_tests->tx_sent[tx_queue->queue] += state->packet_count;
  
#line 504 
  lb_tests->tx_done[tx_queue->queue] += tx_done;
  
#line 505 
  lb_tests->rx_good += rx_good;
  
#line 506 
  lb_tests->rx_bad += rx_bad;
  
#line 508 
  return rc;
}


#line 512  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.c"
static int efx_test_loopback(struct efx_tx_queue *tx_queue, struct efx_loopback_self_tests *lb_tests)
{
  int __retres;
  int i;
  int begin_rc;
  int end_rc;
  int tmp_0;
  int tmp_3;
  
#line 515 
  struct efx_nic *efx = tx_queue->efx;
  
#line 516 
  struct efx_loopback_state *state = (struct efx_loopback_state *)efx->loopback_selftest;
  
#line 519 
  i = 0;
  
#line 519 
  goto ldv_56715;
  ldv_56714: 
#line 520 
  ;
  
#line 521 
  state->packet_count = (int)(efx->txq_entries / 3U);
  {
    int tmp;
    
#line 522 
    int _min1 = 1 << (i << 2);
    
#line 522 
    int _min2 = state->packet_count;
    
#line 522 
    if (_min1 < _min2) 
#line 522 
                       tmp = _min1; else 
#line 522 
                                         tmp = _min2;
    
#line 522 
    tmp_0 = tmp;
  }
  
#line 522 
  state->packet_count = tmp_0;
  
#line 523 
  state->skbs = (struct sk_buff **)kcalloc_0((unsigned long)state->packet_count,8UL,208U);
  
#line 525 
  if (state->skbs == (struct sk_buff **)0) {
    
#line 526 
    __retres = -12;
    
#line 526 
    goto return_label;
  }
  else ;
  
#line 527 
  state->flush = (_Bool)0;
  
#line 529 
  if ((efx->msg_enable & 1U) != 0U) {
    
#line 529 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_test_loopback", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.c", .format = "TX queue %d testing %s loopback with %d packets\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))532U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 529 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      char const *tmp_2;
      
#line 529 
      ;
      
#line 529 
      if ((unsigned int)efx->loopback_mode < efx_loopback_mode_max) 
#line 529 
                                                                    tmp_2 = efx_loopback_mode_names[(unsigned int)efx->loopback_mode]; else 
                                                                    
#line 529 
                                                                    tmp_2 = "(invalid)";
      
#line 529 
      ;
      
#line 529 
      ;
      
#line 529 
      __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"TX queue %d testing %s loopback with %d packets\n",tx_queue->queue,tmp_2,state->packet_count);
    }
    else ;
  }
  else ;
  
#line 534 
  efx_iterate_state(efx);
  
#line 535 
  begin_rc = efx_begin_loopback(tx_queue);
  
#line 539 
  msleep(1U);
  
#line 540 
  tmp_3 = efx_poll_loopback(efx);
  
#line 540 
  if (tmp_3 == 0) {
    
#line 541 
    msleep(1000U);
    
#line 542 
    efx_poll_loopback(efx);
  }
  else ;
  
#line 545 
  end_rc = efx_end_loopback(tx_queue,lb_tests);
  
#line 546 
  kfree((void const *)state->skbs);
  
#line 548 
  if (begin_rc != 0 || end_rc != 0) {
    int tmp_4;
    
#line 551 
    schedule_timeout_uninterruptible(25L);
    
#line 552 
    if (begin_rc != 0) 
#line 552 
                       tmp_4 = begin_rc; else 
#line 552 
                                              tmp_4 = end_rc;
    
#line 552 
    __retres = tmp_4;
    
#line 552 
    goto return_label;
  }
  else ;
  
#line 519 
  i += 1;
  ldv_56715: 
#line 520 
  ;
  
#line 519 
  if (i <= 2) 
#line 521 
              goto ldv_56714; else 
#line 524 
                                   goto ldv_56716;
  ldv_56716: 
#line 525 
  ;
  
#line 556 
  if ((efx->msg_enable & 1U) != 0U) {
    
#line 556 
    struct _ddebug descriptor_0 = {.modname = "sfc", .function = "efx_test_loopback", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.c", .format = "TX queue %d passed %s loopback test with a burst length ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))559U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 556 
    if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) {
      char const *tmp_5;
      
#line 556 
      ;
      
#line 556 
      if ((unsigned int)efx->loopback_mode < efx_loopback_mode_max) 
#line 556 
                                                                    tmp_5 = efx_loopback_mode_names[(unsigned int)efx->loopback_mode]; else 
                                                                    
#line 556 
                                                                    tmp_5 = "(invalid)";
      
#line 556 
      ;
      
#line 556 
      ;
      
#line 556 
      __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)efx->net_dev,"TX queue %d passed %s loopback test with a burst length ",tx_queue->queue,tmp_5,state->packet_count);
    }
    else ;
  }
  else ;
  
#line 561 
  __retres = 0;
  return_label: 
#line 561 
                return __retres;
}


#line 568  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.c"
static int efx_wait_for_link(struct efx_nic *efx)
{
  int __retres;
  int count;
  bool link_up;
  
#line 570 
  struct efx_link_state *link_state = & efx->link_state;
  
#line 571 
  int link_up_count = 0;
  
#line 574 
  count = 0;
  
#line 574 
  goto ldv_56726;
  ldv_56725: 
#line 575 
  ;
  
#line 575 
  schedule_timeout_uninterruptible(25L);
  
#line 577 
  if ((efx->type)->monitor != (void (*)(struct efx_nic *))0) {
    
#line 578 
    ldv_mutex_lock_89(& efx->mac_lock);
    
#line 579 
    (*((efx->type)->monitor))(efx);
    
#line 580 
    ldv_mutex_unlock_90(& efx->mac_lock);
  }
  else ;
  
#line 583 
  ldv_mutex_lock_91(& efx->mac_lock);
  
#line 584 
  link_up = link_state->up;
  
#line 585 
  if ((int)link_up != 0) {
    int tmp_0;
    bool tmp;
    
#line 586 
    tmp = (*((efx->type)->check_mac_fault))(efx);
    
#line 586 
    if ((int)tmp != 0) 
#line 586 
                       tmp_0 = 0; else 
#line 586 
                                       tmp_0 = 1;
    
#line 586 
    link_up = (_Bool)(tmp_0 != 0);
  }
  else ;
  
#line 587 
  ldv_mutex_unlock_92(& efx->mac_lock);
  
#line 589 
  if ((int)link_up != 0) {
    
#line 590 
    link_up_count += 1;
    
#line 590 
    if (link_up_count == 2) {
      
#line 591 
      __retres = 0;
      
#line 591 
      goto return_label;
    }
    else ;
  }
  else 
#line 593 
       link_up_count = 0;
  
#line 574 
  count += 1;
  ldv_56726: 
#line 575 
  ;
  
#line 574 
  if (count <= 39) 
#line 576 
                   goto ldv_56725; else 
#line 579 
                                        goto ldv_56727;
  ldv_56727: 
#line 580 
  ;
  
#line 597 
  __retres = -110;
  return_label: 
#line 597 
                return __retres;
}


#line 600  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.c"
static int efx_test_loopbacks(struct efx_nic *efx, struct efx_self_tests *tests, unsigned int loopback_modes)
{
  int __retres;
  enum efx_loopback_mode mode;
  struct efx_loopback_state *state;
  struct efx_tx_queue *tx_queue;
  int tmp_5;
  bool tmp_4;
  
#line 605 
  struct efx_channel *channel = efx_get_channel(efx,efx->tx_channel_offset);
  
#line 608 
  int rc = 0;
  
#line 613 
  state = (struct efx_loopback_state *)kzalloc_1(136UL,208U);
  
#line 614 
  if (state == (struct efx_loopback_state *)0) {
    
#line 615 
    __retres = -12;
    
#line 615 
    goto return_label;
  }
  else ;
  
#line 616 
  if ((long)(efx->loopback_selftest != (void *)0) != 0L) {
    
#line 618 
    ldv_inline_asm();
    
#line 616 
    ;
  }
  else ;
  
#line 617 
  state->flush = (_Bool)1;
  
#line 618 
  efx->loopback_selftest = (void *)state;
  
#line 621 
  mode = LOOPBACK_NONE;
  
#line 621 
  goto ldv_56744;
  ldv_56743: 
#line 622 
  ;
  
#line 622 
  if (((unsigned int)(1 << (unsigned int)mode) & loopback_modes) == 0U) 
    
#line 623 
    goto ldv_56738; else ;
  
#line 626 
  state->flush = (_Bool)1;
  
#line 627 
  ldv_mutex_lock_93(& efx->mac_lock);
  
#line 628 
  efx->loopback_mode = mode;
  
#line 629 
  rc = __efx_reconfigure_port(efx);
  
#line 630 
  ldv_mutex_unlock_94(& efx->mac_lock);
  
#line 631 
  if (rc != 0) {
    
#line 632 
    if ((efx->msg_enable & 1U) != 0U) {
      char const *tmp_1;
      
#line 632 
      if ((unsigned int)efx->loopback_mode < efx_loopback_mode_max) 
#line 632 
                                                                    tmp_1 = efx_loopback_mode_names[(unsigned int)efx->loopback_mode]; else 
                                                                    
#line 632 
                                                                    tmp_1 = "(invalid)";
      
#line 632 
      ;
      
#line 632 
      netdev_err((struct net_device const *)efx->net_dev,"unable to move into %s loopback\n",tmp_1);
    }
    else ;
    
#line 635 
    goto out;
  }
  else ;
  
#line 638 
  rc = efx_wait_for_link(efx);
  
#line 639 
  if (rc != 0) {
    
#line 640 
    if ((efx->msg_enable & 1U) != 0U) {
      char const *tmp_2;
      
#line 640 
      if ((unsigned int)efx->loopback_mode < efx_loopback_mode_max) 
#line 640 
                                                                    tmp_2 = efx_loopback_mode_names[(unsigned int)efx->loopback_mode]; else 
                                                                    
#line 640 
                                                                    tmp_2 = "(invalid)";
      
#line 640 
      ;
      
#line 640 
      netdev_err((struct net_device const *)efx->net_dev,"loopback %s never came up\n",tmp_2);
    }
    else ;
    
#line 643 
    goto out;
  }
  else ;
  
#line 647 
  tmp_4 = efx_channel_has_tx_queues(channel);
  
#line 647 
  if (tmp_4) 
#line 647 
             tmp_5 = 0; else 
#line 647 
                             tmp_5 = 1;
  
#line 647 
  if (tmp_5) ;
  else {
    
#line 647 
    tx_queue = (struct efx_tx_queue *)(& channel->tx_queue);
    
#line 647 
    goto ldv_56741;
    ldv_56740: 
#line 648 
    ;
    
#line 648 
    state->offload_csum = (_Bool)((tx_queue->queue & 1U) != 0U);
    
#line 650 
    rc = efx_test_loopback(tx_queue,& tests->loopback[(unsigned int)mode]);
    
#line 652 
    if (rc != 0) 
#line 653 
                 goto out; else ;
    
#line 647 
    tx_queue += 1;
    ldv_56741: 
#line 648 
    ;
    
#line 647 
    if ((struct efx_tx_queue *)(& channel->tx_queue) + 4U > tx_queue) {
      bool tmp_3;
      
#line 647 
      tmp_3 = efx_tx_queue_used(tx_queue);
      
#line 647 
      if ((int)tmp_3 != 0) 
#line 649 
                           goto ldv_56740; else 
#line 652 
                                                goto ldv_56742;
    }
    else 
#line 652 
         goto ldv_56742;
    ldv_56742: 
#line 653 
    ;
  }
  ldv_56738: 
#line 655 
  ;
  
#line 621 
  mode += 1U;
  ldv_56744: 
#line 622 
  ;
  
#line 621 
  if (mode <= (unsigned int)LOOPBACK_PMAPMD) 
#line 623 
                                             goto ldv_56743; else 
#line 626 
                                                                  goto ldv_56745;
  ldv_56745: 
#line 627 
  ;
  out: 
#line 657 
  ;
  
#line 659 
  state->flush = (_Bool)1;
  
#line 660 
  efx->loopback_selftest = (void *)0;
  
#line 661 
  ldv_inline_asm();
  
#line 662 
  kfree((void const *)state);
  
#line 664 
  __retres = rc;
  return_label: 
#line 664 
                return __retres;
}


#line 673  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.c"
int efx_selftest(struct efx_nic *efx, struct efx_self_tests *tests, unsigned int flags)
{
  int __retres;
  int rc_reset;
  int rc;
  
#line 676 
  enum efx_loopback_mode loopback_mode = efx->loopback_mode;
  
#line 677 
  int phy_mode = (int)efx->phy_mode;
  
#line 678 
  int rc_test = 0;
  
#line 680 
  efx_selftest_async_cancel(efx);
  
#line 685 
  rc = efx_test_phy_alive(efx,tests);
  
#line 686 
  if (rc != 0 && rc_test == 0) 
#line 687 
                               rc_test = rc; else ;
  
#line 689 
  rc = efx_test_nvram(efx,tests);
  
#line 690 
  if (rc != 0 && rc_test == 0) 
#line 691 
                               rc_test = rc; else ;
  
#line 693 
  rc = efx_test_interrupts(efx,tests);
  
#line 694 
  if (rc != 0 && rc_test == 0) 
#line 695 
                               rc_test = rc; else ;
  
#line 697 
  rc = efx_test_eventq_irq(efx,tests);
  
#line 698 
  if (rc != 0 && rc_test == 0) 
#line 699 
                               rc_test = rc; else ;
  
#line 701 
  if (rc_test != 0) {
    
#line 702 
    __retres = rc_test;
    
#line 702 
    goto return_label;
  }
  else ;
  
#line 704 
  if ((flags & 1U) == 0U) {
    int tmp;
    
#line 705 
    tmp = efx_test_phy(efx,tests,flags);
    
#line 705 
    __retres = tmp;
    
#line 705 
    goto return_label;
  }
  else ;
  
#line 713 
  efx_device_detach_sync(efx);
  
#line 715 
  if ((efx->type)->test_chip != (int (*)(struct efx_nic *, struct efx_self_tests *))0) {
    
#line 716 
    rc_reset = (*((efx->type)->test_chip))(efx,tests);
    
#line 717 
    if (rc_reset != 0) {
      
#line 718 
      if ((efx->msg_enable & 8192U) != 0U) 
#line 718 
                                           netdev_err((struct net_device const *)efx->net_dev,"Unable to recover from chip test\n"); else ;
      
#line 720 
      efx_schedule_reset(efx,(enum reset_type)RESET_TYPE_DISABLE);
      
#line 721 
      __retres = rc_reset;
      
#line 721 
      goto return_label;
    }
    else ;
    
#line 724 
    if ((tests->memory < 0 || tests->registers < 0) && rc_test == 0) 
      
#line 725 
      rc_test = -5; else ;
  }
  else ;
  
#line 730 
  ldv_mutex_lock_95(& efx->mac_lock);
  
#line 731 
  efx->phy_mode = (enum efx_phy_mode)((unsigned int)efx->phy_mode & 4294967293U);
  
#line 732 
  efx->loopback_mode = LOOPBACK_NONE;
  
#line 733 
  __efx_reconfigure_port(efx);
  
#line 734 
  ldv_mutex_unlock_96(& efx->mac_lock);
  
#line 736 
  rc = efx_test_phy(efx,tests,flags);
  
#line 737 
  if (rc != 0 && rc_test == 0) 
#line 738 
                               rc_test = rc; else ;
  
#line 740 
  rc = efx_test_loopbacks(efx,tests,(unsigned int)efx->loopback_modes);
  
#line 741 
  if (rc != 0 && rc_test == 0) 
#line 742 
                               rc_test = rc; else ;
  
#line 745 
  ldv_mutex_lock_97(& efx->mac_lock);
  
#line 746 
  efx->phy_mode = (enum efx_phy_mode)phy_mode;
  
#line 747 
  efx->loopback_mode = loopback_mode;
  
#line 748 
  __efx_reconfigure_port(efx);
  
#line 749 
  ldv_mutex_unlock_98(& efx->mac_lock);
  
#line 751 
  netif_device_attach(efx->net_dev);
  
#line 753 
  __retres = rc_test;
  return_label: 
#line 753 
                return __retres;
}


#line 756  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.c"
void efx_selftest_async_start(struct efx_nic *efx)
{
  struct efx_channel *channel;
  
#line 760 
  channel = efx->channel[0];
  
#line 760 
  goto ldv_56761;
  ldv_56760: 
#line 761 
  ;
  
#line 761 
  efx_nic_event_test_start(channel);
  
#line 760 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 760 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 760 
                                                                    channel = (struct efx_channel *)0;
  ldv_56761: 
#line 761 
  ;
  
#line 760 
  if (channel != (struct efx_channel *)0) 
#line 762 
                                          goto ldv_56760; else 
#line 765 
                                                               goto ldv_56762;
  ldv_56762: 
#line 766 
  ;
  
#line 762 
  ldv_schedule_delayed_work_99(& efx->selftest_work,250UL);
  
#line 763 
  return;
}


#line 765  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.c"
void efx_selftest_async_cancel(struct efx_nic *efx)
{
  
#line 767 
  cancel_delayed_work_sync(& efx->selftest_work);
  
#line 768 
  return;
}


#line 770  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.c"
void efx_selftest_async_work(struct work_struct *data)
{
  struct efx_nic *tmp;
  struct efx_channel *channel;
  int cpu;
  {
    
#line 772 
    struct work_struct const *__mptr = (struct work_struct const *)data;
    
#line 772 
    tmp = (struct efx_nic *)__mptr + 18446744073709549112U;
  }
  
#line 772 
  struct efx_nic *efx = tmp;
  
#line 777 
  channel = efx->channel[0];
  
#line 777 
  goto ldv_56777;
  ldv_56776: 
#line 778 
  ;
  
#line 778 
  cpu = efx_nic_event_test_irq_cpu(channel);
  
#line 779 
  if (cpu < 0) {
    
#line 780 
    if ((efx->msg_enable & 32U) != 0U) 
#line 780 
                                       netdev_err((struct net_device const *)efx->net_dev,"channel %d failed to trigger an interrupt\n",channel->channel); else ;
  }
  else 
    
#line 784 
    if ((efx->msg_enable & 32U) != 0U) {
      
#line 784 
      struct _ddebug descriptor = {.modname = "sfc", .function = "efx_selftest_async_work", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/selftest.c", .format = "channel %d triggered interrupt on CPU %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))786U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 784 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 784 
                                                          __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"channel %d triggered interrupt on CPU %d\n",channel->channel,cpu); else ;
    }
    else ;
  
#line 777 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 777 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 777 
                                                                    channel = (struct efx_channel *)0;
  ldv_56777: 
#line 778 
  ;
  
#line 777 
  if (channel != (struct efx_channel *)0) 
#line 779 
                                          goto ldv_56776; else 
#line 782 
                                                               goto ldv_56778;
  ldv_56778: 
#line 783 
  ;
  
#line 784 
  return;
}


#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_selftest.c.aux"
_Bool ldv_emg_schedule_delayed_work(struct delayed_work *arg0, unsigned long arg1);


#line 125  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_selftest.c.aux"
static void atomic_inc_0(atomic_t *v)
{
  
#line 128 
  ldv_atomic_inc(v);
  
#line 129 
  return;
}


#line 611  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_selftest.c.aux"
static void *kcalloc_0(size_t n, size_t size, gfp_t flags)
{
  void *tmp;
  
#line 614 
  tmp = ldv_kcalloc(n,size,flags);
  
#line 614 
  return tmp;
}


#line 618  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_selftest.c.aux"
static void *kzalloc_1(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 621 
  tmp = ldv_kzalloc(size,flags);
  
#line 621 
  return tmp;
}


#line 625  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_selftest.c.aux"
static void ldv_spin_lock_62_0(spinlock_t *lock)
{
  
#line 629 
  ldv_spin_model_lock((char *)"_xmit_lock_of_netdev_queue");
  
#line 631 
  spin_lock_0(lock);
  
#line 632 
  return;
}


#line 668  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_selftest.c.aux"
static void ldv_spin_unlock_65_0(spinlock_t *lock)
{
  
#line 672 
  ldv_spin_model_unlock((char *)"_xmit_lock_of_netdev_queue");
  
#line 674 
  spin_unlock_0(lock);
  
#line 675 
  return;
}


#line 688  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_selftest.c.aux"
static void ldv_spin_lock_67_0(spinlock_t *lock)
{
  
#line 692 
  ldv_spin_model_lock((char *)"tx_global_lock_of_net_device");
  
#line 694 
  spin_lock_0(lock);
  
#line 695 
  return;
}


#line 698  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_selftest.c.aux"
static void ldv_spin_unlock_68_0(spinlock_t *lock)
{
  
#line 702 
  ldv_spin_model_unlock((char *)"tx_global_lock_of_net_device");
  
#line 704 
  spin_unlock_0(lock);
  
#line 705 
  return;
}


#line 888  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_selftest.c.aux"
static void ldv_mutex_lock_87(struct mutex *ldv_func_arg1)
{
  
#line 892 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 893 
  return;
}


#line 896  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_selftest.c.aux"
static void ldv_mutex_unlock_88(struct mutex *ldv_func_arg1)
{
  
#line 900 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 901 
  return;
}


#line 904  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_selftest.c.aux"
static void ldv_mutex_lock_89(struct mutex *ldv_func_arg1)
{
  
#line 908 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 909 
  return;
}


#line 912  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_selftest.c.aux"
static void ldv_mutex_unlock_90(struct mutex *ldv_func_arg1)
{
  
#line 916 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 917 
  return;
}


#line 920  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_selftest.c.aux"
static void ldv_mutex_lock_91(struct mutex *ldv_func_arg1)
{
  
#line 924 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 925 
  return;
}


#line 928  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_selftest.c.aux"
static void ldv_mutex_unlock_92(struct mutex *ldv_func_arg1)
{
  
#line 932 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 933 
  return;
}


#line 936  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_selftest.c.aux"
static void ldv_mutex_lock_93(struct mutex *ldv_func_arg1)
{
  
#line 940 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 941 
  return;
}


#line 944  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_selftest.c.aux"
static void ldv_mutex_unlock_94(struct mutex *ldv_func_arg1)
{
  
#line 948 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 949 
  return;
}


#line 952  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_selftest.c.aux"
static void ldv_mutex_lock_95(struct mutex *ldv_func_arg1)
{
  
#line 956 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 957 
  return;
}


#line 960  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_selftest.c.aux"
static void ldv_mutex_unlock_96(struct mutex *ldv_func_arg1)
{
  
#line 964 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 965 
  return;
}


#line 968  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_selftest.c.aux"
static void ldv_mutex_lock_97(struct mutex *ldv_func_arg1)
{
  
#line 972 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 973 
  return;
}


#line 976  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_selftest.c.aux"
static void ldv_mutex_unlock_98(struct mutex *ldv_func_arg1)
{
  
#line 980 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 981 
  return;
}


#line 984  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_selftest.c.aux"
static bool ldv_schedule_delayed_work_99(struct delayed_work *dwork, unsigned long delay)
{
  bool __retres;
  bool tmp;
  
#line 988 
  tmp = ldv_emg_schedule_delayed_work(dwork,delay);
  
#line 988 
  __retres = tmp != 0;
  
#line 988 
  return __retres;
}


#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_1(spinlock_t *lock)
{
  
#line 312 
  _raw_spin_lock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 313 
  return;
}


#line 346 
static void ldv_spin_lock_62_1(spinlock_t *lock);


#line 350 
static void ldv_spin_lock_67_1(spinlock_t *lock);


#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_1(spinlock_t *lock)
{
  
#line 365 
  _raw_spin_unlock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 366 
  return;
}


#line 395 
static void ldv_spin_unlock_65_1(spinlock_t *lock);


#line 399 
static void ldv_spin_unlock_68_1(spinlock_t *lock);


#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwsem.h"
void down_write(struct rw_semaphore *);


#line 133 
void up_write(struct rw_semaphore *);


#line 542  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kcalloc_1(size_t n, size_t size, gfp_t flags);


#line 1672  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
int pci_enable_sriov(struct pci_dev *, int);


#line 1673 
void pci_disable_sriov(struct pci_dev *);


#line 1674 
int pci_num_vf(struct pci_dev *);


#line 1675 
int pci_vfs_assigned(struct pci_dev *);


#line 1677 
int pci_sriov_get_totalvfs(struct pci_dev *);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/random.h"
void get_random_bytes(void *, int);


#line 3170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void __netif_tx_lock_1(struct netdev_queue *txq, int cpu)
{
  
#line 3172 
  ldv_spin_lock_62_1(& txq->_xmit_lock);
  
#line 3173 
  txq->xmit_lock_owner = cpu;
  
#line 3174 
  return;
}


#line 3190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void __netif_tx_unlock_1(struct netdev_queue *txq)
{
  
#line 3192 
  txq->xmit_lock_owner = -1;
  
#line 3193 
  ldv_spin_unlock_65_1(& txq->_xmit_lock);
  
#line 3194 
  return;
}


#line 3214  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_lock_1(struct net_device *dev)
{
  unsigned int i;
  int cpu;
  int tmp_3;
  
#line 3219 
  ldv_spin_lock_67_1(& dev->tx_global_lock);
  {
    int pscr_ret__;
    {
      
#line 3220 
      void const *__vpp_verify = (void const *)0;
      
#line 3220 
      void const *tmp = __vpp_verify;
    }
    
#line 3220 
    switch (4UL) {
      int tmp_0;
      int tmp_0_0;
      int tmp_1;
      int tmp_2;
      case (unsigned long)1: 
#line 3220 
      ;
      {
        int pfo_ret__;
        
#line 3220 
        switch (4UL) {
          case (unsigned long)1: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45289;
          case (unsigned long)2: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45289;
          case (unsigned long)4: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45289;
          case (unsigned long)8: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45289;
          default: 
#line 3220 
          ;
          
#line 3220 
          __bad_percpu_size();
        }
        ldv_45289: 
#line 3220 
        ;
        
#line 3220 
        tmp_0 = pfo_ret__;
      }
      
#line 3220 
      pscr_ret__ = tmp_0;
      
#line 3220 
      goto ldv_45295;
      case (unsigned long)2: 
#line 3220 
      ;
      {
        int pfo_ret___0;
        
#line 3220 
        switch (4UL) {
          case (unsigned long)1: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45299;
          case (unsigned long)2: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45299;
          case (unsigned long)4: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45299;
          case (unsigned long)8: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45299;
          default: 
#line 3220 
          ;
          
#line 3220 
          __bad_percpu_size();
        }
        ldv_45299: 
#line 3220 
        ;
        
#line 3220 
        tmp_0_0 = pfo_ret___0;
      }
      
#line 3220 
      pscr_ret__ = tmp_0_0;
      
#line 3220 
      goto ldv_45295;
      case (unsigned long)4: 
#line 3220 
      ;
      {
        int pfo_ret___1;
        
#line 3220 
        switch (4UL) {
          case (unsigned long)1: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45308;
          case (unsigned long)2: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45308;
          case (unsigned long)4: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45308;
          case (unsigned long)8: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45308;
          default: 
#line 3220 
          ;
          
#line 3220 
          __bad_percpu_size();
        }
        ldv_45308: 
#line 3220 
        ;
        
#line 3220 
        tmp_1 = pfo_ret___1;
      }
      
#line 3220 
      pscr_ret__ = tmp_1;
      
#line 3220 
      goto ldv_45295;
      case (unsigned long)8: 
#line 3220 
      ;
      {
        int pfo_ret___2;
        
#line 3220 
        switch (4UL) {
          case (unsigned long)1: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45317;
          case (unsigned long)2: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45317;
          case (unsigned long)4: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45317;
          case (unsigned long)8: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45317;
          default: 
#line 3220 
          ;
          
#line 3220 
          __bad_percpu_size();
        }
        ldv_45317: 
#line 3220 
        ;
        
#line 3220 
        tmp_2 = pfo_ret___2;
      }
      
#line 3220 
      pscr_ret__ = tmp_2;
      
#line 3220 
      goto ldv_45295;
      default: 
#line 3220 
      ;
      
#line 3220 
      __bad_size_call_parameter();
      
#line 3220 
      goto ldv_45295;
    }
    ldv_45295: 
#line 3220 
    ;
    
#line 3220 
    tmp_3 = pscr_ret__;
  }
  
#line 3220 
  cpu = tmp_3;
  
#line 3221 
  i = 0U;
  
#line 3221 
  goto ldv_45327;
  ldv_45326: 
#line 3222 
  ;
  {
    
#line 3222 
    struct netdev_queue *txq = netdev_get_tx_queue((struct net_device const *)dev,i);
    
#line 3230 
    __netif_tx_lock_1(txq,cpu);
    
#line 3231 
    set_bit(2L,(unsigned long volatile *)(& txq->state));
    
#line 3232 
    __netif_tx_unlock_1(txq);
  }
  
#line 3221 
  i += 1U;
  ldv_45327: 
#line 3222 
  ;
  
#line 3221 
  if (dev->num_tx_queues > i) 
#line 3223 
                              goto ldv_45326; else 
#line 3226 
                                                   goto ldv_45328;
  ldv_45328: 
#line 3227 
  ;
  
#line 3228 
  return;
}


#line 3236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_lock_bh_0(struct net_device *dev)
{
  
#line 3238 
  local_bh_disable();
  
#line 3239 
  netif_tx_lock_1(dev);
  
#line 3240 
  return;
}


#line 3242  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_unlock_1(struct net_device *dev)
{
  unsigned int i;
  
#line 3246 
  i = 0U;
  
#line 3246 
  goto ldv_45338;
  ldv_45337: 
#line 3247 
  ;
  {
    
#line 3247 
    struct netdev_queue *txq = netdev_get_tx_queue((struct net_device const *)dev,i);
    
#line 3253 
    set_bit(2L,(unsigned long volatile *)(& txq->state));
    
#line 3254 
    netif_schedule_queue(txq);
  }
  
#line 3246 
  i += 1U;
  ldv_45338: 
#line 3247 
  ;
  
#line 3246 
  if (dev->num_tx_queues > i) 
#line 3248 
                              goto ldv_45337; else 
#line 3251 
                                                   goto ldv_45339;
  ldv_45339: 
#line 3252 
  ;
  
#line 3256 
  ldv_spin_unlock_68_1(& dev->tx_global_lock);
  
#line 3257 
  return;
}


#line 3259  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_unlock_bh_0(struct net_device *dev)
{
  
#line 3261 
  netif_tx_unlock_1(dev);
  
#line 3262 
  local_bh_enable();
  
#line 3263 
  return;
}


#line 3830 
void netdev_warn(struct net_device const *, char const * , ...);


#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool is_zero_ether_addr(u8 const *addr)
{
  bool __retres;
  
#line 96 
  __retres = (_Bool)((*((u32 const *)addr) | (unsigned int)*((u16 const *)(addr + 4U))) == 0U);
  
#line 96 
  return __retres;
}


#line 186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool is_valid_ether_addr(u8 const *addr)
{
  bool __retres;
  int tmp_3;
  int tmp_0;
  bool tmp;
  
#line 190 
  tmp = is_multicast_ether_addr(addr);
  
#line 190 
  if (tmp) 
#line 190 
           tmp_0 = 0; else 
#line 190 
                           tmp_0 = 1;
  
#line 190 
  if (tmp_0) {
    int tmp_2;
    bool tmp_1;
    
#line 190 
    tmp_1 = is_zero_ether_addr(addr);
    
#line 190 
    if (tmp_1) 
#line 190 
               tmp_2 = 0; else 
#line 190 
                               tmp_2 = 1;
    
#line 190 
    if (tmp_2) 
#line 190 
               tmp_3 = 1; else 
#line 190 
                               tmp_3 = 0;
  }
  else 
#line 190 
       tmp_3 = 0;
  
#line 190 
  __retres = (_Bool)(tmp_3 != 0);
  
#line 190 
  return __retres;
}


#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static void eth_random_addr(u8 *addr)
{
  
#line 220 
  get_random_bytes((void *)addr,6);
  
#line 221 
  *addr = (unsigned char)((unsigned int)*addr & 254U);
  
#line 222 
  *addr = (unsigned char)((unsigned int)*addr | 2U);
  
#line 223 
  return;
}


#line 244  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static void eth_zero_addr(u8 *addr)
{
  
#line 246 
  memset((void *)addr,0,6UL);
  
#line 247 
  return;
}


#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.h"
int efx_ef10_sriov_configure(struct efx_nic *efx, int num_vfs);


#line 40 
int efx_ef10_sriov_init(struct efx_nic *efx);


#line 42 
void efx_ef10_sriov_fini(struct efx_nic *efx);


#line 45 
int efx_ef10_sriov_set_vf_mac(struct efx_nic *efx, int vf_i, u8 *mac);


#line 47 
int efx_ef10_sriov_set_vf_vlan(struct efx_nic *efx, int vf_i, u16 vlan, u8 qos);


#line 50 
int efx_ef10_sriov_set_vf_spoofchk(struct efx_nic *efx, int vf_i, bool spoofchk);


#line 53 
int efx_ef10_sriov_get_vf_config(struct efx_nic *efx, int vf_i, struct ifla_vf_info *ivf);


#line 56 
int efx_ef10_sriov_set_vf_link_state(struct efx_nic *efx, int vf_i, int link_state);


#line 59 
int efx_ef10_sriov_get_phys_port_id(struct efx_nic *efx, struct netdev_phys_item_id *ppid);


#line 62 
int efx_ef10_vswitching_probe_pf(struct efx_nic *efx);


#line 63 
int efx_ef10_vswitching_probe_vf(struct efx_nic *efx);


#line 64 
int efx_ef10_vswitching_restore_pf(struct efx_nic *efx);


#line 65 
int efx_ef10_vswitching_restore_vf(struct efx_nic *efx);


#line 66 
void efx_ef10_vswitching_remove_pf(struct efx_nic *efx);


#line 67 
void efx_ef10_vswitching_remove_vf(struct efx_nic *efx);


#line 68 
int efx_ef10_vport_add_mac(struct efx_nic *efx, unsigned int port_id, u8 *mac);


#line 70 
int efx_ef10_vport_del_mac(struct efx_nic *efx, unsigned int port_id, u8 *mac);


#line 72 
int efx_ef10_vadaptor_alloc(struct efx_nic *efx, unsigned int port_id);


#line 73 
int efx_ef10_vadaptor_free(struct efx_nic *efx, unsigned int port_id);


#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
int efx_net_open(struct net_device *net_dev);


#line 23 
int efx_net_stop(struct net_device *net_dev);


#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
__inline static void efx_device_detach_sync_0(struct efx_nic *efx)
{
  
#line 259 
  struct net_device *dev = efx->net_dev;
  
#line 265 
  netif_tx_lock_bh_0(dev);
  
#line 266 
  netif_device_detach(dev);
  
#line 267 
  netif_tx_unlock_bh_0(dev);
  
#line 268 
  return;
}


#line 137  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.h"
int efx_mcdi_rpc(struct efx_nic *efx, unsigned int cmd, efx_dword_t const *inbuf, size_t inlen, efx_dword_t *outbuf, size_t outlen, size_t *outlen_actual);


#line 140 
int efx_mcdi_rpc_quiet(struct efx_nic *efx, unsigned int cmd, efx_dword_t const *inbuf, size_t inlen, efx_dword_t *outbuf, size_t outlen, size_t *outlen_actual);


#line 168 
void efx_mcdi_display_error(struct efx_nic *efx, unsigned int cmd, size_t inlen, efx_dword_t *outbuf, size_t outlen, int rc);


#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c"
static int efx_ef10_evb_port_assign(struct efx_nic *efx, unsigned int port_id, unsigned int vf_fn)
{
  int tmp;
  
#line 20 
  efx_dword_t inbuf[2U] = {{.u32 = {0U}}};
  
#line 21 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 23 
  ((efx_dword_t *)(& inbuf))->u32[0] = port_id;
  
#line 24 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = nic_data->pf_index | (vf_fn << 16);
  
#line 28 
  tmp = efx_mcdi_rpc(efx,154U,(efx_dword_t const *)(& inbuf),8UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 28 
  return tmp;
}


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c"
static int efx_ef10_vswitch_alloc(struct efx_nic *efx, unsigned int port_id, unsigned int vswitch_type)
{
  int rc;
  
#line 35 
  efx_dword_t inbuf[4U] = {{.u32 = {0U}}};
  
#line 38 
  ((efx_dword_t *)(& inbuf))->u32[0] = port_id;
  
#line 39 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = vswitch_type;
  
#line 40 
  ((efx_dword_t *)(& inbuf) + 3U)->u32[0] = 2U;
  
#line 41 
  ((efx_dword_t *)(& inbuf) + 2U)->u32[0] = 0U;
  
#line 45 
  rc = efx_mcdi_rpc_quiet(efx,148U,(efx_dword_t const *)(& inbuf),16UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 49 
  if (rc == -71) {
    
#line 50 
    ((efx_dword_t *)(& inbuf) + 3U)->u32[0] = 1U;
    
#line 51 
    rc = efx_mcdi_rpc(efx,148U,(efx_dword_t const *)(& inbuf),16UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  }
  else 
    
#line 53 
    if (rc != 0) 
#line 54 
                 efx_mcdi_display_error(efx,148U,16UL,(efx_dword_t *)0,0UL,rc); else ;
  
#line 58 
  return rc;
}


#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c"
static int efx_ef10_vswitch_free(struct efx_nic *efx, unsigned int port_id)
{
  int tmp;
  
#line 63 
  efx_dword_t inbuf[1U] = {{.u32 = {0U}}};
  
#line 65 
  ((efx_dword_t *)(& inbuf))->u32[0] = port_id;
  
#line 67 
  tmp = efx_mcdi_rpc(efx,149U,(efx_dword_t const *)(& inbuf),4UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 67 
  return tmp;
}


#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c"
static int efx_ef10_vport_alloc(struct efx_nic *efx, unsigned int port_id_in, unsigned int vport_type, u16 vlan, unsigned int *port_id_out)
{
  int __retres;
  size_t outlen;
  int rc;
  
#line 77 
  efx_dword_t inbuf[5U] = {{.u32 = {0U}}};
  
#line 78 
  efx_dword_t outbuf[1U] = {{.u32 = {0U}}};
  
#line 84 
  ((efx_dword_t *)(& inbuf))->u32[0] = port_id_in;
  
#line 85 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = vport_type;
  
#line 86 
  ((efx_dword_t *)(& inbuf) + 3U)->u32[0] = (unsigned int)((unsigned int)vlan != 0U);
  
#line 88 
  ((efx_dword_t *)(& inbuf) + 2U)->u32[0] = 0U;
  
#line 90 
  if ((unsigned int)vlan != 0U) 
#line 91 
                                ((efx_dword_t *)(& inbuf) + 4U)->u32[0] = (unsigned int)vlan; else ;
  
#line 94 
  rc = efx_mcdi_rpc(efx,150U,(efx_dword_t const *)(& inbuf),20UL,(efx_dword_t *)(& outbuf),4UL,& outlen);
  
#line 96 
  if (rc != 0) {
    
#line 97 
    __retres = rc;
    
#line 97 
    goto return_label;
  }
  else ;
  
#line 98 
  if (outlen <= 3UL) {
    
#line 99 
    __retres = -5;
    
#line 99 
    goto return_label;
  }
  else ;
  
#line 101 
  *port_id_out = ((efx_dword_t *)(& outbuf))->u32[0];
  
#line 102 
  __retres = 0;
  return_label: 
#line 102 
                return __retres;
}


#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c"
static int efx_ef10_vport_free(struct efx_nic *efx, unsigned int port_id)
{
  int tmp;
  
#line 107 
  efx_dword_t inbuf[1U] = {{.u32 = {0U}}};
  
#line 109 
  ((efx_dword_t *)(& inbuf))->u32[0] = port_id;
  
#line 111 
  tmp = efx_mcdi_rpc(efx,151U,(efx_dword_t const *)(& inbuf),4UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 111 
  return tmp;
}


#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c"
static void efx_ef10_sriov_free_vf_vports(struct efx_nic *efx)
{
  int i;
  
#line 117 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 120 
  if (nic_data->vf == (struct ef10_vf *)0) 
#line 121 
                                           goto return_label; else ;
  
#line 123 
  i = 0;
  
#line 123 
  goto ldv_56528;
  ldv_56527: 
#line 124 
  ;
  {
    int tmp_0;
    bool tmp;
    
#line 124 
    struct ef10_vf *vf = nic_data->vf + i;
    
#line 127 
    if (vf->pci_dev != (struct pci_dev *)0 && ((int)(vf->pci_dev)->dev_flags & 4) != 0) 
      
#line 129 
      goto ldv_56526; else ;
    
#line 131 
    if (vf->vport_assigned != 0U) {
      
#line 132 
      efx_ef10_evb_port_assign(efx,0U,(unsigned int)i);
      
#line 133 
      vf->vport_assigned = 0U;
    }
    else ;
    
#line 136 
    tmp = is_zero_ether_addr((u8 const *)(& vf->mac));
    
#line 136 
    if (tmp) 
#line 136 
             tmp_0 = 0; else 
#line 136 
                             tmp_0 = 1;
    
#line 136 
    if (tmp_0) {
      
#line 137 
      efx_ef10_vport_del_mac(efx,vf->vport_id,(u8 *)(& vf->mac));
      
#line 138 
      eth_zero_addr((u8 *)(& vf->mac));
    }
    else ;
    
#line 141 
    if (vf->vport_id != 0U) {
      
#line 142 
      efx_ef10_vport_free(efx,vf->vport_id);
      
#line 143 
      vf->vport_id = 0U;
    }
    else ;
    
#line 146 
    vf->efx = (struct efx_nic *)0;
  }
  ldv_56526: 
#line 148 
  ;
  
#line 123 
  i += 1;
  ldv_56528: 
#line 124 
  ;
  
#line 123 
  if (efx->vf_count > (unsigned int)i) 
#line 125 
                                       goto ldv_56527; else 
#line 128 
                                                            goto ldv_56529;
  ldv_56529: 
#line 129 
  ;
  return_label: 
#line 130 
                return;
}


#line 150  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c"
static void efx_ef10_sriov_free_vf_vswitching(struct efx_nic *efx)
{
  
#line 152 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 154 
  efx_ef10_sriov_free_vf_vports(efx);
  
#line 155 
  kfree((void const *)nic_data->vf);
  
#line 156 
  nic_data->vf = (struct ef10_vf *)0;
  
#line 157 
  return;
}


#line 159  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c"
static int efx_ef10_sriov_assign_vf_vport(struct efx_nic *efx, unsigned int vf_i)
{
  int __retres;
  int rc;
  int tmp_0;
  
#line 162 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 163 
  struct ef10_vf *vf = nic_data->vf + vf_i;
  {
    bool __warned;
    
#line 166 
    int __ret_warn_once = nic_data->vf == (struct ef10_vf *)0;
    
#line 166 
    if ((long)(__ret_warn_once != 0) != 0L) {
      int tmp;
      {
        
#line 166 
        int __ret_warn_on = ! __warned;
        
#line 166 
        if ((long)(__ret_warn_on != 0) != 0L) 
#line 166 
                                              warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c",166); else ;
        
#line 166 
        tmp = (long)(__ret_warn_on != 0);
      }
      
#line 166 
      if ((long)tmp != 0L) 
#line 166 
                           __warned = (_Bool)1; else ;
    }
    else ;
    
#line 166 
    tmp_0 = (long)(__ret_warn_once != 0);
  }
  
#line 166 
  if ((long)tmp_0 != 0L) {
    
#line 167 
    __retres = -95;
    
#line 167 
    goto return_label;
  }
  else ;
  
#line 169 
  rc = efx_ef10_vport_alloc(efx,16777216U,4U,(unsigned short)((int)vf->vlan),& vf->vport_id);
  
#line 172 
  if (rc != 0) {
    
#line 173 
    __retres = rc;
    
#line 173 
    goto return_label;
  }
  else ;
  
#line 175 
  rc = efx_ef10_vport_add_mac(efx,vf->vport_id,(u8 *)(& vf->mac));
  
#line 176 
  if (rc != 0) {
    
#line 177 
    eth_zero_addr((u8 *)(& vf->mac));
    
#line 178 
    __retres = rc;
    
#line 178 
    goto return_label;
  }
  else ;
  
#line 181 
  rc = efx_ef10_evb_port_assign(efx,vf->vport_id,vf_i);
  
#line 182 
  if (rc != 0) {
    
#line 183 
    __retres = rc;
    
#line 183 
    goto return_label;
  }
  else ;
  
#line 185 
  vf->vport_assigned = 1U;
  
#line 186 
  __retres = 0;
  return_label: 
#line 186 
                return __retres;
}


#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c"
static int efx_ef10_sriov_alloc_vf_vswitching(struct efx_nic *efx)
{
  int __retres;
  unsigned int i;
  int rc;
  
#line 191 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 195 
  nic_data->vf = (struct ef10_vf *)kcalloc_1((unsigned long)efx->vf_count,32UL,208U);
  
#line 197 
  if (nic_data->vf == (struct ef10_vf *)0) {
    
#line 198 
    __retres = -12;
    
#line 198 
    goto return_label;
  }
  else ;
  
#line 200 
  i = 0U;
  
#line 200 
  goto ldv_56554;
  ldv_56553: 
#line 201 
  ;
  
#line 201 
  eth_random_addr((u8 *)(& (nic_data->vf + i)->mac));
  
#line 202 
  (nic_data->vf + i)->efx = (struct efx_nic *)0;
  
#line 203 
  (nic_data->vf + i)->vlan = (unsigned short)0U;
  
#line 205 
  rc = efx_ef10_sriov_assign_vf_vport(efx,i);
  
#line 206 
  if (rc != 0) 
#line 207 
               goto fail; else ;
  
#line 200 
  i += 1U;
  ldv_56554: 
#line 201 
  ;
  
#line 200 
  if (efx->vf_count > i) 
#line 202 
                         goto ldv_56553; else 
#line 205 
                                              goto ldv_56555;
  ldv_56555: 
#line 206 
  ;
  
#line 210 
  __retres = 0;
  
#line 210 
  goto return_label;
  fail: 
#line 211 
  ;
  
#line 212 
  efx_ef10_sriov_free_vf_vports(efx);
  
#line 213 
  kfree((void const *)nic_data->vf);
  
#line 214 
  nic_data->vf = (struct ef10_vf *)0;
  
#line 215 
  __retres = rc;
  return_label: 
#line 215 
                return __retres;
}


#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c"
static int efx_ef10_sriov_restore_vf_vswitching(struct efx_nic *efx)
{
  int __retres;
  unsigned int i;
  int rc;
  
#line 223 
  i = 0U;
  
#line 223 
  goto ldv_56563;
  ldv_56562: 
#line 224 
  ;
  
#line 224 
  rc = efx_ef10_sriov_assign_vf_vport(efx,i);
  
#line 225 
  if (rc != 0) 
#line 226 
               goto fail; else ;
  
#line 223 
  i += 1U;
  ldv_56563: 
#line 224 
  ;
  
#line 223 
  if (efx->vf_count > i) 
#line 225 
                         goto ldv_56562; else 
#line 228 
                                              goto ldv_56564;
  ldv_56564: 
#line 229 
  ;
  
#line 229 
  __retres = 0;
  
#line 229 
  goto return_label;
  fail: 
#line 230 
  ;
  
#line 231 
  efx_ef10_sriov_free_vf_vswitching(efx);
  
#line 232 
  __retres = rc;
  return_label: 
#line 232 
                return __retres;
}


#line 238  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c"
int efx_ef10_vswitching_probe_pf(struct efx_nic *efx)
{
  int __retres;
  int rc;
  int tmp;
  
#line 240 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 241 
  struct net_device *net_dev = efx->net_dev;
  
#line 244 
  tmp = pci_sriov_get_totalvfs(efx->pci_dev);
  
#line 244 
  if (tmp <= 0) {
    
#line 246 
    efx_ef10_vadaptor_alloc(efx,nic_data->vport_id);
    
#line 247 
    __retres = 0;
    
#line 247 
    goto return_label;
  }
  else ;
  
#line 250 
  rc = efx_ef10_vswitch_alloc(efx,16777216U,2U);
  
#line 252 
  if (rc != 0) 
#line 253 
               goto fail1; else ;
  
#line 255 
  rc = efx_ef10_vport_alloc(efx,16777216U,4U,(unsigned short)0,& nic_data->vport_id);
  
#line 258 
  if (rc != 0) 
#line 259 
               goto fail2; else ;
  
#line 261 
  rc = efx_ef10_vport_add_mac(efx,nic_data->vport_id,net_dev->dev_addr);
  
#line 262 
  if (rc != 0) 
#line 263 
               goto fail3; else ;
  
#line 264 
  ether_addr_copy((u8 *)(& nic_data->vport_mac),(u8 const *)net_dev->dev_addr);
  
#line 266 
  rc = efx_ef10_vadaptor_alloc(efx,nic_data->vport_id);
  
#line 267 
  if (rc != 0) 
#line 268 
               goto fail4; else ;
  
#line 270 
  __retres = 0;
  
#line 270 
  goto return_label;
  fail4: 
#line 271 
  ;
  
#line 272 
  efx_ef10_vport_del_mac(efx,nic_data->vport_id,(u8 *)(& nic_data->vport_mac));
  
#line 273 
  eth_zero_addr((u8 *)(& nic_data->vport_mac));
  fail3: 
#line 274 
  ;
  
#line 275 
  efx_ef10_vport_free(efx,nic_data->vport_id);
  
#line 276 
  nic_data->vport_id = 16777216U;
  fail2: 
#line 277 
  ;
  
#line 278 
  efx_ef10_vswitch_free(efx,16777216U);
  fail1: 
#line 279 
  ;
  
#line 280 
  __retres = rc;
  return_label: 
#line 280 
                return __retres;
}


#line 283  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c"
int efx_ef10_vswitching_probe_vf(struct efx_nic *efx)
{
  int tmp;
  
#line 285 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 287 
  tmp = efx_ef10_vadaptor_alloc(efx,nic_data->vport_id);
  
#line 287 
  return tmp;
}


#line 290  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c"
int efx_ef10_vswitching_restore_pf(struct efx_nic *efx)
{
  int __retres;
  int rc;
  
#line 292 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 295 
  if (! nic_data->must_probe_vswitching) {
    
#line 296 
    __retres = 0;
    
#line 296 
    goto return_label;
  }
  else ;
  
#line 298 
  rc = efx_ef10_vswitching_probe_pf(efx);
  
#line 299 
  if (rc != 0) 
#line 300 
               goto fail; else ;
  
#line 302 
  rc = efx_ef10_sriov_restore_vf_vswitching(efx);
  
#line 303 
  if (rc != 0) 
#line 304 
               goto fail; else ;
  
#line 306 
  nic_data->must_probe_vswitching = (_Bool)0;
  fail: 
#line 307 
  ;
  
#line 308 
  __retres = rc;
  return_label: 
#line 308 
                return __retres;
}


#line 311  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c"
int efx_ef10_vswitching_restore_vf(struct efx_nic *efx)
{
  int __retres;
  int rc;
  
#line 313 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 316 
  if (! nic_data->must_probe_vswitching) {
    
#line 317 
    __retres = 0;
    
#line 317 
    goto return_label;
  }
  else ;
  
#line 319 
  rc = efx_ef10_vadaptor_free(efx,16777216U);
  
#line 320 
  if (rc != 0) {
    
#line 321 
    __retres = rc;
    
#line 321 
    goto return_label;
  }
  else ;
  
#line 323 
  nic_data->must_probe_vswitching = (_Bool)0;
  
#line 324 
  __retres = 0;
  return_label: 
#line 324 
                return __retres;
}


#line 327  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c"
void efx_ef10_vswitching_remove_pf(struct efx_nic *efx)
{
  int tmp_0;
  bool tmp;
  int tmp_1;
  
#line 329 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 331 
  efx_ef10_sriov_free_vf_vswitching(efx);
  
#line 333 
  efx_ef10_vadaptor_free(efx,nic_data->vport_id);
  
#line 335 
  if (nic_data->vport_id == 16777216U) 
#line 336 
                                       goto return_label; else ;
  
#line 338 
  tmp = is_zero_ether_addr((u8 const *)(& nic_data->vport_mac));
  
#line 338 
  if (tmp) 
#line 338 
           tmp_0 = 0; else 
#line 338 
                           tmp_0 = 1;
  
#line 338 
  if (tmp_0) {
    
#line 339 
    efx_ef10_vport_del_mac(efx,nic_data->vport_id,(efx->net_dev)->dev_addr);
    
#line 341 
    eth_zero_addr((u8 *)(& nic_data->vport_mac));
  }
  else ;
  
#line 343 
  efx_ef10_vport_free(efx,nic_data->vport_id);
  
#line 344 
  nic_data->vport_id = 16777216U;
  
#line 347 
  tmp_1 = pci_vfs_assigned(efx->pci_dev);
  
#line 347 
  if (tmp_1 == 0) 
#line 348 
                  efx_ef10_vswitch_free(efx,nic_data->vport_id); else ;
  return_label: 
#line 349 
                return;
}


#line 351  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c"
void efx_ef10_vswitching_remove_vf(struct efx_nic *efx)
{
  
#line 353 
  efx_ef10_vadaptor_free(efx,16777216U);
  
#line 354 
  return;
}


#line 356  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c"
static int efx_ef10_pci_sriov_enable(struct efx_nic *efx, int num_vfs)
{
  int __retres;
  
#line 358 
  int rc = 0;
  
#line 359 
  struct pci_dev *dev = efx->pci_dev;
  
#line 361 
  efx->vf_count = (unsigned int)num_vfs;
  
#line 363 
  rc = efx_ef10_sriov_alloc_vf_vswitching(efx);
  
#line 364 
  if (rc != 0) 
#line 365 
               goto fail1; else ;
  
#line 367 
  rc = pci_enable_sriov(dev,num_vfs);
  
#line 368 
  if (rc != 0) 
#line 369 
               goto fail2; else ;
  
#line 371 
  __retres = 0;
  
#line 371 
  goto return_label;
  fail2: 
#line 372 
  ;
  
#line 373 
  efx_ef10_sriov_free_vf_vswitching(efx);
  fail1: 
#line 374 
  ;
  
#line 375 
  efx->vf_count = 0U;
  
#line 376 
  if ((efx->msg_enable & 2U) != 0U) 
#line 376 
                                    netdev_err((struct net_device const *)efx->net_dev,"Failed to enable SRIOV VFs\n"); else ;
  
#line 378 
  __retres = rc;
  return_label: 
#line 378 
                return __retres;
}


#line 381  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c"
static int efx_ef10_pci_sriov_disable(struct efx_nic *efx, bool force)
{
  int __retres;
  int tmp;
  
#line 383 
  struct pci_dev *dev = efx->pci_dev;
  
#line 384 
  unsigned int vfs_assigned = 0U;
  
#line 386 
  tmp = pci_vfs_assigned(dev);
  
#line 386 
  vfs_assigned = (unsigned int)tmp;
  
#line 388 
  if (vfs_assigned != 0U && ! force) {
    
#line 389 
    if ((efx->msg_enable & 1U) != 0U) 
#line 389 
                                      netdev_info((struct net_device const *)efx->net_dev,"VFs are assigned to guests; "); else ;
    
#line 391 
    __retres = -16;
    
#line 391 
    goto return_label;
  }
  else ;
  
#line 394 
  if (vfs_assigned == 0U) 
#line 395 
                          pci_disable_sriov(dev); else ;
  
#line 397 
  efx_ef10_sriov_free_vf_vswitching(efx);
  
#line 398 
  efx->vf_count = 0U;
  
#line 399 
  __retres = 0;
  return_label: 
#line 399 
                return __retres;
}


#line 402  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c"
int efx_ef10_sriov_configure(struct efx_nic *efx, int num_vfs)
{
  int __retres;
  
#line 404 
  if (num_vfs == 0) {
    int tmp;
    
#line 405 
    tmp = efx_ef10_pci_sriov_disable(efx,(_Bool)0);
    
#line 405 
    __retres = tmp;
    
#line 405 
    goto return_label;
  }
  else {
    int tmp_0;
    
#line 407 
    tmp_0 = efx_ef10_pci_sriov_enable(efx,num_vfs);
    
#line 407 
    __retres = tmp_0;
    
#line 407 
    goto return_label;
  }
  return_label: 
#line 404 
                return __retres;
}


#line 410  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c"
int efx_ef10_sriov_init(struct efx_nic *efx)
{
  int __retres;
  
#line 412 
  __retres = 0;
  
#line 412 
  return __retres;
}


#line 415  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c"
void efx_ef10_sriov_fini(struct efx_nic *efx)
{
  unsigned int i;
  int rc;
  
#line 417 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 421 
  if (nic_data->vf == (struct ef10_vf *)0) {
    int tmp;
    
#line 423 
    tmp = pci_num_vf(efx->pci_dev);
    
#line 423 
    if (tmp != 0) {
      int tmp_0;
      
#line 423 
      tmp_0 = pci_vfs_assigned(efx->pci_dev);
      
#line 423 
      if (tmp_0 == 0) 
#line 424 
                      pci_disable_sriov(efx->pci_dev); else ;
    }
    else ;
    
#line 425 
    goto return_label;
  }
  else ;
  
#line 429 
  i = 0U;
  
#line 429 
  goto ldv_56626;
  ldv_56625: 
#line 430 
  ;
  {
    
#line 430 
    struct efx_nic *vf_efx = (nic_data->vf + i)->efx;
    
#line 432 
    if (vf_efx != (struct efx_nic *)0) 
#line 433 
                                       (*(((vf_efx->pci_dev)->driver)->remove))(vf_efx->pci_dev); else ;
  }
  
#line 429 
  i += 1U;
  ldv_56626: 
#line 430 
  ;
  
#line 429 
  if (efx->vf_count > i) 
#line 431 
                         goto ldv_56625; else 
#line 434 
                                              goto ldv_56627;
  ldv_56627: 
#line 435 
  ;
  
#line 436 
  rc = efx_ef10_pci_sriov_disable(efx,(_Bool)1);
  
#line 437 
  if (rc != 0) {
    
#line 438 
    if ((efx->msg_enable & 1U) != 0U) {
      
#line 438 
      struct _ddebug descriptor = {.modname = "sfc", .function = "efx_ef10_sriov_fini", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c", .format = "Disabling SRIOV was not successful rc=%d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))439U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 438 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 438 
                                                          __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"Disabling SRIOV was not successful rc=%d\n",rc); else ;
    }
    else ;
  }
  else 
    
#line 441 
    if ((efx->msg_enable & 1U) != 0U) {
      
#line 441 
      struct _ddebug descriptor_0 = {.modname = "sfc", .function = "efx_ef10_sriov_fini", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c", .format = "SRIOV disabled\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))441U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 441 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 441 
                                                            __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)efx->net_dev,"SRIOV disabled\n"); else ;
    }
    else ;
  return_label: 
#line 443 
                return;
}


#line 444  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c"
static int efx_ef10_vport_del_vf_mac(struct efx_nic *efx, unsigned int port_id, u8 *mac)
{
  size_t outlen;
  int rc;
  
#line 447 
  efx_dword_t inbuf[3U] = {{.u32 = {0U}}};
  
#line 448 
  efx_dword_t outbuf[2U] = {{.u32 = {0U}}};
  
#line 452 
  ((efx_dword_t *)(& inbuf))->u32[0] = port_id;
  
#line 453 
  ether_addr_copy((u8 *)(& inbuf) + 4U,(u8 const *)mac);
  
#line 455 
  rc = efx_mcdi_rpc(efx,169U,(efx_dword_t const *)(& inbuf),12UL,(efx_dword_t *)(& outbuf),8UL,& outlen);
  
#line 458 
  return rc;
}


#line 461  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c"
int efx_ef10_sriov_set_vf_mac(struct efx_nic *efx, int vf_i, u8 *mac)
{
  int __retres;
  struct ef10_vf *vf;
  int rc;
  int tmp_0;
  bool tmp;
  int tmp_2;
  bool tmp_1;
  
#line 463 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 467 
  if (nic_data->vf == (struct ef10_vf *)0) {
    
#line 468 
    __retres = -95;
    
#line 468 
    goto return_label;
  }
  else ;
  
#line 470 
  if (efx->vf_count <= (unsigned int)vf_i) {
    
#line 471 
    __retres = -22;
    
#line 471 
    goto return_label;
  }
  else ;
  
#line 472 
  vf = nic_data->vf + vf_i;
  
#line 474 
  if (vf->efx != (struct efx_nic *)0) {
    
#line 475 
    efx_device_detach_sync_0(vf->efx);
    
#line 476 
    efx_net_stop((vf->efx)->net_dev);
    
#line 478 
    down_write(& (vf->efx)->filter_sem);
    
#line 479 
    (*(((vf->efx)->type)->filter_table_remove))(vf->efx);
    
#line 481 
    rc = efx_ef10_vadaptor_free(vf->efx,16777216U);
    
#line 482 
    if (rc != 0) {
      
#line 483 
      up_write(& (vf->efx)->filter_sem);
      
#line 484 
      __retres = rc;
      
#line 484 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 488 
  rc = efx_ef10_evb_port_assign(efx,0U,(unsigned int)vf_i);
  
#line 489 
  if (rc != 0) {
    
#line 490 
    __retres = rc;
    
#line 490 
    goto return_label;
  }
  else ;
  
#line 492 
  tmp = is_zero_ether_addr((u8 const *)(& vf->mac));
  
#line 492 
  if (tmp) 
#line 492 
           tmp_0 = 0; else 
#line 492 
                           tmp_0 = 1;
  
#line 492 
  if (tmp_0) {
    
#line 493 
    rc = efx_ef10_vport_del_vf_mac(efx,vf->vport_id,(u8 *)(& vf->mac));
    
#line 494 
    if (rc != 0) {
      
#line 495 
      __retres = rc;
      
#line 495 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 498 
  tmp_1 = is_zero_ether_addr((u8 const *)mac);
  
#line 498 
  if (tmp_1) 
#line 498 
             tmp_2 = 0; else 
#line 498 
                             tmp_2 = 1;
  
#line 498 
  if (tmp_2) {
    
#line 499 
    rc = efx_ef10_vport_add_mac(efx,vf->vport_id,mac);
    
#line 500 
    if (rc != 0) {
      
#line 501 
      eth_zero_addr((u8 *)(& vf->mac));
      
#line 502 
      goto fail;
    }
    else ;
    
#line 504 
    if (vf->efx != (struct efx_nic *)0) 
#line 505 
                                        ether_addr_copy(((vf->efx)->net_dev)->dev_addr,(u8 const *)mac); else ;
  }
  else ;
  
#line 508 
  ether_addr_copy((u8 *)(& vf->mac),(u8 const *)mac);
  
#line 510 
  rc = efx_ef10_evb_port_assign(efx,vf->vport_id,(unsigned int)vf_i);
  
#line 511 
  if (rc != 0) 
#line 512 
               goto fail; else ;
  
#line 514 
  if (vf->efx != (struct efx_nic *)0) {
    
#line 516 
    rc = efx_ef10_vadaptor_alloc(vf->efx,16777216U);
    
#line 517 
    if (rc != 0) {
      
#line 518 
      up_write(& (vf->efx)->filter_sem);
      
#line 519 
      __retres = rc;
      
#line 519 
      goto return_label;
    }
    else ;
    
#line 521 
    (*(((vf->efx)->type)->filter_table_probe))(vf->efx);
    
#line 522 
    up_write(& (vf->efx)->filter_sem);
    
#line 523 
    efx_net_open((vf->efx)->net_dev);
    
#line 524 
    netif_device_attach((vf->efx)->net_dev);
  }
  else ;
  
#line 527 
  __retres = 0;
  
#line 527 
  goto return_label;
  fail: 
#line 529 
  ;
  
#line 530 
  memset((void *)(& vf->mac),0,6UL);
  
#line 531 
  __retres = rc;
  return_label: 
#line 531 
                return __retres;
}


#line 534  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c"
int efx_ef10_sriov_set_vf_vlan(struct efx_nic *efx, int vf_i, u16 vlan, u8 qos)
{
  int __retres;
  struct ef10_vf *vf;
  u16 old_vlan;
  u16 new_vlan;
  int tmp_0;
  bool tmp;
  int tmp_2;
  bool tmp_1;
  int tmp_3;
  
#line 537 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 540 
  int rc = 0;
  
#line 540 
  int rc2 = 0;
  
#line 542 
  if (efx->vf_count <= (unsigned int)vf_i) {
    
#line 543 
    __retres = -22;
    
#line 543 
    goto return_label;
  }
  else ;
  
#line 544 
  if ((unsigned int)qos != 0U) {
    
#line 545 
    __retres = -22;
    
#line 545 
    goto return_label;
  }
  else ;
  
#line 547 
  vf = nic_data->vf + vf_i;
  
#line 549 
  new_vlan = vlan;
  
#line 550 
  if ((int)vf->vlan == (int)new_vlan) {
    
#line 551 
    __retres = 0;
    
#line 551 
    goto return_label;
  }
  else ;
  
#line 553 
  if (vf->efx != (struct efx_nic *)0) {
    
#line 554 
    efx_device_detach_sync_0(vf->efx);
    
#line 555 
    efx_net_stop((vf->efx)->net_dev);
    
#line 557 
    down_write(& (vf->efx)->filter_sem);
    
#line 558 
    (*(((vf->efx)->type)->filter_table_remove))(vf->efx);
    
#line 560 
    rc = efx_ef10_vadaptor_free(vf->efx,16777216U);
    
#line 561 
    if (rc != 0) 
#line 562 
                 goto restore_filters; else ;
  }
  else ;
  
#line 565 
  if (vf->vport_assigned != 0U) {
    
#line 566 
    rc = efx_ef10_evb_port_assign(efx,0U,(unsigned int)vf_i);
    
#line 567 
    if (rc != 0) {
      
#line 568 
      if ((efx->msg_enable & 1U) != 0U) 
#line 568 
                                        netdev_warn((struct net_device const *)efx->net_dev,"Failed to change vlan on VF %d.\n",vf_i); else ;
      
#line 570 
      if ((efx->msg_enable & 1U) != 0U) 
#line 570 
                                        netdev_warn((struct net_device const *)efx->net_dev,"This is likely because the VF is bound to a driver in a VM.\n"); else ;
      
#line 572 
      if ((efx->msg_enable & 1U) != 0U) 
#line 572 
                                        netdev_warn((struct net_device const *)efx->net_dev,"Please unload the driver in the VM.\n"); else ;
      
#line 574 
      goto restore_vadaptor;
    }
    else ;
    
#line 576 
    vf->vport_assigned = 0U;
  }
  else ;
  
#line 579 
  tmp = is_zero_ether_addr((u8 const *)(& vf->mac));
  
#line 579 
  if (tmp) 
#line 579 
           tmp_0 = 0; else 
#line 579 
                           tmp_0 = 1;
  
#line 579 
  if (tmp_0) {
    
#line 580 
    rc = efx_ef10_vport_del_mac(efx,vf->vport_id,(u8 *)(& vf->mac));
    
#line 581 
    if (rc != 0) 
#line 582 
                 goto restore_evb_port; else ;
  }
  else ;
  
#line 585 
  if (vf->vport_id != 0U) {
    
#line 586 
    rc = efx_ef10_vport_free(efx,vf->vport_id);
    
#line 587 
    if (rc != 0) 
#line 588 
                 goto restore_mac; else ;
    
#line 589 
    vf->vport_id = 0U;
  }
  else ;
  
#line 593 
  old_vlan = vf->vlan;
  
#line 594 
  vf->vlan = new_vlan;
  
#line 597 
  rc = efx_ef10_vport_alloc(efx,16777216U,4U,(unsigned short)((int)vf->vlan),& vf->vport_id);
  
#line 600 
  if (rc != 0) 
#line 601 
               goto reset_nic_up_write; else ;
  restore_mac: 
#line 603 
  ;
  
#line 604 
  tmp_1 = is_zero_ether_addr((u8 const *)(& vf->mac));
  
#line 604 
  if (tmp_1) 
#line 604 
             tmp_2 = 0; else 
#line 604 
                             tmp_2 = 1;
  
#line 604 
  if (tmp_2) {
    
#line 605 
    rc2 = efx_ef10_vport_add_mac(efx,vf->vport_id,(u8 *)(& vf->mac));
    
#line 606 
    if (rc2 != 0) {
      
#line 607 
      eth_zero_addr((u8 *)(& vf->mac));
      
#line 608 
      goto reset_nic_up_write;
    }
    else ;
  }
  else ;
  restore_evb_port: 
#line 612 
  ;
  
#line 613 
  rc2 = efx_ef10_evb_port_assign(efx,vf->vport_id,(unsigned int)vf_i);
  
#line 614 
  if (rc2 != 0) 
#line 615 
                goto reset_nic_up_write; else 
#line 617 
                                              vf->vport_assigned = 1U;
  restore_vadaptor: 
#line 619 
  ;
  
#line 620 
  if (vf->efx != (struct efx_nic *)0) {
    
#line 621 
    rc2 = efx_ef10_vadaptor_alloc(vf->efx,16777216U);
    
#line 622 
    if (rc2 != 0) 
#line 623 
                  goto reset_nic_up_write; else ;
  }
  else ;
  restore_filters: 
#line 626 
  ;
  
#line 627 
  if (vf->efx != (struct efx_nic *)0) {
    
#line 628 
    rc2 = (*(((vf->efx)->type)->filter_table_probe))(vf->efx);
    
#line 629 
    if (rc2 != 0) 
#line 630 
                  goto reset_nic_up_write; else ;
    
#line 632 
    up_write(& (vf->efx)->filter_sem);
    
#line 634 
    up_write(& (vf->efx)->filter_sem);
    
#line 636 
    rc2 = efx_net_open((vf->efx)->net_dev);
    
#line 637 
    if (rc2 != 0) 
#line 638 
                  goto reset_nic; else ;
    
#line 640 
    netif_device_attach((vf->efx)->net_dev);
  }
  else ;
  
#line 642 
  __retres = rc;
  
#line 642 
  goto return_label;
  reset_nic_up_write: 
#line 644 
  ;
  
#line 645 
  if (vf->efx != (struct efx_nic *)0) 
#line 646 
                                      up_write(& (vf->efx)->filter_sem); else ;
  reset_nic: 
#line 648 
  ;
  
#line 649 
  if (vf->efx != (struct efx_nic *)0) {
    
#line 650 
    if ((efx->msg_enable & 1U) != 0U) 
#line 650 
                                      netdev_err((struct net_device const *)efx->net_dev,"Failed to restore VF - scheduling reset.\n"); else ;
    
#line 652 
    efx_schedule_reset(vf->efx,(enum reset_type)RESET_TYPE_DATAPATH);
  }
  else {
    
#line 654 
    if ((efx->msg_enable & 1U) != 0U) 
#line 654 
                                      netdev_err((struct net_device const *)efx->net_dev,"Failed to restore the VF and cannot reset the VF "); else ;
    
#line 657 
    if ((efx->msg_enable & 1U) != 0U) 
#line 657 
                                      netdev_err((struct net_device const *)efx->net_dev,"Please reload the driver attached to the VF.\n"); else ;
  }
  
#line 661 
  if (rc != 0) 
#line 661 
               tmp_3 = rc; else 
#line 661 
                                tmp_3 = rc2;
  
#line 661 
  __retres = tmp_3;
  return_label: 
#line 661 
                return __retres;
}


#line 664  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c"
int efx_ef10_sriov_set_vf_spoofchk(struct efx_nic *efx, int vf_i, bool spoofchk)
{
  int tmp;
  
#line 667 
  if ((int)spoofchk != 0) 
#line 667 
                          tmp = -95; else 
#line 667 
                                          tmp = 0;
  
#line 667 
  return tmp;
}


#line 676 
void __compiletime_assert_677(void);


#line 678 
void __compiletime_assert_679(void);


#line 680 
void __compiletime_assert_681(void);


#line 670  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c"
int efx_ef10_sriov_set_vf_link_state(struct efx_nic *efx, int vf_i, int link_state)
{
  int tmp;
  
#line 673 
  efx_dword_t inbuf[2U] = {{.u32 = {0U}}};
  
#line 674 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  {
    
#line 676 
    bool __cond = (_Bool)0;
    
#line 676 
    if ((int)__cond != 0) 
#line 676 
                          __compiletime_assert_677(); else ;
  }
  {
    
#line 678 
    bool __cond_0 = (_Bool)0;
    
#line 678 
    if ((int)__cond_0 != 0) 
#line 678 
                            __compiletime_assert_679(); else ;
  }
  {
    
#line 680 
    bool __cond_1 = (_Bool)0;
    
#line 680 
    if ((int)__cond_1 != 0) 
#line 680 
                            __compiletime_assert_681(); else ;
  }
  
#line 682 
  ((efx_dword_t *)(& inbuf))->u32[0] = nic_data->pf_index | ((unsigned int)vf_i << 16);
  
#line 686 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = (unsigned int)link_state;
  
#line 687 
  tmp = efx_mcdi_rpc(efx,92U,(efx_dword_t const *)(& inbuf),8UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 687 
  return tmp;
}


#line 691  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c"
int efx_ef10_sriov_get_vf_config(struct efx_nic *efx, int vf_i, struct ifla_vf_info *ivf)
{
  int __retres;
  struct ef10_vf *vf;
  size_t outlen;
  int rc;
  int tmp;
  
#line 694 
  efx_dword_t inbuf[2U] = {{.u32 = {0U}}};
  
#line 695 
  efx_dword_t outbuf[1U] = {{.u32 = {0U}}};
  
#line 697 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 702 
  if (efx->vf_count <= (unsigned int)vf_i) {
    
#line 703 
    __retres = -22;
    
#line 703 
    goto return_label;
  }
  else ;
  
#line 705 
  if (nic_data->vf == (struct ef10_vf *)0) {
    
#line 706 
    __retres = -95;
    
#line 706 
    goto return_label;
  }
  else ;
  
#line 708 
  vf = nic_data->vf + vf_i;
  
#line 710 
  ivf->vf = (unsigned int)vf_i;
  
#line 711 
  ivf->min_tx_rate = 0U;
  
#line 712 
  ivf->max_tx_rate = 0U;
  
#line 713 
  ether_addr_copy((u8 *)(& ivf->mac),(u8 const *)(& vf->mac));
  
#line 714 
  if ((unsigned int)vf->vlan != 0U) 
#line 714 
                                    tmp = (int)vf->vlan; else 
#line 714 
                                                              tmp = 0;
  
#line 714 
  ivf->vlan = (unsigned int)tmp;
  
#line 715 
  ivf->qos = 0U;
  
#line 717 
  ((efx_dword_t *)(& inbuf))->u32[0] = nic_data->pf_index | ((unsigned int)vf_i << 16);
  
#line 721 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = 4294967295U;
  
#line 723 
  rc = efx_mcdi_rpc(efx,92U,(efx_dword_t const *)(& inbuf),8UL,(efx_dword_t *)(& outbuf),4UL,& outlen);
  
#line 725 
  if (rc != 0) {
    
#line 726 
    __retres = rc;
    
#line 726 
    goto return_label;
  }
  else ;
  
#line 727 
  if (outlen <= 3UL) {
    
#line 728 
    __retres = -5;
    
#line 728 
    goto return_label;
  }
  else ;
  
#line 729 
  ivf->linkstate = ((efx_dword_t *)(& outbuf))->u32[0];
  
#line 731 
  __retres = 0;
  return_label: 
#line 731 
                return __retres;
}


#line 734  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.c"
int efx_ef10_sriov_get_phys_port_id(struct efx_nic *efx, struct netdev_phys_item_id *ppid)
{
  int __retres;
  int tmp_0;
  bool tmp;
  
#line 737 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 739 
  tmp = is_valid_ether_addr((u8 const *)(& nic_data->port_id));
  
#line 739 
  if (tmp) 
#line 739 
           tmp_0 = 0; else 
#line 739 
                           tmp_0 = 1;
  
#line 739 
  if (tmp_0) {
    
#line 740 
    __retres = -95;
    
#line 740 
    goto return_label;
  }
  else ;
  
#line 742 
  ppid->id_len = (unsigned char)6U;
  
#line 743 
  memcpy((void *)(& ppid->id),(void const *)(& nic_data->port_id),(unsigned long)ppid->id_len);
  
#line 745 
  __retres = 0;
  return_label: 
#line 745 
                return __retres;
}


#line 505  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10_sriov.c.aux"
static void *kcalloc_1(size_t n, size_t size, gfp_t flags)
{
  void *tmp;
  
#line 508 
  tmp = ldv_kcalloc(n,size,flags);
  
#line 508 
  return tmp;
}


#line 625  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10_sriov.c.aux"
static void ldv_spin_lock_62_1(spinlock_t *lock)
{
  
#line 629 
  ldv_spin_model_lock((char *)"_xmit_lock_of_netdev_queue");
  
#line 631 
  spin_lock_1(lock);
  
#line 632 
  return;
}


#line 668  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10_sriov.c.aux"
static void ldv_spin_unlock_65_1(spinlock_t *lock)
{
  
#line 672 
  ldv_spin_model_unlock((char *)"_xmit_lock_of_netdev_queue");
  
#line 674 
  spin_unlock_1(lock);
  
#line 675 
  return;
}


#line 688  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10_sriov.c.aux"
static void ldv_spin_lock_67_1(spinlock_t *lock)
{
  
#line 692 
  ldv_spin_model_lock((char *)"tx_global_lock_of_net_device");
  
#line 694 
  spin_lock_1(lock);
  
#line 695 
  return;
}


#line 698  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10_sriov.c.aux"
static void ldv_spin_unlock_68_1(spinlock_t *lock)
{
  
#line 702 
  ldv_spin_model_unlock((char *)"tx_global_lock_of_net_device");
  
#line 704 
  spin_unlock_1(lock);
  
#line 705 
  return;
}


#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/arch_hweight.h"
__inline static unsigned int __arch_hweight32(unsigned int w)
{
  
#line 26 
  unsigned int res = 0U;
  
#line 27 
  ldv_inline_asm();
  
#line 32 
  return res;
}


#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
int printk(char const * , ...);


#line 233 
void dump_stack(void);


#line 470  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_irqrestore_1(spinlock_t *lock, unsigned long flags)
{
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
  }
  
#line 472 
  _raw_spin_unlock_irqrestore(& lock->__anonCompField_spinlock_18.rlock,flags);
  
#line 473 
  return;
}


#line 502 
static void ldv_spin_unlock_irqrestore_88_0(spinlock_t *lock, unsigned long flags);


#line 510 
static void ldv_spin_unlock_irqrestore_92_1(spinlock_t *lock, unsigned long flags);


#line 518 
static void ldv_spin_unlock_irqrestore_96(spinlock_t *lock, unsigned long flags);


#line 40  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena.c.aux"
int ldv_mutex_model_is_locked(struct mutex *, char *);


#line 70 
static void ldv___ldv_spin_lock_87_0(spinlock_t *ldv_func_arg1);


#line 78 
static void ldv___ldv_spin_lock_91_1(spinlock_t *ldv_func_arg1);


#line 86 
static void ldv___ldv_spin_lock_95(spinlock_t *ldv_func_arg1);


#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
static int ldv_mutex_is_locked_97(struct mutex *lock);


#line 542  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kcalloc_2(size_t n, size_t size, gfp_t flags);


#line 581 
static void *kzalloc_2(size_t size, gfp_t flags);


#line 1046  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
int pci_wake_from_d3(struct pci_dev *, bool);


#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rtnetlink.h"
int rtnl_is_locked(void);


#line 1082  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
__inline static unsigned int efx_port_num(struct efx_nic *efx)
{
  unsigned int __retres;
  
#line 1084 
  __retres = efx->port_num;
  
#line 1084 
  return __retres;
}


#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
void efx_reset_down(struct efx_nic *efx, enum reset_type method);


#line 195 
int efx_reset_up(struct efx_nic *efx, enum reset_type method, bool ok);


#line 209 
int efx_port_dummy_op_int(struct efx_nic *efx);


#line 210 
void efx_port_dummy_op_void(struct efx_nic *efx);


#line 213 
void efx_update_sw_stats(struct efx_nic *efx, u64 *stats);


#line 217 
int efx_mtd_add(struct efx_nic *efx, struct efx_mtd_partition *parts, size_t n_parts, size_t sizeof_part);


#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.h"
int efx_mcdi_init(struct efx_nic *efx);


#line 135 
void efx_mcdi_fini(struct efx_nic *efx);


#line 319 
int efx_mcdi_get_board_cfg(struct efx_nic *efx, u8 *mac_address, u16 *fw_subtype_list, u32 *capabilities);


#line 321 
int efx_mcdi_log_ctrl(struct efx_nic *efx, bool evq, bool uart, u32 dest_evq);


#line 322 
int efx_mcdi_nvram_types(struct efx_nic *efx, u32 *nvram_types_out);


#line 323 
int efx_mcdi_nvram_info(struct efx_nic *efx, unsigned int type, size_t *size_out, size_t *erase_size_out, bool *protected_out);


#line 326 
int efx_mcdi_nvram_test_all(struct efx_nic *efx);


#line 327 
int efx_mcdi_handle_assertion(struct efx_nic *efx);


#line 328 
void efx_mcdi_set_id_led(struct efx_nic *efx, enum efx_led_mode mode);


#line 329 
int efx_mcdi_wol_filter_set_magic(struct efx_nic *efx, u8 const *mac, int *id_out);


#line 331 
int efx_mcdi_wol_filter_get_magic(struct efx_nic *efx, int *id_out);


#line 332 
int efx_mcdi_wol_filter_remove(struct efx_nic *efx, int id);


#line 333 
int efx_mcdi_wol_filter_reset(struct efx_nic *efx);


#line 335 
int efx_mcdi_port_probe(struct efx_nic *efx);


#line 336 
void efx_mcdi_port_remove(struct efx_nic *efx);


#line 337 
int efx_mcdi_port_reconfigure(struct efx_nic *efx);


#line 341 
int efx_mcdi_set_mac(struct efx_nic *efx);


#line 343 
void efx_mcdi_mac_start_stats(struct efx_nic *efx);


#line 344 
void efx_mcdi_mac_stop_stats(struct efx_nic *efx);


#line 345 
void efx_mcdi_mac_pull_stats(struct efx_nic *efx);


#line 346 
bool efx_mcdi_mac_check_fault(struct efx_nic *efx);


#line 347 
enum reset_type efx_mcdi_map_reset_reason(enum reset_type reason);


#line 348 
int efx_mcdi_reset(struct efx_nic *efx, enum reset_type method);


#line 354 
int efx_mcdi_mon_probe(struct efx_nic *efx);


#line 355 
void efx_mcdi_mon_remove(struct efx_nic *efx);


#line 362 
int efx_mcdi_mtd_read(struct mtd_info *mtd, loff_t start, size_t len, size_t *retlen, u8 *buffer);


#line 364 
int efx_mcdi_mtd_erase(struct mtd_info *mtd, loff_t start, size_t len);


#line 365 
int efx_mcdi_mtd_write(struct mtd_info *mtd, loff_t start, size_t len, size_t *retlen, u8 const *buffer);


#line 367 
int efx_mcdi_mtd_sync(struct mtd_info *mtd);


#line 368 
void efx_mcdi_mtd_rename(struct efx_mtd_partition *part);


#line 558  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
void efx_ptp_defer_probe_with_channel(struct efx_nic *efx);


#line 564 
int efx_ptp_get_mode(struct efx_nic *efx);


#line 565 
int efx_ptp_change_mode(struct efx_nic *efx, bool enable_wanted, unsigned int new_mode);


#line 585 
struct efx_nic_type const siena_a0_nic_type;


#line 729  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
__inline static void efx_update_diff_stat(u64 *stat, u64 diff)
{
  
#line 731 
  if ((long long)(diff - *stat) > 0LL) 
#line 732 
                                       *stat = diff; else ;
  
#line 733 
  return;
}


#line 759 
void siena_prepare_flush(struct efx_nic *efx);


#line 762 
void siena_finish_flush(struct efx_nic *efx);


#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/io.h"
__inline static void efx_writeo_0(struct efx_nic *efx, efx_oword_t const *value, unsigned int reg)
{
  unsigned long flags;
  
#line 113 
  ldv___ldv_spin_lock_87_0(& efx->biu_lock);
  
#line 115 
  _efx_writeq(efx,value->u64[0],reg);
  
#line 116 
  _efx_writeq(efx,value->u64[1],reg + 8U);
  
#line 117 
  ldv_inline_asm();
  
#line 124 
  ldv_spin_unlock_irqrestore_88_0(& efx->biu_lock,flags);
  
#line 125 
  return;
}


#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/io.h"
__inline static void efx_reado_1(struct efx_nic *efx, efx_oword_t *value, unsigned int reg)
{
  unsigned long flags;
  
#line 167 
  ldv___ldv_spin_lock_91_1(& efx->biu_lock);
  
#line 168 
  value->u32[0] = _efx_readd(efx,reg);
  
#line 169 
  value->u32[1] = _efx_readd(efx,reg + 4U);
  
#line 170 
  value->u32[2] = _efx_readd(efx,reg + 8U);
  
#line 171 
  value->u32[3] = _efx_readd(efx,reg + 12U);
  
#line 172 
  ldv_spin_unlock_irqrestore_92_1(& efx->biu_lock,flags);
  
#line 176 
  return;
}


#line 282  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/io.h"
__inline static void _efx_writed_page_locked(struct efx_nic *efx, efx_dword_t const *value, unsigned int reg, unsigned int page)
{
  unsigned long flags;
  
#line 289 
  if (page == 0U) {
    
#line 290 
    ldv___ldv_spin_lock_95(& efx->biu_lock);
    
#line 291 
    efx_writed(efx,value,page * 8192U + reg);
    
#line 292 
    ldv_spin_unlock_irqrestore_96(& efx->biu_lock,flags);
  }
  else 
#line 294 
       efx_writed(efx,value,page * 8192U + reg);
  
#line 295 
  return;
}


#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.h"
int efx_siena_sriov_configure(struct efx_nic *efx, int num_vfs);


#line 45 
int efx_siena_sriov_init(struct efx_nic *efx);


#line 46 
void efx_siena_sriov_fini(struct efx_nic *efx);


#line 47 
int efx_siena_sriov_mac_address_changed(struct efx_nic *efx);


#line 48 
bool efx_siena_sriov_wanted(struct efx_nic *efx);


#line 49 
void efx_siena_sriov_reset(struct efx_nic *efx);


#line 50 
void efx_siena_sriov_flr(struct efx_nic *efx, unsigned int vf_i);


#line 52 
int efx_siena_sriov_set_vf_mac(struct efx_nic *efx, int vf_i, u8 *mac);


#line 53 
int efx_siena_sriov_set_vf_vlan(struct efx_nic *efx, int vf_i, u16 vlan, u8 qos);


#line 55 
int efx_siena_sriov_set_vf_spoofchk(struct efx_nic *efx, int vf_i, bool spoofchk);


#line 57 
int efx_siena_sriov_get_vf_config(struct efx_nic *efx, int vf_i, struct ifla_vf_info *ivi);


#line 73 
void efx_siena_sriov_probe(struct efx_nic *efx);


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static void siena_init_wol(struct efx_nic *efx);


#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static void siena_push_irq_moderation(struct efx_channel *channel)
{
  efx_dword_t timer_cmd;
  
#line 39 
  if (channel->irq_moderation != 0U) 
#line 40 
                                     timer_cmd.u32[0] = (channel->irq_moderation + 4294967295U) | 49152U; else 
                                                                    
#line 46 
                                                                    timer_cmd.u32[0] = 0U;
  
#line 50 
  _efx_writed_page_locked(channel->efx,(efx_dword_t const *)(& timer_cmd),1056U,(unsigned int)channel->channel);
  
#line 51 
  return;
}


#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
void siena_prepare_flush(struct efx_nic *efx)
{
  unsigned int tmp;
  
#line 56 
  tmp = efx->fc_disable;
  
#line 56 
  efx->fc_disable += 1U;
  
#line 56 
  ;
  
#line 56 
  if (tmp == 0U) 
#line 57 
                 efx_mcdi_set_mac(efx); else ;
  
#line 58 
  return;
}


#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
void siena_finish_flush(struct efx_nic *efx)
{
  
#line 62 
  efx->fc_disable -= 1U;
  
#line 62 
  if (efx->fc_disable == 0U) 
#line 63 
                             efx_mcdi_set_mac(efx); else ;
  
#line 64 
  return;
}


#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static struct efx_farch_register_test const siena_register_tests[13U] = {{.address = 0U, .mask = {.u32 = {262143U, 262143U, 262143U, 262143U}}}, {.address = 256U, .mask = {.u32 = {66559U, 0U, 0U, 0U}}}, {.address = 2048U, .mask = {.u32 = {4294967294U, 4294967295U, 262143U, 0U}}}, {.address = 2640U, .mask = {.u32 = {2147418167U, 4294934528U, 4294967295U, 67108863U}}}, {.address = 2688U, .mask = {.u32 = {4294901376U, 536870911U, 33554686U, 8388607U}}}, {.address = 1568U, .mask = {.u32 = {2097151U, 0U, 0U, 0U}}}, {.address = 2112U, .mask = {.u32 = {3U, 0U, 0U, 0U}}}, {.address = 2128U, .mask = {.u32 = {1023U, 0U, 0U, 0U}}}, {.address = 592U, .mask = {.u32 = {4095U, 0U, 0U, 0U}}}, {.address = 2144U, .mask = {.u32 = {4294967295U, 4294967295U, 4294967295U, 4294967295U}}}, {.address = 2256U, .mask = {.u32 = {4294967295U, 4294967295U, 4294967295U, 4294967295U}}}, {.address = 2272U, .mask = {.u32 = {4294967295U, 4294967295U, 4294967295U, 4294967295U}}}, {.address = 2288U, .mask = {.u32 = {4294967295U, 4294967295U, 7U, 0U}}}};

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static int siena_test_chip(struct efx_nic *efx, struct efx_self_tests *tests)
{
  int rc;
  int rc2;
  int tmp;
  int tmp_0;
  
#line 97 
  enum reset_type reset_method = RESET_TYPE_ALL;
  
#line 100 
  efx_reset_down(efx,reset_method);
  
#line 105 
  rc = efx_mcdi_reset(efx,reset_method);
  
#line 106 
  if (rc != 0) 
#line 107 
               goto out; else ;
  
#line 109 
  tmp = efx_farch_test_registers(efx,(struct efx_farch_register_test const *)(& siena_register_tests),13UL);
  
#line 109 
  if (tmp != 0) 
#line 109 
                tests->registers = -1; else 
#line 109 
                                            tests->registers = 1;
  
#line 114 
  rc = efx_mcdi_reset(efx,reset_method);
  out: 
#line 115 
  ;
  
#line 116 
  rc2 = efx_reset_up(efx,reset_method,(_Bool)(rc == 0));
  
#line 117 
  if (rc != 0) 
#line 117 
               tmp_0 = rc; else 
#line 117 
                                tmp_0 = rc2;
  
#line 117 
  return tmp_0;
}


#line 127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static void siena_ptp_write_host_time(struct efx_nic *efx, u32 host_time)
{
  
#line 129 
  _efx_writed(efx,host_time,16713712U);
  
#line 130 
  return;
}


#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static int siena_ptp_set_ts_config(struct efx_nic *efx, struct hwtstamp_config *init)
{
  int __retres;
  int rc;
  
#line 138 
  switch (init->rx_filter) {
    int tmp_0;
    int tmp;
    int tmp_1;
    case 0: 
#line 139 
    ;
    
#line 143 
    tmp = efx_ptp_get_mode(efx);
    
#line 141 
    ;
    
#line 141 
    ;
    
#line 141 
    tmp_0 = efx_ptp_change_mode(efx,(_Bool)(init->tx_type != 0),(unsigned int)tmp);
    
#line 141 
    __retres = tmp_0;
    
#line 141 
    goto return_label;
    case 3: 
#line 144 
    ;
    case 4: 
#line 145 
    ;
    case 5: 
#line 146 
    ;
    
#line 147 
    init->rx_filter = 3;
    
#line 148 
    tmp_1 = efx_ptp_change_mode(efx,(_Bool)1,0U);
    
#line 148 
    __retres = tmp_1;
    
#line 148 
    goto return_label;
    case 6: 
#line 149 
    ;
    case 7: 
#line 150 
    ;
    case 8: 
#line 151 
    ;
    
#line 152 
    init->rx_filter = 6;
    
#line 153 
    rc = efx_ptp_change_mode(efx,(_Bool)1,4U);
    
#line 160 
    if (rc != 0) 
#line 161 
                 rc = efx_ptp_change_mode(efx,(_Bool)1,2U); else ;
    
#line 162 
    __retres = rc;
    
#line 162 
    goto return_label;
    default: 
#line 163 
    ;
    
#line 164 
    __retres = -34;
    
#line 164 
    goto return_label;
  }
  return_label: 
#line 138 
                return __retres;
}


#line 175  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static int siena_map_reset_flags(u32 *flags)
{
  int __retres;
  
#line 185 
  if ((*flags & 65660U) == 65660U) {
    
#line 186 
    *flags &= 4294901635U;
    
#line 187 
    __retres = 3;
    
#line 187 
    goto return_label;
  }
  else ;
  
#line 190 
  if ((*flags & 124U) == 124U) {
    
#line 191 
    *flags &= 4294967171U;
    
#line 192 
    __retres = 2;
    
#line 192 
    goto return_label;
  }
  else ;
  
#line 197 
  __retres = -22;
  return_label: 
#line 197 
                return __retres;
}


#line 215  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static int siena_probe_nvconfig(struct efx_nic *efx)
{
  int rc;
  int tmp;
  
#line 217 
  u32 caps = 0U;
  
#line 220 
  rc = efx_mcdi_get_board_cfg(efx,(u8 *)(& (efx->net_dev)->perm_addr),(u16 *)0U,& caps);
  
#line 224 
  if ((caps & 4U) != 0U) 
#line 224 
                         tmp = 3072; else 
#line 224 
                                          tmp = 6144;
  
#line 222 
  efx->timer_quantum_ns = (unsigned int)tmp;
  
#line 225 
  return rc;
}


#line 228  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static int siena_dimension_resources(struct efx_nic *efx)
{
  int __retres;
  
#line 234 
  efx_farch_dimension_resources(efx,73728U);
  
#line 235 
  __retres = 0;
  
#line 235 
  return __retres;
}


#line 238  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static unsigned int siena_mem_map_size(struct efx_nic *efx)
{
  unsigned int __retres;
  
#line 240 
  __retres = 16713728U;
  
#line 240 
  return __retres;
}


#line 244  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static int siena_probe_nic(struct efx_nic *efx)
{
  int __retres;
  struct siena_nic_data *nic_data;
  efx_oword_t reg;
  int rc;
  u32 tmp_0;
  
#line 251 
  nic_data = (struct siena_nic_data *)kzalloc_2(808UL,208U);
  
#line 252 
  if (nic_data == (struct siena_nic_data *)0) {
    
#line 253 
    __retres = -12;
    
#line 253 
    goto return_label;
  }
  else ;
  
#line 254 
  nic_data->efx = efx;
  
#line 255 
  efx->nic_data = (void *)nic_data;
  
#line 257 
  tmp_0 = efx_farch_fpga_ver(efx);
  
#line 257 
  if (tmp_0 != 0U) {
    
#line 258 
    if ((efx->msg_enable & 2U) != 0U) 
#line 258 
                                      netdev_err((struct net_device const *)efx->net_dev,"Siena FPGA not supported\n"); else ;
    
#line 260 
    rc = -19;
    
#line 261 
    goto fail1;
  }
  else ;
  
#line 264 
  efx->max_channels = 32U;
  
#line 266 
  efx_reado_1(efx,& reg,624U);
  
#line 267 
  efx->port_num = ((unsigned int)(reg.u64[0] >> 40) & 3U) + 4294967295U;
  
#line 269 
  rc = efx_mcdi_init(efx);
  
#line 270 
  if (rc != 0) 
#line 271 
               goto fail1; else ;
  
#line 274 
  rc = efx_mcdi_reset(efx,(enum reset_type)RESET_TYPE_ALL);
  
#line 275 
  if (rc != 0) {
    
#line 276 
    if ((efx->msg_enable & 2U) != 0U) 
#line 276 
                                      netdev_err((struct net_device const *)efx->net_dev,"failed to reset NIC\n"); else ;
    
#line 277 
    goto fail3;
  }
  else ;
  
#line 280 
  siena_init_wol(efx);
  
#line 283 
  rc = efx_nic_alloc_buffer(efx,& efx->irq_status,16U,208U);
  
#line 285 
  if (rc != 0) 
#line 286 
               goto fail4; else ;
  
#line 287 
  if ((long)((efx->irq_status.dma_addr & 15ULL) != 0ULL) != 0L) {
    
#line 289 
    ldv_inline_asm();
    
#line 287 
    ;
  }
  else ;
  
#line 289 
  if ((efx->msg_enable & 2U) != 0U) {
    
#line 289 
    struct _ddebug descriptor = {.modname = "sfc", .function = "siena_probe_nic", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c", .format = "INT_KER at %llx (virt %p phys %llx)\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))293U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 289 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      phys_addr_t tmp_1;
      
#line 289 
      tmp_1 = virt_to_phys((void volatile *)efx->irq_status.addr);
      
#line 289 
      ;
      
#line 289 
      ;
      
#line 289 
      ;
      
#line 289 
      __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"INT_KER at %llx (virt %p phys %llx)\n",efx->irq_status.dma_addr,efx->irq_status.addr,tmp_1);
    }
    else ;
  }
  else ;
  
#line 296 
  rc = siena_probe_nvconfig(efx);
  
#line 297 
  if (rc == -22) {
    
#line 298 
    if ((efx->msg_enable & 2U) != 0U) 
#line 298 
                                      netdev_err((struct net_device const *)efx->net_dev,"NVRAM is invalid therefore using defaults\n"); else ;
    
#line 300 
    efx->phy_type = 0U;
    
#line 301 
    efx->mdio.prtad = -1;
  }
  else 
    
#line 302 
    if (rc != 0) 
#line 303 
                 goto fail5; else ;
  
#line 306 
  rc = efx_mcdi_mon_probe(efx);
  
#line 307 
  if (rc != 0) 
#line 308 
               goto fail5; else ;
  
#line 311 
  efx_siena_sriov_probe(efx);
  
#line 313 
  efx_ptp_defer_probe_with_channel(efx);
  
#line 315 
  __retres = 0;
  
#line 315 
  goto return_label;
  fail5: 
#line 317 
  ;
  
#line 318 
  efx_nic_free_buffer(efx,& efx->irq_status);
  fail4: 
#line 319 
  ;
  fail3: 
#line 320 
  ;
  
#line 321 
  efx_mcdi_fini(efx);
  fail1: 
#line 322 
  ;
  
#line 323 
  kfree((void const *)efx->nic_data);
  
#line 324 
  __retres = rc;
  return_label: 
#line 324 
                return __retres;
}


#line 337 
void __compiletime_assert_339(void);


#line 327  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static int siena_rx_push_rss_config(struct efx_nic *efx, bool user, u32 const *rx_indir_table)
{
  int __retres;
  efx_oword_t temp;
  
#line 333 
  memcpy((void *)(& temp),(void const *)(& efx->rx_hash_key),16UL);
  
#line 334 
  efx_writeo_0(efx,(efx_oword_t const *)(& temp),2144U);
  {
    
#line 337 
    bool __cond = (_Bool)0;
    
#line 337 
    if ((int)__cond != 0) 
#line 337 
                          __compiletime_assert_339(); else ;
  }
  
#line 340 
  memcpy((void *)(& temp),(void const *)(& efx->rx_hash_key),16UL);
  
#line 341 
  efx_writeo_0(efx,(efx_oword_t const *)(& temp),2256U);
  
#line 342 
  memcpy((void *)(& temp),(void const *)(& efx->rx_hash_key) + 16U,16UL);
  
#line 343 
  efx_writeo_0(efx,(efx_oword_t const *)(& temp),2272U);
  
#line 344 
  temp.u64[0] = 0ULL;
  
#line 344 
  temp.u64[1] = 6ULL;
  
#line 346 
  memcpy((void *)(& temp),(void const *)(& efx->rx_hash_key) + 32U,8UL);
  
#line 348 
  efx_writeo_0(efx,(efx_oword_t const *)(& temp),2288U);
  
#line 350 
  memcpy((void *)(& efx->rx_indir_table),(void const *)rx_indir_table,512UL);
  
#line 352 
  efx_farch_rx_push_indir_table(efx);
  
#line 354 
  __retres = 0;
  
#line 354 
  return __retres;
}


#line 361  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static int siena_init_nic(struct efx_nic *efx)
{
  int __retres;
  efx_oword_t temp;
  int rc;
  
#line 367 
  rc = efx_mcdi_handle_assertion(efx);
  
#line 368 
  if (rc != 0) {
    
#line 369 
    __retres = rc;
    
#line 369 
    goto return_label;
  }
  else ;
  
#line 372 
  efx_reado_1(efx,& temp,2688U);
  
#line 373 
  temp.u64[0] |= 128ULL;
  
#line 373 
  temp.u64[1] = temp.u64[1];
  
#line 374 
  efx_writeo_0(efx,(efx_oword_t const *)(& temp),2688U);
  
#line 379 
  efx_reado_1(efx,& temp,2640U);
  
#line 380 
  temp.u64[0] &= 18446744073709551583ULL;
  
#line 380 
  temp.u64[1] = temp.u64[1];
  
#line 381 
  temp.u64[0] |= 140737488355328ULL;
  
#line 381 
  temp.u64[1] = temp.u64[1];
  
#line 382 
  efx_writeo_0(efx,(efx_oword_t const *)(& temp),2640U);
  
#line 384 
  efx_reado_1(efx,& temp,2048U);
  
#line 385 
  temp.u64[0] &= 18446735277616529407ULL;
  
#line 385 
  temp.u64[1] = temp.u64[1];
  
#line 386 
  temp.u64[0] |= 140737488355328ULL;
  
#line 386 
  temp.u64[1] = temp.u64[1];
  
#line 390 
  temp.u64[0] |= 17592186044416ULL;
  
#line 390 
  temp.u64[1] = temp.u64[1];
  
#line 391 
  temp.u64[0] |= 35184372088832ULL;
  
#line 391 
  temp.u64[1] = temp.u64[1];
  
#line 392 
  temp.u64[0] |= 70368744177664ULL;
  
#line 392 
  temp.u64[1] = temp.u64[1];
  
#line 393 
  temp.u64[0] = (temp.u64[0] & 18446744073441640447ULL) | 29360128ULL;
  
#line 393 
  temp.u64[1] = temp.u64[1];
  
#line 395 
  efx_writeo_0(efx,(efx_oword_t const *)(& temp),2048U);
  
#line 397 
  siena_rx_push_rss_config(efx,(_Bool)0,(u32 const *)(& efx->rx_indir_table));
  
#line 400 
  rc = efx_mcdi_log_ctrl(efx,(_Bool)1,(_Bool)0,0U);
  
#line 401 
  if (rc != 0) {
    
#line 402 
    __retres = rc;
    
#line 402 
    goto return_label;
  }
  else ;
  
#line 405 
  temp.u64[0] = 0ULL;
  
#line 405 
  temp.u64[1] = 0ULL;
  
#line 406 
  efx_writeo_0(efx,(efx_oword_t const *)(& temp),592U);
  
#line 408 
  temp.u64[0] = 65536ULL;
  
#line 408 
  temp.u64[1] = 0ULL;
  
#line 409 
  efx_writeo_0(efx,(efx_oword_t const *)(& temp),256U);
  
#line 411 
  efx_farch_init_common(efx);
  
#line 412 
  __retres = 0;
  return_label: 
#line 412 
                return __retres;
}


#line 415  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static void siena_remove_nic(struct efx_nic *efx)
{
  
#line 417 
  efx_mcdi_mon_remove(efx);
  
#line 419 
  efx_nic_free_buffer(efx,& efx->irq_status);
  
#line 421 
  efx_mcdi_reset(efx,(enum reset_type)RESET_TYPE_ALL);
  
#line 423 
  efx_mcdi_fini(efx);
  
#line 426 
  kfree((void const *)efx->nic_data);
  
#line 427 
  efx->nic_data = (void *)0;
  
#line 428 
  return;
}


#line 438  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static struct efx_hw_stat_desc const siena_stat_desc[59U] = {{.name = "rx_noskb_drops", .dma_width = (unsigned short)0U, .offset = (unsigned short)0U}, {.name = "rx_nodesc_trunc", .dma_width = (unsigned short)0U, .offset = (unsigned short)0U}, {.name = "tx_bytes", .dma_width = (unsigned short)64U, .offset = (unsigned short)56U}, {.name = "tx_good_bytes", .dma_width = (unsigned short)0U, .offset = (unsigned short)0U}, {.name = "tx_bad_bytes", .dma_width = (unsigned short)64U, .offset = (unsigned short)64U}, {.name = "tx_packets", .dma_width = (unsigned short)64U, .offset = (unsigned short)8U}, {.name = "tx_bad", .dma_width = (unsigned short)64U, .offset = (unsigned short)144U}, {.name = "tx_pause", .dma_width = (unsigned short)64U, .offset = (unsigned short)16U}, {.name = "tx_control", .dma_width = (unsigned short)64U, .offset = (unsigned short)24U}, {.name = "tx_unicast", .dma_width = (unsigned short)64U, .offset = (unsigned short)32U}, {.name = "tx_multicast", .dma_width = (unsigned short)64U, .offset = (unsigned short)40U}, {.name = "tx_broadcast", .dma_width = (unsigned short)64U, .offset = (unsigned short)48U}, {.name = "tx_lt64", .dma_width = (unsigned short)64U, .offset = (unsigned short)72U}, {.name = "tx_64", .dma_width = (unsigned short)64U, .offset = (unsigned short)80U}, {.name = "tx_65_to_127", .dma_width = (unsigned short)64U, .offset = (unsigned short)88U}, {.name = "tx_128_to_255", .dma_width = (unsigned short)64U, .offset = (unsigned short)96U}, {.name = "tx_256_to_511", .dma_width = (unsigned short)64U, .offset = (unsigned short)104U}, {.name = "tx_512_to_1023", .dma_width = (unsigned short)64U, .offset = (unsigned short)112U}, {.name = "tx_1024_to_15xx", .dma_width = (unsigned short)64U, .offset = (unsigned short)120U}, {.name = "tx_15xx_to_jumbo", .dma_width = (unsigned short)64U, .offset = (unsigned short)128U}, {.name = "tx_gtjumbo", .dma_width = (unsigned short)64U, .offset = (unsigned short)136U}, {.name = "tx_collision", .dma_width = (unsigned short)0U, .offset = (unsigned short)0U}, {.name = "tx_single_collision", .dma_width = (unsigned short)64U, .offset = (unsigned short)152U}, {.name = "tx_multiple_collision", .dma_width = (unsigned short)64U, .offset = (unsigned short)160U}, {.name = "tx_excessive_collision", .dma_width = (unsigned short)64U, .offset = (unsigned short)168U}, {.name = "tx_deferred", .dma_width = (unsigned short)64U, .offset = (unsigned short)184U}, {.name = "tx_late_collision", .dma_width = (unsigned short)64U, .offset = (unsigned short)176U}, {.name = "tx_excessive_deferred", .dma_width = (unsigned short)64U, .offset = (unsigned short)192U}, {.name = "tx_non_tcpudp", .dma_width = (unsigned short)64U, .offset = (unsigned short)200U}, {.name = "tx_mac_src_error", .dma_width = (unsigned short)64U, .offset = (unsigned short)208U}, {.name = "tx_ip_src_error", .dma_width = (unsigned short)64U, .offset = (unsigned short)216U}, {.name = "rx_bytes", .dma_width = (unsigned short)64U, .offset = (unsigned short)280U}, {.name = "rx_good_bytes", .dma_width = (unsigned short)0U, .offset = (unsigned short)0U}, {.name = "rx_bad_bytes", .dma_width = (unsigned short)64U, .offset = (unsigned short)288U}, {.name = "rx_packets", .dma_width = (unsigned short)64U, .offset = (unsigned short)224U}, {.name = "rx_good", .dma_width = (unsigned short)64U, .offset = (unsigned short)240U}, {.name = "rx_bad", .dma_width = (unsigned short)64U, .offset = (unsigned short)368U}, {.name = "rx_pause", .dma_width = (unsigned short)64U, .offset = (unsigned short)232U}, {.name = "rx_control", .dma_width = (unsigned short)64U, .offset = (unsigned short)248U}, {.name = "rx_unicast", .dma_width = (unsigned short)64U, .offset = (unsigned short)256U}, {.name = "rx_multicast", .dma_width = (unsigned short)64U, .offset = (unsigned short)264U}, {.name = "rx_broadcast", .dma_width = (unsigned short)64U, .offset = (unsigned short)272U}, {.name = "rx_lt64", .dma_width = (unsigned short)64U, .offset = (unsigned short)360U}, {.name = "rx_64", .dma_width = (unsigned short)64U, .offset = (unsigned short)296U}, {.name = "rx_65_to_127", .dma_width = (unsigned short)64U, .offset = (unsigned short)304U}, {.name = "rx_128_to_255", .dma_width = (unsigned short)64U, .offset = (unsigned short)312U}, {.name = "rx_256_to_511", .dma_width = (unsigned short)64U, .offset = (unsigned short)320U}, {.name = "rx_512_to_1023", .dma_width = (unsigned short)64U, .offset = (unsigned short)328U}, {.name = "rx_1024_to_15xx", .dma_width = (unsigned short)64U, .offset = (unsigned short)336U}, {.name = "rx_15xx_to_jumbo", .dma_width = (unsigned short)64U, .offset = (unsigned short)344U}, {.name = "rx_gtjumbo", .dma_width = (unsigned short)64U, .offset = (unsigned short)352U}, {.name = "rx_bad_gtjumbo", .dma_width = (unsigned short)64U, .offset = (unsigned short)424U}, {.name = "rx_overflow", .dma_width = (unsigned short)64U, .offset = (unsigned short)376U}, {.name = "rx_false_carrier", .dma_width = (unsigned short)64U, .offset = (unsigned short)384U}, {.name = "rx_symbol_error", .dma_width = (unsigned short)64U, .offset = (unsigned short)392U}, {.name = "rx_align_error", .dma_width = (unsigned short)64U, .offset = (unsigned short)400U}, {.name = "rx_length_error", .dma_width = (unsigned short)64U, .offset = (unsigned short)408U}, {.name = "rx_internal_error", .dma_width = (unsigned short)64U, .offset = (unsigned short)416U}, {.name = "rx_nodesc_drop_cnt", .dma_width = (unsigned short)64U, .offset = (unsigned short)432U}};

#line 499  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static unsigned long const siena_stat_mask[1U] = {18446744073709551615UL};

#line 503  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static size_t siena_describe_nic_stats(struct efx_nic *efx, u8 *names)
{
  size_t tmp;
  
#line 505 
  tmp = efx_nic_describe_stats((struct efx_hw_stat_desc const *)(& siena_stat_desc),59UL,(unsigned long const *)(& siena_stat_mask),names);
  
#line 505 
  return tmp;
}


#line 509  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static int siena_try_update_nic_stats(struct efx_nic *efx)
{
  int __retres;
  __le64 *dma_stats;
  __le64 generation_start;
  __le64 generation_end;
  
#line 511 
  struct siena_nic_data *nic_data = (struct siena_nic_data *)efx->nic_data;
  
#line 512 
  u64 *stats = (u64 *)(& nic_data->stats);
  
#line 516 
  dma_stats = (__le64 *)efx->stats_buffer.addr;
  
#line 518 
  generation_end = *(dma_stats + 96U);
  
#line 519 
  if (generation_end == 18446744073709551615ULL) {
    
#line 520 
    __retres = 0;
    
#line 520 
    goto return_label;
  }
  else ;
  
#line 521 
  ldv_inline_asm();
  
#line 522 
  efx_nic_update_stats((struct efx_hw_stat_desc const *)(& siena_stat_desc),59UL,(unsigned long const *)(& siena_stat_mask),stats,(void const *)efx->stats_buffer.addr,(_Bool)0);
  
#line 524 
  ldv_inline_asm();
  
#line 525 
  generation_start = *dma_stats;
  
#line 526 
  if (generation_end != generation_start) {
    
#line 527 
    __retres = -11;
    
#line 527 
    goto return_label;
  }
  else ;
  
#line 530 
  efx_nic_fix_nodesc_drop_stat(efx,stats + 58U);
  
#line 532 
  efx_update_diff_stat(stats + 3U,*(stats + 2U) - *(stats + 4U));
  
#line 535 
  *(stats + 21U) = ((*(stats + 22U) + *(stats + 23U)) + *(stats + 24U)) + *(stats + 26U);
  
#line 540 
  efx_update_diff_stat(stats + 32U,*(stats + 31U) - *(stats + 33U));
  
#line 543 
  efx_update_sw_stats(efx,stats);
  
#line 544 
  __retres = 0;
  return_label: 
#line 544 
                return __retres;
}


#line 547  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static size_t siena_update_nic_stats(struct efx_nic *efx, u64 *full_stats, struct rtnl_link_stats64 *core_stats)
{
  size_t __retres;
  int retry;
  int tmp;
  
#line 550 
  struct siena_nic_data *nic_data = (struct siena_nic_data *)efx->nic_data;
  
#line 551 
  u64 *stats = (u64 *)(& nic_data->stats);
  
#line 556 
  retry = 0;
  
#line 556 
  goto ldv_56734;
  ldv_56733: 
#line 557 
  ;
  
#line 557 
  tmp = siena_try_update_nic_stats(efx);
  
#line 557 
  if (tmp == 0) 
#line 558 
                goto ldv_56732; else ;
  
#line 559 
  __const_udelay(429500UL);
  
#line 556 
  retry += 1;
  ldv_56734: 
#line 557 
  ;
  
#line 556 
  if (retry <= 99) 
#line 558 
                   goto ldv_56733; else 
#line 561 
                                        goto ldv_56732;
  ldv_56732: 
#line 562 
  ;
  
#line 562 
  if (full_stats != (u64 *)0ULL) 
#line 563 
                                 memcpy((void *)full_stats,(void const *)stats,472UL); else ;
  
#line 565 
  if (core_stats != (struct rtnl_link_stats64 *)0) {
    
#line 566 
    core_stats->rx_packets = *(stats + 34U);
    
#line 567 
    core_stats->tx_packets = *(stats + 5U);
    
#line 568 
    core_stats->rx_bytes = *(stats + 31U);
    
#line 569 
    core_stats->tx_bytes = *(stats + 2U);
    
#line 570 
    core_stats->rx_dropped = (*(stats + 58U) + *(stats + 1U)) + *stats;
    
#line 573 
    core_stats->multicast = *(stats + 40U);
    
#line 574 
    core_stats->collisions = *(stats + 21U);
    
#line 575 
    core_stats->rx_length_errors = *(stats + 50U) + *(stats + 56U);
    
#line 578 
    core_stats->rx_crc_errors = *(stats + 36U);
    
#line 579 
    core_stats->rx_frame_errors = *(stats + 55U);
    
#line 580 
    core_stats->rx_fifo_errors = *(stats + 52U);
    
#line 581 
    core_stats->tx_window_errors = *(stats + 26U);
    
#line 584 
    core_stats->rx_errors = ((core_stats->rx_length_errors + core_stats->rx_crc_errors) + core_stats->rx_frame_errors) + *(stats + 54U);
    
#line 588 
    core_stats->tx_errors = core_stats->tx_window_errors + *(stats + 6U);
  }
  else ;
  
#line 592 
  __retres = 59UL;
  
#line 592 
  return __retres;
}


#line 600 
void __compiletime_assert_602(void);


#line 595  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static int siena_mac_reconfigure(struct efx_nic *efx)
{
  int __retres;
  int rc;
  int tmp_0;
  
#line 597 
  efx_dword_t inbuf[8U] = {{.u32 = {0U}}};
  {
    
#line 600 
    bool __cond = (_Bool)0;
    
#line 600 
    if ((int)__cond != 0) 
#line 600 
                          __compiletime_assert_602(); else ;
  }
  
#line 604 
  efx_farch_filter_sync_rx_mode(efx);
  {
    int tmp;
    
#line 606 
    tmp = ldv_mutex_is_locked_97(& efx->mac_lock);
    
#line 606 
    int __ret_warn_on = tmp == 0;
    
#line 606 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 606 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c",606); else ;
    
#line 606 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 608 
  rc = efx_mcdi_set_mac(efx);
  
#line 609 
  if (rc != 0) {
    
#line 610 
    __retres = rc;
    
#line 610 
    goto return_label;
  }
  else ;
  
#line 612 
  memcpy((void *)(& inbuf),(void const *)(& efx->multicast_hash.byte),32UL);
  
#line 614 
  tmp_0 = efx_mcdi_rpc(efx,53U,(efx_dword_t const *)(& inbuf),32UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 614 
  __retres = tmp_0;
  return_label: 
#line 614 
                return __retres;
}


#line 625  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static void siena_get_wol(struct efx_nic *efx, struct ethtool_wolinfo *wol)
{
  
#line 627 
  struct siena_nic_data *nic_data = (struct siena_nic_data *)efx->nic_data;
  
#line 629 
  wol->supported = 32U;
  
#line 630 
  if (nic_data->wol_filter_id != -1) 
#line 631 
                                     wol->wolopts = 32U; else 
#line 633 
                                                              wol->wolopts = 0U;
  
#line 634 
  memset((void *)(& wol->sopass),0,6UL);
  
#line 635 
  return;
}


#line 638  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static int siena_set_wol(struct efx_nic *efx, u32 type)
{
  int __retres;
  int rc;
  
#line 640 
  struct siena_nic_data *nic_data = (struct siena_nic_data *)efx->nic_data;
  
#line 643 
  if ((type & 4294967263U) != 0U) {
    
#line 644 
    __retres = -22;
    
#line 644 
    goto return_label;
  }
  else ;
  
#line 646 
  if ((type & 32U) != 0U) {
    
#line 647 
    if (nic_data->wol_filter_id != -1) 
#line 648 
                                       efx_mcdi_wol_filter_remove(efx,nic_data->wol_filter_id); else ;
    
#line 650 
    rc = efx_mcdi_wol_filter_set_magic(efx,(u8 const *)(efx->net_dev)->dev_addr,& nic_data->wol_filter_id);
    
#line 652 
    if (rc != 0) 
#line 653 
                 goto fail; else ;
    
#line 655 
    pci_wake_from_d3(efx->pci_dev,(_Bool)1);
  }
  else {
    
#line 657 
    rc = efx_mcdi_wol_filter_reset(efx);
    
#line 658 
    nic_data->wol_filter_id = -1;
    
#line 659 
    pci_wake_from_d3(efx->pci_dev,(_Bool)0);
    
#line 660 
    if (rc != 0) 
#line 661 
                 goto fail; else ;
  }
  
#line 664 
  __retres = 0;
  
#line 664 
  goto return_label;
  fail: 
#line 665 
  ;
  
#line 666 
  if ((efx->msg_enable & 8192U) != 0U) 
#line 666 
                                       netdev_err((struct net_device const *)efx->net_dev,"%s failed: type=%d rc=%d\n","siena_set_wol",type,rc); else ;
  
#line 668 
  __retres = rc;
  return_label: 
#line 668 
                return __retres;
}


#line 672  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static void siena_init_wol(struct efx_nic *efx)
{
  int rc;
  
#line 674 
  struct siena_nic_data *nic_data = (struct siena_nic_data *)efx->nic_data;
  
#line 677 
  rc = efx_mcdi_wol_filter_get_magic(efx,& nic_data->wol_filter_id);
  
#line 679 
  if (rc != 0) {
    
#line 682 
    efx_mcdi_wol_filter_reset(efx);
    
#line 683 
    nic_data->wol_filter_id = -1;
  }
  else 
    
#line 684 
    if (nic_data->wol_filter_id != -1) 
#line 685 
                                       pci_wake_from_d3(efx->pci_dev,(_Bool)1); else ;
  
#line 686 
  return;
}


#line 703  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static void siena_mcdi_request(struct efx_nic *efx, efx_dword_t const *hdr, size_t hdr_len, efx_dword_t const *sdu, size_t sdu_len)
{
  int tmp_0;
  unsigned int tmp;
  int tmp_2;
  unsigned int tmp_1;
  unsigned int i;
  
#line 707 
  tmp = efx_port_num(efx);
  
#line 707 
  if (tmp != 0U) 
#line 707 
                 tmp_0 = 16711944; else 
#line 707 
                                        tmp_0 = 16711688;
  
#line 707 
  unsigned int pdu = (unsigned int)tmp_0;
  
#line 708 
  tmp_1 = efx_port_num(efx);
  
#line 708 
  if (tmp_1 != 0U) 
#line 708 
                   tmp_2 = 16711684; else 
#line 708 
                                          tmp_2 = 16711680;
  
#line 708 
  unsigned int doorbell = (unsigned int)tmp_2;
  
#line 710 
  unsigned int inlen_dw = (unsigned int)((sdu_len + 3UL) / 4UL);
  
#line 714 
  efx_writed(efx,hdr,pdu);
  
#line 716 
  i = 0U;
  
#line 716 
  goto ldv_56776;
  ldv_56775: 
#line 717 
  ;
  
#line 717 
  efx_writed(efx,sdu + i,((unsigned int)hdr_len + pdu) + i * 4U);
  
#line 716 
  i += 1U;
  ldv_56776: 
#line 717 
  ;
  
#line 716 
  if (i < inlen_dw) 
#line 718 
                    goto ldv_56775; else 
#line 721 
                                         goto ldv_56777;
  ldv_56777: 
#line 722 
  ;
  
#line 723 
  ldv_inline_asm();
  
#line 723 
  _efx_writed(efx,1165531836U,doorbell);
  
#line 724 
  return;
}


#line 726  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static bool siena_mcdi_poll_response(struct efx_nic *efx)
{
  bool __retres;
  int tmp_0;
  unsigned int tmp;
  efx_dword_t hdr;
  
#line 728 
  tmp = efx_port_num(efx);
  
#line 728 
  if (tmp != 0U) 
#line 728 
                 tmp_0 = 16711944; else 
#line 728 
                                        tmp_0 = 16711688;
  
#line 728 
  unsigned int pdu = (unsigned int)tmp_0;
  
#line 731 
  efx_readd(efx,& hdr,pdu);
  
#line 737 
  __retres = (_Bool)((hdr.u32[0] != 4294967295U && (hdr.u32[0] & 8388608U) != 0U) != 0);
  
#line 737 
  return __retres;
}


#line 741  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static void siena_mcdi_read_response(struct efx_nic *efx, efx_dword_t *outbuf, size_t offset, size_t outlen)
{
  int tmp_0;
  unsigned int tmp;
  int i;
  
#line 744 
  tmp = efx_port_num(efx);
  
#line 744 
  if (tmp != 0U) 
#line 744 
                 tmp_0 = 16711944; else 
#line 744 
                                        tmp_0 = 16711688;
  
#line 744 
  unsigned int pdu = (unsigned int)tmp_0;
  
#line 745 
  unsigned int outlen_dw = (unsigned int)((outlen + 3UL) / 4UL);
  
#line 748 
  i = 0;
  
#line 748 
  goto ldv_56793;
  ldv_56792: 
#line 749 
  ;
  
#line 749 
  efx_readd(efx,outbuf + i,((unsigned int)offset + pdu) + (unsigned int)(i * 4));
  
#line 748 
  i += 1;
  ldv_56793: 
#line 749 
  ;
  
#line 748 
  if ((unsigned int)i < outlen_dw) 
#line 750 
                                   goto ldv_56792; else 
#line 753 
                                                        goto ldv_56794;
  ldv_56794: 
#line 754 
  ;
  
#line 755 
  return;
}


#line 752  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static int siena_mcdi_poll_reboot(struct efx_nic *efx)
{
  int __retres;
  int tmp_0;
  unsigned int tmp;
  efx_dword_t reg;
  u32 value;
  
#line 754 
  struct siena_nic_data *nic_data = (struct siena_nic_data *)efx->nic_data;
  
#line 755 
  tmp = efx_port_num(efx);
  
#line 755 
  if (tmp != 0U) 
#line 755 
                 tmp_0 = 16713724; else 
#line 755 
                                        tmp_0 = 16713720;
  
#line 755 
  unsigned int addr = (unsigned int)tmp_0;
  
#line 759 
  efx_readd(efx,& reg,addr);
  
#line 760 
  value = reg.u32[0];
  
#line 762 
  if (value == 0U) {
    
#line 763 
    __retres = 0;
    
#line 763 
    goto return_label;
  }
  else ;
  
#line 765 
  reg.u32[0] = 0U;
  
#line 766 
  efx_writed(efx,(efx_dword_t const *)(& reg),addr);
  
#line 771 
  nic_data->stats[3] = 0ULL;
  
#line 772 
  nic_data->stats[32] = 0ULL;
  
#line 774 
  if (value == 3735936685U) {
    
#line 775 
    __retres = -4;
    
#line 775 
    goto return_label;
  }
  else {
    
#line 777 
    __retres = -5;
    
#line 777 
    goto return_label;
  }
  return_label: 
#line 774 
                return __retres;
}


#line 794  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static struct siena_nvram_type_info const siena_nvram_types[14U] = {{.port = 0, .name = "sfc_dummy_phy"}, {.port = 0, .name = "sfc_mcfw"}, {.port = 0, .name = "sfc_mcfw_backup"}, {.port = 0, .name = "sfc_static_cfg"}, {.port = 1, .name = "sfc_static_cfg"}, {.port = 0, .name = "sfc_dynamic_cfg"}, {.port = 1, .name = "sfc_dynamic_cfg"}, {.port = 0, .name = "sfc_exp_rom"}, {.port = 0, .name = "sfc_exp_rom_cfg"}, {.port = 1, .name = "sfc_exp_rom_cfg"}, {.port = 0, .name = "sfc_phy_fw"}, {.port = 1, .name = "sfc_phy_fw"}, [13] = {.port = 0, .name = "sfc_fpga"}};

#line 810  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static int siena_mtd_probe_partition(struct efx_nic *efx, struct efx_mcdi_mtd_partition *part, unsigned int type)
{
  int __retres;
  struct siena_nvram_type_info const *info;
  size_t size;
  size_t erase_size;
  bool protected;
  int rc;
  unsigned int tmp;
  
#line 819 
  if (type > 13U || siena_nvram_types[type].name == (char const *)0) {
    
#line 821 
    __retres = -19;
    
#line 821 
    goto return_label;
  }
  else ;
  
#line 823 
  info = & siena_nvram_types[type];
  
#line 825 
  tmp = efx_port_num(efx);
  
#line 825 
  ;
  
#line 825 
  if ((unsigned int)info->port != tmp) {
    
#line 826 
    __retres = -19;
    
#line 826 
    goto return_label;
  }
  else ;
  
#line 828 
  rc = efx_mcdi_nvram_info(efx,type,& size,& erase_size,& protected);
  
#line 829 
  if (rc != 0) {
    
#line 830 
    __retres = rc;
    
#line 830 
    goto return_label;
  }
  else ;
  
#line 831 
  if ((int)protected != 0) {
    
#line 832 
    __retres = -19;
    
#line 832 
    goto return_label;
  }
  else ;
  
#line 834 
  part->nvram_type = (unsigned short)type;
  
#line 835 
  part->common.dev_type_name = "Siena NVRAM manager";
  
#line 836 
  part->common.type_name = info->name;
  
#line 838 
  part->common.mtd.type = (unsigned char)3U;
  
#line 839 
  part->common.mtd.flags = 3072U;
  
#line 840 
  part->common.mtd.size = (unsigned long long)size;
  
#line 841 
  part->common.mtd.erasesize = (unsigned int)erase_size;
  
#line 843 
  __retres = 0;
  return_label: 
#line 843 
                return __retres;
}


#line 846  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static int siena_mtd_get_fw_subtypes(struct efx_nic *efx, struct efx_mcdi_mtd_partition *parts, size_t n_parts)
{
  int __retres;
  uint16_t fw_subtype_list[32U];
  size_t i;
  int rc;
  
#line 855 
  rc = efx_mcdi_get_board_cfg(efx,(u8 *)0U,(u16 *)(& fw_subtype_list),(u32 *)0U);
  
#line 856 
  if (rc != 0) {
    
#line 857 
    __retres = rc;
    
#line 857 
    goto return_label;
  }
  else ;
  
#line 859 
  i = 0UL;
  
#line 859 
  goto ldv_56828;
  ldv_56827: 
#line 860 
  ;
  
#line 860 
  (parts + i)->fw_subtype = fw_subtype_list[(int)(parts + i)->nvram_type];
  
#line 859 
  i += 1UL;
  ldv_56828: 
#line 860 
  ;
  
#line 859 
  if (i < n_parts) 
#line 861 
                   goto ldv_56827; else 
#line 864 
                                        goto ldv_56829;
  ldv_56829: 
#line 865 
  ;
  
#line 862 
  __retres = 0;
  return_label: 
#line 862 
                return __retres;
}


#line 865  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
static int siena_mtd_probe(struct efx_nic *efx)
{
  int __retres;
  struct efx_mcdi_mtd_partition *parts;
  u32 nvram_types;
  unsigned int type;
  size_t n_parts;
  int rc;
  int tmp;
  void *tmp_2;
  unsigned int tmp_1;
  
#line 873 
  tmp = rtnl_is_locked();
  
#line 873 
  if ((long)(tmp == 0) != 0L) {
    
#line 873 
    printk("\001",(char *)"/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c",873);
    
#line 873 
    dump_stack();
  }
  else ;
  
#line 875 
  rc = efx_mcdi_nvram_types(efx,& nvram_types);
  
#line 876 
  if (rc != 0) {
    
#line 877 
    __retres = rc;
    
#line 877 
    goto return_label;
  }
  else ;
  
#line 879 
  if (0 != 0) 
#line 879 
              tmp_1 = ((unsigned int)((((((((((unsigned long long)nvram_types & 1ULL) != 0ULL) + (((unsigned long long)nvram_types & 2ULL) != 0ULL)) + (((unsigned long long)nvram_types & 4ULL) != 0ULL)) + (((unsigned long long)nvram_types & 8ULL) != 0ULL)) + (((unsigned long long)nvram_types & 16ULL) != 0ULL)) + (((unsigned long long)nvram_types & 32ULL) != 0ULL)) + (((unsigned long long)nvram_types & 64ULL) != 0ULL)) + (((unsigned long long)nvram_types & 128ULL) != 0ULL)) + (unsigned int)((((((((((unsigned long long)(nvram_types >> 8) & 1ULL) != 0ULL) + (((unsigned long long)(nvram_types >> 8) & 2ULL) != 0ULL)) + (((unsigned long long)(nvram_types >> 8) & 4ULL) != 0ULL)) + (((unsigned long long)(nvram_types >> 8) & 8ULL) != 0ULL)) + (((unsigned long long)(nvram_types >> 8) & 16ULL) != 0ULL)) + (((unsigned long long)(nvram_types >> 8) & 32ULL) != 0ULL)) + (((unsigned long long)(nvram_types >> 8) & 64ULL) != 0ULL)) + (((unsigned long long)(nvram_types >> 8) & 128ULL) != 0ULL))) + ((unsigned int)((((((((((unsigned long long)(nvram_types >> 16) & 1ULL) != 0ULL) + (((unsigned long long)(nvram_types >> 16) & 2ULL) != 0ULL)) + (((unsigned long long)(nvram_types >> 16) & 4ULL) != 0ULL)) + (((unsigned long long)(nvram_types >> 16) & 8ULL) != 0ULL)) + (((unsigned long long)(nvram_types >> 16) & 16ULL) != 0ULL)) + (((unsigned long long)(nvram_types >> 16) & 32ULL) != 0ULL)) + (((unsigned long long)(nvram_types >> 16) & 64ULL) != 0ULL)) + (((unsigned long long)(nvram_types >> 16) & 128ULL) != 0ULL)) + (unsigned int)((((((((((unsigned long long)(nvram_types >> 24) & 1ULL) != 0ULL) + (((unsigned long long)(nvram_types >> 24) & 2ULL) != 0ULL)) + (((unsigned long long)(nvram_types >> 24) & 4ULL) != 0ULL)) + (((unsigned long long)(nvram_types >> 24) & 8ULL) != 0ULL)) + (((unsigned long long)(nvram_types >> 24) & 16ULL) != 0ULL)) + (((unsigned long long)(nvram_types >> 24) & 32ULL) != 0ULL)) + (((unsigned long long)(nvram_types >> 24) & 64ULL) != 0ULL)) + (((unsigned long long)(nvram_types >> 24) & 128ULL) != 0ULL))); else 
                                                                    
#line 879 
                                                                    tmp_1 = __arch_hweight32(nvram_types);
  
#line 879 
  tmp_2 = kcalloc_2((unsigned long)tmp_1,1904UL,208U);
  
#line 879 
  parts = (struct efx_mcdi_mtd_partition *)tmp_2;
  
#line 880 
  if (parts == (struct efx_mcdi_mtd_partition *)0) {
    
#line 881 
    __retres = -12;
    
#line 881 
    goto return_label;
  }
  else ;
  
#line 883 
  type = 0U;
  
#line 884 
  n_parts = 0UL;
  
#line 886 
  goto ldv_56840;
  ldv_56839: 
#line 887 
  ;
  
#line 887 
  if ((nvram_types & 1U) != 0U) {
    
#line 888 
    rc = siena_mtd_probe_partition(efx,parts + n_parts,type);
    
#line 890 
    if (rc == 0) 
#line 891 
                 n_parts += 1UL;
    else 
      
#line 892 
      if (rc != -19) 
#line 893 
                     goto fail; else ;
  }
  else ;
  
#line 895 
  type += 1U;
  
#line 896 
  nvram_types >>= 1;
  ldv_56840: 
#line 897 
  ;
  
#line 886 
  if (nvram_types != 0U) 
#line 888 
                         goto ldv_56839; else 
#line 891 
                                              goto ldv_56841;
  ldv_56841: 
#line 892 
  ;
  
#line 899 
  rc = siena_mtd_get_fw_subtypes(efx,parts,n_parts);
  
#line 900 
  if (rc != 0) 
#line 901 
               goto fail; else ;
  
#line 903 
  rc = efx_mtd_add(efx,& parts->common,n_parts,1904UL);
  fail: 
#line 904 
  ;
  
#line 905 
  if (rc != 0) 
#line 906 
               kfree((void const *)parts); else ;
  
#line 907 
  __retres = rc;
  return_label: 
#line 907 
                return __retres;
}


#line 919  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena.c"
struct efx_nic_type const siena_a0_nic_type = {.is_vf = (_Bool)0, .mem_bar = 2U, .mem_map_size = & siena_mem_map_size, .probe = & siena_probe_nic, .remove = & siena_remove_nic, .init = & siena_init_nic, .dimension_resources = & siena_dimension_resources, .fini = & efx_port_dummy_op_void, .monitor = (void (*)(struct efx_nic *))0, .map_reset_reason = & efx_mcdi_map_reset_reason, .map_reset_flags = & siena_map_reset_flags, .reset = & efx_mcdi_reset, .probe_port = & efx_mcdi_port_probe, .remove_port = & efx_mcdi_port_remove, .handle_global_event = (bool (*)(struct efx_channel *, efx_qword_t *))0, .fini_dmaq = & efx_farch_fini_dmaq, .prepare_flush = & siena_prepare_flush, .finish_flush = & siena_finish_flush, .prepare_flr = & efx_port_dummy_op_void, .finish_flr = & efx_farch_finish_flr, .describe_stats = & siena_describe_nic_stats, .update_stats = & siena_update_nic_stats, .start_stats = & efx_mcdi_mac_start_stats, .pull_stats = & efx_mcdi_mac_pull_stats, .stop_stats = & efx_mcdi_mac_stop_stats, .set_id_led = & efx_mcdi_set_id_led, .push_irq_moderation = & siena_push_irq_moderation, .reconfigure_port = & efx_mcdi_port_reconfigure, .prepare_enable_fc_tx = (void (*)(struct efx_nic *))0, .reconfigure_mac = & siena_mac_reconfigure, .check_mac_fault = & efx_mcdi_mac_check_fault, .get_wol = & siena_get_wol, .set_wol = & siena_set_wol, .resume_wol = & siena_init_wol, .test_chip = & siena_test_chip, .test_nvram = & efx_mcdi_nvram_test_all, .mcdi_request = & siena_mcdi_request, .mcdi_poll_response = & siena_mcdi_poll_response, .mcdi_read_response = & siena_mcdi_read_response, .mcdi_poll_reboot = & siena_mcdi_poll_reboot, .irq_enable_master = & efx_farch_irq_enable_master, .irq_test_generate = & efx_farch_irq_test_generate, .irq_disable_non_ev = & efx_farch_irq_disable_master, .irq_handle_msi = & efx_farch_msi_interrupt, .irq_handle_legacy = & efx_farch_legacy_interrupt, .tx_probe = & efx_farch_tx_probe, .tx_init = & efx_farch_tx_init, .tx_remove = & efx_farch_tx_remove, .tx_write = & efx_farch_tx_write, .rx_push_rss_config = & siena_rx_push_rss_config, .rx_probe = & efx_farch_rx_probe, .rx_init = & efx_farch_rx_init, .rx_remove = & efx_farch_rx_remove, .rx_write = & efx_farch_rx_write, .rx_defer_refill = & efx_farch_rx_defer_refill, .ev_probe = & efx_farch_ev_probe, .ev_init = & efx_farch_ev_init, .ev_fini = & efx_farch_ev_fini, .ev_remove = & efx_farch_ev_remove, .ev_process = & efx_farch_ev_process, .ev_read_ack = & efx_farch_ev_read_ack, .ev_test_generate = & efx_farch_ev_test_generate, .filter_table_probe = & efx_farch_filter_table_probe, .filter_table_restore = & efx_farch_filter_table_restore, .filter_table_remove = & efx_farch_filter_table_remove, .filter_update_rx_scatter = & efx_farch_filter_update_rx_scatter, .filter_insert = & efx_farch_filter_insert, .filter_remove_safe = & efx_farch_filter_remove_safe, .filter_get_safe = & efx_farch_filter_get_safe, .filter_clear_rx = & efx_farch_filter_clear_rx, .filter_count_rx_used = & efx_farch_filter_count_rx_used, .filter_get_rx_id_limit = & efx_farch_filter_get_rx_id_limit, .filter_get_rx_ids = & efx_farch_filter_get_rx_ids, .filter_rfs_insert = & efx_farch_filter_rfs_insert, .filter_rfs_expire_one = & efx_farch_filter_rfs_expire_one, .mtd_probe = & siena_mtd_probe, .mtd_rename = & efx_mcdi_mtd_rename, .mtd_read = & efx_mcdi_mtd_read, .mtd_erase = & efx_mcdi_mtd_erase, .mtd_write = & efx_mcdi_mtd_write, .mtd_sync = & efx_mcdi_mtd_sync, .ptp_write_host_time = & siena_ptp_write_host_time, .ptp_set_ts_sync_events = (int (*)(struct efx_nic *, bool , bool ))0, .ptp_set_ts_config = & siena_ptp_set_ts_config, .sriov_configure = & efx_siena_sriov_configure, .sriov_init = & efx_siena_sriov_init, .sriov_fini = & efx_siena_sriov_fini, .sriov_wanted = & efx_siena_sriov_wanted, .sriov_reset = & efx_siena_sriov_reset, .sriov_flr = & efx_siena_sriov_flr, .sriov_set_vf_mac = & efx_siena_sriov_set_vf_mac, .sriov_set_vf_vlan = & efx_siena_sriov_set_vf_vlan, .sriov_set_vf_spoofchk = & efx_siena_sriov_set_vf_spoofchk, .sriov_get_vf_config = & efx_siena_sriov_get_vf_config, .sriov_set_vf_link_state = (int (*)(struct efx_nic *, int , int ))0, .sriov_get_phys_port_id = (int (*)(struct efx_nic *, struct netdev_phys_item_id *))0, .vswitching_probe = & efx_port_dummy_op_int, .vswitching_restore = & efx_port_dummy_op_int, .vswitching_remove = & efx_port_dummy_op_void, .get_mac_address = (int (*)(struct efx_nic *, unsigned char *))0, .set_mac_address = & efx_siena_sriov_mac_address_changed, .revision = 3, .txd_ptr_tbl_base = 16056320U, .rxd_ptr_tbl_base = 15990784U, .buf_tbl_base = 8388608U, .evq_ptr_tbl_base = 16121856U, .evq_rptr_tbl_base = 16384000U, .max_dma_mask = 70368744177663ULL, .rx_prefix_size = 16U, .rx_hash_offset = 12U, .rx_ts_offset = 0U, .rx_buffer_padding = 0U, .can_rx_scatter = (_Bool)1, .always_rx_scatter = (_Bool)0, .max_interrupt_mode = 0U, .timer_period_max = 16384U, .offload_features = 12884901906ULL, .mcdi_max_ver = 1, .max_rx_ip_filters = 8192U, .hwtstamp_filters = 505U};

#line 505  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena.c.aux"
static void *kcalloc_2(size_t n, size_t size, gfp_t flags)
{
  void *tmp;
  
#line 508 
  tmp = ldv_kcalloc(n,size,flags);
  
#line 508 
  return tmp;
}


#line 512  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena.c.aux"
static void *kzalloc_2(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 515 
  tmp = ldv_kzalloc(size,flags);
  
#line 515 
  return tmp;
}


#line 888  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena.c.aux"
static void ldv___ldv_spin_lock_87_0(spinlock_t *ldv_func_arg1)
{
  
#line 892 
  ldv_spin_model_lock((char *)"biu_lock_of_efx_nic");
  
#line 894 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 895 
  return;
}


#line 898  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena.c.aux"
static void ldv_spin_unlock_irqrestore_88_0(spinlock_t *lock, unsigned long flags)
{
  
#line 902 
  ldv_spin_model_unlock((char *)"biu_lock_of_efx_nic");
  
#line 904 
  spin_unlock_irqrestore_1(lock,flags);
  
#line 905 
  return;
}


#line 928  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena.c.aux"
static void ldv___ldv_spin_lock_91_1(spinlock_t *ldv_func_arg1)
{
  
#line 932 
  ldv_spin_model_lock((char *)"biu_lock_of_efx_nic");
  
#line 934 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 935 
  return;
}


#line 938  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena.c.aux"
static void ldv_spin_unlock_irqrestore_92_1(spinlock_t *lock, unsigned long flags)
{
  
#line 942 
  ldv_spin_model_unlock((char *)"biu_lock_of_efx_nic");
  
#line 944 
  spin_unlock_irqrestore_1(lock,flags);
  
#line 945 
  return;
}


#line 968  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena.c.aux"
static void ldv___ldv_spin_lock_95(spinlock_t *ldv_func_arg1)
{
  
#line 972 
  ldv_spin_model_lock((char *)"biu_lock_of_efx_nic");
  
#line 974 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 975 
  return;
}


#line 978  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena.c.aux"
static void ldv_spin_unlock_irqrestore_96(spinlock_t *lock, unsigned long flags)
{
  
#line 982 
  ldv_spin_model_unlock((char *)"biu_lock_of_efx_nic");
  
#line 984 
  spin_unlock_irqrestore_1(lock,flags);
  
#line 985 
  return;
}


#line 988  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena.c.aux"
static int ldv_mutex_is_locked_97(struct mutex *lock)
{
  int tmp;
  
#line 991 
  tmp = ldv_mutex_model_is_locked(lock,(char *)"mac_lock_of_efx_nic");
  
#line 991 
  return tmp;
}


#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/export.h"
extern struct module __this_module;


#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
void __list_add(struct list_head *, struct list_head *, struct list_head *);


#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void list_add_tail(struct list_head *new, struct list_head *head)
{
  
#line 77 
  __list_add(new,head->prev,head);
  
#line 78 
  return;
}


#line 113 
void list_del(struct list_head *);


#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static int list_empty(struct list_head const *head)
{
  int __retres;
  
#line 189 
  __retres = (struct list_head const *)head->next == head;
  
#line 189 
  return __retres;
}


#line 372  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mtd/mtd.h"
int mtd_device_parse_register(struct mtd_info *, char const * const *, struct mtd_part_parser_data *, struct mtd_partition const *, int);


#line 379 
int mtd_device_unregister(struct mtd_info *);


#line 398 
void mtd_erase_callback(struct erase_info *);


#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/delay.h"
__inline static void ssleep(unsigned int seconds)
{
  
#line 52 
  msleep(seconds * 1000U);
  
#line 53 
  return;
}


#line 223  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
void efx_mtd_rename(struct efx_nic *efx);


#line 224 
void efx_mtd_remove(struct efx_nic *efx);


#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mtd.c"
static int efx_mtd_erase(struct mtd_info *mtd, struct erase_info *erase)
{
  int rc;
  
#line 26 
  struct efx_nic *efx = (struct efx_nic *)mtd->priv;
  
#line 29 
  rc = (*((efx->type)->mtd_erase))(mtd,(long long)erase->addr,(unsigned long)erase->len);
  
#line 30 
  if (rc == 0) 
#line 31 
               erase->state = (unsigned char)8U;
  else {
    
#line 33 
    erase->state = (unsigned char)16U;
    
#line 34 
    erase->fail_addr = 18446744073709551615ULL;
  }
  
#line 36 
  mtd_erase_callback(erase);
  
#line 37 
  return rc;
}


#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mtd.c"
static void efx_mtd_sync(struct mtd_info *mtd)
{
  struct efx_mtd_partition *tmp;
  int rc;
  {
    
#line 42 
    struct mtd_info const *__mptr = (struct mtd_info const *)mtd;
    
#line 42 
    tmp = (struct efx_mtd_partition *)__mptr + 18446744073709551600U;
  }
  
#line 42 
  struct efx_mtd_partition *part = tmp;
  
#line 43 
  struct efx_nic *efx = (struct efx_nic *)mtd->priv;
  
#line 46 
  rc = (*((efx->type)->mtd_sync))(mtd);
  
#line 47 
  if (rc != 0) 
#line 48 
               printk("\001",(char *)(& part->name),part->dev_type_name,rc); else ;
  
#line 49 
  return;
}


#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mtd.c"
static void efx_mtd_remove_partition(struct efx_mtd_partition *part)
{
  int rc;
  ldv_55499: 
#line 55 
  ;
  
#line 57 
  rc = mtd_device_unregister(& part->mtd);
  
#line 58 
  if (rc != -16) 
#line 59 
                 goto ldv_55498; else ;
  
#line 60 
  ssleep(1U);
  
#line 57 
  goto ldv_55499;
  ldv_55498: 
#line 58 
  ;
  {
    
#line 62 
    int __ret_warn_on = rc != 0;
    
#line 62 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 62 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mtd.c",62); else ;
    
#line 62 
    long tmp = (long)(__ret_warn_on != 0);
  }
  
#line 63 
  list_del(& part->node);
  
#line 64 
  return;
}


#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mtd.c"
int efx_mtd_add(struct efx_nic *efx, struct efx_mtd_partition *parts, size_t n_parts, size_t sizeof_part)
{
  int __retres;
  struct efx_mtd_partition *part;
  size_t i;
  int tmp;
  size_t tmp_0;
  
#line 72 
  i = 0UL;
  
#line 72 
  goto ldv_55512;
  ldv_55511: 
#line 73 
  ;
  
#line 73 
  part = parts + i * sizeof_part;
  
#line 76 
  part->mtd.writesize = 1U;
  
#line 78 
  part->mtd.owner = & __this_module;
  
#line 79 
  part->mtd.priv = (void *)efx;
  
#line 80 
  part->mtd.name = (char const *)(& part->name);
  
#line 81 
  part->mtd._erase = & efx_mtd_erase;
  
#line 82 
  part->mtd._read = (efx->type)->mtd_read;
  
#line 83 
  part->mtd._write = (efx->type)->mtd_write;
  
#line 84 
  part->mtd._sync = & efx_mtd_sync;
  
#line 86 
  (*((efx->type)->mtd_rename))(part);
  
#line 88 
  tmp = mtd_device_parse_register(& part->mtd,(char const * const *)0,(struct mtd_part_parser_data *)0,(struct mtd_partition const *)0,0);
  
#line 88 
  if (tmp != 0) 
#line 89 
                goto fail; else ;
  
#line 92 
  list_add_tail(& part->node,& efx->mtd_list);
  
#line 72 
  i += 1UL;
  ldv_55512: 
#line 73 
  ;
  
#line 72 
  if (i < n_parts) 
#line 74 
                   goto ldv_55511; else 
#line 77 
                                        goto ldv_55513;
  ldv_55513: 
#line 78 
  ;
  
#line 95 
  __retres = 0;
  
#line 95 
  goto return_label;
  fail: 
#line 97 
  ;
  
#line 98 
  goto ldv_55515;
  ldv_55514: 
#line 99 
  ;
  
#line 99 
  part = parts + i * sizeof_part;
  
#line 101 
  efx_mtd_remove_partition(part);
  ldv_55515: 
#line 102 
  ;
  
#line 98 
  tmp_0 = i;
  
#line 98 
  i -= 1UL;
  
#line 98 
  ;
  
#line 98 
  if (tmp_0 != 0UL) 
#line 100 
                    goto ldv_55514; else 
#line 103 
                                         goto ldv_55516;
  ldv_55516: 
#line 104 
  ;
  
#line 104 
  __retres = -12;
  return_label: 
#line 104 
                return __retres;
}


#line 107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mtd.c"
void efx_mtd_remove(struct efx_nic *efx)
{
  struct efx_mtd_partition *parts;
  struct efx_mtd_partition *part;
  struct efx_mtd_partition *next;
  int tmp_0;
  struct efx_mtd_partition *tmp_1;
  struct efx_mtd_partition *tmp_2_0;
  struct efx_mtd_partition *tmp_3;
  struct efx_mtd_partition *tmp_4;
  {
    int tmp;
    
#line 111 
    tmp = efx_dev_registered(efx);
    
#line 111 
    int __ret_warn_on = tmp != 0;
    
#line 111 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 111 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mtd.c",111); else ;
    
#line 111 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 113 
  tmp_0 = list_empty((struct list_head const *)(& efx->mtd_list));
  
#line 113 
  if (tmp_0 != 0) 
#line 114 
                  goto return_label; else ;
  {
    
#line 116 
    struct list_head const *__mptr = (struct list_head const *)efx->mtd_list.next;
    
#line 116 
    tmp_1 = (struct efx_mtd_partition *)__mptr;
  }
  
#line 116 
  parts = tmp_1;
  {
    
#line 119 
    struct list_head const *__mptr_0 = (struct list_head const *)efx->mtd_list.next;
    
#line 119 
    tmp_2_0 = (struct efx_mtd_partition *)__mptr_0;
  }
  
#line 119 
  part = tmp_2_0;
  {
    
#line 119 
    struct list_head const *__mptr_1 = (struct list_head const *)part->node.next;
    
#line 119 
    tmp_3 = (struct efx_mtd_partition *)__mptr_1;
  }
  
#line 120 
  next = tmp_3;
  
#line 119 
  goto ldv_55534;
  ldv_55533: 
#line 120 
  ;
  
#line 120 
  efx_mtd_remove_partition(part);
  
#line 119 
  part = next;
  {
    
#line 119 
    struct list_head const *__mptr_2 = (struct list_head const *)next->node.next;
    
#line 119 
    tmp_4 = (struct efx_mtd_partition *)__mptr_2;
  }
  
#line 119 
  next = tmp_4;
  ldv_55534: 
#line 121 
  ;
  
#line 119 
  if (& part->node != & efx->mtd_list) 
#line 121 
                                       goto ldv_55533; else 
#line 124 
                                                            goto ldv_55535;
  ldv_55535: 
#line 125 
  ;
  
#line 122 
  kfree((void const *)parts);
  return_label: 
#line 123 
                return;
}


#line 125  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mtd.c"
void efx_mtd_rename(struct efx_nic *efx)
{
  struct efx_mtd_partition *part;
  int tmp;
  struct efx_mtd_partition *tmp_0;
  struct efx_mtd_partition *tmp_1;
  
#line 129 
  tmp = rtnl_is_locked();
  
#line 129 
  if ((long)(tmp == 0) != 0L) {
    
#line 129 
    printk("\001",(char *)"/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mtd.c",129);
    
#line 129 
    dump_stack();
  }
  else ;
  {
    
#line 131 
    struct list_head const *__mptr = (struct list_head const *)efx->mtd_list.next;
    
#line 131 
    tmp_0 = (struct efx_mtd_partition *)__mptr;
  }
  
#line 131 
  part = tmp_0;
  
#line 131 
  goto ldv_55545;
  ldv_55544: 
#line 132 
  ;
  
#line 132 
  (*((efx->type)->mtd_rename))(part);
  {
    
#line 131 
    struct list_head const *__mptr_0 = (struct list_head const *)part->node.next;
    
#line 131 
    tmp_1 = (struct efx_mtd_partition *)__mptr_0;
  }
  
#line 131 
  part = tmp_1;
  ldv_55545: 
#line 133 
  ;
  
#line 131 
  if (& part->node != & efx->mtd_list) 
#line 133 
                                       goto ldv_55544; else 
#line 136 
                                                            goto ldv_55546;
  ldv_55546: 
#line 137 
  ;
  
#line 138 
  return;
}


#line 402  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
int sprintf(char *, char const * , ...);


#line 595  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
static int ldv_device_create_file_88(struct device *ldv_func_arg1, struct device_attribute const *ldv_func_arg2);


#line 601 
static void ldv_device_remove_file_87(struct device *ldv_func_arg1, struct device_attribute const *ldv_func_arg2);


#line 864  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static void *dev_get_drvdata(struct device const *dev)
{
  void *__retres;
  
#line 866 
  __retres = dev->driver_data;
  
#line 866 
  return __retres;
}


#line 2769  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool netif_running(struct net_device const *dev)
{
  bool __retres;
  int tmp;
  
#line 2771 
  tmp = constant_test_bit(0L,(unsigned long const volatile *)(& dev->state));
  
#line 2771 
  __retres = (_Bool)(tmp != 0);
  
#line 2771 
  return __retres;
}


#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rtnetlink.h"
void rtnl_lock(void);


#line 28 
void rtnl_unlock(void);


#line 1471  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev)
{
  void *tmp;
  
#line 1473 
  tmp = dev_get_drvdata((struct device const *)(& pdev->dev));
  
#line 1473 
  return tmp;
}


#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/i2c.h"
s32 i2c_smbus_read_byte_data(struct i2c_client const *, u8);


#line 91 
s32 i2c_smbus_write_byte_data(struct i2c_client const *, u8, u8);


#line 326 
struct i2c_client *i2c_new_device(struct i2c_adapter *, struct i2c_board_info const *);


#line 347 
struct i2c_client *i2c_new_dummy(struct i2c_adapter *, u16);


#line 349 
void i2c_unregister_device(struct i2c_client *);


#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/phy.h"
void tenxpress_set_id_led(struct efx_nic *efx, enum efx_led_mode mode);


#line 37 
void falcon_qt202x_set_led(struct efx_nic *p, int led, int mode);


#line 186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
int efx_reconfigure_port(struct efx_nic *efx);


#line 596  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
int falcon_probe_board(struct efx_nic *efx, u16 revision_info);


#line 763 
void falcon_start_nic_stats(struct efx_nic *efx);


#line 764 
void falcon_stop_nic_stats(struct efx_nic *efx);


#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static int efx_poke_lm87(struct i2c_client *client, u8 const *reg_values)
{
  int __retres;
  
#line 71 
  goto ldv_55503;
  ldv_55502: 
#line 72 
  ;
  {
    u8 const *tmp;
    u8 const *tmp_0;
    
#line 72 
    tmp = reg_values;
    
#line 72 
    reg_values += 1;
    
#line 72 
    u8 reg = *tmp;
    
#line 73 
    tmp_0 = reg_values;
    
#line 73 
    reg_values += 1;
    
#line 73 
    u8 value = *tmp_0;
    
#line 74 
    int rc = i2c_smbus_write_byte_data((struct i2c_client const *)client,(unsigned char)((int)reg),(unsigned char)((int)value));
    
#line 75 
    if (rc != 0) {
      
#line 76 
      __retres = rc;
      
#line 76 
      goto return_label;
    }
    else ;
  }
  ldv_55503: 
#line 78 
  ;
  
#line 71 
  if ((unsigned int)*reg_values != 0U) 
#line 73 
                                       goto ldv_55502; else 
#line 76 
                                                            goto ldv_55504;
  ldv_55504: 
#line 77 
  ;
  
#line 78 
  __retres = 0;
  return_label: 
#line 78 
                return __retres;
}


#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static u8 const falcon_lm87_common_regs[13U] = {(unsigned char)19U, (unsigned char)95U, (unsigned char)23U, (unsigned char)95U, (unsigned char)55U, (unsigned char)90U, (unsigned char)56U, (unsigned char)0U, (unsigned char)20U, (unsigned char)125U, (unsigned char)24U, (unsigned char)125U, (unsigned char)0U};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static int efx_init_lm87(struct efx_nic *efx, struct i2c_board_info const *info, u8 const *reg_values)
{
  int __retres;
  int rc;
  
#line 93 
  struct falcon_board *board = falcon_board(efx);
  
#line 94 
  struct i2c_client *client = i2c_new_device(& board->i2c_adap,info);
  
#line 97 
  if (client == (struct i2c_client *)0) {
    
#line 98 
    __retres = -5;
    
#line 98 
    goto return_label;
  }
  else ;
  
#line 101 
  i2c_smbus_read_byte_data((struct i2c_client const *)client,(unsigned char)65);
  
#line 102 
  i2c_smbus_read_byte_data((struct i2c_client const *)client,(unsigned char)66);
  
#line 104 
  rc = efx_poke_lm87(client,reg_values);
  
#line 105 
  if (rc != 0) 
#line 106 
               goto err; else ;
  
#line 107 
  rc = efx_poke_lm87(client,(u8 const *)(& falcon_lm87_common_regs));
  
#line 108 
  if (rc != 0) 
#line 109 
               goto err; else ;
  
#line 111 
  board->hwmon_client = client;
  
#line 112 
  __retres = 0;
  
#line 112 
  goto return_label;
  err: 
#line 114 
  ;
  
#line 115 
  i2c_unregister_device(client);
  
#line 116 
  __retres = rc;
  return_label: 
#line 116 
                return __retres;
}


#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static void efx_fini_lm87(struct efx_nic *efx)
{
  struct falcon_board *tmp;
  
#line 121 
  tmp = falcon_board(efx);
  
#line 121 
  i2c_unregister_device(tmp->hwmon_client);
  
#line 122 
  return;
}


#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static int efx_check_lm87(struct efx_nic *efx, unsigned int mask)
{
  int __retres;
  struct falcon_board *tmp;
  bool temp_crit;
  bool elec_fault;
  bool is_failure;
  u16 alarms;
  s32 reg;
  int tmp_5;
  
#line 126 
  tmp = falcon_board(efx);
  
#line 126 
  struct i2c_client *client = tmp->hwmon_client;
  
#line 132 
  if ((int)efx->link_state.up != 0) {
    
#line 133 
    __retres = 0;
    
#line 133 
    goto return_label;
  }
  else ;
  
#line 135 
  reg = i2c_smbus_read_byte_data((struct i2c_client const *)client,(unsigned char)65);
  
#line 136 
  if (reg < 0) {
    
#line 137 
    __retres = reg;
    
#line 137 
    goto return_label;
  }
  else ;
  
#line 138 
  alarms = (unsigned short)reg;
  
#line 139 
  reg = i2c_smbus_read_byte_data((struct i2c_client const *)client,(unsigned char)66);
  
#line 140 
  if (reg < 0) {
    
#line 141 
    __retres = reg;
    
#line 141 
    goto return_label;
  }
  else ;
  
#line 142 
  alarms = (unsigned short)((reg << 8) | (int)alarms);
  
#line 143 
  alarms = (unsigned short)((int)((unsigned short)mask) & (int)alarms);
  
#line 145 
  temp_crit = (_Bool)0;
  
#line 146 
  if (((int)alarms & 16) != 0) {
    
#line 147 
    reg = i2c_smbus_read_byte_data((struct i2c_client const *)client,(unsigned char)39);
    
#line 148 
    if (reg < 0) {
      
#line 149 
      __retres = reg;
      
#line 149 
      goto return_label;
    }
    else ;
    
#line 150 
    if (reg > 95) 
#line 151 
                  temp_crit = (_Bool)1; else ;
  }
  else ;
  
#line 153 
  if (((int)alarms & 32) != 0) {
    
#line 154 
    reg = i2c_smbus_read_byte_data((struct i2c_client const *)client,(unsigned char)38);
    
#line 155 
    if (reg < 0) {
      
#line 156 
      __retres = reg;
      
#line 156 
      goto return_label;
    }
    else ;
    
#line 157 
    if (reg > 125) 
#line 158 
                   temp_crit = (_Bool)1; else ;
  }
  else ;
  
#line 160 
  elec_fault = (_Bool)(((int)alarms & -49) != 0);
  
#line 161 
  is_failure = (_Bool)(((int)temp_crit != 0 || (int)elec_fault != 0) != 0);
  
#line 163 
  if ((unsigned int)alarms != 0U) {
    
#line 164 
    if ((efx->msg_enable & 8192U) != 0U) {
      char *tmp_0;
      char *tmp_1;
      char *tmp_2;
      char *tmp_3;
      char *tmp_4;
      
#line 164 
      if ((int)elec_fault != 0) 
#line 164 
                                tmp_0 = (char *)"; electrical fault"; else 
                                                                    
#line 164 
                                                                    tmp_0 = (char *)"";
      
#line 164 
      if ((int)temp_crit != 0) 
#line 164 
                               tmp_1 = (char *)"; reached critical temperature"; else 
                                                                    
#line 164 
                                                                    tmp_1 = (char *)"";
      
#line 164 
      if (((int)alarms & 32) != 0) 
#line 164 
                                   tmp_2 = (char *)"; controller is overheating"; else 
                                                                    
#line 164 
                                                                    tmp_2 = (char *)"";
      
#line 164 
      if (((int)alarms & 16) != 0) 
#line 164 
                                   tmp_3 = (char *)"; board is overheating"; else 
                                                                    
#line 164 
                                                                    tmp_3 = (char *)"";
      
#line 164 
      ;
      
#line 164 
      ;
      
#line 164 
      if ((int)is_failure != 0) 
#line 164 
                                tmp_4 = (char *)"failure"; else 
#line 164 
                                                                tmp_4 = (char *)"problem";
      
#line 164 
      ;
      
#line 164 
      netdev_err((struct net_device const *)efx->net_dev,"LM87 detected a hardware %s (status %02x:%02x)",tmp_4,(int)alarms & 255,(int)alarms >> 8,tmp_3,tmp_2,tmp_1,tmp_0);
    }
    else ;
  }
  else ;
  
#line 176 
  if ((int)is_failure != 0) 
#line 176 
                            tmp_5 = -34; else 
#line 176 
                                              tmp_5 = 0;
  
#line 176 
  __retres = tmp_5;
  return_label: 
#line 176 
                return __retres;
}


#line 258  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static void sfe4001_poweroff(struct efx_nic *efx)
{
  struct falcon_board *tmp;
  struct falcon_board *tmp_0;
  
#line 260 
  tmp = falcon_board(efx);
  
#line 260 
  struct i2c_client *ioexp_client = tmp->ioexp_client;
  
#line 261 
  tmp_0 = falcon_board(efx);
  
#line 261 
  struct i2c_client *hwmon_client = tmp_0->hwmon_client;
  
#line 264 
  i2c_smbus_write_byte_data((struct i2c_client const *)ioexp_client,(unsigned char)2,(unsigned char)255);
  
#line 265 
  i2c_smbus_write_byte_data((struct i2c_client const *)ioexp_client,(unsigned char)7,(unsigned char)255);
  
#line 266 
  i2c_smbus_write_byte_data((struct i2c_client const *)ioexp_client,(unsigned char)6,(unsigned char)255);
  
#line 269 
  i2c_smbus_read_byte_data((struct i2c_client const *)hwmon_client,(unsigned char)2);
  
#line 270 
  return;
}


#line 272  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static int sfe4001_poweron(struct efx_nic *efx)
{
  int __retres;
  struct falcon_board *tmp;
  struct falcon_board *tmp_0;
  unsigned int i;
  unsigned int j;
  int rc;
  u8 out;
  
#line 274 
  tmp = falcon_board(efx);
  
#line 274 
  struct i2c_client *ioexp_client = tmp->ioexp_client;
  
#line 275 
  tmp_0 = falcon_board(efx);
  
#line 275 
  struct i2c_client *hwmon_client = tmp_0->hwmon_client;
  
#line 281 
  rc = i2c_smbus_read_byte_data((struct i2c_client const *)hwmon_client,(unsigned char)2);
  
#line 282 
  if (rc < 0) {
    
#line 283 
    __retres = rc;
    
#line 283 
    goto return_label;
  }
  else ;
  
#line 286 
  rc = i2c_smbus_write_byte_data((struct i2c_client const *)ioexp_client,(unsigned char)6,(unsigned char)0);
  
#line 287 
  if (rc != 0) {
    
#line 288 
    __retres = rc;
    
#line 288 
    goto return_label;
  }
  else ;
  
#line 289 
  rc = i2c_smbus_write_byte_data((struct i2c_client const *)ioexp_client,(unsigned char)7,(unsigned char)239);
  
#line 291 
  if (rc != 0) 
#line 292 
               goto fail_on; else ;
  
#line 297 
  rc = i2c_smbus_read_byte_data((struct i2c_client const *)ioexp_client,(unsigned char)2);
  
#line 298 
  if (rc < 0) 
#line 299 
              goto fail_on; else ;
  
#line 300 
  out = (unsigned char)255U;
  
#line 303 
  if ((int)out != rc) {
    
#line 304 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 304 
                                         netdev_info((struct net_device const *)efx->net_dev,"power-cycling PHY\n"); else ;
    
#line 305 
    rc = i2c_smbus_write_byte_data((struct i2c_client const *)ioexp_client,(unsigned char)2,(unsigned char)((int)out));
    
#line 306 
    if (rc != 0) 
#line 307 
                 goto fail_on; else ;
    
#line 308 
    schedule_timeout_uninterruptible(250L);
  }
  else ;
  
#line 311 
  i = 0U;
  
#line 311 
  goto ldv_55547;
  ldv_55546: 
#line 312 
  ;
  
#line 313 
  out = (unsigned char)161U;
  
#line 316 
  if (((unsigned int)efx->phy_mode & 8U) != 0U) 
#line 317 
                                                out = (unsigned char)((unsigned int)out | 8U); else ;
  
#line 319 
  rc = i2c_smbus_write_byte_data((struct i2c_client const *)ioexp_client,(unsigned char)2,(unsigned char)((int)out));
  
#line 320 
  if (rc != 0) 
#line 321 
               goto fail_on; else ;
  
#line 322 
  msleep(10U);
  
#line 325 
  out = (unsigned char)((unsigned int)out & 254U);
  
#line 326 
  rc = i2c_smbus_write_byte_data((struct i2c_client const *)ioexp_client,(unsigned char)2,(unsigned char)((int)out));
  
#line 327 
  if (rc != 0) 
#line 328 
               goto fail_on; else ;
  
#line 330 
  if ((efx->msg_enable & 8192U) != 0U) 
#line 330 
                                       netdev_info((struct net_device const *)efx->net_dev,"waiting for DSP boot (attempt %d)...\n",i); else ;
  
#line 336 
  if (((unsigned int)efx->phy_mode & 8U) != 0U) {
    
#line 337 
    schedule_timeout_uninterruptible(250L);
    
#line 338 
    __retres = 0;
    
#line 338 
    goto return_label;
  }
  else ;
  
#line 341 
  j = 0U;
  
#line 341 
  goto ldv_55544;
  ldv_55543: 
#line 342 
  ;
  
#line 342 
  msleep(100U);
  
#line 345 
  rc = i2c_smbus_read_byte_data((struct i2c_client const *)ioexp_client,(unsigned char)1);
  
#line 346 
  if (rc < 0) 
#line 347 
              goto fail_on; else ;
  
#line 348 
  if ((rc & 1) != 0) {
    
#line 349 
    __retres = 0;
    
#line 349 
    goto return_label;
  }
  else ;
  
#line 341 
  j += 1U;
  ldv_55544: 
#line 342 
  ;
  
#line 341 
  if (j <= 9U) 
#line 343 
               goto ldv_55543; else 
#line 346 
                                    goto ldv_55545;
  ldv_55545: 
#line 347 
  ;
  
#line 311 
  i += 1U;
  ldv_55547: 
#line 312 
  ;
  
#line 311 
  if (i <= 19U) 
#line 313 
                goto ldv_55546; else 
#line 316 
                                     goto ldv_55548;
  ldv_55548: 
#line 317 
  ;
  
#line 353 
  if ((efx->msg_enable & 8192U) != 0U) 
#line 353 
                                       netdev_info((struct net_device const *)efx->net_dev,"timed out waiting for DSP boot\n"); else ;
  
#line 354 
  rc = -110;
  fail_on: 
#line 355 
  ;
  
#line 356 
  sfe4001_poweroff(efx);
  
#line 357 
  __retres = rc;
  return_label: 
#line 357 
                return __retres;
}


#line 360  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static ssize_t show_phy_flash_cfg(struct device *dev, struct device_attribute *attr, char *buf)
{
  ssize_t __retres;
  struct efx_nic *tmp_0;
  struct pci_dev *tmp;
  int tmp_1;
  {
    
#line 363 
    struct device const *__mptr = (struct device const *)dev;
    
#line 363 
    tmp = (struct pci_dev *)__mptr + 18446744073709551464U;
  }
  
#line 363 
  tmp_0 = (struct efx_nic *)pci_get_drvdata(tmp);
  
#line 363 
  struct efx_nic *efx = tmp_0;
  
#line 364 
  tmp_1 = sprintf(buf,"%d\n",((unsigned int)efx->phy_mode & 8U) != 0U);
  
#line 364 
  __retres = (long)tmp_1;
  
#line 364 
  return __retres;
}


#line 367  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static ssize_t set_phy_flash_cfg(struct device *dev, struct device_attribute *attr, char const *buf, size_t count)
{
  ssize_t __retres;
  struct efx_nic *tmp_0;
  struct pci_dev *tmp;
  enum efx_phy_mode old_mode;
  enum efx_phy_mode new_mode;
  int err;
  unsigned long tmp_2;
  {
    
#line 371 
    struct device const *__mptr = (struct device const *)dev;
    
#line 371 
    tmp = (struct pci_dev *)__mptr + 18446744073709551464U;
  }
  
#line 371 
  tmp_0 = (struct efx_nic *)pci_get_drvdata(tmp);
  
#line 371 
  struct efx_nic *efx = tmp_0;
  
#line 375 
  rtnl_lock();
  
#line 376 
  old_mode = efx->phy_mode;
  
#line 377 
  if (count == 0UL || (int)*buf == 48) 
#line 378 
                                       new_mode = (enum efx_phy_mode)((unsigned int)old_mode & 4294967287U); else 
                                                                    
#line 380 
                                                                    new_mode = PHY_MODE_SPECIAL;
  
#line 381 
  if ((((unsigned int)old_mode ^ (unsigned int)new_mode) & 8U) == 0U) 
    
#line 382 
    err = 0;
  else 
    
#line 383 
    if (efx->state != (unsigned int)STATE_READY) 
#line 383 
                                                 goto _LOR;
    else {
      bool tmp_1;
      
#line 383 
      tmp_1 = netif_running((struct net_device const *)efx->net_dev);
      
#line 383 
      if ((int)tmp_1 != 0) _LOR: 
#line 384 
                                 err = -16;
      else {
        
#line 388 
        efx->phy_mode = new_mode;
        
#line 389 
        if (((unsigned int)new_mode & 8U) != 0U) 
#line 390 
                                                 falcon_stop_nic_stats(efx); else ;
        
#line 391 
        err = sfe4001_poweron(efx);
        
#line 392 
        if (err == 0) 
#line 393 
                      err = efx_reconfigure_port(efx); else ;
        
#line 394 
        if (((unsigned int)new_mode & 8U) == 0U) 
#line 395 
                                                 falcon_start_nic_stats(efx); else ;
      }
    }
  
#line 397 
  rtnl_unlock();
  
#line 399 
  if (err != 0) 
#line 399 
                tmp_2 = (unsigned long)err; else 
#line 399 
                                                 tmp_2 = count;
  
#line 399 
  __retres = (long)tmp_2;
  
#line 399 
  return __retres;
}


#line 402  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static struct device_attribute dev_attr_phy_flash_cfg = {.attr = {.name = "phy_flash_cfg", .mode = (unsigned short)420U, .ignore_lockdep = (_Bool)0, .key = (struct lock_class_key *)0, .skey = {.subkeys = {{.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}}}}, .show = & show_phy_flash_cfg, .store = & set_phy_flash_cfg};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static void sfe4001_fini(struct efx_nic *efx)
{
  
#line 406 
  struct falcon_board *board = falcon_board(efx);
  
#line 408 
  if ((efx->msg_enable & 1U) != 0U) 
#line 408 
                                    netdev_info((struct net_device const *)efx->net_dev,"%s\n","sfe4001_fini"); else ;
  
#line 410 
  ldv_device_remove_file_87(& (efx->pci_dev)->dev,(struct device_attribute const *)(& dev_attr_phy_flash_cfg));
  
#line 411 
  sfe4001_poweroff(efx);
  
#line 412 
  i2c_unregister_device(board->ioexp_client);
  
#line 413 
  i2c_unregister_device(board->hwmon_client);
  
#line 414 
  return;
}


#line 416  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static int sfe4001_check_hw(struct efx_nic *efx)
{
  int __retres;
  s32 status;
  struct falcon_board *tmp;
  int tmp_0;
  
#line 418 
  struct falcon_nic_data *nic_data = (struct falcon_nic_data *)efx->nic_data;
  
#line 422 
  if (! nic_data->xmac_poll_required) {
    
#line 423 
    __retres = 0;
    
#line 423 
    goto return_label;
  }
  else ;
  
#line 433 
  tmp = falcon_board(efx);
  
#line 433 
  status = i2c_smbus_read_byte_data((struct i2c_client const *)tmp->ioexp_client,(unsigned char)1);
  
#line 434 
  if (status >= 0 && (status & 3) != 0) {
    
#line 436 
    __retres = 0;
    
#line 436 
    goto return_label;
  }
  else ;
  
#line 439 
  sfe4001_poweroff(efx);
  
#line 440 
  efx->phy_mode = PHY_MODE_OFF;
  
#line 442 
  if (status < 0) 
#line 442 
                  tmp_0 = -5; else 
#line 442 
                                   tmp_0 = -34;
  
#line 442 
  __retres = tmp_0;
  return_label: 
#line 442 
                return __retres;
}


#line 445  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static struct i2c_board_info const sfe4001_hwmon_info = {.type = {(char)'m', (char)'a', (char)'x', (char)'6', (char)'6', (char)'4', (char)'7', (char)'\000'}, .flags = (unsigned short)0, .addr = (unsigned short)78U, .platform_data = (void *)0, .archdata = (struct dev_archdata *)0, .of_node = (struct device_node *)0, .fwnode = (struct fwnode_handle *)0, .irq = 0};

#line 453  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static int sfe4001_init(struct efx_nic *efx)
{
  int __retres;
  int rc;
  
#line 455 
  struct falcon_board *board = falcon_board(efx);
  
#line 459 
  board->hwmon_client = i2c_new_device(& board->i2c_adap,& sfe4001_hwmon_info);
  
#line 465 
  if (board->hwmon_client == (struct i2c_client *)0) {
    
#line 466 
    __retres = -5;
    
#line 466 
    goto return_label;
  }
  else ;
  
#line 469 
  rc = i2c_smbus_write_byte_data((struct i2c_client const *)board->hwmon_client,(unsigned char)11,(unsigned char)90);
  
#line 471 
  if (rc != 0) 
#line 472 
               goto fail_hwmon; else ;
  
#line 474 
  board->ioexp_client = i2c_new_dummy(& board->i2c_adap,(unsigned short)116);
  
#line 475 
  if (board->ioexp_client == (struct i2c_client *)0) {
    
#line 476 
    rc = -5;
    
#line 477 
    goto fail_hwmon;
  }
  else ;
  
#line 480 
  if (((unsigned int)efx->phy_mode & 8U) != 0U) 
#line 483 
                                                falcon_stop_nic_stats(efx); else ;
  
#line 485 
  rc = sfe4001_poweron(efx);
  
#line 486 
  if (rc != 0) 
#line 487 
               goto fail_ioexp; else ;
  
#line 489 
  rc = ldv_device_create_file_88(& (efx->pci_dev)->dev,(struct device_attribute const *)(& dev_attr_phy_flash_cfg));
  
#line 490 
  if (rc != 0) 
#line 491 
               goto fail_on; else ;
  
#line 493 
  if ((efx->msg_enable & 8192U) != 0U) 
#line 493 
                                       netdev_info((struct net_device const *)efx->net_dev,"PHY is powered on\n"); else ;
  
#line 494 
  __retres = 0;
  
#line 494 
  goto return_label;
  fail_on: 
#line 496 
  ;
  
#line 497 
  sfe4001_poweroff(efx);
  fail_ioexp: 
#line 498 
  ;
  
#line 499 
  i2c_unregister_device(board->ioexp_client);
  fail_hwmon: 
#line 500 
  ;
  
#line 501 
  i2c_unregister_device(board->hwmon_client);
  
#line 502 
  __retres = rc;
  return_label: 
#line 502 
                return __retres;
}


#line 509  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static u8 sfe4002_lm87_channel = (unsigned char)3U;

#line 511  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static u8 const sfe4002_lm87_regs[41U] = {(unsigned char)43U, (unsigned char)153U, (unsigned char)44U, (unsigned char)124U, (unsigned char)45U, (unsigned char)94U, (unsigned char)46U, (unsigned char)76U, (unsigned char)47U, (unsigned char)212U, (unsigned char)48U, (unsigned char)172U, (unsigned char)49U, (unsigned char)212U, (unsigned char)50U, (unsigned char)172U, (unsigned char)51U, (unsigned char)224U, (unsigned char)52U, (unsigned char)172U, (unsigned char)53U, (unsigned char)79U, (unsigned char)54U, (unsigned char)63U, (unsigned char)59U, (unsigned char)187U, (unsigned char)26U, (unsigned char)152U, (unsigned char)60U, (unsigned char)169U, (unsigned char)27U, (unsigned char)138U, (unsigned char)57U, (unsigned char)95U, (unsigned char)58U, (unsigned char)0U, (unsigned char)55U, (unsigned char)90U, (unsigned char)56U, (unsigned char)0U, (unsigned char)0U};

#line 525  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static struct i2c_board_info const sfe4002_hwmon_info = {.type = {(char)'l', (char)'m', (char)'8', (char)'7', (char)'\000'}, .flags = (unsigned short)0, .addr = (unsigned short)46U, .platform_data = (void *)(& sfe4002_lm87_channel), .archdata = (struct dev_archdata *)0, .of_node = (struct device_node *)0, .fwnode = (struct fwnode_handle *)0, .irq = 0};

#line 540  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static void sfe4002_init_phy(struct efx_nic *efx)
{
  
#line 544 
  falcon_qt202x_set_led(efx,1,3);
  
#line 546 
  falcon_qt202x_set_led(efx,0,11);
  
#line 548 
  falcon_qt202x_set_led(efx,2,4);
  
#line 549 
  return;
}


#line 551  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static void sfe4002_set_id_led(struct efx_nic *efx, enum efx_led_mode mode)
{
  int tmp;
  
#line 553 
  if (mode == (unsigned int)EFX_LED_ON) 
#line 553 
                                        tmp = 5; else 
#line 553 
                                                      tmp = 4;
  
#line 553 
  ;
  
#line 553 
  falcon_qt202x_set_led(efx,2,tmp);
  
#line 556 
  return;
}


#line 558  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static int sfe4002_check_hw(struct efx_nic *efx)
{
  int tmp_0;
  int tmp_1;
  
#line 560 
  struct falcon_board *board = falcon_board(efx);
  
#line 566 
  if (board->major == 0 && board->minor == 0) 
#line 566 
                                              tmp_0 = -33; else 
#line 566 
                                                                tmp_0 = -1;
  
#line 564 
  unsigned int alarm_mask = (unsigned int)tmp_0;
  
#line 568 
  tmp_1 = efx_check_lm87(efx,alarm_mask);
  
#line 568 
  return tmp_1;
}


#line 571  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static int sfe4002_init(struct efx_nic *efx)
{
  int tmp;
  
#line 573 
  tmp = efx_init_lm87(efx,& sfe4002_hwmon_info,(u8 const *)(& sfe4002_lm87_regs));
  
#line 573 
  return tmp;
}


#line 580  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static u8 sfn4112f_lm87_channel = (unsigned char)3U;

#line 582  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static u8 const sfn4112f_lm87_regs[33U] = {(unsigned char)43U, (unsigned char)153U, (unsigned char)44U, (unsigned char)124U, (unsigned char)45U, (unsigned char)94U, (unsigned char)46U, (unsigned char)76U, (unsigned char)47U, (unsigned char)212U, (unsigned char)48U, (unsigned char)172U, (unsigned char)51U, (unsigned char)224U, (unsigned char)52U, (unsigned char)172U, (unsigned char)53U, (unsigned char)79U, (unsigned char)54U, (unsigned char)63U, (unsigned char)60U, (unsigned char)169U, (unsigned char)27U, (unsigned char)138U, (unsigned char)57U, (unsigned char)75U, (unsigned char)58U, (unsigned char)0U, (unsigned char)55U, (unsigned char)90U, (unsigned char)56U, (unsigned char)0U, (unsigned char)0U};

#line 594  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static struct i2c_board_info const sfn4112f_hwmon_info = {.type = {(char)'l', (char)'m', (char)'8', (char)'7', (char)'\000'}, .flags = (unsigned short)0, .addr = (unsigned short)46U, .platform_data = (void *)(& sfn4112f_lm87_channel), .archdata = (struct dev_archdata *)0, .of_node = (struct device_node *)0, .fwnode = (struct fwnode_handle *)0, .irq = 0};

#line 602  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static void sfn4112f_init_phy(struct efx_nic *efx)
{
  
#line 604 
  falcon_qt202x_set_led(efx,0,10);
  
#line 606 
  falcon_qt202x_set_led(efx,1,9);
  
#line 607 
  return;
}


#line 610  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static void sfn4112f_set_id_led(struct efx_nic *efx, enum efx_led_mode mode)
{
  int reg;
  
#line 614 
  switch ((unsigned int)mode) {
    case (unsigned int)0: 
#line 615 
    ;
    
#line 616 
    reg = 4;
    
#line 617 
    goto ldv_55637;
    case (unsigned int)1: 
#line 618 
    ;
    
#line 619 
    reg = 5;
    
#line 620 
    goto ldv_55637;
    default: 
#line 621 
    ;
    
#line 622 
    reg = 9;
    
#line 623 
    goto ldv_55637;
  }
  ldv_55637: 
#line 626 
  ;
  
#line 626 
  falcon_qt202x_set_led(efx,1,reg);
  
#line 627 
  return;
}


#line 629  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static int sfn4112f_check_hw(struct efx_nic *efx)
{
  int tmp;
  
#line 632 
  tmp = efx_check_lm87(efx,4294967223U);
  
#line 632 
  return tmp;
}


#line 635  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static int sfn4112f_init(struct efx_nic *efx)
{
  int tmp;
  
#line 637 
  tmp = efx_init_lm87(efx,& sfn4112f_hwmon_info,(u8 const *)(& sfn4112f_lm87_regs));
  
#line 637 
  return tmp;
}


#line 644  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static u8 sfe4003_lm87_channel = (unsigned char)3U;

#line 646  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static u8 const sfe4003_lm87_regs[25U] = {(unsigned char)43U, (unsigned char)127U, (unsigned char)44U, (unsigned char)103U, (unsigned char)45U, (unsigned char)94U, (unsigned char)46U, (unsigned char)76U, (unsigned char)47U, (unsigned char)212U, (unsigned char)48U, (unsigned char)172U, (unsigned char)51U, (unsigned char)224U, (unsigned char)52U, (unsigned char)172U, (unsigned char)53U, (unsigned char)79U, (unsigned char)54U, (unsigned char)63U, (unsigned char)57U, (unsigned char)85U, (unsigned char)58U, (unsigned char)0U, (unsigned char)0U};

#line 656  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static struct i2c_board_info const sfe4003_hwmon_info = {.type = {(char)'l', (char)'m', (char)'8', (char)'7', (char)'\000'}, .flags = (unsigned short)0, .addr = (unsigned short)46U, .platform_data = (void *)(& sfe4003_lm87_channel), .archdata = (struct dev_archdata *)0, .of_node = (struct device_node *)0, .fwnode = (struct fwnode_handle *)0, .irq = 0};

#line 666  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static void sfe4003_set_id_led(struct efx_nic *efx, enum efx_led_mode mode)
{
  
#line 668 
  struct falcon_board *board = falcon_board(efx);
  
#line 671 
  if (board->minor <= 2 && board->major == 0) 
#line 672 
                                              goto return_label; else ;
  
#line 674 
  falcon_txc_set_gpio_val(efx,11,mode == (unsigned int)EFX_LED_ON);
  return_label: 
#line 677 
                return;
}


#line 679  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static void sfe4003_init_phy(struct efx_nic *efx)
{
  
#line 681 
  struct falcon_board *board = falcon_board(efx);
  
#line 684 
  if (board->minor <= 2 && board->major == 0) 
#line 685 
                                              goto return_label; else ;
  
#line 687 
  falcon_txc_set_gpio_dir(efx,11,1);
  
#line 688 
  falcon_txc_set_gpio_val(efx,11,0);
  return_label: 
#line 689 
                return;
}


#line 691  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static int sfe4003_check_hw(struct efx_nic *efx)
{
  int tmp_0;
  int tmp_1;
  
#line 693 
  struct falcon_board *board = falcon_board(efx);
  
#line 699 
  if (board->major == 0 && board->minor <= 2) 
#line 699 
                                              tmp_0 = -33; else 
#line 699 
                                                                tmp_0 = -1;
  
#line 697 
  unsigned int alarm_mask = (unsigned int)tmp_0;
  
#line 701 
  tmp_1 = efx_check_lm87(efx,alarm_mask);
  
#line 701 
  return tmp_1;
}


#line 704  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static int sfe4003_init(struct efx_nic *efx)
{
  int tmp;
  
#line 706 
  tmp = efx_init_lm87(efx,& sfe4003_hwmon_info,(u8 const *)(& sfe4003_lm87_regs));
  
#line 706 
  return tmp;
}


#line 709  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
static struct falcon_board_type const board_types[4U] = {{.id = (unsigned char)1U, .init = & sfe4001_init, .init_phy = & efx_port_dummy_op_void, .fini = & sfe4001_fini, .set_id_led = & tenxpress_set_id_led, .monitor = & sfe4001_check_hw}, {.id = (unsigned char)2U, .init = & sfe4002_init, .init_phy = & sfe4002_init_phy, .fini = & efx_fini_lm87, .set_id_led = & sfe4002_set_id_led, .monitor = & sfe4002_check_hw}, {.id = (unsigned char)3U, .init = & sfe4003_init, .init_phy = & sfe4003_init_phy, .fini = & efx_fini_lm87, .set_id_led = & sfe4003_set_id_led, .monitor = & sfe4003_check_hw}, {.id = (unsigned char)82U, .init = & sfn4112f_init, .init_phy = & sfn4112f_init_phy, .fini = & efx_fini_lm87, .set_id_led = & sfn4112f_set_id_led, .monitor = & sfn4112f_check_hw}};

#line 744  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon_boards.c"
int falcon_probe_board(struct efx_nic *efx, u16 revision_info)
{
  int __retres;
  int i;
  
#line 746 
  struct falcon_board *board = falcon_board(efx);
  
#line 747 
  u8 type_id = (unsigned char)((int)revision_info >> 8);
  
#line 750 
  board->major = ((int)revision_info >> 4) & 15;
  
#line 751 
  board->minor = (int)revision_info & 15;
  
#line 753 
  i = 0;
  
#line 753 
  goto ldv_55678;
  ldv_55677: 
#line 754 
  ;
  
#line 754 
  if ((int)board_types[i].id == (int)type_id) 
#line 755 
                                              board->type = & board_types[i]; else ;
  
#line 753 
  i += 1;
  ldv_55678: 
#line 754 
  ;
  
#line 753 
  if ((unsigned int)i <= 3U) 
#line 755 
                             goto ldv_55677; else 
#line 758 
                                                  goto ldv_55679;
  ldv_55679: 
#line 759 
  ;
  
#line 757 
  if (board->type != (struct falcon_board_type const *)0) {
    
#line 758 
    __retres = 0;
    
#line 758 
    goto return_label;
  }
  else {
    
#line 760 
    if ((efx->msg_enable & 2U) != 0U) 
#line 760 
                                      netdev_err((struct net_device const *)efx->net_dev,"unknown board type %d\n",(int)type_id); else ;
    
#line 762 
    __retres = -19;
    
#line 762 
    goto return_label;
  }
  return_label: 
#line 757 
                return __retres;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon_boards.c.aux"
struct device_attribute *ldv_emg_alias_dev_attr_phy_flash_cfg_3 = & dev_attr_phy_flash_cfg;

#line 61 
void ldv_emg_device_remove_file(struct device *arg0, struct device_attribute *arg1);


#line 63 
int ldv_emg_device_create_file(struct device *arg0, struct device_attribute *arg1);


#line 76  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon_boards.c.aux"
long ldv_emg_wrapper_set_phy_flash_cfg_4(struct device *arg0, struct device_attribute *arg1, char *arg2, unsigned long arg3)
{
  long tmp;
  
#line 77 
  tmp = set_phy_flash_cfg(arg0,arg1,(char const *)arg2,arg3);
  
#line 77 
  return tmp;
}


#line 81  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon_boards.c.aux"
long ldv_emg_wrapper_show_phy_flash_cfg_2(struct device *arg0, struct device_attribute *arg1, char *arg2)
{
  long tmp;
  
#line 82 
  tmp = show_phy_flash_cfg(arg0,arg1,arg2);
  
#line 82 
  return tmp;
}


#line 903  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon_boards.c.aux"
static void ldv_device_remove_file_87(struct device *ldv_func_arg1, struct device_attribute const *ldv_func_arg2)
{
  
#line 907 
  ldv_emg_device_remove_file(ldv_func_arg1,(struct device_attribute *)ldv_func_arg2);
  
#line 908 
  return;
}


#line 911  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon_boards.c.aux"
static int ldv_device_create_file_88(struct device *ldv_func_arg1, struct device_attribute const *ldv_func_arg2)
{
  int tmp;
  
#line 915 
  tmp = ldv_emg_device_create_file(ldv_func_arg1,(struct device_attribute *)ldv_func_arg2);
  
#line 915 
  return tmp;
}


#line 581  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kzalloc_3(size_t size, gfp_t flags);


#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mdio_10g.h"
__inline static unsigned int efx_mdio_id_rev(u32 id)
{
  unsigned int __retres;
  
#line 21 
  __retres = id & 15U;
  
#line 21 
  return __retres;
}


#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mdio_10g.h"
__inline static unsigned int efx_mdio_id_model(u32 id)
{
  unsigned int __retres;
  
#line 22 
  __retres = (id >> 4) & 63U;
  
#line 22 
  return __retres;
}


#line 23 
unsigned int efx_mdio_id_oui(u32 id);


#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mdio_10g.h"
__inline static u32 efx_mdio_read_id(struct efx_nic *efx, int mmd)
{
  u32 __retres;
  int tmp;
  int tmp_0;
  
#line 38 
  tmp = efx_mdio_read(efx,mmd,3);
  
#line 38 
  u16 id_low = (unsigned short)tmp;
  
#line 39 
  tmp_0 = efx_mdio_read(efx,mmd,2);
  
#line 39 
  u16 id_hi = (unsigned short)tmp_0;
  
#line 40 
  __retres = (unsigned int)(((int)id_hi << 16) | (int)id_low);
  
#line 40 
  return __retres;
}


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/phy.h"
struct efx_phy_operations const falcon_qt202x_phy_ops;


#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/qt202x_phy.c"
void falcon_qt202x_set_led(struct efx_nic *p, int led, int mode)
{
  
#line 55 
  int addr = led + 53254;
  
#line 56 
  efx_mdio_write(p,1,addr,mode);
  
#line 57 
  return;
}


#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/qt202x_phy.c"
static int qt2025c_wait_heartbeat(struct efx_nic *efx)
{
  int __retres;
  int reg;
  
#line 78 
  unsigned long timeout = jiffies + 1250UL;
  
#line 79 
  int old_counter = 0;
  ldv_55584: 
#line 80 
  ;
  {
    int counter;
    int tmp;
    
#line 84 
    reg = efx_mdio_read(efx,3,55278);
    
#line 85 
    if (reg < 0) {
      
#line 86 
      __retres = reg;
      
#line 86 
      goto return_label;
    }
    else ;
    
#line 87 
    counter = reg & 255;
    
#line 89 
    if (old_counter == 0) 
#line 90 
                          old_counter = counter;
    else 
      
#line 91 
      if (counter != old_counter) 
#line 92 
                                  goto ldv_55577; else ;
    {
      unsigned long __dummy;
      unsigned long volatile __dummy2;
      
#line 93 
      tmp = 1;
    }
    
#line 93 
    if (tmp != 0) {
      int tmp_0;
      {
        unsigned long __dummy_0;
        unsigned long __dummy2_0;
        
#line 93 
        tmp_0 = 1;
      }
      
#line 93 
      if (tmp_0 != 0) {
        
#line 93 
        if ((long)(timeout - jiffies) < 0L) {
          
#line 96 
          if ((efx->msg_enable & 8192U) != 0U) 
#line 96 
                                               netdev_err((struct net_device const *)efx->net_dev,"If an SFP+ direct attach cable is"); else ;
          
#line 100 
          __retres = -110;
          
#line 100 
          goto return_label;
        }
        else ;
      }
      else ;
    }
    else ;
    
#line 102 
    msleep(100U);
  }
  
#line 82 
  goto ldv_55584;
  ldv_55577: 
#line 83 
  ;
  
#line 105 
  __retres = 0;
  return_label: 
#line 105 
                return __retres;
}


#line 108  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/qt202x_phy.c"
static int qt2025c_wait_fw_status_good(struct efx_nic *efx)
{
  int __retres;
  int reg;
  int tmp;
  
#line 110 
  unsigned long timeout = jiffies + 625UL;
  ldv_55597: 
#line 112 
  ;
  
#line 115 
  reg = efx_mdio_read(efx,3,55293);
  
#line 116 
  if (reg < 0) {
    
#line 117 
    __retres = reg;
    
#line 117 
    goto return_label;
  }
  else ;
  
#line 118 
  if ((reg & 255) > 31) 
#line 121 
                        goto ldv_55590; else ;
  {
    unsigned long __dummy;
    unsigned long volatile __dummy2;
    
#line 122 
    tmp = 1;
  }
  
#line 122 
  if (tmp != 0) {
    int tmp_0;
    {
      unsigned long __dummy_0;
      unsigned long __dummy2_0;
      
#line 122 
      tmp_0 = 1;
    }
    
#line 122 
    if (tmp_0 != 0) {
      
#line 122 
      if ((long)(timeout - jiffies) < 0L) {
        
#line 123 
        __retres = -110;
        
#line 123 
        goto return_label;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 124 
  msleep(100U);
  
#line 115 
  goto ldv_55597;
  ldv_55590: 
#line 116 
  ;
  
#line 127 
  __retres = 0;
  return_label: 
#line 127 
                return __retres;
}


#line 130  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/qt202x_phy.c"
static void qt2025c_restart_firmware(struct efx_nic *efx)
{
  
#line 133 
  efx_mdio_write(efx,3,59476,192);
  
#line 134 
  efx_mdio_write(efx,3,59476,64);
  
#line 135 
  msleep(50U);
  
#line 136 
  return;
}


#line 138  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/qt202x_phy.c"
static int qt2025c_wait_reset(struct efx_nic *efx)
{
  int __retres;
  int rc;
  
#line 142 
  rc = qt2025c_wait_heartbeat(efx);
  
#line 143 
  if (rc != 0) {
    
#line 144 
    __retres = rc;
    
#line 144 
    goto return_label;
  }
  else ;
  
#line 146 
  rc = qt2025c_wait_fw_status_good(efx);
  
#line 147 
  if (rc == -110) {
    
#line 151 
    if ((efx->msg_enable & 8192U) != 0U) {
      
#line 151 
      struct _ddebug descriptor = {.modname = "sfc", .function = "qt2025c_wait_reset", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/qt202x_phy.c", .format = "bashing QT2025C microcontroller\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))152U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 151 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 151 
                                                          __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"bashing QT2025C microcontroller\n"); else ;
    }
    else ;
    
#line 153 
    qt2025c_restart_firmware(efx);
    
#line 154 
    rc = qt2025c_wait_heartbeat(efx);
    
#line 155 
    if (rc != 0) {
      
#line 156 
      __retres = rc;
      
#line 156 
      goto return_label;
    }
    else ;
    
#line 157 
    rc = qt2025c_wait_fw_status_good(efx);
  }
  else ;
  
#line 160 
  __retres = rc;
  return_label: 
#line 160 
                return __retres;
}


#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/qt202x_phy.c"
static void qt2025c_firmware_id(struct efx_nic *efx)
{
  u8 firmware_id[9U];
  size_t i;
  int tmp;
  
#line 165 
  struct qt202x_phy_data *phy_data = (struct qt202x_phy_data *)efx->phy_data;
  
#line 169 
  i = 0UL;
  
#line 169 
  goto ldv_55614;
  ldv_55613: 
#line 170 
  ;
  
#line 170 
  tmp = efx_mdio_read(efx,3,(int)(i + (size_t)55280U));
  
#line 170 
  firmware_id[i] = (unsigned char)tmp;
  
#line 169 
  i += 1UL;
  ldv_55614: 
#line 170 
  ;
  
#line 169 
  if (i <= 8UL) 
#line 171 
                goto ldv_55613; else 
#line 174 
                                     goto ldv_55615;
  ldv_55615: 
#line 175 
  ;
  
#line 172 
  if ((efx->msg_enable & 2U) != 0U) 
#line 172 
                                    netdev_info((struct net_device const *)efx->net_dev,"QT2025C firmware %xr%d v%d.%d.%d.%d [20%02d-%02d-%02d]\n",((int)firmware_id[0] << 8) | (int)firmware_id[1],(int)firmware_id[2],(int)firmware_id[3] >> 4,(int)firmware_id[3] & 15,(int)firmware_id[4],(int)firmware_id[5],(int)firmware_id[6],(int)firmware_id[7],(int)firmware_id[8]); else ;
  
#line 178 
  phy_data->firmware_ver = (unsigned int)((((((int)firmware_id[3] << 20) & 251658240) | (((int)firmware_id[3] << 16) & 983040)) | ((int)firmware_id[4] << 8)) | (int)firmware_id[5]);
  
#line 181 
  return;
}


#line 183  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/qt202x_phy.c"
static void qt2025c_bug17190_workaround(struct efx_nic *efx)
{
  int tmp_1;
  
#line 185 
  struct qt202x_phy_data *phy_data = (struct qt202x_phy_data *)efx->phy_data;
  
#line 193 
  if ((int)efx->link_state.up != 0) 
#line 193 
                                    goto _LOR;
  else {
    int tmp_0;
    bool tmp;
    
#line 194 
    tmp = efx_mdio_links_ok(efx,18U);
    
#line 194 
    if (tmp) 
#line 194 
             tmp_0 = 0; else 
#line 194 
                             tmp_0 = 1;
    
#line 194 
    if (tmp_0) {
      _LOR: {
              
#line 195 
              phy_data->bug17190_in_bad_state = (_Bool)0;
              
#line 196 
              goto return_label;
            }
    }
    else ;
  }
  
#line 199 
  if (! phy_data->bug17190_in_bad_state) {
    
#line 200 
    phy_data->bug17190_in_bad_state = (_Bool)1;
    
#line 201 
    phy_data->bug17190_timer = jiffies + 500UL;
    
#line 202 
    goto return_label;
  }
  else ;
  {
    unsigned long __dummy;
    unsigned long volatile __dummy2;
    
#line 205 
    tmp_1 = 1;
  }
  
#line 205 
  if (tmp_1 != 0) {
    int tmp_2;
    {
      unsigned long __dummy_0;
      unsigned long __dummy2_0;
      
#line 205 
      tmp_2 = 1;
    }
    
#line 205 
    if (tmp_2 != 0) {
      
#line 205 
      if ((long)(jiffies - phy_data->bug17190_timer) >= 0L) {
        
#line 206 
        if ((efx->msg_enable & 8192U) != 0U) {
          
#line 206 
          struct _ddebug descriptor = {.modname = "sfc", .function = "qt2025c_bug17190_workaround", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/qt202x_phy.c", .format = "bashing QT2025C PMA/PMD\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))206U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
          
#line 206 
          if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 206 
                                                              __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"bashing QT2025C PMA/PMD\n"); else ;
        }
        else ;
        
#line 207 
        efx_mdio_set_flag(efx,1,0,1,(_Bool)1);
        
#line 209 
        msleep(100U);
        
#line 210 
        efx_mdio_set_flag(efx,1,0,1,(_Bool)0);
        
#line 212 
        phy_data->bug17190_timer = jiffies + 500UL;
      }
      else ;
    }
    else ;
  }
  else ;
  return_label: 
#line 214 
                return;
}


#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/qt202x_phy.c"
static int qt2025c_select_phy_mode(struct efx_nic *efx)
{
  int __retres;
  int reg;
  int rc;
  int i;
  uint16_t phy_op_mode;
  
#line 218 
  struct qt202x_phy_data *phy_data = (struct qt202x_phy_data *)efx->phy_data;
  
#line 219 
  struct falcon_board *board = falcon_board(efx);
  
#line 226 
  if (phy_data->firmware_ver <= 33554687U) {
    
#line 227 
    __retres = 0;
    
#line 227 
    goto return_label;
  }
  else ;
  
#line 233 
  if (efx->loopback_mode == (unsigned int)LOOPBACK_NONE) 
#line 233 
                                                         phy_op_mode = (unsigned short)56U; else 
                                                                    
#line 233 
                                                                    phy_op_mode = (unsigned short)32U;
  
#line 236 
  reg = efx_mdio_read(efx,1,49945);
  
#line 237 
  if ((reg & 56) == (int)phy_op_mode) {
    
#line 238 
    __retres = 0;
    
#line 238 
    goto return_label;
  }
  else ;
  
#line 239 
  if ((efx->msg_enable & 8192U) != 0U) {
    
#line 239 
    struct _ddebug descriptor = {.modname = "sfc", .function = "qt2025c_select_phy_mode", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/qt202x_phy.c", .format = "Switching PHY to mode 0x%04x\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))240U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 239 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 239 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"Switching PHY to mode 0x%04x\n",(int)phy_op_mode); else ;
  }
  else ;
  
#line 246 
  efx_mdio_write(efx,1,49920,0);
  
#line 251 
  if (board->major == 0 && board->minor <= 1) {
    
#line 252 
    efx_mdio_write(efx,1,49923,17560);
    
#line 253 
    i = 0;
    
#line 253 
    goto ldv_55640;
    ldv_55639: 
#line 254 
    ;
    
#line 254 
    efx_mdio_write(efx,1,49923,17544);
    
#line 255 
    efx_mdio_write(efx,1,49923,17536);
    
#line 256 
    efx_mdio_write(efx,1,49923,17552);
    
#line 257 
    efx_mdio_write(efx,1,49923,17560);
    
#line 253 
    i += 1;
    ldv_55640: 
#line 254 
    ;
    
#line 253 
    if (i <= 8) 
#line 255 
                goto ldv_55639; else 
#line 258 
                                     goto ldv_55641;
    ldv_55641: 
#line 259 
    ;
  }
  else {
    
#line 260 
    efx_mdio_write(efx,1,49923,2336);
    
#line 261 
    efx_mdio_write(efx,1,53256,4);
    
#line 262 
    i = 0;
    
#line 262 
    goto ldv_55643;
    ldv_55642: 
#line 263 
    ;
    
#line 263 
    efx_mdio_write(efx,1,49923,2304);
    
#line 264 
    efx_mdio_write(efx,1,53256,5);
    
#line 265 
    efx_mdio_write(efx,1,49923,2336);
    
#line 266 
    efx_mdio_write(efx,1,53256,4);
    
#line 262 
    i += 1;
    ldv_55643: 
#line 263 
    ;
    
#line 262 
    if (i <= 8) 
#line 264 
                goto ldv_55642; else 
#line 267 
                                     goto ldv_55644;
    ldv_55644: 
#line 268 
    ;
    
#line 268 
    efx_mdio_write(efx,1,49923,18688);
  }
  
#line 270 
  efx_mdio_write(efx,1,49923,18688);
  
#line 271 
  efx_mdio_write(efx,1,49922,4);
  
#line 272 
  efx_mdio_write(efx,1,49942,19);
  
#line 273 
  efx_mdio_write(efx,1,49944,84);
  
#line 274 
  efx_mdio_write(efx,1,49945,(int)phy_op_mode);
  
#line 275 
  efx_mdio_write(efx,1,49946,152);
  
#line 276 
  efx_mdio_write(efx,3,38,3584);
  
#line 277 
  efx_mdio_write(efx,3,39,19);
  
#line 278 
  efx_mdio_write(efx,3,40,42280);
  
#line 279 
  efx_mdio_write(efx,1,53254,10);
  
#line 280 
  efx_mdio_write(efx,1,53255,9);
  
#line 281 
  efx_mdio_write(efx,1,53256,4);
  
#line 286 
  efx_mdio_write(efx,1,49943,255);
  
#line 289 
  efx_mdio_set_flag(efx,1,49921,64,(_Bool)0);
  
#line 291 
  efx_mdio_write(efx,1,49920,2);
  
#line 292 
  msleep(20U);
  
#line 295 
  qt2025c_restart_firmware(efx);
  
#line 298 
  rc = qt2025c_wait_reset(efx);
  
#line 299 
  if (rc < 0) {
    
#line 300 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 300 
                                         netdev_err((struct net_device const *)efx->net_dev,"PHY microcontroller reset during mode switch "); else ;
    
#line 303 
    __retres = rc;
    
#line 303 
    goto return_label;
  }
  else ;
  
#line 306 
  __retres = 0;
  return_label: 
#line 306 
                return __retres;
}


#line 309  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/qt202x_phy.c"
static int qt202x_reset_phy(struct efx_nic *efx)
{
  int __retres;
  int rc;
  struct falcon_board *tmp;
  
#line 313 
  if (efx->phy_type == 9U) {
    
#line 316 
    rc = qt2025c_wait_reset(efx);
    
#line 317 
    if (rc < 0) 
#line 318 
                goto fail; else ;
  }
  else {
    
#line 322 
    rc = efx_mdio_reset_mmd(efx,4,50,10);
    
#line 326 
    if (rc < 0) 
#line 327 
                goto fail; else ;
  }
  
#line 331 
  msleep(250U);
  
#line 333 
  tmp = falcon_board(efx);
  
#line 333 
  (*((tmp->type)->init_phy))(efx);
  
#line 335 
  __retres = 0;
  
#line 335 
  goto return_label;
  fail: 
#line 337 
  ;
  
#line 338 
  if ((efx->msg_enable & 8192U) != 0U) 
#line 338 
                                       netdev_err((struct net_device const *)efx->net_dev,"PHY reset timed out\n"); else ;
  
#line 339 
  __retres = rc;
  return_label: 
#line 339 
                return __retres;
}


#line 342  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/qt202x_phy.c"
static int qt202x_phy_probe(struct efx_nic *efx)
{
  int __retres;
  struct qt202x_phy_data *phy_data;
  
#line 346 
  phy_data = (struct qt202x_phy_data *)kzalloc_3(24UL,208U);
  
#line 347 
  if (phy_data == (struct qt202x_phy_data *)0) {
    
#line 348 
    __retres = -12;
    
#line 348 
    goto return_label;
  }
  else ;
  
#line 349 
  efx->phy_data = (void *)phy_data;
  
#line 350 
  phy_data->phy_mode = efx->phy_mode;
  
#line 351 
  phy_data->bug17190_in_bad_state = (_Bool)0;
  
#line 352 
  phy_data->bug17190_timer = 0UL;
  
#line 354 
  efx->mdio.mmds = 26U;
  
#line 355 
  efx->mdio.mode_support = 6U;
  
#line 356 
  efx->loopback_modes = 67305528ULL;
  
#line 357 
  __retres = 0;
  return_label: 
#line 357 
                return __retres;
}


#line 360  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/qt202x_phy.c"
static int qt202x_phy_init(struct efx_nic *efx)
{
  int __retres;
  u32 devid;
  int rc;
  
#line 365 
  rc = qt202x_reset_phy(efx);
  
#line 366 
  if (rc != 0) {
    
#line 367 
    if ((efx->msg_enable & 2U) != 0U) 
#line 367 
                                      netdev_err((struct net_device const *)efx->net_dev,"PHY init failed\n"); else ;
    
#line 368 
    __retres = rc;
    
#line 368 
    goto return_label;
  }
  else ;
  
#line 371 
  devid = efx_mdio_read_id(efx,4);
  
#line 372 
  if ((efx->msg_enable & 2U) != 0U) {
    unsigned int tmp;
    unsigned int tmp_0;
    unsigned int tmp_1;
    
#line 372 
    tmp = efx_mdio_id_rev(devid);
    
#line 372 
    tmp_0 = efx_mdio_id_model(devid);
    
#line 372 
    tmp_1 = efx_mdio_id_oui(devid);
    
#line 372 
    ;
    
#line 372 
    ;
    
#line 372 
    netdev_info((struct net_device const *)efx->net_dev,"PHY ID reg %x (OUI %06x model %02x revision %x)\n",devid,tmp_1,tmp_0,tmp);
  }
  else ;
  
#line 377 
  if (efx->phy_type == 9U) 
#line 378 
                           qt2025c_firmware_id(efx); else ;
  
#line 380 
  __retres = 0;
  return_label: 
#line 380 
                return __retres;
}


#line 383  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/qt202x_phy.c"
static int qt202x_link_ok(struct efx_nic *efx)
{
  int __retres;
  bool tmp;
  
#line 385 
  tmp = efx_mdio_links_ok(efx,26U);
  
#line 385 
  __retres = (int)tmp;
  
#line 385 
  return __retres;
}


#line 388  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/qt202x_phy.c"
static bool qt202x_phy_poll(struct efx_nic *efx)
{
  bool __retres;
  int tmp;
  
#line 390 
  bool was_up = efx->link_state.up;
  
#line 392 
  tmp = qt202x_link_ok(efx);
  
#line 392 
  efx->link_state.up = (_Bool)(tmp != 0);
  
#line 393 
  efx->link_state.speed = 10000U;
  
#line 394 
  efx->link_state.fd = (_Bool)1;
  
#line 395 
  efx->link_state.fc = efx->wanted_fc;
  
#line 397 
  if (efx->phy_type == 9U) 
#line 398 
                           qt2025c_bug17190_workaround(efx); else ;
  
#line 400 
  __retres = (_Bool)((int)efx->link_state.up != (int)was_up);
  
#line 400 
  return __retres;
}


#line 403  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/qt202x_phy.c"
static int qt202x_phy_reconfigure(struct efx_nic *efx)
{
  int __retres;
  
#line 405 
  struct qt202x_phy_data *phy_data = (struct qt202x_phy_data *)efx->phy_data;
  
#line 407 
  if (efx->phy_type == 9U) {
    
#line 408 
    int rc = qt2025c_select_phy_mode(efx);
    
#line 409 
    if (rc != 0) {
      
#line 410 
      __retres = rc;
      
#line 410 
      goto return_label;
    }
    else ;
    
#line 417 
    mdio_set_flag((struct mdio_if_info const *)(& efx->mdio),efx->mdio.prtad,1,(unsigned short)49929,8192,(_Bool)((int)((_Bool)((((((unsigned int)efx->phy_mode & 1U) != 0U || ((unsigned int)efx->phy_mode & 2U) != 0U) || efx->loopback_mode == (unsigned int)LOOPBACK_PCS) || efx->loopback_mode == (unsigned int)LOOPBACK_PMAPMD) != 0))));
  }
  else {
    
#line 426 
    if (((unsigned int)efx->phy_mode & 1U) == 0U && ((unsigned int)phy_data->phy_mode & 1U) != 0U) 
      
#line 428 
      qt202x_reset_phy(efx); else ;
    
#line 430 
    efx_mdio_transmit_disable(efx);
  }
  
#line 433 
  efx_mdio_phy_reconfigure(efx);
  
#line 435 
  phy_data->phy_mode = efx->phy_mode;
  
#line 437 
  __retres = 0;
  return_label: 
#line 437 
                return __retres;
}


#line 440  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/qt202x_phy.c"
static void qt202x_phy_get_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd)
{
  
#line 442 
  mdio45_ethtool_gset((struct mdio_if_info const *)(& efx->mdio),ecmd);
  
#line 443 
  return;
}


#line 445  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/qt202x_phy.c"
static void qt202x_phy_remove(struct efx_nic *efx)
{
  
#line 448 
  kfree((void const *)efx->phy_data);
  
#line 449 
  efx->phy_data = (void *)0;
  
#line 450 
  return;
}


#line 452  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/qt202x_phy.c"
static int qt202x_phy_get_module_info(struct efx_nic *efx, struct ethtool_modinfo *modinfo)
{
  int __retres;
  
#line 455 
  modinfo->type = 1U;
  
#line 456 
  modinfo->eeprom_len = 256U;
  
#line 457 
  __retres = 0;
  
#line 457 
  return __retres;
}


#line 460  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/qt202x_phy.c"
static int qt202x_phy_get_module_eeprom(struct efx_nic *efx, struct ethtool_eeprom *ee, u8 *data)
{
  int __retres;
  int mmd;
  int reg_base;
  int rc;
  int i;
  
#line 465 
  if (efx->phy_type == 9U) {
    
#line 466 
    mmd = 3;
    
#line 467 
    reg_base = 53248;
  }
  else {
    
#line 469 
    mmd = 1;
    
#line 470 
    reg_base = 32775;
  }
  
#line 473 
  i = 0;
  
#line 473 
  goto ldv_55692;
  ldv_55691: 
#line 474 
  ;
  
#line 474 
  rc = efx_mdio_read(efx,mmd,(int)((ee->offset + (unsigned int)reg_base) + (unsigned int)i));
  
#line 475 
  if (rc < 0) {
    
#line 476 
    __retres = rc;
    
#line 476 
    goto return_label;
  }
  else ;
  
#line 477 
  *(data + i) = (unsigned char)rc;
  
#line 473 
  i += 1;
  ldv_55692: 
#line 474 
  ;
  
#line 473 
  if (ee->len > (unsigned int)i) 
#line 475 
                                 goto ldv_55691; else 
#line 478 
                                                      goto ldv_55693;
  ldv_55693: 
#line 479 
  ;
  
#line 480 
  __retres = 0;
  return_label: 
#line 480 
                return __retres;
}


#line 483  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/qt202x_phy.c"
struct efx_phy_operations const falcon_qt202x_phy_ops = {.probe = & qt202x_phy_probe, .init = & qt202x_phy_init, .fini = & efx_port_dummy_op_void, .remove = & qt202x_phy_remove, .reconfigure = & qt202x_phy_reconfigure, .poll = & qt202x_phy_poll, .get_settings = & qt202x_phy_get_settings, .set_settings = & efx_mdio_set_settings, .set_npage_adv = (void (*)(struct efx_nic *, u32 ))0, .test_alive = & efx_mdio_test_alive, .test_name = (char const *(*)(struct efx_nic *, unsigned int ))0, .run_tests = (int (*)(struct efx_nic *, int *, unsigned int ))0, .get_module_eeprom = & qt202x_phy_get_module_eeprom, .get_module_info = & qt202x_phy_get_module_info};

#line 441  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_qt202x_phy.c.aux"
static void *kzalloc_3(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 444 
  tmp = ldv_kzalloc(size,flags);
  
#line 444 
  return tmp;
}


#line 405  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
int snprintf(char *, size_t, char const * , ...);


#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
char *strcpy(char *, char const *);


#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/string.h"
char *strchr(char const *, int);


#line 355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_bh_0(spinlock_t *lock)
{
  
#line 357 
  _raw_spin_lock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 358 
  return;
}


#line 407 
static void ldv_spin_lock_bh_91(spinlock_t *lock);


#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_bh_0(spinlock_t *lock)
{
  
#line 406 
  _raw_spin_unlock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 407 
  return;
}


#line 460 
static void ldv_spin_unlock_bh_92(spinlock_t *lock);


#line 37  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ethtool.c.aux"
static void ldv_mutex_lock_87_0(struct mutex *ldv_func_arg1);


#line 41 
static void ldv_mutex_lock_89_0(struct mutex *ldv_func_arg1);


#line 45 
static void ldv_mutex_lock_93_0(struct mutex *ldv_func_arg1);


#line 49 
static void ldv_mutex_lock_95_0(struct mutex *ldv_func_arg1);


#line 53 
static void ldv_mutex_lock_97_0(struct mutex *ldv_func_arg1);


#line 193  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
static void ldv_mutex_unlock_88_0(struct mutex *ldv_func_arg1);


#line 197 
static void ldv_mutex_unlock_90_0(struct mutex *ldv_func_arg1);


#line 201 
static void ldv_mutex_unlock_94_0(struct mutex *ldv_func_arg1);


#line 205 
static void ldv_mutex_unlock_96_0(struct mutex *ldv_func_arg1);


#line 209 
static void ldv_mutex_unlock_98_0(struct mutex *ldv_func_arg1);


#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
__inline static char const *kobject_name(struct kobject const *kobj)
{
  char const *__retres;
  
#line 89 
  __retres = kobj->name;
  
#line 89 
  return __retres;
}


#line 833  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static char const *dev_name(struct device const *dev)
{
  char const *__retres;
  char const *tmp;
  
#line 836 
  if (dev->init_name != (char const *)0) {
    
#line 837 
    __retres = dev->init_name;
    
#line 837 
    goto return_label;
  }
  else ;
  
#line 839 
  tmp = kobject_name(& dev->kobj);
  
#line 839 
  __retres = tmp;
  return_label: 
#line 839 
                return __retres;
}


#line 581  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kzalloc_4(size_t size, gfp_t flags);


#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
__inline static void ethtool_cmd_speed_set(struct ethtool_cmd *ep, __u32 speed)
{
  
#line 117 
  ep->speed = (unsigned short)speed;
  
#line 118 
  ep->speed_hi = (unsigned short)(speed >> 16);
  
#line 119 
  return;
}


#line 121  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
__inline static __u32 ethtool_cmd_speed(struct ethtool_cmd const *ep)
{
  __u32 __retres;
  
#line 123 
  __retres = (unsigned int)(((int)ep->speed_hi << 16) | (int)ep->speed);
  
#line 123 
  return __retres;
}


#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
u32 ethtool_op_get_link(struct net_device *);


#line 1880  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void *netdev_priv(struct net_device const *dev)
{
  void *__retres;
  
#line 1882 
  __retres = (void *)dev + 3008U;
  
#line 1882 
  return __retres;
}


#line 2182 
int dev_open(struct net_device *);


#line 2183 
int dev_close(struct net_device *);


#line 157  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool is_broadcast_ether_addr(u8 const *addr)
{
  bool __retres;
  
#line 161 
  __retres = (_Bool)((unsigned int)(((int)*((u16 const *)addr) & (int)*((u16 const *)(addr + 2U))) & (int)*((u16 const *)(addr + 4U))) == 65535U);
  
#line 161 
  return __retres;
}


#line 233  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static void eth_broadcast_addr(u8 *addr)
{
  
#line 235 
  memset((void *)addr,255,6UL);
  
#line 236 
  return;
}


#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool ether_addr_equal(u8 const *addr1, u8 const *addr2)
{
  bool __retres;
  
#line 313 
  u32 fold = (*((u32 const *)addr1) ^ *((u32 const *)addr2)) | (unsigned int)((int)*((u16 const *)(addr1 + 4U)) ^ (int)*((u16 const *)(addr2 + 4U)));
  
#line 316 
  __retres = (_Bool)(fold == 0U);
  
#line 316 
  return __retres;
}


#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mdio.h"
int mdio45_nway_restart(struct mdio_if_info const *);


#line 1484  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static char const *pci_name(struct pci_dev const *pdev)
{
  char const *tmp;
  
#line 1486 
  tmp = dev_name(& pdev->dev);
  
#line 1486 
  return tmp;
}


#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/filter.h"
__inline static void efx_filter_init_rx(struct efx_filter_spec *spec, enum efx_filter_priority priority, enum efx_filter_flags flags, unsigned int rxq_id)
{
  
#line 160 
  memset((void *)spec,0,64UL);
  
#line 161 
  spec->priority = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))priority;
  
#line 162 
  spec->flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))((unsigned int)((unsigned char)flags) | 8U);
  
#line 163 
  spec->rss_context = 4294967295U;
  
#line 164 
  spec->dmaq_id = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))))rxq_id;
  
#line 165 
  return;
}


#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
unsigned int efx_tx_max_skb_descs(struct efx_nic *efx);


#line 80 
void efx_mac_reconfigure(struct efx_nic *efx);


#line 107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
__inline static s32 efx_filter_insert_filter(struct efx_nic *efx, struct efx_filter_spec *spec, bool replace_equal)
{
  s32 tmp;
  
#line 111 
  tmp = (*((efx->type)->filter_insert))(efx,spec,(_Bool)((bool)((int)replace_equal) != 0));
  
#line 111 
  return tmp;
}


#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
__inline static int efx_filter_remove_id_safe(struct efx_nic *efx, enum efx_filter_priority priority, u32 filter_id)
{
  int tmp;
  
#line 127 
  tmp = (*((efx->type)->filter_remove_safe))(efx,priority,filter_id);
  
#line 127 
  return tmp;
}


#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
__inline static int efx_filter_get_filter_safe(struct efx_nic *efx, enum efx_filter_priority priority, u32 filter_id, struct efx_filter_spec *spec)
{
  int tmp;
  
#line 145 
  tmp = (*((efx->type)->filter_get_safe))(efx,priority,filter_id,spec);
  
#line 145 
  return tmp;
}


#line 148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
__inline static u32 efx_filter_count_rx_used(struct efx_nic *efx, enum efx_filter_priority priority)
{
  u32 tmp;
  
#line 151 
  tmp = (*((efx->type)->filter_count_rx_used))(efx,priority);
  
#line 151 
  return tmp;
}


#line 153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
__inline static u32 efx_filter_get_rx_id_limit(struct efx_nic *efx)
{
  u32 tmp;
  
#line 155 
  tmp = (*((efx->type)->filter_get_rx_id_limit))(efx);
  
#line 155 
  return tmp;
}


#line 157  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
__inline static s32 efx_filter_get_rx_ids(struct efx_nic *efx, enum efx_filter_priority priority, u32 *buf, u32 size)
{
  s32 tmp;
  
#line 161 
  tmp = (*((efx->type)->filter_get_rx_ids))(efx,priority,buf,size);
  
#line 161 
  return tmp;
}


#line 183 
int efx_realloc_channels(struct efx_nic *efx, u32 rxq_entries, u32 txq_entries);


#line 190 
struct ethtool_ops const efx_ethtool_ops;


#line 193 
int efx_reset(struct efx_nic *efx, enum reset_type method);


#line 200 
int efx_init_irq_moderation(struct efx_nic *efx, unsigned int tx_usecs, unsigned int rx_usecs, bool rx_adaptive, bool rx_may_override_tx);


#line 203 
void efx_get_irq_moderation(struct efx_nic *efx, unsigned int *tx_usecs, unsigned int *rx_usecs, bool *rx_adaptive);


#line 255 
void efx_link_set_wanted_fc(struct efx_nic *efx, u8 wanted_fc);


#line 318  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.h"
void efx_mcdi_print_fwver(struct efx_nic *efx, char *buf, size_t len);


#line 562  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
void efx_ptp_get_ts_info(struct efx_nic *efx, struct ethtool_ts_info *ts_info);


#line 569 
size_t efx_ptp_describe_stats(struct efx_nic *efx, u8 *strings);


#line 570 
size_t efx_ptp_update_stats(struct efx_nic *efx, u64 *stats);


#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static u64 efx_get_uint_stat(void *field)
{
  u64 __retres;
  
#line 47 
  __retres = (unsigned long long)*((unsigned int *)field);
  
#line 47 
  return __retres;
}


#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static u64 efx_get_atomic_stat(void *field)
{
  u64 __retres;
  int tmp;
  
#line 52 
  tmp = atomic_read((atomic_t const *)field);
  
#line 52 
  __retres = (unsigned long long)tmp;
  
#line 52 
  return __retres;
}


#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static struct efx_sw_stat_desc const efx_sw_stat_desc[14U] = {{.name = "tx_merge_events", .source = EFX_ETHTOOL_STAT_SOURCE_tx_queue, .offset = 136U, .get_stat = & efx_get_uint_stat}, {.name = "tx_tso_bursts", .source = EFX_ETHTOOL_STAT_SOURCE_tx_queue, .offset = 204U, .get_stat = & efx_get_uint_stat}, {.name = "tx_tso_long_headers", .source = EFX_ETHTOOL_STAT_SOURCE_tx_queue, .offset = 208U, .get_stat = & efx_get_uint_stat}, {.name = "tx_tso_packets", .source = EFX_ETHTOOL_STAT_SOURCE_tx_queue, .offset = 212U, .get_stat = & efx_get_uint_stat}, {.name = "tx_pushes", .source = EFX_ETHTOOL_STAT_SOURCE_tx_queue, .offset = 216U, .get_stat = & efx_get_uint_stat}, {.name = "tx_pio_packets", .source = EFX_ETHTOOL_STAT_SOURCE_tx_queue, .offset = 220U, .get_stat = & efx_get_uint_stat}, {.name = "rx_reset", .source = EFX_ETHTOOL_STAT_SOURCE_nic, .offset = 3192U, .get_stat = & efx_get_atomic_stat}, {.name = "rx_tobe_disc", .source = EFX_ETHTOOL_STAT_SOURCE_channel, .offset = 464U, .get_stat = & efx_get_uint_stat}, {.name = "rx_ip_hdr_chksum_err", .source = EFX_ETHTOOL_STAT_SOURCE_channel, .offset = 468U, .get_stat = & efx_get_uint_stat}, {.name = "rx_tcp_udp_chksum_err", .source = EFX_ETHTOOL_STAT_SOURCE_channel, .offset = 472U, .get_stat = & efx_get_uint_stat}, {.name = "rx_mcast_mismatch", .source = EFX_ETHTOOL_STAT_SOURCE_channel, .offset = 476U, .get_stat = & efx_get_uint_stat}, {.name = "rx_frm_trunc", .source = EFX_ETHTOOL_STAT_SOURCE_channel, .offset = 480U, .get_stat = & efx_get_uint_stat}, {.name = "rx_merge_events", .source = EFX_ETHTOOL_STAT_SOURCE_channel, .offset = 496U, .get_stat = & efx_get_uint_stat}, {.name = "rx_merge_packets", .source = EFX_ETHTOOL_STAT_SOURCE_channel, .offset = 500U, .get_stat = & efx_get_uint_stat}};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static int efx_ethtool_phys_id(struct net_device *net_dev, enum ethtool_phys_id_state state)
{
  int __retres;
  
#line 99 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 100 
  enum efx_led_mode mode = EFX_LED_DEFAULT;
  
#line 102 
  switch ((unsigned int)state) {
    case (unsigned int)2: 
#line 103 
    ;
    
#line 104 
    mode = EFX_LED_ON;
    
#line 105 
    goto ldv_55567;
    case (unsigned int)3: 
#line 106 
    ;
    
#line 107 
    mode = EFX_LED_OFF;
    
#line 108 
    goto ldv_55567;
    case (unsigned int)0: 
#line 109 
    ;
    
#line 110 
    mode = EFX_LED_DEFAULT;
    
#line 111 
    goto ldv_55567;
    case (unsigned int)1: 
#line 112 
    ;
    
#line 113 
    __retres = 1;
    
#line 113 
    goto return_label;
  }
  ldv_55567: 
#line 116 
  ;
  
#line 116 
  (*((efx->type)->set_id_led))(efx,mode);
  
#line 117 
  __retres = 0;
  return_label: 
#line 117 
                return __retres;
}


#line 121  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static int efx_ethtool_get_settings(struct net_device *net_dev, struct ethtool_cmd *ecmd)
{
  int __retres;
  
#line 124 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 125 
  struct efx_link_state *link_state = & efx->link_state;
  
#line 127 
  ldv_mutex_lock_87_0(& efx->mac_lock);
  
#line 128 
  (*((efx->phy_op)->get_settings))(efx,ecmd);
  
#line 129 
  ldv_mutex_unlock_88_0(& efx->mac_lock);
  
#line 132 
  ecmd->supported |= 24576U;
  
#line 134 
  if (((66600958 >> (unsigned int)efx->loopback_mode) & 1) != 0) {
    
#line 135 
    ethtool_cmd_speed_set(ecmd,link_state->speed);
    
#line 136 
    ecmd->duplex = (unsigned char)((int)link_state->fd != 0);
  }
  else ;
  
#line 139 
  __retres = 0;
  
#line 139 
  return __retres;
}


#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static int efx_ethtool_set_settings(struct net_device *net_dev, struct ethtool_cmd *ecmd)
{
  int __retres;
  int rc;
  __u32 tmp_0;
  
#line 146 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 150 
  tmp_0 = ethtool_cmd_speed((struct ethtool_cmd const *)ecmd);
  
#line 150 
  if (tmp_0 == 1000U) {
    
#line 150 
    if ((unsigned int)ecmd->duplex != 1U) {
      
#line 152 
      if ((efx->msg_enable & 1U) != 0U) {
        
#line 152 
        struct _ddebug descriptor = {.modname = "sfc", .function = "efx_ethtool_set_settings", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c", .format = "rejecting unsupported 1000Mbps HD setting\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))153U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 152 
        if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 152 
                                                            __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"rejecting unsupported 1000Mbps HD setting\n"); else ;
      }
      else ;
      
#line 154 
      __retres = -22;
      
#line 154 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 157 
  ldv_mutex_lock_89_0(& efx->mac_lock);
  
#line 158 
  rc = (*((efx->phy_op)->set_settings))(efx,ecmd);
  
#line 159 
  ldv_mutex_unlock_90_0(& efx->mac_lock);
  
#line 160 
  __retres = rc;
  return_label: 
#line 160 
                return __retres;
}


#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static void efx_ethtool_get_drvinfo(struct net_device *net_dev, struct ethtool_drvinfo *info)
{
  int tmp_0;
  char const *tmp_1;
  
#line 166 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 168 
  strlcpy((char *)(& info->driver),"sfc",32UL);
  
#line 169 
  strlcpy((char *)(& info->version),"4.0",32UL);
  
#line 170 
  tmp_0 = efx_nic_rev(efx);
  
#line 170 
  if (tmp_0 > 2) 
#line 171 
                 efx_mcdi_print_fwver(efx,(char *)(& info->fw_version),32UL); else ;
  
#line 173 
  tmp_1 = pci_name((struct pci_dev const *)efx->pci_dev);
  
#line 173 
  ;
  
#line 173 
  strlcpy((char *)(& info->bus_info),tmp_1,32UL);
  
#line 174 
  return;
}


#line 176  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static int efx_ethtool_get_regs_len(struct net_device *net_dev)
{
  int __retres;
  size_t tmp_0;
  void *tmp;
  
#line 178 
  tmp = netdev_priv((struct net_device const *)net_dev);
  
#line 178 
  tmp_0 = efx_nic_get_regs_len((struct efx_nic *)tmp);
  
#line 178 
  __retres = (int)tmp_0;
  
#line 178 
  return __retres;
}


#line 181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static void efx_ethtool_get_regs(struct net_device *net_dev, struct ethtool_regs *regs, void *buf)
{
  
#line 184 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 186 
  regs->version = (unsigned int)(efx->type)->revision;
  
#line 187 
  efx_nic_get_regs(efx,buf);
  
#line 188 
  return;
}


#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static u32 efx_ethtool_get_msglevel(struct net_device *net_dev)
{
  u32 __retres;
  
#line 192 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 193 
  __retres = efx->msg_enable;
  
#line 193 
  return __retres;
}


#line 196  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static void efx_ethtool_set_msglevel(struct net_device *net_dev, u32 msg_enable)
{
  
#line 198 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 199 
  efx->msg_enable = msg_enable;
  
#line 200 
  return;
}


#line 215  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static void efx_fill_test(unsigned int test_index, u8 *strings, u64 *data, int *test, char const *unit_format, int unit_id, char const *test_format, char const *test_id)
{
  char unit_str[32U];
  char test_str[32U];
  
#line 222 
  if (data != (u64 *)0ULL) 
#line 223 
                           *(data + test_index) = (unsigned long long)*test; else ;
  
#line 226 
  if (strings != (u8 *)0U) {
    char *tmp;
    
#line 227 
    tmp = strchr(unit_format,37);
    
#line 227 
    if (tmp != (char *)0) 
#line 228 
                          snprintf((char *)(& unit_str),32UL,unit_format,unit_id); else 
                                                                    
#line 231 
                                                                    strcpy((char *)(& unit_str),unit_format);
    
#line 232 
    snprintf((char *)(& test_str),32UL,test_format,test_id);
    
#line 233 
    snprintf((char *)(strings + test_index * 32U),32UL,"%-6s %-24s",(char *)(& unit_str),(char *)(& test_str));
  }
  else ;
  
#line 237 
  return;
}


#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static int efx_fill_loopback_test(struct efx_nic *efx, struct efx_loopback_self_tests *lb_tests, enum efx_loopback_mode mode, unsigned int test_index, u8 *strings, u64 *data)
{
  int __retres;
  struct efx_tx_queue *tx_queue;
  int tmp_6;
  bool tmp_5;
  char const *tmp_7;
  unsigned int tmp_8;
  char const *tmp_9;
  unsigned int tmp_10;
  
#line 263 
  struct efx_channel *channel = efx_get_channel(efx,efx->tx_channel_offset);
  
#line 267 
  tmp_5 = efx_channel_has_tx_queues(channel);
  
#line 267 
  if (tmp_5) 
#line 267 
             tmp_6 = 0; else 
#line 267 
                             tmp_6 = 1;
  
#line 267 
  if (tmp_6) ;
  else {
    char const *tmp_0;
    unsigned int tmp_1;
    char const *tmp_2;
    unsigned int tmp_3;
    
#line 267 
    tx_queue = (struct efx_tx_queue *)(& channel->tx_queue);
    
#line 267 
    goto ldv_55631;
    ldv_55630: 
#line 268 
    ;
    
#line 271 
    if ((unsigned int)mode < efx_loopback_mode_max) 
#line 271 
                                                    tmp_0 = efx_loopback_mode_names[(unsigned int)mode]; else 
                                                                    
#line 271 
                                                                    tmp_0 = "(invalid)";
    
#line 268 
    ;
    
#line 268 
    ;
    
#line 268 
    ;
    
#line 268 
    ;
    
#line 268 
    tmp_1 = test_index;
    
#line 268 
    test_index += 1U;
    
#line 268 
    ;
    
#line 268 
    efx_fill_test(tmp_1,strings,data,& lb_tests->tx_sent[tx_queue->queue],"txq%d",(int)tx_queue->queue,"loopback.%s.",tmp_0);
    
#line 275 
    if ((unsigned int)mode < efx_loopback_mode_max) 
#line 275 
                                                    tmp_2 = efx_loopback_mode_names[(unsigned int)mode]; else 
                                                                    
#line 275 
                                                                    tmp_2 = "(invalid)";
    
#line 272 
    ;
    
#line 272 
    ;
    
#line 272 
    ;
    
#line 272 
    ;
    
#line 272 
    tmp_3 = test_index;
    
#line 272 
    test_index += 1U;
    
#line 272 
    ;
    
#line 272 
    efx_fill_test(tmp_3,strings,data,& lb_tests->tx_done[tx_queue->queue],"txq%d",(int)tx_queue->queue,"loopback.%s.",tmp_2);
    
#line 267 
    tx_queue += 1;
    ldv_55631: 
#line 268 
    ;
    
#line 267 
    if ((struct efx_tx_queue *)(& channel->tx_queue) + 4U > tx_queue) {
      bool tmp_4;
      
#line 267 
      tmp_4 = efx_tx_queue_used(tx_queue);
      
#line 267 
      if ((int)tmp_4 != 0) 
#line 269 
                           goto ldv_55630; else 
#line 272 
                                                goto ldv_55632;
    }
    else 
#line 272 
         goto ldv_55632;
    ldv_55632: 
#line 273 
    ;
  }
  
#line 280 
  if ((unsigned int)mode < efx_loopback_mode_max) 
#line 280 
                                                  tmp_7 = efx_loopback_mode_names[(unsigned int)mode]; else 
                                                                    
#line 280 
                                                                    tmp_7 = "(invalid)";
  
#line 277 
  ;
  
#line 277 
  ;
  
#line 277 
  ;
  
#line 277 
  tmp_8 = test_index;
  
#line 277 
  test_index += 1U;
  
#line 277 
  ;
  
#line 277 
  efx_fill_test(tmp_8,strings,data,& lb_tests->rx_good,"rx",0,"loopback.%s.",tmp_7);
  
#line 284 
  if ((unsigned int)mode < efx_loopback_mode_max) 
#line 284 
                                                  tmp_9 = efx_loopback_mode_names[(unsigned int)mode]; else 
                                                                    
#line 284 
                                                                    tmp_9 = "(invalid)";
  
#line 281 
  ;
  
#line 281 
  ;
  
#line 281 
  ;
  
#line 281 
  tmp_10 = test_index;
  
#line 281 
  test_index += 1U;
  
#line 281 
  ;
  
#line 281 
  efx_fill_test(tmp_10,strings,data,& lb_tests->rx_bad,"rx",0,"loopback.%s.",tmp_9);
  
#line 286 
  __retres = (int)test_index;
  
#line 286 
  return __retres;
}


#line 302  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static int efx_ethtool_fill_self_tests(struct efx_nic *efx, struct efx_self_tests *tests, u8 *strings, u64 *data)
{
  int __retres;
  struct efx_channel *channel;
  unsigned int i;
  enum efx_loopback_mode mode;
  unsigned int tmp;
  unsigned int tmp_0;
  unsigned int tmp_1;
  unsigned int tmp_2;
  unsigned int tmp_3;
  unsigned int tmp_4;
  unsigned int tmp_5;
  int tmp_7;
  
#line 307 
  unsigned int n = 0U;
  
#line 310 
  ;
  
#line 310 
  ;
  
#line 310 
  ;
  
#line 310 
  tmp = n;
  
#line 310 
  n += 1U;
  
#line 310 
  ;
  
#line 310 
  efx_fill_test(tmp,strings,data,& tests->phy_alive,"phy",0,"alive",(char const *)0);
  
#line 312 
  ;
  
#line 312 
  ;
  
#line 312 
  ;
  
#line 312 
  tmp_0 = n;
  
#line 312 
  n += 1U;
  
#line 312 
  ;
  
#line 312 
  efx_fill_test(tmp_0,strings,data,& tests->nvram,"core",0,"nvram",(char const *)0);
  
#line 314 
  ;
  
#line 314 
  ;
  
#line 314 
  ;
  
#line 314 
  tmp_1 = n;
  
#line 314 
  n += 1U;
  
#line 314 
  ;
  
#line 314 
  efx_fill_test(tmp_1,strings,data,& tests->interrupt,"core",0,"interrupt",(char const *)0);
  
#line 318 
  channel = efx->channel[0];
  
#line 318 
  goto ldv_55644;
  ldv_55643: 
#line 319 
  ;
  
#line 319 
  ;
  
#line 319 
  ;
  
#line 319 
  ;
  
#line 319 
  ;
  
#line 319 
  tmp_2 = n;
  
#line 319 
  n += 1U;
  
#line 319 
  ;
  
#line 319 
  efx_fill_test(tmp_2,strings,data,& tests->eventq_dma[channel->channel],"chan%d",channel->channel,"eventq.dma",(char const *)0);
  
#line 323 
  ;
  
#line 323 
  ;
  
#line 323 
  ;
  
#line 323 
  ;
  
#line 323 
  tmp_3 = n;
  
#line 323 
  n += 1U;
  
#line 323 
  ;
  
#line 323 
  efx_fill_test(tmp_3,strings,data,& tests->eventq_int[channel->channel],"chan%d",channel->channel,"eventq.int",(char const *)0);
  
#line 318 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 318 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 318 
                                                                    channel = (struct efx_channel *)0;
  ldv_55644: 
#line 319 
  ;
  
#line 318 
  if (channel != (struct efx_channel *)0) 
#line 320 
                                          goto ldv_55643; else 
#line 323 
                                                               goto ldv_55645;
  ldv_55645: 
#line 324 
  ;
  
#line 329 
  ;
  
#line 329 
  ;
  
#line 329 
  ;
  
#line 329 
  tmp_4 = n;
  
#line 329 
  n += 1U;
  
#line 329 
  ;
  
#line 329 
  efx_fill_test(tmp_4,strings,data,& tests->memory,"core",0,"memory",(char const *)0);
  
#line 331 
  ;
  
#line 331 
  ;
  
#line 331 
  ;
  
#line 331 
  tmp_5 = n;
  
#line 331 
  n += 1U;
  
#line 331 
  ;
  
#line 331 
  efx_fill_test(tmp_5,strings,data,& tests->registers,"core",0,"registers",(char const *)0);
  
#line 334 
  if ((efx->phy_op)->run_tests != (int (*)(struct efx_nic *, int *, unsigned int ))0) {
    
#line 337 
    i = 0U;
    ldv_55648: 
#line 338 
    ;
    {
      char const *name;
      unsigned int tmp_6;
      
#line 341 
      name = (*((efx->phy_op)->test_name))(efx,i);
      
#line 342 
      if (name == (char const *)0) 
#line 343 
                                   goto ldv_55647; else ;
      
#line 345 
      ;
      
#line 345 
      ;
      
#line 345 
      ;
      
#line 345 
      ;
      
#line 345 
      tmp_6 = n;
      
#line 345 
      n += 1U;
      
#line 345 
      ;
      
#line 345 
      efx_fill_test(tmp_6,strings,data,& tests->phy_ext[i],"phy",0,name,(char const *)0);
    }
    
#line 337 
    i += 1U;
    
#line 337 
    goto ldv_55648;
    ldv_55647: 
#line 338 
    ;
  }
  else ;
  
#line 351 
  mode = LOOPBACK_NONE;
  
#line 351 
  goto ldv_55651;
  ldv_55650: 
#line 352 
  ;
  
#line 352 
  if ((efx->loopback_modes & (unsigned long long)(1 << (unsigned int)mode)) == 0ULL) 
    
#line 353 
    goto ldv_55649; else ;
  
#line 354 
  tmp_7 = efx_fill_loopback_test(efx,& tests->loopback[(unsigned int)mode],mode,n,strings,data);
  
#line 354 
  n = (unsigned int)tmp_7;
  ldv_55649: 
#line 356 
  ;
  
#line 351 
  mode += 1U;
  ldv_55651: 
#line 352 
  ;
  
#line 351 
  if (mode <= (unsigned int)LOOPBACK_PMAPMD) 
#line 353 
                                             goto ldv_55650; else 
#line 356 
                                                                  goto ldv_55652;
  ldv_55652: 
#line 357 
  ;
  
#line 359 
  __retres = (int)n;
  
#line 359 
  return __retres;
}


#line 362  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static size_t efx_describe_per_queue_stats(struct efx_nic *efx, u8 *strings)
{
  struct efx_channel *channel;
  bool tmp;
  bool tmp_0;
  
#line 364 
  size_t n_stats = 0UL;
  
#line 367 
  channel = efx->channel[0];
  
#line 367 
  goto ldv_55660;
  ldv_55659: 
#line 368 
  ;
  
#line 368 
  tmp = efx_channel_has_tx_queues(channel);
  
#line 368 
  if ((int)tmp != 0) {
    
#line 369 
    n_stats += 1UL;
    
#line 370 
    if (strings != (u8 *)0U) {
      
#line 371 
      snprintf((char *)strings,32UL,"tx-%u.tx_packets",channel->tx_queue[0].queue / 4U);
      
#line 376 
      strings += 32U;
    }
    else ;
  }
  else ;
  
#line 367 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 367 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 367 
                                                                    channel = (struct efx_channel *)0;
  ldv_55660: 
#line 368 
  ;
  
#line 367 
  if (channel != (struct efx_channel *)0) 
#line 369 
                                          goto ldv_55659; else 
#line 372 
                                                               goto ldv_55661;
  ldv_55661: 
#line 373 
  ;
  
#line 380 
  channel = efx->channel[0];
  
#line 380 
  goto ldv_55663;
  ldv_55662: 
#line 381 
  ;
  
#line 381 
  tmp_0 = efx_channel_has_rx_queue(channel);
  
#line 381 
  if ((int)tmp_0 != 0) {
    
#line 382 
    n_stats += 1UL;
    
#line 383 
    if (strings != (u8 *)0U) {
      
#line 384 
      snprintf((char *)strings,32UL,"rx-%d.rx_packets",channel->channel);
      
#line 386 
      strings += 32U;
    }
    else ;
  }
  else ;
  
#line 380 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 380 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 380 
                                                                    channel = (struct efx_channel *)0;
  ldv_55663: 
#line 381 
  ;
  
#line 380 
  if (channel != (struct efx_channel *)0) 
#line 382 
                                          goto ldv_55662; else 
#line 385 
                                                               goto ldv_55664;
  ldv_55664: 
#line 386 
  ;
  
#line 390 
  return n_stats;
}


#line 393  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static int efx_ethtool_get_sset_count(struct net_device *net_dev, int string_set)
{
  int __retres;
  
#line 396 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 398 
  switch (string_set) {
    size_t tmp_0;
    size_t tmp_1;
    size_t tmp_2;
    int tmp_3;
    case 1: 
#line 399 
    ;
    
#line 402 
    tmp_0 = (*((efx->type)->describe_stats))(efx,(u8 *)0U);
    
#line 401 
    tmp_1 = efx_describe_per_queue_stats(efx,(u8 *)0U);
    
#line 402 
    tmp_2 = efx_ptp_describe_stats(efx,(u8 *)0U);
    
#line 402 
    __retres = (int)(((tmp_0 + tmp_1) + tmp_2) + (size_t)14U);
    
#line 402 
    goto return_label;
    case 0: 
#line 404 
    ;
    
#line 405 
    tmp_3 = efx_ethtool_fill_self_tests(efx,(struct efx_self_tests *)0,(u8 *)0U,(u64 *)0ULL);
    
#line 405 
    __retres = tmp_3;
    
#line 405 
    goto return_label;
    default: 
#line 406 
    ;
    
#line 407 
    __retres = -22;
    
#line 407 
    goto return_label;
  }
  return_label: 
#line 398 
                return __retres;
}


#line 411  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static void efx_ethtool_get_strings(struct net_device *net_dev, u32 string_set, u8 *strings)
{
  int i;
  
#line 414 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 417 
  switch (string_set) {
    size_t tmp_0;
    size_t tmp_1;
    case (u32)1: 
#line 418 
    ;
    
#line 419 
    tmp_0 = (*((efx->type)->describe_stats))(efx,strings);
    
#line 420 
    strings += tmp_0 * 32UL;
    
#line 421 
    i = 0;
    
#line 421 
    goto ldv_55688;
    ldv_55687: 
#line 422 
    ;
    
#line 422 
    strlcpy((char *)(strings + i * 32),efx_sw_stat_desc[i].name,32UL);
    
#line 421 
    i += 1;
    ldv_55688: 
#line 422 
    ;
    
#line 421 
    if ((unsigned int)i <= 13U) 
#line 423 
                                goto ldv_55687; else 
#line 426 
                                                     goto ldv_55689;
    ldv_55689: 
#line 427 
    ;
    
#line 424 
    strings += 448U;
    
#line 425 
    tmp_1 = efx_describe_per_queue_stats(efx,strings);
    
#line 426 
    strings += tmp_1 * 32UL;
    
#line 427 
    efx_ptp_describe_stats(efx,strings);
    
#line 428 
    goto ldv_55693;
    case (u32)0: 
#line 429 
    ;
    
#line 430 
    efx_ethtool_fill_self_tests(efx,(struct efx_self_tests *)0,strings,(u64 *)0ULL);
    
#line 431 
    goto ldv_55693;
    default: 
#line 432 
    ;
    
#line 434 
    goto ldv_55693;
  }
  ldv_55693: 
#line 436 
  ;
  
#line 437 
  return;
}


#line 438  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static void efx_ethtool_get_stats(struct net_device *net_dev, struct ethtool_stats *stats, u64 *data)
{
  struct efx_sw_stat_desc const *stat;
  struct efx_channel *channel;
  struct efx_tx_queue *tx_queue;
  struct efx_rx_queue *rx_queue;
  int i;
  size_t tmp_0;
  bool tmp_9;
  bool tmp_12;
  
#line 442 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 449 
  ldv_spin_lock_bh_91(& efx->stats_lock);
  
#line 452 
  tmp_0 = (*((efx->type)->update_stats))(efx,data,(struct rtnl_link_stats64 *)0);
  
#line 452 
  data += tmp_0;
  
#line 455 
  i = 0;
  
#line 455 
  goto ldv_55724;
  ldv_55723: 
#line 456 
  ;
  
#line 456 
  stat = & efx_sw_stat_desc[i];
  
#line 457 
  switch ((unsigned int)stat->source) {
    u64 tmp_1;
    int tmp_5;
    bool tmp_4;
    case (unsigned int)0: 
#line 458 
    ;
    
#line 459 
    *(data + i) = (*(stat->get_stat))((void *)efx + stat->offset);
    
#line 460 
    goto ldv_55711;
    case (unsigned int)1: 
#line 461 
    ;
    
#line 462 
    *(data + i) = 0ULL;
    
#line 463 
    channel = efx->channel[0];
    
#line 463 
    goto ldv_55714;
    ldv_55713: 
#line 464 
    ;
    
#line 464 
    tmp_1 = (*(stat->get_stat))((void *)channel + stat->offset);
    
#line 465 
    *(data + i) += tmp_1;
    
#line 463 
    if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 463 
                                                                channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 463 
                                                                    channel = (struct efx_channel *)0;
    ldv_55714: 
#line 464 
    ;
    
#line 463 
    if (channel != (struct efx_channel *)0) 
#line 465 
                                            goto ldv_55713; else 
#line 468 
                                                                 goto ldv_55715;
    ldv_55715: 
#line 469 
    ;
    
#line 466 
    goto ldv_55711;
    case (unsigned int)2: 
#line 467 
    ;
    
#line 468 
    *(data + i) = 0ULL;
    
#line 469 
    channel = efx->channel[0];
    
#line 469 
    goto ldv_55721;
    ldv_55720: 
#line 470 
    ;
    
#line 470 
    tmp_4 = efx_channel_has_tx_queues(channel);
    
#line 470 
    if (tmp_4) 
#line 470 
               tmp_5 = 0; else 
#line 470 
                               tmp_5 = 1;
    
#line 470 
    if (tmp_5) ;
    else {
      u64 tmp_2;
      
#line 470 
      tx_queue = (struct efx_tx_queue *)(& channel->tx_queue);
      
#line 470 
      goto ldv_55718;
      ldv_55717: 
#line 471 
      ;
      
#line 471 
      tmp_2 = (*(stat->get_stat))((void *)tx_queue + stat->offset);
      
#line 473 
      *(data + i) += tmp_2;
      
#line 470 
      tx_queue += 1;
      ldv_55718: 
#line 471 
      ;
      
#line 470 
      if ((struct efx_tx_queue *)(& channel->tx_queue) + 4U > tx_queue) {
        bool tmp_3;
        
#line 470 
        tmp_3 = efx_tx_queue_used(tx_queue);
        
#line 470 
        if ((int)tmp_3 != 0) 
#line 472 
                             goto ldv_55717; else 
#line 475 
                                                  goto ldv_55719;
      }
      else 
#line 475 
           goto ldv_55719;
      ldv_55719: 
#line 476 
      ;
    }
    
#line 469 
    if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 469 
                                                                channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 469 
                                                                    channel = (struct efx_channel *)0;
    ldv_55721: 
#line 470 
    ;
    
#line 469 
    if (channel != (struct efx_channel *)0) 
#line 471 
                                            goto ldv_55720; else 
#line 474 
                                                                 goto ldv_55722;
    ldv_55722: 
#line 475 
    ;
    
#line 475 
    goto ldv_55711;
  }
  ldv_55711: 
#line 477 
  ;
  
#line 455 
  i += 1;
  ldv_55724: 
#line 456 
  ;
  
#line 455 
  if ((unsigned int)i <= 13U) 
#line 457 
                              goto ldv_55723; else 
#line 460 
                                                   goto ldv_55725;
  ldv_55725: 
#line 461 
  ;
  
#line 478 
  data += 14U;
  
#line 480 
  ldv_spin_unlock_bh_92(& efx->stats_lock);
  
#line 482 
  channel = efx->channel[0];
  
#line 482 
  goto ldv_55733;
  ldv_55732: 
#line 483 
  ;
  
#line 483 
  tmp_9 = efx_channel_has_tx_queues(channel);
  
#line 483 
  if ((int)tmp_9 != 0) {
    int tmp_8;
    bool tmp_7;
    
#line 484 
    *data = 0ULL;
    
#line 485 
    tmp_7 = efx_channel_has_tx_queues(channel);
    
#line 485 
    if (tmp_7) 
#line 485 
               tmp_8 = 0; else 
#line 485 
                               tmp_8 = 1;
    
#line 485 
    if (tmp_8) ;
    else {
      
#line 485 
      tx_queue = (struct efx_tx_queue *)(& channel->tx_queue);
      
#line 485 
      goto ldv_55730;
      ldv_55729: 
#line 486 
      ;
      
#line 486 
      *data += (unsigned long long)tx_queue->tx_packets;
      
#line 485 
      tx_queue += 1;
      ldv_55730: 
#line 486 
      ;
      
#line 485 
      if ((struct efx_tx_queue *)(& channel->tx_queue) + 4U > tx_queue) {
        bool tmp_6;
        
#line 485 
        tmp_6 = efx_tx_queue_used(tx_queue);
        
#line 485 
        if ((int)tmp_6 != 0) 
#line 487 
                             goto ldv_55729; else 
#line 490 
                                                  goto ldv_55731;
      }
      else 
#line 490 
           goto ldv_55731;
      ldv_55731: 
#line 491 
      ;
    }
    
#line 488 
    data += 1;
  }
  else ;
  
#line 482 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 482 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 482 
                                                                    channel = (struct efx_channel *)0;
  ldv_55733: 
#line 483 
  ;
  
#line 482 
  if (channel != (struct efx_channel *)0) 
#line 484 
                                          goto ldv_55732; else 
#line 487 
                                                               goto ldv_55734;
  ldv_55734: 
#line 488 
  ;
  
#line 491 
  channel = efx->channel[0];
  
#line 491 
  goto ldv_55739;
  ldv_55738: 
#line 492 
  ;
  
#line 492 
  tmp_12 = efx_channel_has_rx_queue(channel);
  
#line 492 
  if ((int)tmp_12 != 0) {
    int tmp_11;
    bool tmp_10;
    
#line 493 
    *data = 0ULL;
    
#line 494 
    tmp_10 = efx_channel_has_rx_queue(channel);
    
#line 494 
    if (tmp_10) 
#line 494 
                tmp_11 = 0; else 
#line 494 
                                 tmp_11 = 1;
    
#line 494 
    if (tmp_11) ;
    else {
      
#line 494 
      rx_queue = & channel->rx_queue;
      
#line 494 
      goto ldv_55736;
      ldv_55735: 
#line 495 
      ;
      
#line 495 
      *data += (unsigned long long)rx_queue->rx_packets;
      
#line 494 
      rx_queue = (struct efx_rx_queue *)0;
      ldv_55736: 
#line 495 
      ;
      
#line 494 
      if (rx_queue != (struct efx_rx_queue *)0) 
#line 496 
                                                goto ldv_55735; else 
                                                                  
#line 499 
                                                                  goto ldv_55737;
      ldv_55737: 
#line 500 
      ;
    }
    
#line 497 
    data += 1;
  }
  else ;
  
#line 491 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 491 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 491 
                                                                    channel = (struct efx_channel *)0;
  ldv_55739: 
#line 492 
  ;
  
#line 491 
  if (channel != (struct efx_channel *)0) 
#line 493 
                                          goto ldv_55738; else 
#line 496 
                                                               goto ldv_55740;
  ldv_55740: 
#line 497 
  ;
  
#line 501 
  efx_ptp_update_stats(efx,data);
  
#line 502 
  return;
}


#line 504  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static void efx_ethtool_self_test(struct net_device *net_dev, struct ethtool_test *test, u64 *data)
{
  struct efx_self_tests *efx_tests;
  bool already_up;
  
#line 507 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 510 
  int rc = -12;
  
#line 512 
  efx_tests = (struct efx_self_tests *)kzalloc_4(1076UL,208U);
  
#line 513 
  if (efx_tests == (struct efx_self_tests *)0) 
#line 514 
                                               goto fail; else ;
  
#line 516 
  if (efx->state != (unsigned int)STATE_READY) {
    
#line 517 
    rc = -16;
    
#line 518 
    goto out;
  }
  else ;
  
#line 521 
  if ((efx->msg_enable & 1U) != 0U) {
    char *tmp_1;
    
#line 521 
    if ((test->flags & 1U) != 0U) 
#line 521 
                                  tmp_1 = (char *)"off"; else 
#line 521 
                                                              tmp_1 = (char *)"on";
    
#line 521 
    ;
    
#line 521 
    netdev_info((struct net_device const *)efx->net_dev,"starting %sline testing\n",tmp_1);
  }
  else ;
  
#line 525 
  already_up = (_Bool)(((efx->net_dev)->flags & 1U) != 0U);
  
#line 526 
  if (! already_up) {
    
#line 527 
    rc = dev_open(efx->net_dev);
    
#line 528 
    if (rc != 0) {
      
#line 529 
      if ((efx->msg_enable & 1U) != 0U) 
#line 529 
                                        netdev_err((struct net_device const *)efx->net_dev,"failed opening device.\n"); else ;
      
#line 531 
      goto out;
    }
    else ;
  }
  else ;
  
#line 535 
  rc = efx_selftest(efx,efx_tests,test->flags);
  
#line 537 
  if (! already_up) 
#line 538 
                    dev_close(efx->net_dev); else ;
  
#line 540 
  if ((efx->msg_enable & 1U) != 0U) {
    char *tmp_2;
    char *tmp_3;
    
#line 540 
    if ((test->flags & 1U) != 0U) 
#line 540 
                                  tmp_2 = (char *)"off"; else 
#line 540 
                                                              tmp_2 = (char *)"on";
    
#line 540 
    if (rc == 0) 
#line 540 
                 tmp_3 = (char *)"passed"; else 
#line 540 
                                                tmp_3 = (char *)"failed";
    
#line 540 
    ;
    
#line 540 
    netdev_info((struct net_device const *)efx->net_dev,"%s %sline self-tests\n",tmp_3,tmp_2);
  }
  else ;
  out: 
#line 544 
  ;
  
#line 545 
  efx_ethtool_fill_self_tests(efx,efx_tests,(u8 *)0U,data);
  
#line 546 
  kfree((void const *)efx_tests);
  fail: 
#line 547 
  ;
  
#line 548 
  if (rc != 0) 
#line 549 
               test->flags |= 2U; else ;
  
#line 550 
  return;
}


#line 553  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static int efx_ethtool_nway_reset(struct net_device *net_dev)
{
  int tmp_0;
  
#line 555 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 557 
  tmp_0 = mdio45_nway_restart((struct mdio_if_info const *)(& efx->mdio));
  
#line 557 
  return tmp_0;
}


#line 589  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static int efx_ethtool_get_coalesce(struct net_device *net_dev, struct ethtool_coalesce *coalesce)
{
  int __retres;
  unsigned int tx_usecs;
  unsigned int rx_usecs;
  bool rx_adaptive;
  
#line 592 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 596 
  efx_get_irq_moderation(efx,& tx_usecs,& rx_usecs,& rx_adaptive);
  
#line 598 
  coalesce->tx_coalesce_usecs = tx_usecs;
  
#line 599 
  coalesce->tx_coalesce_usecs_irq = tx_usecs;
  
#line 600 
  coalesce->rx_coalesce_usecs = rx_usecs;
  
#line 601 
  coalesce->rx_coalesce_usecs_irq = rx_usecs;
  
#line 602 
  coalesce->use_adaptive_rx_coalesce = (unsigned int)rx_adaptive;
  
#line 604 
  __retres = 0;
  
#line 604 
  return __retres;
}


#line 607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static int efx_ethtool_set_coalesce(struct net_device *net_dev, struct ethtool_coalesce *coalesce)
{
  int __retres;
  struct efx_channel *channel;
  unsigned int tx_usecs;
  unsigned int rx_usecs;
  bool adaptive;
  bool rx_may_override_tx;
  int rc;
  
#line 610 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 616 
  if (coalesce->use_adaptive_tx_coalesce != 0U) {
    
#line 617 
    __retres = -22;
    
#line 617 
    goto return_label;
  }
  else ;
  
#line 619 
  efx_get_irq_moderation(efx,& tx_usecs,& rx_usecs,& adaptive);
  
#line 621 
  if (coalesce->rx_coalesce_usecs != rx_usecs) 
#line 622 
                                               rx_usecs = coalesce->rx_coalesce_usecs; else 
                                                                    
#line 624 
                                                                    rx_usecs = coalesce->rx_coalesce_usecs_irq;
  
#line 626 
  adaptive = (_Bool)(coalesce->use_adaptive_rx_coalesce != 0U);
  
#line 631 
  rx_may_override_tx = (_Bool)((coalesce->tx_coalesce_usecs == tx_usecs && coalesce->tx_coalesce_usecs_irq == tx_usecs) != 0);
  
#line 633 
  if (coalesce->tx_coalesce_usecs != tx_usecs) 
#line 634 
                                               tx_usecs = coalesce->tx_coalesce_usecs; else 
                                                                    
#line 636 
                                                                    tx_usecs = coalesce->tx_coalesce_usecs_irq;
  
#line 638 
  rc = efx_init_irq_moderation(efx,tx_usecs,rx_usecs,(_Bool)((bool)((int)adaptive) != 0),(_Bool)((bool)((int)rx_may_override_tx) != 0));
  
#line 640 
  if (rc != 0) {
    
#line 641 
    __retres = rc;
    
#line 641 
    goto return_label;
  }
  else ;
  
#line 643 
  channel = efx->channel[0];
  
#line 643 
  goto ldv_55776;
  ldv_55775: 
#line 644 
  ;
  
#line 644 
  (*((efx->type)->push_irq_moderation))(channel);
  
#line 643 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 643 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 643 
                                                                    channel = (struct efx_channel *)0;
  ldv_55776: 
#line 644 
  ;
  
#line 643 
  if (channel != (struct efx_channel *)0) 
#line 645 
                                          goto ldv_55775; else 
#line 648 
                                                               goto ldv_55777;
  ldv_55777: 
#line 649 
  ;
  
#line 646 
  __retres = 0;
  return_label: 
#line 646 
                return __retres;
}


#line 649  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static void efx_ethtool_get_ringparam(struct net_device *net_dev, struct ethtool_ringparam *ring)
{
  int tmp_0;
  
#line 652 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 654 
  ring->rx_max_pending = 4096U;
  
#line 655 
  tmp_0 = efx_nic_rev(efx);
  
#line 655 
  if (tmp_0 == 4) 
    
#line 655 
    if ((int)((struct efx_ef10_nic_data *)efx->nic_data)->workaround_35388 != 0) 
      
#line 655 
      ring->tx_max_pending = 2048U; else 
#line 655 
                                         ring->tx_max_pending = 4096U;
  else 
#line 655 
       ring->tx_max_pending = 4096U;
  
#line 656 
  ring->rx_pending = efx->rxq_entries;
  
#line 657 
  ring->tx_pending = efx->txq_entries;
  
#line 658 
  return;
}


#line 660  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static int efx_ethtool_set_ringparam(struct net_device *net_dev, struct ethtool_ringparam *ring)
{
  int __retres;
  u32 txq_entries;
  unsigned int tmp_4;
  int tmp_5;
  
#line 663 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 666 
  if ((ring->rx_mini_pending != 0U || ring->rx_jumbo_pending != 0U) || ring->rx_pending > 4096U) {
    
#line 669 
    __retres = -22;
    
#line 669 
    goto return_label;
  }
  else {
    unsigned long tmp_1;
    int tmp_0;
    
#line 668 
    tmp_0 = efx_nic_rev(efx);
    
#line 668 
    if (tmp_0 == 4) 
      
#line 668 
      if ((int)((struct efx_ef10_nic_data *)efx->nic_data)->workaround_35388 != 0) 
        
#line 668 
        tmp_1 = 2048UL; else 
#line 668 
                             tmp_1 = 4096UL;
    else 
#line 668 
         tmp_1 = 4096UL;
    
#line 668 
    ;
    
#line 668 
    if ((unsigned long)ring->tx_pending > tmp_1) {
      
#line 669 
      __retres = -22;
      
#line 669 
      goto return_label;
    }
    else ;
  }
  
#line 671 
  if (ring->rx_pending <= 127U) {
    
#line 672 
    if ((efx->msg_enable & 1U) != 0U) 
#line 672 
                                      netdev_err((struct net_device const *)efx->net_dev,"RX queues cannot be smaller than %u\n",128U); else ;
    
#line 675 
    __retres = -22;
    
#line 675 
    goto return_label;
  }
  else ;
  {
    unsigned int tmp_2;
    __u32 tmp_3;
    
#line 678 
    __u32 _max1 = ring->tx_pending;
    
#line 678 
    tmp_2 = efx_tx_max_skb_descs(efx);
    
#line 678 
    unsigned int _max2 = tmp_2 * 2U;
    
#line 678 
    if (_max1 > _max2) 
#line 678 
                       tmp_3 = _max1; else 
#line 678 
                                           tmp_3 = _max2;
    
#line 678 
    tmp_4 = tmp_3;
  }
  
#line 678 
  txq_entries = tmp_4;
  
#line 679 
  if (ring->tx_pending != txq_entries) {
    
#line 680 
    if ((efx->msg_enable & 1U) != 0U) 
#line 680 
                                      netdev_warn((struct net_device const *)efx->net_dev,"increasing TX queue size to minimum of %u\n",txq_entries); else ;
  }
  else ;
  
#line 684 
  tmp_5 = efx_realloc_channels(efx,ring->rx_pending,txq_entries);
  
#line 684 
  __retres = tmp_5;
  return_label: 
#line 684 
                return __retres;
}


#line 687  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static int efx_ethtool_set_pauseparam(struct net_device *net_dev, struct ethtool_pauseparam *pause)
{
  u8 wanted_fc;
  u8 old_fc;
  u32 old_adv;
  int tmp_0;
  int tmp_1;
  
#line 690 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 693 
  int rc = 0;
  
#line 695 
  ldv_mutex_lock_93_0(& efx->mac_lock);
  
#line 698 
  if (pause->rx_pause != 0U) 
#line 698 
                             tmp_0 = 2; else 
#line 698 
                                             tmp_0 = 0;
  
#line 698 
  if (pause->autoneg != 0U) 
#line 698 
                            tmp_1 = 4; else 
#line 698 
                                            tmp_1 = 0;
  
#line 697 
  wanted_fc = (unsigned char)((tmp_0 | (pause->tx_pause != 0U)) | tmp_1);
  
#line 701 
  if (((int)wanted_fc & 1) != 0 && ((int)wanted_fc & 2) == 0) {
    
#line 702 
    if ((efx->msg_enable & 1U) != 0U) {
      
#line 702 
      struct _ddebug descriptor = {.modname = "sfc", .function = "efx_ethtool_set_pauseparam", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c", .format = "Flow control unsupported: tx ON rx OFF\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))703U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 702 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 702 
                                                          __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"Flow control unsupported: tx ON rx OFF\n"); else ;
    }
    else ;
    
#line 704 
    rc = -22;
    
#line 705 
    goto out;
  }
  else ;
  
#line 708 
  if (((int)wanted_fc & 4) != 0 && efx->link_advertising == 0U) {
    
#line 709 
    if ((efx->msg_enable & 1U) != 0U) {
      
#line 709 
      struct _ddebug descriptor_0 = {.modname = "sfc", .function = "efx_ethtool_set_pauseparam", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c", .format = "Autonegotiation is disabled\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))710U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 709 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 709 
                                                            __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)efx->net_dev,"Autonegotiation is disabled\n"); else ;
    }
    else ;
    
#line 711 
    rc = -22;
    
#line 712 
    goto out;
  }
  else ;
  
#line 716 
  if (((efx->type)->prepare_enable_fc_tx != (void (*)(struct efx_nic *))0 && ((int)wanted_fc & 1) != 0) && ((int)efx->wanted_fc & 1) == 0) 
    
#line 718 
    (*((efx->type)->prepare_enable_fc_tx))(efx); else ;
  
#line 720 
  old_adv = efx->link_advertising;
  
#line 721 
  old_fc = efx->wanted_fc;
  
#line 722 
  efx_link_set_wanted_fc(efx,(unsigned char)((int)wanted_fc));
  
#line 723 
  if (efx->link_advertising != old_adv || (((int)efx->wanted_fc ^ (int)old_fc) & 4) != 0) {
    
#line 725 
    rc = (*((efx->phy_op)->reconfigure))(efx);
    
#line 726 
    if (rc != 0) {
      
#line 727 
      if ((efx->msg_enable & 1U) != 0U) 
#line 727 
                                        netdev_err((struct net_device const *)efx->net_dev,"Unable to advertise requested flow "); else ;
      
#line 730 
      goto out;
    }
    else ;
  }
  else ;
  
#line 737 
  efx_mac_reconfigure(efx);
  out: 
#line 739 
  ;
  
#line 740 
  ldv_mutex_unlock_94_0(& efx->mac_lock);
  
#line 742 
  return rc;
}


#line 745  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static void efx_ethtool_get_pauseparam(struct net_device *net_dev, struct ethtool_pauseparam *pause)
{
  
#line 748 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 750 
  pause->rx_pause = (unsigned int)(((int)efx->wanted_fc & 2) != 0);
  
#line 751 
  pause->tx_pause = (unsigned int)(((int)efx->wanted_fc & 1) != 0);
  
#line 752 
  pause->autoneg = (unsigned int)(((int)efx->wanted_fc & 4) != 0);
  
#line 753 
  return;
}


#line 755  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static void efx_ethtool_get_wol(struct net_device *net_dev, struct ethtool_wolinfo *wol)
{
  
#line 758 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 759 
  (*((efx->type)->get_wol))(efx,wol);
  
#line 760 
  return;
}


#line 763  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static int efx_ethtool_set_wol(struct net_device *net_dev, struct ethtool_wolinfo *wol)
{
  int tmp_0;
  
#line 766 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 767 
  tmp_0 = (*((efx->type)->set_wol))(efx,wol->wolopts);
  
#line 767 
  return tmp_0;
}


#line 770  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static int efx_ethtool_reset(struct net_device *net_dev, u32 *flags)
{
  int __retres;
  int rc;
  int tmp_0;
  
#line 772 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 775 
  rc = (*((efx->type)->map_reset_flags))(flags);
  
#line 776 
  if (rc < 0) {
    
#line 777 
    __retres = rc;
    
#line 777 
    goto return_label;
  }
  else ;
  
#line 779 
  tmp_0 = efx_reset(efx,(enum reset_type)rc);
  
#line 779 
  __retres = tmp_0;
  return_label: 
#line 779 
                return __retres;
}


#line 783  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static u8 const mac_addr_ig_mask[6U] = {(unsigned char)1U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U};

#line 789  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static int efx_ethtool_get_class_rule(struct efx_nic *efx, struct ethtool_rx_flow_spec *rule)
{
  int __retres;
  struct efx_filter_spec spec;
  int rc;
  
#line 792 
  struct ethtool_tcpip4_spec *ip_entry = & rule->h_u.tcp_ip4_spec;
  
#line 793 
  struct ethtool_tcpip4_spec *ip_mask = & rule->m_u.tcp_ip4_spec;
  
#line 794 
  struct ethhdr *mac_entry = & rule->h_u.ether_spec;
  
#line 795 
  struct ethhdr *mac_mask = & rule->m_u.ether_spec;
  
#line 799 
  rc = efx_filter_get_filter_safe(efx,(enum efx_filter_priority)EFX_FILTER_PRI_MANUAL,rule->location,& spec);
  
#line 801 
  if (rc != 0) {
    
#line 802 
    __retres = rc;
    
#line 802 
    goto return_label;
  }
  else ;
  
#line 804 
  if ((unsigned int)*((unsigned short *)(& spec) + 1UL) == 65520U) 
#line 805 
                                                                   rule->ring_cookie = 18446744073709551615ULL; else 
                                                                    
#line 807 
                                                                    rule->ring_cookie = (unsigned long long)spec.dmaq_id;
  
#line 809 
  if ((((((int)spec.match_flags & 64) != 0 && (unsigned int)spec.ether_type == 8U) && ((int)spec.match_flags & 512) != 0) && ((unsigned int)spec.ip_proto == 6U || (unsigned int)spec.ip_proto == 17U)) && ((int)spec.match_flags & -876) == 0) {
    int tmp;
    
#line 819 
    if ((unsigned int)spec.ip_proto == 6U) 
#line 819 
                                           tmp = 1; else 
#line 819 
                                                         tmp = 2;
    
#line 818 
    rule->flow_type = (unsigned int)tmp;
    
#line 820 
    if (((int)spec.match_flags & 2) != 0) {
      
#line 821 
      ip_entry->ip4dst = spec.loc_host[0];
      
#line 822 
      ip_mask->ip4dst = 4294967295U;
    }
    else ;
    
#line 824 
    if (((int)spec.match_flags & 1) != 0) {
      
#line 825 
      ip_entry->ip4src = spec.rem_host[0];
      
#line 826 
      ip_mask->ip4src = 4294967295U;
    }
    else ;
    
#line 828 
    if (((int)spec.match_flags & 32) != 0) {
      
#line 829 
      ip_entry->pdst = spec.loc_port;
      
#line 830 
      ip_mask->pdst = (unsigned short)65535U;
    }
    else ;
    
#line 832 
    if (((int)spec.match_flags & 8) != 0) {
      
#line 833 
      ip_entry->psrc = spec.rem_port;
      
#line 834 
      ip_mask->psrc = (unsigned short)65535U;
    }
    else ;
  }
  else 
    
#line 836 
    if (((int)spec.match_flags & -1365) == 0) {
      
#line 840 
      rule->flow_type = 18U;
      
#line 841 
      if (((int)spec.match_flags & 1040) != 0) {
        
#line 843 
        ether_addr_copy((u8 *)(& mac_entry->h_dest),(u8 const *)(& spec.loc_mac));
        
#line 844 
        if (((int)spec.match_flags & 16) != 0) 
#line 845 
                                               eth_broadcast_addr((u8 *)(& mac_mask->h_dest)); else 
                                                                    
#line 847 
                                                                    ether_addr_copy((u8 *)(& mac_mask->h_dest),(u8 const *)(& mac_addr_ig_mask));
      }
      else ;
      
#line 850 
      if (((int)spec.match_flags & 4) != 0) {
        
#line 851 
        ether_addr_copy((u8 *)(& mac_entry->h_source),(u8 const *)(& spec.rem_mac));
        
#line 852 
        eth_broadcast_addr((u8 *)(& mac_mask->h_source));
      }
      else ;
      
#line 854 
      if (((int)spec.match_flags & 64) != 0) {
        
#line 855 
        mac_entry->h_proto = spec.ether_type;
        
#line 856 
        mac_mask->h_proto = (unsigned short)65535U;
      }
      else ;
    }
    else {
      {
        
#line 860 
        int __ret_warn_on = 1;
        
#line 860 
        if ((long)(__ret_warn_on != 0) != 0L) 
#line 860 
                                              warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c",860); else ;
        
#line 860 
        long tmp_2 = (long)(__ret_warn_on != 0);
      }
      
#line 861 
      __retres = -22;
      
#line 861 
      goto return_label;
    }
  
#line 864 
  if (((int)spec.match_flags & 256) != 0) {
    
#line 865 
    rule->flow_type |= 2147483648U;
    
#line 866 
    rule->h_ext.vlan_tci = spec.outer_vid;
    
#line 867 
    rule->m_ext.vlan_tci = (unsigned short)65295U;
  }
  else ;
  
#line 870 
  __retres = rc;
  return_label: 
#line 870 
                return __retres;
}


#line 874  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static int efx_ethtool_get_rxnfc(struct net_device *net_dev, struct ethtool_rxnfc *info, u32 *rule_locs)
{
  int __retres;
  
#line 877 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 879 
  switch (info->cmd) {
    u32 tmp_1;
    u32 tmp_2;
    int tmp_3;
    case (__u32)45: 
#line 880 
    ;
    
#line 881 
    info->data = (unsigned long long)efx->n_rx_channels;
    
#line 882 
    __retres = 0;
    
#line 882 
    goto return_label;
    case (__u32)41: 
#line 884 
    ;
    {
      int tmp_0;
      
#line 885 
      unsigned int min_revision = 0U;
      
#line 887 
      info->data = 0ULL;
      
#line 888 
      switch (info->flow_type) {
        case (__u32)1: 
#line 889 
        ;
        
#line 890 
        info->data |= 192ULL;
        case (__u32)2: 
#line 892 
        ;
        case (__u32)3: 
#line 893 
        ;
        case (__u32)4: 
#line 894 
        ;
        case (__u32)16: 
#line 895 
        ;
        
#line 896 
        info->data |= 48ULL;
        
#line 897 
        min_revision = 2U;
        
#line 898 
        goto ldv_55853;
        case (__u32)5: 
#line 899 
        ;
        
#line 900 
        info->data |= 192ULL;
        case (__u32)6: 
#line 902 
        ;
        case (__u32)7: 
#line 903 
        ;
        case (__u32)8: 
#line 904 
        ;
        case (__u32)17: 
#line 905 
        ;
        
#line 906 
        info->data |= 48ULL;
        
#line 907 
        min_revision = 3U;
        
#line 908 
        goto ldv_55853;
        default: 
#line 909 
        ;
        
#line 910 
        goto ldv_55853;
      }
      ldv_55853: 
#line 912 
      ;
      
#line 912 
      tmp_0 = efx_nic_rev(efx);
      
#line 912 
      ;
      
#line 912 
      if ((unsigned int)tmp_0 < min_revision) 
#line 913 
                                              info->data = 0ULL; else ;
      
#line 914 
      __retres = 0;
      
#line 914 
      goto return_label;
    }
    case (__u32)46: 
#line 917 
    ;
    
#line 918 
    tmp_1 = efx_filter_get_rx_id_limit(efx);
    
#line 918 
    info->data = (unsigned long long)tmp_1;
    
#line 919 
    if (info->data == 0ULL) {
      
#line 920 
      __retres = -95;
      
#line 920 
      goto return_label;
    }
    else ;
    
#line 921 
    info->data |= 2147483648ULL;
    
#line 922 
    info->rule_cnt = efx_filter_count_rx_used(efx,(enum efx_filter_priority)EFX_FILTER_PRI_MANUAL);
    
#line 924 
    __retres = 0;
    
#line 924 
    goto return_label;
    case (__u32)47: 
#line 926 
    ;
    
#line 927 
    tmp_2 = efx_filter_get_rx_id_limit(efx);
    
#line 927 
    if (tmp_2 == 0U) {
      
#line 928 
      __retres = -95;
      
#line 928 
      goto return_label;
    }
    else ;
    
#line 929 
    tmp_3 = efx_ethtool_get_class_rule(efx,& info->fs);
    
#line 929 
    __retres = tmp_3;
    
#line 929 
    goto return_label;
    case (__u32)48: 
#line 931 
    ;
    {
      s32 rc;
      u32 tmp_4;
      
#line 933 
      tmp_4 = efx_filter_get_rx_id_limit(efx);
      
#line 933 
      info->data = (unsigned long long)tmp_4;
      
#line 934 
      if (info->data == 0ULL) {
        
#line 935 
        __retres = -95;
        
#line 935 
        goto return_label;
      }
      else ;
      
#line 936 
      rc = efx_filter_get_rx_ids(efx,(enum efx_filter_priority)EFX_FILTER_PRI_MANUAL,rule_locs,info->rule_cnt);
      
#line 938 
      if (rc < 0) {
        
#line 939 
        __retres = rc;
        
#line 939 
        goto return_label;
      }
      else ;
      
#line 940 
      info->rule_cnt = (unsigned int)rc;
      
#line 941 
      __retres = 0;
      
#line 941 
      goto return_label;
    }
    default: 
#line 944 
    ;
    
#line 945 
    __retres = -95;
    
#line 945 
    goto return_label;
  }
  return_label: 
#line 879 
                return __retres;
}


#line 949  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static int efx_ethtool_set_class_rule(struct efx_nic *efx, struct ethtool_rx_flow_spec *rule)
{
  int __retres;
  struct efx_filter_spec spec;
  int rc;
  unsigned int tmp;
  int tmp_0;
  
#line 952 
  struct ethtool_tcpip4_spec *ip_entry = & rule->h_u.tcp_ip4_spec;
  
#line 953 
  struct ethtool_tcpip4_spec *ip_mask = & rule->m_u.tcp_ip4_spec;
  
#line 954 
  struct ethhdr *mac_entry = & rule->h_u.ether_spec;
  
#line 955 
  struct ethhdr *mac_mask = & rule->m_u.ether_spec;
  
#line 960 
  if (rule->location != 4294967295U) {
    
#line 961 
    __retres = -22;
    
#line 961 
    goto return_label;
  }
  else ;
  
#line 964 
  if (rule->ring_cookie >= (unsigned long long)efx->n_rx_channels && rule->ring_cookie != 18446744073709551615ULL) {
    
#line 966 
    __retres = -22;
    
#line 966 
    goto return_label;
  }
  else ;
  
#line 969 
  if (rule->flow_type < (__u32)0 && (((unsigned int)rule->m_ext.vlan_etype != 0U || rule->m_ext.data[0] != 0U) || rule->m_ext.data[1] != 0U)) {
    
#line 972 
    __retres = -22;
    
#line 972 
    goto return_label;
  }
  else ;
  
#line 975 
  if (rule->ring_cookie != 18446744073709551615ULL) 
#line 975 
                                                    tmp = (unsigned int)rule->ring_cookie; else 
                                                                    
#line 975 
                                                                    tmp = 4095U;
  
#line 975 
  if ((int)efx->rx_scatter != 0) 
#line 975 
                                 tmp_0 = 2; else 
#line 975 
                                                 tmp_0 = 0;
  
#line 974 
  efx_filter_init_rx(& spec,(enum efx_filter_priority)EFX_FILTER_PRI_MANUAL,(enum efx_filter_flags)tmp_0,tmp);
  
#line 979 
  switch (rule->flow_type & 2147483647U) {
    int tmp_4;
    bool tmp_3;
    int tmp_8;
    bool tmp_7;
    case (unsigned int)1: 
#line 980 
    ;
    case (unsigned int)2: 
#line 981 
    ;
    
#line 982 
    spec.match_flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))))576U;
    
#line 984 
    spec.ether_type = (unsigned short)8U;
    
#line 985 
    if ((rule->flow_type & 2147483647U) == 1U) 
#line 985 
                                               spec.ip_proto = (unsigned char)6U; else 
                                                                    
#line 985 
                                                                    spec.ip_proto = (unsigned char)17U;
    
#line 987 
    if (ip_mask->ip4dst != 0U) {
      
#line 988 
      if (ip_mask->ip4dst != 4294967295U) {
        
#line 989 
        __retres = -22;
        
#line 989 
        goto return_label;
      }
      else ;
      
#line 990 
      spec.match_flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))))((unsigned int)spec.match_flags | 2U);
      
#line 991 
      spec.loc_host[0] = ip_entry->ip4dst;
    }
    else ;
    
#line 993 
    if (ip_mask->ip4src != 0U) {
      
#line 994 
      if (ip_mask->ip4src != 4294967295U) {
        
#line 995 
        __retres = -22;
        
#line 995 
        goto return_label;
      }
      else ;
      
#line 996 
      spec.match_flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))))((unsigned int)spec.match_flags | 1U);
      
#line 997 
      spec.rem_host[0] = ip_entry->ip4src;
    }
    else ;
    
#line 999 
    if ((unsigned int)ip_mask->pdst != 0U) {
      
#line 1000 
      if ((unsigned int)ip_mask->pdst != 65535U) {
        
#line 1001 
        __retres = -22;
        
#line 1001 
        goto return_label;
      }
      else ;
      
#line 1002 
      spec.match_flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))))((unsigned int)spec.match_flags | 32U);
      
#line 1003 
      spec.loc_port = ip_entry->pdst;
    }
    else ;
    
#line 1005 
    if ((unsigned int)ip_mask->psrc != 0U) {
      
#line 1006 
      if ((unsigned int)ip_mask->psrc != 65535U) {
        
#line 1007 
        __retres = -22;
        
#line 1007 
        goto return_label;
      }
      else ;
      
#line 1008 
      spec.match_flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))))((unsigned int)spec.match_flags | 8U);
      
#line 1009 
      spec.rem_port = ip_entry->psrc;
    }
    else ;
    
#line 1011 
    if ((unsigned int)ip_mask->tos != 0U) {
      
#line 1012 
      __retres = -22;
      
#line 1012 
      goto return_label;
    }
    else ;
    
#line 1013 
    goto ldv_55877;
    case (unsigned int)18: 
#line 1015 
    ;
    
#line 1016 
    tmp_3 = is_zero_ether_addr((u8 const *)(& mac_mask->h_dest));
    
#line 1016 
    if (tmp_3) 
#line 1016 
               tmp_4 = 0; else 
#line 1016 
                               tmp_4 = 1;
    
#line 1016 
    if (tmp_4) {
      bool tmp_2;
      
#line 1017 
      tmp_2 = ether_addr_equal((u8 const *)(& mac_mask->h_dest),(u8 const *)(& mac_addr_ig_mask));
      
#line 1017 
      if ((int)tmp_2 != 0) 
#line 1019 
                           spec.match_flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))))((unsigned int)spec.match_flags | 1024U);
      else {
        bool tmp_1;
        
#line 1020 
        tmp_1 = is_broadcast_ether_addr((u8 const *)(& mac_mask->h_dest));
        
#line 1020 
        if ((int)tmp_1 != 0) 
#line 1021 
                             spec.match_flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))))((unsigned int)spec.match_flags | 16U);
        else {
          
#line 1023 
          __retres = -22;
          
#line 1023 
          goto return_label;
        }
      }
      
#line 1024 
      ether_addr_copy((u8 *)(& spec.loc_mac),(u8 const *)(& mac_entry->h_dest));
    }
    else ;
    
#line 1026 
    tmp_7 = is_zero_ether_addr((u8 const *)(& mac_mask->h_source));
    
#line 1026 
    if (tmp_7) 
#line 1026 
               tmp_8 = 0; else 
#line 1026 
                               tmp_8 = 1;
    
#line 1026 
    if (tmp_8) {
      int tmp_6;
      bool tmp_5;
      
#line 1027 
      tmp_5 = is_broadcast_ether_addr((u8 const *)(& mac_mask->h_source));
      
#line 1027 
      if (tmp_5) 
#line 1027 
                 tmp_6 = 0; else 
#line 1027 
                                 tmp_6 = 1;
      
#line 1027 
      if (tmp_6) {
        
#line 1028 
        __retres = -22;
        
#line 1028 
        goto return_label;
      }
      else ;
      
#line 1029 
      spec.match_flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))))((unsigned int)spec.match_flags | 4U);
      
#line 1030 
      ether_addr_copy((u8 *)(& spec.rem_mac),(u8 const *)(& mac_entry->h_source));
    }
    else ;
    
#line 1032 
    if ((unsigned int)mac_mask->h_proto != 0U) {
      
#line 1033 
      if ((unsigned int)mac_mask->h_proto != 65535U) {
        
#line 1034 
        __retres = -22;
        
#line 1034 
        goto return_label;
      }
      else ;
      
#line 1035 
      spec.match_flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))))((unsigned int)spec.match_flags | 64U);
      
#line 1036 
      spec.ether_type = mac_entry->h_proto;
    }
    else ;
    
#line 1038 
    goto ldv_55877;
    default: 
#line 1040 
    ;
    
#line 1041 
    __retres = -22;
    
#line 1041 
    goto return_label;
  }
  ldv_55877: 
#line 1044 
  ;
  
#line 1044 
  if (rule->flow_type < (__u32)0 && (unsigned int)rule->m_ext.vlan_tci != 0U) {
    
#line 1045 
    if ((unsigned int)rule->m_ext.vlan_tci != 65295U) {
      
#line 1046 
      __retres = -22;
      
#line 1046 
      goto return_label;
    }
    else ;
    
#line 1047 
    spec.match_flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))))((unsigned int)spec.match_flags | 256U);
    
#line 1048 
    spec.outer_vid = rule->h_ext.vlan_tci;
  }
  else ;
  
#line 1051 
  rc = efx_filter_insert_filter(efx,& spec,(_Bool)1);
  
#line 1052 
  if (rc < 0) {
    
#line 1053 
    __retres = rc;
    
#line 1053 
    goto return_label;
  }
  else ;
  
#line 1055 
  rule->location = (unsigned int)rc;
  
#line 1056 
  __retres = 0;
  return_label: 
#line 1056 
                return __retres;
}


#line 1059  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static int efx_ethtool_set_rxnfc(struct net_device *net_dev, struct ethtool_rxnfc *info)
{
  int __retres;
  u32 tmp_0;
  
#line 1062 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 1064 
  tmp_0 = efx_filter_get_rx_id_limit(efx);
  
#line 1064 
  if (tmp_0 == 0U) {
    
#line 1065 
    __retres = -95;
    
#line 1065 
    goto return_label;
  }
  else ;
  
#line 1067 
  switch (info->cmd) {
    int tmp_1;
    int tmp_2;
    case (__u32)50: 
#line 1068 
    ;
    
#line 1069 
    tmp_1 = efx_ethtool_set_class_rule(efx,& info->fs);
    
#line 1069 
    __retres = tmp_1;
    
#line 1069 
    goto return_label;
    case (__u32)49: 
#line 1071 
    ;
    
#line 1072 
    tmp_2 = efx_filter_remove_id_safe(efx,(enum efx_filter_priority)EFX_FILTER_PRI_MANUAL,info->fs.location);
    
#line 1072 
    __retres = tmp_2;
    
#line 1072 
    goto return_label;
    default: 
#line 1075 
    ;
    
#line 1076 
    __retres = -95;
    
#line 1076 
    goto return_label;
  }
  return_label: 
#line 1067 
                return __retres;
}


#line 1080  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static u32 efx_ethtool_get_rxfh_indir_size(struct net_device *net_dev)
{
  unsigned int tmp_1;
  int tmp_0;
  
#line 1082 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 1086 
  tmp_0 = efx_nic_rev(efx);
  
#line 1086 
  if (tmp_0 <= 1) 
#line 1086 
                  tmp_1 = 0U;
  else 
    
#line 1084 
    if (efx->n_rx_channels == 1U) 
#line 1086 
                                  tmp_1 = 0U; else 
#line 1086 
                                                   tmp_1 = 128U;
  
#line 1086 
  return tmp_1;
}


#line 1089  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static int efx_ethtool_get_rxfh(struct net_device *net_dev, u32 *indir, u8 *key, u8 *hfunc)
{
  int __retres;
  
#line 1092 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 1094 
  if (hfunc != (u8 *)0U) 
#line 1095 
                         *hfunc = (unsigned char)1U; else ;
  
#line 1096 
  if (indir != (u32 *)0U) 
#line 1097 
                          memcpy((void *)indir,(void const *)(& efx->rx_indir_table),512UL); else ;
  
#line 1098 
  __retres = 0;
  
#line 1098 
  return __retres;
}


#line 1101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static int efx_ethtool_set_rxfh(struct net_device *net_dev, u32 const *indir, u8 const *key, u8 const hfunc)
{
  int __retres;
  int tmp_0;
  
#line 1104 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 1107 
  if (key != (u8 const *)0U || (unsigned int)hfunc > 1U) {
    
#line 1109 
    __retres = -95;
    
#line 1109 
    goto return_label;
  }
  else ;
  
#line 1110 
  if (indir == (u32 const *)0U) {
    
#line 1111 
    __retres = 0;
    
#line 1111 
    goto return_label;
  }
  else ;
  
#line 1113 
  tmp_0 = (*((efx->type)->rx_push_rss_config))(efx,(_Bool)1,indir);
  
#line 1113 
  __retres = tmp_0;
  return_label: 
#line 1113 
                return __retres;
}


#line 1116  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static int efx_ethtool_get_ts_info(struct net_device *net_dev, struct ethtool_ts_info *ts_info)
{
  int __retres;
  
#line 1119 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 1122 
  ts_info->so_timestamping = 24U;
  
#line 1124 
  ts_info->phc_index = -1;
  
#line 1126 
  efx_ptp_get_ts_info(efx,ts_info);
  
#line 1127 
  __retres = 0;
  
#line 1127 
  return __retres;
}


#line 1130  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static int efx_ethtool_get_module_eeprom(struct net_device *net_dev, struct ethtool_eeprom *ee, u8 *data)
{
  int __retres;
  int ret;
  
#line 1134 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 1137 
  if (efx->phy_op == (struct efx_phy_operations const *)0 || (efx->phy_op)->get_module_eeprom == (int (*)(struct efx_nic *, struct ethtool_eeprom *, u8 *))0) {
    
#line 1138 
    __retres = -95;
    
#line 1138 
    goto return_label;
  }
  else ;
  
#line 1140 
  ldv_mutex_lock_95_0(& efx->mac_lock);
  
#line 1141 
  ret = (*((efx->phy_op)->get_module_eeprom))(efx,ee,data);
  
#line 1142 
  ldv_mutex_unlock_96_0(& efx->mac_lock);
  
#line 1144 
  __retres = ret;
  return_label: 
#line 1144 
                return __retres;
}


#line 1147  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
static int efx_ethtool_get_module_info(struct net_device *net_dev, struct ethtool_modinfo *modinfo)
{
  int __retres;
  int ret;
  
#line 1150 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 1153 
  if (efx->phy_op == (struct efx_phy_operations const *)0 || (efx->phy_op)->get_module_info == (int (*)(struct efx_nic *, struct ethtool_modinfo *))0) {
    
#line 1154 
    __retres = -95;
    
#line 1154 
    goto return_label;
  }
  else ;
  
#line 1156 
  ldv_mutex_lock_97_0(& efx->mac_lock);
  
#line 1157 
  ret = (*((efx->phy_op)->get_module_info))(efx,modinfo);
  
#line 1158 
  ldv_mutex_unlock_98_0(& efx->mac_lock);
  
#line 1160 
  __retres = ret;
  return_label: 
#line 1160 
                return __retres;
}


#line 1163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ethtool.c"
struct ethtool_ops const efx_ethtool_ops = {.get_settings = & efx_ethtool_get_settings, .set_settings = & efx_ethtool_set_settings, .get_drvinfo = & efx_ethtool_get_drvinfo, .get_regs_len = & efx_ethtool_get_regs_len, .get_regs = & efx_ethtool_get_regs, .get_wol = & efx_ethtool_get_wol, .set_wol = & efx_ethtool_set_wol, .get_msglevel = & efx_ethtool_get_msglevel, .set_msglevel = & efx_ethtool_set_msglevel, .nway_reset = & efx_ethtool_nway_reset, .get_link = & ethtool_op_get_link, .get_eeprom_len = (int (*)(struct net_device *))0, .get_eeprom = (int (*)(struct net_device *, struct ethtool_eeprom *, u8 *))0, .set_eeprom = (int (*)(struct net_device *, struct ethtool_eeprom *, u8 *))0, .get_coalesce = & efx_ethtool_get_coalesce, .set_coalesce = & efx_ethtool_set_coalesce, .get_ringparam = & efx_ethtool_get_ringparam, .set_ringparam = & efx_ethtool_set_ringparam, .get_pauseparam = & efx_ethtool_get_pauseparam, .set_pauseparam = & efx_ethtool_set_pauseparam, .self_test = & efx_ethtool_self_test, .get_strings = & efx_ethtool_get_strings, .set_phys_id = & efx_ethtool_phys_id, .get_ethtool_stats = & efx_ethtool_get_stats, .begin = (int (*)(struct net_device *))0, .complete = (void (*)(struct net_device *))0, .get_priv_flags = (u32 (*)(struct net_device *))0, .set_priv_flags = (int (*)(struct net_device *, u32 ))0, .get_sset_count = & efx_ethtool_get_sset_count, .get_rxnfc = & efx_ethtool_get_rxnfc, .set_rxnfc = & efx_ethtool_set_rxnfc, .flash_device = (int (*)(struct net_device *, struct ethtool_flash *))0, .reset = & efx_ethtool_reset, .get_rxfh_key_size = (u32 (*)(struct net_device *))0, .get_rxfh_indir_size = & efx_ethtool_get_rxfh_indir_size, .get_rxfh = & efx_ethtool_get_rxfh, .set_rxfh = & efx_ethtool_set_rxfh, .get_channels = (void (*)(struct net_device *, struct ethtool_channels *))0, .set_channels = (int (*)(struct net_device *, struct ethtool_channels *))0, .get_dump_flag = (int (*)(struct net_device *, struct ethtool_dump *))0, .get_dump_data = (int (*)(struct net_device *, struct ethtool_dump *, void *))0, .set_dump = (int (*)(struct net_device *, struct ethtool_dump *))0, .get_ts_info = & efx_ethtool_get_ts_info, .get_module_info = & efx_ethtool_get_module_info, .get_module_eeprom = & efx_ethtool_get_module_eeprom, .get_eee = (int (*)(struct net_device *, struct ethtool_eee *))0, .set_eee = (int (*)(struct net_device *, struct ethtool_eee *))0, .get_tunable = (int (*)(struct net_device *, struct ethtool_tunable const *, void *))0, .set_tunable = (int (*)(struct net_device *, struct ethtool_tunable const *, void const *))0};

#line 618  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ethtool.c.aux"
static void *kzalloc_4(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 621 
  tmp = ldv_kzalloc(size,flags);
  
#line 621 
  return tmp;
}


#line 888  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ethtool.c.aux"
static void ldv_mutex_lock_87_0(struct mutex *ldv_func_arg1)
{
  
#line 892 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 893 
  return;
}


#line 896  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ethtool.c.aux"
static void ldv_mutex_unlock_88_0(struct mutex *ldv_func_arg1)
{
  
#line 900 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 901 
  return;
}


#line 904  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ethtool.c.aux"
static void ldv_mutex_lock_89_0(struct mutex *ldv_func_arg1)
{
  
#line 908 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 909 
  return;
}


#line 912  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ethtool.c.aux"
static void ldv_mutex_unlock_90_0(struct mutex *ldv_func_arg1)
{
  
#line 916 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 917 
  return;
}


#line 920  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ethtool.c.aux"
static void ldv_spin_lock_bh_91(spinlock_t *lock)
{
  
#line 924 
  ldv_spin_model_lock((char *)"stats_lock_of_efx_nic");
  
#line 926 
  spin_lock_bh_0(lock);
  
#line 927 
  return;
}


#line 930  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ethtool.c.aux"
static void ldv_spin_unlock_bh_92(spinlock_t *lock)
{
  
#line 934 
  ldv_spin_model_unlock((char *)"stats_lock_of_efx_nic");
  
#line 936 
  spin_unlock_bh_0(lock);
  
#line 937 
  return;
}


#line 940  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ethtool.c.aux"
static void ldv_mutex_lock_93_0(struct mutex *ldv_func_arg1)
{
  
#line 944 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 945 
  return;
}


#line 948  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ethtool.c.aux"
static void ldv_mutex_unlock_94_0(struct mutex *ldv_func_arg1)
{
  
#line 952 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 953 
  return;
}


#line 956  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ethtool.c.aux"
static void ldv_mutex_lock_95_0(struct mutex *ldv_func_arg1)
{
  
#line 960 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 961 
  return;
}


#line 964  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ethtool.c.aux"
static void ldv_mutex_unlock_96_0(struct mutex *ldv_func_arg1)
{
  
#line 968 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 969 
  return;
}


#line 972  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ethtool.c.aux"
static void ldv_mutex_lock_97_0(struct mutex *ldv_func_arg1)
{
  
#line 976 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 977 
  return;
}


#line 980  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ethtool.c.aux"
static void ldv_mutex_unlock_98_0(struct mutex *ldv_func_arg1)
{
  
#line 984 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 985 
  return;
}


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/err.h"
static long PTR_ERR(void const *ptr);


#line 41 
static bool IS_ERR(void const *ptr);


#line 37  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi_mon.c.aux"
static void ldv_mutex_lock_87_1(struct mutex *ldv_func_arg1);


#line 27  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/err.h"
long ldv_is_err(void const *ptr);


#line 30 
long ldv_ptr_err(void const *ptr);


#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
void __mutex_init(struct mutex *, char const *, struct lock_class_key *);


#line 193 
static void ldv_mutex_unlock_88_1(struct mutex *ldv_func_arg1);


#line 542  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kcalloc_3(size_t n, size_t size, gfp_t flags);


#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hwmon.h"
struct device *hwmon_device_register_with_groups(struct device *, char const *, void *, struct attribute_group const **);


#line 30 
void hwmon_device_unregister(struct device *);


#line 127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.h"
__inline static struct efx_mcdi_mon *efx_mcdi_mon(struct efx_nic *efx)
{
  struct efx_mcdi_mon *__retres;
  
#line 130 
  __retres = & (efx->mcdi)->hwmon;
  
#line 130 
  return __retres;
}


#line 178 
void efx_mcdi_sensor_event(struct efx_nic *efx, efx_qword_t *ev);


#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_mon.c"
static char const * const efx_hwmon_unit[6U] = {[1] = " degC", " rpm", " mV", " mA", " W"};

#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_mon.c"
static struct __anonstruct_efx_mcdi_sensor_type_4217 const efx_mcdi_sensor_type[46U] = {{.label = "Controller board temp.", .hwmon_type = EFX_HWMON_TEMP, .port = -1}, {.label = "PHY temp.", .hwmon_type = EFX_HWMON_TEMP, .port = -1}, {.label = "Controller heat sink", .hwmon_type = EFX_HWMON_COOL, .port = -1}, {.label = "PHY temp.", .hwmon_type = EFX_HWMON_TEMP, .port = 0}, {.label = "PHY heat sink", .hwmon_type = EFX_HWMON_COOL, .port = 0}, {.label = "PHY temp.", .hwmon_type = EFX_HWMON_TEMP, .port = 1}, {.label = "PHY heat sink", .hwmon_type = EFX_HWMON_COOL, .port = 1}, {.label = "1.0V supply", .hwmon_type = EFX_HWMON_IN, .port = -1}, {.label = "1.2V supply", .hwmon_type = EFX_HWMON_IN, .port = -1}, {.label = "1.8V supply", .hwmon_type = EFX_HWMON_IN, .port = -1}, {.label = "2.5V supply", .hwmon_type = EFX_HWMON_IN, .port = -1}, {.label = "3.3V supply", .hwmon_type = EFX_HWMON_IN, .port = -1}, {.label = "12.0V supply", .hwmon_type = EFX_HWMON_IN, .port = -1}, {.label = "1.2V analogue supply", .hwmon_type = EFX_HWMON_IN, .port = -1}, {.label = "Ref. voltage", .hwmon_type = EFX_HWMON_IN, .port = -1}, {.label = "AOE FPGA supply", .hwmon_type = EFX_HWMON_IN, .port = -1}, {.label = "AOE FPGA temp.", .hwmon_type = EFX_HWMON_TEMP, .port = -1}, {.label = "AOE regulator temp.", .hwmon_type = EFX_HWMON_TEMP, .port = -1}, {.label = "Controller regulator temp.", .hwmon_type = EFX_HWMON_TEMP, .port = -1}, {.label = "Fan 0", .hwmon_type = EFX_HWMON_COOL, .port = -1}, {.label = "Fan 1", .hwmon_type = EFX_HWMON_COOL, .port = -1}, {.label = "Fan 2", .hwmon_type = EFX_HWMON_COOL, .port = -1}, {.label = "Fan 3", .hwmon_type = EFX_HWMON_COOL, .port = -1}, {.label = "Fan 4", .hwmon_type = EFX_HWMON_COOL, .port = -1}, {.label = "AOE input supply", .hwmon_type = EFX_HWMON_IN, .port = -1}, {.label = "AOE output current", .hwmon_type = EFX_HWMON_CURR, .port = -1}, {.label = "AOE input current", .hwmon_type = EFX_HWMON_CURR, .port = -1}, {.label = "Board power use", .hwmon_type = EFX_HWMON_POWER, .port = -1}, {.label = "0.9V supply", .hwmon_type = EFX_HWMON_IN, .port = -1}, {.label = "0.9V supply current", .hwmon_type = EFX_HWMON_CURR, .port = -1}, {.label = "1.2V supply current", .hwmon_type = EFX_HWMON_CURR, .port = -1}, [32] = {.label = "0.9V supply (ext. ADC)", .hwmon_type = EFX_HWMON_IN, .port = -1}, {.label = "Controller board temp. 2", .hwmon_type = EFX_HWMON_TEMP, .port = -1}, {.label = "Regulator die temp.", .hwmon_type = EFX_HWMON_TEMP, .port = -1}, {.label = "0.9V regulator temp.", .hwmon_type = EFX_HWMON_TEMP, .port = -1}, {.label = "1.2V regulator temp.", .hwmon_type = EFX_HWMON_TEMP, .port = -1}, {.label = "Controller PTAT voltage (int. ADC)", .hwmon_type = EFX_HWMON_IN, .port = -1}, {.label = "Controller die temp. (int. ADC)", .hwmon_type = EFX_HWMON_TEMP, .port = -1}, {.label = "Controller PTAT voltage (ext. ADC)", .hwmon_type = EFX_HWMON_IN, .port = -1}, {.label = "Controller die temp. (ext. ADC)", .hwmon_type = EFX_HWMON_TEMP, .port = -1}, {.label = "Ambient temp.", .hwmon_type = EFX_HWMON_TEMP, .port = -1}, {.label = "Air flow raw", .hwmon_type = EFX_HWMON_IN, .port = -1}, {.label = "0.9V die (int. ADC)", .hwmon_type = EFX_HWMON_IN, .port = -1}, {.label = "0.9V die (ext. ADC)", .hwmon_type = EFX_HWMON_IN, .port = -1}, {.label = "Controller board temp. (hotpoint)", .hwmon_type = EFX_HWMON_TEMP, .port = -1}};

#line 98  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_mon.c"
static char const * const sensor_status_names[5U] = {"OK", "Warning", "Fatal", "Device failure", "No reading"};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_mon.c"
void efx_mcdi_sensor_event(struct efx_nic *efx, efx_qword_t *ev)
{
  unsigned int type;
  unsigned int state;
  unsigned int value;
  char const *state_txt;
  char const *unit;
  
#line 109 
  enum efx_hwmon_type hwmon_type = EFX_HWMON_UNKNOWN;
  
#line 110 
  char const *name = (char const *)0;
  
#line 112 
  type = (unsigned int)ev->u64[0] & 255U;
  
#line 113 
  state = (unsigned int)(ev->u64[0] >> 8) & 255U;
  
#line 114 
  value = (unsigned int)(ev->u64[0] >> 16) & 65535U;
  
#line 118 
  if (type <= 45U) {
    
#line 119 
    name = efx_mcdi_sensor_type[type].label;
    
#line 120 
    hwmon_type = efx_mcdi_sensor_type[type].hwmon_type;
  }
  else ;
  
#line 122 
  if (name == (char const *)0) 
#line 123 
                               name = "No sensor name available"; else ;
  
#line 125 
  state_txt = sensor_status_names[state];
  
#line 127 
  unit = efx_hwmon_unit[(unsigned int)hwmon_type];
  
#line 128 
  if (unit == (char const *)0) 
#line 129 
                               unit = ""; else ;
  
#line 131 
  if ((efx->msg_enable & 8192U) != 0U) 
#line 131 
                                       netdev_err((struct net_device const *)efx->net_dev,"Sensor %d (%s) reports condition \'%s\' for value %d%s\n",type,name,state_txt,value,unit); else ;
  
#line 132 
  return;
}


#line 147  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_mon.c"
static int efx_mcdi_mon_update(struct efx_nic *efx)
{
  int rc;
  
#line 149 
  struct efx_mcdi_mon *hwmon = efx_mcdi_mon(efx);
  
#line 150 
  efx_dword_t inbuf[3U] = {{.u32 = {0U}}};
  
#line 153 
  ((efx_dword_t *)(& inbuf))->u32[0] = (unsigned int)hwmon->dma_buf.dma_addr;
  
#line 153 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = (unsigned int)(hwmon->dma_buf.dma_addr >> 32);
  
#line 155 
  ((efx_dword_t *)(& inbuf) + 2U)->u32[0] = hwmon->dma_buf.len;
  
#line 157 
  rc = efx_mcdi_rpc(efx,66U,(efx_dword_t const *)(& inbuf),12UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 159 
  if (rc == 0) 
#line 160 
               hwmon->last_update = jiffies; else ;
  
#line 161 
  return rc;
}


#line 171 
void __compiletime_assert_171(void);


#line 164  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_mon.c"
static int efx_mcdi_mon_get_entry(struct device *dev, unsigned int index, efx_dword_t *entry)
{
  int rc;
  int tmp_1;
  
#line 167 
  struct efx_nic *efx = dev_get_drvdata((struct device const *)dev->parent);
  
#line 168 
  struct efx_mcdi_mon *hwmon = efx_mcdi_mon(efx);
  {
    
#line 171 
    bool __cond = (_Bool)0;
    
#line 171 
    if ((int)__cond != 0) 
#line 171 
                          __compiletime_assert_171(); else ;
  }
  
#line 173 
  ldv_mutex_lock_87_1(& hwmon->update_lock);
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
#line 176 
    tmp_1 = 1;
  }
  
#line 176 
  if (tmp_1 != 0) {
    int tmp_2;
    {
      unsigned long __dummy_0;
      unsigned long volatile __dummy2_0;
      
#line 176 
      tmp_2 = 1;
    }
    
#line 176 
    if (tmp_2 != 0) 
      
#line 176 
      if ((long)((jiffies - hwmon->last_update) + 18446744073709551366UL) < 0L) 
        
#line 177 
        rc = 0; else 
#line 179 
                     rc = efx_mcdi_mon_update(efx);
    else 
#line 179 
         rc = efx_mcdi_mon_update(efx);
  }
  else 
#line 179 
       rc = efx_mcdi_mon_update(efx);
  
#line 182 
  *entry = *((efx_dword_t *)hwmon->dma_buf.addr + index);
  
#line 184 
  ldv_mutex_unlock_88_1(& hwmon->update_lock);
  
#line 186 
  return rc;
}


#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_mon.c"
static ssize_t efx_mcdi_mon_show_value(struct device *dev, struct device_attribute *attr, char *buf)
{
  ssize_t __retres;
  struct efx_mcdi_mon_attribute *tmp;
  efx_dword_t entry;
  unsigned int value;
  unsigned int state;
  int rc;
  int tmp_0;
  {
    
#line 194 
    struct device_attribute const *__mptr = (struct device_attribute const *)attr;
    
#line 194 
    tmp = (struct efx_mcdi_mon_attribute *)__mptr;
  }
  
#line 193 
  struct efx_mcdi_mon_attribute *mon_attr = tmp;
  
#line 199 
  rc = efx_mcdi_mon_get_entry(dev,mon_attr->index,& entry);
  
#line 200 
  if (rc != 0) {
    
#line 201 
    __retres = (long)rc;
    
#line 201 
    goto return_label;
  }
  else ;
  
#line 203 
  state = (entry.u32[0] >> 16) & 255U;
  
#line 204 
  if (state == 4U) {
    
#line 205 
    __retres = -16L;
    
#line 205 
    goto return_label;
  }
  else ;
  
#line 207 
  value = entry.u32[0] & 65535U;
  
#line 209 
  switch ((unsigned int)mon_attr->hwmon_type) {
    case (unsigned int)1: 
#line 210 
    ;
    
#line 212 
    value *= 1000U;
    
#line 213 
    goto ldv_55570;
    case (unsigned int)5: 
#line 214 
    ;
    
#line 216 
    value *= 1000000U;
    
#line 217 
    goto ldv_55570;
    default: 
#line 218 
    ;
    
#line 220 
    goto ldv_55570;
  }
  ldv_55570: 
#line 223 
  ;
  
#line 223 
  tmp_0 = sprintf(buf,"%u\n",value);
  
#line 223 
  __retres = (long)tmp_0;
  return_label: 
#line 223 
                return __retres;
}


#line 226  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_mon.c"
static ssize_t efx_mcdi_mon_show_limit(struct device *dev, struct device_attribute *attr, char *buf)
{
  ssize_t __retres;
  struct efx_mcdi_mon_attribute *tmp;
  unsigned int value;
  int tmp_0;
  {
    
#line 231 
    struct device_attribute const *__mptr = (struct device_attribute const *)attr;
    
#line 231 
    tmp = (struct efx_mcdi_mon_attribute *)__mptr;
  }
  
#line 230 
  struct efx_mcdi_mon_attribute *mon_attr = tmp;
  
#line 234 
  value = mon_attr->limit_value;
  
#line 236 
  switch ((unsigned int)mon_attr->hwmon_type) {
    case (unsigned int)1: 
#line 237 
    ;
    
#line 239 
    value *= 1000U;
    
#line 240 
    goto ldv_55583;
    case (unsigned int)5: 
#line 241 
    ;
    
#line 243 
    value *= 1000000U;
    
#line 244 
    goto ldv_55583;
    default: 
#line 245 
    ;
    
#line 247 
    goto ldv_55583;
  }
  ldv_55583: 
#line 250 
  ;
  
#line 250 
  tmp_0 = sprintf(buf,"%u\n",value);
  
#line 250 
  __retres = (long)tmp_0;
  
#line 250 
  return __retres;
}


#line 253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_mon.c"
static ssize_t efx_mcdi_mon_show_alarm(struct device *dev, struct device_attribute *attr, char *buf)
{
  ssize_t __retres;
  struct efx_mcdi_mon_attribute *tmp;
  efx_dword_t entry;
  int state;
  int rc;
  int tmp_0;
  {
    
#line 258 
    struct device_attribute const *__mptr = (struct device_attribute const *)attr;
    
#line 258 
    tmp = (struct efx_mcdi_mon_attribute *)__mptr;
  }
  
#line 257 
  struct efx_mcdi_mon_attribute *mon_attr = tmp;
  
#line 263 
  rc = efx_mcdi_mon_get_entry(dev,mon_attr->index,& entry);
  
#line 264 
  if (rc != 0) {
    
#line 265 
    __retres = (long)rc;
    
#line 265 
    goto return_label;
  }
  else ;
  
#line 267 
  state = (int)(entry.u32[0] >> 16) & 255;
  
#line 268 
  tmp_0 = sprintf(buf,"%d\n",state != 0);
  
#line 268 
  __retres = (long)tmp_0;
  return_label: 
#line 268 
                return __retres;
}


#line 271  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_mon.c"
static ssize_t efx_mcdi_mon_show_label(struct device *dev, struct device_attribute *attr, char *buf)
{
  ssize_t __retres;
  struct efx_mcdi_mon_attribute *tmp;
  int tmp_0;
  {
    
#line 276 
    struct device_attribute const *__mptr = (struct device_attribute const *)attr;
    
#line 276 
    tmp = (struct efx_mcdi_mon_attribute *)__mptr;
  }
  
#line 275 
  struct efx_mcdi_mon_attribute *mon_attr = tmp;
  
#line 277 
  tmp_0 = sprintf(buf,"%s\n",efx_mcdi_sensor_type[mon_attr->type].label);
  
#line 277 
  __retres = (long)tmp_0;
  
#line 277 
  return __retres;
}


#line 282  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_mon.c"
static void efx_mcdi_mon_add_attr(struct efx_nic *efx, char const *name, ssize_t (*reader)(struct device *, struct device_attribute *, char *), unsigned int index, unsigned int type, unsigned int limit_value)
{
  unsigned int tmp_0;
  
#line 288 
  struct efx_mcdi_mon *hwmon = efx_mcdi_mon(efx);
  
#line 289 
  struct efx_mcdi_mon_attribute *attr = hwmon->attrs + hwmon->n_attrs;
  
#line 291 
  strlcpy((char *)(& attr->name),name,12UL);
  
#line 292 
  attr->index = index;
  
#line 293 
  attr->type = type;
  
#line 294 
  if (type <= 45U) 
#line 295 
                   attr->hwmon_type = efx_mcdi_sensor_type[type].hwmon_type; else 
                                                                    
#line 297 
                                                                    attr->hwmon_type = EFX_HWMON_UNKNOWN;
  
#line 298 
  attr->limit_value = limit_value;
  {
    struct lock_class_key __key;
    
#line 299 
    attr->dev_attr.attr.key = & __key;
  }
  
#line 300 
  attr->dev_attr.attr.name = (char const *)(& attr->name);
  
#line 301 
  attr->dev_attr.attr.mode = (unsigned short)292U;
  
#line 302 
  attr->dev_attr.show = reader;
  
#line 303 
  tmp_0 = hwmon->n_attrs;
  
#line 303 
  hwmon->n_attrs += 1U;
  
#line 303 
  *(hwmon->group.attrs + tmp_0) = & attr->dev_attr.attr;
  
#line 304 
  return;
}


#line 306  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_mon.c"
int efx_mcdi_mon_probe(struct efx_nic *efx)
{
  int __retres;
  unsigned int n_pages;
  unsigned int n_sensors;
  unsigned int n_attrs;
  unsigned int page;
  size_t outlen;
  char name[12U];
  u32 mask;
  int rc;
  int i;
  int j;
  int type;
  bool tmp_9;
  
#line 308 
  unsigned int n_temp = 0U;
  
#line 308 
  unsigned int n_cool = 0U;
  
#line 308 
  unsigned int n_in = 0U;
  
#line 308 
  unsigned int n_curr = 0U;
  
#line 308 
  unsigned int n_power = 0U;
  
#line 309 
  struct efx_mcdi_mon *hwmon = efx_mcdi_mon(efx);
  
#line 310 
  efx_dword_t inbuf[1U] = {{.u32 = {0U}}};
  
#line 311 
  efx_dword_t outbuf[63U] = {{.u32 = {0U}}};
  
#line 319 
  n_sensors = 0U;
  
#line 320 
  page = 0U;
  ldv_55653: 
#line 321 
  ;
  {
    unsigned int tmp_1;
    
#line 322 
    ((efx_dword_t *)(& inbuf))->u32[0] = page;
    
#line 324 
    rc = efx_mcdi_rpc(efx,65U,(efx_dword_t const *)(& inbuf),4UL,(efx_dword_t *)(& outbuf),252UL,& outlen);
    
#line 326 
    if (rc != 0) {
      
#line 327 
      __retres = rc;
      
#line 327 
      goto return_label;
    }
    else ;
    
#line 328 
    if (outlen <= 3UL) {
      
#line 329 
      __retres = -5;
      
#line 329 
      goto return_label;
    }
    else ;
    
#line 331 
    mask = ((efx_dword_t *)(& outbuf))->u32[0];
    
#line 332 
    if (0 != 0) 
#line 332 
                tmp_1 = ((unsigned int)((((((((((unsigned long long)mask & 1ULL) != 0ULL) + (((unsigned long long)mask & 2ULL) != 0ULL)) + (((unsigned long long)mask & 4ULL) != 0ULL)) + (((unsigned long long)mask & 8ULL) != 0ULL)) + (((unsigned long long)mask & 16ULL) != 0ULL)) + (((unsigned long long)mask & 32ULL) != 0ULL)) + (((unsigned long long)mask & 64ULL) != 0ULL)) + (((unsigned long long)mask & 128ULL) != 0ULL)) + (unsigned int)((((((((((unsigned long long)(mask >> 8) & 1ULL) != 0ULL) + (((unsigned long long)(mask >> 8) & 2ULL) != 0ULL)) + (((unsigned long long)(mask >> 8) & 4ULL) != 0ULL)) + (((unsigned long long)(mask >> 8) & 8ULL) != 0ULL)) + (((unsigned long long)(mask >> 8) & 16ULL) != 0ULL)) + (((unsigned long long)(mask >> 8) & 32ULL) != 0ULL)) + (((unsigned long long)(mask >> 8) & 64ULL) != 0ULL)) + (((unsigned long long)(mask >> 8) & 128ULL) != 0ULL))) + ((unsigned int)((((((((((unsigned long long)(mask >> 16) & 1ULL) != 0ULL) + (((unsigned long long)(mask >> 16) & 2ULL) != 0ULL)) + (((unsigned long long)(mask >> 16) & 4ULL) != 0ULL)) + (((unsigned long long)(mask >> 16) & 8ULL) != 0ULL)) + (((unsigned long long)(mask >> 16) & 16ULL) != 0ULL)) + (((unsigned long long)(mask >> 16) & 32ULL) != 0ULL)) + (((unsigned long long)(mask >> 16) & 64ULL) != 0ULL)) + (((unsigned long long)(mask >> 16) & 128ULL) != 0ULL)) + (unsigned int)(((((((((unsigned long long)(mask >> 24) & 1ULL) != 0ULL) + (((unsigned long long)(mask >> 24) & 2ULL) != 0ULL)) + (((unsigned long long)(mask >> 24) & 4ULL) != 0ULL)) + (((unsigned long long)(mask >> 24) & 8ULL) != 0ULL)) + (((unsigned long long)(mask >> 24) & 16ULL) != 0ULL)) + (((unsigned long long)(mask >> 24) & 32ULL) != 0ULL)) + (((unsigned long long)(mask >> 24) & 64ULL) != 0ULL))); else 
                                                                    
#line 332 
                                                                    tmp_1 = __arch_hweight32(mask & 2147483647U);
    
#line 332 
    n_sensors = tmp_1 + n_sensors;
    
#line 333 
    page += 1U;
  }
  
#line 334 
  if (mask < (u32)0) 
#line 336 
                     goto ldv_55653; else 
#line 339 
                                          goto ldv_55654;
  ldv_55654: 
#line 340 
  ;
  
#line 335 
  n_pages = page;
  
#line 338 
  if (n_sensors == 0U) {
    
#line 339 
    __retres = 0;
    
#line 339 
    goto return_label;
  }
  else ;
  
#line 341 
  rc = efx_nic_alloc_buffer(efx,& hwmon->dma_buf,n_sensors * 4U,208U);
  
#line 345 
  if (rc != 0) {
    
#line 346 
    __retres = rc;
    
#line 346 
    goto return_label;
  }
  else ;
  {
    struct lock_class_key __key;
    
#line 348 
    __mutex_init(& hwmon->update_lock,"&hwmon->update_lock",& __key);
  }
  
#line 349 
  efx_mcdi_mon_update(efx);
  
#line 355 
  n_attrs = n_sensors * 6U;
  
#line 356 
  hwmon->attrs = (struct efx_mcdi_mon_attribute *)kcalloc_3((unsigned long)n_attrs,80UL,208U);
  
#line 357 
  if (hwmon->attrs == (struct efx_mcdi_mon_attribute *)0) {
    
#line 358 
    rc = -12;
    
#line 359 
    goto fail;
  }
  else ;
  
#line 361 
  hwmon->group.attrs = (struct attribute **)kcalloc_3((unsigned long)(n_attrs + 1U),8UL,208U);
  
#line 363 
  if (hwmon->group.attrs == (struct attribute **)0) {
    
#line 364 
    rc = -12;
    
#line 365 
    goto fail;
  }
  else ;
  
#line 368 
  i = 0;
  
#line 368 
  j = -1;
  
#line 368 
  type = -1;
  ldv_55737: 
#line 369 
  ;
  {
    enum efx_hwmon_type hwmon_type;
    char const *hwmon_prefix;
    unsigned int hwmon_index;
    u16 min1;
    u16 max1;
    u16 min2;
    u16 max2;
    ldv_55674: 
#line 445 
    ;
    
#line 376 
    type += 1;
    
#line 378 
    if (((unsigned int)type & 31U) == 0U) {
      unsigned int tmp_5;
      
#line 379 
      page = (unsigned int)(type / 32);
      
#line 380 
      j = -1;
      
#line 381 
      if (page == n_pages) 
#line 382 
                           goto hwmon_register; else ;
      
#line 384 
      ((efx_dword_t *)(& inbuf))->u32[0] = page;
      
#line 386 
      rc = efx_mcdi_rpc(efx,65U,(efx_dword_t const *)(& inbuf),4UL,(efx_dword_t *)(& outbuf),252UL,& outlen);
      
#line 390 
      if (rc != 0) 
#line 391 
                   goto fail; else ;
      
#line 392 
      if (outlen <= 3UL) {
        
#line 393 
        rc = -5;
        
#line 394 
        goto fail;
      }
      else ;
      
#line 397 
      mask = ((efx_dword_t *)(& outbuf))->u32[0] & 2147483647U;
      
#line 403 
      if (0 != 0) 
#line 403 
                  tmp_5 = (((unsigned int)((((((((((unsigned long long)mask & 1ULL) != 0ULL) + (((unsigned long long)mask & 2ULL) != 0ULL)) + (((unsigned long long)mask & 4ULL) != 0ULL)) + (((unsigned long long)mask & 8ULL) != 0ULL)) + (((unsigned long long)mask & 16ULL) != 0ULL)) + (((unsigned long long)mask & 32ULL) != 0ULL)) + (((unsigned long long)mask & 64ULL) != 0ULL)) + (((unsigned long long)mask & 128ULL) != 0ULL)) + (unsigned int)((((((((((unsigned long long)(mask >> 8) & 1ULL) != 0ULL) + (((unsigned long long)(mask >> 8) & 2ULL) != 0ULL)) + (((unsigned long long)(mask >> 8) & 4ULL) != 0ULL)) + (((unsigned long long)(mask >> 8) & 8ULL) != 0ULL)) + (((unsigned long long)(mask >> 8) & 16ULL) != 0ULL)) + (((unsigned long long)(mask >> 8) & 32ULL) != 0ULL)) + (((unsigned long long)(mask >> 8) & 64ULL) != 0ULL)) + (((unsigned long long)(mask >> 8) & 128ULL) != 0ULL))) + ((unsigned int)((((((((((unsigned long long)(mask >> 16) & 1ULL) != 0ULL) + (((unsigned long long)(mask >> 16) & 2ULL) != 0ULL)) + (((unsigned long long)(mask >> 16) & 4ULL) != 0ULL)) + (((unsigned long long)(mask >> 16) & 8ULL) != 0ULL)) + (((unsigned long long)(mask >> 16) & 16ULL) != 0ULL)) + (((unsigned long long)(mask >> 16) & 32ULL) != 0ULL)) + (((unsigned long long)(mask >> 16) & 64ULL) != 0ULL)) + (((unsigned long long)(mask >> 16) & 128ULL) != 0ULL)) + (unsigned int)((((((((((unsigned long long)(mask >> 24) & 1ULL) != 0ULL) + (((unsigned long long)(mask >> 24) & 2ULL) != 0ULL)) + (((unsigned long long)(mask >> 24) & 4ULL) != 0ULL)) + (((unsigned long long)(mask >> 24) & 8ULL) != 0ULL)) + (((unsigned long long)(mask >> 24) & 16ULL) != 0ULL)) + (((unsigned long long)(mask >> 24) & 32ULL) != 0ULL)) + (((unsigned long long)(mask >> 24) & 64ULL) != 0ULL)) + (((unsigned long long)(mask >> 24) & 128ULL) != 0ULL)))) * 8U + 4U;
      else {
        unsigned int tmp_4;
        
#line 403 
        tmp_4 = __arch_hweight32(mask);
        
#line 403 
        tmp_5 = tmp_4 * 8U + 4U;
      }
      
#line 403 
      ;
      
#line 403 
      if ((unsigned long)tmp_5 > outlen) {
        
#line 404 
        rc = -5;
        
#line 405 
        goto fail;
      }
      else ;
    }
    else ;
    
#line 408 
    if (((unsigned int)(1 << type % 32) & mask) == 0U) 
#line 410 
                                                       goto ldv_55674; else 
                                                                    
#line 413 
                                                                    goto ldv_55675;
    ldv_55675: 
#line 414 
    ;
    
#line 409 
    j += 1;
    
#line 411 
    if ((unsigned int)type <= 45U) {
      
#line 412 
      hwmon_type = efx_mcdi_sensor_type[type].hwmon_type;
      
#line 415 
      if (hwmon_type != (unsigned int)EFX_HWMON_UNKNOWN && efx_mcdi_sensor_type[type].port >= 0) {
        unsigned int tmp_6;
        
#line 417 
        tmp_6 = efx_port_num(efx);
        
#line 417 
        ;
        
#line 417 
        if ((unsigned int)efx_mcdi_sensor_type[type].port != tmp_6) 
#line 419 
                                                                    goto ldv_55679; else ;
      }
      else ;
    }
    else 
#line 421 
         hwmon_type = EFX_HWMON_UNKNOWN;
    
#line 424 
    switch ((unsigned int)hwmon_type) {
      unsigned int tmp_7;
      case (unsigned int)1: 
#line 425 
      ;
      
#line 426 
      hwmon_prefix = "temp";
      
#line 427 
      n_temp += 1U;
      
#line 427 
      hwmon_index = n_temp;
      
#line 428 
      goto ldv_55681;
      case (unsigned int)2: 
#line 429 
      ;
      
#line 434 
      hwmon_prefix = "fan";
      
#line 435 
      n_cool += 1U;
      
#line 435 
      hwmon_index = n_cool;
      
#line 436 
      goto ldv_55681;
      default: 
#line 437 
      ;
      
#line 438 
      hwmon_prefix = "in";
      
#line 439 
      tmp_7 = n_in;
      
#line 439 
      n_in += 1U;
      
#line 439 
      hwmon_index = tmp_7;
      
#line 440 
      goto ldv_55681;
      case (unsigned int)4: 
#line 441 
      ;
      
#line 442 
      hwmon_prefix = "curr";
      
#line 443 
      n_curr += 1U;
      
#line 443 
      hwmon_index = n_curr;
      
#line 444 
      goto ldv_55681;
      case (unsigned int)5: 
#line 445 
      ;
      
#line 446 
      hwmon_prefix = "power";
      
#line 447 
      n_power += 1U;
      
#line 447 
      hwmon_index = n_power;
      
#line 448 
      goto ldv_55681;
    }
    ldv_55681: 
#line 451 
    ;
    
#line 451 
    min1 = (unsigned short)((efx_dword_t *)(& outbuf) + ((unsigned long)j * 8UL + (unsigned long)4U))->u32[0];
    
#line 453 
    max1 = (unsigned short)(((efx_dword_t *)(& outbuf) + ((unsigned long)j * 8UL + (unsigned long)4U))->u32[0] >> 16);
    
#line 455 
    min2 = (unsigned short)((efx_dword_t *)(& outbuf) + ((unsigned int)j + 1U) * 8U)->u32[0];
    
#line 457 
    max2 = (unsigned short)(((efx_dword_t *)(& outbuf) + ((unsigned int)j + 1U) * 8U)->u32[0] >> 16);
    
#line 460 
    if ((int)min1 != (int)max1) {
      
#line 461 
      snprintf((char *)(& name),12UL,"%s%u_input",hwmon_prefix,hwmon_index);
      
#line 463 
      efx_mcdi_mon_add_attr(efx,(char const *)(& name),& efx_mcdi_mon_show_value,(unsigned int)i,(unsigned int)type,0U);
      
#line 466 
      if (hwmon_type != (unsigned int)EFX_HWMON_POWER) {
        
#line 467 
        snprintf((char *)(& name),12UL,"%s%u_min",hwmon_prefix,hwmon_index);
        
#line 469 
        efx_mcdi_mon_add_attr(efx,(char const *)(& name),& efx_mcdi_mon_show_limit,(unsigned int)i,(unsigned int)type,(unsigned int)min1);
      }
      else ;
      
#line 474 
      snprintf((char *)(& name),12UL,"%s%u_max",hwmon_prefix,hwmon_index);
      
#line 476 
      efx_mcdi_mon_add_attr(efx,(char const *)(& name),& efx_mcdi_mon_show_limit,(unsigned int)i,(unsigned int)type,(unsigned int)max1);
      
#line 480 
      if ((int)min2 != (int)max2) {
        
#line 484 
        snprintf((char *)(& name),12UL,"%s%u_crit",hwmon_prefix,hwmon_index);
        
#line 486 
        efx_mcdi_mon_add_attr(efx,(char const *)(& name),& efx_mcdi_mon_show_limit,(unsigned int)i,(unsigned int)type,(unsigned int)max2);
      }
      else ;
    }
    else ;
    
#line 492 
    snprintf((char *)(& name),12UL,"%s%u_alarm",hwmon_prefix,hwmon_index);
    
#line 494 
    efx_mcdi_mon_add_attr(efx,(char const *)(& name),& efx_mcdi_mon_show_alarm,(unsigned int)i,(unsigned int)type,0U);
    
#line 497 
    if ((unsigned int)type <= 45U && efx_mcdi_sensor_type[type].label != (char const *)0) {
      
#line 499 
      snprintf((char *)(& name),12UL,"%s%u_label",hwmon_prefix,hwmon_index);
      
#line 501 
      efx_mcdi_mon_add_attr(efx,(char const *)(& name),& efx_mcdi_mon_show_label,(unsigned int)i,(unsigned int)type,0U);
    }
    else ;
  }
  ldv_55679: 
#line 505 
  ;
  
#line 368 
  i += 1;
  
#line 368 
  goto ldv_55737;
  hwmon_register: 
#line 506 
  ;
  
#line 507 
  hwmon->groups[0] = (struct attribute_group const *)(& hwmon->group);
  
#line 508 
  hwmon->device = hwmon_device_register_with_groups(& (efx->pci_dev)->dev,"sfc",(void *)0,(struct attribute_group const **)(& hwmon->groups));
  
#line 511 
  tmp_9 = IS_ERR((void const *)hwmon->device);
  
#line 511 
  if ((int)tmp_9 != 0) {
    long tmp_8;
    
#line 512 
    tmp_8 = PTR_ERR((void const *)hwmon->device);
    
#line 512 
    rc = (int)tmp_8;
    
#line 513 
    goto fail;
  }
  else ;
  
#line 516 
  __retres = 0;
  
#line 516 
  goto return_label;
  fail: 
#line 518 
  ;
  
#line 519 
  efx_mcdi_mon_remove(efx);
  
#line 520 
  __retres = rc;
  return_label: 
#line 520 
                return __retres;
}


#line 523  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_mon.c"
void efx_mcdi_mon_remove(struct efx_nic *efx)
{
  
#line 525 
  struct efx_mcdi_mon *hwmon = efx_mcdi_mon(efx);
  
#line 527 
  if (hwmon->device != (struct device *)0) 
#line 528 
                                           hwmon_device_unregister(hwmon->device); else ;
  
#line 529 
  kfree((void const *)hwmon->attrs);
  
#line 530 
  kfree((void const *)hwmon->group.attrs);
  
#line 531 
  efx_nic_free_buffer(efx,& hwmon->dma_buf);
  
#line 532 
  return;
}


#line 79  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi_mon.c.aux"
static long PTR_ERR(void const *ptr)
{
  long tmp;
  
#line 82 
  tmp = ldv_ptr_err(ptr);
  
#line 82 
  return tmp;
}


#line 86  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi_mon.c.aux"
static bool IS_ERR(void const *ptr)
{
  bool __retres;
  long ret;
  
#line 90 
  ret = ldv_is_err(ptr);
  
#line 91 
  __retres = (_Bool)(ret != 0L);
  
#line 91 
  return __retres;
}


#line 434  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi_mon.c.aux"
static void *kcalloc_3(size_t n, size_t size, gfp_t flags)
{
  void *tmp;
  
#line 437 
  tmp = ldv_kcalloc(n,size,flags);
  
#line 437 
  return tmp;
}


#line 888  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi_mon.c.aux"
static void ldv_mutex_lock_87_1(struct mutex *ldv_func_arg1)
{
  
#line 892 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"update_lock_of_efx_mcdi_mon");
  
#line 893 
  return;
}


#line 896  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi_mon.c.aux"
static void ldv_mutex_unlock_88_1(struct mutex *ldv_func_arg1)
{
  
#line 900 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"update_lock_of_efx_mcdi_mon");
  
#line 901 
  return;
}

void __builtin_prefetch(void const * , ...);


#line 437  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int fls(int x)
{
  int __retres;
  int r;
  
#line 440 
  ldv_inline_asm();
  
#line 464 
  __retres = r + 1;
  
#line 464 
  return __retres;
}


#line 479  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int fls64(__u64 x)
{
  int __retres;
  
#line 481 
  int bitpos = -1;
  
#line 482 
  ldv_inline_asm();
  
#line 490 
  __retres = bitpos + 1;
  
#line 490 
  return __retres;
}


#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitops.h"
__inline static unsigned int fls_long(unsigned long l)
{
  unsigned int __retres;
  int tmp_0;
  
#line 178 
  tmp_0 = fls64((unsigned long long)l);
  
#line 178 
  __retres = (unsigned int)tmp_0;
  
#line 178 
  return __retres;
}


#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/log2.h"
int ____ilog2_NaN(void);


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/log2.h"
__inline static int __ilog2_u32(u32 n)
{
  int __retres;
  int tmp;
  
#line 34 
  tmp = fls((int)n);
  
#line 34 
  __retres = tmp + -1;
  
#line 34 
  return __retres;
}


#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/log2.h"
__inline static unsigned long __roundup_pow_of_two(unsigned long n)
{
  unsigned long __retres;
  unsigned int tmp;
  
#line 63 
  tmp = fls_long(n + 18446744073709551615UL);
  
#line 63 
  __retres = 1UL << tmp;
  
#line 63 
  return __retres;
}


#line 98  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/atomic.h"
static void atomic_inc_1(atomic_t *v);


#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_api_smp.h"
int _raw_spin_trylock_bh(raw_spinlock_t *);


#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_bh_1(spinlock_t *lock)
{
  
#line 406 
  _raw_spin_unlock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 407 
  return;
}


#line 460 
static void ldv_spin_unlock_bh_89(spinlock_t *lock);


#line 503  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static int spin_trylock_bh(spinlock_t *lock)
{
  int tmp;
  
#line 505 
  tmp = _raw_spin_trylock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 505 
  return tmp;
}


#line 511 
static int ldv_spin_trylock_bh_88(spinlock_t *lock);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
int ldv_undef_int(void);


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/in.h"
__inline static bool ipv4_is_multicast(__be32 addr)
{
  bool __retres;
  
#line 49 
  __retres = (_Bool)((addr & 240U) == 224U);
  
#line 49 
  return __retres;
}


#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmdebug.h"
void dump_page(struct page *, char const *);


#line 232  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
static int ldv_del_timer_sync_87(struct timer_list *ldv_func_arg1);


#line 322  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/gfp.h"
struct page *alloc_pages_current(gfp_t, unsigned int);


#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/gfp.h"
__inline static struct page *alloc_pages(gfp_t gfp_mask, unsigned int order)
{
  struct page *tmp;
  
#line 327 
  tmp = alloc_pages_current(gfp_mask,order);
  
#line 327 
  return tmp;
}


#line 366 
void __free_pages(struct page *, unsigned int);


#line 542  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kcalloc_4(size_t n, size_t size, gfp_t flags);


#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address, unsigned int n)
{
  
#line 133 
  return;
}


#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
int net_ratelimit(void);


#line 400  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/page-flags.h"
__inline static int PageTail(struct page const *page)
{
  int tmp;
  
#line 400 
  tmp = constant_test_bit(15L,(unsigned long const volatile *)(& page->flags));
  
#line 400 
  return tmp;
}


#line 440  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
__inline static struct page *compound_head_by_tail(struct page *tail)
{
  struct page *__retres;
  int tmp;
  
#line 442 
  struct page *head = tail->__anonCompField_page_55.first_page;
  
#line 443 
  ldv_inline_asm();
  
#line 450 
  tmp = PageTail((struct page const *)tail);
  
#line 450 
  if ((long)(tmp != 0) != 0L) {
    
#line 451 
    __retres = head;
    
#line 451 
    goto return_label;
  }
  else ;
  
#line 452 
  __retres = tail;
  return_label: 
#line 452 
                return __retres;
}


#line 461  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
__inline static struct page *compound_head(struct page *page)
{
  struct page *__retres;
  int tmp_0;
  
#line 463 
  tmp_0 = PageTail((struct page const *)page);
  
#line 463 
  if ((long)(tmp_0 != 0) != 0L) {
    struct page *tmp;
    
#line 464 
    tmp = compound_head_by_tail(page);
    
#line 464 
    __retres = tmp;
    
#line 464 
    goto return_label;
  }
  else ;
  
#line 465 
  __retres = page;
  return_label: 
#line 465 
                return __retres;
}


#line 496  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
__inline static int page_count(struct page *page)
{
  int tmp_0;
  struct page *tmp;
  
#line 498 
  tmp = compound_head(page);
  
#line 498 
  tmp_0 = atomic_read((atomic_t const *)(& tmp->__anonCompField_page_51.__anonCompField___anonstruct_168_50.__anonCompField___anonunion_170_49._count));
  
#line 498 
  return tmp_0;
}


#line 532 
bool __get_page_tail(struct page *);


#line 534  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
__inline static void get_page(struct page *page)
{
  int tmp_0;
  int tmp_1;
  
#line 536 
  tmp_0 = PageTail((struct page const *)page);
  
#line 536 
  if ((long)(tmp_0 != 0) != 0L) {
    bool tmp;
    
#line 537 
    tmp = __get_page_tail(page);
    
#line 537 
    if ((long)((int)tmp != 0) != 0L) 
#line 538 
                                     goto return_label; else ;
  }
  else ;
  
#line 543 
  tmp_1 = atomic_read((atomic_t const *)(& page->__anonCompField_page_51.__anonCompField___anonstruct_168_50.__anonCompField___anonunion_170_49._count));
  
#line 543 
  if ((long)(tmp_1 <= 0) != 0L) {
    
#line 543 
    dump_page(page,"VM_BUG_ON_PAGE(");
    
#line 544 
    ldv_inline_asm();
    
#line 543 
    ;
  }
  else ;
  
#line 544 
  atomic_inc_1(& page->__anonCompField_page_51.__anonCompField___anonstruct_168_50.__anonCompField___anonunion_170_49._count);
  return_label: 
#line 545 
                return;
}


#line 569 
void put_page(struct page *);


#line 945  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
__inline static void *lowmem_page_address(struct page const *page)
{
  void *__retres;
  
#line 947 
  __retres = (void *)((unsigned long)((unsigned long long)(((long)page + 24189255811072L) / 64L) << 12) + 18446612132314218496UL);
  
#line 947 
  return __retres;
}


#line 1031  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
__inline static bool page_is_pfmemalloc(struct page *page)
{
  bool __retres;
  
#line 1037 
  __retres = (_Bool)(page->__anonCompField_page_51.__anonCompField___anonstruct_168_46.index == 18446744073709551615UL);
  
#line 1037 
  return __retres;
}


#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction)
{
  int __retres;
  
#line 76 
  __retres = (unsigned int)dma_direction <= 2U;
  
#line 76 
  return __retres;
}


#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-debug.h"
void debug_dma_map_page(struct device *, struct page *, size_t, size_t, int, dma_addr_t, bool);


#line 42 
void debug_dma_mapping_error(struct device *, dma_addr_t);


#line 44 
void debug_dma_unmap_page(struct device *, dma_addr_t, size_t, int, bool);


#line 59 
void debug_dma_sync_single_for_cpu(struct device *, dma_addr_t, size_t, int);


#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
extern struct dma_map_ops *dma_ops;


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev)
{
  struct dma_map_ops *__retres;
  
#line 37 
  if ((long)(dev == (struct device *)0) != 0L || dev->archdata.dma_ops == (struct dma_map_ops *)0) {
    
#line 38 
    __retres = dma_ops;
    
#line 38 
    goto return_label;
  }
  else {
    
#line 40 
    __retres = dev->archdata.dma_ops;
    
#line 40 
    goto return_label;
  }
  return_label: 
#line 37 
                return __retres;
}


#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_page(struct device *dev, struct page *page, size_t offset, size_t size, enum dma_data_direction dir)
{
  dma_addr_t addr;
  void *tmp_0;
  int tmp_1;
  
#line 80 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 83 
  ;
  
#line 83 
  tmp_0 = lowmem_page_address((struct page const *)page);
  
#line 83 
  ;
  
#line 83 
  kmemcheck_mark_initialized(tmp_0 + offset,(unsigned int)size);
  
#line 84 
  tmp_1 = valid_dma_direction((int)dir);
  
#line 84 
  if ((long)(tmp_1 == 0) != 0L) {
    
#line 86 
    ldv_inline_asm();
    
#line 84 
    ;
  }
  else ;
  
#line 85 
  addr = (*(ops->map_page))(dev,page,offset,size,dir,(struct dma_attrs *)0);
  
#line 86 
  debug_dma_map_page(dev,page,offset,size,(int)dir,addr,(_Bool)0);
  
#line 88 
  return addr;
}


#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_page(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir)
{
  int tmp_0;
  
#line 94 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 96 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 96 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 98 
    ldv_inline_asm();
    
#line 96 
    ;
  }
  else ;
  
#line 97 
  if (ops->unmap_page != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction , struct dma_attrs *))0) 
    
#line 98 
    (*(ops->unmap_page))(dev,addr,size,dir,(struct dma_attrs *)0); else ;
  
#line 99 
  debug_dma_unmap_page(dev,addr,size,(int)dir,(_Bool)0);
  
#line 100 
  return;
}


#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_cpu(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir)
{
  int tmp_0;
  
#line 106 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 108 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 108 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 110 
    ldv_inline_asm();
    
#line 108 
    ;
  }
  else ;
  
#line 109 
  if (ops->sync_single_for_cpu != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction ))0) 
    
#line 110 
    (*(ops->sync_single_for_cpu))(dev,addr,size,dir); else ;
  
#line 111 
  debug_dma_sync_single_for_cpu(dev,addr,size,(int)dir);
  
#line 112 
  return;
}


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
__inline static int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
  int __retres;
  
#line 49 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 50 
  debug_dma_mapping_error(dev,dma_addr);
  
#line 51 
  if (ops->mapping_error != (int (*)(struct device *, dma_addr_t ))0) {
    int tmp_0;
    
#line 52 
    tmp_0 = (*(ops->mapping_error))(dev,dma_addr);
    
#line 52 
    __retres = tmp_0;
    
#line 52 
    goto return_label;
  }
  else ;
  
#line 54 
  __retres = dma_addr == 0ULL;
  return_label: 
#line 54 
                return __retres;
}


#line 235  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_frag_size_set(skb_frag_t *frag, unsigned int size)
{
  
#line 237 
  frag->size = size;
  
#line 238 
  return;
}


#line 926  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_set_hash(struct sk_buff *skb, __u32 hash, enum pkt_hash_types type)
{
  
#line 928 
  skb->l4_hash = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))(type == (unsigned int)PKT_HASH_TYPE_L4);
  
#line 929 
  skb->sw_hash = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U;
  
#line 930 
  skb->hash = hash;
  
#line 931 
  return;
}


#line 976  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_end_pointer(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 978 
  __retres = skb->head + skb->end;
  
#line 978 
  return __retres;
}


#line 1567  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static bool skb_is_nonlinear(struct sk_buff const *skb)
{
  bool __retres;
  
#line 1569 
  __retres = (_Bool)(skb->data_len != 0U);
  
#line 1569 
  return __retres;
}


#line 1599  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void __skb_fill_page_desc(struct sk_buff *skb, int i, struct page *page, int off, int size)
{
  unsigned char *tmp;
  bool tmp_0;
  
#line 1602 
  tmp = skb_end_pointer((struct sk_buff const *)skb);
  
#line 1602 
  skb_frag_t *frag = & ((struct skb_shared_info *)tmp)->frags[i];
  
#line 1609 
  frag->page.p = page;
  
#line 1610 
  frag->page_offset = (unsigned int)off;
  
#line 1611 
  skb_frag_size_set(frag,(unsigned int)size);
  
#line 1613 
  page = compound_head(page);
  
#line 1614 
  tmp_0 = page_is_pfmemalloc(page);
  
#line 1614 
  if ((int)tmp_0 != 0) 
#line 1615 
                       skb->pfmemalloc = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U; else ;
  
#line 1616 
  return;
}


#line 1632  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_fill_page_desc(struct sk_buff *skb, int i, struct page *page, int off, int size)
{
  unsigned char *tmp;
  
#line 1635 
  __skb_fill_page_desc(skb,i,page,off,size);
  
#line 1636 
  tmp = skb_end_pointer((struct sk_buff const *)skb);
  
#line 1636 
  ((struct skb_shared_info *)tmp)->nr_frags = (unsigned char)((unsigned int)((unsigned char)i) + 1U);
  
#line 1637 
  return;
}


#line 1650  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_tail_pointer(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 1652 
  __retres = skb->head + skb->tail;
  
#line 1652 
  return __retres;
}


#line 1689  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)
{
  bool tmp_1;
  
#line 1691 
  unsigned char *tmp = skb_tail_pointer((struct sk_buff const *)skb);
  
#line 1692 
  tmp_1 = skb_is_nonlinear((struct sk_buff const *)skb);
  
#line 1692 
  if ((long)((int)tmp_1 != 0) != 0L) {
    
#line 1694 
    ldv_inline_asm();
    
#line 1692 
    ;
  }
  else ;
  
#line 1693 
  skb->tail += len;
  
#line 1694 
  skb->len += len;
  
#line 1695 
  return tmp;
}


#line 1789  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_reserve(struct sk_buff *skb, int len)
{
  
#line 1791 
  skb->data += len;
  
#line 1792 
  skb->tail += (unsigned int)len;
  
#line 1793 
  return;
}


#line 2140 
struct sk_buff *__netdev_alloc_skb(struct net_device *, unsigned int, gfp_t);


#line 2156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct sk_buff *netdev_alloc_skb(struct net_device *dev, unsigned int length)
{
  struct sk_buff *tmp;
  
#line 2159 
  tmp = __netdev_alloc_skb(dev,length,32U);
  
#line 2159 
  return tmp;
}


#line 3305  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_record_rx_queue(struct sk_buff *skb, u16 rx_queue)
{
  
#line 3307 
  skb->queue_mapping = (unsigned short)((unsigned int)rx_queue + 1U);
  
#line 3308 
  return;
}


#line 3310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static u16 skb_get_rx_queue(struct sk_buff const *skb)
{
  u16 __retres;
  
#line 3312 
  __retres = (unsigned short)((unsigned int)skb->queue_mapping + 65535U);
  
#line 3312 
  return __retres;
}


#line 3426  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_checksum_none_assert(struct sk_buff const *skb)
{
  
#line 3428 
  return;
}


#line 2943  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
int netif_receive_skb_sk(struct sock *, struct sk_buff *);


#line 2944  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static int netif_receive_skb(struct sk_buff *skb)
{
  int tmp;
  
#line 2946 
  tmp = netif_receive_skb_sk(skb->sk,skb);
  
#line 2946 
  return tmp;
}


#line 2950 
struct sk_buff *napi_get_frags(struct napi_struct *);


#line 2951 
gro_result_t napi_gro_frags(struct napi_struct *);


#line 751  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
extern struct bus_type pci_bus_type;


#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/iommu.h"
bool iommu_present(struct bus_type *);


#line 255  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/ip.h"
__inline static bool ip_is_fragment(struct iphdr const *iph)
{
  bool __retres;
  
#line 257 
  __retres = (_Bool)(((int)iph->frag_off & 65343) != 0);
  
#line 257 
  return __retres;
}


#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__be16 eth_type_trans(struct sk_buff *, struct net_device *);


#line 121  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/busy_poll.h"
__inline static void skb_mark_napi_id(struct sk_buff *skb, struct napi_struct *napi)
{
  
#line 124 
  skb->__anonCompField_sk_buff_90.napi_id = napi->napi_id;
  
#line 125 
  return;
}


#line 545  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
__inline static bool efx_channel_busy_polling(struct efx_channel *channel)
{
  bool __retres;
  {
    
#line 547 
    int __ret_warn_on = (channel->state & 3U) == 0U;
    
#line 547 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 547 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h",547); else ;
    
#line 547 
    long tmp = (long)(__ret_warn_on != 0);
  }
  
#line 548 
  __retres = (_Bool)((channel->state & 18U) != 0U);
  
#line 548 
  return __retres;
}


#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
void efx_rx_config_page_split(struct efx_nic *efx);


#line 42 
int efx_probe_rx_queue(struct efx_rx_queue *rx_queue);


#line 43 
void efx_remove_rx_queue(struct efx_rx_queue *rx_queue);


#line 44 
void efx_init_rx_queue(struct efx_rx_queue *rx_queue);


#line 45 
void efx_fini_rx_queue(struct efx_rx_queue *rx_queue);


#line 47 
void efx_rx_slow_fill(unsigned long context);


#line 48 
void __efx_rx_packet(struct efx_channel *channel);


#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
__inline static void efx_rx_flush_packet(struct efx_channel *channel)
{
  
#line 53 
  if (channel->rx_pkt_n_frags != 0U) 
#line 54 
                                     __efx_rx_packet(channel); else ;
  
#line 55 
  return;
}


#line 56 
void efx_schedule_slow_fill(struct efx_rx_queue *rx_queue);


#line 164 
int efx_filter_rfs(struct net_device *net_dev, struct sk_buff const *skb, u16 rxq_index, u32 flow_id);


#line 166 
bool __efx_filter_rfs_expire(struct efx_nic *efx, unsigned int quota);


#line 178 
bool efx_filter_is_mc_recipient(struct efx_filter_spec const *spec);


#line 572  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
void __efx_rx_skb_attach_timestamp(struct efx_channel *channel, struct sk_buff *skb);


#line 574  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
__inline static void efx_rx_skb_attach_timestamp(struct efx_channel *channel, struct sk_buff *skb)
{
  
#line 577 
  if (channel->sync_events_state == (unsigned int)SYNC_EVENTS_VALID) 
    
#line 578 
    __efx_rx_skb_attach_timestamp(channel,skb); else ;
  
#line 579 
  return;
}


#line 617  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
__inline static int efx_nic_probe_rx(struct efx_rx_queue *rx_queue)
{
  int tmp;
  
#line 619 
  tmp = (*(((rx_queue->efx)->type)->rx_probe))(rx_queue);
  
#line 619 
  return tmp;
}


#line 621  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
__inline static void efx_nic_init_rx(struct efx_rx_queue *rx_queue)
{
  
#line 623 
  (*(((rx_queue->efx)->type)->rx_init))(rx_queue);
  
#line 624 
  return;
}


#line 625  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
__inline static void efx_nic_remove_rx(struct efx_rx_queue *rx_queue)
{
  
#line 627 
  (*(((rx_queue->efx)->type)->rx_remove))(rx_queue);
  
#line 628 
  return;
}


#line 629  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
__inline static void efx_nic_notify_rx_desc(struct efx_rx_queue *rx_queue)
{
  
#line 631 
  (*(((rx_queue->efx)->type)->rx_write))(rx_queue);
  
#line 632 
  return;
}


#line 633  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
__inline static void efx_nic_generate_fill_event(struct efx_rx_queue *rx_queue)
{
  
#line 635 
  (*(((rx_queue->efx)->type)->rx_defer_refill))(rx_queue);
  
#line 636 
  return;
}


#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c"
static unsigned int rx_refill_threshold;

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c"
__inline static u8 *efx_rx_buf_va(struct efx_rx_buffer *buf)
{
  u8 *__retres;
  void *tmp;
  
#line 62 
  tmp = lowmem_page_address((struct page const *)buf->page);
  
#line 62 
  ;
  
#line 62 
  __retres = (u8 *)(tmp + (int)buf->page_offset);
  
#line 62 
  return __retres;
}


#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c"
__inline static u32 efx_rx_buf_hash(struct efx_nic *efx, u8 const *eh)
{
  u32 tmp;
  
#line 68 
  tmp = __le32_to_cpup((__le32 const *)(eh + efx->rx_packet_hash_offset));
  
#line 68 
  return tmp;
}


#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c"
__inline static struct efx_rx_buffer *efx_rx_buf_next(struct efx_rx_queue *rx_queue, struct efx_rx_buffer *rx_buf)
{
  struct efx_rx_buffer *__retres;
  struct efx_rx_buffer *tmp_0;
  
#line 81 
  tmp_0 = efx_rx_buffer(rx_queue,rx_queue->ptr_mask);
  
#line 81 
  ;
  
#line 81 
  if ((long)(tmp_0 == rx_buf) != 0L) {
    struct efx_rx_buffer *tmp;
    
#line 82 
    tmp = efx_rx_buffer(rx_queue,0U);
    
#line 82 
    __retres = tmp;
    
#line 82 
    goto return_label;
  }
  else {
    
#line 84 
    __retres = rx_buf + 1U;
    
#line 84 
    goto return_label;
  }
  return_label: 
#line 81 
                return __retres;
}


#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c"
__inline static void efx_sync_rx_buffer(struct efx_nic *efx, struct efx_rx_buffer *rx_buf, unsigned int len)
{
  
#line 91 
  dma_sync_single_for_cpu(& (efx->pci_dev)->dev,rx_buf->dma_addr,(unsigned long)len,(enum dma_data_direction)DMA_FROM_DEVICE);
  
#line 92 
  return;
}


#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c"
void efx_rx_config_page_split(struct efx_nic *efx)
{
  
#line 97 
  efx->rx_page_buf_step = ((efx->rx_dma_len + efx->rx_ip_align) + 63U) & 4294967232U;
  
#line 99 
  if (efx->rx_buffer_order == 0U) 
#line 99 
                                  efx->rx_bufs_per_page = 4032U / efx->rx_page_buf_step; else 
                                                                    
#line 99 
                                                                    efx->rx_bufs_per_page = 1U;
  
#line 102 
  efx->rx_buffer_truesize = (unsigned int)((4096UL << efx->rx_buffer_order) / (unsigned long)efx->rx_bufs_per_page);
  
#line 104 
  efx->rx_pages_per_batch = (efx->rx_bufs_per_page + 7U) / efx->rx_bufs_per_page;
  
#line 105 
  return;
}


#line 109  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c"
static struct page *efx_reuse_page(struct efx_rx_queue *rx_queue)
{
  struct page *__retres;
  struct page *page;
  struct efx_rx_page_state *state;
  unsigned int index;
  int tmp_0;
  
#line 111 
  struct efx_nic *efx = rx_queue->efx;
  
#line 116 
  index = rx_queue->page_remove & rx_queue->page_ptr_mask;
  
#line 117 
  page = *(rx_queue->page_ring + index);
  
#line 118 
  if (page == (struct page *)0) {
    
#line 119 
    __retres = (struct page *)0;
    
#line 119 
    goto return_label;
  }
  else ;
  
#line 121 
  *(rx_queue->page_ring + index) = (struct page *)0;
  
#line 123 
  if (rx_queue->page_remove != rx_queue->page_add) 
#line 124 
                                                   rx_queue->page_remove += 1U; else ;
  
#line 127 
  tmp_0 = page_count(page);
  
#line 127 
  if (tmp_0 == 1) {
    
#line 128 
    rx_queue->page_recycle_count += 1U;
    
#line 129 
    __retres = page;
    
#line 129 
    goto return_label;
  }
  else {
    
#line 131 
    state = (struct efx_rx_page_state *)lowmem_page_address((struct page const *)page);
    
#line 132 
    dma_unmap_page(& (efx->pci_dev)->dev,state->dma_addr,4096UL << efx->rx_buffer_order,(enum dma_data_direction)DMA_FROM_DEVICE);
    
#line 135 
    put_page(page);
    
#line 136 
    rx_queue->page_recycle_failed += 1U;
  }
  
#line 139 
  __retres = (struct page *)0;
  return_label: 
#line 139 
                return __retres;
}


#line 152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c"
static int efx_init_rx_buffers(struct efx_rx_queue *rx_queue, bool atomic)
{
  int __retres;
  struct efx_rx_buffer *rx_buf;
  struct page *page;
  unsigned int page_offset;
  struct efx_rx_page_state *state;
  dma_addr_t dma_addr;
  unsigned int index;
  unsigned int count;
  
#line 154 
  struct efx_nic *efx = rx_queue->efx;
  
#line 162 
  count = 0U;
  ldv_56404: 
#line 163 
  ;
  
#line 164 
  page = efx_reuse_page(rx_queue);
  
#line 165 
  if (page == (struct page *)0) {
    unsigned int tmp;
    int tmp_0;
    
#line 166 
    ;
    
#line 166 
    if ((int)atomic != 0) 
#line 166 
                          tmp = 16672U; else 
#line 166 
                                             tmp = 16848U;
    
#line 166 
    page = alloc_pages(tmp,efx->rx_buffer_order);
    
#line 169 
    if ((long)(page == (struct page *)0) != 0L) {
      
#line 170 
      __retres = -12;
      
#line 170 
      goto return_label;
    }
    else ;
    
#line 171 
    dma_addr = dma_map_page(& (efx->pci_dev)->dev,page,0UL,4096UL << efx->rx_buffer_order,(enum dma_data_direction)DMA_FROM_DEVICE);
    
#line 175 
    tmp_0 = dma_mapping_error(& (efx->pci_dev)->dev,dma_addr);
    
#line 175 
    if ((long)(tmp_0 != 0) != 0L) {
      
#line 177 
      __free_pages(page,efx->rx_buffer_order);
      
#line 178 
      __retres = -5;
      
#line 178 
      goto return_label;
    }
    else ;
    
#line 180 
    state = (struct efx_rx_page_state *)lowmem_page_address((struct page const *)page);
    
#line 181 
    state->dma_addr = dma_addr;
  }
  else {
    
#line 183 
    state = (struct efx_rx_page_state *)lowmem_page_address((struct page const *)page);
    
#line 184 
    dma_addr = state->dma_addr;
  }
  
#line 187 
  dma_addr += 64ULL;
  
#line 188 
  page_offset = 64U;
  ldv_56402: 
#line 189 
  ;
  
#line 191 
  index = rx_queue->added_count & rx_queue->ptr_mask;
  
#line 192 
  rx_buf = efx_rx_buffer(rx_queue,index);
  
#line 193 
  rx_buf->dma_addr = (unsigned long long)efx->rx_ip_align + dma_addr;
  
#line 194 
  rx_buf->page = page;
  
#line 195 
  rx_buf->page_offset = (unsigned short)((int)((unsigned short)efx->rx_ip_align) + (int)((unsigned short)page_offset));
  
#line 196 
  rx_buf->len = (unsigned short)efx->rx_dma_len;
  
#line 197 
  rx_buf->flags = (unsigned short)0U;
  
#line 198 
  rx_queue->added_count += 1U;
  
#line 199 
  get_page(page);
  
#line 200 
  dma_addr = (unsigned long long)efx->rx_page_buf_step + dma_addr;
  
#line 201 
  page_offset = efx->rx_page_buf_step + page_offset;
  
#line 202 
  if (efx->rx_page_buf_step + page_offset <= 4096U) 
#line 204 
                                                    goto ldv_56402; else 
                                                                    
#line 207 
                                                                    goto ldv_56403;
  ldv_56403: 
#line 208 
  ;
  
#line 204 
  rx_buf->flags = (unsigned short)1U;
  
#line 205 
  count += 1U;
  
#line 205 
  ;
  
#line 205 
  if (count < efx->rx_pages_per_batch) 
#line 207 
                                       goto ldv_56404; else 
#line 210 
                                                            goto ldv_56405;
  ldv_56405: 
#line 211 
  ;
  
#line 207 
  __retres = 0;
  return_label: 
#line 207 
                return __retres;
}


#line 213  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c"
static void efx_unmap_rx_buffer(struct efx_nic *efx, struct efx_rx_buffer *rx_buf)
{
  
#line 216 
  struct page *page = rx_buf->page;
  
#line 218 
  if (page != (struct page *)0) {
    
#line 219 
    struct efx_rx_page_state *state = lowmem_page_address((struct page const *)page);
    
#line 220 
    dma_unmap_page(& (efx->pci_dev)->dev,state->dma_addr,4096UL << efx->rx_buffer_order,(enum dma_data_direction)DMA_FROM_DEVICE);
  }
  else ;
  
#line 224 
  return;
}


#line 227  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c"
static void efx_free_rx_buffers(struct efx_rx_queue *rx_queue, struct efx_rx_buffer *rx_buf, unsigned int num_bufs)
{
  ldv_56417: 
#line 229 
  ;
  
#line 232 
  if (rx_buf->page != (struct page *)0) {
    
#line 233 
    put_page(rx_buf->page);
    
#line 234 
    rx_buf->page = (struct page *)0;
  }
  else ;
  
#line 236 
  rx_buf = efx_rx_buf_next(rx_queue,rx_buf);
  
#line 237 
  num_bufs -= 1U;
  
#line 237 
  if (num_bufs != 0U) 
#line 239 
                      goto ldv_56417; else 
#line 242 
                                           goto ldv_56418;
  ldv_56418: 
#line 243 
  ;
  
#line 244 
  return;
}


#line 244  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c"
static void efx_recycle_rx_page(struct efx_channel *channel, struct efx_rx_buffer *rx_buf)
{
  unsigned int index;
  
#line 247 
  struct page *page = rx_buf->page;
  
#line 248 
  struct efx_rx_queue *rx_queue = efx_channel_get_rx_queue(channel);
  
#line 249 
  struct efx_nic *efx = rx_queue->efx;
  
#line 253 
  if (((int)rx_buf->flags & 1) == 0) 
#line 254 
                                     goto return_label; else ;
  
#line 256 
  index = rx_queue->page_add & rx_queue->page_ptr_mask;
  
#line 257 
  if (*(rx_queue->page_ring + index) == (struct page *)0) {
    
#line 258 
    unsigned int read_index = rx_queue->page_remove & rx_queue->page_ptr_mask;
    
#line 265 
    if (read_index == index) 
#line 266 
                             rx_queue->page_remove += 1U; else ;
    
#line 267 
    *(rx_queue->page_ring + index) = page;
    
#line 268 
    rx_queue->page_add += 1U;
    
#line 269 
    goto return_label;
  }
  else ;
  
#line 271 
  rx_queue->page_recycle_full += 1U;
  
#line 272 
  efx_unmap_rx_buffer(efx,rx_buf);
  
#line 273 
  put_page(rx_buf->page);
  return_label: 
#line 274 
                return;
}


#line 276  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c"
static void efx_fini_rx_buffer(struct efx_rx_queue *rx_queue, struct efx_rx_buffer *rx_buf)
{
  
#line 280 
  if (rx_buf->page != (struct page *)0) 
#line 281 
                                        put_page(rx_buf->page); else ;
  
#line 284 
  if (((int)rx_buf->flags & 1) != 0) {
    
#line 285 
    efx_unmap_rx_buffer(rx_queue->efx,rx_buf);
    
#line 286 
    efx_free_rx_buffers(rx_queue,rx_buf,1U);
  }
  else ;
  
#line 288 
  rx_buf->page = (struct page *)0;
  
#line 289 
  return;
}


#line 292  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c"
static void efx_recycle_rx_pages(struct efx_channel *channel, struct efx_rx_buffer *rx_buf, unsigned int n_frags)
{
  
#line 296 
  struct efx_rx_queue *rx_queue = efx_channel_get_rx_queue(channel);
  ldv_56438: 
#line 297 
  ;
  
#line 299 
  efx_recycle_rx_page(channel,rx_buf);
  
#line 300 
  rx_buf = efx_rx_buf_next(rx_queue,rx_buf);
  
#line 301 
  n_frags -= 1U;
  
#line 301 
  if (n_frags != 0U) 
#line 303 
                     goto ldv_56438; else 
#line 306 
                                          goto ldv_56439;
  ldv_56439: 
#line 307 
  ;
  
#line 308 
  return;
}


#line 304  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c"
static void efx_discard_rx_packet(struct efx_channel *channel, struct efx_rx_buffer *rx_buf, unsigned int n_frags)
{
  
#line 308 
  struct efx_rx_queue *rx_queue = efx_channel_get_rx_queue(channel);
  
#line 310 
  efx_recycle_rx_pages(channel,rx_buf,n_frags);
  
#line 312 
  efx_free_rx_buffers(rx_queue,rx_buf,n_frags);
  
#line 313 
  return;
}


#line 327  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c"
void efx_fast_push_rx_descriptors(struct efx_rx_queue *rx_queue, bool atomic)
{
  unsigned int fill_level;
  unsigned int batch_size;
  int space;
  
#line 329 
  struct efx_nic *efx = rx_queue->efx;
  
#line 331 
  int rc = 0;
  
#line 333 
  if (! rx_queue->refill_enabled) 
#line 334 
                                  goto return_label; else ;
  
#line 337 
  fill_level = rx_queue->added_count - rx_queue->removed_count;
  
#line 339 
  if (rx_queue->fast_fill_trigger <= fill_level) 
#line 340 
                                                 goto out; else ;
  
#line 343 
  if ((long)(rx_queue->min_fill > fill_level) != 0L) {
    
#line 344 
    if (fill_level != 0U) 
#line 345 
                          rx_queue->min_fill = fill_level; else ;
  }
  else ;
  
#line 348 
  batch_size = efx->rx_pages_per_batch * efx->rx_bufs_per_page;
  
#line 349 
  space = (int)(rx_queue->max_fill - fill_level);
  ldv_56457: 
#line 354 
  ;
  
#line 360 
  rc = efx_init_rx_buffers(rx_queue,(_Bool)((bool)((int)atomic) != 0));
  
#line 361 
  if ((long)(rc != 0) != 0L) {
    
#line 363 
    if (rx_queue->added_count == rx_queue->removed_count) 
#line 364 
                                                          efx_schedule_slow_fill(rx_queue); else ;
    
#line 365 
    goto out;
  }
  else ;
  
#line 367 
  space = (int)((unsigned int)space - batch_size);
  
#line 367 
  ;
  
#line 367 
  if ((unsigned int)space >= batch_size) 
#line 369 
                                         goto ldv_56457; else 
#line 372 
                                                              goto ldv_56458;
  ldv_56458: 
#line 373 
  ;
  out: 
#line 374 
  ;
  
#line 375 
  if (rx_queue->notified_count != rx_queue->added_count) 
#line 376 
                                                         efx_nic_notify_rx_desc(rx_queue); else ;
  return_label: 
#line 377 
                return;
}


#line 379  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c"
void efx_rx_slow_fill(unsigned long context)
{
  
#line 381 
  struct efx_rx_queue *rx_queue = (struct efx_rx_queue *)context;
  
#line 384 
  efx_nic_generate_fill_event(rx_queue);
  
#line 385 
  rx_queue->slow_fill_count += 1U;
  
#line 386 
  return;
}


#line 388  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c"
static void efx_rx_packet__check_len(struct efx_rx_queue *rx_queue, struct efx_rx_buffer *rx_buf, int len)
{
  struct efx_channel *tmp_4;
  
#line 392 
  struct efx_nic *efx = rx_queue->efx;
  
#line 393 
  unsigned int max_len = (unsigned int)rx_buf->len - (efx->type)->rx_buffer_padding;
  
#line 395 
  if ((long)((unsigned int)len <= max_len) != 0L) 
#line 396 
                                                  goto return_label; else ;
  
#line 401 
  rx_buf->flags = (unsigned short)((unsigned int)rx_buf->flags | 4U);
  
#line 403 
  if ((int)rx_buf->len < len) {
    int tmp_3;
    
#line 403 
    tmp_3 = efx_nic_rev(efx);
    
#line 403 
    if (tmp_3 <= 1) {
      int tmp_0;
      
#line 404 
      tmp_0 = net_ratelimit();
      
#line 404 
      if (tmp_0 != 0) {
        
#line 405 
        if ((efx->msg_enable & 64U) != 0U) {
          int tmp;
          
#line 405 
          ;
          
#line 405 
          ;
          
#line 405 
          ;
          
#line 405 
          tmp = efx_rx_queue_index(rx_queue);
          
#line 405 
          ;
          
#line 405 
          netdev_err((struct net_device const *)efx->net_dev," RX queue %d seriously overlength ",tmp,len,max_len,(efx->type)->rx_buffer_padding);
        }
        else ;
      }
      else ;
      
#line 410 
      efx_schedule_reset(efx,(enum reset_type)RESET_TYPE_RX_RECOVERY);
    }
    else 
#line 403 
         goto _LAND;
  }
  else {
    int tmp_2;
    _LAND: 
#line 412 
    tmp_2 = net_ratelimit();
    
#line 412 
    if (tmp_2 != 0) {
      
#line 413 
      if ((efx->msg_enable & 64U) != 0U) {
        int tmp_1;
        
#line 413 
        ;
        
#line 413 
        ;
        
#line 413 
        tmp_1 = efx_rx_queue_index(rx_queue);
        
#line 413 
        ;
        
#line 413 
        netdev_err((struct net_device const *)efx->net_dev," RX queue %d overlength RX event ",tmp_1,len,max_len);
      }
      else ;
    }
    else ;
  }
  
#line 419 
  tmp_4 = efx_rx_queue_channel(rx_queue);
  
#line 419 
  tmp_4->n_rx_overlength += 1U;
  return_label: 
#line 420 
                return;
}


#line 426  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c"
static void efx_rx_packet_gro(struct efx_channel *channel, struct efx_rx_buffer *rx_buf, unsigned int n_frags, u8 *eh)
{
  gro_result_t gro_result;
  struct sk_buff *skb;
  unsigned char *tmp_0;
  unsigned char *tmp_1;
  
#line 429 
  struct napi_struct *napi = & channel->napi_str;
  
#line 431 
  struct efx_nic *efx = channel->efx;
  
#line 434 
  skb = napi_get_frags(napi);
  
#line 435 
  if ((long)(skb == (struct sk_buff *)0) != 0L) {
    struct efx_rx_queue *rx_queue;
    
#line 438 
    rx_queue = efx_channel_get_rx_queue(channel);
    
#line 439 
    efx_free_rx_buffers(rx_queue,rx_buf,n_frags);
    
#line 440 
    goto return_label;
  }
  else ;
  
#line 443 
  if (((efx->net_dev)->features & 8589934592ULL) != 0ULL) {
    u32 tmp;
    
#line 444 
    tmp = efx_rx_buf_hash(efx,(u8 const *)eh);
    
#line 444 
    ;
    
#line 444 
    skb_set_hash(skb,tmp,(enum pkt_hash_types)PKT_HASH_TYPE_L3);
  }
  else ;
  
#line 446 
  skb->ip_summed = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))((unsigned int)((int)rx_buf->flags >> 1) & 1U);
  ldv_56483: 
#line 448 
  ;
  
#line 450 
  ;
  
#line 450 
  ;
  
#line 450 
  ;
  
#line 450 
  tmp_0 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 450 
  ;
  
#line 450 
  skb_fill_page_desc(skb,(int)((struct skb_shared_info *)tmp_0)->nr_frags,rx_buf->page,(int)rx_buf->page_offset,(int)rx_buf->len);
  
#line 453 
  rx_buf->page = (struct page *)0;
  
#line 454 
  skb->len += (unsigned int)rx_buf->len;
  
#line 455 
  tmp_1 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 455 
  ;
  
#line 455 
  if ((unsigned int)((struct skb_shared_info *)tmp_1)->nr_frags == n_frags) 
    
#line 456 
    goto ldv_56482; else ;
  
#line 458 
  rx_buf = efx_rx_buf_next(& channel->rx_queue,rx_buf);
  
#line 450 
  goto ldv_56483;
  ldv_56482: 
#line 451 
  ;
  
#line 461 
  skb->data_len = skb->len;
  
#line 462 
  skb->truesize += efx->rx_buffer_truesize * n_frags;
  
#line 464 
  skb_record_rx_queue(skb,(unsigned short)((int)((unsigned short)channel->rx_queue.core_index)));
  
#line 466 
  skb_mark_napi_id(skb,& channel->napi_str);
  
#line 467 
  gro_result = napi_gro_frags(napi);
  
#line 468 
  if (gro_result != (unsigned int)GRO_DROP) 
#line 469 
                                            channel->irq_mod_score += 2U; else ;
  return_label: 
#line 470 
                return;
}


#line 473  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c"
static struct sk_buff *efx_rx_mk_skb(struct efx_channel *channel, struct efx_rx_buffer *rx_buf, unsigned int n_frags, u8 *eh, int hdr_len)
{
  struct sk_buff *__retres;
  struct sk_buff *skb;
  
#line 478 
  struct efx_nic *efx = channel->efx;
  
#line 482 
  skb = netdev_alloc_skb(efx->net_dev,(efx->rx_ip_align + efx->rx_prefix_size) + (unsigned int)hdr_len);
  
#line 485 
  if ((long)(skb == (struct sk_buff *)0) != 0L) {
    
#line 486 
    atomic_inc_1(& efx->n_rx_noskb_drops);
    
#line 487 
    __retres = (struct sk_buff *)0;
    
#line 487 
    goto return_label;
  }
  else ;
  
#line 492 
  memcpy((void *)(skb->data + efx->rx_ip_align),(void const *)(eh + - efx->rx_prefix_size),(unsigned long)(efx->rx_prefix_size + (unsigned int)hdr_len));
  
#line 494 
  skb_reserve(skb,(int)(efx->rx_ip_align + efx->rx_prefix_size));
  
#line 495 
  __skb_put(skb,(unsigned int)hdr_len);
  
#line 498 
  if ((int)rx_buf->len > hdr_len) {
    unsigned char *tmp;
    unsigned char *tmp_0;
    
#line 499 
    rx_buf->page_offset = (unsigned short)((int)rx_buf->page_offset + (int)((unsigned short)hdr_len));
    
#line 500 
    rx_buf->len = (unsigned short)((int)rx_buf->len - (int)((unsigned short)hdr_len));
    ldv_56494: 
#line 501 
    ;
    
#line 503 
    ;
    
#line 503 
    ;
    
#line 503 
    ;
    
#line 503 
    tmp = skb_end_pointer((struct sk_buff const *)skb);
    
#line 503 
    ;
    
#line 503 
    skb_fill_page_desc(skb,(int)((struct skb_shared_info *)tmp)->nr_frags,rx_buf->page,(int)rx_buf->page_offset,(int)rx_buf->len);
    
#line 506 
    rx_buf->page = (struct page *)0;
    
#line 507 
    skb->len += (unsigned int)rx_buf->len;
    
#line 508 
    skb->data_len += (unsigned int)rx_buf->len;
    
#line 509 
    tmp_0 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 509 
    ;
    
#line 509 
    if ((unsigned int)((struct skb_shared_info *)tmp_0)->nr_frags == n_frags) 
      
#line 510 
      goto ldv_56493; else ;
    
#line 512 
    rx_buf = efx_rx_buf_next(& channel->rx_queue,rx_buf);
    
#line 503 
    goto ldv_56494;
    ldv_56493: 
#line 504 
    ;
  }
  else {
    
#line 515 
    __free_pages(rx_buf->page,efx->rx_buffer_order);
    
#line 516 
    rx_buf->page = (struct page *)0;
    
#line 517 
    n_frags = 0U;
  }
  
#line 520 
  skb->truesize += efx->rx_buffer_truesize * n_frags;
  
#line 523 
  skb->protocol = eth_type_trans(skb,efx->net_dev);
  
#line 525 
  skb_mark_napi_id(skb,& channel->napi_str);
  
#line 527 
  __retres = skb;
  return_label: 
#line 527 
                return __retres;
}


#line 530  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c"
void efx_rx_packet(struct efx_rx_queue *rx_queue, unsigned int index, unsigned int n_frags, unsigned int len, u16 flags)
{
  struct efx_rx_buffer *rx_buf;
  u8 *tmp_3;
  
#line 533 
  struct efx_nic *efx = rx_queue->efx;
  
#line 534 
  struct efx_channel *channel = efx_rx_queue_channel(rx_queue);
  
#line 537 
  rx_queue->rx_packets += 1UL;
  
#line 539 
  rx_buf = efx_rx_buffer(rx_queue,index);
  
#line 540 
  rx_buf->flags = (unsigned short)((int)rx_buf->flags | (int)flags);
  
#line 543 
  if (n_frags == 1U) {
    
#line 544 
    if (((int)flags & 128) == 0) 
#line 545 
                                 efx_rx_packet__check_len(rx_queue,rx_buf,(int)len); else ;
  }
  else 
    
#line 546 
    if ((((long)(n_frags > 6U) != 0L || (long)((n_frags + 4294967295U) * efx->rx_dma_len >= len) != 0L) || (long)(efx->rx_dma_len * n_frags < len) != 0L) || (long)(! efx->rx_scatter) != 0L) {
      {
        
#line 553 
        int __ret_warn_on = (len != 0U || ((int)rx_buf->flags & 4) == 0) != 0;
        
#line 553 
        if ((long)(__ret_warn_on != 0) != 0L) 
#line 553 
                                              warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c",553); else ;
        
#line 553 
        long tmp_2 = (long)(__ret_warn_on != 0);
      }
      
#line 554 
      rx_buf->flags = (unsigned short)((unsigned int)rx_buf->flags | 4U);
    }
    else ;
  
#line 567 
  if ((long)(((int)rx_buf->flags & 4) != 0) != 0L) {
    
#line 568 
    efx_rx_flush_packet(channel);
    
#line 569 
    efx_discard_rx_packet(channel,rx_buf,n_frags);
    
#line 570 
    goto return_label;
  }
  else ;
  
#line 573 
  if (n_frags == 1U && ((int)flags & 128) == 0) 
#line 574 
                                                rx_buf->len = (unsigned short)len; else ;
  
#line 579 
  efx_sync_rx_buffer(efx,rx_buf,(unsigned int)rx_buf->len);
  
#line 584 
  tmp_3 = efx_rx_buf_va(rx_buf);
  
#line 584 
  __builtin_prefetch((void const *)tmp_3);
  
#line 586 
  rx_buf->page_offset = (unsigned short)((int)rx_buf->page_offset + (int)((unsigned short)efx->rx_prefix_size));
  
#line 587 
  rx_buf->len = (unsigned short)((int)rx_buf->len - (int)((unsigned short)efx->rx_prefix_size));
  
#line 589 
  if (n_frags > 1U) {
    
#line 593 
    unsigned int tail_frags = n_frags + 4294967295U;
    ldv_56510: 
#line 594 
    ;
    
#line 596 
    rx_buf = efx_rx_buf_next(rx_queue,rx_buf);
    
#line 597 
    tail_frags -= 1U;
    
#line 597 
    if (tail_frags == 0U) 
#line 598 
                          goto ldv_56509; else ;
    
#line 599 
    efx_sync_rx_buffer(efx,rx_buf,efx->rx_dma_len);
    
#line 596 
    goto ldv_56510;
    ldv_56509: 
#line 597 
    ;
    
#line 601 
    rx_buf->len = (unsigned short)((int)((unsigned short)len) - (int)((unsigned short)(n_frags + 4294967295U)) * (int)((unsigned short)efx->rx_dma_len));
    
#line 602 
    efx_sync_rx_buffer(efx,rx_buf,(unsigned int)rx_buf->len);
  }
  else ;
  
#line 606 
  rx_buf = efx_rx_buffer(rx_queue,index);
  
#line 607 
  efx_recycle_rx_pages(channel,rx_buf,n_frags);
  
#line 612 
  efx_rx_flush_packet(channel);
  
#line 613 
  channel->rx_pkt_n_frags = n_frags;
  
#line 614 
  channel->rx_pkt_index = index;
  return_label: 
#line 615 
                return;
}


#line 617  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c"
static void efx_rx_deliver(struct efx_channel *channel, u8 *eh, struct efx_rx_buffer *rx_buf, unsigned int n_frags)
{
  struct sk_buff *skb;
  int tmp_0;
  {
    int tmp;
    
#line 622 
    u16 __min1 = rx_buf->len;
    
#line 622 
    u16 __min2 = (unsigned short)128U;
    
#line 622 
    if ((int)__min1 < (int)__min2) 
#line 622 
                                   tmp = (int)__min1; else 
#line 622 
                                                           tmp = (int)__min2;
    
#line 622 
    tmp_0 = tmp;
  }
  
#line 622 
  u16 hdr_len = (unsigned short)tmp_0;
  
#line 624 
  skb = efx_rx_mk_skb(channel,rx_buf,n_frags,eh,(int)hdr_len);
  
#line 625 
  if ((long)(skb == (struct sk_buff *)0) != 0L) {
    struct efx_rx_queue *rx_queue;
    
#line 628 
    rx_queue = efx_channel_get_rx_queue(channel);
    
#line 629 
    efx_free_rx_buffers(rx_queue,rx_buf,n_frags);
    
#line 630 
    goto return_label;
  }
  else ;
  
#line 632 
  skb_record_rx_queue(skb,(unsigned short)((int)((unsigned short)channel->rx_queue.core_index)));
  
#line 635 
  skb_checksum_none_assert((struct sk_buff const *)skb);
  
#line 636 
  if ((long)(((int)rx_buf->flags & 2) != 0) != 0L) 
#line 637 
                                                   skb->ip_summed = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U; else ;
  
#line 639 
  efx_rx_skb_attach_timestamp(channel,skb);
  
#line 641 
  if ((channel->type)->receive_skb != (bool (*)(struct efx_channel *, struct sk_buff *))0) {
    bool tmp_1;
    
#line 642 
    tmp_1 = (*((channel->type)->receive_skb))(channel,skb);
    
#line 642 
    if ((int)tmp_1 != 0) 
#line 643 
                         goto return_label; else ;
  }
  else ;
  
#line 646 
  netif_receive_skb(skb);
  return_label: 
#line 647 
                return;
}


#line 650  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c"
void __efx_rx_packet(struct efx_channel *channel)
{
  
#line 652 
  struct efx_nic *efx = channel->efx;
  
#line 653 
  struct efx_rx_buffer *rx_buf = efx_rx_buffer(& channel->rx_queue,channel->rx_pkt_index);
  
#line 655 
  u8 *eh = efx_rx_buf_va(rx_buf);
  
#line 660 
  if (((int)rx_buf->flags & 128) != 0) 
#line 661 
                                       rx_buf->len = __le16_to_cpup((__le16 const *)(eh + efx->rx_packet_len_offset)); else ;
  
#line 667 
  if ((long)(efx->loopback_selftest != (void *)0) != 0L) {
    struct efx_rx_queue *rx_queue;
    
#line 670 
    efx_loopback_rx_packet(efx,(char const *)eh,(int)rx_buf->len);
    
#line 671 
    rx_queue = efx_channel_get_rx_queue(channel);
    
#line 672 
    efx_free_rx_buffers(rx_queue,rx_buf,channel->rx_pkt_n_frags);
    
#line 674 
    goto out;
  }
  else ;
  
#line 677 
  if ((long)(((efx->net_dev)->features & 17179869184ULL) == 0ULL) != 0L) 
    
#line 678 
    rx_buf->flags = (unsigned short)((unsigned int)rx_buf->flags & 65533U); else ;
  
#line 680 
  if (((int)rx_buf->flags & 64) != 0 && (channel->type)->receive_skb == (bool (*)(struct efx_channel *, struct sk_buff *))0) {
    int tmp_2;
    bool tmp_1;
    
#line 681 
    tmp_1 = efx_channel_busy_polling(channel);
    
#line 681 
    if (tmp_1) 
#line 681 
               tmp_2 = 0; else 
#line 681 
                               tmp_2 = 1;
    
#line 681 
    if (tmp_2) 
#line 682 
               efx_rx_packet_gro(channel,rx_buf,channel->rx_pkt_n_frags,eh); else 
                                                                    
#line 684 
                                                                    efx_rx_deliver(channel,eh,rx_buf,channel->rx_pkt_n_frags);
  }
  else 
#line 684 
       efx_rx_deliver(channel,eh,rx_buf,channel->rx_pkt_n_frags);
  out: 
#line 685 
  ;
  
#line 686 
  channel->rx_pkt_n_frags = 0U;
  
#line 687 
  return;
}


#line 689  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c"
int efx_probe_rx_queue(struct efx_rx_queue *rx_queue)
{
  int __retres;
  unsigned int entries;
  int rc;
  unsigned long tmp_71;
  
#line 691 
  struct efx_nic *efx = rx_queue->efx;
  {
    unsigned long tmp_69;
    unsigned long tmp_70;
    
#line 696 
    if (0 != 0) {
      unsigned long tmp_67;
      
#line 696 
      if (efx->rxq_entries != 1U) {
        unsigned long tmp_66;
        
#line 696 
        if (0 != 0) {
          unsigned long tmp_64;
          
#line 696 
          if (efx->rxq_entries == 1U) {
            int tmp;
            
#line 696 
            tmp = ____ilog2_NaN();
            
#line 696 
            tmp_64 = 1UL << (tmp + 1);
          }
          else {
            unsigned long tmp_63;
            
#line 696 
            if (((unsigned long long)(efx->rxq_entries + 4294967295U) & 4611686018427387904ULL) == 0ULL) {
              unsigned long tmp_62;
              
#line 696 
              if (((unsigned long long)(efx->rxq_entries + 4294967295U) & 2305843009213693952ULL) == 0ULL) {
                unsigned long tmp_61;
                
#line 696 
                if (((unsigned long long)(efx->rxq_entries + 4294967295U) & 1152921504606846976ULL) == 0ULL) {
                  unsigned long tmp_60;
                  
#line 696 
                  if (((unsigned long long)(efx->rxq_entries + 4294967295U) & 576460752303423488ULL) == 0ULL) {
                    unsigned long tmp_59;
                    
#line 696 
                    if (((unsigned long long)(efx->rxq_entries + 4294967295U) & 288230376151711744ULL) == 0ULL) {
                      unsigned long tmp_58;
                      
#line 696 
                      if (((unsigned long long)(efx->rxq_entries + 4294967295U) & 144115188075855872ULL) == 0ULL) {
                        unsigned long tmp_57;
                        
#line 696 
                        if (((unsigned long long)(efx->rxq_entries + 4294967295U) & 72057594037927936ULL) == 0ULL) {
                          unsigned long tmp_56;
                          
#line 696 
                          if (((unsigned long long)(efx->rxq_entries + 4294967295U) & 36028797018963968ULL) == 0ULL) {
                            unsigned long tmp_55;
                            
#line 696 
                            if (((unsigned long long)(efx->rxq_entries + 4294967295U) & 18014398509481984ULL) == 0ULL) {
                              unsigned long tmp_54;
                              
#line 696 
                              if (((unsigned long long)(efx->rxq_entries + 4294967295U) & 9007199254740992ULL) == 0ULL) {
                                unsigned long tmp_53;
                                
#line 696 
                                if (((unsigned long long)(efx->rxq_entries + 4294967295U) & 4503599627370496ULL) == 0ULL) {
                                  unsigned long tmp_52;
                                  
#line 696 
                                  if (((unsigned long long)(efx->rxq_entries + 4294967295U) & 2251799813685248ULL) == 0ULL) {
                                    unsigned long tmp_51;
                                    
#line 696 
                                    if (((unsigned long long)(efx->rxq_entries + 4294967295U) & 1125899906842624ULL) == 0ULL) {
                                      unsigned long tmp_50;
                                      
#line 696 
                                      if (((unsigned long long)(efx->rxq_entries + 4294967295U) & 562949953421312ULL) == 0ULL) {
                                        unsigned long tmp_49;
                                        
#line 696 
                                        if (((unsigned long long)(efx->rxq_entries + 4294967295U) & 281474976710656ULL) == 0ULL) {
                                          unsigned long tmp_48;
                                          
#line 696 
                                          if (((unsigned long long)(efx->rxq_entries + 4294967295U) & 140737488355328ULL) == 0ULL) {
                                            unsigned long tmp_47;
                                            
#line 696 
                                            if (((unsigned long long)(efx->rxq_entries + 4294967295U) & 70368744177664ULL) == 0ULL) {
                                              unsigned long tmp_46;
                                              
#line 696 
                                              if (((unsigned long long)(efx->rxq_entries + 4294967295U) & 35184372088832ULL) == 0ULL) {
                                                unsigned long tmp_45;
                                                
#line 696 
                                                if (((unsigned long long)(efx->rxq_entries + 4294967295U) & 17592186044416ULL) == 0ULL) {
                                                  unsigned long tmp_44;
                                                  
#line 696 
                                                  if (((unsigned long long)(efx->rxq_entries + 4294967295U) & 8796093022208ULL) == 0ULL) {
                                                    unsigned long tmp_43;
                                                    
#line 696 
                                                    if (((unsigned long long)(efx->rxq_entries + 4294967295U) & 4398046511104ULL) == 0ULL) {
                                                      unsigned long tmp_42;
                                                      
#line 696 
                                                      if (((unsigned long long)(efx->rxq_entries + 4294967295U) & 2199023255552ULL) == 0ULL) {
                                                        unsigned long tmp_41;
                                                        
#line 696 
                                                        if (((unsigned long long)(efx->rxq_entries + 4294967295U) & 1099511627776ULL) == 0ULL) {
                                                          unsigned long tmp_40;
                                                          
#line 696 
                                                          if (((unsigned long long)(efx->rxq_entries + 4294967295U) & 549755813888ULL) == 0ULL) {
                                                            unsigned long tmp_39;
                                                            
#line 696 
                                                            if (((unsigned long long)(efx->rxq_entries + 4294967295U) & 274877906944ULL) == 0ULL) {
                                                              unsigned long tmp_38;
                                                              
#line 696 
                                                              if (((unsigned long long)(efx->rxq_entries + 4294967295U) & 137438953472ULL) == 0ULL) {
                                                                unsigned long tmp_37;
                                                                
#line 696 
                                                                if (((unsigned long long)(efx->rxq_entries + 4294967295U) & 68719476736ULL) == 0ULL) {
                                                                  unsigned long tmp_36;
                                                                  
#line 696 
                                                                  if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 34359738368ULL) == 0ULL) {
                                                                    unsigned long tmp_35;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 17179869184ULL) == 0ULL) {
                                                                    unsigned long tmp_34;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 8589934592ULL) == 0ULL) {
                                                                    unsigned long tmp_33;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 4294967296ULL) == 0ULL) {
                                                                    unsigned long tmp_32;
                                                                    
#line 696 
                                                                    if (
                                                                    efx->rxq_entries + 4294967295U >= (unsigned int)0) {
                                                                    unsigned long tmp_31;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 1073741824ULL) == 0ULL) {
                                                                    unsigned long tmp_30;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 536870912ULL) == 0ULL) {
                                                                    unsigned long tmp_29;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 268435456ULL) == 0ULL) {
                                                                    unsigned long tmp_28;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 134217728ULL) == 0ULL) {
                                                                    unsigned long tmp_27;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 67108864ULL) == 0ULL) {
                                                                    unsigned long tmp_26;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 33554432ULL) == 0ULL) {
                                                                    unsigned long tmp_25;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 16777216ULL) == 0ULL) {
                                                                    unsigned long tmp_24;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 8388608ULL) == 0ULL) {
                                                                    unsigned long tmp_23;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 4194304ULL) == 0ULL) {
                                                                    unsigned long tmp_22;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 2097152ULL) == 0ULL) {
                                                                    unsigned long tmp_21;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 1048576ULL) == 0ULL) {
                                                                    unsigned long tmp_20;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 524288ULL) == 0ULL) {
                                                                    unsigned long tmp_19;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 262144ULL) == 0ULL) {
                                                                    unsigned long tmp_18;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 131072ULL) == 0ULL) {
                                                                    unsigned long tmp_17;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 65536ULL) == 0ULL) {
                                                                    unsigned long tmp_16;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 32768ULL) == 0ULL) {
                                                                    unsigned long tmp_15;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 16384ULL) == 0ULL) {
                                                                    unsigned long tmp_14;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 8192ULL) == 0ULL) {
                                                                    unsigned long tmp_13;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 4096ULL) == 0ULL) {
                                                                    unsigned long tmp_12;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 2048ULL) == 0ULL) {
                                                                    unsigned long tmp_11;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 1024ULL) == 0ULL) {
                                                                    unsigned long tmp_10;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 512ULL) == 0ULL) {
                                                                    unsigned long tmp_9;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 256ULL) == 0ULL) {
                                                                    unsigned long tmp_8;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 128ULL) == 0ULL) {
                                                                    unsigned long tmp_7;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 64ULL) == 0ULL) {
                                                                    unsigned long tmp_6;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 32ULL) == 0ULL) {
                                                                    unsigned long tmp_5;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 16ULL) == 0ULL) {
                                                                    unsigned long tmp_4;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 8ULL) == 0ULL) {
                                                                    unsigned long tmp_3;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 4ULL) == 0ULL) {
                                                                    unsigned long tmp_2;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 2ULL) == 0ULL) {
                                                                    unsigned long tmp_1;
                                                                    
#line 696 
                                                                    if (
                                                                    ((unsigned long long)(efx->rxq_entries + 4294967295U) & 1ULL) == 0ULL) {
                                                                    int tmp_0;
                                                                    
#line 696 
                                                                    tmp_0 = ____ilog2_NaN();
                                                                    
#line 696 
                                                                    tmp_1 = 1UL << (tmp_0 + 1);
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_1 = 2UL;
                                                                    
#line 696 
                                                                    tmp_2 = tmp_1;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_2 = 4UL;
                                                                    
#line 696 
                                                                    tmp_3 = tmp_2;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_3 = 8UL;
                                                                    
#line 696 
                                                                    tmp_4 = tmp_3;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_4 = 16UL;
                                                                    
#line 696 
                                                                    tmp_5 = tmp_4;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_5 = 32UL;
                                                                    
#line 696 
                                                                    tmp_6 = tmp_5;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_6 = 64UL;
                                                                    
#line 696 
                                                                    tmp_7 = tmp_6;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_7 = 128UL;
                                                                    
#line 696 
                                                                    tmp_8 = tmp_7;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_8 = 256UL;
                                                                    
#line 696 
                                                                    tmp_9 = tmp_8;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_9 = 512UL;
                                                                    
#line 696 
                                                                    tmp_10 = tmp_9;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_10 = 1024UL;
                                                                    
#line 696 
                                                                    tmp_11 = tmp_10;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_11 = 2048UL;
                                                                    
#line 696 
                                                                    tmp_12 = tmp_11;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_12 = 4096UL;
                                                                    
#line 696 
                                                                    tmp_13 = tmp_12;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_13 = 8192UL;
                                                                    
#line 696 
                                                                    tmp_14 = tmp_13;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_14 = 16384UL;
                                                                    
#line 696 
                                                                    tmp_15 = tmp_14;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_15 = 32768UL;
                                                                    
#line 696 
                                                                    tmp_16 = tmp_15;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_16 = 65536UL;
                                                                    
#line 696 
                                                                    tmp_17 = tmp_16;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_17 = 131072UL;
                                                                    
#line 696 
                                                                    tmp_18 = tmp_17;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_18 = 262144UL;
                                                                    
#line 696 
                                                                    tmp_19 = tmp_18;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_19 = 524288UL;
                                                                    
#line 696 
                                                                    tmp_20 = tmp_19;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_20 = 1048576UL;
                                                                    
#line 696 
                                                                    tmp_21 = tmp_20;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_21 = 2097152UL;
                                                                    
#line 696 
                                                                    tmp_22 = tmp_21;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_22 = 4194304UL;
                                                                    
#line 696 
                                                                    tmp_23 = tmp_22;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_23 = 8388608UL;
                                                                    
#line 696 
                                                                    tmp_24 = tmp_23;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_24 = 16777216UL;
                                                                    
#line 696 
                                                                    tmp_25 = tmp_24;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_25 = 33554432UL;
                                                                    
#line 696 
                                                                    tmp_26 = tmp_25;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_26 = 67108864UL;
                                                                    
#line 696 
                                                                    tmp_27 = tmp_26;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_27 = 134217728UL;
                                                                    
#line 696 
                                                                    tmp_28 = tmp_27;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_28 = 268435456UL;
                                                                    
#line 696 
                                                                    tmp_29 = tmp_28;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_29 = 536870912UL;
                                                                    
#line 696 
                                                                    tmp_30 = tmp_29;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_30 = 1073741824UL;
                                                                    
#line 696 
                                                                    tmp_31 = tmp_30;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_31 = 2147483648UL;
                                                                    
#line 696 
                                                                    tmp_32 = tmp_31;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_32 = 4294967296UL;
                                                                    
#line 696 
                                                                    tmp_33 = tmp_32;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_33 = 8589934592UL;
                                                                    
#line 696 
                                                                    tmp_34 = tmp_33;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_34 = 17179869184UL;
                                                                    
#line 696 
                                                                    tmp_35 = tmp_34;
                                                                    }
                                                                    else 
                                                                    
#line 696 
                                                                    tmp_35 = 34359738368UL;
                                                                    
#line 696 
                                                                    tmp_36 = tmp_35;
                                                                  }
                                                                  else 
                                                                    
#line 696 
                                                                    tmp_36 = 68719476736UL;
                                                                  
#line 696 
                                                                  tmp_37 = tmp_36;
                                                                }
                                                                else 
                                                                  
#line 696 
                                                                  tmp_37 = 137438953472UL;
                                                                
#line 696 
                                                                tmp_38 = tmp_37;
                                                              }
                                                              else 
#line 696 
                                                                   tmp_38 = 274877906944UL;
                                                              
#line 696 
                                                              tmp_39 = tmp_38;
                                                            }
                                                            else 
#line 696 
                                                                 tmp_39 = 549755813888UL;
                                                            
#line 696 
                                                            tmp_40 = tmp_39;
                                                          }
                                                          else 
#line 696 
                                                               tmp_40 = 1099511627776UL;
                                                          
#line 696 
                                                          tmp_41 = tmp_40;
                                                        }
                                                        else 
#line 696 
                                                             tmp_41 = 2199023255552UL;
                                                        
#line 696 
                                                        tmp_42 = tmp_41;
                                                      }
                                                      else 
#line 696 
                                                           tmp_42 = 4398046511104UL;
                                                      
#line 696 
                                                      tmp_43 = tmp_42;
                                                    }
                                                    else 
#line 696 
                                                         tmp_43 = 8796093022208UL;
                                                    
#line 696 
                                                    tmp_44 = tmp_43;
                                                  }
                                                  else 
#line 696 
                                                       tmp_44 = 17592186044416UL;
                                                  
#line 696 
                                                  tmp_45 = tmp_44;
                                                }
                                                else 
#line 696 
                                                     tmp_45 = 35184372088832UL;
                                                
#line 696 
                                                tmp_46 = tmp_45;
                                              }
                                              else 
#line 696 
                                                   tmp_46 = 70368744177664UL;
                                              
#line 696 
                                              tmp_47 = tmp_46;
                                            }
                                            else 
#line 696 
                                                 tmp_47 = 140737488355328UL;
                                            
#line 696 
                                            tmp_48 = tmp_47;
                                          }
                                          else 
#line 696 
                                               tmp_48 = 281474976710656UL;
                                          
#line 696 
                                          tmp_49 = tmp_48;
                                        }
                                        else 
#line 696 
                                             tmp_49 = 562949953421312UL;
                                        
#line 696 
                                        tmp_50 = tmp_49;
                                      }
                                      else 
#line 696 
                                           tmp_50 = 1125899906842624UL;
                                      
#line 696 
                                      tmp_51 = tmp_50;
                                    }
                                    else 
#line 696 
                                         tmp_51 = 2251799813685248UL;
                                    
#line 696 
                                    tmp_52 = tmp_51;
                                  }
                                  else 
#line 696 
                                       tmp_52 = 4503599627370496UL;
                                  
#line 696 
                                  tmp_53 = tmp_52;
                                }
                                else 
#line 696 
                                     tmp_53 = 9007199254740992UL;
                                
#line 696 
                                tmp_54 = tmp_53;
                              }
                              else 
#line 696 
                                   tmp_54 = 18014398509481984UL;
                              
#line 696 
                              tmp_55 = tmp_54;
                            }
                            else 
#line 696 
                                 tmp_55 = 36028797018963968UL;
                            
#line 696 
                            tmp_56 = tmp_55;
                          }
                          else 
#line 696 
                               tmp_56 = 72057594037927936UL;
                          
#line 696 
                          tmp_57 = tmp_56;
                        }
                        else 
#line 696 
                             tmp_57 = 144115188075855872UL;
                        
#line 696 
                        tmp_58 = tmp_57;
                      }
                      else 
#line 696 
                           tmp_58 = 288230376151711744UL;
                      
#line 696 
                      tmp_59 = tmp_58;
                    }
                    else 
#line 696 
                         tmp_59 = 576460752303423488UL;
                    
#line 696 
                    tmp_60 = tmp_59;
                  }
                  else 
#line 696 
                       tmp_60 = 1152921504606846976UL;
                  
#line 696 
                  tmp_61 = tmp_60;
                }
                else 
#line 696 
                     tmp_61 = 2305843009213693952UL;
                
#line 696 
                tmp_62 = tmp_61;
              }
              else 
#line 696 
                   tmp_62 = 4611686018427387904UL;
              
#line 696 
              tmp_63 = tmp_62;
            }
            else 
#line 696 
                 tmp_63 = 9223372036854775808UL;
            
#line 696 
            tmp_64 = tmp_63;
          }
          
#line 696 
          tmp_66 = tmp_64;
        }
        else {
          int tmp_65;
          
#line 696 
          tmp_65 = __ilog2_u32(efx->rxq_entries + 4294967295U);
          
#line 696 
          tmp_66 = 1UL << (tmp_65 + 1);
        }
        
#line 696 
        tmp_67 = tmp_66;
      }
      else 
#line 696 
           tmp_67 = 1UL;
      
#line 696 
      tmp_69 = tmp_67;
    }
    else 
#line 696 
         tmp_69 = __roundup_pow_of_two((unsigned long)efx->rxq_entries);
    
#line 696 
    unsigned long _max1 = tmp_69;
    
#line 696 
    unsigned long _max2 = 512UL;
    
#line 696 
    if (_max1 > _max2) 
#line 696 
                       tmp_70 = _max1; else 
#line 696 
                                            tmp_70 = _max2;
    
#line 696 
    tmp_71 = tmp_70;
  }
  
#line 696 
  entries = (unsigned int)tmp_71;
  
#line 698 
  rx_queue->ptr_mask = entries + 4294967295U;
  
#line 700 
  if ((efx->msg_enable & 2U) != 0U) {
    
#line 700 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_probe_rx_queue", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c", .format = "creating RX queue %d size %#x mask %#x\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))703U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 700 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      int tmp_72;
      
#line 700 
      ;
      
#line 700 
      ;
      
#line 700 
      tmp_72 = efx_rx_queue_index(rx_queue);
      
#line 700 
      ;
      
#line 700 
      __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"creating RX queue %d size %#x mask %#x\n",tmp_72,efx->rxq_entries,rx_queue->ptr_mask);
    }
    else ;
  }
  else ;
  
#line 706 
  rx_queue->buffer = (struct efx_rx_buffer *)kcalloc_4((unsigned long)entries,24UL,208U);
  
#line 708 
  if (rx_queue->buffer == (struct efx_rx_buffer *)0) {
    
#line 709 
    __retres = -12;
    
#line 709 
    goto return_label;
  }
  else ;
  
#line 711 
  rc = efx_nic_probe_rx(rx_queue);
  
#line 712 
  if (rc != 0) {
    
#line 713 
    kfree((void const *)rx_queue->buffer);
    
#line 714 
    rx_queue->buffer = (struct efx_rx_buffer *)0;
  }
  else ;
  
#line 717 
  __retres = rc;
  return_label: 
#line 717 
                return __retres;
}


#line 720  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c"
static void efx_init_rx_recycle_ring(struct efx_nic *efx, struct efx_rx_queue *rx_queue)
{
  unsigned int bufs_in_recycle_ring;
  unsigned int page_ring_size;
  bool tmp;
  
#line 729 
  tmp = iommu_present(& pci_bus_type);
  
#line 729 
  if ((int)tmp != 0) 
#line 730 
                     bufs_in_recycle_ring = 4096U; else 
#line 732 
                                                        bufs_in_recycle_ring = 16U;
  
#line 735 
  if (0 != 0) {
    unsigned int tmp_68;
    
#line 735 
    if (bufs_in_recycle_ring / efx->rx_bufs_per_page != 1U) {
      unsigned int tmp_67;
      
#line 735 
      if (0 != 0) {
        unsigned int tmp_65;
        
#line 735 
        if (bufs_in_recycle_ring / efx->rx_bufs_per_page == 1U) {
          int tmp_0;
          
#line 735 
          tmp_0 = ____ilog2_NaN();
          
#line 735 
          tmp_65 = (unsigned int)(1UL << (tmp_0 + 1));
        }
        else {
          unsigned int tmp_64;
          
#line 735 
          if (((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 4611686018427387904ULL) == 0ULL) {
            unsigned int tmp_63;
            
#line 735 
            if (((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 2305843009213693952ULL) == 0ULL) {
              unsigned int tmp_62;
              
#line 735 
              if (((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 1152921504606846976ULL) == 0ULL) {
                unsigned int tmp_61;
                
#line 735 
                if (((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 576460752303423488ULL) == 0ULL) {
                  unsigned int tmp_60;
                  
#line 735 
                  if (((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 288230376151711744ULL) == 0ULL) {
                    unsigned int tmp_59;
                    
#line 735 
                    if (((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 144115188075855872ULL) == 0ULL) {
                      unsigned int tmp_58;
                      
#line 735 
                      if (((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 72057594037927936ULL) == 0ULL) {
                        unsigned int tmp_57;
                        
#line 735 
                        if (((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 36028797018963968ULL) == 0ULL) {
                          unsigned int tmp_56;
                          
#line 735 
                          if (((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 18014398509481984ULL) == 0ULL) {
                            unsigned int tmp_55;
                            
#line 735 
                            if (((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 9007199254740992ULL) == 0ULL) {
                              unsigned int tmp_54;
                              
#line 735 
                              if (((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 4503599627370496ULL) == 0ULL) {
                                unsigned int tmp_53;
                                
#line 735 
                                if (((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 2251799813685248ULL) == 0ULL) {
                                  unsigned int tmp_52;
                                  
#line 735 
                                  if (((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 1125899906842624ULL) == 0ULL) {
                                    unsigned int tmp_51;
                                    
#line 735 
                                    if (((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 562949953421312ULL) == 0ULL) {
                                      unsigned int tmp_50;
                                      
#line 735 
                                      if (((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 281474976710656ULL) == 0ULL) {
                                        unsigned int tmp_49;
                                        
#line 735 
                                        if (((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 140737488355328ULL) == 0ULL) {
                                          unsigned int tmp_48;
                                          
#line 735 
                                          if (((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 70368744177664ULL) == 0ULL) {
                                            unsigned int tmp_47;
                                            
#line 735 
                                            if (((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 35184372088832ULL) == 0ULL) {
                                              unsigned int tmp_46;
                                              
#line 735 
                                              if (((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 17592186044416ULL) == 0ULL) {
                                                unsigned int tmp_45;
                                                
#line 735 
                                                if (((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 8796093022208ULL) == 0ULL) {
                                                  unsigned int tmp_44;
                                                  
#line 735 
                                                  if (((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 4398046511104ULL) == 0ULL) {
                                                    unsigned int tmp_43;
                                                    
#line 735 
                                                    if (((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 2199023255552ULL) == 0ULL) {
                                                      unsigned int tmp_42;
                                                      
#line 735 
                                                      if (((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 1099511627776ULL) == 0ULL) {
                                                        unsigned int tmp_41;
                                                        
#line 735 
                                                        if (((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 549755813888ULL) == 0ULL) {
                                                          unsigned int tmp_40;
                                                          
#line 735 
                                                          if (((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 274877906944ULL) == 0ULL) {
                                                            unsigned int tmp_39;
                                                            
#line 735 
                                                            if (((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 137438953472ULL) == 0ULL) {
                                                              unsigned int tmp_38;
                                                              
#line 735 
                                                              if (((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 68719476736ULL) == 0ULL) {
                                                                unsigned int tmp_37;
                                                                
#line 735 
                                                                if (((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 34359738368ULL) == 0ULL) {
                                                                  unsigned int tmp_36;
                                                                  
#line 735 
                                                                  if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 17179869184ULL) == 0ULL) {
                                                                    unsigned int tmp_35;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 8589934592ULL) == 0ULL) {
                                                                    unsigned int tmp_34;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 4294967296ULL) == 0ULL) {
                                                                    unsigned int tmp_33;
                                                                    
#line 735 
                                                                    if (
                                                                    bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U >= (unsigned int)0) {
                                                                    unsigned int tmp_32;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 1073741824ULL) == 0ULL) {
                                                                    unsigned int tmp_31;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 536870912ULL) == 0ULL) {
                                                                    unsigned int tmp_30;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 268435456ULL) == 0ULL) {
                                                                    unsigned int tmp_29;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 134217728ULL) == 0ULL) {
                                                                    unsigned int tmp_28;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 67108864ULL) == 0ULL) {
                                                                    unsigned int tmp_27;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 33554432ULL) == 0ULL) {
                                                                    unsigned int tmp_26;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 16777216ULL) == 0ULL) {
                                                                    unsigned int tmp_25;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 8388608ULL) == 0ULL) {
                                                                    unsigned int tmp_24;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 4194304ULL) == 0ULL) {
                                                                    unsigned int tmp_23;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 2097152ULL) == 0ULL) {
                                                                    unsigned int tmp_22;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 1048576ULL) == 0ULL) {
                                                                    unsigned int tmp_21;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 524288ULL) == 0ULL) {
                                                                    unsigned int tmp_20;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 262144ULL) == 0ULL) {
                                                                    unsigned int tmp_19;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 131072ULL) == 0ULL) {
                                                                    unsigned int tmp_18;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 65536ULL) == 0ULL) {
                                                                    unsigned int tmp_17;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 32768ULL) == 0ULL) {
                                                                    unsigned int tmp_16;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 16384ULL) == 0ULL) {
                                                                    unsigned int tmp_15;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 8192ULL) == 0ULL) {
                                                                    unsigned int tmp_14;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 4096ULL) == 0ULL) {
                                                                    unsigned int tmp_13;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 2048ULL) == 0ULL) {
                                                                    unsigned int tmp_12;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 1024ULL) == 0ULL) {
                                                                    unsigned int tmp_11;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 512ULL) == 0ULL) {
                                                                    unsigned int tmp_10;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 256ULL) == 0ULL) {
                                                                    unsigned int tmp_9;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 128ULL) == 0ULL) {
                                                                    unsigned int tmp_8;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 64ULL) == 0ULL) {
                                                                    unsigned int tmp_7;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 32ULL) == 0ULL) {
                                                                    unsigned int tmp_6;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 16ULL) == 0ULL) {
                                                                    unsigned int tmp_5;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 8ULL) == 0ULL) {
                                                                    unsigned int tmp_4;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 4ULL) == 0ULL) {
                                                                    unsigned int tmp_3;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 2ULL) == 0ULL) {
                                                                    unsigned int tmp_2;
                                                                    
#line 735 
                                                                    if (
                                                                    ((unsigned long long)(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U) & 1ULL) == 0ULL) {
                                                                    int tmp_1;
                                                                    
#line 735 
                                                                    tmp_1 = ____ilog2_NaN();
                                                                    
#line 735 
                                                                    tmp_2 = (unsigned int)(1UL << (tmp_1 + 1));
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_2 = 2U;
                                                                    
#line 735 
                                                                    tmp_3 = tmp_2;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_3 = 4U;
                                                                    
#line 735 
                                                                    tmp_4 = tmp_3;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_4 = 8U;
                                                                    
#line 735 
                                                                    tmp_5 = tmp_4;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_5 = 16U;
                                                                    
#line 735 
                                                                    tmp_6 = tmp_5;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_6 = 32U;
                                                                    
#line 735 
                                                                    tmp_7 = tmp_6;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_7 = 64U;
                                                                    
#line 735 
                                                                    tmp_8 = tmp_7;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_8 = 128U;
                                                                    
#line 735 
                                                                    tmp_9 = tmp_8;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_9 = 256U;
                                                                    
#line 735 
                                                                    tmp_10 = tmp_9;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_10 = 512U;
                                                                    
#line 735 
                                                                    tmp_11 = tmp_10;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_11 = 1024U;
                                                                    
#line 735 
                                                                    tmp_12 = tmp_11;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_12 = 2048U;
                                                                    
#line 735 
                                                                    tmp_13 = tmp_12;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_13 = 4096U;
                                                                    
#line 735 
                                                                    tmp_14 = tmp_13;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_14 = 8192U;
                                                                    
#line 735 
                                                                    tmp_15 = tmp_14;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_15 = 16384U;
                                                                    
#line 735 
                                                                    tmp_16 = tmp_15;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_16 = 32768U;
                                                                    
#line 735 
                                                                    tmp_17 = tmp_16;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_17 = 65536U;
                                                                    
#line 735 
                                                                    tmp_18 = tmp_17;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_18 = 131072U;
                                                                    
#line 735 
                                                                    tmp_19 = tmp_18;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_19 = 262144U;
                                                                    
#line 735 
                                                                    tmp_20 = tmp_19;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_20 = 524288U;
                                                                    
#line 735 
                                                                    tmp_21 = tmp_20;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_21 = 1048576U;
                                                                    
#line 735 
                                                                    tmp_22 = tmp_21;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_22 = 2097152U;
                                                                    
#line 735 
                                                                    tmp_23 = tmp_22;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_23 = 4194304U;
                                                                    
#line 735 
                                                                    tmp_24 = tmp_23;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_24 = 8388608U;
                                                                    
#line 735 
                                                                    tmp_25 = tmp_24;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_25 = 16777216U;
                                                                    
#line 735 
                                                                    tmp_26 = tmp_25;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_26 = 33554432U;
                                                                    
#line 735 
                                                                    tmp_27 = tmp_26;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_27 = 67108864U;
                                                                    
#line 735 
                                                                    tmp_28 = tmp_27;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_28 = 134217728U;
                                                                    
#line 735 
                                                                    tmp_29 = tmp_28;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_29 = 268435456U;
                                                                    
#line 735 
                                                                    tmp_30 = tmp_29;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_30 = 536870912U;
                                                                    
#line 735 
                                                                    tmp_31 = tmp_30;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_31 = 1073741824U;
                                                                    
#line 735 
                                                                    tmp_32 = tmp_31;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_32 = 2147483648U;
                                                                    
#line 735 
                                                                    tmp_33 = tmp_32;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_33 = 0U;
                                                                    
#line 735 
                                                                    tmp_34 = tmp_33;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_34 = 0U;
                                                                    
#line 735 
                                                                    tmp_35 = tmp_34;
                                                                    }
                                                                    else 
                                                                    
#line 735 
                                                                    tmp_35 = 0U;
                                                                    
#line 735 
                                                                    tmp_36 = tmp_35;
                                                                  }
                                                                  else 
                                                                    
#line 735 
                                                                    tmp_36 = 0U;
                                                                  
#line 735 
                                                                  tmp_37 = tmp_36;
                                                                }
                                                                else 
                                                                  
#line 735 
                                                                  tmp_37 = 0U;
                                                                
#line 735 
                                                                tmp_38 = tmp_37;
                                                              }
                                                              else 
#line 735 
                                                                   tmp_38 = 0U;
                                                              
#line 735 
                                                              tmp_39 = tmp_38;
                                                            }
                                                            else 
#line 735 
                                                                 tmp_39 = 0U;
                                                            
#line 735 
                                                            tmp_40 = tmp_39;
                                                          }
                                                          else 
#line 735 
                                                               tmp_40 = 0U;
                                                          
#line 735 
                                                          tmp_41 = tmp_40;
                                                        }
                                                        else 
#line 735 
                                                             tmp_41 = 0U;
                                                        
#line 735 
                                                        tmp_42 = tmp_41;
                                                      }
                                                      else 
#line 735 
                                                           tmp_42 = 0U;
                                                      
#line 735 
                                                      tmp_43 = tmp_42;
                                                    }
                                                    else 
#line 735 
                                                         tmp_43 = 0U;
                                                    
#line 735 
                                                    tmp_44 = tmp_43;
                                                  }
                                                  else 
#line 735 
                                                       tmp_44 = 0U;
                                                  
#line 735 
                                                  tmp_45 = tmp_44;
                                                }
                                                else 
#line 735 
                                                     tmp_45 = 0U;
                                                
#line 735 
                                                tmp_46 = tmp_45;
                                              }
                                              else 
#line 735 
                                                   tmp_46 = 0U;
                                              
#line 735 
                                              tmp_47 = tmp_46;
                                            }
                                            else 
#line 735 
                                                 tmp_47 = 0U;
                                            
#line 735 
                                            tmp_48 = tmp_47;
                                          }
                                          else 
#line 735 
                                               tmp_48 = 0U;
                                          
#line 735 
                                          tmp_49 = tmp_48;
                                        }
                                        else 
#line 735 
                                             tmp_49 = 0U;
                                        
#line 735 
                                        tmp_50 = tmp_49;
                                      }
                                      else 
#line 735 
                                           tmp_50 = 0U;
                                      
#line 735 
                                      tmp_51 = tmp_50;
                                    }
                                    else 
#line 735 
                                         tmp_51 = 0U;
                                    
#line 735 
                                    tmp_52 = tmp_51;
                                  }
                                  else 
#line 735 
                                       tmp_52 = 0U;
                                  
#line 735 
                                  tmp_53 = tmp_52;
                                }
                                else 
#line 735 
                                     tmp_53 = 0U;
                                
#line 735 
                                tmp_54 = tmp_53;
                              }
                              else 
#line 735 
                                   tmp_54 = 0U;
                              
#line 735 
                              tmp_55 = tmp_54;
                            }
                            else 
#line 735 
                                 tmp_55 = 0U;
                            
#line 735 
                            tmp_56 = tmp_55;
                          }
                          else 
#line 735 
                               tmp_56 = 0U;
                          
#line 735 
                          tmp_57 = tmp_56;
                        }
                        else 
#line 735 
                             tmp_57 = 0U;
                        
#line 735 
                        tmp_58 = tmp_57;
                      }
                      else 
#line 735 
                           tmp_58 = 0U;
                      
#line 735 
                      tmp_59 = tmp_58;
                    }
                    else 
#line 735 
                         tmp_59 = 0U;
                    
#line 735 
                    tmp_60 = tmp_59;
                  }
                  else 
#line 735 
                       tmp_60 = 0U;
                  
#line 735 
                  tmp_61 = tmp_60;
                }
                else 
#line 735 
                     tmp_61 = 0U;
                
#line 735 
                tmp_62 = tmp_61;
              }
              else 
#line 735 
                   tmp_62 = 0U;
              
#line 735 
              tmp_63 = tmp_62;
            }
            else 
#line 735 
                 tmp_63 = 0U;
            
#line 735 
            tmp_64 = tmp_63;
          }
          else 
#line 735 
               tmp_64 = 0U;
          
#line 735 
          tmp_65 = tmp_64;
        }
        
#line 735 
        tmp_67 = tmp_65;
      }
      else {
        int tmp_66;
        
#line 735 
        tmp_66 = __ilog2_u32(bufs_in_recycle_ring / efx->rx_bufs_per_page + 4294967295U);
        
#line 735 
        tmp_67 = (unsigned int)(1UL << (tmp_66 + 1));
      }
      
#line 735 
      tmp_68 = tmp_67;
    }
    else 
#line 735 
         tmp_68 = 1U;
    
#line 735 
    page_ring_size = tmp_68;
  }
  else {
    unsigned long tmp_69;
    
#line 735 
    tmp_69 = __roundup_pow_of_two((unsigned long)(bufs_in_recycle_ring / efx->rx_bufs_per_page));
    
#line 735 
    page_ring_size = (unsigned int)tmp_69;
  }
  
#line 737 
  rx_queue->page_ring = (struct page **)kcalloc_4((unsigned long)page_ring_size,8UL,208U);
  
#line 739 
  rx_queue->page_ptr_mask = page_ring_size + 4294967295U;
  
#line 740 
  return;
}


#line 742  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c"
void efx_init_rx_queue(struct efx_rx_queue *rx_queue)
{
  unsigned int max_fill;
  unsigned int trigger;
  unsigned int max_trigger;
  
#line 744 
  struct efx_nic *efx = rx_queue->efx;
  
#line 747 
  if (((rx_queue->efx)->msg_enable & 1U) != 0U) {
    
#line 747 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_init_rx_queue", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c", .format = "initialising RX queue %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))748U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 747 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      int tmp;
      
#line 747 
      tmp = efx_rx_queue_index(rx_queue);
      
#line 747 
      ;
      
#line 747 
      __dynamic_netdev_dbg(& descriptor,(struct net_device const *)(rx_queue->efx)->net_dev,"initialising RX queue %d\n",tmp);
    }
    else ;
  }
  else ;
  
#line 751 
  rx_queue->added_count = 0U;
  
#line 752 
  rx_queue->notified_count = 0U;
  
#line 753 
  rx_queue->removed_count = 0U;
  
#line 754 
  rx_queue->min_fill = 4294967295U;
  
#line 755 
  efx_init_rx_recycle_ring(efx,rx_queue);
  
#line 757 
  rx_queue->page_remove = 0U;
  
#line 758 
  rx_queue->page_add = rx_queue->page_ptr_mask + 1U;
  
#line 759 
  rx_queue->page_recycle_count = 0U;
  
#line 760 
  rx_queue->page_recycle_failed = 0U;
  
#line 761 
  rx_queue->page_recycle_full = 0U;
  
#line 764 
  max_fill = efx->rxq_entries + 4294967289U;
  
#line 765 
  max_trigger = max_fill - efx->rx_pages_per_batch * efx->rx_bufs_per_page;
  
#line 767 
  if (rx_refill_threshold != 0U) {
    unsigned int tmp_1;
    {
      unsigned int tmp_0;
      
#line 768 
      unsigned int _min1 = rx_refill_threshold;
      
#line 768 
      unsigned int _min2 = 100U;
      
#line 768 
      if (_min1 < _min2) 
#line 768 
                         tmp_0 = _min1; else 
#line 768 
                                             tmp_0 = _min2;
      
#line 768 
      tmp_1 = tmp_0;
    }
    
#line 768 
    trigger = (tmp_1 * max_fill) / 100U;
    
#line 769 
    if (trigger > max_trigger) 
#line 770 
                               trigger = max_trigger; else ;
  }
  else 
#line 772 
       trigger = max_trigger;
  
#line 775 
  rx_queue->max_fill = max_fill;
  
#line 776 
  rx_queue->fast_fill_trigger = trigger;
  
#line 777 
  rx_queue->refill_enabled = (_Bool)1;
  
#line 780 
  efx_nic_init_rx(rx_queue);
  
#line 781 
  return;
}


#line 783  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c"
void efx_fini_rx_queue(struct efx_rx_queue *rx_queue)
{
  int i;
  struct efx_rx_buffer *rx_buf;
  
#line 786 
  struct efx_nic *efx = rx_queue->efx;
  
#line 789 
  if (((rx_queue->efx)->msg_enable & 1U) != 0U) {
    
#line 789 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_fini_rx_queue", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c", .format = "shutting down RX queue %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))790U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 789 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      int tmp;
      
#line 789 
      tmp = efx_rx_queue_index(rx_queue);
      
#line 789 
      ;
      
#line 789 
      __dynamic_netdev_dbg(& descriptor,(struct net_device const *)(rx_queue->efx)->net_dev,"shutting down RX queue %d\n",tmp);
    }
    else ;
  }
  else ;
  
#line 792 
  ldv_del_timer_sync_87(& rx_queue->slow_fill);
  
#line 795 
  if (rx_queue->buffer != (struct efx_rx_buffer *)0) {
    
#line 796 
    i = (int)rx_queue->removed_count;
    
#line 796 
    goto ldv_56570;
    ldv_56569: 
#line 797 
    ;
    {
      
#line 798 
      unsigned int index = rx_queue->ptr_mask & (unsigned int)i;
      
#line 799 
      rx_buf = efx_rx_buffer(rx_queue,index);
      
#line 800 
      efx_fini_rx_buffer(rx_queue,rx_buf);
    }
    
#line 797 
    i += 1;
    ldv_56570: 
#line 798 
    ;
    
#line 796 
    if (rx_queue->added_count > (unsigned int)i) 
#line 798 
                                                 goto ldv_56569; else 
                                                                   
#line 801 
                                                                   goto ldv_56571;
    ldv_56571: 
#line 802 
    ;
  }
  else ;
  
#line 805 
  i = 0;
  
#line 805 
  goto ldv_56576;
  ldv_56575: 
#line 806 
  ;
  {
    struct efx_rx_page_state *state;
    
#line 806 
    struct page *page = *(rx_queue->page_ring + i);
    
#line 809 
    if (page == (struct page *)0) 
#line 810 
                                  goto ldv_56574; else ;
    
#line 812 
    state = (struct efx_rx_page_state *)lowmem_page_address((struct page const *)page);
    
#line 813 
    dma_unmap_page(& (efx->pci_dev)->dev,state->dma_addr,4096UL << efx->rx_buffer_order,(enum dma_data_direction)DMA_FROM_DEVICE);
    
#line 816 
    put_page(page);
  }
  ldv_56574: 
#line 818 
  ;
  
#line 805 
  i += 1;
  ldv_56576: 
#line 806 
  ;
  
#line 805 
  if (rx_queue->page_ptr_mask >= (unsigned int)i) 
#line 807 
                                                  goto ldv_56575; else 
                                                                    
#line 810 
                                                                    goto ldv_56577;
  ldv_56577: 
#line 811 
  ;
  
#line 818 
  kfree((void const *)rx_queue->page_ring);
  
#line 819 
  rx_queue->page_ring = (struct page **)0;
  
#line 820 
  return;
}


#line 822  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c"
void efx_remove_rx_queue(struct efx_rx_queue *rx_queue)
{
  
#line 824 
  if (((rx_queue->efx)->msg_enable & 1U) != 0U) {
    
#line 824 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_remove_rx_queue", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c", .format = "destroying RX queue %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))825U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 824 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      int tmp;
      
#line 824 
      tmp = efx_rx_queue_index(rx_queue);
      
#line 824 
      ;
      
#line 824 
      __dynamic_netdev_dbg(& descriptor,(struct net_device const *)(rx_queue->efx)->net_dev,"destroying RX queue %d\n",tmp);
    }
    else ;
  }
  else ;
  
#line 827 
  efx_nic_remove_rx(rx_queue);
  
#line 829 
  kfree((void const *)rx_queue->buffer);
  
#line 830 
  rx_queue->buffer = (struct efx_rx_buffer *)0;
  
#line 831 
  return;
}


#line 840  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c"
int efx_filter_rfs(struct net_device *net_dev, struct sk_buff const *skb, u16 rxq_index, u32 flow_id)
{
  int __retres;
  struct efx_channel *channel;
  struct efx_filter_spec spec;
  __be16 const *ports;
  __be16 ether_type;
  int nhoff;
  int rc;
  int tmp_0;
  u16 tmp_2;
  
#line 843 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 856 
  if ((unsigned int)skb->protocol == 129U) {
    
#line 857 
    struct vlan_hdr const *vh = (struct vlan_hdr const *)skb->data;
    
#line 865 
    ether_type = vh->h_vlan_encapsulated_proto;
    
#line 866 
    nhoff = 4;
  }
  else {
    
#line 868 
    ether_type = skb->protocol;
    
#line 869 
    nhoff = 0;
  }
  
#line 872 
  if ((unsigned int)ether_type != 8U && (unsigned int)ether_type != 56710U) {
    
#line 873 
    __retres = -93;
    
#line 873 
    goto return_label;
  }
  else ;
  
#line 875 
  ;
  
#line 876 
  if ((int)efx->rx_scatter != 0) 
#line 876 
                                 tmp_0 = 2; else 
#line 876 
                                                 tmp_0 = 0;
  
#line 875 
  efx_filter_init_rx(& spec,(enum efx_filter_priority)EFX_FILTER_PRI_HINT,(enum efx_filter_flags)tmp_0,(unsigned int)rxq_index);
  
#line 878 
  spec.match_flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))))619U;
  
#line 882 
  spec.ether_type = ether_type;
  
#line 884 
  if ((unsigned int)ether_type == 8U) {
    bool tmp_1;
    
#line 885 
    struct iphdr const *ip = (struct iphdr const *)(skb->data + nhoff);
    
#line 889 
    tmp_1 = ip_is_fragment(ip);
    
#line 889 
    if ((int)tmp_1 != 0) {
      
#line 890 
      __retres = -93;
      
#line 890 
      goto return_label;
    }
    else ;
    
#line 891 
    spec.ip_proto = ip->protocol;
    
#line 892 
    spec.rem_host[0] = ip->saddr;
    
#line 893 
    spec.loc_host[0] = ip->daddr;
    
#line 895 
    ports = (__be16 const *)(skb->data + (nhoff + (int)ip->ihl * 4));
  }
  else {
    
#line 897 
    struct ipv6hdr const *ip6 = (struct ipv6hdr const *)(skb->data + nhoff);
    
#line 902 
    spec.ip_proto = ip6->nexthdr;
    
#line 903 
    memcpy((void *)(& spec.rem_host),(void const *)(& ip6->saddr),16UL);
    
#line 904 
    memcpy((void *)(& spec.loc_host),(void const *)(& ip6->daddr),16UL);
    
#line 905 
    ports = (__be16 const *)(ip6 + 1U);
  }
  
#line 908 
  spec.rem_port = *ports;
  
#line 909 
  spec.loc_port = *(ports + 1U);
  
#line 911 
  rc = (*((efx->type)->filter_rfs_insert))(efx,& spec);
  
#line 912 
  if (rc < 0) {
    
#line 913 
    __retres = rc;
    
#line 913 
    goto return_label;
  }
  else ;
  
#line 916 
  *(efx->rps_flow_id + rc) = flow_id;
  
#line 917 
  tmp_2 = skb_get_rx_queue(skb);
  
#line 917 
  ;
  
#line 917 
  channel = efx_get_channel(efx,(unsigned int)tmp_2);
  
#line 918 
  channel->rfs_filters_added += 1U;
  
#line 920 
  if ((unsigned int)ether_type == 8U) {
    
#line 921 
    if ((efx->msg_enable & 2048U) != 0U) {
      int tmp_4;
      int tmp_6;
      char *tmp_7;
      
#line 921 
      ;
      
#line 921 
      ;
      
#line 921 
      ;
      
#line 921 
      if (0 != 0) 
#line 921 
                  tmp_4 = (int)((unsigned short)(((int)*(ports + 1U) << 8) | ((int)*(ports + 1U) >> 8)));
      else {
        __u16 tmp_3;
        
#line 921 
        tmp_3 = __fswab16((unsigned short)((int)*(ports + 1U)));
        
#line 921 
        tmp_4 = (int)tmp_3;
      }
      
#line 921 
      if (0 != 0) 
#line 921 
                  tmp_6 = (int)((unsigned short)(((int)*ports << 8) | ((int)*ports >> 8)));
      else {
        __u16 tmp_5;
        
#line 921 
        tmp_5 = __fswab16((unsigned short)((int)*ports));
        
#line 921 
        tmp_6 = (int)tmp_5;
      }
      
#line 921 
      if ((unsigned int)spec.ip_proto == 6U) 
#line 921 
                                             tmp_7 = (char *)"TCP"; else 
                                                                    
#line 921 
                                                                    tmp_7 = (char *)"UDP";
      
#line 921 
      ;
      
#line 921 
      netdev_info((struct net_device const *)efx->net_dev,"steering %s %pI4:%u:%pI4:%u to queue %u [flow %u filter %d]\n",tmp_7,(__be32 *)(& spec.rem_host),tmp_6,(__be32 *)(& spec.loc_host),tmp_4,(int)rxq_index,flow_id,rc);
    }
    else ;
  }
  else 
    
#line 927 
    if ((efx->msg_enable & 2048U) != 0U) {
      int tmp_9;
      int tmp_11;
      char *tmp_12;
      
#line 927 
      ;
      
#line 927 
      ;
      
#line 927 
      ;
      
#line 927 
      if (0 != 0) 
#line 927 
                  tmp_9 = (int)((unsigned short)(((int)*(ports + 1U) << 8) | ((int)*(ports + 1U) >> 8)));
      else {
        __u16 tmp_8;
        
#line 927 
        tmp_8 = __fswab16((unsigned short)((int)*(ports + 1U)));
        
#line 927 
        tmp_9 = (int)tmp_8;
      }
      
#line 927 
      if (0 != 0) 
#line 927 
                  tmp_11 = (int)((unsigned short)(((int)*ports << 8) | ((int)*ports >> 8)));
      else {
        __u16 tmp_10;
        
#line 927 
        tmp_10 = __fswab16((unsigned short)((int)*ports));
        
#line 927 
        tmp_11 = (int)tmp_10;
      }
      
#line 927 
      if ((unsigned int)spec.ip_proto == 6U) 
#line 927 
                                             tmp_12 = (char *)"TCP"; else 
                                                                    
#line 927 
                                                                    tmp_12 = (char *)"UDP";
      
#line 927 
      ;
      
#line 927 
      netdev_info((struct net_device const *)efx->net_dev,"steering %s [%pI6]:%u:[%pI6]:%u to queue %u [flow %u filter %d]\n",tmp_12,(__be32 *)(& spec.rem_host),tmp_11,(__be32 *)(& spec.loc_host),tmp_9,(int)rxq_index,flow_id,rc);
    }
    else ;
  
#line 933 
  __retres = rc;
  return_label: 
#line 933 
                return __retres;
}


#line 936  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c"
bool __efx_filter_rfs_expire(struct efx_nic *efx, unsigned int quota)
{
  bool __retres;
  bool (*expire_one)(struct efx_nic *, u32 , unsigned int );
  unsigned int index;
  unsigned int size;
  u32 flow_id;
  int tmp;
  bool tmp_0;
  unsigned int tmp_1;
  
#line 942 
  tmp = ldv_spin_trylock_bh_88(& efx->filter_lock);
  
#line 942 
  if (tmp == 0) {
    
#line 943 
    __retres = (_Bool)0;
    
#line 943 
    goto return_label;
  }
  else ;
  
#line 945 
  expire_one = (efx->type)->filter_rfs_expire_one;
  
#line 946 
  index = efx->rps_expire_index;
  
#line 947 
  size = (efx->type)->max_rx_ip_filters;
  
#line 948 
  goto ldv_56636;
  ldv_56635: 
#line 949 
  ;
  
#line 949 
  flow_id = *(efx->rps_flow_id + index);
  
#line 950 
  tmp_0 = (*expire_one)(efx,flow_id,index);
  
#line 950 
  if ((int)tmp_0 != 0) {
    
#line 951 
    if ((efx->msg_enable & 2048U) != 0U) 
#line 951 
                                         netdev_info((struct net_device const *)efx->net_dev,"expired filter %d [flow %u]\n",index,flow_id); else ;
  }
  else ;
  
#line 954 
  index += 1U;
  
#line 954 
  ;
  
#line 954 
  if (index == size) 
#line 955 
                     index = 0U; else ;
  ldv_56636: 
#line 956 
  ;
  
#line 948 
  tmp_1 = quota;
  
#line 948 
  quota -= 1U;
  
#line 948 
  ;
  
#line 948 
  if (tmp_1 != 0U) 
#line 950 
                   goto ldv_56635; else 
#line 953 
                                        goto ldv_56637;
  ldv_56637: 
#line 954 
  ;
  
#line 957 
  efx->rps_expire_index = index;
  
#line 959 
  ldv_spin_unlock_bh_89(& efx->filter_lock);
  
#line 960 
  __retres = (_Bool)1;
  return_label: 
#line 960 
                return __retres;
}


#line 974  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/rx.c"
bool efx_filter_is_mc_recipient(struct efx_filter_spec const *spec)
{
  bool __retres;
  
#line 976 
  if (((int)spec->flags & 8) == 0 || (unsigned int)*((unsigned short *)spec + 1UL) == 65520U) {
    
#line 978 
    __retres = (_Bool)0;
    
#line 978 
    goto return_label;
  }
  else ;
  
#line 980 
  if (((int)spec->match_flags & 1040) != 0) {
    bool tmp;
    
#line 981 
    tmp = is_multicast_ether_addr((u8 const *)(& spec->loc_mac));
    
#line 981 
    if ((int)tmp != 0) {
      
#line 983 
      __retres = (_Bool)1;
      
#line 983 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 985 
  if (((int)spec->match_flags & 66) == 66) {
    
#line 988 
    if ((unsigned int)spec->ether_type == 8U) {
      bool tmp_0;
      
#line 988 
      tmp_0 = ipv4_is_multicast(spec->loc_host[0]);
      
#line 988 
      if ((int)tmp_0 != 0) {
        
#line 990 
        __retres = (_Bool)1;
        
#line 990 
        goto return_label;
      }
      else ;
    }
    else ;
    
#line 991 
    if ((unsigned int)spec->ether_type == 56710U && (unsigned int)*((u8 const *)(& spec->loc_host)) == 255U) {
      
#line 993 
      __retres = (_Bool)1;
      
#line 993 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 996 
  __retres = (_Bool)0;
  return_label: 
#line 996 
                return __retres;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
int ldv_emg_del_timer_sync(struct timer_list *arg0);


#line 125  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void atomic_inc_1(atomic_t *v)
{
  
#line 128 
  ldv_atomic_inc(v);
  
#line 129 
  return;
}


#line 434  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void *kcalloc_4(size_t n, size_t size, gfp_t flags)
{
  void *tmp;
  
#line 437 
  tmp = ldv_kcalloc(n,size,flags);
  
#line 437 
  return tmp;
}


#line 888  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static int ldv_del_timer_sync_87(struct timer_list *ldv_func_arg1)
{
  int tmp;
  
#line 892 
  tmp = ldv_emg_del_timer_sync(ldv_func_arg1);
  
#line 892 
  return tmp;
}


#line 896  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static int ldv_spin_trylock_bh_88(spinlock_t *lock)
{
  int __retres;
  
#line 900 
  ldv_func_ret_type ldv_func_res = spin_trylock_bh(lock);
  
#line 902 
  int is_spin_held_by_another_thread = ldv_undef_int();
  
#line 904 
  if (is_spin_held_by_another_thread != 0) {
    
#line 907 
    __retres = 0;
    
#line 907 
    goto return_label;
  }
  else {
    
#line 910 
    ldv_spin_model_lock((char *)"filter_lock_of_efx_nic");
    
#line 912 
    __retres = 1;
    
#line 912 
    goto return_label;
  }
  
#line 915 
  __retres = ldv_func_res;
  return_label: 
#line 915 
                return __retres;
}


#line 919  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_unlock_bh_89(spinlock_t *lock)
{
  
#line 923 
  ldv_spin_model_unlock((char *)"filter_lock_of_efx_nic");
  
#line 925 
  spin_unlock_bh_1(lock);
  
#line 926 
  return;
}


#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void)
{
  struct task_struct *tmp;
  {
    struct task_struct *pfo_ret__;
    
#line 14 
    switch (8UL) {
      case (unsigned long)1: 
#line 14 
      ;
      
#line 15 
      ldv_inline_asm();
      
#line 14 
      goto ldv_3477;
      case (unsigned long)2: 
#line 14 
      ;
      
#line 15 
      ldv_inline_asm();
      
#line 14 
      goto ldv_3477;
      case (unsigned long)4: 
#line 14 
      ;
      
#line 15 
      ldv_inline_asm();
      
#line 14 
      goto ldv_3477;
      case (unsigned long)8: 
#line 14 
      ;
      
#line 15 
      ldv_inline_asm();
      
#line 14 
      goto ldv_3477;
      default: 
#line 14 
      ;
      
#line 14 
      __bad_percpu_size();
    }
    ldv_3477: 
#line 14 
    ;
    
#line 14 
    tmp = pfo_ret__;
  }
  
#line 14 
  return tmp;
}


#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_add(int val)
{
  int tmp;
  
#line 72 
  if (0 != 0 && (val == 1 || val == -1)) 
#line 72 
                                         tmp = val; else 
#line 72 
                                                         tmp = 0;
  
#line 72 
  int const pao_ID__ = tmp;
  
#line 72 
  switch (4UL) {
    case (unsigned long)1: 
#line 72 
    ;
    
#line 72 
    if (pao_ID__ == 1) 
#line 74 
                       ldv_inline_asm();
    else 
      
#line 72 
      if (pao_ID__ == -1) 
#line 74 
                          ldv_inline_asm(); else 
#line 77 
                                                 ldv_inline_asm();
    
#line 72 
    goto ldv_6377;
    case (unsigned long)2: 
#line 72 
    ;
    
#line 72 
    if (pao_ID__ == 1) 
#line 74 
                       ldv_inline_asm();
    else 
      
#line 72 
      if (pao_ID__ == -1) 
#line 74 
                          ldv_inline_asm(); else 
#line 77 
                                                 ldv_inline_asm();
    
#line 72 
    goto ldv_6377;
    case (unsigned long)4: 
#line 72 
    ;
    
#line 72 
    if (pao_ID__ == 1) 
#line 74 
                       ldv_inline_asm();
    else 
      
#line 72 
      if (pao_ID__ == -1) 
#line 74 
                          ldv_inline_asm(); else 
#line 77 
                                                 ldv_inline_asm();
    
#line 72 
    goto ldv_6377;
    case (unsigned long)8: 
#line 72 
    ;
    
#line 72 
    if (pao_ID__ == 1) 
#line 74 
                       ldv_inline_asm();
    else 
      
#line 72 
      if (pao_ID__ == -1) 
#line 74 
                          ldv_inline_asm(); else 
#line 77 
                                                 ldv_inline_asm();
    
#line 72 
    goto ldv_6377;
    default: 
#line 72 
    ;
    
#line 72 
    __bad_percpu_size();
  }
  ldv_6377: 
#line 72 
  ;
  
#line 74 
  return;
}


#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_sub(int val)
{
  int tmp;
  
#line 77 
  if (0 != 0 && (- val == 1 || - val == -1)) 
#line 77 
                                             tmp = - val; else 
#line 77 
                                                               tmp = 0;
  
#line 77 
  int const pao_ID__ = tmp;
  
#line 77 
  switch (4UL) {
    case (unsigned long)1: 
#line 77 
    ;
    
#line 77 
    if (pao_ID__ == 1) 
#line 79 
                       ldv_inline_asm();
    else 
      
#line 77 
      if (pao_ID__ == -1) 
#line 79 
                          ldv_inline_asm(); else 
#line 82 
                                                 ldv_inline_asm();
    
#line 77 
    goto ldv_6389;
    case (unsigned long)2: 
#line 77 
    ;
    
#line 77 
    if (pao_ID__ == 1) 
#line 79 
                       ldv_inline_asm();
    else 
      
#line 77 
      if (pao_ID__ == -1) 
#line 79 
                          ldv_inline_asm(); else 
#line 82 
                                                 ldv_inline_asm();
    
#line 77 
    goto ldv_6389;
    case (unsigned long)4: 
#line 77 
    ;
    
#line 77 
    if (pao_ID__ == 1) 
#line 79 
                       ldv_inline_asm();
    else 
      
#line 77 
      if (pao_ID__ == -1) 
#line 79 
                          ldv_inline_asm(); else 
#line 82 
                                                 ldv_inline_asm();
    
#line 77 
    goto ldv_6389;
    case (unsigned long)8: 
#line 77 
    ;
    
#line 77 
    if (pao_ID__ == 1) 
#line 79 
                       ldv_inline_asm();
    else 
      
#line 77 
      if (pao_ID__ == -1) 
#line 79 
                          ldv_inline_asm(); else 
#line 82 
                                                 ldv_inline_asm();
    
#line 77 
    goto ldv_6389;
    default: 
#line 77 
    ;
    
#line 77 
    __bad_percpu_size();
  }
  ldv_6389: 
#line 77 
  ;
  
#line 79 
  return;
}


#line 24  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kmalloc(size_t size, gfp_t flags);


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/io.h"
void __iowrite64_copy(void *, void const *, size_t);


#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kmalloc(size_t size, gfp_t flags);


#line 542 
static void *kcalloc_5(size_t n, size_t size, gfp_t flags);


#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_single_attrs(struct device *dev, void *ptr, size_t size, enum dma_data_direction dir, struct dma_attrs *attrs)
{
  dma_addr_t addr;
  int tmp_0;
  unsigned long tmp_1;
  unsigned long tmp_2;
  
#line 15 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 18 
  kmemcheck_mark_initialized(ptr,(unsigned int)size);
  
#line 19 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 19 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 21 
    ldv_inline_asm();
    
#line 19 
    ;
  }
  else ;
  
#line 20 
  ;
  
#line 20 
  ;
  
#line 20 
  ;
  
#line 20 
  ;
  
#line 20 
  tmp_1 = __phys_addr((unsigned long)ptr);
  
#line 20 
  ;
  
#line 20 
  addr = (*(ops->map_page))(dev,(struct page *)(-24189255811072) + (tmp_1 >> 12),(unsigned long)ptr & 4095UL,size,dir,attrs);
  
#line 23 
  ;
  
#line 23 
  ;
  
#line 23 
  ;
  
#line 23 
  ;
  
#line 23 
  tmp_2 = __phys_addr((unsigned long)ptr);
  
#line 23 
  ;
  
#line 23 
  debug_dma_map_page(dev,(struct page *)(-24189255811072) + (tmp_2 >> 12),(unsigned long)ptr & 4095UL,size,(int)dir,addr,(_Bool)1);
  
#line 26 
  return addr;
}


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_single_attrs(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir, struct dma_attrs *attrs)
{
  int tmp_0;
  
#line 34 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 36 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 36 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 38 
    ldv_inline_asm();
    
#line 36 
    ;
  }
  else ;
  
#line 37 
  if (ops->unmap_page != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction , struct dma_attrs *))0) 
    
#line 38 
    (*(ops->unmap_page))(dev,addr,size,dir,attrs); else ;
  
#line 39 
  debug_dma_unmap_page(dev,addr,size,(int)dir,(_Bool)1);
  
#line 40 
  return;
}


#line 230  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned int skb_frag_size(skb_frag_t const *frag)
{
  unsigned int __retres;
  
#line 232 
  __retres = frag->size;
  
#line 232 
  return __retres;
}


#line 862 
int skb_pad(struct sk_buff *, int);


#line 1572  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned int skb_headlen(struct sk_buff const *skb)
{
  unsigned int __retres;
  
#line 1574 
  __retres = skb->len - skb->data_len;
  
#line 1574 
  return __retres;
}


#line 1880  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_transport_header(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 1882 
  __retres = skb->head + (int)skb->transport_header;
  
#line 1882 
  return __retres;
}


#line 1897  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_network_header(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 1899 
  __retres = skb->head + (int)skb->network_header;
  
#line 1899 
  return __retres;
}


#line 2272  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct page *skb_frag_page(skb_frag_t const *frag)
{
  struct page *__retres;
  
#line 2274 
  __retres = frag->page.p;
  
#line 2274 
  return __retres;
}


#line 2390  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static dma_addr_t skb_frag_dma_map(struct device *dev, skb_frag_t const *frag, size_t offset, size_t size, enum dma_data_direction dir)
{
  dma_addr_t tmp_0;
  struct page *tmp;
  
#line 2395 
  ;
  
#line 2395 
  ;
  
#line 2395 
  ;
  
#line 2395 
  tmp = skb_frag_page(frag);
  
#line 2395 
  ;
  
#line 2395 
  tmp_0 = dma_map_page(dev,tmp,(unsigned long)frag->page_offset + offset,size,dir);
  
#line 2395 
  return tmp_0;
}


#line 3295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static u16 skb_get_queue_mapping(struct sk_buff const *skb)
{
  u16 __retres;
  
#line 3297 
  __retres = skb->queue_mapping;
  
#line 3297 
  return __retres;
}


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_queue_limits.h"
__inline static void dql_queued(struct dql *dql, unsigned int count)
{
  
#line 74 
  if ((long)(count > 268435455U) != 0L) {
    
#line 76 
    ldv_inline_asm();
    
#line 74 
    ;
  }
  else ;
  
#line 76 
  dql->last_obj_cnt = count;
  
#line 77 
  ldv_inline_asm();
  
#line 85 
  dql->num_queued += count;
  
#line 86 
  return;
}


#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_queue_limits.h"
__inline static int dql_avail(struct dql const *dql)
{
  int __retres;
  unsigned int const volatile *tmp;
  unsigned int const volatile *tmp_0;
  {
    
#line 91 
    unsigned int const __var = 0U;
    
#line 91 
    tmp = (unsigned int const volatile *)(& dql->adj_limit);
  }
  {
    
#line 91 
    unsigned int const __var_0 = 0U;
    
#line 91 
    tmp_0 = (unsigned int const volatile *)(& dql->num_queued);
  }
  
#line 91 
  ;
  
#line 91 
  __retres = (int)(*tmp - *tmp_0);
  
#line 91 
  return __retres;
}


#line 98 
void dql_reset(struct dql *);


#line 2515  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_start_queue(struct netdev_queue *dev_queue)
{
  
#line 2517 
  set_bit(0L,(unsigned long volatile *)(& dev_queue->state));
  
#line 2518 
  return;
}


#line 2541 
void netif_tx_wake_queue(struct netdev_queue *);


#line 2584  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool netif_tx_queue_stopped(struct netdev_queue const *dev_queue)
{
  bool __retres;
  int tmp;
  
#line 2586 
  tmp = constant_test_bit(0L,(unsigned long const volatile *)(& dev_queue->state));
  
#line 2586 
  __retres = (_Bool)(tmp != 0);
  
#line 2586 
  return __retres;
}


#line 2600  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool netif_xmit_stopped(struct netdev_queue const *dev_queue)
{
  bool __retres;
  
#line 2602 
  __retres = (_Bool)((dev_queue->state & 3UL) != 0UL);
  
#line 2602 
  return __retres;
}


#line 2645  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netdev_tx_sent_queue(struct netdev_queue *dev_queue, unsigned int bytes)
{
  int tmp;
  int tmp_0;
  
#line 2649 
  dql_queued(& dev_queue->dql,bytes);
  
#line 2651 
  tmp = dql_avail((struct dql const *)(& dev_queue->dql));
  
#line 2651 
  if ((long)(tmp >= 0) != 0L) 
#line 2652 
                              goto return_label; else ;
  
#line 2654 
  set_bit(1L,(unsigned long volatile *)(& dev_queue->state));
  
#line 2655 
  ldv_inline_asm();
  
#line 2664 
  tmp_0 = dql_avail((struct dql const *)(& dev_queue->dql));
  
#line 2664 
  if ((long)(tmp_0 >= 0) != 0L) 
#line 2665 
                                set_bit(1L,(unsigned long volatile *)(& dev_queue->state)); else ;
  return_label: 
#line 2666 
                return;
}


#line 2723  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netdev_tx_reset_queue(struct netdev_queue *q)
{
  
#line 2726 
  set_bit(1L,(unsigned long volatile *)(& q->state));
  
#line 2727 
  dql_reset(& q->dql);
  
#line 2728 
  return;
}


#line 2867 
int netif_set_real_num_tx_queues(struct net_device *, unsigned int);


#line 2900 
void __dev_kfree_skb_any(struct sk_buff *, enum skb_free_reason);


#line 2931  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void dev_kfree_skb_any(struct sk_buff *skb)
{
  
#line 2933 
  __dev_kfree_skb_any(skb,(enum skb_free_reason)SKB_REASON_DROPPED);
  
#line 2934 
  return;
}


#line 2936  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void dev_consume_skb_any(struct sk_buff *skb)
{
  
#line 2938 
  __dev_kfree_skb_any(skb,(enum skb_free_reason)SKB_REASON_CONSUMED);
  
#line 2939 
  return;
}


#line 3112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool netif_device_present(struct net_device *dev)
{
  bool __retres;
  int tmp;
  
#line 3114 
  tmp = constant_test_bit(1L,(unsigned long const volatile *)(& dev->state));
  
#line 3114 
  __retres = (_Bool)(tmp != 0);
  
#line 3114 
  return __retres;
}


#line 7  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uaccess.h"
__inline static void pagefault_disabled_inc(void)
{
  struct task_struct *tmp;
  
#line 9 
  tmp = get_current();
  
#line 9 
  tmp->pagefault_disabled += 1;
  
#line 10 
  return;
}


#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uaccess.h"
__inline static void pagefault_disabled_dec(void)
{
  struct task_struct *tmp;
  
#line 14 
  tmp = get_current();
  
#line 14 
  tmp->pagefault_disabled -= 1;
  {
    struct task_struct *tmp_0;
    
#line 15 
    tmp_0 = get_current();
    
#line 15 
    int __ret_warn_on = tmp_0->pagefault_disabled < 0;
    
#line 15 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 15 
                                          warn_slowpath_null("include/linux/uaccess.h",15); else ;
    
#line 15 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 17 
  return;
}


#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uaccess.h"
__inline static void pagefault_disable(void)
{
  
#line 27 
  pagefault_disabled_inc();
  
#line 28 
  ldv_inline_asm();
  
#line 29 
  return;
}


#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uaccess.h"
__inline static void pagefault_enable(void)
{
  
#line 37 
  ldv_inline_asm();
  
#line 42 
  pagefault_disabled_dec();
  
#line 43 
  return;
}


#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/tcp.h"
__inline static struct tcphdr *tcp_hdr(struct sk_buff const *skb)
{
  struct tcphdr *tmp;
  
#line 29 
  tmp = (struct tcphdr *)skb_transport_header(skb);
  
#line 29 
  return tmp;
}


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ip.h"
__inline static struct iphdr *ip_hdr(struct sk_buff const *skb)
{
  struct iphdr *tmp;
  
#line 25 
  tmp = (struct iphdr *)skb_network_header(skb);
  
#line 25 
  return tmp;
}


#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/highmem.h"
__inline static void *kmap_atomic(struct page *page)
{
  void *tmp;
  
#line 68 
  __preempt_count_add(1);
  
#line 69 
  ldv_inline_asm();
  
#line 69 
  pagefault_disable();
  
#line 70 
  tmp = lowmem_page_address((struct page const *)page);
  
#line 70 
  return tmp;
}


#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/highmem.h"
__inline static void __kunmap_atomic(void *addr)
{
  
#line 76 
  pagefault_enable();
  
#line 77 
  ldv_inline_asm();
  
#line 77 
  __preempt_count_sub(1);
  
#line 78 
  return;
}


#line 1519  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
__inline static bool efx_xmit_with_hwtstamp(struct sk_buff *skb)
{
  bool __retres;
  unsigned char *tmp;
  
#line 1521 
  tmp = skb_end_pointer((struct sk_buff const *)skb);
  
#line 1521 
  ;
  
#line 1521 
  __retres = (_Bool)(((int)((struct skb_shared_info *)tmp)->tx_flags & 1) != 0);
  
#line 1521 
  return __retres;
}


#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
int efx_probe_tx_queue(struct efx_tx_queue *tx_queue);


#line 27 
void efx_remove_tx_queue(struct efx_tx_queue *tx_queue);


#line 28 
void efx_init_tx_queue(struct efx_tx_queue *tx_queue);


#line 29 
void efx_init_tx_queue_core_txq(struct efx_tx_queue *tx_queue);


#line 30 
void efx_fini_tx_queue(struct efx_tx_queue *tx_queue);


#line 31 
netdev_tx_t efx_hard_start_xmit(struct sk_buff *skb, struct net_device *net_dev);


#line 35 
int efx_setup_tc(struct net_device *net_dev, u8 num_tc);


#line 37 
unsigned int efx_piobuf_size;


#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
static struct efx_tx_queue *efx_tx_queue_partner(struct efx_tx_queue *tx_queue)
{
  struct efx_tx_queue *__retres;
  
#line 77 
  if ((tx_queue->queue & 1U) != 0U) {
    
#line 78 
    __retres = tx_queue + 18446744073709551615U;
    
#line 78 
    goto return_label;
  }
  else {
    
#line 80 
    __retres = tx_queue + 1U;
    
#line 80 
    goto return_label;
  }
  return_label: 
#line 77 
                return __retres;
}


#line 103  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
__inline static bool efx_nic_may_tx_pio(struct efx_tx_queue *tx_queue)
{
  bool __retres;
  int tmp_2;
  
#line 105 
  struct efx_tx_queue *partner = efx_tx_queue_partner(tx_queue);
  
#line 107 
  if (tx_queue->piobuf != (void *)0) {
    bool tmp_0;
    
#line 106 
    tmp_0 = __efx_nic_tx_is_empty(tx_queue,tx_queue->insert_count);
    
#line 106 
    if ((int)tmp_0 != 0) {
      bool tmp_1;
      
#line 107 
      tmp_1 = __efx_nic_tx_is_empty(partner,partner->insert_count);
      
#line 107 
      if ((int)tmp_1 != 0) 
#line 107 
                           tmp_2 = 1; else 
#line 107 
                                           tmp_2 = 0;
    }
    else 
#line 107 
         tmp_2 = 0;
  }
  else 
#line 107 
       tmp_2 = 0;
  
#line 107 
  __retres = (_Bool)(tmp_2 != 0);
  
#line 107 
  return __retres;
}


#line 563 
bool efx_ptp_is_ptp_tx(struct efx_nic *efx, struct sk_buff *skb);


#line 567 
int efx_ptp_tx(struct efx_nic *efx, struct sk_buff *skb);


#line 599  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
__inline static int efx_nic_probe_tx(struct efx_tx_queue *tx_queue)
{
  int tmp;
  
#line 601 
  tmp = (*(((tx_queue->efx)->type)->tx_probe))(tx_queue);
  
#line 601 
  return tmp;
}


#line 603  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
__inline static void efx_nic_init_tx(struct efx_tx_queue *tx_queue)
{
  
#line 605 
  (*(((tx_queue->efx)->type)->tx_init))(tx_queue);
  
#line 606 
  return;
}


#line 607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
__inline static void efx_nic_remove_tx(struct efx_tx_queue *tx_queue)
{
  
#line 609 
  (*(((tx_queue->efx)->type)->tx_remove))(tx_queue);
  
#line 610 
  return;
}


#line 611  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
__inline static void efx_nic_push_buffers(struct efx_tx_queue *tx_queue)
{
  
#line 613 
  (*(((tx_queue->efx)->type)->tx_write))(tx_queue);
  
#line 614 
  return;
}


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
unsigned int efx_piobuf_size = 256U;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
__inline static unsigned int efx_tx_queue_get_insert_index(struct efx_tx_queue const *tx_queue)
{
  unsigned int __retres;
  
#line 39 
  __retres = tx_queue->insert_count & tx_queue->ptr_mask;
  
#line 39 
  return __retres;
}


#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
__inline static struct efx_tx_buffer *__efx_tx_queue_get_insert_buffer(struct efx_tx_queue const *tx_queue)
{
  struct efx_tx_buffer *__retres;
  unsigned int tmp;
  
#line 45 
  tmp = efx_tx_queue_get_insert_index(tx_queue);
  
#line 45 
  ;
  
#line 45 
  __retres = tx_queue->buffer + tmp;
  
#line 45 
  return __retres;
}


#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
__inline static struct efx_tx_buffer *efx_tx_queue_get_insert_buffer(struct efx_tx_queue const *tx_queue)
{
  
#line 51 
  struct efx_tx_buffer *buffer = __efx_tx_queue_get_insert_buffer(tx_queue);
  
#line 58 
  return buffer;
}


#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
static void efx_dequeue_buffer(struct efx_tx_queue *tx_queue, struct efx_tx_buffer *buffer, unsigned int *pkts_compl, unsigned int *bytes_compl)
{
  
#line 66 
  if ((unsigned int)buffer->unmap_len != 0U) {
    
#line 67 
    struct device *dma_dev = & ((tx_queue->efx)->pci_dev)->dev;
    
#line 68 
    dma_addr_t unmap_addr = buffer->__anonCompField_efx_tx_buffer_116.dma_addr - (unsigned long long)buffer->dma_offset;
    
#line 69 
    if (((int)buffer->flags & 8) != 0) 
#line 70 
                                       dma_unmap_single_attrs(dma_dev,unmap_addr,(unsigned long)buffer->unmap_len,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0); else 
                                                                    
#line 73 
                                                                    dma_unmap_page(dma_dev,unmap_addr,(unsigned long)buffer->unmap_len,(enum dma_data_direction)DMA_TO_DEVICE);
    
#line 75 
    buffer->unmap_len = (unsigned short)0U;
  }
  else ;
  
#line 78 
  if (((int)buffer->flags & 2) != 0) {
    
#line 79 
    *pkts_compl += 1U;
    
#line 80 
    *bytes_compl += (buffer->__anonCompField_efx_tx_buffer_115.skb)->len;
    
#line 81 
    dev_consume_skb_any((struct sk_buff *)buffer->__anonCompField_efx_tx_buffer_115.skb);
  }
  else 
    
#line 85 
    if (((int)buffer->flags & 4) != 0) 
#line 86 
                                       kfree((void const *)buffer->__anonCompField_efx_tx_buffer_115.heap_buf); else ;
  
#line 89 
  buffer->len = (unsigned short)0U;
  
#line 90 
  buffer->flags = (unsigned short)0U;
  
#line 91 
  return;
}


#line 93 
static int efx_enqueue_skb_tso(struct efx_tx_queue *tx_queue, struct sk_buff *skb);


#line 97  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
__inline static unsigned int efx_max_tx_len(struct efx_nic *efx, dma_addr_t dma_addr)
{
  int tmp_1;
  
#line 105 
  unsigned int len = (~ ((unsigned int)dma_addr) & 4095U) + 1U;
  
#line 108 
  tmp_1 = efx_nic_rev(efx);
  
#line 108 
  if (tmp_1 <= 1) {
    
#line 108 
    if ((dma_addr & 15ULL) != 0ULL) {
      unsigned int tmp_0;
      {
        unsigned int tmp;
        
#line 109 
        unsigned int __min1 = len;
        
#line 109 
        unsigned int __min2 = 512U - ((unsigned int)dma_addr & 15U);
        
#line 109 
        if (__min1 < __min2) 
#line 109 
                             tmp = __min1; else 
#line 109 
                                                tmp = __min2;
        
#line 109 
        tmp_0 = tmp;
      }
      
#line 109 
      len = tmp_0;
    }
    else ;
  }
  else ;
  
#line 111 
  return len;
}


#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
unsigned int efx_tx_max_skb_descs(struct efx_nic *efx)
{
  int tmp;
  
#line 119 
  unsigned int max_descs = 217U;
  
#line 124 
  tmp = efx_nic_rev(efx);
  
#line 124 
  if (tmp <= 1) 
#line 125 
                max_descs += 100U;
  else {
    int tmp_0;
    
#line 124 
    tmp_0 = efx_nic_rev(efx);
    
#line 124 
    if (tmp_0 > 3) 
#line 125 
                   max_descs += 100U; else ;
  }
  
#line 132 
  return max_descs;
}


#line 135  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
static void efx_tx_maybe_stop_queue(struct efx_tx_queue *txq1)
{
  unsigned int fill_level;
  unsigned int tmp_1;
  unsigned int volatile *tmp_2;
  unsigned int volatile *tmp_3;
  unsigned int tmp_5;
  
#line 138 
  struct efx_tx_queue *txq2 = efx_tx_queue_partner(txq1);
  
#line 139 
  struct efx_nic *efx = txq1->efx;
  {
    unsigned int tmp_0;
    
#line 142 
    unsigned int _max1 = txq1->insert_count - txq1->old_read_count;
    
#line 142 
    unsigned int _max2 = txq2->insert_count - txq2->old_read_count;
    
#line 142 
    if (_max1 > _max2) 
#line 142 
                       tmp_0 = _max1; else 
#line 142 
                                           tmp_0 = _max2;
    
#line 142 
    tmp_1 = tmp_0;
  }
  
#line 142 
  fill_level = tmp_1;
  
#line 144 
  if ((long)(efx->txq_stop_thresh > fill_level) != 0L) 
#line 145 
                                                       goto return_label; else ;
  
#line 161 
  netif_tx_start_queue(txq1->core_txq);
  
#line 162 
  ldv_inline_asm();
  {
    
#line 163 
    unsigned int __var = 0U;
    
#line 163 
    tmp_2 = (unsigned int volatile *)(& txq1->read_count);
  }
  
#line 163 
  txq1->old_read_count = *tmp_2;
  {
    
#line 164 
    unsigned int __var_0 = 0U;
    
#line 164 
    tmp_3 = (unsigned int volatile *)(& txq2->read_count);
  }
  
#line 164 
  txq2->old_read_count = *tmp_3;
  {
    unsigned int tmp_4;
    
#line 166 
    unsigned int _max1_0 = txq1->insert_count - txq1->old_read_count;
    
#line 166 
    unsigned int _max2_0 = txq2->insert_count - txq2->old_read_count;
    
#line 166 
    if (_max1_0 > _max2_0) 
#line 166 
                           tmp_4 = _max1_0; else 
#line 166 
                                                 tmp_4 = _max2_0;
    
#line 166 
    tmp_5 = tmp_4;
  }
  
#line 166 
  fill_level = tmp_5;
  
#line 169 
  if ((long)(efx->txq_stop_thresh > fill_level) != 0L) {
    
#line 171 
    ldv_inline_asm();
    
#line 171 
    if ((long)(efx->loopback_selftest == (void *)0) != 0L) 
#line 172 
                                                           netif_tx_start_queue(txq1->core_txq); else ;
  }
  else ;
  return_label: 
#line 174 
                return;
}


#line 186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
static void efx_memcpy_toio_aligned(struct efx_nic *efx, u8 **piobuf, u8 *data, int len, struct efx_short_copy_buffer *copy_buf)
{
  
#line 190 
  int block_len = len & -64;
  
#line 192 
  __iowrite64_copy((void *)*piobuf,(void const *)data,(unsigned long)(block_len >> 3));
  
#line 193 
  *piobuf += block_len;
  
#line 194 
  len -= block_len;
  
#line 196 
  if (len != 0) {
    
#line 197 
    data += block_len;
    
#line 198 
    if ((long)(copy_buf->used != 0) != 0L) {
      
#line 200 
      ldv_inline_asm();
      
#line 198 
      ;
    }
    else ;
    
#line 199 
    if ((long)((unsigned int)len > 64U) != 0L) {
      
#line 201 
      ldv_inline_asm();
      
#line 199 
      ;
    }
    else ;
    
#line 200 
    memcpy((void *)(& copy_buf->buf),(void const *)data,(unsigned long)len);
    
#line 201 
    copy_buf->used = len;
  }
  else ;
  
#line 203 
  return;
}


#line 208  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
static void efx_memcpy_toio_aligned_cb(struct efx_nic *efx, u8 **piobuf, u8 *data, int len, struct efx_short_copy_buffer *copy_buf)
{
  
#line 212 
  if (copy_buf->used != 0) {
    int tmp_0;
    {
      int tmp;
      
#line 215 
      int __min1 = (int)(64U - (unsigned int)copy_buf->used);
      
#line 215 
      int __min2 = len;
      
#line 215 
      if (__min1 < __min2) 
#line 215 
                           tmp = __min1; else 
#line 215 
                                              tmp = __min2;
      
#line 215 
      tmp_0 = tmp;
    }
    
#line 214 
    int copy_to_buf = tmp_0;
    
#line 217 
    memcpy((void *)(& copy_buf->buf) + copy_buf->used,(void const *)data,(unsigned long)copy_to_buf);
    
#line 218 
    copy_buf->used += copy_to_buf;
    
#line 221 
    if ((unsigned int)copy_buf->used <= 63U) 
#line 222 
                                             goto return_label; else ;
    
#line 224 
    __iowrite64_copy((void *)*piobuf,(void const *)(& copy_buf->buf),8UL);
    
#line 226 
    *piobuf += 64U;
    
#line 227 
    data += copy_to_buf;
    
#line 228 
    len -= copy_to_buf;
    
#line 229 
    copy_buf->used = 0;
  }
  else ;
  
#line 232 
  efx_memcpy_toio_aligned(efx,piobuf,data,len,copy_buf);
  return_label: 
#line 233 
                return;
}


#line 235  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
static void efx_flush_copy_buffer(struct efx_nic *efx, u8 *piobuf, struct efx_short_copy_buffer *copy_buf)
{
  
#line 239 
  if (copy_buf->used != 0) 
#line 240 
                           __iowrite64_copy((void *)piobuf,(void const *)(& copy_buf->buf),8UL); else ;
  
#line 241 
  return;
}


#line 264 
void __compiletime_assert_264(void);


#line 247  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
static void efx_skb_copy_bits_to_pio(struct efx_nic *efx, struct sk_buff *skb, u8 **piobuf, struct efx_short_copy_buffer *copy_buf)
{
  int i;
  unsigned int tmp;
  unsigned char *tmp_4;
  
#line 253 
  ;
  
#line 253 
  tmp = skb_headlen((struct sk_buff const *)skb);
  
#line 253 
  ;
  
#line 253 
  ;
  
#line 253 
  ;
  
#line 253 
  efx_memcpy_toio_aligned(efx,piobuf,skb->data,(int)tmp,copy_buf);
  
#line 256 
  i = 0;
  
#line 256 
  goto ldv_55714;
  ldv_55713: 
#line 257 
  ;
  {
    unsigned char *tmp_0;
    u8 *vaddr;
    void *tmp_2;
    struct page *tmp_1;
    unsigned int tmp_3;
    
#line 257 
    tmp_0 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 257 
    skb_frag_t *f = & ((struct skb_shared_info *)tmp_0)->frags[i];
    
#line 260 
    tmp_1 = skb_frag_page((skb_frag_t const *)f);
    
#line 260 
    tmp_2 = kmap_atomic(tmp_1);
    
#line 260 
    vaddr = (u8 *)tmp_2;
    
#line 262 
    ;
    
#line 263 
    tmp_3 = skb_frag_size((skb_frag_t const *)f);
    
#line 262 
    ;
    
#line 262 
    ;
    
#line 262 
    ;
    
#line 262 
    efx_memcpy_toio_aligned_cb(efx,piobuf,vaddr + f->page_offset,(int)tmp_3,copy_buf);
    {
      
#line 264 
      bool __cond = (_Bool)0;
      
#line 264 
      if ((int)__cond != 0) 
#line 264 
                            __compiletime_assert_264(); else ;
    }
    
#line 264 
    __kunmap_atomic((void *)vaddr);
  }
  
#line 256 
  i += 1;
  ldv_55714: 
#line 257 
  ;
  
#line 256 
  tmp_4 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 256 
  ;
  
#line 256 
  if ((int)((struct skb_shared_info *)tmp_4)->nr_frags > i) 
#line 258 
                                                            goto ldv_55713; else 
                                                                    
#line 261 
                                                                    goto ldv_55715;
  ldv_55715: 
#line 262 
  ;
  
#line 263 
  return;
}


#line 298 
void __compiletime_assert_299(void);


#line 271  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
static struct efx_tx_buffer *efx_enqueue_skb_pio(struct efx_tx_queue *tx_queue, struct sk_buff *skb)
{
  unsigned char *tmp_0;
  
#line 273 
  struct efx_tx_buffer *buffer = efx_tx_queue_get_insert_buffer((struct efx_tx_queue const *)tx_queue);
  
#line 275 
  u8 *piobuf = (u8 *)tx_queue->piobuf;
  
#line 282 
  tmp_0 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 282 
  ;
  
#line 282 
  if ((unsigned int)((struct skb_shared_info *)tmp_0)->nr_frags != 0U) {
    struct efx_short_copy_buffer copy_buf;
    
#line 288 
    copy_buf.used = 0;
    
#line 290 
    efx_skb_copy_bits_to_pio(tx_queue->efx,skb,& piobuf,& copy_buf);
    
#line 292 
    efx_flush_copy_buffer(tx_queue->efx,piobuf,& copy_buf);
  }
  else {
    {
      
#line 298 
      bool __cond = (_Bool)0;
      
#line 298 
      if ((int)__cond != 0) 
#line 298 
                            __compiletime_assert_299(); else ;
    }
    
#line 300 
    __iowrite64_copy(tx_queue->piobuf,(void const *)skb->data,(unsigned long)((skb->len + 63U) >> 3) & 536870904UL);
  }
  
#line 304 
  buffer->__anonCompField_efx_tx_buffer_116.option.u64[0] = (((unsigned long long)skb->len << 32) | (unsigned long long)tx_queue->piobuf_offset) | 10376293541461622784ULL;
  
#line 311 
  tx_queue->pio_packets += 1U;
  
#line 312 
  tx_queue->insert_count += 1U;
  
#line 313 
  return buffer;
}


#line 333  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
netdev_tx_t efx_enqueue_skb(struct efx_tx_queue *tx_queue, struct sk_buff *skb)
{
  netdev_tx_t __retres;
  struct efx_tx_buffer *buffer;
  skb_frag_t *fragment;
  unsigned int len;
  dma_addr_t dma_addr;
  unsigned int dma_len;
  unsigned short dma_flags;
  unsigned char *tmp_0;
  int tmp_2;
  int tmp_4;
  unsigned char *tmp_5;
  unsigned char *tmp_6;
  
#line 335 
  struct efx_nic *efx = tx_queue->efx;
  
#line 336 
  struct device *dma_dev = & (efx->pci_dev)->dev;
  
#line 338 
  unsigned int old_insert_count = tx_queue->insert_count;
  
#line 340 
  unsigned int unmap_len = 0U;
  
#line 341 
  dma_addr_t unmap_addr = 0ULL;
  
#line 344 
  int i = 0;
  
#line 346 
  tmp_0 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 346 
  ;
  
#line 346 
  if ((unsigned int)((struct skb_shared_info *)tmp_0)->gso_size != 0U) {
    int tmp;
    
#line 347 
    tmp = efx_enqueue_skb_tso(tx_queue,skb);
    
#line 347 
    __retres = (enum netdev_tx)tmp;
    
#line 347 
    goto return_label;
  }
  else ;
  
#line 350 
  len = skb_headlen((struct sk_buff const *)skb);
  
#line 353 
  tmp_2 = efx_nic_rev(efx);
  
#line 353 
  if (tmp_2 <= 2) {
    
#line 353 
    if (skb->len <= 32U) {
      int tmp_1;
      
#line 355 
      len = 33U;
      
#line 356 
      tmp_1 = skb_pad(skb,(int)(len - skb->len));
      
#line 356 
      if (tmp_1 != 0) {
        
#line 357 
        __retres = NETDEV_TX_OK;
        
#line 357 
        goto return_label;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 362 
  if (skb->len <= efx_piobuf_size && (unsigned int)*((unsigned char *)skb + 142UL) == 0U) {
    bool tmp_3;
    
#line 362 
    tmp_3 = efx_nic_may_tx_pio(tx_queue);
    
#line 362 
    if ((int)tmp_3 != 0) {
      
#line 364 
      buffer = efx_enqueue_skb_pio(tx_queue,skb);
      
#line 365 
      dma_flags = (unsigned short)16U;
      
#line 366 
      goto finish_packet;
    }
    else ;
  }
  else ;
  
#line 374 
  dma_flags = (unsigned short)8U;
  
#line 375 
  dma_addr = dma_map_single_attrs(dma_dev,(void *)skb->data,(unsigned long)len,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
  ldv_55748: 
#line 376 
  ;
  
#line 379 
  tmp_4 = dma_mapping_error(dma_dev,dma_addr);
  
#line 379 
  if ((long)(tmp_4 != 0) != 0L) 
#line 380 
                                goto dma_err; else ;
  
#line 384 
  unmap_len = len;
  
#line 385 
  unmap_addr = dma_addr;
  ldv_55745: 
#line 386 
  ;
  
#line 389 
  buffer = efx_tx_queue_get_insert_buffer((struct efx_tx_queue const *)tx_queue);
  
#line 391 
  dma_len = efx_max_tx_len(efx,dma_addr);
  
#line 392 
  if ((long)(dma_len >= len) != 0L) 
#line 393 
                                    dma_len = len; else ;
  
#line 396 
  buffer->len = (unsigned short)dma_len;
  
#line 397 
  buffer->__anonCompField_efx_tx_buffer_116.dma_addr = dma_addr;
  
#line 398 
  buffer->flags = (unsigned short)1U;
  
#line 399 
  len -= dma_len;
  
#line 400 
  dma_addr = (unsigned long long)dma_len + dma_addr;
  
#line 401 
  tx_queue->insert_count += 1U;
  
#line 402 
  if (len != 0U) 
#line 404 
                 goto ldv_55745; else 
#line 407 
                                      goto ldv_55746;
  ldv_55746: 
#line 408 
  ;
  
#line 405 
  buffer->flags = (unsigned short)((unsigned int)dma_flags | 1U);
  
#line 406 
  buffer->unmap_len = (unsigned short)unmap_len;
  
#line 407 
  buffer->dma_offset = (unsigned short)((int)((unsigned short)buffer->__anonCompField_efx_tx_buffer_116.dma_addr) - (int)((unsigned short)unmap_addr));
  
#line 408 
  unmap_len = 0U;
  
#line 411 
  tmp_5 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 411 
  ;
  
#line 411 
  if ((int)((struct skb_shared_info *)tmp_5)->nr_frags <= i) 
#line 412 
                                                             goto ldv_55747; else ;
  
#line 413 
  tmp_6 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 413 
  fragment = & ((struct skb_shared_info *)tmp_6)->frags[i];
  
#line 414 
  len = skb_frag_size((skb_frag_t const *)fragment);
  
#line 415 
  i += 1;
  
#line 417 
  dma_flags = (unsigned short)0U;
  
#line 418 
  dma_addr = skb_frag_dma_map(dma_dev,(skb_frag_t const *)fragment,0UL,(unsigned long)len,(enum dma_data_direction)DMA_TO_DEVICE);
  
#line 379 
  goto ldv_55748;
  ldv_55747: 
#line 380 
  ;
  finish_packet: 
#line 424 
  ;
  
#line 426 
  buffer->__anonCompField_efx_tx_buffer_115.skb = (struct sk_buff const *)skb;
  
#line 427 
  buffer->flags = (unsigned short)((unsigned int)dma_flags | 2U);
  
#line 429 
  netdev_tx_sent_queue(tx_queue->core_txq,skb->len);
  
#line 431 
  efx_tx_maybe_stop_queue(tx_queue);
  
#line 434 
  if ((unsigned int)*((unsigned char *)skb + 142UL) == 0U) 
#line 435 
                                                           efx_nic_push_buffers(tx_queue);
  else {
    bool tmp_7;
    
#line 434 
    tmp_7 = netif_xmit_stopped((struct netdev_queue const *)tx_queue->core_txq);
    
#line 434 
    if ((int)tmp_7 != 0) 
#line 435 
                         efx_nic_push_buffers(tx_queue); else ;
  }
  
#line 437 
  tx_queue->tx_packets += 1UL;
  
#line 439 
  __retres = NETDEV_TX_OK;
  
#line 439 
  goto return_label;
  dma_err: 
#line 441 
  ;
  
#line 442 
  if ((efx->msg_enable & 128U) != 0U) {
    unsigned char *tmp_8;
    
#line 442 
    tmp_8 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 442 
    ;
    
#line 442 
    ;
    
#line 442 
    ;
    
#line 442 
    ;
    
#line 442 
    netdev_err((struct net_device const *)efx->net_dev," TX queue %d could not map skb with %d bytes %d ",tx_queue->queue,skb->len,(int)((struct skb_shared_info *)tmp_8)->nr_frags + 1);
  }
  else ;
  
#line 448 
  dev_kfree_skb_any(skb);
  
#line 451 
  goto ldv_55752;
  ldv_55751: 
#line 452 
  ;
  {
    
#line 452 
    unsigned int pkts_compl = 0U;
    
#line 452 
    unsigned int bytes_compl = 0U;
    
#line 453 
    tx_queue->insert_count -= 1U;
    
#line 454 
    buffer = __efx_tx_queue_get_insert_buffer((struct efx_tx_queue const *)tx_queue);
    
#line 455 
    efx_dequeue_buffer(tx_queue,buffer,& pkts_compl,& bytes_compl);
  }
  ldv_55752: 
#line 457 
  ;
  
#line 451 
  if (tx_queue->insert_count != old_insert_count) 
#line 453 
                                                  goto ldv_55751; else 
                                                                    
#line 456 
                                                                    goto ldv_55753;
  ldv_55753: 
#line 457 
  ;
  
#line 459 
  if (unmap_len != 0U) 
    
#line 460 
    if (((int)dma_flags & 8) != 0) 
#line 461 
                                   dma_unmap_single_attrs(dma_dev,unmap_addr,(unsigned long)unmap_len,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0); else 
                                                                    
#line 464 
                                                                    dma_unmap_page(dma_dev,unmap_addr,(unsigned long)unmap_len,(enum dma_data_direction)DMA_TO_DEVICE);
  else ;
  
#line 468 
  __retres = NETDEV_TX_OK;
  return_label: 
#line 468 
                return __retres;
}


#line 476  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
static void efx_dequeue_buffers(struct efx_tx_queue *tx_queue, unsigned int index, unsigned int *pkts_compl, unsigned int *bytes_compl)
{
  unsigned int stop_index;
  unsigned int read_ptr;
  
#line 481 
  struct efx_nic *efx = tx_queue->efx;
  
#line 484 
  stop_index = (index + 1U) & tx_queue->ptr_mask;
  
#line 485 
  read_ptr = tx_queue->read_count & tx_queue->ptr_mask;
  
#line 487 
  goto ldv_55765;
  ldv_55764: 
#line 488 
  ;
  {
    
#line 488 
    struct efx_tx_buffer *buffer = tx_queue->buffer + read_ptr;
    
#line 490 
    if (((int)buffer->flags & 16) == 0 && (long)((unsigned int)buffer->len == 0U) != 0L) {
      
#line 492 
      if ((efx->msg_enable & 128U) != 0U) 
#line 492 
                                          netdev_err((struct net_device const *)efx->net_dev,"TX queue %d spurious TX completion id %x\n",tx_queue->queue,read_ptr); else ;
      
#line 495 
      efx_schedule_reset(efx,(enum reset_type)RESET_TYPE_TX_SKIP);
      
#line 496 
      goto return_label;
    }
    else ;
    
#line 499 
    efx_dequeue_buffer(tx_queue,buffer,pkts_compl,bytes_compl);
    
#line 501 
    tx_queue->read_count += 1U;
    
#line 502 
    read_ptr = tx_queue->read_count & tx_queue->ptr_mask;
  }
  ldv_55765: 
#line 504 
  ;
  
#line 487 
  if (read_ptr != stop_index) 
#line 489 
                              goto ldv_55764; else 
#line 492 
                                                   goto ldv_55766;
  ldv_55766: 
#line 493 
  ;
  return_label: 
#line 494 
                return;
}


#line 515  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
netdev_tx_t efx_hard_start_xmit(struct sk_buff *skb, struct net_device *net_dev)
{
  netdev_tx_t __retres;
  struct efx_tx_queue *tx_queue;
  unsigned int index;
  unsigned int type;
  bool tmp_1;
  u16 tmp_3;
  netdev_tx_t tmp_4;
  
#line 518 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 525 
  tmp_1 = efx_xmit_with_hwtstamp(skb);
  
#line 525 
  if ((long)((int)tmp_1 != 0) != 0L) {
    bool tmp_2;
    
#line 526 
    tmp_2 = efx_ptp_is_ptp_tx(efx,skb);
    
#line 525 
    if ((long)((int)tmp_2 != 0) != 0L) {
      int tmp_0;
      
#line 527 
      tmp_0 = efx_ptp_tx(efx,skb);
      
#line 527 
      __retres = (enum netdev_tx)tmp_0;
      
#line 527 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 530 
  tmp_3 = skb_get_queue_mapping((struct sk_buff const *)skb);
  
#line 530 
  index = (unsigned int)tmp_3;
  
#line 531 
  type = (unsigned int)((unsigned int)*((unsigned char *)skb + 145UL) == 6U);
  
#line 532 
  if (efx->n_tx_channels <= index) {
    
#line 533 
    index -= efx->n_tx_channels;
    
#line 534 
    type |= 2U;
  }
  else ;
  
#line 536 
  tx_queue = efx_get_tx_queue(efx,index,type);
  
#line 538 
  tmp_4 = efx_enqueue_skb(tx_queue,skb);
  
#line 538 
  __retres = tmp_4;
  return_label: 
#line 538 
                return __retres;
}


#line 541  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
void efx_init_tx_queue_core_txq(struct efx_tx_queue *tx_queue)
{
  unsigned int tmp;
  
#line 543 
  struct efx_nic *efx = tx_queue->efx;
  
#line 548 
  if ((tx_queue->queue & 2U) != 0U) 
#line 548 
                                    tmp = efx->n_tx_channels; else 
#line 548 
                                                                   tmp = 0U;
  
#line 546 
  ;
  
#line 546 
  ;
  
#line 546 
  tx_queue->core_txq = netdev_get_tx_queue((struct net_device const *)efx->net_dev,tx_queue->queue / 4U + tmp);
  
#line 551 
  return;
}


#line 553  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
int efx_setup_tc(struct net_device *net_dev, u8 num_tc)
{
  int __retres;
  struct efx_channel *channel;
  struct efx_tx_queue *tx_queue;
  unsigned int tc;
  int rc;
  int tmp_0;
  int tmp_4;
  
#line 555 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 561 
  tmp_0 = efx_nic_rev(efx);
  
#line 561 
  if (tmp_0 <= 1) {
    
#line 562 
    __retres = -22;
    
#line 562 
    goto return_label;
  }
  else 
    
#line 561 
    if ((unsigned int)num_tc > 2U) {
      
#line 562 
      __retres = -22;
      
#line 562 
      goto return_label;
    }
    else ;
  
#line 564 
  if ((int)net_dev->num_tc == (int)num_tc) {
    
#line 565 
    __retres = 0;
    
#line 565 
    goto return_label;
  }
  else ;
  
#line 567 
  tc = 0U;
  
#line 567 
  goto ldv_55789;
  ldv_55788: 
#line 568 
  ;
  
#line 568 
  net_dev->tc_to_txq[tc].offset = (unsigned short)((int)((unsigned short)efx->n_tx_channels) * (int)((unsigned short)tc));
  
#line 569 
  net_dev->tc_to_txq[tc].count = (unsigned short)efx->n_tx_channels;
  
#line 567 
  tc += 1U;
  ldv_55789: 
#line 568 
  ;
  
#line 567 
  if ((unsigned int)num_tc > tc) 
#line 569 
                                 goto ldv_55788; else 
#line 572 
                                                      goto ldv_55790;
  ldv_55790: 
#line 573 
  ;
  
#line 572 
  if ((int)net_dev->num_tc < (int)num_tc) {
    int tmp_2;
    bool tmp_1;
    
#line 574 
    channel = efx->channel[0];
    
#line 574 
    goto ldv_55796;
    ldv_55795: 
#line 575 
    ;
    
#line 575 
    tmp_1 = efx_channel_has_tx_queues(channel);
    
#line 575 
    if (tmp_1) 
#line 575 
               tmp_2 = 0; else 
#line 575 
                               tmp_2 = 1;
    
#line 575 
    if (tmp_2) ;
    else {
      
#line 575 
      tx_queue = (struct efx_tx_queue *)(& channel->tx_queue);
      
#line 575 
      goto ldv_55793;
      ldv_55792: 
#line 576 
      ;
      
#line 577 
      if ((tx_queue->queue & 2U) == 0U) 
#line 578 
                                        goto ldv_55791; else ;
      
#line 579 
      if (tx_queue->buffer == (struct efx_tx_buffer *)0) {
        
#line 580 
        rc = efx_probe_tx_queue(tx_queue);
        
#line 581 
        if (rc != 0) {
          
#line 582 
          __retres = rc;
          
#line 582 
          goto return_label;
        }
        else ;
      }
      else ;
      
#line 584 
      if (! tx_queue->initialised) 
#line 585 
                                   efx_init_tx_queue(tx_queue); else ;
      
#line 586 
      efx_init_tx_queue_core_txq(tx_queue);
      ldv_55791: 
#line 587 
      ;
      
#line 575 
      tx_queue += 1;
      ldv_55793: 
#line 576 
      ;
      
#line 575 
      if ((struct efx_tx_queue *)(& channel->tx_queue) + 4U > tx_queue) 
        
#line 577 
        goto ldv_55792; else 
#line 580 
                             goto ldv_55794;
      ldv_55794: 
#line 581 
      ;
    }
    
#line 574 
    if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 574 
                                                                channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 574 
                                                                    channel = (struct efx_channel *)0;
    ldv_55796: 
#line 575 
    ;
    
#line 574 
    if (channel != (struct efx_channel *)0) 
#line 576 
                                            goto ldv_55795; else 
#line 579 
                                                                 goto ldv_55797;
    ldv_55797: 
#line 580 
    ;
  }
  else 
#line 591 
       net_dev->num_tc = num_tc;
  {
    int tmp_3;
    
#line 595 
    int __max1 = (int)num_tc;
    
#line 595 
    int __max2 = 1;
    
#line 595 
    if (__max1 > __max2) 
#line 595 
                         tmp_3 = __max1; else 
#line 595 
                                              tmp_3 = __max2;
    
#line 595 
    tmp_4 = tmp_3;
  }
  
#line 594 
  ;
  
#line 594 
  ;
  
#line 594 
  rc = netif_set_real_num_tx_queues(net_dev,(unsigned int)tmp_4 * efx->n_tx_channels);
  
#line 597 
  if (rc != 0) {
    
#line 598 
    __retres = rc;
    
#line 598 
    goto return_label;
  }
  else ;
  
#line 606 
  net_dev->num_tc = num_tc;
  
#line 607 
  __retres = 0;
  return_label: 
#line 607 
                return __retres;
}


#line 610  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
void efx_xmit_done(struct efx_tx_queue *tx_queue, unsigned int index)
{
  unsigned int fill_level;
  struct efx_tx_queue *txq2;
  bool tmp_1;
  
#line 613 
  struct efx_nic *efx = tx_queue->efx;
  
#line 615 
  unsigned int pkts_compl = 0U;
  
#line 615 
  unsigned int bytes_compl = 0U;
  
#line 619 
  efx_dequeue_buffers(tx_queue,index,& pkts_compl,& bytes_compl);
  
#line 620 
  tx_queue->pkts_compl += pkts_compl;
  
#line 621 
  tx_queue->bytes_compl += bytes_compl;
  
#line 623 
  if (pkts_compl > 1U) 
#line 624 
                       tx_queue->merge_events += 1U; else ;
  
#line 625 
  ldv_inline_asm();
  
#line 631 
  tmp_1 = netif_tx_queue_stopped((struct netdev_queue const *)tx_queue->core_txq);
  
#line 631 
  if ((long)((int)tmp_1 != 0) != 0L) {
    
#line 631 
    if ((long)((int)efx->port_enabled != 0) != 0L) {
      bool tmp_2;
      
#line 633 
      tmp_2 = netif_device_present(efx->net_dev);
      
#line 632 
      if ((long)((int)tmp_2 != 0) != 0L) {
        unsigned int tmp_0;
        
#line 634 
        txq2 = efx_tx_queue_partner(tx_queue);
        {
          unsigned int tmp;
          
#line 635 
          unsigned int _max1 = tx_queue->insert_count - tx_queue->read_count;
          
#line 635 
          unsigned int _max2 = txq2->insert_count - txq2->read_count;
          
#line 635 
          if (_max1 > _max2) 
#line 635 
                             tmp = _max1; else 
#line 635 
                                               tmp = _max2;
          
#line 635 
          tmp_0 = tmp;
        }
        
#line 635 
        fill_level = tmp_0;
        
#line 637 
        if (efx->txq_wake_thresh >= fill_level) 
#line 638 
                                                netif_tx_wake_queue(tx_queue->core_txq); else ;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 642 
  if ((int)(tx_queue->read_count - tx_queue->old_write_count) >= 0) {
    unsigned int volatile *tmp_3;
    {
      
#line 643 
      unsigned int __var = 0U;
      
#line 643 
      tmp_3 = (unsigned int volatile *)(& tx_queue->write_count);
    }
    
#line 643 
    tx_queue->old_write_count = *tmp_3;
    
#line 644 
    if (tx_queue->read_count == tx_queue->old_write_count) {
      
#line 646 
      ldv_inline_asm();
      
#line 646 
      tx_queue->empty_read_count = tx_queue->read_count | 2147483648U;
    }
    else ;
  }
  else ;
  
#line 650 
  return;
}


#line 662  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
static unsigned int efx_tsoh_page_count(struct efx_tx_queue *tx_queue)
{
  unsigned int __retres;
  
#line 664 
  __retres = (unsigned int)(((unsigned long)(tx_queue->ptr_mask + 1U) + 63UL) / 64UL);
  
#line 664 
  return __retres;
}


#line 667  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
int efx_probe_tx_queue(struct efx_tx_queue *tx_queue)
{
  int __retres;
  unsigned int entries;
  int rc;
  unsigned long tmp_71;
  
#line 669 
  struct efx_nic *efx = tx_queue->efx;
  {
    unsigned long tmp_69;
    unsigned long tmp_70;
    
#line 674 
    if (0 != 0) {
      unsigned long tmp_67;
      
#line 674 
      if (efx->txq_entries != 1U) {
        unsigned long tmp_66;
        
#line 674 
        if (0 != 0) {
          unsigned long tmp_64;
          
#line 674 
          if (efx->txq_entries == 1U) {
            int tmp;
            
#line 674 
            tmp = ____ilog2_NaN();
            
#line 674 
            tmp_64 = 1UL << (tmp + 1);
          }
          else {
            unsigned long tmp_63;
            
#line 674 
            if (((unsigned long long)(efx->txq_entries + 4294967295U) & 4611686018427387904ULL) == 0ULL) {
              unsigned long tmp_62;
              
#line 674 
              if (((unsigned long long)(efx->txq_entries + 4294967295U) & 2305843009213693952ULL) == 0ULL) {
                unsigned long tmp_61;
                
#line 674 
                if (((unsigned long long)(efx->txq_entries + 4294967295U) & 1152921504606846976ULL) == 0ULL) {
                  unsigned long tmp_60;
                  
#line 674 
                  if (((unsigned long long)(efx->txq_entries + 4294967295U) & 576460752303423488ULL) == 0ULL) {
                    unsigned long tmp_59;
                    
#line 674 
                    if (((unsigned long long)(efx->txq_entries + 4294967295U) & 288230376151711744ULL) == 0ULL) {
                      unsigned long tmp_58;
                      
#line 674 
                      if (((unsigned long long)(efx->txq_entries + 4294967295U) & 144115188075855872ULL) == 0ULL) {
                        unsigned long tmp_57;
                        
#line 674 
                        if (((unsigned long long)(efx->txq_entries + 4294967295U) & 72057594037927936ULL) == 0ULL) {
                          unsigned long tmp_56;
                          
#line 674 
                          if (((unsigned long long)(efx->txq_entries + 4294967295U) & 36028797018963968ULL) == 0ULL) {
                            unsigned long tmp_55;
                            
#line 674 
                            if (((unsigned long long)(efx->txq_entries + 4294967295U) & 18014398509481984ULL) == 0ULL) {
                              unsigned long tmp_54;
                              
#line 674 
                              if (((unsigned long long)(efx->txq_entries + 4294967295U) & 9007199254740992ULL) == 0ULL) {
                                unsigned long tmp_53;
                                
#line 674 
                                if (((unsigned long long)(efx->txq_entries + 4294967295U) & 4503599627370496ULL) == 0ULL) {
                                  unsigned long tmp_52;
                                  
#line 674 
                                  if (((unsigned long long)(efx->txq_entries + 4294967295U) & 2251799813685248ULL) == 0ULL) {
                                    unsigned long tmp_51;
                                    
#line 674 
                                    if (((unsigned long long)(efx->txq_entries + 4294967295U) & 1125899906842624ULL) == 0ULL) {
                                      unsigned long tmp_50;
                                      
#line 674 
                                      if (((unsigned long long)(efx->txq_entries + 4294967295U) & 562949953421312ULL) == 0ULL) {
                                        unsigned long tmp_49;
                                        
#line 674 
                                        if (((unsigned long long)(efx->txq_entries + 4294967295U) & 281474976710656ULL) == 0ULL) {
                                          unsigned long tmp_48;
                                          
#line 674 
                                          if (((unsigned long long)(efx->txq_entries + 4294967295U) & 140737488355328ULL) == 0ULL) {
                                            unsigned long tmp_47;
                                            
#line 674 
                                            if (((unsigned long long)(efx->txq_entries + 4294967295U) & 70368744177664ULL) == 0ULL) {
                                              unsigned long tmp_46;
                                              
#line 674 
                                              if (((unsigned long long)(efx->txq_entries + 4294967295U) & 35184372088832ULL) == 0ULL) {
                                                unsigned long tmp_45;
                                                
#line 674 
                                                if (((unsigned long long)(efx->txq_entries + 4294967295U) & 17592186044416ULL) == 0ULL) {
                                                  unsigned long tmp_44;
                                                  
#line 674 
                                                  if (((unsigned long long)(efx->txq_entries + 4294967295U) & 8796093022208ULL) == 0ULL) {
                                                    unsigned long tmp_43;
                                                    
#line 674 
                                                    if (((unsigned long long)(efx->txq_entries + 4294967295U) & 4398046511104ULL) == 0ULL) {
                                                      unsigned long tmp_42;
                                                      
#line 674 
                                                      if (((unsigned long long)(efx->txq_entries + 4294967295U) & 2199023255552ULL) == 0ULL) {
                                                        unsigned long tmp_41;
                                                        
#line 674 
                                                        if (((unsigned long long)(efx->txq_entries + 4294967295U) & 1099511627776ULL) == 0ULL) {
                                                          unsigned long tmp_40;
                                                          
#line 674 
                                                          if (((unsigned long long)(efx->txq_entries + 4294967295U) & 549755813888ULL) == 0ULL) {
                                                            unsigned long tmp_39;
                                                            
#line 674 
                                                            if (((unsigned long long)(efx->txq_entries + 4294967295U) & 274877906944ULL) == 0ULL) {
                                                              unsigned long tmp_38;
                                                              
#line 674 
                                                              if (((unsigned long long)(efx->txq_entries + 4294967295U) & 137438953472ULL) == 0ULL) {
                                                                unsigned long tmp_37;
                                                                
#line 674 
                                                                if (((unsigned long long)(efx->txq_entries + 4294967295U) & 68719476736ULL) == 0ULL) {
                                                                  unsigned long tmp_36;
                                                                  
#line 674 
                                                                  if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 34359738368ULL) == 0ULL) {
                                                                    unsigned long tmp_35;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 17179869184ULL) == 0ULL) {
                                                                    unsigned long tmp_34;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 8589934592ULL) == 0ULL) {
                                                                    unsigned long tmp_33;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 4294967296ULL) == 0ULL) {
                                                                    unsigned long tmp_32;
                                                                    
#line 674 
                                                                    if (
                                                                    efx->txq_entries + 4294967295U >= (unsigned int)0) {
                                                                    unsigned long tmp_31;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 1073741824ULL) == 0ULL) {
                                                                    unsigned long tmp_30;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 536870912ULL) == 0ULL) {
                                                                    unsigned long tmp_29;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 268435456ULL) == 0ULL) {
                                                                    unsigned long tmp_28;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 134217728ULL) == 0ULL) {
                                                                    unsigned long tmp_27;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 67108864ULL) == 0ULL) {
                                                                    unsigned long tmp_26;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 33554432ULL) == 0ULL) {
                                                                    unsigned long tmp_25;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 16777216ULL) == 0ULL) {
                                                                    unsigned long tmp_24;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 8388608ULL) == 0ULL) {
                                                                    unsigned long tmp_23;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 4194304ULL) == 0ULL) {
                                                                    unsigned long tmp_22;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 2097152ULL) == 0ULL) {
                                                                    unsigned long tmp_21;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 1048576ULL) == 0ULL) {
                                                                    unsigned long tmp_20;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 524288ULL) == 0ULL) {
                                                                    unsigned long tmp_19;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 262144ULL) == 0ULL) {
                                                                    unsigned long tmp_18;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 131072ULL) == 0ULL) {
                                                                    unsigned long tmp_17;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 65536ULL) == 0ULL) {
                                                                    unsigned long tmp_16;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 32768ULL) == 0ULL) {
                                                                    unsigned long tmp_15;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 16384ULL) == 0ULL) {
                                                                    unsigned long tmp_14;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 8192ULL) == 0ULL) {
                                                                    unsigned long tmp_13;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 4096ULL) == 0ULL) {
                                                                    unsigned long tmp_12;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 2048ULL) == 0ULL) {
                                                                    unsigned long tmp_11;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 1024ULL) == 0ULL) {
                                                                    unsigned long tmp_10;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 512ULL) == 0ULL) {
                                                                    unsigned long tmp_9;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 256ULL) == 0ULL) {
                                                                    unsigned long tmp_8;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 128ULL) == 0ULL) {
                                                                    unsigned long tmp_7;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 64ULL) == 0ULL) {
                                                                    unsigned long tmp_6;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 32ULL) == 0ULL) {
                                                                    unsigned long tmp_5;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 16ULL) == 0ULL) {
                                                                    unsigned long tmp_4;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 8ULL) == 0ULL) {
                                                                    unsigned long tmp_3;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 4ULL) == 0ULL) {
                                                                    unsigned long tmp_2;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 2ULL) == 0ULL) {
                                                                    unsigned long tmp_1;
                                                                    
#line 674 
                                                                    if (
                                                                    ((unsigned long long)(efx->txq_entries + 4294967295U) & 1ULL) == 0ULL) {
                                                                    int tmp_0;
                                                                    
#line 674 
                                                                    tmp_0 = ____ilog2_NaN();
                                                                    
#line 674 
                                                                    tmp_1 = 1UL << (tmp_0 + 1);
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_1 = 2UL;
                                                                    
#line 674 
                                                                    tmp_2 = tmp_1;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_2 = 4UL;
                                                                    
#line 674 
                                                                    tmp_3 = tmp_2;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_3 = 8UL;
                                                                    
#line 674 
                                                                    tmp_4 = tmp_3;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_4 = 16UL;
                                                                    
#line 674 
                                                                    tmp_5 = tmp_4;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_5 = 32UL;
                                                                    
#line 674 
                                                                    tmp_6 = tmp_5;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_6 = 64UL;
                                                                    
#line 674 
                                                                    tmp_7 = tmp_6;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_7 = 128UL;
                                                                    
#line 674 
                                                                    tmp_8 = tmp_7;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_8 = 256UL;
                                                                    
#line 674 
                                                                    tmp_9 = tmp_8;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_9 = 512UL;
                                                                    
#line 674 
                                                                    tmp_10 = tmp_9;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_10 = 1024UL;
                                                                    
#line 674 
                                                                    tmp_11 = tmp_10;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_11 = 2048UL;
                                                                    
#line 674 
                                                                    tmp_12 = tmp_11;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_12 = 4096UL;
                                                                    
#line 674 
                                                                    tmp_13 = tmp_12;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_13 = 8192UL;
                                                                    
#line 674 
                                                                    tmp_14 = tmp_13;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_14 = 16384UL;
                                                                    
#line 674 
                                                                    tmp_15 = tmp_14;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_15 = 32768UL;
                                                                    
#line 674 
                                                                    tmp_16 = tmp_15;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_16 = 65536UL;
                                                                    
#line 674 
                                                                    tmp_17 = tmp_16;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_17 = 131072UL;
                                                                    
#line 674 
                                                                    tmp_18 = tmp_17;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_18 = 262144UL;
                                                                    
#line 674 
                                                                    tmp_19 = tmp_18;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_19 = 524288UL;
                                                                    
#line 674 
                                                                    tmp_20 = tmp_19;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_20 = 1048576UL;
                                                                    
#line 674 
                                                                    tmp_21 = tmp_20;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_21 = 2097152UL;
                                                                    
#line 674 
                                                                    tmp_22 = tmp_21;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_22 = 4194304UL;
                                                                    
#line 674 
                                                                    tmp_23 = tmp_22;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_23 = 8388608UL;
                                                                    
#line 674 
                                                                    tmp_24 = tmp_23;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_24 = 16777216UL;
                                                                    
#line 674 
                                                                    tmp_25 = tmp_24;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_25 = 33554432UL;
                                                                    
#line 674 
                                                                    tmp_26 = tmp_25;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_26 = 67108864UL;
                                                                    
#line 674 
                                                                    tmp_27 = tmp_26;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_27 = 134217728UL;
                                                                    
#line 674 
                                                                    tmp_28 = tmp_27;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_28 = 268435456UL;
                                                                    
#line 674 
                                                                    tmp_29 = tmp_28;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_29 = 536870912UL;
                                                                    
#line 674 
                                                                    tmp_30 = tmp_29;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_30 = 1073741824UL;
                                                                    
#line 674 
                                                                    tmp_31 = tmp_30;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_31 = 2147483648UL;
                                                                    
#line 674 
                                                                    tmp_32 = tmp_31;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_32 = 4294967296UL;
                                                                    
#line 674 
                                                                    tmp_33 = tmp_32;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_33 = 8589934592UL;
                                                                    
#line 674 
                                                                    tmp_34 = tmp_33;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_34 = 17179869184UL;
                                                                    
#line 674 
                                                                    tmp_35 = tmp_34;
                                                                    }
                                                                    else 
                                                                    
#line 674 
                                                                    tmp_35 = 34359738368UL;
                                                                    
#line 674 
                                                                    tmp_36 = tmp_35;
                                                                  }
                                                                  else 
                                                                    
#line 674 
                                                                    tmp_36 = 68719476736UL;
                                                                  
#line 674 
                                                                  tmp_37 = tmp_36;
                                                                }
                                                                else 
                                                                  
#line 674 
                                                                  tmp_37 = 137438953472UL;
                                                                
#line 674 
                                                                tmp_38 = tmp_37;
                                                              }
                                                              else 
#line 674 
                                                                   tmp_38 = 274877906944UL;
                                                              
#line 674 
                                                              tmp_39 = tmp_38;
                                                            }
                                                            else 
#line 674 
                                                                 tmp_39 = 549755813888UL;
                                                            
#line 674 
                                                            tmp_40 = tmp_39;
                                                          }
                                                          else 
#line 674 
                                                               tmp_40 = 1099511627776UL;
                                                          
#line 674 
                                                          tmp_41 = tmp_40;
                                                        }
                                                        else 
#line 674 
                                                             tmp_41 = 2199023255552UL;
                                                        
#line 674 
                                                        tmp_42 = tmp_41;
                                                      }
                                                      else 
#line 674 
                                                           tmp_42 = 4398046511104UL;
                                                      
#line 674 
                                                      tmp_43 = tmp_42;
                                                    }
                                                    else 
#line 674 
                                                         tmp_43 = 8796093022208UL;
                                                    
#line 674 
                                                    tmp_44 = tmp_43;
                                                  }
                                                  else 
#line 674 
                                                       tmp_44 = 17592186044416UL;
                                                  
#line 674 
                                                  tmp_45 = tmp_44;
                                                }
                                                else 
#line 674 
                                                     tmp_45 = 35184372088832UL;
                                                
#line 674 
                                                tmp_46 = tmp_45;
                                              }
                                              else 
#line 674 
                                                   tmp_46 = 70368744177664UL;
                                              
#line 674 
                                              tmp_47 = tmp_46;
                                            }
                                            else 
#line 674 
                                                 tmp_47 = 140737488355328UL;
                                            
#line 674 
                                            tmp_48 = tmp_47;
                                          }
                                          else 
#line 674 
                                               tmp_48 = 281474976710656UL;
                                          
#line 674 
                                          tmp_49 = tmp_48;
                                        }
                                        else 
#line 674 
                                             tmp_49 = 562949953421312UL;
                                        
#line 674 
                                        tmp_50 = tmp_49;
                                      }
                                      else 
#line 674 
                                           tmp_50 = 1125899906842624UL;
                                      
#line 674 
                                      tmp_51 = tmp_50;
                                    }
                                    else 
#line 674 
                                         tmp_51 = 2251799813685248UL;
                                    
#line 674 
                                    tmp_52 = tmp_51;
                                  }
                                  else 
#line 674 
                                       tmp_52 = 4503599627370496UL;
                                  
#line 674 
                                  tmp_53 = tmp_52;
                                }
                                else 
#line 674 
                                     tmp_53 = 9007199254740992UL;
                                
#line 674 
                                tmp_54 = tmp_53;
                              }
                              else 
#line 674 
                                   tmp_54 = 18014398509481984UL;
                              
#line 674 
                              tmp_55 = tmp_54;
                            }
                            else 
#line 674 
                                 tmp_55 = 36028797018963968UL;
                            
#line 674 
                            tmp_56 = tmp_55;
                          }
                          else 
#line 674 
                               tmp_56 = 72057594037927936UL;
                          
#line 674 
                          tmp_57 = tmp_56;
                        }
                        else 
#line 674 
                             tmp_57 = 144115188075855872UL;
                        
#line 674 
                        tmp_58 = tmp_57;
                      }
                      else 
#line 674 
                           tmp_58 = 288230376151711744UL;
                      
#line 674 
                      tmp_59 = tmp_58;
                    }
                    else 
#line 674 
                         tmp_59 = 576460752303423488UL;
                    
#line 674 
                    tmp_60 = tmp_59;
                  }
                  else 
#line 674 
                       tmp_60 = 1152921504606846976UL;
                  
#line 674 
                  tmp_61 = tmp_60;
                }
                else 
#line 674 
                     tmp_61 = 2305843009213693952UL;
                
#line 674 
                tmp_62 = tmp_61;
              }
              else 
#line 674 
                   tmp_62 = 4611686018427387904UL;
              
#line 674 
              tmp_63 = tmp_62;
            }
            else 
#line 674 
                 tmp_63 = 9223372036854775808UL;
            
#line 674 
            tmp_64 = tmp_63;
          }
          
#line 674 
          tmp_66 = tmp_64;
        }
        else {
          int tmp_65;
          
#line 674 
          tmp_65 = __ilog2_u32(efx->txq_entries + 4294967295U);
          
#line 674 
          tmp_66 = 1UL << (tmp_65 + 1);
        }
        
#line 674 
        tmp_67 = tmp_66;
      }
      else 
#line 674 
           tmp_67 = 1UL;
      
#line 674 
      tmp_69 = tmp_67;
    }
    else 
#line 674 
         tmp_69 = __roundup_pow_of_two((unsigned long)efx->txq_entries);
    
#line 674 
    unsigned long _max1 = tmp_69;
    
#line 674 
    unsigned long _max2 = 512UL;
    
#line 674 
    if (_max1 > _max2) 
#line 674 
                       tmp_70 = _max1; else 
#line 674 
                                            tmp_70 = _max2;
    
#line 674 
    tmp_71 = tmp_70;
  }
  
#line 674 
  entries = (unsigned int)tmp_71;
  
#line 676 
  tx_queue->ptr_mask = entries + 4294967295U;
  
#line 678 
  if ((efx->msg_enable & 2U) != 0U) {
    
#line 678 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_probe_tx_queue", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c", .format = "creating TX queue %d size %#x mask %#x\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))680U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 678 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 678 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"creating TX queue %d size %#x mask %#x\n",tx_queue->queue,efx->txq_entries,tx_queue->ptr_mask); else ;
  }
  else ;
  
#line 683 
  tx_queue->buffer = (struct efx_tx_buffer *)kcalloc_5((unsigned long)entries,24UL,208U);
  
#line 685 
  if (tx_queue->buffer == (struct efx_tx_buffer *)0) {
    
#line 686 
    __retres = -12;
    
#line 686 
    goto return_label;
  }
  else ;
  
#line 688 
  if ((tx_queue->queue & 1U) != 0U) {
    void *tmp_74;
    unsigned int tmp_73;
    
#line 690 
    tmp_73 = efx_tsoh_page_count(tx_queue);
    
#line 690 
    tmp_74 = kcalloc_5((unsigned long)tmp_73,24UL,208U);
    
#line 689 
    tx_queue->tsoh_page = (struct efx_buffer *)tmp_74;
    
#line 692 
    if (tx_queue->tsoh_page == (struct efx_buffer *)0) {
      
#line 693 
      rc = -12;
      
#line 694 
      goto fail1;
    }
    else ;
  }
  else ;
  
#line 699 
  rc = efx_nic_probe_tx(tx_queue);
  
#line 700 
  if (rc != 0) 
#line 701 
               goto fail2; else ;
  
#line 703 
  __retres = 0;
  
#line 703 
  goto return_label;
  fail2: 
#line 705 
  ;
  
#line 706 
  kfree((void const *)tx_queue->tsoh_page);
  
#line 707 
  tx_queue->tsoh_page = (struct efx_buffer *)0;
  fail1: 
#line 708 
  ;
  
#line 709 
  kfree((void const *)tx_queue->buffer);
  
#line 710 
  tx_queue->buffer = (struct efx_tx_buffer *)0;
  
#line 711 
  __retres = rc;
  return_label: 
#line 711 
                return __retres;
}


#line 714  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
void efx_init_tx_queue(struct efx_tx_queue *tx_queue)
{
  
#line 716 
  if (((tx_queue->efx)->msg_enable & 1U) != 0U) {
    
#line 716 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_init_tx_queue", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c", .format = "initialising TX queue %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))717U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 716 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 716 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)(tx_queue->efx)->net_dev,"initialising TX queue %d\n",tx_queue->queue); else ;
  }
  else ;
  
#line 719 
  tx_queue->insert_count = 0U;
  
#line 720 
  tx_queue->write_count = 0U;
  
#line 721 
  tx_queue->old_write_count = 0U;
  
#line 722 
  tx_queue->read_count = 0U;
  
#line 723 
  tx_queue->old_read_count = 0U;
  
#line 724 
  tx_queue->empty_read_count = 2147483648U;
  
#line 727 
  efx_nic_init_tx(tx_queue);
  
#line 729 
  tx_queue->initialised = (_Bool)1;
  
#line 730 
  return;
}


#line 732  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
void efx_fini_tx_queue(struct efx_tx_queue *tx_queue)
{
  struct efx_tx_buffer *buffer;
  
#line 736 
  if (((tx_queue->efx)->msg_enable & 1U) != 0U) {
    
#line 736 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_fini_tx_queue", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c", .format = "shutting down TX queue %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))737U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 736 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 736 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)(tx_queue->efx)->net_dev,"shutting down TX queue %d\n",tx_queue->queue); else ;
  }
  else ;
  
#line 739 
  if (tx_queue->buffer == (struct efx_tx_buffer *)0) 
#line 740 
                                                     goto return_label; else ;
  
#line 743 
  goto ldv_55845;
  ldv_55844: 
#line 744 
  ;
  {
    
#line 744 
    unsigned int pkts_compl = 0U;
    
#line 744 
    unsigned int bytes_compl = 0U;
    
#line 745 
    buffer = tx_queue->buffer + (tx_queue->read_count & tx_queue->ptr_mask);
    
#line 746 
    efx_dequeue_buffer(tx_queue,buffer,& pkts_compl,& bytes_compl);
    
#line 748 
    tx_queue->read_count += 1U;
  }
  ldv_55845: 
#line 750 
  ;
  
#line 743 
  if (tx_queue->read_count != tx_queue->write_count) 
#line 745 
                                                     goto ldv_55844; else 
                                                                    
#line 748 
                                                                    goto ldv_55846;
  ldv_55846: 
#line 749 
  ;
  
#line 750 
  netdev_tx_reset_queue(tx_queue->core_txq);
  return_label: 
#line 751 
                return;
}


#line 753  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
void efx_remove_tx_queue(struct efx_tx_queue *tx_queue)
{
  int i;
  
#line 757 
  if (tx_queue->buffer == (struct efx_tx_buffer *)0) 
#line 758 
                                                     goto return_label; else ;
  
#line 760 
  if (((tx_queue->efx)->msg_enable & 1U) != 0U) {
    
#line 760 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_remove_tx_queue", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c", .format = "destroying TX queue %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))761U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 760 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 760 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)(tx_queue->efx)->net_dev,"destroying TX queue %d\n",tx_queue->queue); else ;
  }
  else ;
  
#line 762 
  efx_nic_remove_tx(tx_queue);
  
#line 764 
  if (tx_queue->tsoh_page != (struct efx_buffer *)0) {
    unsigned int tmp;
    
#line 765 
    i = 0;
    
#line 765 
    goto ldv_55854;
    ldv_55853: 
#line 766 
    ;
    
#line 766 
    efx_nic_free_buffer(tx_queue->efx,tx_queue->tsoh_page + i);
    
#line 765 
    i += 1;
    ldv_55854: 
#line 766 
    ;
    
#line 765 
    tmp = efx_tsoh_page_count(tx_queue);
    
#line 765 
    ;
    
#line 765 
    if (tmp > (unsigned int)i) 
#line 767 
                               goto ldv_55853; else 
#line 770 
                                                    goto ldv_55855;
    ldv_55855: 
#line 771 
    ;
    
#line 768 
    kfree((void const *)tx_queue->tsoh_page);
    
#line 769 
    tx_queue->tsoh_page = (struct efx_buffer *)0;
  }
  else ;
  
#line 772 
  kfree((void const *)tx_queue->buffer);
  
#line 773 
  tx_queue->buffer = (struct efx_tx_buffer *)0;
  return_label: 
#line 774 
                return;
}


#line 838  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
static __be16 efx_tso_check_protocol(struct sk_buff *skb)
{
  
#line 840 
  __be16 protocol = skb->protocol;
  
#line 844 
  if ((unsigned int)protocol == 129U) {
    
#line 845 
    struct vlan_ethhdr *veh = (struct vlan_ethhdr *)skb->data;
    
#line 846 
    protocol = veh->h_vlan_encapsulated_proto;
  }
  else ;
  
#line 849 
  if ((unsigned int)protocol == 8U) ; else ;
  
#line 859 
  return protocol;
}


#line 862  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
static u8 *efx_tsoh_get_buffer(struct efx_tx_queue *tx_queue, struct efx_tx_buffer *buffer, unsigned int len)
{
  u8 *__retres;
  u8 *result;
  
#line 871 
  if ((long)(len <= 128U) != 0L) {
    
#line 872 
    unsigned int index = (tx_queue->insert_count & tx_queue->ptr_mask) / 2U;
    
#line 874 
    struct efx_buffer *page_buf = tx_queue->tsoh_page + index / 32U;
    
#line 876 
    unsigned int offset = (index & 31U) * 128U;
    
#line 879 
    if ((long)(page_buf->addr == (void *)0) != 0L) {
      int tmp;
      
#line 879 
      tmp = efx_nic_alloc_buffer(tx_queue->efx,page_buf,4096U,32U);
      
#line 879 
      if (tmp != 0) {
        
#line 882 
        __retres = (u8 *)0U;
        
#line 882 
        goto return_label;
      }
      else ;
    }
    else ;
    
#line 884 
    result = (u8 *)page_buf->addr + offset;
    
#line 885 
    buffer->__anonCompField_efx_tx_buffer_116.dma_addr = page_buf->dma_addr + (unsigned long long)offset;
    
#line 886 
    buffer->flags = (unsigned short)1U;
  }
  else {
    
#line 888 
    tx_queue->tso_long_headers += 1U;
    
#line 890 
    buffer->__anonCompField_efx_tx_buffer_115.heap_buf = kmalloc((unsigned long)len,32U);
    
#line 891 
    if ((long)(buffer->__anonCompField_efx_tx_buffer_115.heap_buf == (void *)0) != 0L) {
      
#line 892 
      __retres = (u8 *)0U;
      
#line 892 
      goto return_label;
    }
    else ;
    
#line 893 
    result = (u8 *)buffer->__anonCompField_efx_tx_buffer_115.heap_buf;
    
#line 894 
    buffer->flags = (unsigned short)5U;
  }
  
#line 897 
  buffer->len = (unsigned short)len;
  
#line 899 
  __retres = result;
  return_label: 
#line 899 
                return __retres;
}


#line 911  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
static void efx_tx_queue_insert(struct efx_tx_queue *tx_queue, dma_addr_t dma_addr, unsigned int len, struct efx_tx_buffer **final_buffer)
{
  struct efx_tx_buffer *buffer;
  unsigned int dma_len;
  
#line 916 
  struct efx_nic *efx = tx_queue->efx;
  ldv_55897: 
#line 918 
  ;
  
#line 922 
  buffer = efx_tx_queue_get_insert_buffer((struct efx_tx_queue const *)tx_queue);
  
#line 923 
  tx_queue->insert_count += 1U;
  
#line 929 
  buffer->__anonCompField_efx_tx_buffer_116.dma_addr = dma_addr;
  
#line 931 
  dma_len = efx_max_tx_len(efx,dma_addr);
  
#line 934 
  if (dma_len >= len) 
#line 935 
                      goto ldv_55896; else ;
  
#line 937 
  buffer->len = (unsigned short)dma_len;
  
#line 938 
  buffer->flags = (unsigned short)1U;
  
#line 939 
  dma_addr = (unsigned long long)dma_len + dma_addr;
  
#line 940 
  len -= dma_len;
  
#line 922 
  goto ldv_55897;
  ldv_55896: 
#line 923 
  ;
  
#line 944 
  buffer->len = (unsigned short)len;
  
#line 945 
  *final_buffer = buffer;
  
#line 946 
  return;
}


#line 956  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
static int efx_tso_put_header(struct efx_tx_queue *tx_queue, struct efx_tx_buffer *buffer, u8 *header)
{
  int __retres;
  
#line 959 
  if ((long)(((int)buffer->flags & 4) != 0) != 0L) {
    int tmp;
    
#line 960 
    buffer->__anonCompField_efx_tx_buffer_116.dma_addr = dma_map_single_attrs(& ((tx_queue->efx)->pci_dev)->dev,(void *)header,(unsigned long)buffer->len,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
    
#line 963 
    tmp = dma_mapping_error(& ((tx_queue->efx)->pci_dev)->dev,buffer->__anonCompField_efx_tx_buffer_116.dma_addr);
    
#line 963 
    if ((long)(tmp != 0) != 0L) {
      
#line 965 
      kfree((void const *)buffer->__anonCompField_efx_tx_buffer_115.heap_buf);
      
#line 966 
      buffer->len = (unsigned short)0U;
      
#line 967 
      buffer->flags = (unsigned short)0U;
      
#line 968 
      __retres = -12;
      
#line 968 
      goto return_label;
    }
    else ;
    
#line 970 
    buffer->unmap_len = buffer->len;
    
#line 971 
    buffer->dma_offset = (unsigned short)0U;
    
#line 972 
    buffer->flags = (unsigned short)((unsigned int)buffer->flags | 8U);
  }
  else ;
  
#line 975 
  tx_queue->insert_count += 1U;
  
#line 976 
  __retres = 0;
  return_label: 
#line 976 
                return __retres;
}


#line 983  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
static void efx_enqueue_unwind(struct efx_tx_queue *tx_queue, unsigned int insert_count)
{
  struct efx_tx_buffer *buffer;
  
#line 989 
  goto ldv_55909;
  ldv_55908: 
#line 990 
  ;
  
#line 990 
  tx_queue->insert_count -= 1U;
  
#line 991 
  buffer = __efx_tx_queue_get_insert_buffer((struct efx_tx_queue const *)tx_queue);
  
#line 992 
  efx_dequeue_buffer(tx_queue,buffer,(unsigned int *)0U,(unsigned int *)0U);
  ldv_55909: 
#line 993 
  ;
  
#line 989 
  if (tx_queue->insert_count != insert_count) 
#line 991 
                                              goto ldv_55908; else 
#line 994 
                                                                   goto ldv_55910;
  ldv_55910: 
#line 995 
  ;
  
#line 996 
  return;
}


#line 998  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
static int tso_start(struct tso_state *st, struct efx_nic *efx, struct sk_buff const *skb)
{
  int __retres;
  int tmp;
  unsigned int header_len;
  unsigned int in_len;
  dma_addr_t dma_addr;
  unsigned char *tmp_0;
  unsigned char *tmp_1;
  struct tcphdr *tmp_2;
  unsigned int tmp_3;
  __u32 tmp_7;
  struct tcphdr *tmp_6;
  int tmp_10;
  int tmp_9;
  
#line 1001 
  tmp = efx_nic_rev(efx);
  
#line 1001 
  bool use_opt_desc = (_Bool)(tmp > 3);
  
#line 1002 
  struct device *dma_dev = & (efx->pci_dev)->dev;
  
#line 1006 
  tmp_0 = skb_network_header(skb);
  
#line 1006 
  st->ip_off = (unsigned int)((long)tmp_0 - (long)skb->data);
  
#line 1007 
  tmp_1 = skb_transport_header(skb);
  
#line 1007 
  st->tcp_off = (unsigned int)((long)tmp_1 - (long)skb->data);
  
#line 1008 
  tmp_2 = tcp_hdr(skb);
  
#line 1008 
  header_len = st->tcp_off + (unsigned int)((int)tmp_2->doff << 2U);
  
#line 1009 
  tmp_3 = skb_headlen(skb);
  
#line 1009 
  in_len = tmp_3 - header_len;
  
#line 1010 
  st->header_len = header_len;
  
#line 1011 
  st->in_len = in_len;
  
#line 1012 
  if ((unsigned int)st->protocol == 8U) {
    __u16 tmp_5;
    struct iphdr *tmp_4;
    
#line 1013 
    st->ip_base_len = st->header_len - st->ip_off;
    
#line 1014 
    tmp_4 = ip_hdr(skb);
    
#line 1014 
    tmp_5 = __fswab16((unsigned short)((int)tmp_4->id));
    
#line 1014 
    st->ipv4_id = tmp_5;
  }
  else {
    
#line 1016 
    st->ip_base_len = st->header_len - st->tcp_off;
    
#line 1017 
    st->ipv4_id = (unsigned short)0U;
  }
  
#line 1019 
  tmp_6 = tcp_hdr(skb);
  
#line 1019 
  tmp_7 = __fswab32(tmp_6->seq);
  
#line 1019 
  st->seqnum = tmp_7;
  
#line 1025 
  st->out_len = skb->len - header_len;
  
#line 1027 
  if (! use_opt_desc) {
    
#line 1028 
    st->header_unmap_len = 0U;
    
#line 1030 
    if ((long)(in_len == 0U) != 0L) {
      
#line 1031 
      st->dma_flags = (unsigned short)0U;
      
#line 1032 
      st->unmap_len = 0U;
      
#line 1033 
      __retres = 0;
      
#line 1033 
      goto return_label;
    }
    else ;
    
#line 1036 
    dma_addr = dma_map_single_attrs(dma_dev,(void *)(skb->data + header_len),(unsigned long)in_len,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
    
#line 1038 
    st->dma_flags = (unsigned short)8U;
    
#line 1039 
    st->dma_addr = dma_addr;
    
#line 1040 
    st->unmap_addr = dma_addr;
    
#line 1041 
    st->unmap_len = in_len;
  }
  else {
    unsigned int tmp_8;
    
#line 1043 
    tmp_8 = skb_headlen(skb);
    
#line 1043 
    ;
    
#line 1043 
    ;
    
#line 1043 
    dma_addr = dma_map_single_attrs(dma_dev,(void *)skb->data,(unsigned long)tmp_8,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
    
#line 1045 
    st->header_dma_addr = dma_addr;
    
#line 1046 
    st->header_unmap_len = skb_headlen(skb);
    
#line 1047 
    st->dma_flags = (unsigned short)0U;
    
#line 1048 
    st->dma_addr = (unsigned long long)header_len + dma_addr;
    
#line 1049 
    st->unmap_len = 0U;
  }
  
#line 1052 
  tmp_9 = dma_mapping_error(dma_dev,dma_addr);
  
#line 1052 
  if ((long)(tmp_9 != 0) != 0L) 
#line 1052 
                                tmp_10 = -12; else 
#line 1052 
                                                   tmp_10 = 0;
  
#line 1052 
  __retres = tmp_10;
  return_label: 
#line 1052 
                return __retres;
}


#line 1055  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
static int tso_get_fragment(struct tso_state *st, struct efx_nic *efx, skb_frag_t *frag)
{
  int __retres;
  unsigned int tmp;
  int tmp_0;
  
#line 1059 
  tmp = skb_frag_size((skb_frag_t const *)frag);
  
#line 1058 
  ;
  
#line 1058 
  ;
  
#line 1058 
  st->unmap_addr = skb_frag_dma_map(& (efx->pci_dev)->dev,(skb_frag_t const *)frag,0UL,(unsigned long)tmp,(enum dma_data_direction)DMA_TO_DEVICE);
  
#line 1060 
  tmp_0 = dma_mapping_error(& (efx->pci_dev)->dev,st->unmap_addr);
  
#line 1060 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 1061 
    st->dma_flags = (unsigned short)0U;
    
#line 1062 
    st->unmap_len = skb_frag_size((skb_frag_t const *)frag);
    
#line 1063 
    st->in_len = skb_frag_size((skb_frag_t const *)frag);
    
#line 1064 
    st->dma_addr = st->unmap_addr;
    
#line 1065 
    __retres = 0;
    
#line 1065 
    goto return_label;
  }
  else ;
  
#line 1067 
  __retres = -12;
  return_label: 
#line 1067 
                return __retres;
}


#line 1080  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
static void tso_fill_packet_with_fragment(struct efx_tx_queue *tx_queue, struct sk_buff const *skb, struct tso_state *st)
{
  struct efx_tx_buffer *buffer;
  int n;
  unsigned int tmp_0;
  
#line 1087 
  if (st->in_len == 0U) 
#line 1088 
                        goto return_label; else ;
  
#line 1089 
  if (st->packet_space == 0U) 
#line 1090 
                              goto return_label; else ;
  {
    unsigned int tmp;
    
#line 1095 
    unsigned int _min1 = st->in_len;
    
#line 1095 
    unsigned int _min2 = st->packet_space;
    
#line 1095 
    if (_min1 < _min2) 
#line 1095 
                       tmp = _min1; else 
#line 1095 
                                         tmp = _min2;
    
#line 1095 
    tmp_0 = tmp;
  }
  
#line 1095 
  n = (int)tmp_0;
  
#line 1097 
  st->packet_space -= (unsigned int)n;
  
#line 1098 
  st->out_len -= (unsigned int)n;
  
#line 1099 
  st->in_len -= (unsigned int)n;
  
#line 1101 
  efx_tx_queue_insert(tx_queue,st->dma_addr,(unsigned int)n,& buffer);
  
#line 1103 
  if (st->out_len == 0U) {
    
#line 1105 
    buffer->__anonCompField_efx_tx_buffer_115.skb = skb;
    
#line 1106 
    buffer->flags = (unsigned short)2U;
  }
  else 
    
#line 1107 
    if (st->packet_space != 0U) 
#line 1108 
                                buffer->flags = (unsigned short)1U; else ;
  
#line 1111 
  if (st->in_len == 0U) {
    
#line 1113 
    buffer->unmap_len = (unsigned short)st->unmap_len;
    
#line 1114 
    buffer->dma_offset = (unsigned short)((int)buffer->unmap_len - (int)buffer->len);
    
#line 1115 
    buffer->flags = (unsigned short)((int)buffer->flags | (int)st->dma_flags);
    
#line 1116 
    st->unmap_len = 0U;
  }
  else ;
  
#line 1119 
  st->dma_addr += (unsigned long long)n;
  return_label: 
#line 1120 
                return;
}


#line 1132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
static int tso_start_new_packet(struct efx_tx_queue *tx_queue, struct sk_buff const *skb, struct tso_state *st)
{
  int __retres;
  unsigned char *tmp_0;
  u8 tcp_flags_clear;
  unsigned char *tmp_7;
  
#line 1136 
  struct efx_tx_buffer *buffer = efx_tx_queue_get_insert_buffer((struct efx_tx_queue const *)tx_queue);
  
#line 1138 
  tmp_0 = skb_end_pointer(skb);
  
#line 1138 
  bool is_last = (_Bool)(st->out_len <= (unsigned int)((struct skb_shared_info *)tmp_0)->gso_size);
  
#line 1141 
  if (! is_last) {
    unsigned char *tmp_1;
    
#line 1142 
    tmp_1 = skb_end_pointer(skb);
    
#line 1142 
    st->packet_space = (unsigned int)((struct skb_shared_info *)tmp_1)->gso_size;
    
#line 1143 
    tcp_flags_clear = (unsigned char)9U;
  }
  else {
    
#line 1145 
    st->packet_space = st->out_len;
    
#line 1146 
    tcp_flags_clear = (unsigned char)0U;
  }
  
#line 1149 
  if (st->header_unmap_len == 0U) {
    struct tcphdr *tsoh_th;
    unsigned int ip_length;
    u8 *header;
    int rc;
    
#line 1156 
    header = efx_tsoh_get_buffer(tx_queue,buffer,st->header_len);
    
#line 1157 
    if (header == (u8 *)0U) {
      
#line 1158 
      __retres = -12;
      
#line 1158 
      goto return_label;
    }
    else ;
    
#line 1160 
    tsoh_th = (struct tcphdr *)(header + st->tcp_off);
    
#line 1163 
    memcpy((void *)header,(void const *)skb->data,(unsigned long)st->header_len);
    
#line 1165 
    if (0 != 0) 
#line 1165 
                tsoh_th->seq = (((st->seqnum << 24) | ((st->seqnum << 8) & 16711680U)) | ((st->seqnum >> 8) & 65280U)) | (st->seqnum >> 24); else 
                                                                    
#line 1165 
                                                                    tsoh_th->seq = __fswab32(st->seqnum);
    
#line 1166 
    *((u8 *)tsoh_th + 13U) = (unsigned char)((int)*((u8 *)tsoh_th + 13U) & ~ ((int)tcp_flags_clear));
    
#line 1168 
    ip_length = st->ip_base_len + st->packet_space;
    
#line 1170 
    if ((unsigned int)st->protocol == 8U) {
      
#line 1171 
      struct iphdr *tsoh_iph = (struct iphdr *)(header + st->ip_off);
      
#line 1174 
      if (0 != 0) 
#line 1174 
                  tsoh_iph->tot_len = (unsigned short)(((int)((unsigned short)ip_length) << 8) | ((int)((unsigned short)ip_length) >> 8)); else 
                                                                    
#line 1174 
                                                                    tsoh_iph->tot_len = __fswab16((unsigned short)((int)((unsigned short)ip_length)));
      
#line 1175 
      if (0 != 0) 
#line 1175 
                  tsoh_iph->id = (unsigned short)(((int)st->ipv4_id << 8) | ((int)st->ipv4_id >> 8)); else 
                                                                    
#line 1175 
                                                                    tsoh_iph->id = __fswab16((unsigned short)((int)st->ipv4_id));
    }
    else {
      
#line 1177 
      struct ipv6hdr *tsoh_iph_0 = (struct ipv6hdr *)(header + st->ip_off);
      
#line 1180 
      if (0 != 0) 
#line 1180 
                  tsoh_iph_0->payload_len = (unsigned short)(((int)((unsigned short)ip_length) << 8) | ((int)((unsigned short)ip_length) >> 8)); else 
                                                                    
#line 1180 
                                                                    tsoh_iph_0->payload_len = __fswab16((unsigned short)((int)((unsigned short)ip_length)));
    }
    
#line 1183 
    rc = efx_tso_put_header(tx_queue,buffer,header);
    
#line 1184 
    if ((long)(rc != 0) != 0L) {
      
#line 1185 
      __retres = rc;
      
#line 1185 
      goto return_label;
    }
    else ;
  }
  else {
    struct tcphdr *tmp_6;
    
#line 1190 
    tmp_6 = tcp_hdr(skb);
    
#line 1190 
    u8 tcp_flags = (unsigned char)((int)*((u8 *)tmp_6 + 13U) & ~ ((int)tcp_flags_clear));
    
#line 1192 
    buffer->flags = (unsigned short)16U;
    
#line 1193 
    buffer->len = (unsigned short)0U;
    
#line 1194 
    buffer->unmap_len = (unsigned short)0U;
    
#line 1195 
    buffer->__anonCompField_efx_tx_buffer_116.option.u64[0] = ((((unsigned long long)tcp_flags << 48) | ((unsigned long long)st->ipv4_id << 32)) | (unsigned long long)st->seqnum) | 17293822569102704640ULL;
    
#line 1202 
    tx_queue->insert_count += 1U;
    
#line 1207 
    buffer = efx_tx_queue_get_insert_buffer((struct efx_tx_queue const *)tx_queue);
    
#line 1208 
    buffer->__anonCompField_efx_tx_buffer_116.dma_addr = st->header_dma_addr;
    
#line 1209 
    buffer->len = (unsigned short)st->header_len;
    
#line 1210 
    if ((int)is_last != 0) {
      
#line 1211 
      buffer->flags = (unsigned short)9U;
      
#line 1212 
      buffer->unmap_len = (unsigned short)st->header_unmap_len;
      
#line 1213 
      buffer->dma_offset = (unsigned short)0U;
      
#line 1217 
      st->header_unmap_len = 0U;
    }
    else {
      
#line 1219 
      buffer->flags = (unsigned short)1U;
      
#line 1220 
      buffer->unmap_len = (unsigned short)0U;
    }
    
#line 1222 
    tx_queue->insert_count += 1U;
  }
  
#line 1225 
  tmp_7 = skb_end_pointer(skb);
  
#line 1225 
  st->seqnum += (unsigned int)((struct skb_shared_info *)tmp_7)->gso_size;
  
#line 1228 
  st->ipv4_id = (u16)((int)st->ipv4_id + 1);
  
#line 1230 
  tx_queue->tso_packets += 1U;
  
#line 1232 
  tx_queue->tx_packets += 1UL;
  
#line 1234 
  __retres = 0;
  return_label: 
#line 1234 
                return __retres;
}


#line 1249  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tx.c"
static int efx_enqueue_skb_tso(struct efx_tx_queue *tx_queue, struct sk_buff *skb)
{
  int __retres;
  int frag_i;
  int rc;
  struct tso_state state;
  int tmp_0;
  
#line 1252 
  struct efx_nic *efx = tx_queue->efx;
  
#line 1253 
  unsigned int old_insert_count = tx_queue->insert_count;
  
#line 1258 
  state.protocol = efx_tso_check_protocol(skb);
  
#line 1260 
  rc = tso_start(& state,efx,(struct sk_buff const *)skb);
  
#line 1261 
  if (rc != 0) 
#line 1262 
               goto mem_err; else ;
  
#line 1264 
  if ((long)(state.in_len == 0U) != 0L) {
    unsigned char *tmp;
    
#line 1267 
    frag_i = 0;
    
#line 1269 
    tmp = skb_end_pointer((struct sk_buff const *)skb);
    
#line 1268 
    ;
    
#line 1268 
    ;
    
#line 1268 
    rc = tso_get_fragment(& state,efx,(skb_frag_t *)(& ((struct skb_shared_info *)tmp)->frags) + frag_i);
    
#line 1270 
    if (rc != 0) 
#line 1271 
                 goto mem_err; else ;
  }
  else 
#line 1274 
       frag_i = -1;
  
#line 1277 
  tmp_0 = tso_start_new_packet(tx_queue,(struct sk_buff const *)skb,& state);
  
#line 1277 
  if (tmp_0 < 0) 
#line 1278 
                 goto mem_err; else ;
  ldv_55962: 
#line 1279 
  ;
  
#line 1281 
  tso_fill_packet_with_fragment(tx_queue,(struct sk_buff const *)skb,& state);
  
#line 1284 
  if (state.in_len == 0U) {
    unsigned char *tmp_1;
    unsigned char *tmp_2;
    
#line 1285 
    frag_i += 1;
    
#line 1285 
    tmp_1 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 1285 
    ;
    
#line 1285 
    if (frag_i >= (int)((struct skb_shared_info *)tmp_1)->nr_frags) 
#line 1287 
                                                                    goto ldv_55961; else ;
    
#line 1289 
    tmp_2 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 1288 
    ;
    
#line 1288 
    ;
    
#line 1288 
    rc = tso_get_fragment(& state,efx,(skb_frag_t *)(& ((struct skb_shared_info *)tmp_2)->frags) + frag_i);
    
#line 1290 
    if (rc != 0) 
#line 1291 
                 goto mem_err; else ;
  }
  else ;
  
#line 1295 
  if (state.packet_space == 0U) {
    int tmp_3;
    
#line 1295 
    tmp_3 = tso_start_new_packet(tx_queue,(struct sk_buff const *)skb,& state);
    
#line 1295 
    if (tmp_3 < 0) 
#line 1297 
                   goto mem_err; else ;
  }
  else ;
  
#line 1281 
  goto ldv_55962;
  ldv_55961: 
#line 1282 
  ;
  
#line 1300 
  netdev_tx_sent_queue(tx_queue->core_txq,skb->len);
  
#line 1302 
  efx_tx_maybe_stop_queue(tx_queue);
  
#line 1305 
  if ((unsigned int)*((unsigned char *)skb + 142UL) == 0U) 
#line 1306 
                                                           efx_nic_push_buffers(tx_queue);
  else {
    bool tmp_4;
    
#line 1305 
    tmp_4 = netif_xmit_stopped((struct netdev_queue const *)tx_queue->core_txq);
    
#line 1305 
    if ((int)tmp_4 != 0) 
#line 1306 
                         efx_nic_push_buffers(tx_queue); else ;
  }
  
#line 1308 
  tx_queue->tso_bursts += 1U;
  
#line 1309 
  __retres = 0;
  
#line 1309 
  goto return_label;
  mem_err: 
#line 1311 
  ;
  
#line 1312 
  if ((efx->msg_enable & 128U) != 0U) 
#line 1312 
                                      netdev_err((struct net_device const *)efx->net_dev,"Out of memory for TSO headers, or DMA mapping error\n"); else ;
  
#line 1314 
  dev_kfree_skb_any(skb);
  
#line 1317 
  if (state.unmap_len != 0U) 
    
#line 1318 
    if (((int)state.dma_flags & 8) != 0) 
#line 1319 
                                         dma_unmap_single_attrs(& (efx->pci_dev)->dev,state.unmap_addr,(unsigned long)state.unmap_len,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0); else 
                                                                    
#line 1322 
                                                                    dma_unmap_page(& (efx->pci_dev)->dev,state.unmap_addr,(unsigned long)state.unmap_len,(enum dma_data_direction)DMA_TO_DEVICE);
  else ;
  
#line 1327 
  if (state.header_unmap_len != 0U) 
#line 1328 
                                    dma_unmap_single_attrs(& (efx->pci_dev)->dev,state.header_dma_addr,(unsigned long)state.header_unmap_len,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0); else ;
  
#line 1331 
  efx_enqueue_unwind(tx_queue,old_insert_count);
  
#line 1332 
  __retres = 0;
  return_label: 
#line 1332 
                return __retres;
}


#line 491  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void *kmalloc(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 494 
  tmp = ldv_kmalloc(size,flags);
  
#line 494 
  return tmp;
}


#line 505  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void *kcalloc_5(size_t n, size_t size, gfp_t flags)
{
  void *tmp;
  
#line 508 
  tmp = ldv_kcalloc(n,size,flags);
  
#line 508 
  return tmp;
}


#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/cmpxchg.h"
void __xchg_wrong_size(void);


#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/atomic.h"
static void atomic_dec_0(atomic_t *v);


#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
void __raw_spin_lock_init(raw_spinlock_t *, char const *, struct lock_class_key *);


#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock)
{
  raw_spinlock_t *__retres;
  
#line 301 
  __retres = & lock->__anonCompField_spinlock_18.rlock;
  
#line 301 
  return __retres;
}


#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_2(spinlock_t *lock)
{
  
#line 312 
  _raw_spin_lock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 313 
  return;
}


#line 358 
static void ldv_spin_lock_106(spinlock_t *lock);


#line 362 
static void ldv_spin_lock_109(spinlock_t *lock);


#line 366 
static void ldv_spin_lock_111(spinlock_t *lock);


#line 370 
static void ldv_spin_lock_121(spinlock_t *lock);


#line 374 
static void ldv_spin_lock_123(spinlock_t *lock);


#line 375  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_bh_1(spinlock_t *lock)
{
  
#line 377 
  _raw_spin_lock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 378 
  return;
}


#line 427 
static void ldv_spin_lock_bh_97_0(spinlock_t *lock);


#line 431 
static void ldv_spin_lock_bh_99(spinlock_t *lock);


#line 435 
static void ldv_spin_lock_bh_101(spinlock_t *lock);


#line 439 
static void ldv_spin_lock_bh_103(spinlock_t *lock);


#line 443 
static void ldv_spin_lock_bh_113(spinlock_t *lock);


#line 447 
static void ldv_spin_lock_bh_115(spinlock_t *lock);


#line 451 
static void ldv_spin_lock_bh_117(spinlock_t *lock);


#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_2(spinlock_t *lock)
{
  
#line 365 
  _raw_spin_unlock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 366 
  return;
}


#line 407 
static void ldv_spin_unlock_107(spinlock_t *lock);


#line 411 
static void ldv_spin_unlock_110(spinlock_t *lock);


#line 415 
static void ldv_spin_unlock_112(spinlock_t *lock);


#line 419 
static void ldv_spin_unlock_122(spinlock_t *lock);


#line 423 
static void ldv_spin_unlock_124(spinlock_t *lock);


#line 424  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_bh_2(spinlock_t *lock)
{
  
#line 426 
  _raw_spin_unlock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 427 
  return;
}


#line 480 
static void ldv_spin_unlock_bh_98(spinlock_t *lock);


#line 484 
static void ldv_spin_unlock_bh_100(spinlock_t *lock);


#line 488 
static void ldv_spin_unlock_bh_102(spinlock_t *lock);


#line 492 
static void ldv_spin_unlock_bh_105_0(spinlock_t *lock);


#line 496 
static void ldv_spin_unlock_bh_114(spinlock_t *lock);


#line 500 
static void ldv_spin_unlock_bh_116(spinlock_t *lock);


#line 504 
static void ldv_spin_unlock_bh_119(spinlock_t *lock);


#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
void init_timer_key(struct timer_list *, unsigned int, char const *, struct lock_class_key *);


#line 173 
static int ldv_mod_timer_104(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2);


#line 177 
static int ldv_mod_timer_118(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2);


#line 232 
static int ldv_del_timer_sync_108(struct timer_list *ldv_func_arg1);


#line 236 
static int ldv_del_timer_sync_120(struct timer_list *ldv_func_arg1);


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
void __init_waitqueue_head(wait_queue_head_t *, char const *, struct lock_class_key *);


#line 352  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/gfp.h"
unsigned long __get_free_pages(gfp_t, unsigned int);


#line 367 
void free_pages(unsigned long, unsigned int);


#line 425  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
void schedule(void);


#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kmalloc_0(size_t size, gfp_t flags);


#line 581 
static void *kzalloc_5(size_t size, gfp_t flags);


#line 999  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
int pci_reset_function(struct pci_dev *);


#line 120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.h"
__inline static struct efx_mcdi_iface *efx_mcdi(struct efx_nic *efx)
{
  struct efx_mcdi_iface *__retres;
  
#line 123 
  __retres = & (efx->mcdi)->iface;
  
#line 123 
  return __retres;
}


#line 145 
int efx_mcdi_rpc_start(struct efx_nic *efx, unsigned int cmd, efx_dword_t const *inbuf, size_t inlen);


#line 147 
int efx_mcdi_rpc_finish(struct efx_nic *efx, unsigned int cmd, size_t inlen, efx_dword_t *outbuf, size_t outlen, size_t *outlen_actual);


#line 150 
int efx_mcdi_rpc_finish_quiet(struct efx_nic *efx, unsigned int cmd, size_t inlen, efx_dword_t *outbuf, size_t outlen, size_t *outlen_actual);


#line 158 
int efx_mcdi_rpc_async(struct efx_nic *efx, unsigned int cmd, efx_dword_t const *inbuf, size_t inlen, size_t outlen, efx_mcdi_async_completer *complete_0, unsigned long cookie);


#line 162 
int efx_mcdi_rpc_async_quiet(struct efx_nic *efx, unsigned int cmd, efx_dword_t const *inbuf, size_t inlen, size_t outlen, efx_mcdi_async_completer *complete_0, unsigned long cookie);


#line 172 
int efx_mcdi_poll_reboot(struct efx_nic *efx);


#line 173 
void efx_mcdi_mode_poll(struct efx_nic *efx);


#line 174 
void efx_mcdi_mode_event(struct efx_nic *efx);


#line 175 
void efx_mcdi_flush_async(struct efx_nic *efx);


#line 340 
void efx_mcdi_process_link_change(struct efx_nic *efx, efx_qword_t *ev);


#line 349 
int efx_mcdi_set_workaround(struct efx_nic *efx, u32 type, bool enabled);


#line 350 
int efx_mcdi_get_workarounds(struct efx_nic *efx, unsigned int *impl_out, unsigned int *enabled_out);


#line 568  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
void efx_ptp_event(struct efx_nic *efx, efx_qword_t *ev);


#line 571 
void efx_time_sync_event(struct efx_channel *channel, efx_qword_t *ev);


#line 768 
void efx_ef10_handle_drain_event(struct efx_nic *efx);


#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static void efx_mcdi_timeout_async(unsigned long context);


#line 53 
static int efx_mcdi_drv_attach(struct efx_nic *efx, bool driver_operating, bool *was_attached);


#line 55 
static bool efx_mcdi_poll_once(struct efx_nic *efx);


#line 56 
static void efx_mcdi_abandon(struct efx_nic *efx);


#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static bool mcdi_logging_default;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
int efx_mcdi_init(struct efx_nic *efx)
{
  int __retres;
  struct efx_mcdi_iface *mcdi;
  bool already_attached;
  unsigned long tmp_0;
  
#line 69 
  int rc = -12;
  
#line 71 
  efx->mcdi = (struct efx_mcdi_data *)kzalloc_5(712UL,208U);
  
#line 72 
  if (efx->mcdi == (struct efx_mcdi_data *)0) 
#line 73 
                                              goto fail; else ;
  
#line 75 
  mcdi = efx_mcdi(efx);
  
#line 76 
  mcdi->efx = efx;
  
#line 79 
  tmp_0 = __get_free_pages(208U,0U);
  
#line 79 
  mcdi->logging_buffer = (char *)tmp_0;
  
#line 80 
  if (mcdi->logging_buffer == (char *)0) 
#line 81 
                                         goto fail1; else ;
  
#line 82 
  mcdi->logging_enabled = mcdi_logging_default;
  {
    struct lock_class_key __key;
    
#line 84 
    __init_waitqueue_head(& mcdi->wq,"&mcdi->wq",& __key);
  }
  
#line 85 
  spinlock_check(& mcdi->iface_lock);
  {
    struct lock_class_key __key_0;
    
#line 85 
    __raw_spin_lock_init(& mcdi->iface_lock.__anonCompField_spinlock_18.rlock,"&(&mcdi->iface_lock)->rlock",& __key_0);
  }
  
#line 86 
  mcdi->state = MCDI_STATE_QUIESCENT;
  
#line 87 
  mcdi->mode = MCDI_MODE_POLL;
  
#line 88 
  spinlock_check(& mcdi->async_lock);
  {
    struct lock_class_key __key_1;
    
#line 88 
    __raw_spin_lock_init(& mcdi->async_lock.__anonCompField_spinlock_18.rlock,"&(&mcdi->async_lock)->rlock",& __key_1);
  }
  
#line 89 
  INIT_LIST_HEAD(& mcdi->async_list);
  {
    struct lock_class_key __key_2;
    
#line 90 
    init_timer_key(& mcdi->async_timer,0U,"((&mcdi->async_timer))",& __key_2);
  }
  
#line 90 
  mcdi->async_timer.function = & efx_mcdi_timeout_async;
  
#line 90 
  mcdi->async_timer.data = (unsigned long)mcdi;
  
#line 93 
  efx_mcdi_poll_reboot(efx);
  
#line 94 
  mcdi->new_epoch = (_Bool)1;
  
#line 97 
  rc = efx_mcdi_handle_assertion(efx);
  
#line 98 
  if (rc != 0) 
#line 99 
               goto fail2; else ;
  
#line 104 
  rc = efx_mcdi_drv_attach(efx,(_Bool)1,& already_attached);
  
#line 105 
  if (rc != 0) {
    
#line 106 
    if ((efx->msg_enable & 2U) != 0U) 
#line 106 
                                      netdev_err((struct net_device const *)efx->net_dev,"Unable to register driver with MCPU\n"); else ;
    
#line 108 
    goto fail2;
  }
  else ;
  
#line 110 
  if ((int)already_attached != 0) {
    
#line 112 
    if ((efx->msg_enable & 2U) != 0U) 
#line 112 
                                      netdev_err((struct net_device const *)efx->net_dev,"Host already registered with MCPU\n"); else ;
  }
  else ;
  
#line 115 
  if (((efx->mcdi)->fn_flags & 1U) != 0U) 
#line 117 
                                          efx->primary = efx; else ;
  
#line 119 
  __retres = 0;
  
#line 119 
  goto return_label;
  fail2: 
#line 120 
  ;
  
#line 122 
  free_pages((unsigned long)mcdi->logging_buffer,0U);
  fail1: 
#line 123 
  ;
  
#line 125 
  kfree((void const *)efx->mcdi);
  
#line 126 
  efx->mcdi = (struct efx_mcdi_data *)0;
  fail: 
#line 127 
  ;
  
#line 128 
  __retres = rc;
  return_label: 
#line 128 
                return __retres;
}


#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
void efx_mcdi_fini(struct efx_nic *efx)
{
  
#line 133 
  if (efx->mcdi == (struct efx_mcdi_data *)0) 
#line 134 
                                              goto return_label; else ;
  
#line 136 
  if ((long)((efx->mcdi)->iface.state != (unsigned int)MCDI_STATE_QUIESCENT) != 0L) {
    
#line 138 
    ldv_inline_asm();
    
#line 136 
    ;
  }
  else ;
  
#line 139 
  efx_mcdi_drv_attach(efx,(_Bool)0,(bool *)0);
  
#line 142 
  free_pages((unsigned long)(efx->mcdi)->iface.logging_buffer,0U);
  
#line 145 
  kfree((void const *)efx->mcdi);
  return_label: 
#line 146 
                return;
}


#line 148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static void efx_mcdi_send_request(struct efx_nic *efx, unsigned int cmd, efx_dword_t const *inbuf, size_t inlen)
{
  efx_dword_t hdr[2U];
  size_t hdr_len;
  u32 xflags;
  u32 seqno;
  
#line 151 
  struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
  
#line 153 
  char *buf = mcdi->logging_buffer;
  
#line 159 
  if ((long)(mcdi->state == (unsigned int)MCDI_STATE_QUIESCENT) != 0L) {
    
#line 161 
    ldv_inline_asm();
    
#line 159 
    ;
  }
  else ;
  
#line 162 
  ldv_spin_lock_bh_97_0(& mcdi->iface_lock);
  
#line 163 
  mcdi->seqno += 1U;
  
#line 164 
  ldv_spin_unlock_bh_98(& mcdi->iface_lock);
  
#line 166 
  seqno = mcdi->seqno & 15U;
  
#line 167 
  xflags = 0U;
  
#line 168 
  if (mcdi->mode == (unsigned int)MCDI_MODE_EVENTS) 
#line 169 
                                                    xflags |= 1U; else ;
  
#line 171 
  if ((efx->type)->mcdi_max_ver == 1) {
    
#line 173 
    hdr[0].u32[0] = ((((((unsigned int)inlen << 8) | cmd) | (seqno << 16)) | (xflags << 24)) | ((unsigned int)(! mcdi->new_epoch) << 21)) | 128U;
    
#line 181 
    hdr_len = 4UL;
  }
  else {
    
#line 184 
    if ((long)(inlen > 1024UL) != 0L) {
      
#line 186 
      ldv_inline_asm();
      
#line 184 
      ;
    }
    else ;
    
#line 185 
    hdr[0].u32[0] = (((seqno << 16) | (xflags << 24)) | ((unsigned int)(! mcdi->new_epoch) << 21)) | 255U;
    
#line 193 
    hdr[1].u32[0] = ((unsigned int)inlen << 16) | cmd;
    
#line 196 
    hdr_len = 8UL;
  }
  
#line 200 
  if ((int)mcdi->logging_enabled != 0) {
    int tmp_5;
    {
      bool __warned_1;
      
#line 200 
      int __ret_warn_once_1 = buf == (char *)0;
      
#line 200 
      if ((long)(__ret_warn_once_1 != 0) != 0L) {
        int tmp_4_0;
        {
          
#line 200 
          int __ret_warn_on_1 = ! __warned_1;
          
#line 200 
          if ((long)(__ret_warn_on_1 != 0) != 0L) 
#line 200 
                                                  warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c",200); else ;
          
#line 200 
          tmp_4_0 = (long)(__ret_warn_on_1 != 0);
        }
        
#line 200 
        if ((long)tmp_4_0 != 0L) 
#line 200 
                                 __warned_1 = (_Bool)1; else ;
      }
      else ;
      
#line 200 
      tmp_5 = (long)(__ret_warn_once_1 != 0);
    }
    
#line 200 
    if ((long)tmp_5 == 0L) {
      int i;
      int tmp_2_0;
      int tmp_3;
      
#line 201 
      int bytes = 0;
      {
        bool __warned;
        
#line 206 
        int __ret_warn_once = (hdr_len & 3UL) != 0UL;
        
#line 206 
        if ((long)(__ret_warn_once != 0) != 0L) {
          int tmp_0;
          {
            
#line 206 
            int __ret_warn_on = ! __warned;
            
#line 206 
            if ((long)(__ret_warn_on != 0) != 0L) 
#line 206 
                                                  warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c",206); else ;
            
#line 206 
            tmp_0 = (long)(__ret_warn_on != 0);
          }
          
#line 206 
          if ((long)tmp_0 != 0L) 
#line 206 
                                 __warned = (_Bool)1; else ;
        }
        else ;
        
#line 206 
        long tmp_2 = (long)(__ret_warn_once != 0);
      }
      {
        bool __warned_0;
        
#line 207 
        int __ret_warn_once_0 = (inlen & 3UL) != 0UL;
        
#line 207 
        if ((long)(__ret_warn_once_0 != 0) != 0L) {
          int tmp_1;
          {
            
#line 207 
            int __ret_warn_on_0 = ! __warned_0;
            
#line 207 
            if ((long)(__ret_warn_on_0 != 0) != 0L) 
#line 207 
                                                    warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c",207); else ;
            
#line 207 
            tmp_1 = (long)(__ret_warn_on_0 != 0);
          }
          
#line 207 
          if ((long)tmp_1 != 0L) 
#line 207 
                                 __warned_0 = (_Bool)1; else ;
        }
        else ;
        
#line 207 
        long tmp_4 = (long)(__ret_warn_once_0 != 0);
      }
      
#line 212 
      i = 0;
      
#line 212 
      goto ldv_56035;
      ldv_56034: 
#line 213 
      ;
      
#line 213 
      tmp_2_0 = snprintf(buf + bytes,4096UL - (unsigned long)bytes," %08x",hdr[i].u32[0]);
      
#line 214 
      bytes = tmp_2_0 + bytes;
      
#line 212 
      i += 1;
      ldv_56035: 
#line 213 
      ;
      
#line 212 
      if ((unsigned long)i < hdr_len / 4UL && (unsigned int)bytes <= 4095U) 
        
#line 214 
        goto ldv_56034; else 
#line 217 
                             goto ldv_56036;
      ldv_56036: 
#line 218 
      ;
      
#line 216 
      i = 0;
      
#line 216 
      goto ldv_56038;
      ldv_56037: 
#line 217 
      ;
      
#line 217 
      tmp_3 = snprintf(buf + bytes,4096UL - (unsigned long)bytes," %08x",(inbuf + i)->u32[0]);
      
#line 218 
      bytes = tmp_3 + bytes;
      
#line 216 
      i += 1;
      ldv_56038: 
#line 217 
      ;
      
#line 216 
      if ((unsigned long)i < inlen / 4UL && (unsigned int)bytes <= 4095U) 
        
#line 218 
        goto ldv_56037; else 
#line 221 
                             goto ldv_56039;
      ldv_56039: 
#line 222 
      ;
      
#line 220 
      if ((efx->msg_enable & 8192U) != 0U) 
#line 220 
                                           netdev_info((struct net_device const *)efx->net_dev,"MCDI RPC REQ:%s\n",buf); else ;
    }
    else ;
  }
  else ;
  
#line 224 
  (*((efx->type)->mcdi_request))(efx,(efx_dword_t const *)(& hdr),hdr_len,inbuf,inlen);
  
#line 226 
  mcdi->new_epoch = (_Bool)0;
  
#line 227 
  return;
}


#line 229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static int efx_mcdi_errno(unsigned int mcdi_err)
{
  int __retres;
  
#line 231 
  switch (mcdi_err) {
    case (unsigned int)0: 
#line 232 
    ;
    
#line 233 
    __retres = 0;
    
#line 233 
    goto return_label;
    case (unsigned int)1: 
#line 237 
    ;
    
#line 237 
    __retres = -1;
    
#line 237 
    goto return_label;
    case (unsigned int)2: 
#line 238 
    ;
    
#line 238 
    __retres = -2;
    
#line 238 
    goto return_label;
    case (unsigned int)4: 
#line 239 
    ;
    
#line 239 
    __retres = -4;
    
#line 239 
    goto return_label;
    case (unsigned int)11: 
#line 240 
    ;
    
#line 240 
    __retres = -11;
    
#line 240 
    goto return_label;
    case (unsigned int)13: 
#line 241 
    ;
    
#line 241 
    __retres = -13;
    
#line 241 
    goto return_label;
    case (unsigned int)16: 
#line 242 
    ;
    
#line 242 
    __retres = -16;
    
#line 242 
    goto return_label;
    case (unsigned int)22: 
#line 243 
    ;
    
#line 243 
    __retres = -22;
    
#line 243 
    goto return_label;
    case (unsigned int)35: 
#line 244 
    ;
    
#line 244 
    __retres = -35;
    
#line 244 
    goto return_label;
    case (unsigned int)38: 
#line 245 
    ;
    
#line 245 
    __retres = -38;
    
#line 245 
    goto return_label;
    case (unsigned int)62: 
#line 246 
    ;
    
#line 246 
    __retres = -62;
    
#line 246 
    goto return_label;
    case (unsigned int)114: 
#line 247 
    ;
    
#line 247 
    __retres = -114;
    
#line 247 
    goto return_label;
    case (unsigned int)28: 
#line 248 
    ;
    
#line 248 
    __retres = -28;
    
#line 248 
    goto return_label;
    case (unsigned int)95: 
#line 250 
    ;
    
#line 251 
    __retres = -95;
    
#line 251 
    goto return_label;
    case (unsigned int)4096: 
#line 252 
    ;
    
#line 253 
    __retres = -105;
    
#line 253 
    goto return_label;
    case (unsigned int)4105: 
#line 254 
    ;
    
#line 255 
    __retres = -98;
    
#line 255 
    goto return_label;
    default: 
#line 256 
    ;
    
#line 257 
    __retres = -71;
    
#line 257 
    goto return_label;
  }
  return_label: 
#line 231 
                return __retres;
}


#line 261  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static void efx_mcdi_read_response_header(struct efx_nic *efx)
{
  unsigned int respseq;
  unsigned int respcmd;
  unsigned int error;
  efx_dword_t hdr;
  
#line 263 
  struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
  
#line 266 
  char *buf = mcdi->logging_buffer;
  
#line 270 
  (*((efx->type)->mcdi_read_response))(efx,& hdr,0UL,4UL);
  
#line 271 
  respseq = (hdr.u32[0] >> 16) & 15U;
  
#line 272 
  respcmd = hdr.u32[0] & 127U;
  
#line 273 
  error = (hdr.u32[0] >> 22) & 1U;
  
#line 275 
  if (respcmd != 127U) {
    
#line 276 
    mcdi->resp_hdr_len = 4UL;
    
#line 277 
    mcdi->resp_data_len = (unsigned long)(hdr.u32[0] >> 8) & 255UL;
  }
  else {
    
#line 279 
    (*((efx->type)->mcdi_read_response))(efx,& hdr,4UL,4UL);
    
#line 280 
    mcdi->resp_hdr_len = 8UL;
    
#line 281 
    mcdi->resp_data_len = (unsigned long)(hdr.u32[0] >> 16) & 1023UL;
  }
  
#line 286 
  if ((int)mcdi->logging_enabled != 0) {
    int tmp_4;
    {
      bool __warned_0;
      
#line 286 
      int __ret_warn_once_0 = buf == (char *)0;
      
#line 286 
      if ((long)(__ret_warn_once_0 != 0) != 0L) {
        int tmp_3;
        {
          
#line 286 
          int __ret_warn_on_0 = ! __warned_0;
          
#line 286 
          if ((long)(__ret_warn_on_0 != 0) != 0L) 
#line 286 
                                                  warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c",286); else ;
          
#line 286 
          tmp_3 = (long)(__ret_warn_on_0 != 0);
        }
        
#line 286 
        if ((long)tmp_3 != 0L) 
#line 286 
                               __warned_0 = (_Bool)1; else ;
      }
      else ;
      
#line 286 
      tmp_4 = (long)(__ret_warn_once_0 != 0);
    }
    
#line 286 
    if ((long)tmp_4 == 0L) {
      size_t hdr_len;
      size_t data_len;
      int i;
      int tmp_1;
      int tmp_2_0;
      
#line 288 
      int bytes = 0;
      {
        bool __warned;
        
#line 291 
        int __ret_warn_once = (mcdi->resp_hdr_len & 3UL) != 0UL;
        
#line 291 
        if ((long)(__ret_warn_once != 0) != 0L) {
          int tmp_0;
          {
            
#line 291 
            int __ret_warn_on = ! __warned;
            
#line 291 
            if ((long)(__ret_warn_on != 0) != 0L) 
#line 291 
                                                  warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c",291); else ;
            
#line 291 
            tmp_0 = (long)(__ret_warn_on != 0);
          }
          
#line 291 
          if ((long)tmp_0 != 0L) 
#line 291 
                                 __warned = (_Bool)1; else ;
        }
        else ;
        
#line 291 
        long tmp_2 = (long)(__ret_warn_once != 0);
      }
      
#line 292 
      hdr_len = mcdi->resp_hdr_len / 4UL;
      
#line 296 
      data_len = (mcdi->resp_data_len + 3UL) / 4UL;
      
#line 301 
      i = 0;
      
#line 301 
      goto ldv_56084;
      ldv_56083: 
#line 302 
      ;
      
#line 302 
      (*((efx->type)->mcdi_read_response))(efx,& hdr,(unsigned long)(i * 4),4UL);
      
#line 303 
      tmp_1 = snprintf(buf + bytes,4096UL - (unsigned long)bytes," %08x",hdr.u32[0]);
      
#line 304 
      bytes = tmp_1 + bytes;
      
#line 301 
      i += 1;
      ldv_56084: 
#line 302 
      ;
      
#line 301 
      if ((unsigned long)i < hdr_len && (unsigned int)bytes <= 4095U) 
        
#line 303 
        goto ldv_56083; else 
#line 306 
                             goto ldv_56085;
      ldv_56085: 
#line 307 
      ;
      
#line 307 
      i = 0;
      
#line 307 
      goto ldv_56087;
      ldv_56086: 
#line 308 
      ;
      
#line 308 
      (*((efx->type)->mcdi_read_response))(efx,& hdr,mcdi->resp_hdr_len + (unsigned long)(i * 4),4UL);
      
#line 310 
      tmp_2_0 = snprintf(buf + bytes,4096UL - (unsigned long)bytes," %08x",hdr.u32[0]);
      
#line 311 
      bytes = tmp_2_0 + bytes;
      
#line 307 
      i += 1;
      ldv_56087: 
#line 308 
      ;
      
#line 307 
      if ((unsigned long)i < data_len && (unsigned int)bytes <= 4095U) 
        
#line 309 
        goto ldv_56086; else 
#line 312 
                             goto ldv_56088;
      ldv_56088: 
#line 313 
      ;
      
#line 314 
      if ((efx->msg_enable & 8192U) != 0U) 
#line 314 
                                           netdev_info((struct net_device const *)efx->net_dev,"MCDI RPC RESP:%s\n",buf); else ;
    }
    else ;
  }
  else ;
  
#line 318 
  if (error != 0U && mcdi->resp_data_len == 0UL) {
    
#line 319 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 319 
                                         netdev_err((struct net_device const *)efx->net_dev,"MC rebooted\n"); else ;
    
#line 320 
    mcdi->resprc = -5;
  }
  else 
    
#line 321 
    if (((mcdi->seqno ^ respseq) & 15U) != 0U) {
      
#line 322 
      if ((efx->msg_enable & 8192U) != 0U) 
#line 322 
                                           netdev_err((struct net_device const *)efx->net_dev,"MC response mismatch tx seq 0x%x rx seq 0x%x\n",respseq,mcdi->seqno); else ;
      
#line 325 
      mcdi->resprc = -5;
    }
    else 
      
#line 326 
      if (error != 0U) {
        
#line 327 
        (*((efx->type)->mcdi_read_response))(efx,& hdr,mcdi->resp_hdr_len,4UL);
        
#line 328 
        mcdi->resprc = efx_mcdi_errno(hdr.u32[0]);
      }
      else 
#line 331 
           mcdi->resprc = 0;
  
#line 332 
  return;
}


#line 335  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static bool efx_mcdi_poll_once(struct efx_nic *efx)
{
  bool __retres;
  int tmp_1;
  bool tmp_0;
  
#line 337 
  struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
  
#line 338 
  ldv_inline_asm();
  
#line 340 
  tmp_0 = (*((efx->type)->mcdi_poll_response))(efx);
  
#line 340 
  if (tmp_0) 
#line 340 
             tmp_1 = 0; else 
#line 340 
                             tmp_1 = 1;
  
#line 340 
  if (tmp_1) {
    
#line 341 
    __retres = (_Bool)0;
    
#line 341 
    goto return_label;
  }
  else ;
  
#line 343 
  ldv_spin_lock_bh_99(& mcdi->iface_lock);
  
#line 344 
  efx_mcdi_read_response_header(efx);
  
#line 345 
  ldv_spin_unlock_bh_100(& mcdi->iface_lock);
  
#line 347 
  __retres = (_Bool)1;
  return_label: 
#line 347 
                return __retres;
}


#line 350  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static int efx_mcdi_poll(struct efx_nic *efx)
{
  int __retres;
  unsigned long time;
  unsigned long finish;
  unsigned int spins;
  int rc;
  bool tmp_0;
  int tmp_1;
  
#line 352 
  struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
  
#line 358 
  rc = efx_mcdi_poll_reboot(efx);
  
#line 359 
  if (rc != 0) {
    
#line 360 
    ldv_spin_lock_bh_101(& mcdi->iface_lock);
    
#line 361 
    mcdi->resprc = rc;
    
#line 362 
    mcdi->resp_hdr_len = 0UL;
    
#line 363 
    mcdi->resp_data_len = 0UL;
    
#line 364 
    ldv_spin_unlock_bh_102(& mcdi->iface_lock);
    
#line 365 
    __retres = 0;
    
#line 365 
    goto return_label;
  }
  else ;
  
#line 372 
  spins = 10000U;
  
#line 373 
  finish = jiffies + 2500UL;
  ldv_56108: 
#line 374 
  ;
  
#line 376 
  if (spins != 0U) {
    
#line 377 
    spins -= 1U;
    
#line 378 
    __const_udelay(4295UL);
  }
  else 
#line 380 
       schedule_timeout_uninterruptible(1L);
  
#line 383 
  time = jiffies;
  
#line 385 
  tmp_0 = efx_mcdi_poll_once(efx);
  
#line 385 
  if ((int)tmp_0 != 0) 
#line 386 
                       goto ldv_56101; else ;
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
#line 388 
    tmp_1 = 1;
  }
  
#line 388 
  if (tmp_1 != 0) {
    int tmp_2;
    {
      unsigned long __dummy_0;
      unsigned long __dummy2_0;
      
#line 388 
      tmp_2 = 1;
    }
    
#line 388 
    if (tmp_2 != 0) {
      
#line 388 
      if ((long)(finish - time) < 0L) {
        
#line 389 
        __retres = -110;
        
#line 389 
        goto return_label;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 376 
  goto ldv_56108;
  ldv_56101: 
#line 377 
  ;
  
#line 393 
  __retres = 0;
  return_label: 
#line 393 
                return __retres;
}


#line 399  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
int efx_mcdi_poll_reboot(struct efx_nic *efx)
{
  int __retres;
  int tmp;
  
#line 401 
  if (efx->mcdi == (struct efx_mcdi_data *)0) {
    
#line 402 
    __retres = 0;
    
#line 402 
    goto return_label;
  }
  else ;
  
#line 404 
  tmp = (*((efx->type)->mcdi_poll_reboot))(efx);
  
#line 404 
  __retres = tmp;
  return_label: 
#line 404 
                return __retres;
}


#line 407  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static bool efx_mcdi_acquire_async(struct efx_mcdi_iface *mcdi)
{
  bool __retres;
  enum efx_mcdi_state tmp;
  {
    enum efx_mcdi_state __ret;
    
#line 409 
    enum efx_mcdi_state __old = MCDI_STATE_QUIESCENT;
    
#line 409 
    enum efx_mcdi_state __new = MCDI_STATE_RUNNING_ASYNC;
    
#line 409 
    switch (4UL) {
      case (unsigned long)1: 
#line 409 
      ;
      {
        
#line 409 
        u8 volatile *__ptr = (u8 volatile *)(& mcdi->state);
        
#line 410 
        ldv_inline_asm();
        
#line 409 
        goto ldv_56120;
      }
      case (unsigned long)2: 
#line 409 
      ;
      {
        
#line 409 
        u16 volatile *__ptr_0 = (u16 volatile *)(& mcdi->state);
        
#line 410 
        ldv_inline_asm();
        
#line 409 
        goto ldv_56120;
      }
      case (unsigned long)4: 
#line 409 
      ;
      {
        
#line 409 
        u32 volatile *__ptr_1 = (u32 volatile *)(& mcdi->state);
        
#line 410 
        ldv_inline_asm();
        
#line 409 
        goto ldv_56120;
      }
      case (unsigned long)8: 
#line 409 
      ;
      {
        
#line 409 
        u64 volatile *__ptr_2 = (u64 volatile *)(& mcdi->state);
        
#line 410 
        ldv_inline_asm();
        
#line 409 
        goto ldv_56120;
      }
      default: 
#line 409 
      ;
      
#line 409 
      __cmpxchg_wrong_size();
    }
    ldv_56120: 
#line 409 
    ;
    
#line 409 
    tmp = __ret;
  }
  
#line 410 
  __retres = (_Bool)(tmp == (unsigned int)MCDI_STATE_QUIESCENT);
  
#line 410 
  return __retres;
}


#line 414  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static void efx_mcdi_acquire_sync(struct efx_mcdi_iface *mcdi)
{
  enum efx_mcdi_state tmp;
  
#line 419 
  __might_sleep("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c",422,0);
  {
    enum efx_mcdi_state __ret;
    
#line 419 
    enum efx_mcdi_state __old = MCDI_STATE_QUIESCENT;
    
#line 419 
    enum efx_mcdi_state __new = MCDI_STATE_RUNNING_SYNC;
    
#line 419 
    switch (4UL) {
      case (unsigned long)1: 
#line 419 
      ;
      {
        
#line 419 
        u8 volatile *__ptr = (u8 volatile *)(& mcdi->state);
        
#line 420 
        ldv_inline_asm();
        
#line 419 
        goto ldv_56137;
      }
      case (unsigned long)2: 
#line 419 
      ;
      {
        
#line 419 
        u16 volatile *__ptr_0 = (u16 volatile *)(& mcdi->state);
        
#line 420 
        ldv_inline_asm();
        
#line 419 
        goto ldv_56137;
      }
      case (unsigned long)4: 
#line 419 
      ;
      {
        
#line 419 
        u32 volatile *__ptr_1 = (u32 volatile *)(& mcdi->state);
        
#line 420 
        ldv_inline_asm();
        
#line 419 
        goto ldv_56137;
      }
      case (unsigned long)8: 
#line 419 
      ;
      {
        
#line 419 
        u64 volatile *__ptr_2 = (u64 volatile *)(& mcdi->state);
        
#line 420 
        ldv_inline_asm();
        
#line 419 
        goto ldv_56137;
      }
      default: 
#line 419 
      ;
      
#line 419 
      __cmpxchg_wrong_size();
    }
    ldv_56137: 
#line 419 
    ;
    
#line 419 
    tmp = __ret;
  }
  
#line 419 
  if (tmp == (unsigned int)MCDI_STATE_QUIESCENT) 
#line 419 
                                                 goto ldv_56146; else ;
  {
    wait_queue_t __wait;
    
#line 419 
    long __ret_0 = 0L;
    
#line 419 
    INIT_LIST_HEAD(& __wait.task_list);
    
#line 419 
    __wait.flags = 0U;
    ldv_56166: 
#line 422 
    ;
    {
      enum efx_mcdi_state tmp_1;
      
#line 419 
      long __int = prepare_to_wait_event(& mcdi->wq,& __wait,2);
      {
        enum efx_mcdi_state __ret_1;
        
#line 419 
        enum efx_mcdi_state __old_0 = MCDI_STATE_QUIESCENT;
        
#line 419 
        enum efx_mcdi_state __new_0 = MCDI_STATE_RUNNING_SYNC;
        
#line 419 
        switch (4UL) {
          case (unsigned long)1: 
#line 419 
          ;
          {
            
#line 419 
            u8 volatile *__ptr_3 = (u8 volatile *)(& mcdi->state);
            
#line 420 
            ldv_inline_asm();
            
#line 419 
            goto ldv_56156;
          }
          case (unsigned long)2: 
#line 419 
          ;
          {
            
#line 419 
            u16 volatile *__ptr_4 = (u16 volatile *)(& mcdi->state);
            
#line 420 
            ldv_inline_asm();
            
#line 419 
            goto ldv_56156;
          }
          case (unsigned long)4: 
#line 419 
          ;
          {
            
#line 419 
            u32 volatile *__ptr_5 = (u32 volatile *)(& mcdi->state);
            
#line 420 
            ldv_inline_asm();
            
#line 419 
            goto ldv_56156;
          }
          case (unsigned long)8: 
#line 419 
          ;
          {
            
#line 419 
            u64 volatile *__ptr_6 = (u64 volatile *)(& mcdi->state);
            
#line 420 
            ldv_inline_asm();
            
#line 419 
            goto ldv_56156;
          }
          default: 
#line 419 
          ;
          
#line 419 
          __cmpxchg_wrong_size();
        }
        ldv_56156: 
#line 419 
        ;
        
#line 419 
        tmp_1 = __ret_1;
      }
      
#line 419 
      if (tmp_1 == (unsigned int)MCDI_STATE_QUIESCENT) 
#line 419 
                                                       goto ldv_56165; else ;
      
#line 419 
      schedule();
    }
    
#line 419 
    goto ldv_56166;
    ldv_56165: 
#line 420 
    ;
    
#line 419 
    finish_wait(& mcdi->wq,& __wait);
    __out_0: 
#line 419 
    ;
    
#line 419 
    long tmp_2 = __ret_0;
  }
  ldv_56146: 
#line 421 
  ;
  
#line 422 
  return;
}


#line 425  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static int efx_mcdi_await_completion(struct efx_nic *efx)
{
  int __retres;
  long tmp_4;
  
#line 427 
  struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
  {
    
#line 429 
    long __ret = 2500L;
    
#line 429 
    __might_sleep("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c",430,0);
    {
      int tmp_3;
      {
        
#line 429 
        bool __cond_0 = (_Bool)(mcdi->state == (unsigned int)MCDI_STATE_COMPLETED);
        
#line 429 
        if ((int)__cond_0 != 0 && __ret == 0L) 
#line 429 
                                               __ret = 1L; else ;
        
#line 429 
        tmp_3 = ((int)__cond_0 != 0 || __ret == 0L) != 0;
      }
      
#line 429 
      if (tmp_3 == 0) {
        long tmp_2;
        {
          wait_queue_t __wait;
          
#line 429 
          long __ret_0 = 2500L;
          
#line 429 
          INIT_LIST_HEAD(& __wait.task_list);
          
#line 429 
          __wait.flags = 0U;
          ldv_56182: 
#line 432 
          ;
          {
            int tmp_1;
            
#line 429 
            long __int = prepare_to_wait_event(& mcdi->wq,& __wait,2);
            {
              
#line 429 
              bool __cond = (_Bool)(mcdi->state == (unsigned int)MCDI_STATE_COMPLETED);
              
#line 429 
              if ((int)__cond != 0 && __ret_0 == 0L) 
#line 429 
                                                     __ret_0 = 1L; else ;
              
#line 429 
              tmp_1 = ((int)__cond != 0 || __ret_0 == 0L) != 0;
            }
            
#line 429 
            if (tmp_1 != 0) 
#line 429 
                            goto ldv_56181; else ;
            
#line 429 
            __ret_0 = schedule_timeout(__ret_0);
          }
          
#line 429 
          goto ldv_56182;
          ldv_56181: 
#line 430 
          ;
          
#line 429 
          finish_wait(& mcdi->wq,& __wait);
          __out_0: 
#line 429 
          ;
          
#line 429 
          tmp_2 = __ret_0;
        }
        
#line 429 
        __ret = tmp_2;
      }
      else ;
    }
    
#line 429 
    tmp_4 = __ret;
  }
  
#line 429 
  if (tmp_4 == 0L) {
    
#line 431 
    __retres = -110;
    
#line 431 
    goto return_label;
  }
  else ;
  
#line 441 
  if (mcdi->mode == (unsigned int)MCDI_MODE_POLL) {
    int tmp_5;
    
#line 442 
    tmp_5 = efx_mcdi_poll(efx);
    
#line 442 
    __retres = tmp_5;
    
#line 442 
    goto return_label;
  }
  else ;
  
#line 444 
  __retres = 0;
  return_label: 
#line 444 
                return __retres;
}


#line 450  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static bool efx_mcdi_complete_sync(struct efx_mcdi_iface *mcdi)
{
  bool __retres;
  enum efx_mcdi_state tmp;
  {
    enum efx_mcdi_state __ret;
    
#line 452 
    enum efx_mcdi_state __old = MCDI_STATE_RUNNING_SYNC;
    
#line 452 
    enum efx_mcdi_state __new = MCDI_STATE_COMPLETED;
    
#line 452 
    switch (4UL) {
      case (unsigned long)1: 
#line 452 
      ;
      {
        
#line 452 
        u8 volatile *__ptr = (u8 volatile *)(& mcdi->state);
        
#line 453 
        ldv_inline_asm();
        
#line 452 
        goto ldv_56193;
      }
      case (unsigned long)2: 
#line 452 
      ;
      {
        
#line 452 
        u16 volatile *__ptr_0 = (u16 volatile *)(& mcdi->state);
        
#line 453 
        ldv_inline_asm();
        
#line 452 
        goto ldv_56193;
      }
      case (unsigned long)4: 
#line 452 
      ;
      {
        
#line 452 
        u32 volatile *__ptr_1 = (u32 volatile *)(& mcdi->state);
        
#line 453 
        ldv_inline_asm();
        
#line 452 
        goto ldv_56193;
      }
      case (unsigned long)8: 
#line 452 
      ;
      {
        
#line 452 
        u64 volatile *__ptr_2 = (u64 volatile *)(& mcdi->state);
        
#line 453 
        ldv_inline_asm();
        
#line 452 
        goto ldv_56193;
      }
      default: 
#line 452 
      ;
      
#line 452 
      __cmpxchg_wrong_size();
    }
    ldv_56193: 
#line 452 
    ;
    
#line 452 
    tmp = __ret;
  }
  
#line 452 
  if (tmp == (unsigned int)MCDI_STATE_RUNNING_SYNC) {
    
#line 455 
    __wake_up(& mcdi->wq,3U,1,(void *)0);
    
#line 456 
    __retres = (_Bool)1;
    
#line 456 
    goto return_label;
  }
  else ;
  
#line 459 
  __retres = (_Bool)0;
  return_label: 
#line 459 
                return __retres;
}


#line 462  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static void efx_mcdi_release(struct efx_mcdi_iface *mcdi)
{
  
#line 464 
  if (mcdi->mode == (unsigned int)MCDI_MODE_EVENTS) {
    struct efx_mcdi_async_param *async;
    int tmp;
    
#line 466 
    struct efx_nic *efx = mcdi->efx;
    
#line 469 
    ldv_spin_lock_bh_103(& mcdi->async_lock);
    
#line 470 
    tmp = list_empty((struct list_head const *)(& mcdi->async_list));
    
#line 470 
    if (tmp == 0) {
      struct efx_mcdi_async_param *tmp_0;
      {
        
#line 470 
        struct list_head const *__mptr = (struct list_head const *)mcdi->async_list.next;
        
#line 470 
        tmp_0 = (struct efx_mcdi_async_param *)__mptr;
      }
      
#line 470 
      async = tmp_0;
    }
    else 
#line 470 
         async = (struct efx_mcdi_async_param *)0;
    
#line 472 
    if (async != (struct efx_mcdi_async_param *)0) {
      
#line 473 
      mcdi->state = MCDI_STATE_RUNNING_ASYNC;
      
#line 474 
      efx_mcdi_send_request(efx,async->cmd,(efx_dword_t const *)(async + 1U),async->inlen);
      
#line 477 
      ldv_mod_timer_104(& mcdi->async_timer,jiffies + 2500UL);
    }
    else ;
    
#line 480 
    ldv_spin_unlock_bh_105_0(& mcdi->async_lock);
    
#line 482 
    if (async != (struct efx_mcdi_async_param *)0) 
#line 483 
                                                   goto return_label; else ;
  }
  else ;
  
#line 486 
  mcdi->state = MCDI_STATE_QUIESCENT;
  
#line 487 
  __wake_up(& mcdi->wq,3U,1,(void *)0);
  return_label: 
#line 488 
                return;
}


#line 495  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static bool efx_mcdi_complete_async(struct efx_mcdi_iface *mcdi, bool timeout)
{
  bool __retres;
  struct efx_mcdi_async_param *async;
  size_t hdr_len;
  size_t data_len;
  size_t err_len;
  efx_dword_t *outbuf;
  int rc;
  enum efx_mcdi_state tmp;
  struct efx_mcdi_async_param *tmp_0;
  size_t tmp_2;
  
#line 497 
  struct efx_nic *efx = mcdi->efx;
  
#line 501 
  efx_dword_t errbuf[2U] = {{.u32 = {0U}}};
  {
    enum efx_mcdi_state __ret;
    
#line 504 
    enum efx_mcdi_state __old = MCDI_STATE_RUNNING_ASYNC;
    
#line 504 
    enum efx_mcdi_state __new = MCDI_STATE_COMPLETED;
    
#line 504 
    switch (4UL) {
      case (unsigned long)1: 
#line 504 
      ;
      {
        
#line 504 
        u8 volatile *__ptr = (u8 volatile *)(& mcdi->state);
        
#line 505 
        ldv_inline_asm();
        
#line 504 
        goto ldv_56226;
      }
      case (unsigned long)2: 
#line 504 
      ;
      {
        
#line 504 
        u16 volatile *__ptr_0 = (u16 volatile *)(& mcdi->state);
        
#line 505 
        ldv_inline_asm();
        
#line 504 
        goto ldv_56226;
      }
      case (unsigned long)4: 
#line 504 
      ;
      {
        
#line 504 
        u32 volatile *__ptr_1 = (u32 volatile *)(& mcdi->state);
        
#line 505 
        ldv_inline_asm();
        
#line 504 
        goto ldv_56226;
      }
      case (unsigned long)8: 
#line 504 
      ;
      {
        
#line 504 
        u64 volatile *__ptr_2 = (u64 volatile *)(& mcdi->state);
        
#line 505 
        ldv_inline_asm();
        
#line 504 
        goto ldv_56226;
      }
      default: 
#line 504 
      ;
      
#line 504 
      __cmpxchg_wrong_size();
    }
    ldv_56226: 
#line 504 
    ;
    
#line 504 
    tmp = __ret;
  }
  
#line 504 
  if (tmp != (unsigned int)MCDI_STATE_RUNNING_ASYNC) {
    
#line 507 
    __retres = (_Bool)0;
    
#line 507 
    goto return_label;
  }
  else ;
  
#line 509 
  ldv_spin_lock_106(& mcdi->iface_lock);
  
#line 510 
  if ((int)timeout != 0) {
    
#line 514 
    mcdi->seqno += 1U;
    
#line 515 
    mcdi->credits += 1U;
    
#line 516 
    rc = -110;
    
#line 517 
    hdr_len = 0UL;
    
#line 518 
    data_len = 0UL;
  }
  else {
    
#line 520 
    rc = mcdi->resprc;
    
#line 521 
    hdr_len = mcdi->resp_hdr_len;
    
#line 522 
    data_len = mcdi->resp_data_len;
  }
  
#line 524 
  ldv_spin_unlock_107(& mcdi->iface_lock);
  
#line 530 
  if (! timeout) 
#line 531 
                 ldv_del_timer_sync_108(& mcdi->async_timer); else ;
  
#line 533 
  ldv_spin_lock_109(& mcdi->async_lock);
  {
    
#line 534 
    struct list_head const *__mptr = (struct list_head const *)mcdi->async_list.next;
    
#line 534 
    tmp_0 = (struct efx_mcdi_async_param *)__mptr;
  }
  
#line 534 
  async = tmp_0;
  
#line 536 
  list_del(& async->list);
  
#line 537 
  ldv_spin_unlock_110(& mcdi->async_lock);
  
#line 539 
  outbuf = (efx_dword_t *)(async + 1U);
  {
    size_t tmp_1;
    
#line 541 
    size_t _min1 = async->outlen;
    
#line 541 
    size_t _min2 = data_len;
    
#line 541 
    if (_min1 < _min2) 
#line 541 
                       tmp_1 = _min1; else 
#line 541 
                                           tmp_1 = _min2;
    
#line 541 
    tmp_2 = tmp_1;
  }
  
#line 540 
  ;
  
#line 540 
  ;
  
#line 540 
  ;
  
#line 540 
  (*((efx->type)->mcdi_read_response))(efx,outbuf,hdr_len,tmp_2);
  
#line 542 
  if ((! timeout && rc != 0) && ! async->quiet) {
    unsigned long tmp_4;
    {
      unsigned long tmp_3;
      
#line 543 
      unsigned long _min1_0 = 8UL;
      
#line 543 
      size_t _min2_0 = data_len;
      
#line 543 
      if (_min1_0 < _min2_0) 
#line 543 
                             tmp_3 = _min1_0; else 
#line 543 
                                                   tmp_3 = _min2_0;
      
#line 543 
      tmp_4 = tmp_3;
    }
    
#line 543 
    err_len = tmp_4;
    
#line 544 
    (*((efx->type)->mcdi_read_response))(efx,(efx_dword_t *)(& errbuf),hdr_len,8UL);
    
#line 546 
    efx_mcdi_display_error(efx,async->cmd,async->inlen,(efx_dword_t *)(& errbuf),err_len,rc);
  }
  else ;
  
#line 549 
  (*(async->complete))(efx,async->cookie,rc,outbuf,data_len);
  
#line 550 
  kfree((void const *)async);
  
#line 552 
  efx_mcdi_release(mcdi);
  
#line 554 
  __retres = (_Bool)1;
  return_label: 
#line 554 
                return __retres;
}


#line 557  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static void efx_mcdi_ev_cpl(struct efx_nic *efx, unsigned int seqno, unsigned int datalen, unsigned int mcdi_err)
{
  
#line 560 
  struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
  
#line 561 
  bool wake = (_Bool)0;
  
#line 563 
  ldv_spin_lock_111(& mcdi->iface_lock);
  
#line 565 
  if (((mcdi->seqno ^ seqno) & 15U) != 0U) {
    
#line 566 
    if (mcdi->credits != 0U) 
#line 568 
                             mcdi->credits -= 1U;
    else 
      
#line 570 
      if ((efx->msg_enable & 8192U) != 0U) 
#line 570 
                                           netdev_err((struct net_device const *)efx->net_dev,"MC response mismatch tx seq 0x%x rx ",seqno,mcdi->seqno); else ;
  }
  else {
    
#line 574 
    if ((efx->type)->mcdi_max_ver > 1) 
#line 576 
                                       efx_mcdi_read_response_header(efx);
    else {
      
#line 578 
      mcdi->resprc = efx_mcdi_errno(mcdi_err);
      
#line 579 
      mcdi->resp_hdr_len = 4UL;
      
#line 580 
      mcdi->resp_data_len = (unsigned long)datalen;
    }
    
#line 583 
    wake = (_Bool)1;
  }
  
#line 586 
  ldv_spin_unlock_112(& mcdi->iface_lock);
  
#line 588 
  if ((int)wake != 0) {
    int tmp_1;
    bool tmp_0;
    
#line 589 
    tmp_0 = efx_mcdi_complete_async(mcdi,(_Bool)0);
    
#line 589 
    if (tmp_0) 
#line 589 
               tmp_1 = 0; else 
#line 589 
                               tmp_1 = 1;
    
#line 589 
    if (tmp_1) 
#line 590 
               efx_mcdi_complete_sync(mcdi); else ;
  }
  else ;
  
#line 591 
  return;
}


#line 601  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static void efx_mcdi_timeout_async(unsigned long context)
{
  
#line 603 
  struct efx_mcdi_iface *mcdi = (struct efx_mcdi_iface *)context;
  
#line 605 
  efx_mcdi_complete_async(mcdi,(_Bool)1);
  
#line 606 
  return;
}


#line 609  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static int efx_mcdi_check_supported(struct efx_nic *efx, unsigned int cmd, size_t inlen)
{
  int __retres;
  
#line 611 
  if ((efx->type)->mcdi_max_ver < 0 || ((efx->type)->mcdi_max_ver <= 1 && cmd > 127U)) {
    
#line 614 
    __retres = -22;
    
#line 614 
    goto return_label;
  }
  else ;
  
#line 616 
  if (inlen > 1024UL || ((efx->type)->mcdi_max_ver <= 1 && inlen > 252UL)) {
    
#line 619 
    __retres = -90;
    
#line 619 
    goto return_label;
  }
  else ;
  
#line 621 
  __retres = 0;
  return_label: 
#line 621 
                return __retres;
}


#line 624  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static int _efx_mcdi_rpc_finish(struct efx_nic *efx, unsigned int cmd, size_t inlen, efx_dword_t *outbuf, size_t outlen, size_t *outlen_actual, bool quiet)
{
  int rc;
  
#line 628 
  struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
  
#line 629 
  efx_dword_t errbuf[2U] = {{.u32 = {0U}}};
  
#line 632 
  if (mcdi->mode == (unsigned int)MCDI_MODE_POLL) 
#line 633 
                                                  rc = efx_mcdi_poll(efx); else 
                                                                    
#line 635 
                                                                    rc = efx_mcdi_await_completion(efx);
  
#line 637 
  if (rc != 0) {
    
#line 638 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 638 
                                         netdev_err((struct net_device const *)efx->net_dev,"MC command 0x%x inlen %d mode %d timed out\n",cmd,(int)inlen,(unsigned int)mcdi->mode); else ;
    
#line 642 
    if (mcdi->mode == (unsigned int)MCDI_MODE_EVENTS) {
      bool tmp_0;
      
#line 642 
      tmp_0 = efx_mcdi_poll_once(efx);
      
#line 642 
      if ((int)tmp_0 != 0) {
        
#line 643 
        if ((efx->msg_enable & 8192U) != 0U) 
#line 643 
                                             netdev_err((struct net_device const *)efx->net_dev,"MCDI request was completed without an event\n"); else ;
        
#line 645 
        rc = 0;
      }
      else ;
    }
    else ;
    
#line 648 
    efx_mcdi_abandon(efx);
    
#line 654 
    ldv_spin_lock_bh_113(& mcdi->iface_lock);
    
#line 655 
    mcdi->seqno += 1U;
    
#line 656 
    mcdi->credits += 1U;
    
#line 657 
    ldv_spin_unlock_bh_114(& mcdi->iface_lock);
  }
  else ;
  
#line 660 
  if (rc != 0) {
    
#line 661 
    if (outlen_actual != (size_t *)0UL) 
#line 662 
                                        *outlen_actual = 0UL; else ;
  }
  else {
    size_t hdr_len;
    size_t data_len;
    size_t err_len;
    unsigned long tmp_2;
    size_t tmp_4;
    
#line 670 
    ldv_spin_lock_bh_115(& mcdi->iface_lock);
    
#line 671 
    rc = mcdi->resprc;
    
#line 672 
    hdr_len = mcdi->resp_hdr_len;
    
#line 673 
    data_len = mcdi->resp_data_len;
    {
      unsigned long tmp_1;
      
#line 674 
      unsigned long _min1 = 8UL;
      
#line 674 
      size_t _min2 = data_len;
      
#line 674 
      if (_min1 < _min2) 
#line 674 
                         tmp_1 = _min1; else 
#line 674 
                                             tmp_1 = _min2;
      
#line 674 
      tmp_2 = tmp_1;
    }
    
#line 674 
    err_len = tmp_2;
    
#line 675 
    ldv_spin_unlock_bh_116(& mcdi->iface_lock);
    
#line 677 
    if ((long)(rc > 0) != 0L) {
      
#line 679 
      ldv_inline_asm();
      
#line 677 
      ;
    }
    else ;
    {
      size_t tmp_3;
      
#line 680 
      size_t _min1_0 = outlen;
      
#line 680 
      size_t _min2_0 = data_len;
      
#line 680 
      if (_min1_0 < _min2_0) 
#line 680 
                             tmp_3 = _min1_0; else 
#line 680 
                                                   tmp_3 = _min2_0;
      
#line 680 
      tmp_4 = tmp_3;
    }
    
#line 679 
    ;
    
#line 679 
    ;
    
#line 679 
    ;
    
#line 679 
    (*((efx->type)->mcdi_read_response))(efx,outbuf,hdr_len,tmp_4);
    
#line 681 
    if (outlen_actual != (size_t *)0UL) 
#line 682 
                                        *outlen_actual = data_len; else ;
    
#line 684 
    (*((efx->type)->mcdi_read_response))(efx,(efx_dword_t *)(& errbuf),hdr_len,err_len);
    
#line 686 
    if (cmd == 61U && rc == -5) ;
    else 
      
#line 688 
      if ((unsigned int)rc + 5U <= 1U) {
        
#line 689 
        if ((efx->msg_enable & 8192U) != 0U) 
#line 689 
                                             netdev_err((struct net_device const *)efx->net_dev,"MC fatal error %d\n",- rc); else ;
        
#line 691 
        efx_schedule_reset(efx,(enum reset_type)RESET_TYPE_MC_FAILURE);
      }
      else 
        
#line 692 
        if (rc != 0 && ! quiet) 
#line 693 
                                efx_mcdi_display_error(efx,cmd,inlen,(efx_dword_t *)(& errbuf),err_len,rc); else ;
    
#line 697 
    if ((unsigned int)rc + 5U <= 1U) {
      
#line 698 
      msleep(250U);
      
#line 699 
      efx_mcdi_poll_reboot(efx);
      
#line 700 
      mcdi->new_epoch = (_Bool)1;
    }
    else ;
  }
  
#line 704 
  efx_mcdi_release(mcdi);
  
#line 705 
  return rc;
}


#line 708  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static int _efx_mcdi_rpc(struct efx_nic *efx, unsigned int cmd, efx_dword_t const *inbuf, size_t inlen, efx_dword_t *outbuf, size_t outlen, size_t *outlen_actual, bool quiet)
{
  int __retres;
  int rc;
  int tmp;
  
#line 715 
  rc = efx_mcdi_rpc_start(efx,cmd,inbuf,inlen);
  
#line 716 
  if (rc != 0) {
    
#line 717 
    if (outlen_actual != (size_t *)0UL) 
#line 718 
                                        *outlen_actual = 0UL; else ;
    
#line 719 
    __retres = rc;
    
#line 719 
    goto return_label;
  }
  else ;
  
#line 721 
  tmp = _efx_mcdi_rpc_finish(efx,cmd,inlen,outbuf,outlen,outlen_actual,(_Bool)((bool)((int)quiet) != 0));
  
#line 721 
  __retres = tmp;
  return_label: 
#line 721 
                return __retres;
}


#line 725  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
int efx_mcdi_rpc(struct efx_nic *efx, unsigned int cmd, efx_dword_t const *inbuf, size_t inlen, efx_dword_t *outbuf, size_t outlen, size_t *outlen_actual)
{
  int tmp;
  
#line 730 
  tmp = _efx_mcdi_rpc(efx,cmd,inbuf,inlen,outbuf,outlen,outlen_actual,(_Bool)0);
  
#line 730 
  return tmp;
}


#line 742  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
int efx_mcdi_rpc_quiet(struct efx_nic *efx, unsigned int cmd, efx_dword_t const *inbuf, size_t inlen, efx_dword_t *outbuf, size_t outlen, size_t *outlen_actual)
{
  int tmp;
  
#line 747 
  tmp = _efx_mcdi_rpc(efx,cmd,inbuf,inlen,outbuf,outlen,outlen_actual,(_Bool)1);
  
#line 747 
  return tmp;
}


#line 751  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
int efx_mcdi_rpc_start(struct efx_nic *efx, unsigned int cmd, efx_dword_t const *inbuf, size_t inlen)
{
  int __retres;
  int rc;
  
#line 754 
  struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
  
#line 757 
  rc = efx_mcdi_check_supported(efx,cmd,inlen);
  
#line 758 
  if (rc != 0) {
    
#line 759 
    __retres = rc;
    
#line 759 
    goto return_label;
  }
  else ;
  
#line 761 
  if ((int)efx->mc_bist_for_other_fn != 0) {
    
#line 762 
    __retres = -100;
    
#line 762 
    goto return_label;
  }
  else ;
  
#line 764 
  if (mcdi->mode == (unsigned int)MCDI_MODE_FAIL) {
    
#line 765 
    __retres = -100;
    
#line 765 
    goto return_label;
  }
  else ;
  
#line 767 
  efx_mcdi_acquire_sync(mcdi);
  
#line 768 
  efx_mcdi_send_request(efx,cmd,inbuf,inlen);
  
#line 769 
  __retres = 0;
  return_label: 
#line 769 
                return __retres;
}


#line 772  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static int _efx_mcdi_rpc_async(struct efx_nic *efx, unsigned int cmd, efx_dword_t const *inbuf, size_t inlen, size_t outlen, efx_mcdi_async_completer *complete_0, unsigned long cookie, bool quiet)
{
  int __retres;
  struct efx_mcdi_async_param *async;
  int rc;
  void *tmp_2;
  size_t tmp_1;
  
#line 778 
  struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
  
#line 782 
  rc = efx_mcdi_check_supported(efx,cmd,inlen);
  
#line 783 
  if (rc != 0) {
    
#line 784 
    __retres = rc;
    
#line 784 
    goto return_label;
  }
  else ;
  
#line 786 
  if ((int)efx->mc_bist_for_other_fn != 0) {
    
#line 787 
    __retres = -100;
    
#line 787 
    goto return_label;
  }
  else ;
  {
    size_t tmp_0;
    
#line 789 
    size_t _max1 = inlen;
    
#line 789 
    size_t _max2 = outlen;
    
#line 789 
    if (_max1 > _max2) 
#line 789 
                       tmp_0 = _max1; else 
#line 789 
                                           tmp_0 = _max2;
    
#line 789 
    tmp_1 = tmp_0;
  }
  
#line 789 
  tmp_2 = kmalloc_0(((tmp_1 + 3UL) & 18446744073709551612UL) + 64UL,32U);
  
#line 789 
  async = (struct efx_mcdi_async_param *)tmp_2;
  
#line 791 
  if (async == (struct efx_mcdi_async_param *)0) {
    
#line 792 
    __retres = -12;
    
#line 792 
    goto return_label;
  }
  else ;
  
#line 794 
  async->cmd = cmd;
  
#line 795 
  async->inlen = inlen;
  
#line 796 
  async->outlen = outlen;
  
#line 797 
  async->quiet = quiet;
  
#line 798 
  async->complete = complete_0;
  
#line 799 
  async->cookie = cookie;
  
#line 800 
  memcpy((void *)(async + 1U),(void const *)inbuf,inlen);
  
#line 802 
  ldv_spin_lock_bh_117(& mcdi->async_lock);
  
#line 804 
  if (mcdi->mode == (unsigned int)MCDI_MODE_EVENTS) {
    
#line 805 
    list_add_tail(& async->list,& mcdi->async_list);
    
#line 810 
    if (mcdi->async_list.next == & async->list) {
      bool tmp_3;
      
#line 810 
      tmp_3 = efx_mcdi_acquire_async(mcdi);
      
#line 810 
      if ((int)tmp_3 != 0) {
        
#line 812 
        efx_mcdi_send_request(efx,cmd,inbuf,inlen);
        
#line 813 
        ldv_mod_timer_118(& mcdi->async_timer,jiffies + 2500UL);
      }
      else ;
    }
    else ;
  }
  else {
    
#line 817 
    kfree((void const *)async);
    
#line 818 
    rc = -100;
  }
  
#line 821 
  ldv_spin_unlock_bh_119(& mcdi->async_lock);
  
#line 823 
  __retres = rc;
  return_label: 
#line 823 
                return __retres;
}


#line 847  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
int efx_mcdi_rpc_async(struct efx_nic *efx, unsigned int cmd, efx_dword_t const *inbuf, size_t inlen, size_t outlen, efx_mcdi_async_completer *complete_0, unsigned long cookie)
{
  int tmp;
  
#line 851 
  tmp = _efx_mcdi_rpc_async(efx,cmd,inbuf,inlen,outlen,complete_0,cookie,(_Bool)0);
  
#line 851 
  return tmp;
}


#line 855  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
int efx_mcdi_rpc_async_quiet(struct efx_nic *efx, unsigned int cmd, efx_dword_t const *inbuf, size_t inlen, size_t outlen, efx_mcdi_async_completer *complete_0, unsigned long cookie)
{
  int tmp;
  
#line 860 
  tmp = _efx_mcdi_rpc_async(efx,cmd,inbuf,inlen,outlen,complete_0,cookie,(_Bool)1);
  
#line 860 
  return tmp;
}


#line 864  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
int efx_mcdi_rpc_finish(struct efx_nic *efx, unsigned int cmd, size_t inlen, efx_dword_t *outbuf, size_t outlen, size_t *outlen_actual)
{
  int tmp;
  
#line 868 
  tmp = _efx_mcdi_rpc_finish(efx,cmd,inlen,outbuf,outlen,outlen_actual,(_Bool)0);
  
#line 868 
  return tmp;
}


#line 872  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
int efx_mcdi_rpc_finish_quiet(struct efx_nic *efx, unsigned int cmd, size_t inlen, efx_dword_t *outbuf, size_t outlen, size_t *outlen_actual)
{
  int tmp;
  
#line 876 
  tmp = _efx_mcdi_rpc_finish(efx,cmd,inlen,outbuf,outlen,outlen_actual,(_Bool)1);
  
#line 876 
  return tmp;
}


#line 880  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
void efx_mcdi_display_error(struct efx_nic *efx, unsigned int cmd, size_t inlen, efx_dword_t *outbuf, size_t outlen, int rc)
{
  
#line 884 
  int code = 0;
  
#line 884 
  int err_arg = 0;
  
#line 886 
  if (outlen > 3UL) 
#line 887 
                    code = (int)outbuf->u32[0]; else ;
  
#line 888 
  if (outlen > 7UL) 
#line 889 
                    err_arg = (int)(outbuf + 1U)->u32[0]; else ;
  
#line 890 
  if ((efx->msg_enable & 8192U) != 0U) 
#line 890 
                                       netdev_err((struct net_device const *)efx->net_dev,"MC command 0x%x inlen %d failed rc=%d (raw=%d) arg=%d\n",cmd,(int)inlen,rc,code,err_arg); else ;
  
#line 891 
  return;
}


#line 899  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
void efx_mcdi_mode_poll(struct efx_nic *efx)
{
  struct efx_mcdi_iface *mcdi;
  
#line 903 
  if (efx->mcdi == (struct efx_mcdi_data *)0) 
#line 904 
                                              goto return_label; else ;
  
#line 906 
  mcdi = efx_mcdi(efx);
  
#line 911 
  if (mcdi->mode == (unsigned int)MCDI_MODE_POLL || mcdi->mode == (unsigned int)MCDI_MODE_FAIL) 
    
#line 912 
    goto return_label; else ;
  
#line 922 
  mcdi->mode = MCDI_MODE_POLL;
  
#line 924 
  efx_mcdi_complete_sync(mcdi);
  return_label: 
#line 925 
                return;
}


#line 930  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
void efx_mcdi_flush_async(struct efx_nic *efx)
{
  struct efx_mcdi_async_param *async;
  struct efx_mcdi_async_param *next;
  struct efx_mcdi_iface *mcdi;
  struct efx_mcdi_async_param *tmp;
  struct efx_mcdi_async_param *tmp_0;
  struct efx_mcdi_async_param *tmp_1;
  
#line 935 
  if (efx->mcdi == (struct efx_mcdi_data *)0) 
#line 936 
                                              goto return_label; else ;
  
#line 938 
  mcdi = efx_mcdi(efx);
  
#line 941 
  if ((long)(mcdi->mode == (unsigned int)MCDI_MODE_EVENTS) != 0L) {
    
#line 943 
    ldv_inline_asm();
    
#line 941 
    ;
  }
  else ;
  
#line 943 
  ldv_del_timer_sync_120(& mcdi->async_timer);
  
#line 949 
  if (mcdi->state == (unsigned int)MCDI_STATE_RUNNING_ASYNC) {
    
#line 950 
    efx_mcdi_poll(efx);
    
#line 951 
    mcdi->state = MCDI_STATE_QUIESCENT;
  }
  else ;
  {
    
#line 959 
    struct list_head const *__mptr = (struct list_head const *)mcdi->async_list.next;
    
#line 959 
    tmp = (struct efx_mcdi_async_param *)__mptr;
  }
  
#line 959 
  async = tmp;
  {
    
#line 959 
    struct list_head const *__mptr_0 = (struct list_head const *)async->list.next;
    
#line 959 
    tmp_0 = (struct efx_mcdi_async_param *)__mptr_0;
  }
  
#line 960 
  next = tmp_0;
  
#line 959 
  goto ldv_56413;
  ldv_56412: 
#line 960 
  ;
  
#line 960 
  (*(async->complete))(efx,async->cookie,-100,(efx_dword_t *)0,0UL);
  
#line 961 
  list_del(& async->list);
  
#line 962 
  kfree((void const *)async);
  
#line 959 
  async = next;
  {
    
#line 959 
    struct list_head const *__mptr_1 = (struct list_head const *)next->list.next;
    
#line 959 
    tmp_1 = (struct efx_mcdi_async_param *)__mptr_1;
  }
  
#line 959 
  next = tmp_1;
  ldv_56413: 
#line 961 
  ;
  
#line 959 
  if (& async->list != & mcdi->async_list) 
#line 961 
                                           goto ldv_56412; else 
#line 964 
                                                                goto ldv_56414;
  ldv_56414: 
#line 965 
  ;
  return_label: 
#line 966 
                return;
}


#line 966  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
void efx_mcdi_mode_event(struct efx_nic *efx)
{
  struct efx_mcdi_iface *mcdi;
  
#line 970 
  if (efx->mcdi == (struct efx_mcdi_data *)0) 
#line 971 
                                              goto return_label; else ;
  
#line 973 
  mcdi = efx_mcdi(efx);
  
#line 978 
  if ((unsigned int)mcdi->mode + 4294967295U <= 1U) 
#line 979 
                                                    goto return_label; else ;
  
#line 988 
  efx_mcdi_acquire_sync(mcdi);
  
#line 989 
  mcdi->mode = MCDI_MODE_EVENTS;
  
#line 990 
  efx_mcdi_release(mcdi);
  return_label: 
#line 991 
                return;
}


#line 993  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static void efx_mcdi_ev_death(struct efx_nic *efx, int rc)
{
  bool tmp_1;
  
#line 995 
  struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
  
#line 1018 
  ldv_spin_lock_121(& mcdi->iface_lock);
  
#line 1019 
  tmp_1 = efx_mcdi_complete_sync(mcdi);
  
#line 1019 
  if ((int)tmp_1 != 0) {
    
#line 1020 
    if (mcdi->mode == (unsigned int)MCDI_MODE_EVENTS) {
      
#line 1021 
      mcdi->resprc = rc;
      
#line 1022 
      mcdi->resp_hdr_len = 0UL;
      
#line 1023 
      mcdi->resp_data_len = 0UL;
      
#line 1024 
      mcdi->credits += 1U;
    }
    else ;
  }
  else {
    int count;
    int tmp_0;
    
#line 1030 
    count = 0;
    
#line 1030 
    goto ldv_56427;
    ldv_56426: 
#line 1031 
    ;
    
#line 1031 
    tmp_0 = efx_mcdi_poll_reboot(efx);
    
#line 1031 
    if (tmp_0 != 0) 
#line 1032 
                    goto ldv_56425; else ;
    
#line 1033 
    __const_udelay(429500UL);
    
#line 1030 
    count += 1;
    ldv_56427: 
#line 1031 
    ;
    
#line 1030 
    if (count <= 2499) 
#line 1032 
                       goto ldv_56426; else 
#line 1035 
                                            goto ldv_56425;
    ldv_56425: 
#line 1036 
    ;
    
#line 1035 
    mcdi->new_epoch = (_Bool)1;
    
#line 1038 
    efx_schedule_reset(efx,(enum reset_type)RESET_TYPE_MC_FAILURE);
  }
  
#line 1041 
  ldv_spin_unlock_122(& mcdi->iface_lock);
  
#line 1042 
  return;
}


#line 1049  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static void efx_mcdi_ev_bist(struct efx_nic *efx)
{
  bool tmp_0;
  
#line 1051 
  struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
  
#line 1053 
  ldv_spin_lock_123(& mcdi->iface_lock);
  
#line 1054 
  efx->mc_bist_for_other_fn = (_Bool)1;
  
#line 1055 
  tmp_0 = efx_mcdi_complete_sync(mcdi);
  
#line 1055 
  if ((int)tmp_0 != 0) {
    
#line 1056 
    if (mcdi->mode == (unsigned int)MCDI_MODE_EVENTS) {
      
#line 1057 
      mcdi->resprc = -5;
      
#line 1058 
      mcdi->resp_hdr_len = 0UL;
      
#line 1059 
      mcdi->resp_data_len = 0UL;
      
#line 1060 
      mcdi->credits += 1U;
    }
    else ;
  }
  else ;
  
#line 1063 
  mcdi->new_epoch = (_Bool)1;
  
#line 1064 
  efx_schedule_reset(efx,(enum reset_type)RESET_TYPE_MC_BIST);
  
#line 1065 
  ldv_spin_unlock_124(& mcdi->iface_lock);
  
#line 1066 
  return;
}


#line 1071  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static void efx_mcdi_abandon(struct efx_nic *efx)
{
  enum efx_mcdi_mode tmp_0;
  
#line 1073 
  struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
  {
    
#line 1075 
    enum efx_mcdi_mode __ret = MCDI_MODE_FAIL;
    
#line 1075 
    switch (4UL) {
      case (unsigned long)1: 
#line 1075 
      ;
      
#line 1076 
      ldv_inline_asm();
      
#line 1075 
      goto ldv_56438;
      case (unsigned long)2: 
#line 1075 
      ;
      
#line 1076 
      ldv_inline_asm();
      
#line 1075 
      goto ldv_56438;
      case (unsigned long)4: 
#line 1075 
      ;
      
#line 1076 
      ldv_inline_asm();
      
#line 1075 
      goto ldv_56438;
      case (unsigned long)8: 
#line 1075 
      ;
      
#line 1076 
      ldv_inline_asm();
      
#line 1075 
      goto ldv_56438;
      default: 
#line 1075 
      ;
      
#line 1075 
      __xchg_wrong_size();
    }
    ldv_56438: 
#line 1075 
    ;
    
#line 1075 
    tmp_0 = __ret;
  }
  
#line 1075 
  if (tmp_0 == (unsigned int)MCDI_MODE_FAIL) 
#line 1076 
                                             goto return_label; else ;
  
#line 1077 
  if ((efx->msg_enable & 8192U) != 0U) {
    
#line 1077 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_mcdi_abandon", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c", .format = "MCDI is timing out; trying to recover\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1077U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1077 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1077 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"MCDI is timing out; trying to recover\n"); else ;
  }
  else ;
  
#line 1078 
  efx_schedule_reset(efx,(enum reset_type)RESET_TYPE_MCDI_TIMEOUT);
  return_label: 
#line 1079 
                return;
}


#line 1150 
void __compiletime_assert_1151(void);


#line 1082  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
void efx_mcdi_process_event(struct efx_channel *channel, efx_qword_t *event)
{
  
#line 1085 
  struct efx_nic *efx = channel->efx;
  
#line 1086 
  int code = (int)(event->u64[0] >> 44) & 255;
  
#line 1087 
  u32 data = (unsigned int)event->u64[0];
  
#line 1089 
  switch (code) {
    case 1: 
#line 1090 
    ;
    
#line 1091 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 1091 
                                         netdev_err((struct net_device const *)efx->net_dev,"MC watchdog or assertion failure at 0x%x\n",data); else ;
    
#line 1093 
    efx_mcdi_ev_death(efx,-4);
    
#line 1094 
    goto ldv_56454;
    case 2: 
#line 1096 
    ;
    
#line 1097 
    if ((efx->msg_enable & 16384U) != 0U) 
#line 1097 
                                          netdev_info((struct net_device const *)efx->net_dev,"MCDI PM event.\n"); else ;
    
#line 1098 
    goto ldv_56454;
    case 3: 
#line 1100 
    ;
    
#line 1101 
    efx_mcdi_ev_cpl(efx,(unsigned int)event->u64[0] & 255U,(unsigned int)(event->u64[0] >> 8) & 255U,(unsigned int)(event->u64[0] >> 16) & 255U);
    
#line 1105 
    goto ldv_56454;
    case 4: 
#line 1107 
    ;
    
#line 1108 
    efx_mcdi_process_link_change(efx,event);
    
#line 1109 
    goto ldv_56454;
    case 5: 
#line 1110 
    ;
    
#line 1111 
    efx_mcdi_sensor_event(efx,event);
    
#line 1112 
    goto ldv_56454;
    case 6: 
#line 1113 
    ;
    
#line 1114 
    if ((efx->msg_enable & 8192U) != 0U) {
      
#line 1114 
      struct _ddebug descriptor = {.modname = "sfc", .function = "efx_mcdi_process_event", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c", .format = "MC Scheduler alert (0x%x)\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1115U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1114 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1114 
                                                          __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"MC Scheduler alert (0x%x)\n",data); else ;
    }
    else ;
    
#line 1116 
    goto ldv_56454;
    case 7: 
#line 1117 
    ;
    case 21: 
#line 1118 
    ;
    
#line 1119 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 1119 
                                         netdev_info((struct net_device const *)efx->net_dev,"MC Reboot\n"); else ;
    
#line 1120 
    efx_mcdi_ev_death(efx,-5);
    
#line 1121 
    goto ldv_56454;
    case 25: 
#line 1122 
    ;
    
#line 1123 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 1123 
                                         netdev_info((struct net_device const *)efx->net_dev,"MC entered BIST mode\n"); else ;
    
#line 1124 
    efx_mcdi_ev_bist(efx);
    
#line 1125 
    goto ldv_56454;
    case 8: 
#line 1126 
    ;
    
#line 1128 
    goto ldv_56454;
    case 10: 
#line 1129 
    ;
    
#line 1130 
    if ((efx->type)->sriov_flr != (void (*)(struct efx_nic *, unsigned int ))0) 
      
#line 1131 
      (*((efx->type)->sriov_flr))(efx,(unsigned int)event->u64[0] & 255U); else ;
    
#line 1133 
    goto ldv_56454;
    case 13: 
#line 1134 
    ;
    case 14: 
#line 1135 
    ;
    case 15: 
#line 1136 
    ;
    
#line 1137 
    efx_ptp_event(efx,event);
    
#line 1138 
    goto ldv_56454;
    case 26: 
#line 1139 
    ;
    
#line 1140 
    efx_time_sync_event(channel,event);
    
#line 1141 
    goto ldv_56454;
    case 12: 
#line 1142 
    ;
    case 16: 
#line 1143 
    ;
    {
      
#line 1150 
      bool __cond = (_Bool)0;
      
#line 1150 
      if ((int)__cond != 0) 
#line 1150 
                            __compiletime_assert_1151(); else ;
    }
    
#line 1152 
    if ((event->u64[0] & 4096ULL) == 0ULL) 
#line 1153 
                                           efx_ef10_handle_drain_event(efx); else ;
    
#line 1154 
    goto ldv_56454;
    case 11: 
#line 1155 
    ;
    case 17: 
#line 1156 
    ;
    
#line 1157 
    if ((efx->msg_enable & 8192U) != 0U) {
      char *tmp;
      
#line 1157 
      ;
      
#line 1157 
      ;
      
#line 1157 
      if (code == 11) 
#line 1157 
                      tmp = (char *)"TX"; else 
#line 1157 
                                               tmp = (char *)"RX";
      
#line 1157 
      ;
      
#line 1157 
      netdev_err((struct net_device const *)efx->net_dev,"%s DMA error (event: ",tmp,event->u32[1],event->u32[0]);
    }
    else ;
    
#line 1161 
    efx_schedule_reset(efx,(enum reset_type)RESET_TYPE_DMA_ERROR);
    
#line 1162 
    goto ldv_56454;
    default: 
#line 1163 
    ;
    
#line 1164 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 1164 
                                         netdev_err((struct net_device const *)efx->net_dev,"Unknown MCDI event 0x%x\n",code); else ;
  }
  ldv_56454: 
#line 1167 
  ;
  
#line 1168 
  return;
}


#line 1184 
void __compiletime_assert_1184(void);


#line 1176  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
void efx_mcdi_print_fwver(struct efx_nic *efx, char *buf, size_t len)
{
  size_t outlength;
  __le16 const *ver_words;
  size_t offset;
  int rc;
  int tmp;
  int tmp_2;
  
#line 1178 
  efx_dword_t outbuf[8U] = {{.u32 = {0U}}};
  {
    
#line 1184 
    bool __cond = (_Bool)0;
    
#line 1184 
    if ((int)__cond != 0) 
#line 1184 
                          __compiletime_assert_1184(); else ;
  }
  
#line 1185 
  rc = efx_mcdi_rpc(efx,8U,(efx_dword_t const *)0,0UL,(efx_dword_t *)(& outbuf),32UL,& outlength);
  
#line 1187 
  if (rc != 0) 
#line 1188 
               goto fail; else ;
  
#line 1189 
  if (outlength <= 31UL) {
    
#line 1190 
    rc = -5;
    
#line 1191 
    goto fail;
  }
  else ;
  
#line 1194 
  ver_words = (__le16 const *)(& outbuf) + 24U;
  
#line 1195 
  tmp = snprintf(buf,len,"%u.%u.%u.%u",(int)*ver_words,(int)*(ver_words + 1U),(int)*(ver_words + 2U),(int)*(ver_words + 3U));
  
#line 1195 
  offset = (unsigned long)tmp;
  
#line 1202 
  tmp_2 = efx_nic_rev(efx);
  
#line 1202 
  if (tmp_2 > 3) {
    int tmp_0;
    int tmp_1;
    
#line 1203 
    struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
    
#line 1205 
    tmp_0 = snprintf(buf + offset,len - offset," rx%x tx%x",nic_data->rx_dpcpu_fw_id,nic_data->tx_dpcpu_fw_id);
    
#line 1207 
    offset = (unsigned long)tmp_0 + offset;
    {
      
#line 1213 
      int __ret_warn_on = offset >= len;
      
#line 1213 
      if ((long)(__ret_warn_on != 0) != 0L) 
#line 1213 
                                            warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c",1213); else ;
      
#line 1213 
      tmp_1 = (long)(__ret_warn_on != 0);
    }
    
#line 1213 
    if ((long)tmp_1 != 0L) 
#line 1214 
                           *buf = (char)0; else ;
  }
  else ;
  
#line 1217 
  goto return_label;
  fail: 
#line 1219 
  ;
  
#line 1220 
  if ((efx->msg_enable & 2U) != 0U) 
#line 1220 
                                    netdev_err((struct net_device const *)efx->net_dev,"%s: failed rc=%d\n","efx_mcdi_print_fwver",rc); else ;
  
#line 1221 
  *buf = (char)0;
  return_label: 
#line 1222 
                return;
}


#line 1224  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static int efx_mcdi_drv_attach(struct efx_nic *efx, bool driver_operating, bool *was_attached)
{
  int __retres;
  size_t outlen;
  int rc;
  
#line 1227 
  efx_dword_t inbuf[3U] = {{.u32 = {0U}}};
  
#line 1228 
  efx_dword_t outbuf[2U] = {{.u32 = {0U}}};
  
#line 1232 
  ((efx_dword_t *)(& inbuf))->u32[0] = (unsigned int)((int)driver_operating != 0);
  
#line 1234 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = 1U;
  
#line 1235 
  ((efx_dword_t *)(& inbuf) + 2U)->u32[0] = 1U;
  
#line 1237 
  rc = efx_mcdi_rpc_quiet(efx,28U,(efx_dword_t const *)(& inbuf),12UL,(efx_dword_t *)(& outbuf),8UL,& outlen);
  
#line 1243 
  if (rc == -1) {
    
#line 1244 
    if ((efx->msg_enable & 2U) != 0U) {
      
#line 1244 
      struct _ddebug descriptor = {.modname = "sfc", .function = "efx_mcdi_drv_attach", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c", .format = "efx_mcdi_drv_attach with fw-variant setting failed EPERM, trying without it\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1245U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1244 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1244 
                                                          __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"efx_mcdi_drv_attach with fw-variant setting failed EPERM, trying without it\n"); else ;
    }
    else ;
    
#line 1246 
    ((efx_dword_t *)(& inbuf) + 2U)->u32[0] = 4294967295U;
    
#line 1248 
    rc = efx_mcdi_rpc_quiet(efx,28U,(efx_dword_t const *)(& inbuf),12UL,(efx_dword_t *)(& outbuf),8UL,& outlen);
  }
  else ;
  
#line 1252 
  if (rc != 0) {
    
#line 1253 
    efx_mcdi_display_error(efx,28U,12UL,(efx_dword_t *)(& outbuf),outlen,rc);
    
#line 1255 
    goto fail;
  }
  else ;
  
#line 1257 
  if (outlen <= 3UL) {
    
#line 1258 
    rc = -5;
    
#line 1259 
    goto fail;
  }
  else ;
  
#line 1262 
  if ((int)driver_operating != 0) 
    
#line 1263 
    if (outlen > 7UL) 
#line 1264 
                      (efx->mcdi)->fn_flags = ((efx_dword_t *)(& outbuf) + 1U)->u32[0];
    else {
      int tmp_0;
      unsigned int tmp;
      
#line 1271 
      tmp = efx_port_num(efx);
      
#line 1271 
      if (tmp == 0U) 
#line 1271 
                     tmp_0 = 7; else 
#line 1271 
                                     tmp_0 = 6;
      
#line 1269 
      (efx->mcdi)->fn_flags = (unsigned int)tmp_0;
    }
  else ;
  
#line 1282 
  if (was_attached != (bool *)0) 
#line 1283 
                                 *was_attached = (_Bool)(((efx_dword_t *)(& outbuf))->u32[0] != 0U); else ;
  
#line 1284 
  __retres = 0;
  
#line 1284 
  goto return_label;
  fail: 
#line 1286 
  ;
  
#line 1287 
  if ((efx->msg_enable & 2U) != 0U) 
#line 1287 
                                    netdev_err((struct net_device const *)efx->net_dev,"%s: failed rc=%d\n","efx_mcdi_drv_attach",rc); else ;
  
#line 1288 
  __retres = rc;
  return_label: 
#line 1288 
                return __retres;
}


#line 1299 
void __compiletime_assert_1299(void);


#line 1301 
void __compiletime_assert_1301(void);


#line 1302 
void __compiletime_assert_1302(void);


#line 1291  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
int efx_mcdi_get_board_cfg(struct efx_nic *efx, u8 *mac_address, u16 *fw_subtype_list, u32 *capabilities)
{
  int __retres;
  size_t outlen;
  size_t i;
  unsigned int tmp;
  int rc;
  
#line 1294 
  efx_dword_t outbuf[34U] = {{.u32 = {0U}}};
  
#line 1296 
  tmp = efx_port_num(efx);
  
#line 1296 
  int port_num = (int)tmp;
  {
    
#line 1299 
    bool __cond = (_Bool)0;
    
#line 1299 
    if ((int)__cond != 0) 
#line 1299 
                          __compiletime_assert_1299(); else ;
  }
  {
    
#line 1301 
    bool __cond_0 = (_Bool)0;
    
#line 1301 
    if ((int)__cond_0 != 0) 
#line 1301 
                            __compiletime_assert_1301(); else ;
  }
  {
    
#line 1302 
    bool __cond_1 = (_Bool)0;
    
#line 1302 
    if ((int)__cond_1 != 0) 
#line 1302 
                            __compiletime_assert_1302(); else ;
  }
  
#line 1304 
  rc = efx_mcdi_rpc(efx,24U,(efx_dword_t const *)0,0UL,(efx_dword_t *)(& outbuf),136UL,& outlen);
  
#line 1306 
  if (rc != 0) 
#line 1307 
               goto fail; else ;
  
#line 1309 
  if (outlen <= 95UL) {
    
#line 1310 
    rc = -5;
    
#line 1311 
    goto fail;
  }
  else ;
  
#line 1314 
  if (mac_address != (u8 *)0U) {
    u8 *tmp_0;
    
#line 1317 
    if (port_num != 0) 
#line 1317 
                       tmp_0 = (u8 *)(& outbuf) + 50U; else 
#line 1317 
                                                            tmp_0 = (u8 *)(& outbuf) + 44U;
    
#line 1315 
    ;
    
#line 1315 
    ether_addr_copy(mac_address,(u8 const *)tmp_0);
  }
  else ;
  
#line 1319 
  if (fw_subtype_list != (u16 *)0U) {
    size_t tmp_2;
    
#line 1320 
    i = 0UL;
    
#line 1320 
    goto ldv_56572;
    ldv_56571: 
#line 1321 
    ;
    
#line 1324 
    *(fw_subtype_list + i) = *((__le16 const *)(& outbuf) + (i + (size_t)36U) * (size_t)2U);
    
#line 1323 
    i += 1UL;
    ldv_56572: 
#line 1324 
    ;
    {
      size_t tmp_1;
      
#line 1321 
      size_t __min1 = 32UL;
      
#line 1321 
      size_t __min2 = (outlen + 18446744073709551544UL) / 2UL;
      
#line 1321 
      if (__min1 < __min2) 
#line 1321 
                           tmp_1 = __min1; else 
#line 1321 
                                                tmp_1 = __min2;
      
#line 1321 
      tmp_2 = tmp_1;
    }
    
#line 1320 
    ;
    
#line 1320 
    if (tmp_2 > i) 
#line 1323 
                   goto ldv_56571; else 
#line 1326 
                                        goto ldv_56573;
    ldv_56573: 
#line 1327 
    ;
    
#line 1326 
    goto ldv_56575;
    ldv_56574: 
#line 1327 
    ;
    
#line 1327 
    *(fw_subtype_list + i) = (unsigned short)0U;
    
#line 1326 
    i += 1UL;
    ldv_56575: 
#line 1327 
    ;
    
#line 1326 
    if (i <= 31UL) 
#line 1328 
                   goto ldv_56574; else 
#line 1331 
                                        goto ldv_56576;
    ldv_56576: 
#line 1332 
    ;
  }
  else ;
  
#line 1329 
  if (capabilities != (u32 *)0U) 
    
#line 1330 
    if (port_num != 0) 
#line 1331 
                       *capabilities = ((efx_dword_t *)(& outbuf) + 10U)->u32[0]; else 
                                                                    
#line 1334 
                                                                    *capabilities = ((efx_dword_t *)(& outbuf) + 9U)->u32[0];
  else ;
  
#line 1338 
  __retres = 0;
  
#line 1338 
  goto return_label;
  fail: 
#line 1340 
  ;
  
#line 1341 
  if ((efx->msg_enable & 8192U) != 0U) 
#line 1341 
                                       netdev_err((struct net_device const *)efx->net_dev,"%s: failed rc=%d len=%d\n","efx_mcdi_get_board_cfg",rc,(int)outlen); else ;
  
#line 1344 
  __retres = rc;
  return_label: 
#line 1344 
                return __retres;
}


#line 1361 
void __compiletime_assert_1361(void);


#line 1347  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
int efx_mcdi_log_ctrl(struct efx_nic *efx, bool evq, bool uart, u32 dest_evq)
{
  int rc;
  
#line 1349 
  efx_dword_t inbuf[2U] = {{.u32 = {0U}}};
  
#line 1350 
  u32 dest = 0U;
  
#line 1353 
  if ((int)uart != 0) 
#line 1354 
                      dest |= 1U; else ;
  
#line 1355 
  if ((int)evq != 0) 
#line 1356 
                     dest |= 2U; else ;
  
#line 1358 
  ((efx_dword_t *)(& inbuf))->u32[0] = dest;
  
#line 1359 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = dest_evq;
  {
    
#line 1361 
    bool __cond = (_Bool)0;
    
#line 1361 
    if ((int)__cond != 0) 
#line 1361 
                          __compiletime_assert_1361(); else ;
  }
  
#line 1363 
  rc = efx_mcdi_rpc(efx,7U,(efx_dword_t const *)(& inbuf),8UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 1365 
  return rc;
}


#line 1374 
void __compiletime_assert_1374(void);


#line 1368  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
int efx_mcdi_nvram_types(struct efx_nic *efx, u32 *nvram_types_out)
{
  int __retres;
  size_t outlen;
  int rc;
  
#line 1370 
  efx_dword_t outbuf[1U] = {{.u32 = {0U}}};
  {
    
#line 1374 
    bool __cond = (_Bool)0;
    
#line 1374 
    if ((int)__cond != 0) 
#line 1374 
                          __compiletime_assert_1374(); else ;
  }
  
#line 1376 
  rc = efx_mcdi_rpc(efx,54U,(efx_dword_t const *)0,0UL,(efx_dword_t *)(& outbuf),4UL,& outlen);
  
#line 1378 
  if (rc != 0) 
#line 1379 
               goto fail; else ;
  
#line 1380 
  if (outlen <= 3UL) {
    
#line 1381 
    rc = -5;
    
#line 1382 
    goto fail;
  }
  else ;
  
#line 1385 
  *nvram_types_out = ((efx_dword_t *)(& outbuf))->u32[0];
  
#line 1386 
  __retres = 0;
  
#line 1386 
  goto return_label;
  fail: 
#line 1388 
  ;
  
#line 1389 
  if ((efx->msg_enable & 8192U) != 0U) 
#line 1389 
                                       netdev_err((struct net_device const *)efx->net_dev,"%s: failed rc=%d\n","efx_mcdi_nvram_types",rc); else ;
  
#line 1391 
  __retres = rc;
  return_label: 
#line 1391 
                return __retres;
}


#line 1394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
int efx_mcdi_nvram_info(struct efx_nic *efx, unsigned int type, size_t *size_out, size_t *erase_size_out, bool *protected_out)
{
  int __retres;
  size_t outlen;
  int rc;
  
#line 1398 
  efx_dword_t inbuf[1U] = {{.u32 = {0U}}};
  
#line 1399 
  efx_dword_t outbuf[6U] = {{.u32 = {0U}}};
  
#line 1403 
  ((efx_dword_t *)(& inbuf))->u32[0] = type;
  
#line 1405 
  rc = efx_mcdi_rpc(efx,55U,(efx_dword_t const *)(& inbuf),4UL,(efx_dword_t *)(& outbuf),24UL,& outlen);
  
#line 1407 
  if (rc != 0) 
#line 1408 
               goto fail; else ;
  
#line 1409 
  if (outlen <= 23UL) {
    
#line 1410 
    rc = -5;
    
#line 1411 
    goto fail;
  }
  else ;
  
#line 1414 
  *size_out = (unsigned long)((efx_dword_t *)(& outbuf) + 1U)->u32[0];
  
#line 1415 
  *erase_size_out = (unsigned long)((efx_dword_t *)(& outbuf) + 2U)->u32[0];
  
#line 1416 
  *protected_out = (_Bool)((((efx_dword_t *)(& outbuf) + 3U)->u32[0] & 1U) != 0U);
  
#line 1418 
  __retres = 0;
  
#line 1418 
  goto return_label;
  fail: 
#line 1420 
  ;
  
#line 1421 
  if ((efx->msg_enable & 8192U) != 0U) 
#line 1421 
                                       netdev_err((struct net_device const *)efx->net_dev,"%s: failed rc=%d\n","efx_mcdi_nvram_info",rc); else ;
  
#line 1422 
  __retres = rc;
  return_label: 
#line 1422 
                return __retres;
}


#line 1425  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static int efx_mcdi_nvram_test(struct efx_nic *efx, unsigned int type)
{
  int __retres;
  int rc;
  
#line 1427 
  efx_dword_t inbuf[1U] = {{.u32 = {0U}}};
  
#line 1428 
  efx_dword_t outbuf[1U] = {{.u32 = {0U}}};
  
#line 1431 
  ((efx_dword_t *)(& inbuf))->u32[0] = type;
  
#line 1433 
  rc = efx_mcdi_rpc(efx,76U,(efx_dword_t const *)(& inbuf),4UL,(efx_dword_t *)(& outbuf),4UL,(size_t *)0UL);
  
#line 1435 
  if (rc != 0) {
    
#line 1436 
    __retres = rc;
    
#line 1436 
    goto return_label;
  }
  else ;
  
#line 1438 
  switch (((efx_dword_t *)(& outbuf))->u32[0]) {
    case (__le32)0: 
#line 1439 
    ;
    case (__le32)2: 
#line 1440 
    ;
    
#line 1441 
    __retres = 0;
    
#line 1441 
    goto return_label;
    default: 
#line 1442 
    ;
    
#line 1443 
    __retres = -5;
    
#line 1443 
    goto return_label;
  }
  return_label: 
#line 1438 
                return __retres;
}


#line 1447  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
int efx_mcdi_nvram_test_all(struct efx_nic *efx)
{
  int __retres;
  u32 nvram_types;
  unsigned int type;
  int rc;
  
#line 1453 
  rc = efx_mcdi_nvram_types(efx,& nvram_types);
  
#line 1454 
  if (rc != 0) 
#line 1455 
               goto fail1; else ;
  
#line 1457 
  type = 0U;
  
#line 1458 
  goto ldv_56690;
  ldv_56689: 
#line 1459 
  ;
  
#line 1459 
  if ((nvram_types & 1U) != 0U) {
    
#line 1460 
    rc = efx_mcdi_nvram_test(efx,type);
    
#line 1461 
    if (rc != 0) 
#line 1462 
                 goto fail2; else ;
  }
  else ;
  
#line 1464 
  type += 1U;
  
#line 1465 
  nvram_types >>= 1;
  ldv_56690: 
#line 1466 
  ;
  
#line 1458 
  if (nvram_types != 0U) 
#line 1460 
                         goto ldv_56689; else 
#line 1463 
                                              goto ldv_56691;
  ldv_56691: 
#line 1464 
  ;
  
#line 1468 
  __retres = 0;
  
#line 1468 
  goto return_label;
  fail2: 
#line 1470 
  ;
  
#line 1471 
  if ((efx->msg_enable & 8192U) != 0U) 
#line 1471 
                                       netdev_err((struct net_device const *)efx->net_dev,"%s: failed type=%u\n","efx_mcdi_nvram_test_all",type); else ;
  fail1: 
#line 1473 
  ;
  
#line 1474 
  if ((efx->msg_enable & 8192U) != 0U) 
#line 1474 
                                       netdev_err((struct net_device const *)efx->net_dev,"%s: failed rc=%d\n","efx_mcdi_nvram_test_all",rc); else ;
  
#line 1475 
  __retres = rc;
  return_label: 
#line 1475 
                return __retres;
}


#line 1481  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static int efx_mcdi_read_assertion(struct efx_nic *efx)
{
  int __retres;
  unsigned int flags;
  unsigned int index;
  char const *reason;
  size_t outlen;
  int retry;
  int rc;
  char *tmp_2;
  
#line 1483 
  efx_dword_t inbuf[1U] = {{.u32 = {0U}}};
  
#line 1484 
  efx_dword_t outbuf[35U] = {{.u32 = {0U}}};
  
#line 1496 
  retry = 2;
  ldv_56707: 
#line 1497 
  ;
  
#line 1498 
  ((efx_dword_t *)(& inbuf))->u32[0] = 1U;
  
#line 1499 
  rc = efx_mcdi_rpc_quiet(efx,6U,(efx_dword_t const *)(& inbuf),4UL,(efx_dword_t *)(& outbuf),140UL,& outlen);
  
#line 1502 
  if (rc == -1) {
    
#line 1503 
    __retres = 0;
    
#line 1503 
    goto return_label;
  }
  else ;
  
#line 1504 
  if ((unsigned int)rc + 5U <= 1U) {
    int tmp;
    
#line 1504 
    tmp = retry;
    
#line 1504 
    retry -= 1;
    
#line 1504 
    ;
    
#line 1504 
    if (tmp > 0) 
#line 1506 
                 goto ldv_56707; else 
#line 1509 
                                      goto ldv_56708;
  }
  else 
#line 1509 
       goto ldv_56708;
  ldv_56708: 
#line 1510 
  ;
  
#line 1506 
  if (rc != 0) {
    
#line 1507 
    efx_mcdi_display_error(efx,6U,4UL,(efx_dword_t *)(& outbuf),outlen,rc);
    
#line 1510 
    __retres = rc;
    
#line 1510 
    goto return_label;
  }
  else ;
  
#line 1512 
  if (outlen <= 139UL) {
    
#line 1513 
    __retres = -5;
    
#line 1513 
    goto return_label;
  }
  else ;
  
#line 1516 
  flags = ((efx_dword_t *)(& outbuf))->u32[0];
  
#line 1517 
  if (flags == 1U) {
    
#line 1518 
    __retres = 0;
    
#line 1518 
    goto return_label;
  }
  else ;
  
#line 1522 
  if (flags != 2U) {
    char *tmp_1;
    
#line 1520 
    if (flags != 3U) {
      char *tmp_0;
      
#line 1522 
      if (flags == 4U) 
#line 1522 
                       tmp_0 = (char *)"watchdog reset"; else 
#line 1522 
                                                              tmp_0 = (char *)"unknown assertion";
      
#line 1520 
      tmp_1 = tmp_0;
    }
    else 
#line 1520 
         tmp_1 = (char *)"thread-level assertion";
    
#line 1522 
    tmp_2 = tmp_1;
  }
  else 
#line 1522 
       tmp_2 = (char *)"system-level assertion";
  
#line 1520 
  reason = (char const *)tmp_2;
  
#line 1527 
  if ((efx->msg_enable & 8192U) != 0U) 
#line 1527 
                                       netdev_err((struct net_device const *)efx->net_dev,"MCPU %s at PC = 0x%.8x in thread 0x%.8x\n",reason,((efx_dword_t *)(& outbuf) + 1U)->u32[0],((efx_dword_t *)(& outbuf) + 33U)->u32[0]); else ;
  
#line 1533 
  index = 0U;
  
#line 1533 
  goto ldv_56746;
  ldv_56745: 
#line 1534 
  ;
  
#line 1536 
  if ((efx->msg_enable & 8192U) != 0U) 
#line 1536 
                                       netdev_err((struct net_device const *)efx->net_dev,"R%.2d (?): 0x%.8x\n",index + 1U,((efx_dword_t *)(& outbuf) + (index + 2U) * 4U)->u32[0]); else ;
  
#line 1535 
  index += 1U;
  ldv_56746: 
#line 1536 
  ;
  
#line 1533 
  if (index <= 30U) 
#line 1536 
                    goto ldv_56745; else 
#line 1539 
                                         goto ldv_56747;
  ldv_56747: 
#line 1540 
  ;
  
#line 1541 
  __retres = 1;
  return_label: 
#line 1541 
                return __retres;
}


#line 1555 
void __compiletime_assert_1555(void);


#line 1544  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static int efx_mcdi_exit_assertion(struct efx_nic *efx)
{
  int rc;
  
#line 1546 
  efx_dword_t inbuf[1U] = {{.u32 = {0U}}};
  {
    
#line 1555 
    bool __cond = (_Bool)0;
    
#line 1555 
    if ((int)__cond != 0) 
#line 1555 
                          __compiletime_assert_1555(); else ;
  }
  
#line 1556 
  ((efx_dword_t *)(& inbuf))->u32[0] = 1U;
  
#line 1558 
  rc = efx_mcdi_rpc_quiet(efx,61U,(efx_dword_t const *)(& inbuf),4UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 1560 
  if (rc == -5) 
#line 1561 
                rc = 0; else ;
  
#line 1562 
  if (rc != 0) 
#line 1563 
               efx_mcdi_display_error(efx,61U,4UL,(efx_dword_t *)0,0UL,rc); else ;
  
#line 1565 
  return rc;
}


#line 1568  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
int efx_mcdi_handle_assertion(struct efx_nic *efx)
{
  int __retres;
  int rc;
  int tmp;
  
#line 1572 
  rc = efx_mcdi_read_assertion(efx);
  
#line 1573 
  if (rc <= 0) {
    
#line 1574 
    __retres = rc;
    
#line 1574 
    goto return_label;
  }
  else ;
  
#line 1576 
  tmp = efx_mcdi_exit_assertion(efx);
  
#line 1576 
  __retres = tmp;
  return_label: 
#line 1576 
                return __retres;
}


#line 1584 
void __compiletime_assert_1584(void);


#line 1585 
void __compiletime_assert_1585(void);


#line 1586 
void __compiletime_assert_1586(void);


#line 1588 
void __compiletime_assert_1588(void);


#line 1579  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
void efx_mcdi_set_id_led(struct efx_nic *efx, enum efx_led_mode mode)
{
  int rc;
  
#line 1581 
  efx_dword_t inbuf[1U] = {{.u32 = {0U}}};
  {
    
#line 1584 
    bool __cond = (_Bool)0;
    
#line 1584 
    if ((int)__cond != 0) 
#line 1584 
                          __compiletime_assert_1584(); else ;
  }
  {
    
#line 1585 
    bool __cond_0 = (_Bool)0;
    
#line 1585 
    if ((int)__cond_0 != 0) 
#line 1585 
                            __compiletime_assert_1585(); else ;
  }
  {
    
#line 1586 
    bool __cond_1 = (_Bool)0;
    
#line 1586 
    if ((int)__cond_1 != 0) 
#line 1586 
                            __compiletime_assert_1586(); else ;
  }
  {
    
#line 1588 
    bool __cond_2 = (_Bool)0;
    
#line 1588 
    if ((int)__cond_2 != 0) 
#line 1588 
                            __compiletime_assert_1588(); else ;
  }
  
#line 1590 
  ((efx_dword_t *)(& inbuf))->u32[0] = (unsigned int)mode;
  
#line 1592 
  rc = efx_mcdi_rpc(efx,43U,(efx_dword_t const *)(& inbuf),4UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 1593 
  return;
}


#line 1601 
void __compiletime_assert_1601(void);


#line 1596  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static int efx_mcdi_reset_func(struct efx_nic *efx)
{
  int rc;
  
#line 1598 
  efx_dword_t inbuf[1U] = {{.u32 = {0U}}};
  {
    
#line 1601 
    bool __cond = (_Bool)0;
    
#line 1601 
    if ((int)__cond != 0) 
#line 1601 
                          __compiletime_assert_1601(); else ;
  }
  
#line 1602 
  ((efx_dword_t *)(& inbuf))->u32[0] = 1U;
  
#line 1604 
  rc = efx_mcdi_rpc(efx,32U,(efx_dword_t const *)(& inbuf),4UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 1606 
  return rc;
}


#line 1614 
void __compiletime_assert_1614(void);


#line 1609  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static int efx_mcdi_reset_mc(struct efx_nic *efx)
{
  int __retres;
  int rc;
  
#line 1611 
  efx_dword_t inbuf[1U] = {{.u32 = {0U}}};
  {
    
#line 1614 
    bool __cond = (_Bool)0;
    
#line 1614 
    if ((int)__cond != 0) 
#line 1614 
                          __compiletime_assert_1614(); else ;
  }
  
#line 1615 
  ((efx_dword_t *)(& inbuf))->u32[0] = 0U;
  
#line 1616 
  rc = efx_mcdi_rpc(efx,61U,(efx_dword_t const *)(& inbuf),4UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 1619 
  if (rc == -5) {
    
#line 1620 
    __retres = 0;
    
#line 1620 
    goto return_label;
  }
  else ;
  
#line 1621 
  if (rc == 0) 
#line 1622 
               rc = -5; else ;
  
#line 1623 
  __retres = rc;
  return_label: 
#line 1623 
                return __retres;
}


#line 1626  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
enum reset_type efx_mcdi_map_reset_reason(enum reset_type reason)
{
  enum reset_type __retres;
  
#line 1628 
  __retres = RESET_TYPE_RECOVER_OR_ALL;
  
#line 1628 
  return __retres;
}


#line 1631  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
int efx_mcdi_reset(struct efx_nic *efx, enum reset_type method)
{
  int __retres;
  int rc;
  
#line 1636 
  if (method == (unsigned int)RESET_TYPE_MCDI_TIMEOUT) {
    
#line 1637 
    rc = pci_reset_function(efx->pci_dev);
    
#line 1638 
    if (rc != 0) {
      
#line 1639 
      __retres = rc;
      
#line 1639 
      goto return_label;
    }
    else ;
    
#line 1641 
    if (efx->mcdi != (struct efx_mcdi_data *)0) {
      
#line 1642 
      struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
      
#line 1643 
      mcdi->mode = MCDI_MODE_POLL;
    }
    else ;
    
#line 1645 
    __retres = 0;
    
#line 1645 
    goto return_label;
  }
  else ;
  
#line 1649 
  rc = efx_mcdi_handle_assertion(efx);
  
#line 1650 
  if (rc != 0) {
    
#line 1651 
    __retres = rc;
    
#line 1651 
    goto return_label;
  }
  else ;
  
#line 1653 
  if (method == (unsigned int)RESET_TYPE_DATAPATH) {
    
#line 1654 
    __retres = 0;
    
#line 1654 
    goto return_label;
  }
  else 
    
#line 1655 
    if (method == (unsigned int)RESET_TYPE_WORLD) {
      int tmp_0;
      
#line 1656 
      tmp_0 = efx_mcdi_reset_mc(efx);
      
#line 1656 
      __retres = tmp_0;
      
#line 1656 
      goto return_label;
    }
    else {
      int tmp_1;
      
#line 1658 
      tmp_1 = efx_mcdi_reset_func(efx);
      
#line 1658 
      __retres = tmp_1;
      
#line 1658 
      goto return_label;
    }
  return_label: 
#line 1653 
                return __retres;
}


#line 1661  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static int efx_mcdi_wol_filter_set(struct efx_nic *efx, u32 type, u8 const *mac, int *id_out)
{
  int __retres;
  size_t outlen;
  int rc;
  
#line 1664 
  efx_dword_t inbuf[48U] = {{.u32 = {0U}}};
  
#line 1665 
  efx_dword_t outbuf[1U] = {{.u32 = {0U}}};
  
#line 1669 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = type;
  
#line 1670 
  ((efx_dword_t *)(& inbuf))->u32[0] = 0U;
  
#line 1672 
  ether_addr_copy((u8 *)(& inbuf) + 8U,mac);
  
#line 1674 
  rc = efx_mcdi_rpc(efx,50U,(efx_dword_t const *)(& inbuf),192UL,(efx_dword_t *)(& outbuf),4UL,& outlen);
  
#line 1676 
  if (rc != 0) 
#line 1677 
               goto fail; else ;
  
#line 1679 
  if (outlen <= 3UL) {
    
#line 1680 
    rc = -5;
    
#line 1681 
    goto fail;
  }
  else ;
  
#line 1684 
  *id_out = (int)((efx_dword_t *)(& outbuf))->u32[0];
  
#line 1686 
  __retres = 0;
  
#line 1686 
  goto return_label;
  fail: 
#line 1688 
  ;
  
#line 1689 
  *id_out = -1;
  
#line 1690 
  if ((efx->msg_enable & 8192U) != 0U) 
#line 1690 
                                       netdev_err((struct net_device const *)efx->net_dev,"%s: failed rc=%d\n","efx_mcdi_wol_filter_set",rc); else ;
  
#line 1691 
  __retres = rc;
  return_label: 
#line 1691 
                return __retres;
}


#line 1697  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
int efx_mcdi_wol_filter_set_magic(struct efx_nic *efx, u8 const *mac, int *id_out)
{
  int tmp;
  
#line 1699 
  tmp = efx_mcdi_wol_filter_set(efx,0U,mac,id_out);
  
#line 1699 
  return tmp;
}


#line 1703  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
int efx_mcdi_wol_filter_get_magic(struct efx_nic *efx, int *id_out)
{
  int __retres;
  size_t outlen;
  int rc;
  
#line 1705 
  efx_dword_t outbuf[1U] = {{.u32 = {0U}}};
  
#line 1709 
  rc = efx_mcdi_rpc(efx,69U,(efx_dword_t const *)0,0UL,(efx_dword_t *)(& outbuf),4UL,& outlen);
  
#line 1711 
  if (rc != 0) 
#line 1712 
               goto fail; else ;
  
#line 1714 
  if (outlen <= 3UL) {
    
#line 1715 
    rc = -5;
    
#line 1716 
    goto fail;
  }
  else ;
  
#line 1719 
  *id_out = (int)((efx_dword_t *)(& outbuf))->u32[0];
  
#line 1721 
  __retres = 0;
  
#line 1721 
  goto return_label;
  fail: 
#line 1723 
  ;
  
#line 1724 
  *id_out = -1;
  
#line 1725 
  if ((efx->msg_enable & 8192U) != 0U) 
#line 1725 
                                       netdev_err((struct net_device const *)efx->net_dev,"%s: failed rc=%d\n","efx_mcdi_wol_filter_get_magic",rc); else ;
  
#line 1726 
  __retres = rc;
  return_label: 
#line 1726 
                return __retres;
}


#line 1730  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
int efx_mcdi_wol_filter_remove(struct efx_nic *efx, int id)
{
  int rc;
  
#line 1732 
  efx_dword_t inbuf[1U] = {{.u32 = {0U}}};
  
#line 1735 
  ((efx_dword_t *)(& inbuf))->u32[0] = (unsigned int)id;
  
#line 1737 
  rc = efx_mcdi_rpc(efx,51U,(efx_dword_t const *)(& inbuf),4UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 1739 
  return rc;
}


#line 1750 
void __compiletime_assert_1751(void);


#line 1742  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
int efx_mcdi_flush_rxqs(struct efx_nic *efx)
{
  struct efx_channel *channel;
  struct efx_rx_queue *rx_queue;
  int rc;
  int count;
  int tmp_1;
  bool tmp_0;
  
#line 1746 
  efx_dword_t inbuf[32U] = {{.u32 = {0U}}};
  {
    
#line 1750 
    bool __cond = (_Bool)0;
    
#line 1750 
    if ((int)__cond != 0) 
#line 1750 
                          __compiletime_assert_1751(); else ;
  }
  
#line 1753 
  count = 0;
  
#line 1754 
  channel = efx->channel[0];
  
#line 1754 
  goto ldv_56909;
  ldv_56908: 
#line 1755 
  ;
  
#line 1755 
  tmp_0 = efx_channel_has_rx_queue(channel);
  
#line 1755 
  if (tmp_0) 
#line 1755 
             tmp_1 = 0; else 
#line 1755 
                             tmp_1 = 1;
  
#line 1755 
  if (tmp_1) ;
  else {
    
#line 1755 
    rx_queue = & channel->rx_queue;
    
#line 1755 
    goto ldv_56906;
    ldv_56905: 
#line 1756 
    ;
    
#line 1756 
    if ((int)rx_queue->flush_pending != 0) {
      
#line 1757 
      rx_queue->flush_pending = (_Bool)0;
      
#line 1758 
      atomic_dec_0(& efx->rxq_flush_pending);
      {
        int tmp;
        
#line 1759 
        tmp = efx_rx_queue_index(rx_queue);
        
#line 1759 
        ((efx_dword_t *)(& inbuf) + (unsigned long)count * 4UL)->u32[0] = (unsigned int)tmp;
      }
      
#line 1762 
      count += 1;
    }
    else ;
    
#line 1755 
    rx_queue = (struct efx_rx_queue *)0;
    ldv_56906: 
#line 1756 
    ;
    
#line 1755 
    if (rx_queue != (struct efx_rx_queue *)0) 
#line 1757 
                                              goto ldv_56905; else 
#line 1760 
                                                                   goto ldv_56907;
    ldv_56907: 
#line 1761 
    ;
  }
  
#line 1754 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 1754 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 1754 
                                                                    channel = (struct efx_channel *)0;
  ldv_56909: 
#line 1755 
  ;
  
#line 1754 
  if (channel != (struct efx_channel *)0) 
#line 1756 
                                          goto ldv_56908; else 
#line 1759 
                                                               goto ldv_56910;
  ldv_56910: 
#line 1760 
  ;
  
#line 1767 
  rc = efx_mcdi_rpc(efx,39U,(efx_dword_t const *)(& inbuf),(unsigned long)(count * 4),(efx_dword_t *)0,0UL,(size_t *)0UL);
  {
    
#line 1769 
    int __ret_warn_on = rc < 0;
    
#line 1769 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 1769 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c",1769); else ;
    
#line 1769 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 1771 
  return rc;
}


#line 1774  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
int efx_mcdi_wol_filter_reset(struct efx_nic *efx)
{
  int rc;
  
#line 1778 
  rc = efx_mcdi_rpc(efx,52U,(efx_dword_t const *)0,0UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 1779 
  return rc;
}


#line 1786 
void __compiletime_assert_1786(void);


#line 1782  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
int efx_mcdi_set_workaround(struct efx_nic *efx, u32 type, bool enabled)
{
  int tmp;
  
#line 1784 
  efx_dword_t inbuf[2U] = {{.u32 = {0U}}};
  {
    
#line 1786 
    bool __cond = (_Bool)0;
    
#line 1786 
    if ((int)__cond != 0) 
#line 1786 
                          __compiletime_assert_1786(); else ;
  }
  
#line 1787 
  ((efx_dword_t *)(& inbuf))->u32[0] = type;
  
#line 1788 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = (unsigned int)enabled;
  
#line 1789 
  tmp = efx_mcdi_rpc(efx,74U,(efx_dword_t const *)(& inbuf),8UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 1789 
  return tmp;
}


#line 1793  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
int efx_mcdi_get_workarounds(struct efx_nic *efx, unsigned int *impl_out, unsigned int *enabled_out)
{
  int __retres;
  size_t outlen;
  int rc;
  
#line 1796 
  efx_dword_t outbuf[2U] = {{.u32 = {0U}}};
  
#line 1800 
  rc = efx_mcdi_rpc(efx,89U,(efx_dword_t const *)0,0UL,(efx_dword_t *)(& outbuf),8UL,& outlen);
  
#line 1802 
  if (rc != 0) 
#line 1803 
               goto fail; else ;
  
#line 1805 
  if (outlen <= 7UL) {
    
#line 1806 
    rc = -5;
    
#line 1807 
    goto fail;
  }
  else ;
  
#line 1810 
  if (impl_out != (unsigned int *)0U) 
#line 1811 
                                      *impl_out = ((efx_dword_t *)(& outbuf))->u32[0]; else ;
  
#line 1813 
  if (enabled_out != (unsigned int *)0U) 
#line 1814 
                                         *enabled_out = ((efx_dword_t *)(& outbuf) + 1U)->u32[0]; else ;
  
#line 1816 
  __retres = 0;
  
#line 1816 
  goto return_label;
  fail: 
#line 1818 
  ;
  
#line 1819 
  if ((efx->msg_enable & 8192U) != 0U) 
#line 1819 
                                       netdev_err((struct net_device const *)efx->net_dev,"%s: failed rc=%d\n","efx_mcdi_get_workarounds",rc); else ;
  
#line 1820 
  __retres = rc;
  return_label: 
#line 1820 
                return __retres;
}


#line 1834 
void __compiletime_assert_1834(void);


#line 1827  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static int efx_mcdi_nvram_update_start(struct efx_nic *efx, unsigned int type)
{
  int rc;
  
#line 1829 
  efx_dword_t inbuf[1U] = {{.u32 = {0U}}};
  
#line 1832 
  ((efx_dword_t *)(& inbuf))->u32[0] = type;
  {
    
#line 1834 
    bool __cond = (_Bool)0;
    
#line 1834 
    if ((int)__cond != 0) 
#line 1834 
                          __compiletime_assert_1834(); else ;
  }
  
#line 1836 
  rc = efx_mcdi_rpc(efx,56U,(efx_dword_t const *)(& inbuf),4UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 1838 
  return rc;
}


#line 1841  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static int efx_mcdi_nvram_read(struct efx_nic *efx, unsigned int type, loff_t offset, u8 *buffer, size_t length)
{
  int __retres;
  size_t outlen;
  int rc;
  
#line 1844 
  efx_dword_t inbuf[3U] = {{.u32 = {0U}}};
  
#line 1845 
  efx_dword_t outbuf[32U] = {{.u32 = {0U}}};
  
#line 1850 
  ((efx_dword_t *)(& inbuf))->u32[0] = type;
  
#line 1851 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = (unsigned int)offset;
  
#line 1852 
  ((efx_dword_t *)(& inbuf) + 2U)->u32[0] = (unsigned int)length;
  
#line 1854 
  rc = efx_mcdi_rpc(efx,57U,(efx_dword_t const *)(& inbuf),12UL,(efx_dword_t *)(& outbuf),128UL,& outlen);
  
#line 1856 
  if (rc != 0) {
    
#line 1857 
    __retres = rc;
    
#line 1857 
    goto return_label;
  }
  else ;
  
#line 1859 
  memcpy((void *)buffer,(void const *)(& outbuf),length);
  
#line 1860 
  __retres = 0;
  return_label: 
#line 1860 
                return __retres;
}


#line 1875 
void __compiletime_assert_1875(void);


#line 1863  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static int efx_mcdi_nvram_write(struct efx_nic *efx, unsigned int type, loff_t offset, u8 const *buffer, size_t length)
{
  int rc;
  
#line 1866 
  efx_dword_t inbuf[35U] = {{.u32 = {0U}}};
  
#line 1870 
  ((efx_dword_t *)(& inbuf))->u32[0] = type;
  
#line 1871 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = (unsigned int)offset;
  
#line 1872 
  ((efx_dword_t *)(& inbuf) + 2U)->u32[0] = (unsigned int)length;
  
#line 1873 
  memcpy((void *)(& inbuf) + 12U,(void const *)buffer,length);
  {
    
#line 1875 
    bool __cond = (_Bool)0;
    
#line 1875 
    if ((int)__cond != 0) 
#line 1875 
                          __compiletime_assert_1875(); else ;
  }
  
#line 1877 
  rc = efx_mcdi_rpc(efx,58U,(efx_dword_t const *)(& inbuf),(length + 15UL) & 18446744073709551612UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 1880 
  return rc;
}


#line 1893 
void __compiletime_assert_1893(void);


#line 1883  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static int efx_mcdi_nvram_erase(struct efx_nic *efx, unsigned int type, loff_t offset, size_t length)
{
  int rc;
  
#line 1886 
  efx_dword_t inbuf[3U] = {{.u32 = {0U}}};
  
#line 1889 
  ((efx_dword_t *)(& inbuf))->u32[0] = type;
  
#line 1890 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = (unsigned int)offset;
  
#line 1891 
  ((efx_dword_t *)(& inbuf) + 2U)->u32[0] = (unsigned int)length;
  {
    
#line 1893 
    bool __cond = (_Bool)0;
    
#line 1893 
    if ((int)__cond != 0) 
#line 1893 
                          __compiletime_assert_1893(); else ;
  }
  
#line 1895 
  rc = efx_mcdi_rpc(efx,59U,(efx_dword_t const *)(& inbuf),12UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 1897 
  return rc;
}


#line 1907 
void __compiletime_assert_1907(void);


#line 1900  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
static int efx_mcdi_nvram_update_finish(struct efx_nic *efx, unsigned int type)
{
  int rc;
  
#line 1902 
  efx_dword_t inbuf[2U] = {{.u32 = {0U}}};
  
#line 1905 
  ((efx_dword_t *)(& inbuf))->u32[0] = type;
  {
    
#line 1907 
    bool __cond = (_Bool)0;
    
#line 1907 
    if ((int)__cond != 0) 
#line 1907 
                          __compiletime_assert_1907(); else ;
  }
  
#line 1909 
  rc = efx_mcdi_rpc(efx,60U,(efx_dword_t const *)(& inbuf),8UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 1911 
  return rc;
}


#line 1914  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
int efx_mcdi_mtd_read(struct mtd_info *mtd, loff_t start, size_t len, size_t *retlen, u8 *buffer)
{
  struct efx_mcdi_mtd_partition *tmp;
  loff_t tmp_1;
  size_t chunk;
  size_t tmp_3;
  {
    
#line 1917 
    struct mtd_info const *__mptr = (struct mtd_info const *)mtd;
    
#line 1917 
    tmp = (struct efx_mcdi_mtd_partition *)__mptr + 18446744073709551600U;
  }
  
#line 1917 
  struct efx_mcdi_mtd_partition *part = tmp;
  
#line 1918 
  struct efx_nic *efx = (struct efx_nic *)mtd->priv;
  
#line 1919 
  loff_t offset = start;
  {
    loff_t tmp_0;
    
#line 1920 
    loff_t __min1 = (long long)((unsigned long long)start + (unsigned long long)len);
    
#line 1920 
    loff_t __min2 = (long long)mtd->size;
    
#line 1920 
    if (__min1 < __min2) 
#line 1920 
                         tmp_0 = __min1; else 
#line 1920 
                                              tmp_0 = __min2;
    
#line 1920 
    tmp_1 = tmp_0;
  }
  
#line 1920 
  loff_t end = tmp_1;
  
#line 1922 
  int rc = 0;
  
#line 1924 
  goto ldv_57067;
  ldv_57066: 
#line 1925 
  ;
  {
    size_t tmp_2;
    
#line 1925 
    size_t __min1_0 = (unsigned long)(end - offset);
    
#line 1925 
    size_t __min2_0 = 128UL;
    
#line 1925 
    if (__min1_0 < __min2_0) 
#line 1925 
                             tmp_2 = __min1_0; else 
#line 1925 
                                                    tmp_2 = __min2_0;
    
#line 1925 
    tmp_3 = tmp_2;
  }
  
#line 1925 
  chunk = tmp_3;
  
#line 1926 
  rc = efx_mcdi_nvram_read(efx,(unsigned int)part->nvram_type,offset,buffer,chunk);
  
#line 1928 
  if (rc != 0) 
#line 1929 
               goto out; else ;
  
#line 1930 
  offset = (long long)((unsigned long long)offset + (unsigned long long)chunk);
  
#line 1931 
  buffer += chunk;
  ldv_57067: 
#line 1932 
  ;
  
#line 1924 
  if (offset < end) 
#line 1926 
                    goto ldv_57066; else 
#line 1929 
                                         goto ldv_57068;
  ldv_57068: 
#line 1930 
  ;
  out: 
#line 1933 
  ;
  
#line 1934 
  *retlen = (unsigned long)(offset - start);
  
#line 1935 
  return rc;
}


#line 1938  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
int efx_mcdi_mtd_erase(struct mtd_info *mtd, loff_t start, size_t len)
{
  struct efx_mcdi_mtd_partition *tmp;
  loff_t tmp_1;
  {
    
#line 1940 
    struct mtd_info const *__mptr = (struct mtd_info const *)mtd;
    
#line 1940 
    tmp = (struct efx_mcdi_mtd_partition *)__mptr + 18446744073709551600U;
  }
  
#line 1940 
  struct efx_mcdi_mtd_partition *part = tmp;
  
#line 1941 
  struct efx_nic *efx = (struct efx_nic *)mtd->priv;
  
#line 1942 
  loff_t offset = ~ ((long long)(mtd->erasesize + 4294967295U)) & start;
  {
    loff_t tmp_0;
    
#line 1943 
    loff_t __min1 = (long long)((unsigned long long)start + (unsigned long long)len);
    
#line 1943 
    loff_t __min2 = (long long)mtd->size;
    
#line 1943 
    if (__min1 < __min2) 
#line 1943 
                         tmp_0 = __min1; else 
#line 1943 
                                              tmp_0 = __min2;
    
#line 1943 
    tmp_1 = tmp_0;
  }
  
#line 1943 
  loff_t end = tmp_1;
  
#line 1944 
  size_t chunk = (unsigned long)part->common.mtd.erasesize;
  
#line 1945 
  int rc = 0;
  
#line 1947 
  if (! part->updating) {
    
#line 1948 
    rc = efx_mcdi_nvram_update_start(efx,(unsigned int)part->nvram_type);
    
#line 1949 
    if (rc != 0) 
#line 1950 
                 goto out; else ;
    
#line 1951 
    part->updating = (_Bool)1;
  }
  else ;
  
#line 1957 
  goto ldv_57087;
  ldv_57086: 
#line 1958 
  ;
  
#line 1958 
  rc = efx_mcdi_nvram_erase(efx,(unsigned int)part->nvram_type,offset,chunk);
  
#line 1960 
  if (rc != 0) 
#line 1961 
               goto out; else ;
  
#line 1962 
  offset = (long long)((unsigned long long)offset + (unsigned long long)chunk);
  ldv_57087: 
#line 1963 
  ;
  
#line 1957 
  if (offset < end) 
#line 1959 
                    goto ldv_57086; else 
#line 1962 
                                         goto ldv_57088;
  ldv_57088: 
#line 1963 
  ;
  out: 
#line 1964 
  ;
  
#line 1965 
  return rc;
}


#line 1968  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
int efx_mcdi_mtd_write(struct mtd_info *mtd, loff_t start, size_t len, size_t *retlen, u8 const *buffer)
{
  struct efx_mcdi_mtd_partition *tmp;
  loff_t tmp_1;
  size_t chunk;
  size_t tmp_3;
  {
    
#line 1971 
    struct mtd_info const *__mptr = (struct mtd_info const *)mtd;
    
#line 1971 
    tmp = (struct efx_mcdi_mtd_partition *)__mptr + 18446744073709551600U;
  }
  
#line 1971 
  struct efx_mcdi_mtd_partition *part = tmp;
  
#line 1972 
  struct efx_nic *efx = (struct efx_nic *)mtd->priv;
  
#line 1973 
  loff_t offset = start;
  {
    loff_t tmp_0;
    
#line 1974 
    loff_t __min1 = (long long)((unsigned long long)start + (unsigned long long)len);
    
#line 1974 
    loff_t __min2 = (long long)mtd->size;
    
#line 1974 
    if (__min1 < __min2) 
#line 1974 
                         tmp_0 = __min1; else 
#line 1974 
                                              tmp_0 = __min2;
    
#line 1974 
    tmp_1 = tmp_0;
  }
  
#line 1974 
  loff_t end = tmp_1;
  
#line 1976 
  int rc = 0;
  
#line 1978 
  if (! part->updating) {
    
#line 1979 
    rc = efx_mcdi_nvram_update_start(efx,(unsigned int)part->nvram_type);
    
#line 1980 
    if (rc != 0) 
#line 1981 
                 goto out; else ;
    
#line 1982 
    part->updating = (_Bool)1;
  }
  else ;
  
#line 1985 
  goto ldv_57112;
  ldv_57111: 
#line 1986 
  ;
  {
    size_t tmp_2;
    
#line 1986 
    size_t __min1_0 = (unsigned long)(end - offset);
    
#line 1986 
    size_t __min2_0 = 128UL;
    
#line 1986 
    if (__min1_0 < __min2_0) 
#line 1986 
                             tmp_2 = __min1_0; else 
#line 1986 
                                                    tmp_2 = __min2_0;
    
#line 1986 
    tmp_3 = tmp_2;
  }
  
#line 1986 
  chunk = tmp_3;
  
#line 1987 
  rc = efx_mcdi_nvram_write(efx,(unsigned int)part->nvram_type,offset,buffer,chunk);
  
#line 1989 
  if (rc != 0) 
#line 1990 
               goto out; else ;
  
#line 1991 
  offset = (long long)((unsigned long long)offset + (unsigned long long)chunk);
  
#line 1992 
  buffer += chunk;
  ldv_57112: 
#line 1993 
  ;
  
#line 1985 
  if (offset < end) 
#line 1987 
                    goto ldv_57111; else 
#line 1990 
                                         goto ldv_57113;
  ldv_57113: 
#line 1991 
  ;
  out: 
#line 1994 
  ;
  
#line 1995 
  *retlen = (unsigned long)(offset - start);
  
#line 1996 
  return rc;
}


#line 1999  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
int efx_mcdi_mtd_sync(struct mtd_info *mtd)
{
  struct efx_mcdi_mtd_partition *tmp;
  {
    
#line 2001 
    struct mtd_info const *__mptr = (struct mtd_info const *)mtd;
    
#line 2001 
    tmp = (struct efx_mcdi_mtd_partition *)__mptr + 18446744073709551600U;
  }
  
#line 2001 
  struct efx_mcdi_mtd_partition *part = tmp;
  
#line 2002 
  struct efx_nic *efx = (struct efx_nic *)mtd->priv;
  
#line 2003 
  int rc = 0;
  
#line 2005 
  if ((int)part->updating != 0) {
    
#line 2006 
    part->updating = (_Bool)0;
    
#line 2007 
    rc = efx_mcdi_nvram_update_finish(efx,(unsigned int)part->nvram_type);
  }
  else ;
  
#line 2010 
  return rc;
}


#line 2013  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.c"
void efx_mcdi_mtd_rename(struct efx_mtd_partition *part)
{
  struct efx_mcdi_mtd_partition *tmp;
  {
    
#line 2016 
    struct efx_mtd_partition const *__mptr = (struct efx_mtd_partition const *)part;
    
#line 2016 
    tmp = (struct efx_mcdi_mtd_partition *)__mptr;
  }
  
#line 2015 
  struct efx_mcdi_mtd_partition *mcdi_part = tmp;
  
#line 2017 
  struct efx_nic *efx = (struct efx_nic *)part->mtd.priv;
  
#line 2019 
  snprintf((char *)(& part->name),36UL,"%s %s:%02x",(char *)(& efx->name),part->type_name,(int)mcdi_part->fw_subtype);
  
#line 2021 
  return;
}


#line 69  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
int ldv_emg_mod_timer(struct timer_list *arg0, unsigned long arg1);


#line 132  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static void atomic_dec_0(atomic_t *v)
{
  
#line 135 
  ldv_atomic_dec(v);
  
#line 136 
  return;
}


#line 597  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static void *kmalloc_0(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 600 
  tmp = ldv_kmalloc(size,flags);
  
#line 600 
  return tmp;
}


#line 618  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static void *kzalloc_5(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 621 
  tmp = ldv_kzalloc(size,flags);
  
#line 621 
  return tmp;
}


#line 988  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static void ldv_spin_lock_bh_97_0(spinlock_t *lock)
{
  
#line 992 
  ldv_spin_model_lock((char *)"iface_lock_of_efx_mcdi_iface");
  
#line 994 
  spin_lock_bh_1(lock);
  
#line 995 
  return;
}


#line 998  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static void ldv_spin_unlock_bh_98(spinlock_t *lock)
{
  
#line 1002 
  ldv_spin_model_unlock((char *)"iface_lock_of_efx_mcdi_iface");
  
#line 1004 
  spin_unlock_bh_2(lock);
  
#line 1005 
  return;
}


#line 1008  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static void ldv_spin_lock_bh_99(spinlock_t *lock)
{
  
#line 1012 
  ldv_spin_model_lock((char *)"iface_lock_of_efx_mcdi_iface");
  
#line 1014 
  spin_lock_bh_1(lock);
  
#line 1015 
  return;
}


#line 1018  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static void ldv_spin_unlock_bh_100(spinlock_t *lock)
{
  
#line 1022 
  ldv_spin_model_unlock((char *)"iface_lock_of_efx_mcdi_iface");
  
#line 1024 
  spin_unlock_bh_2(lock);
  
#line 1025 
  return;
}


#line 1028  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static void ldv_spin_lock_bh_101(spinlock_t *lock)
{
  
#line 1032 
  ldv_spin_model_lock((char *)"iface_lock_of_efx_mcdi_iface");
  
#line 1034 
  spin_lock_bh_1(lock);
  
#line 1035 
  return;
}


#line 1038  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static void ldv_spin_unlock_bh_102(spinlock_t *lock)
{
  
#line 1042 
  ldv_spin_model_unlock((char *)"iface_lock_of_efx_mcdi_iface");
  
#line 1044 
  spin_unlock_bh_2(lock);
  
#line 1045 
  return;
}


#line 1048  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static void ldv_spin_lock_bh_103(spinlock_t *lock)
{
  
#line 1052 
  ldv_spin_model_lock((char *)"async_lock_of_efx_mcdi_iface");
  
#line 1054 
  spin_lock_bh_1(lock);
  
#line 1055 
  return;
}


#line 1058  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static int ldv_mod_timer_104(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2)
{
  int tmp;
  
#line 1062 
  tmp = ldv_emg_mod_timer(ldv_func_arg1,ldv_func_arg2);
  
#line 1062 
  return tmp;
}


#line 1066  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static void ldv_spin_unlock_bh_105_0(spinlock_t *lock)
{
  
#line 1070 
  ldv_spin_model_unlock((char *)"async_lock_of_efx_mcdi_iface");
  
#line 1072 
  spin_unlock_bh_2(lock);
  
#line 1073 
  return;
}


#line 1076  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static void ldv_spin_lock_106(spinlock_t *lock)
{
  
#line 1080 
  ldv_spin_model_lock((char *)"iface_lock_of_efx_mcdi_iface");
  
#line 1082 
  spin_lock_2(lock);
  
#line 1083 
  return;
}


#line 1086  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static void ldv_spin_unlock_107(spinlock_t *lock)
{
  
#line 1090 
  ldv_spin_model_unlock((char *)"iface_lock_of_efx_mcdi_iface");
  
#line 1092 
  spin_unlock_2(lock);
  
#line 1093 
  return;
}


#line 1096  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static int ldv_del_timer_sync_108(struct timer_list *ldv_func_arg1)
{
  int tmp;
  
#line 1100 
  tmp = ldv_emg_del_timer_sync(ldv_func_arg1);
  
#line 1100 
  return tmp;
}


#line 1104  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static void ldv_spin_lock_109(spinlock_t *lock)
{
  
#line 1108 
  ldv_spin_model_lock((char *)"async_lock_of_efx_mcdi_iface");
  
#line 1110 
  spin_lock_2(lock);
  
#line 1111 
  return;
}


#line 1114  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static void ldv_spin_unlock_110(spinlock_t *lock)
{
  
#line 1118 
  ldv_spin_model_unlock((char *)"async_lock_of_efx_mcdi_iface");
  
#line 1120 
  spin_unlock_2(lock);
  
#line 1121 
  return;
}


#line 1124  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static void ldv_spin_lock_111(spinlock_t *lock)
{
  
#line 1128 
  ldv_spin_model_lock((char *)"iface_lock_of_efx_mcdi_iface");
  
#line 1130 
  spin_lock_2(lock);
  
#line 1131 
  return;
}


#line 1134  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static void ldv_spin_unlock_112(spinlock_t *lock)
{
  
#line 1138 
  ldv_spin_model_unlock((char *)"iface_lock_of_efx_mcdi_iface");
  
#line 1140 
  spin_unlock_2(lock);
  
#line 1141 
  return;
}


#line 1144  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static void ldv_spin_lock_bh_113(spinlock_t *lock)
{
  
#line 1148 
  ldv_spin_model_lock((char *)"iface_lock_of_efx_mcdi_iface");
  
#line 1150 
  spin_lock_bh_1(lock);
  
#line 1151 
  return;
}


#line 1154  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static void ldv_spin_unlock_bh_114(spinlock_t *lock)
{
  
#line 1158 
  ldv_spin_model_unlock((char *)"iface_lock_of_efx_mcdi_iface");
  
#line 1160 
  spin_unlock_bh_2(lock);
  
#line 1161 
  return;
}


#line 1164  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static void ldv_spin_lock_bh_115(spinlock_t *lock)
{
  
#line 1168 
  ldv_spin_model_lock((char *)"iface_lock_of_efx_mcdi_iface");
  
#line 1170 
  spin_lock_bh_1(lock);
  
#line 1171 
  return;
}


#line 1174  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static void ldv_spin_unlock_bh_116(spinlock_t *lock)
{
  
#line 1178 
  ldv_spin_model_unlock((char *)"iface_lock_of_efx_mcdi_iface");
  
#line 1180 
  spin_unlock_bh_2(lock);
  
#line 1181 
  return;
}


#line 1184  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static void ldv_spin_lock_bh_117(spinlock_t *lock)
{
  
#line 1188 
  ldv_spin_model_lock((char *)"async_lock_of_efx_mcdi_iface");
  
#line 1190 
  spin_lock_bh_1(lock);
  
#line 1191 
  return;
}


#line 1194  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static int ldv_mod_timer_118(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2)
{
  int tmp;
  
#line 1198 
  tmp = ldv_emg_mod_timer(ldv_func_arg1,ldv_func_arg2);
  
#line 1198 
  return tmp;
}


#line 1202  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static void ldv_spin_unlock_bh_119(spinlock_t *lock)
{
  
#line 1206 
  ldv_spin_model_unlock((char *)"async_lock_of_efx_mcdi_iface");
  
#line 1208 
  spin_unlock_bh_2(lock);
  
#line 1209 
  return;
}


#line 1212  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static int ldv_del_timer_sync_120(struct timer_list *ldv_func_arg1)
{
  int tmp;
  
#line 1216 
  tmp = ldv_emg_del_timer_sync(ldv_func_arg1);
  
#line 1216 
  return tmp;
}


#line 1220  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static void ldv_spin_lock_121(spinlock_t *lock)
{
  
#line 1224 
  ldv_spin_model_lock((char *)"iface_lock_of_efx_mcdi_iface");
  
#line 1226 
  spin_lock_2(lock);
  
#line 1227 
  return;
}


#line 1230  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static void ldv_spin_unlock_122(spinlock_t *lock)
{
  
#line 1234 
  ldv_spin_model_unlock((char *)"iface_lock_of_efx_mcdi_iface");
  
#line 1236 
  spin_unlock_2(lock);
  
#line 1237 
  return;
}


#line 1240  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static void ldv_spin_lock_123(spinlock_t *lock)
{
  
#line 1244 
  ldv_spin_model_lock((char *)"iface_lock_of_efx_mcdi_iface");
  
#line 1246 
  spin_lock_2(lock);
  
#line 1247 
  return;
}


#line 1250  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi.c.aux"
static void ldv_spin_unlock_124(spinlock_t *lock)
{
  
#line 1254 
  ldv_spin_model_unlock((char *)"iface_lock_of_efx_mcdi_iface");
  
#line 1256 
  spin_unlock_2(lock);
  
#line 1257 
  return;
}


#line 37  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mdio_10g.c.aux"
static void ldv_mutex_lock_87_2(struct mutex *ldv_func_arg1);


#line 193  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
static void ldv_mutex_unlock_88_2(struct mutex *ldv_func_arg1);


#line 304  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mii.h"
__inline static u16 mii_advertise_flowctrl(int cap)
{
  
#line 306 
  u16 adv = (unsigned short)0U;
  
#line 308 
  if ((cap & 2) != 0) 
#line 309 
                      adv = (unsigned short)3072U; else ;
  
#line 310 
  if ((cap & 1) != 0) 
#line 311 
                      adv = (unsigned short)((unsigned int)adv ^ 2048U); else ;
  
#line 313 
  return adv;
}


#line 323  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mii.h"
__inline static u8 mii_resolve_flowctrl_fdx(u16 lcladv, u16 rmtadv)
{
  
#line 325 
  u8 cap = (unsigned char)0U;
  
#line 327 
  if ((((int)lcladv & (int)rmtadv) & 1024) != 0) 
#line 328 
                                                 cap = (unsigned char)3U;
  else 
    
#line 329 
    if ((((int)lcladv & (int)rmtadv) & 2048) != 0) {
      
#line 330 
      if (((int)lcladv & 1024) != 0) 
#line 331 
                                     cap = (unsigned char)2U;
      else 
        
#line 332 
        if (((int)rmtadv & 1024) != 0) 
#line 333 
                                       cap = (unsigned char)1U; else ;
    }
    else ;
  
#line 336 
  return cap;
}


#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mdio.h"
int mdio45_links_ok(struct mdio_if_info const *, u32);


#line 769  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
__inline static bool efx_phy_mode_disabled(enum efx_phy_mode mode)
{
  bool __retres;
  
#line 771 
  __retres = (_Bool)(((unsigned int)mode & 4294967294U) != 0U);
  
#line 771 
  return __retres;
}


#line 254  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
void efx_link_set_advertising(struct efx_nic *efx, u32 advertising);


#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mdio_10g.h"
void efx_mdio_an_reconfigure(struct efx_nic *efx);


#line 94 
u8 efx_mdio_get_pause(struct efx_nic *efx);


#line 97 
int efx_mdio_wait_reset_mmds(struct efx_nic *efx, unsigned int mmd_mask);


#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mdio_10g.c"
unsigned int efx_mdio_id_oui(u32 id)
{
  int i;
  
#line 21 
  unsigned int oui = 0U;
  
#line 27 
  i = 0;
  
#line 27 
  goto ldv_54671;
  ldv_54670: 
#line 28 
  ;
  
#line 28 
  if (((unsigned int)(1 << (i + 10)) & id) != 0U) 
#line 29 
                                                  oui = (unsigned int)(1 << (i ^ 7)) | oui; else ;
  
#line 27 
  i += 1;
  ldv_54671: 
#line 28 
  ;
  
#line 27 
  if (i <= 21) 
#line 29 
               goto ldv_54670; else 
#line 32 
                                    goto ldv_54672;
  ldv_54672: 
#line 33 
  ;
  
#line 31 
  return oui;
}


#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mdio_10g.c"
int efx_mdio_reset_mmd(struct efx_nic *port, int mmd, int spins, int spintime)
{
  u32 ctrl;
  int tmp;
  int tmp_0;
  
#line 42 
  efx_mdio_write(port,mmd,0,32768);
  ldv_54680: 
#line 43 
  ;
  
#line 45 
  msleep((unsigned int)spintime);
  
#line 46 
  tmp = efx_mdio_read(port,mmd,0);
  
#line 46 
  ctrl = (unsigned int)tmp;
  
#line 47 
  spins -= 1;
  
#line 49 
  if (spins != 0 && (ctrl & 32768U) != 0U) 
#line 51 
                                           goto ldv_54680; else 
#line 54 
                                                                goto ldv_54681;
  ldv_54681: 
#line 55 
  ;
  
#line 51 
  if (spins != 0) 
#line 51 
                  tmp_0 = spins; else 
#line 51 
                                      tmp_0 = -110;
  
#line 51 
  return tmp_0;
}


#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mdio_10g.c"
static int efx_mdio_check_mmd(struct efx_nic *efx, int mmd)
{
  int __retres;
  int status;
  
#line 58 
  if (mmd != 7) {
    
#line 60 
    status = efx_mdio_read(efx,mmd,8);
    
#line 61 
    if ((status & 49152) != 32768) {
      
#line 62 
      if ((efx->msg_enable & 8192U) != 0U) 
#line 62 
                                           netdev_err((struct net_device const *)efx->net_dev,"PHY MMD %d not responding.\n",mmd); else ;
      
#line 64 
      __retres = -5;
      
#line 64 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 68 
  __retres = 0;
  return_label: 
#line 68 
                return __retres;
}


#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mdio_10g.c"
int efx_mdio_wait_reset_mmds(struct efx_nic *efx, unsigned int mmd_mask)
{
  int __retres;
  int in_reset;
  
#line 77 
  int const spintime = 10;
  
#line 78 
  int tries = 100;
  
#line 79 
  int rc = 0;
  
#line 82 
  goto ldv_54703;
  ldv_54702: 
#line 83 
  ;
  {
    int stat;
    
#line 83 
    int mask = (int)mmd_mask;
    
#line 84 
    int mmd = 0;
    
#line 86 
    in_reset = 0;
    
#line 87 
    goto ldv_54699;
    ldv_54698: 
#line 88 
    ;
    
#line 88 
    if ((mask & 1) != 0) {
      
#line 89 
      stat = efx_mdio_read(efx,mmd,0);
      
#line 90 
      if (stat < 0) {
        
#line 91 
        if ((efx->msg_enable & 8192U) != 0U) 
#line 91 
                                             netdev_err((struct net_device const *)efx->net_dev,"failed to read status of",mmd); else ;
        
#line 94 
        __retres = -5;
        
#line 94 
        goto return_label;
      }
      else ;
      
#line 96 
      if ((stat & 32768) != 0) 
#line 97 
                               in_reset = (1 << mmd) | in_reset; else ;
    }
    else ;
    
#line 99 
    mask >>= 1;
    
#line 100 
    mmd += 1;
    ldv_54699: 
#line 101 
    ;
    
#line 87 
    if (mask != 0) 
#line 89 
                   goto ldv_54698; else 
#line 92 
                                        goto ldv_54700;
    ldv_54700: 
#line 93 
    ;
    
#line 102 
    if (in_reset == 0) 
#line 103 
                       goto ldv_54701; else ;
    
#line 104 
    tries -= 1;
    
#line 105 
    msleep((unsigned int)spintime);
  }
  ldv_54703: 
#line 107 
  ;
  
#line 82 
  if (tries != 0) 
#line 84 
                  goto ldv_54702; else 
#line 87 
                                       goto ldv_54701;
  ldv_54701: 
#line 88 
  ;
  
#line 107 
  if (in_reset != 0) {
    
#line 108 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 108 
                                         netdev_err((struct net_device const *)efx->net_dev,"not all MMDs came out of reset in time.",in_reset); else ;
    
#line 111 
    rc = -110;
  }
  else ;
  
#line 113 
  __retres = rc;
  return_label: 
#line 113 
                return __retres;
}


#line 116  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mdio_10g.c"
int efx_mdio_check_mmds(struct efx_nic *efx, unsigned int mmd_mask)
{
  int __retres;
  int probe_mmd;
  int devs1;
  int devs2;
  u32 devices;
  
#line 118 
  int mmd = 0;
  
#line 124 
  if ((mmd_mask & 16U) == 0U) {
    unsigned long tmp;
    
#line 124 
    tmp = __ffs((unsigned long)mmd_mask);
    
#line 124 
    probe_mmd = (int)tmp;
  }
  else 
#line 124 
       probe_mmd = 4;
  
#line 128 
  devs1 = efx_mdio_read(efx,probe_mmd,5);
  
#line 129 
  devs2 = efx_mdio_read(efx,probe_mmd,6);
  
#line 130 
  if (devs1 < 0 || devs2 < 0) {
    
#line 131 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 131 
                                         netdev_err((struct net_device const *)efx->net_dev,"failed to read devices present\n"); else ;
    
#line 133 
    __retres = -5;
    
#line 133 
    goto return_label;
  }
  else ;
  
#line 135 
  devices = (unsigned int)((devs2 << 16) | devs1);
  
#line 136 
  if ((devices & mmd_mask) != mmd_mask) {
    
#line 137 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 137 
                                         netdev_err((struct net_device const *)efx->net_dev,"required MMDs not present: got %x, wanted %x\n",devices,mmd_mask); else ;
    
#line 140 
    __retres = -19;
    
#line 140 
    goto return_label;
  }
  else ;
  
#line 145 
  goto ldv_54715;
  ldv_54714: 
#line 146 
  ;
  
#line 146 
  if ((mmd_mask & 1U) != 0U) {
    int tmp_0;
    
#line 146 
    tmp_0 = efx_mdio_check_mmd(efx,mmd);
    
#line 146 
    if (tmp_0 != 0) {
      
#line 147 
      __retres = -5;
      
#line 147 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 148 
  mmd_mask >>= 1;
  
#line 149 
  mmd += 1;
  ldv_54715: 
#line 150 
  ;
  
#line 145 
  if (mmd_mask != 0U) 
#line 147 
                      goto ldv_54714; else 
#line 150 
                                           goto ldv_54716;
  ldv_54716: 
#line 151 
  ;
  
#line 152 
  __retres = 0;
  return_label: 
#line 152 
                return __retres;
}


#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mdio_10g.c"
bool efx_mdio_links_ok(struct efx_nic *efx, unsigned int mmd_mask)
{
  bool __retres;
  int tmp_0;
  
#line 159 
  if (((66600958 >> (unsigned int)efx->loopback_mode) & 1) != 0) {
    
#line 160 
    __retres = (_Bool)1;
    
#line 160 
    goto return_label;
  }
  else 
    
#line 161 
    if (((133693440 >> (unsigned int)efx->loopback_mode) & 1) != 0) {
      
#line 162 
      __retres = (_Bool)0;
      
#line 162 
      goto return_label;
    }
    else {
      bool tmp;
      
#line 163 
      tmp = efx_phy_mode_disabled(efx->phy_mode);
      
#line 163 
      if ((int)tmp != 0) {
        
#line 164 
        __retres = (_Bool)0;
        
#line 164 
        goto return_label;
      }
      else 
        
#line 165 
        if (efx->loopback_mode == (unsigned int)LOOPBACK_PHYXS) 
#line 166 
                                                                mmd_mask &= 4294967141U;
        else 
          
#line 170 
          if (efx->loopback_mode == (unsigned int)LOOPBACK_PCS) 
#line 171 
                                                                mmd_mask &= 4294967157U;
          else 
            
#line 174 
            if (efx->loopback_mode == (unsigned int)LOOPBACK_PMAPMD) 
              
#line 175 
              mmd_mask &= 4294967165U; else ;
    }
  
#line 178 
  tmp_0 = mdio45_links_ok((struct mdio_if_info const *)(& efx->mdio),mmd_mask);
  
#line 178 
  __retres = (_Bool)(tmp_0 != 0);
  return_label: 
#line 178 
                return __retres;
}


#line 181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mdio_10g.c"
void efx_mdio_transmit_disable(struct efx_nic *efx)
{
  
#line 183 
  efx_mdio_set_flag(efx,1,9,1,(_Bool)(((unsigned int)efx->phy_mode & 1U) != 0U));
  
#line 186 
  return;
}


#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mdio_10g.c"
void efx_mdio_phy_reconfigure(struct efx_nic *efx)
{
  
#line 190 
  efx_mdio_set_flag(efx,1,0,1,(_Bool)(efx->loopback_mode == (unsigned int)LOOPBACK_PMAPMD));
  
#line 193 
  efx_mdio_set_flag(efx,3,0,16384,(_Bool)(efx->loopback_mode == (unsigned int)LOOPBACK_PCS));
  
#line 196 
  efx_mdio_set_flag(efx,4,0,16384,(_Bool)(efx->loopback_mode == (unsigned int)LOOPBACK_PHYXS_WS));
  
#line 199 
  return;
}


#line 201  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mdio_10g.c"
static void efx_mdio_set_mmd_lpower(struct efx_nic *efx, int lpower, int mmd)
{
  
#line 204 
  int stat = efx_mdio_read(efx,mmd,1);
  
#line 209 
  if ((stat & 2) != 0) 
#line 210 
                       efx_mdio_set_flag(efx,mmd,0,2048,(_Bool)(lpower != 0)); else ;
  
#line 211 
  return;
}


#line 215  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mdio_10g.c"
void efx_mdio_set_mmds_lpower(struct efx_nic *efx, int low_power, unsigned int mmd_mask)
{
  
#line 218 
  int mmd = 0;
  
#line 219 
  mmd_mask &= 4294967167U;
  
#line 220 
  goto ldv_54741;
  ldv_54740: 
#line 221 
  ;
  
#line 221 
  if ((mmd_mask & 1U) != 0U) 
#line 222 
                             efx_mdio_set_mmd_lpower(efx,low_power,mmd); else ;
  
#line 223 
  mmd_mask >>= 1;
  
#line 224 
  mmd += 1;
  ldv_54741: 
#line 225 
  ;
  
#line 220 
  if (mmd_mask != 0U) 
#line 222 
                      goto ldv_54740; else 
#line 225 
                                           goto ldv_54742;
  ldv_54742: 
#line 226 
  ;
  
#line 227 
  return;
}


#line 233  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mdio_10g.c"
int efx_mdio_set_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd)
{
  int __retres;
  
#line 235 
  struct ethtool_cmd prev = {.cmd = 1U, .supported = 0U, .advertising = 0U, .speed = (unsigned short)0, .duplex = (unsigned char)0, .port = (unsigned char)0, .phy_address = (unsigned char)0, .transceiver = (unsigned char)0, .autoneg = (unsigned char)0, .mdio_support = (unsigned char)0, .maxtxpkt = 0U, .maxrxpkt = 0U, .speed_hi = (unsigned short)0, .eth_tp_mdix = (unsigned char)0, .eth_tp_mdix_ctrl = (unsigned char)0, .lp_advertising = 0U, .reserved = {0U, 0U}};
  
#line 237 
  (*((efx->phy_op)->get_settings))(efx,& prev);
  
#line 239 
  if (ecmd->advertising == prev.advertising) {
    __u32 tmp;
    __u32 tmp_0;
    
#line 239 
    tmp = ethtool_cmd_speed((struct ethtool_cmd const *)ecmd);
    
#line 240 
    tmp_0 = ethtool_cmd_speed((struct ethtool_cmd const *)(& prev));
    
#line 239 
    if (tmp == tmp_0) {
      
#line 240 
      if ((int)ecmd->duplex == (int)prev.duplex) {
        
#line 241 
        if ((int)ecmd->port == (int)prev.port) {
          
#line 242 
          if ((int)ecmd->autoneg == (int)prev.autoneg) {
            
#line 244 
            __retres = 0;
            
#line 244 
            goto return_label;
          }
          else ;
        }
        else ;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 247 
  if ((unsigned int)prev.port != 0U || (unsigned int)ecmd->port != 0U) {
    
#line 248 
    __retres = -22;
    
#line 248 
    goto return_label;
  }
  else ;
  
#line 251 
  if ((unsigned int)ecmd->autoneg == 0U || ((ecmd->advertising | 64U) & ~ prev.supported) != 0U) {
    
#line 253 
    __retres = -22;
    
#line 253 
    goto return_label;
  }
  else ;
  
#line 255 
  efx_link_set_advertising(efx,ecmd->advertising | 64U);
  
#line 256 
  efx_mdio_an_reconfigure(efx);
  
#line 257 
  __retres = 0;
  return_label: 
#line 257 
                return __retres;
}


#line 264  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mdio_10g.c"
void efx_mdio_an_reconfigure(struct efx_nic *efx)
{
  int reg;
  {
    
#line 268 
    int __ret_warn_on = (efx->mdio.mmds & 128U) == 0U;
    
#line 268 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 268 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mdio_10g.c",268); else ;
    
#line 268 
    long tmp = (long)(__ret_warn_on != 0);
  }
  
#line 271 
  reg = 4097;
  
#line 272 
  if ((efx->link_advertising & 8192U) != 0U) 
#line 273 
                                             reg |= 1024; else ;
  
#line 274 
  if ((efx->link_advertising & 16384U) != 0U) 
#line 275 
                                              reg |= 2048; else ;
  
#line 276 
  efx_mdio_write(efx,7,16,reg);
  
#line 279 
  (*((efx->phy_op)->set_npage_adv))(efx,efx->link_advertising);
  
#line 282 
  reg = efx_mdio_read(efx,7,0);
  
#line 283 
  reg |= 12800;
  
#line 284 
  efx_mdio_write(efx,7,0,reg);
  
#line 285 
  return;
}


#line 289 
void __compiletime_assert_289(void);


#line 287  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mdio_10g.c"
u8 efx_mdio_get_pause(struct efx_nic *efx)
{
  u8 __retres;
  u8 tmp_1;
  int tmp_0;
  u16 tmp_0_0;
  {
    
#line 289 
    bool __cond = (_Bool)0;
    
#line 289 
    if ((int)__cond != 0) 
#line 289 
                          __compiletime_assert_289(); else ;
  }
  
#line 291 
  if (((int)efx->wanted_fc & 4) == 0) {
    
#line 292 
    __retres = efx->wanted_fc;
    
#line 292 
    goto return_label;
  }
  else ;
  {
    
#line 294 
    int __ret_warn_on = (efx->mdio.mmds & 128U) == 0U;
    
#line 294 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 294 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mdio_10g.c",294); else ;
    
#line 294 
    long tmp = (long)(__ret_warn_on != 0);
  }
  
#line 297 
  tmp_0 = efx_mdio_read(efx,7,19);
  
#line 297 
  tmp_0_0 = mii_advertise_flowctrl((int)efx->wanted_fc);
  
#line 296 
  tmp_1 = mii_resolve_flowctrl_fdx((unsigned short)((int)tmp_0_0),(unsigned short)((int)((unsigned short)tmp_0)));
  
#line 296 
  __retres = tmp_1;
  return_label: 
#line 296 
                return __retres;
}


#line 301  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mdio_10g.c"
int efx_mdio_test_alive(struct efx_nic *efx)
{
  int rc;
  unsigned long tmp;
  u16 physid1;
  u16 physid2;
  int tmp_0;
  int tmp_1;
  
#line 304 
  tmp = __ffs((unsigned long)efx->mdio.mmds);
  
#line 304 
  int devad = (int)tmp;
  
#line 307 
  ldv_mutex_lock_87_2(& efx->mac_lock);
  
#line 309 
  tmp_0 = efx_mdio_read(efx,devad,2);
  
#line 309 
  physid1 = (unsigned short)tmp_0;
  
#line 310 
  tmp_1 = efx_mdio_read(efx,devad,3);
  
#line 310 
  physid2 = (unsigned short)tmp_1;
  
#line 312 
  if ((unsigned int)physid1 + 65535U > 65533U || (unsigned int)physid2 + 65535U > 65533U) {
    
#line 314 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 314 
                                         netdev_err((struct net_device const *)efx->net_dev,"no MDIO PHY present with ID %d\n",efx->mdio.prtad); else ;
    
#line 316 
    rc = -22;
  }
  else 
#line 318 
       rc = efx_mdio_check_mmds(efx,efx->mdio.mmds);
  
#line 321 
  ldv_mutex_unlock_88_2(& efx->mac_lock);
  
#line 322 
  return rc;
}


#line 888  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mdio_10g.c.aux"
static void ldv_mutex_lock_87_2(struct mutex *ldv_func_arg1)
{
  
#line 892 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 893 
  return;
}


#line 896  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mdio_10g.c.aux"
static void ldv_mutex_unlock_88_2(struct mutex *ldv_func_arg1)
{
  
#line 900 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 901 
  return;
}


#line 9  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
int ldv_atomic_dec_and_test(atomic_t *v);


#line 108  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitops.h"
__inline static __u32 rol32(__u32 word, unsigned int shift)
{
  __u32 __retres;
  
#line 110 
  __retres = (word << shift) | (word >> ((unsigned long)8 * sizeof(word) - (unsigned long)shift));
  
#line 110 
  return __retres;
}


#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/log2.h"
__inline static unsigned long __rounddown_pow_of_two(unsigned long n)
{
  unsigned long __retres;
  unsigned int tmp;
  
#line 72 
  tmp = fls_long(n);
  
#line 72 
  __retres = 1UL << (tmp + 4294967295U);
  
#line 72 
  return __retres;
}


#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/bug.h"
void warn_slowpath_fmt(char const *, int const, char const * , ...);


#line 181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitmap.h"
__inline static void bitmap_zero(unsigned long *dst, unsigned int nbits)
{
  
#line 183 
  if (0 != 0 && nbits <= 64U) 
#line 184 
                              *dst = 0UL;
  else {
    
#line 186 
    unsigned int len = (unsigned int)(((unsigned long)nbits + 63UL) / 64UL) * 8U;
    
#line 187 
    memset((void *)dst,0,(unsigned long)len);
  }
  
#line 189 
  return;
}


#line 120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/atomic.h"
static int atomic_dec_and_test(atomic_t *v);


#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/preempt.h"
__inline static int preempt_count(void)
{
  int __retres;
  int tmp;
  {
    int pfo_ret__;
    
#line 22 
    switch (4UL) {
      case (unsigned long)1: 
#line 22 
      ;
      
#line 23 
      ldv_inline_asm();
      
#line 22 
      goto ldv_6320;
      case (unsigned long)2: 
#line 22 
      ;
      
#line 23 
      ldv_inline_asm();
      
#line 22 
      goto ldv_6320;
      case (unsigned long)4: 
#line 22 
      ;
      
#line 23 
      ldv_inline_asm();
      
#line 22 
      goto ldv_6320;
      case (unsigned long)8: 
#line 22 
      ;
      
#line 23 
      ldv_inline_asm();
      
#line 22 
      goto ldv_6320;
      default: 
#line 22 
      ;
      
#line 22 
      __bad_percpu_size();
    }
    ldv_6320: 
#line 22 
    ;
    
#line 22 
    tmp = pfo_ret__;
  }
  
#line 22 
  __retres = tmp & 2147483647;
  
#line 22 
  return __retres;
}


#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_3(spinlock_t *lock)
{
  
#line 312 
  _raw_spin_lock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 313 
  return;
}


#line 346 
static void ldv_spin_lock_62_2(spinlock_t *lock);


#line 350 
static void ldv_spin_lock_67_2(spinlock_t *lock);


#line 355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_bh_2(spinlock_t *lock)
{
  
#line 357 
  _raw_spin_lock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 358 
  return;
}


#line 379 
static void ldv_spin_lock_bh_71_0(spinlock_t *lock);


#line 407 
static void ldv_spin_lock_bh_104_0(spinlock_t *lock);


#line 411 
static void ldv_spin_lock_bh_105(spinlock_t *lock);


#line 415 
static void ldv_spin_lock_bh_106_0(spinlock_t *lock);


#line 419 
static void ldv_spin_lock_bh_107(spinlock_t *lock);


#line 423 
static void ldv_spin_lock_bh_110_0(spinlock_t *lock);


#line 427 
static void ldv_spin_lock_bh_112_0(spinlock_t *lock);


#line 431 
static void ldv_spin_lock_bh_114(spinlock_t *lock);


#line 435 
static void ldv_spin_lock_bh_117_0(spinlock_t *lock);


#line 439 
static void ldv_spin_lock_bh_118(spinlock_t *lock);


#line 443 
static void ldv_spin_lock_bh_120(spinlock_t *lock);


#line 447 
static void ldv_spin_lock_bh_122(spinlock_t *lock);


#line 451 
static void ldv_spin_lock_bh_124(spinlock_t *lock);


#line 455 
static void ldv_spin_lock_bh_126(spinlock_t *lock);


#line 459 
static void ldv_spin_lock_bh_129(spinlock_t *lock);


#line 463 
static void ldv_spin_lock_bh_131(spinlock_t *lock);


#line 467 
static void ldv_spin_lock_bh_133(spinlock_t *lock);


#line 471 
static void ldv_spin_lock_bh_135(spinlock_t *lock);


#line 475 
static void ldv_spin_lock_bh_137(spinlock_t *lock);


#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_3(spinlock_t *lock)
{
  
#line 365 
  _raw_spin_unlock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 366 
  return;
}


#line 395 
static void ldv_spin_unlock_65_2(spinlock_t *lock);


#line 399 
static void ldv_spin_unlock_68_2(spinlock_t *lock);


#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_bh_3(spinlock_t *lock)
{
  
#line 406 
  _raw_spin_unlock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 407 
  return;
}


#line 428 
static void ldv_spin_unlock_bh_73_0(spinlock_t *lock);


#line 460 
static void ldv_spin_unlock_bh_103_0(spinlock_t *lock);


#line 464 
static void ldv_spin_unlock_bh_108(spinlock_t *lock);


#line 468 
static void ldv_spin_unlock_bh_109_0(spinlock_t *lock);


#line 472 
static void ldv_spin_unlock_bh_111_0(spinlock_t *lock);


#line 476 
static void ldv_spin_unlock_bh_113_0(spinlock_t *lock);


#line 480 
static void ldv_spin_unlock_bh_115(spinlock_t *lock);


#line 484 
static void ldv_spin_unlock_bh_116_0(spinlock_t *lock);


#line 488 
static void ldv_spin_unlock_bh_119_0(spinlock_t *lock);


#line 492 
static void ldv_spin_unlock_bh_121(spinlock_t *lock);


#line 496 
static void ldv_spin_unlock_bh_123(spinlock_t *lock);


#line 500 
static void ldv_spin_unlock_bh_125(spinlock_t *lock);


#line 504 
static void ldv_spin_unlock_bh_127(spinlock_t *lock);


#line 508 
static void ldv_spin_unlock_bh_128(spinlock_t *lock);


#line 512 
static void ldv_spin_unlock_bh_130(spinlock_t *lock);


#line 516 
static void ldv_spin_unlock_bh_132(spinlock_t *lock);


#line 520 
static void ldv_spin_unlock_bh_134(spinlock_t *lock);


#line 524 
static void ldv_spin_unlock_bh_136(spinlock_t *lock);


#line 528 
static void ldv_spin_unlock_bh_138(spinlock_t *lock);


#line 924  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
void prepare_to_wait(wait_queue_head_t *, wait_queue_t *, int);


#line 931 
int autoremove_wake_function(wait_queue_t *, unsigned int, int, void *);


#line 164  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ioport.h"
__inline static resource_size_t resource_size(struct resource const *res)
{
  resource_size_t __retres;
  
#line 166 
  __retres = (res->end - res->start) + 1ULL;
  
#line 166 
  return __retres;
}


#line 181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
void *ioremap_nocache(resource_size_t, unsigned long);


#line 195 
void iounmap(void volatile *);


#line 329 
void *ioremap_wc(resource_size_t, unsigned long);


#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwsem.h"
__inline static int rwsem_is_locked(struct rw_semaphore *sem)
{
  int __retres;
  
#line 55 
  __retres = sem->count != 0L;
  
#line 55 
  return __retres;
}


#line 595  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
static int ldv_device_create_file_97(struct device *ldv_func_arg1, struct device_attribute const *ldv_func_arg2);


#line 599 
static int ldv_device_create_file_98(struct device *ldv_func_arg1, struct device_attribute const *ldv_func_arg2);


#line 605 
static void ldv_device_remove_file_99(struct device *ldv_func_arg1, struct device_attribute const *ldv_func_arg2);


#line 609 
static void ldv_device_remove_file_100(struct device *ldv_func_arg1, struct device_attribute const *ldv_func_arg2);


#line 613 
static void ldv_device_remove_file_101(struct device *ldv_func_arg1, struct device_attribute const *ldv_func_arg2);


#line 617 
static void ldv_device_remove_file_102(struct device *ldv_func_arg1, struct device_attribute const *ldv_func_arg2);


#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kmalloc_1(size_t size, gfp_t flags);


#line 542 
static void *kcalloc_6(size_t n, size_t size, gfp_t flags);


#line 581 
static void *kzalloc_6(size_t size, gfp_t flags);


#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
__inline static u32 ethtool_rxfh_indir_default(u32 index, u32 n_rx_rings)
{
  u32 __retres;
  
#line 97 
  __retres = index % n_rx_rings;
  
#line 97 
  return __retres;
}


#line 3170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void __netif_tx_lock_2(struct netdev_queue *txq, int cpu)
{
  
#line 3172 
  ldv_spin_lock_62_2(& txq->_xmit_lock);
  
#line 3173 
  txq->xmit_lock_owner = cpu;
  
#line 3174 
  return;
}


#line 3190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void __netif_tx_unlock_2(struct netdev_queue *txq)
{
  
#line 3192 
  txq->xmit_lock_owner = -1;
  
#line 3193 
  ldv_spin_unlock_65_2(& txq->_xmit_lock);
  
#line 3194 
  return;
}


#line 3214  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_lock_2(struct net_device *dev)
{
  unsigned int i;
  int cpu;
  int tmp_3;
  
#line 3219 
  ldv_spin_lock_67_2(& dev->tx_global_lock);
  {
    int pscr_ret__;
    {
      
#line 3220 
      void const *__vpp_verify = (void const *)0;
      
#line 3220 
      void const *tmp = __vpp_verify;
    }
    
#line 3220 
    switch (4UL) {
      int tmp_0;
      int tmp_0_0;
      int tmp_1;
      int tmp_2;
      case (unsigned long)1: 
#line 3220 
      ;
      {
        int pfo_ret__;
        
#line 3220 
        switch (4UL) {
          case (unsigned long)1: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_43040;
          case (unsigned long)2: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_43040;
          case (unsigned long)4: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_43040;
          case (unsigned long)8: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_43040;
          default: 
#line 3220 
          ;
          
#line 3220 
          __bad_percpu_size();
        }
        ldv_43040: 
#line 3220 
        ;
        
#line 3220 
        tmp_0 = pfo_ret__;
      }
      
#line 3220 
      pscr_ret__ = tmp_0;
      
#line 3220 
      goto ldv_43046;
      case (unsigned long)2: 
#line 3220 
      ;
      {
        int pfo_ret___0;
        
#line 3220 
        switch (4UL) {
          case (unsigned long)1: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_43050;
          case (unsigned long)2: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_43050;
          case (unsigned long)4: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_43050;
          case (unsigned long)8: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_43050;
          default: 
#line 3220 
          ;
          
#line 3220 
          __bad_percpu_size();
        }
        ldv_43050: 
#line 3220 
        ;
        
#line 3220 
        tmp_0_0 = pfo_ret___0;
      }
      
#line 3220 
      pscr_ret__ = tmp_0_0;
      
#line 3220 
      goto ldv_43046;
      case (unsigned long)4: 
#line 3220 
      ;
      {
        int pfo_ret___1;
        
#line 3220 
        switch (4UL) {
          case (unsigned long)1: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_43059;
          case (unsigned long)2: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_43059;
          case (unsigned long)4: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_43059;
          case (unsigned long)8: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_43059;
          default: 
#line 3220 
          ;
          
#line 3220 
          __bad_percpu_size();
        }
        ldv_43059: 
#line 3220 
        ;
        
#line 3220 
        tmp_1 = pfo_ret___1;
      }
      
#line 3220 
      pscr_ret__ = tmp_1;
      
#line 3220 
      goto ldv_43046;
      case (unsigned long)8: 
#line 3220 
      ;
      {
        int pfo_ret___2;
        
#line 3220 
        switch (4UL) {
          case (unsigned long)1: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_43068;
          case (unsigned long)2: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_43068;
          case (unsigned long)4: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_43068;
          case (unsigned long)8: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_43068;
          default: 
#line 3220 
          ;
          
#line 3220 
          __bad_percpu_size();
        }
        ldv_43068: 
#line 3220 
        ;
        
#line 3220 
        tmp_2 = pfo_ret___2;
      }
      
#line 3220 
      pscr_ret__ = tmp_2;
      
#line 3220 
      goto ldv_43046;
      default: 
#line 3220 
      ;
      
#line 3220 
      __bad_size_call_parameter();
      
#line 3220 
      goto ldv_43046;
    }
    ldv_43046: 
#line 3220 
    ;
    
#line 3220 
    tmp_3 = pscr_ret__;
  }
  
#line 3220 
  cpu = tmp_3;
  
#line 3221 
  i = 0U;
  
#line 3221 
  goto ldv_43078;
  ldv_43077: 
#line 3222 
  ;
  {
    
#line 3222 
    struct netdev_queue *txq = netdev_get_tx_queue((struct net_device const *)dev,i);
    
#line 3230 
    __netif_tx_lock_2(txq,cpu);
    
#line 3231 
    set_bit(2L,(unsigned long volatile *)(& txq->state));
    
#line 3232 
    __netif_tx_unlock_2(txq);
  }
  
#line 3221 
  i += 1U;
  ldv_43078: 
#line 3222 
  ;
  
#line 3221 
  if (dev->num_tx_queues > i) 
#line 3223 
                              goto ldv_43077; else 
#line 3226 
                                                   goto ldv_43079;
  ldv_43079: 
#line 3227 
  ;
  
#line 3228 
  return;
}


#line 3236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_lock_bh_1(struct net_device *dev)
{
  
#line 3238 
  local_bh_disable();
  
#line 3239 
  netif_tx_lock_2(dev);
  
#line 3240 
  return;
}


#line 3242  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_unlock_2(struct net_device *dev)
{
  unsigned int i;
  
#line 3246 
  i = 0U;
  
#line 3246 
  goto ldv_43089;
  ldv_43088: 
#line 3247 
  ;
  {
    
#line 3247 
    struct netdev_queue *txq = netdev_get_tx_queue((struct net_device const *)dev,i);
    
#line 3253 
    set_bit(2L,(unsigned long volatile *)(& txq->state));
    
#line 3254 
    netif_schedule_queue(txq);
  }
  
#line 3246 
  i += 1U;
  ldv_43089: 
#line 3247 
  ;
  
#line 3246 
  if (dev->num_tx_queues > i) 
#line 3248 
                              goto ldv_43088; else 
#line 3251 
                                                   goto ldv_43090;
  ldv_43090: 
#line 3252 
  ;
  
#line 3256 
  ldv_spin_unlock_68_2(& dev->tx_global_lock);
  
#line 3257 
  return;
}


#line 3259  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_unlock_bh_1(struct net_device *dev)
{
  
#line 3261 
  netif_tx_unlock_2(dev);
  
#line 3262 
  local_bh_enable();
  
#line 3263 
  return;
}


#line 3314  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_addr_lock_bh_0(struct net_device *dev)
{
  
#line 3316 
  ldv_spin_lock_bh_71_0(& dev->addr_list_lock);
  
#line 3317 
  return;
}


#line 3324  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_addr_unlock_bh_0(struct net_device *dev)
{
  
#line 3326 
  ldv_spin_unlock_bh_73_0(& dev->addr_list_lock);
  
#line 3327 
  return;
}


#line 3796  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static char const *netdev_name(struct net_device const *dev)
{
  char const *__retres;
  
#line 3798 
  if ((int)dev->name[0] == 0) {
    
#line 3799 
    __retres = "(unnamed net_device)";
    
#line 3799 
    goto return_label;
  }
  else {
    char *tmp;
    
#line 3798 
    tmp = strchr((char const *)(& dev->name),37);
    
#line 3798 
    if (tmp != (char *)0) {
      
#line 3799 
      __retres = "(unnamed net_device)";
      
#line 3799 
      goto return_label;
    }
    else ;
  }
  
#line 3800 
  __retres = (char const *)(& dev->name);
  return_label: 
#line 3800 
                return __retres;
}


#line 3803  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static char const *netdev_reg_state(struct net_device const *dev)
{
  char const *__retres;
  
#line 3805 
  switch ((int)dev->reg_state) {
    case 0: 
#line 3806 
    ;
    
#line 3806 
    __retres = " (uninitialized)";
    
#line 3806 
    goto return_label;
    case 1: 
#line 3807 
    ;
    
#line 3807 
    __retres = "";
    
#line 3807 
    goto return_label;
    case 2: 
#line 3808 
    ;
    
#line 3808 
    __retres = " (unregistering)";
    
#line 3808 
    goto return_label;
    case 3: 
#line 3809 
    ;
    
#line 3809 
    __retres = " (unregistered)";
    
#line 3809 
    goto return_label;
    case 4: 
#line 3810 
    ;
    
#line 3810 
    __retres = " (released)";
    
#line 3810 
    goto return_label;
    case 5: 
#line 3811 
    ;
    
#line 3811 
    __retres = " (dummy)";
    
#line 3811 
    goto return_label;
  }
  {
    bool __warned;
    
#line 3814 
    int __ret_warn_once = 1;
    
#line 3814 
    if ((long)(__ret_warn_once != 0) != 0L) {
      int tmp;
      {
        
#line 3814 
        int __ret_warn_on = ! __warned;
        
#line 3814 
        if ((long)(__ret_warn_on != 0) != 0L) 
#line 3814 
                                              warn_slowpath_fmt("include/linux/netdevice.h",3814,"%s: unknown reg_state %d\n",(char const *)(& dev->name),(int)dev->reg_state); else ;
        
#line 3814 
        tmp = (long)(__ret_warn_on != 0);
      }
      
#line 3814 
      if ((long)tmp != 0L) 
#line 3814 
                           __warned = (_Bool)1; else ;
    }
    else ;
    
#line 3814 
    long tmp_2 = (long)(__ret_warn_once != 0);
  }
  
#line 3815 
  __retres = " (unknown)";
  return_label: 
#line 3815 
                return __retres;
}


#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jhash.h"
__inline static u32 jhash2(u32 const *k, u32 length, u32 initval)
{
  u32 a;
  u32 b;
  u32 c;
  __u32 tmp;
  __u32 tmp_0;
  __u32 tmp_1;
  __u32 tmp_2;
  __u32 tmp_3;
  __u32 tmp_4;
  
#line 122 
  c = ((length << 2) + initval) + 3735928559U;
  
#line 122 
  b = c;
  
#line 122 
  a = b;
  
#line 125 
  goto ldv_47404;
  ldv_47403: 
#line 126 
  ;
  
#line 126 
  a = *k + a;
  
#line 127 
  b = *(k + 1U) + b;
  
#line 128 
  c = *(k + 2U) + c;
  
#line 129 
  a -= c;
  
#line 129 
  tmp = rol32(c,4U);
  
#line 129 
  a = tmp ^ a;
  
#line 129 
  c += b;
  
#line 129 
  b -= a;
  
#line 129 
  tmp_0 = rol32(a,6U);
  
#line 129 
  b = tmp_0 ^ b;
  
#line 129 
  a += c;
  
#line 129 
  c -= b;
  
#line 129 
  tmp_1 = rol32(b,8U);
  
#line 129 
  c = tmp_1 ^ c;
  
#line 129 
  b += a;
  
#line 129 
  a -= c;
  
#line 129 
  tmp_2 = rol32(c,16U);
  
#line 129 
  a = tmp_2 ^ a;
  
#line 129 
  c += b;
  
#line 129 
  b -= a;
  
#line 129 
  tmp_3 = rol32(a,19U);
  
#line 129 
  b = tmp_3 ^ b;
  
#line 129 
  a += c;
  
#line 129 
  c -= b;
  
#line 129 
  tmp_4 = rol32(b,4U);
  
#line 129 
  c = tmp_4 ^ c;
  
#line 129 
  b += a;
  
#line 130 
  length += 4294967293U;
  
#line 131 
  k += 3U;
  ldv_47404: 
#line 132 
  ;
  
#line 125 
  if (length > 3U) 
#line 127 
                   goto ldv_47403; else 
#line 130 
                                        goto ldv_47405;
  ldv_47405: 
#line 131 
  ;
  
#line 135 
  switch (length) {
    __u32 tmp_5;
    __u32 tmp_6;
    __u32 tmp_7;
    __u32 tmp_8;
    __u32 tmp_9;
    __u32 tmp_10;
    __u32 tmp_11;
    case (u32)3: 
#line 136 
    ;
    
#line 136 
    c = *(k + 2U) + c;
    case (u32)2: 
#line 137 
    ;
    
#line 137 
    b = *(k + 1U) + b;
    case (u32)1: 
#line 138 
    ;
    
#line 138 
    a = *k + a;
    
#line 139 
    c ^= b;
    
#line 139 
    tmp_5 = rol32(b,14U);
    
#line 139 
    c -= tmp_5;
    
#line 139 
    a ^= c;
    
#line 139 
    tmp_6 = rol32(c,11U);
    
#line 139 
    a -= tmp_6;
    
#line 139 
    b ^= a;
    
#line 139 
    tmp_7 = rol32(a,25U);
    
#line 139 
    b -= tmp_7;
    
#line 139 
    c ^= b;
    
#line 139 
    tmp_8 = rol32(b,16U);
    
#line 139 
    c -= tmp_8;
    
#line 139 
    a ^= c;
    
#line 139 
    tmp_9 = rol32(c,4U);
    
#line 139 
    a -= tmp_9;
    
#line 139 
    b ^= a;
    
#line 139 
    tmp_10 = rol32(a,14U);
    
#line 139 
    b -= tmp_10;
    
#line 139 
    c ^= b;
    
#line 139 
    tmp_11 = rol32(b,24U);
    
#line 139 
    c -= tmp_11;
    case (u32)0: 
#line 140 
    ;
    
#line 141 
    goto ldv_47410;
  }
  ldv_47410: 
#line 144 
  ;
  
#line 144 
  return c;
}


#line 234  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/filter.h"
__inline static int efx_filter_set_eth_local(struct efx_filter_spec *spec, u16 vid, u8 const *addr)
{
  int __retres;
  
#line 237 
  if ((unsigned int)vid == 65535U && addr == (u8 const *)0U) {
    
#line 238 
    __retres = -22;
    
#line 238 
    goto return_label;
  }
  else ;
  
#line 240 
  if ((unsigned int)vid != 65535U) {
    
#line 241 
    spec->match_flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))))((unsigned int)spec->match_flags | 256U);
    
#line 242 
    if (0 != 0) 
#line 242 
                spec->outer_vid = (unsigned short)(((int)vid << 8) | ((int)vid >> 8)); else 
                                                                    
#line 242 
                                                                    spec->outer_vid = __fswab16((unsigned short)((int)vid));
  }
  else ;
  
#line 244 
  if (addr != (u8 const *)0U) {
    
#line 245 
    spec->match_flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))))((unsigned int)spec->match_flags | 16U);
    
#line 246 
    ether_addr_copy((u8 *)(& spec->loc_mac),addr);
  }
  else ;
  
#line 248 
  __retres = 0;
  return_label: 
#line 248 
                return __retres;
}


#line 255  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/filter.h"
__inline static int efx_filter_set_uc_def(struct efx_filter_spec *spec)
{
  int __retres;
  
#line 257 
  spec->match_flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))))((unsigned int)spec->match_flags | 1024U);
  
#line 258 
  __retres = 0;
  
#line 258 
  return __retres;
}


#line 265  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/filter.h"
__inline static int efx_filter_set_mc_def(struct efx_filter_spec *spec)
{
  int __retres;
  
#line 267 
  spec->match_flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))))((unsigned int)spec->match_flags | 1024U);
  
#line 268 
  spec->loc_mac[0] = (unsigned char)1U;
  
#line 269 
  __retres = 0;
  
#line 269 
  return __retres;
}


#line 338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi.h"
int efx_mcdi_port_get_number(struct efx_nic *efx);


#line 339 
u32 efx_mcdi_phy_get_caps(struct efx_nic *efx);


#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
void efx_set_default_rx_indir_table(struct efx_nic *efx);


#line 238  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
__inline static void efx_schedule_channel_0(struct efx_channel *channel)
{
  
#line 240 
  if (0) {
    
#line 240 
    if (((channel->efx)->msg_enable & 512U) != 0U) {
      int tmp_3;
      {
        int pscr_ret__;
        {
          
#line 240 
          void const *__vpp_verify = (void const *)0;
          
#line 240 
          void const *tmp = __vpp_verify;
        }
        
#line 240 
        switch (4UL) {
          int tmp_0;
          int tmp_0_0;
          int tmp_1;
          int tmp_2;
          case (unsigned long)1: 
#line 240 
          ;
          {
            int pfo_ret__;
            
#line 240 
            switch (4UL) {
              case (unsigned long)1: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55117;
              case (unsigned long)2: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55117;
              case (unsigned long)4: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55117;
              case (unsigned long)8: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55117;
              default: 
#line 240 
              ;
              
#line 240 
              __bad_percpu_size();
            }
            ldv_55117: 
#line 240 
            ;
            
#line 240 
            tmp_0 = pfo_ret__;
          }
          
#line 240 
          pscr_ret__ = tmp_0;
          
#line 240 
          goto ldv_55123;
          case (unsigned long)2: 
#line 240 
          ;
          {
            int pfo_ret___0;
            
#line 240 
            switch (4UL) {
              case (unsigned long)1: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55127;
              case (unsigned long)2: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55127;
              case (unsigned long)4: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55127;
              case (unsigned long)8: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55127;
              default: 
#line 240 
              ;
              
#line 240 
              __bad_percpu_size();
            }
            ldv_55127: 
#line 240 
            ;
            
#line 240 
            tmp_0_0 = pfo_ret___0;
          }
          
#line 240 
          pscr_ret__ = tmp_0_0;
          
#line 240 
          goto ldv_55123;
          case (unsigned long)4: 
#line 240 
          ;
          {
            int pfo_ret___1;
            
#line 240 
            switch (4UL) {
              case (unsigned long)1: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55136;
              case (unsigned long)2: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55136;
              case (unsigned long)4: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55136;
              case (unsigned long)8: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55136;
              default: 
#line 240 
              ;
              
#line 240 
              __bad_percpu_size();
            }
            ldv_55136: 
#line 240 
            ;
            
#line 240 
            tmp_1 = pfo_ret___1;
          }
          
#line 240 
          pscr_ret__ = tmp_1;
          
#line 240 
          goto ldv_55123;
          case (unsigned long)8: 
#line 240 
          ;
          {
            int pfo_ret___2;
            
#line 240 
            switch (4UL) {
              case (unsigned long)1: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55145;
              case (unsigned long)2: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55145;
              case (unsigned long)4: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55145;
              case (unsigned long)8: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55145;
              default: 
#line 240 
              ;
              
#line 240 
              __bad_percpu_size();
            }
            ldv_55145: 
#line 240 
            ;
            
#line 240 
            tmp_2 = pfo_ret___2;
          }
          
#line 240 
          pscr_ret__ = tmp_2;
          
#line 240 
          goto ldv_55123;
          default: 
#line 240 
          ;
          
#line 240 
          __bad_size_call_parameter();
          
#line 240 
          goto ldv_55123;
        }
        ldv_55123: 
#line 240 
        ;
        
#line 240 
        tmp_3 = pscr_ret__;
      }
      
#line 240 
      ;
      
#line 240 
      ;
      
#line 240 
      netdev_printk("\001",(struct net_device const *)(channel->efx)->net_dev,"channel %d scheduling NAPI poll on CPU%d\n",channel->channel,tmp_3);
    }
    else ;
  }
  else ;
  
#line 244 
  napi_schedule(& channel->napi_str);
  
#line 245 
  return;
}


#line 247  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
__inline static void efx_schedule_channel_irq_0(struct efx_channel *channel)
{
  int tmp_3;
  {
    int pscr_ret__;
    {
      
#line 249 
      void const *__vpp_verify = (void const *)0;
      
#line 249 
      void const *tmp = __vpp_verify;
    }
    
#line 249 
    switch (4UL) {
      int tmp_0;
      int tmp_0_0;
      int tmp_1;
      int tmp_2;
      case (unsigned long)1: 
#line 249 
      ;
      {
        int pfo_ret__;
        
#line 249 
        switch (4UL) {
          case (unsigned long)1: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55162;
          case (unsigned long)2: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55162;
          case (unsigned long)4: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55162;
          case (unsigned long)8: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55162;
          default: 
#line 249 
          ;
          
#line 249 
          __bad_percpu_size();
        }
        ldv_55162: 
#line 249 
        ;
        
#line 249 
        tmp_0 = pfo_ret__;
      }
      
#line 249 
      pscr_ret__ = tmp_0;
      
#line 249 
      goto ldv_55168;
      case (unsigned long)2: 
#line 249 
      ;
      {
        int pfo_ret___0;
        
#line 249 
        switch (4UL) {
          case (unsigned long)1: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55172;
          case (unsigned long)2: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55172;
          case (unsigned long)4: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55172;
          case (unsigned long)8: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55172;
          default: 
#line 249 
          ;
          
#line 249 
          __bad_percpu_size();
        }
        ldv_55172: 
#line 249 
        ;
        
#line 249 
        tmp_0_0 = pfo_ret___0;
      }
      
#line 249 
      pscr_ret__ = tmp_0_0;
      
#line 249 
      goto ldv_55168;
      case (unsigned long)4: 
#line 249 
      ;
      {
        int pfo_ret___1;
        
#line 249 
        switch (4UL) {
          case (unsigned long)1: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55181;
          case (unsigned long)2: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55181;
          case (unsigned long)4: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55181;
          case (unsigned long)8: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55181;
          default: 
#line 249 
          ;
          
#line 249 
          __bad_percpu_size();
        }
        ldv_55181: 
#line 249 
        ;
        
#line 249 
        tmp_1 = pfo_ret___1;
      }
      
#line 249 
      pscr_ret__ = tmp_1;
      
#line 249 
      goto ldv_55168;
      case (unsigned long)8: 
#line 249 
      ;
      {
        int pfo_ret___2;
        
#line 249 
        switch (4UL) {
          case (unsigned long)1: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55190;
          case (unsigned long)2: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55190;
          case (unsigned long)4: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55190;
          case (unsigned long)8: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55190;
          default: 
#line 249 
          ;
          
#line 249 
          __bad_percpu_size();
        }
        ldv_55190: 
#line 249 
        ;
        
#line 249 
        tmp_2 = pfo_ret___2;
      }
      
#line 249 
      pscr_ret__ = tmp_2;
      
#line 249 
      goto ldv_55168;
      default: 
#line 249 
      ;
      
#line 249 
      __bad_size_call_parameter();
      
#line 249 
      goto ldv_55168;
    }
    ldv_55168: 
#line 249 
    ;
    
#line 249 
    tmp_3 = pscr_ret__;
  }
  
#line 249 
  channel->event_test_cpu = tmp_3;
  
#line 250 
  efx_schedule_channel_0(channel);
  
#line 251 
  return;
}


#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
__inline static void efx_device_detach_sync_1(struct efx_nic *efx)
{
  
#line 259 
  struct net_device *dev = efx->net_dev;
  
#line 265 
  netif_tx_lock_bh_1(dev);
  
#line 266 
  netif_device_detach(dev);
  
#line 267 
  netif_tx_unlock_bh_1(dev);
  
#line 268 
  return;
}


#line 557  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
int efx_ptp_probe(struct efx_nic *efx, struct efx_channel *channel);


#line 559 
void efx_ptp_remove(struct efx_nic *efx);


#line 586 
struct efx_nic_type const efx_hunt_a0_nic_type;


#line 587 
struct efx_nic_type const efx_hunt_a0_vf_nic_type;


#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.h"
__inline static bool efx_ef10_sriov_wanted(struct efx_nic *efx)
{
  bool __retres;
  
#line 36 
  __retres = (_Bool)0;
  
#line 36 
  return __retres;
}


#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.h"
__inline static void efx_ef10_sriov_reset(struct efx_nic *efx)
{
  
#line 43 
  return;
}


#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10_sriov.h"
__inline static void efx_ef10_sriov_flr(struct efx_nic *efx, unsigned int vf_i)
{
  
#line 45 
  return;
}


#line 84  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_rx_free_indir_table(struct efx_nic *efx);


#line 85 
static void efx_ef10_filter_table_remove(struct efx_nic *efx);


#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_get_warm_boot_count(struct efx_nic *efx)
{
  int __retres;
  efx_dword_t reg;
  unsigned int tmp;
  
#line 91 
  efx_readd(efx,& reg,16U);
  
#line 92 
  if (reg.u32[0] >> 16 == 45063U) 
#line 92 
                                  tmp = reg.u32[0] & 65535U; else 
#line 92 
                                                                  tmp = 4294967291U;
  
#line 93 
  __retres = (int)tmp;
  
#line 93 
  return __retres;
}


#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static unsigned int efx_ef10_mem_map_size(struct efx_nic *efx)
{
  unsigned int __retres;
  int bar;
  resource_size_t tmp;
  
#line 100 
  bar = (int)(efx->type)->mem_bar;
  
#line 101 
  tmp = resource_size((struct resource const *)(& (efx->pci_dev)->resource[bar]));
  
#line 101 
  __retres = (unsigned int)tmp;
  
#line 101 
  return __retres;
}


#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static bool efx_ef10_is_vf(struct efx_nic *efx)
{
  bool __retres;
  
#line 106 
  __retres = (efx->type)->is_vf != 0;
  
#line 106 
  return __retres;
}


#line 109  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_get_pf_index(struct efx_nic *efx)
{
  int __retres;
  size_t outlen;
  int rc;
  
#line 111 
  efx_dword_t outbuf[2U] = {{.u32 = {0U}}};
  
#line 112 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 116 
  rc = efx_mcdi_rpc(efx,236U,(efx_dword_t const *)0,0UL,(efx_dword_t *)(& outbuf),8UL,& outlen);
  
#line 118 
  if (rc != 0) {
    
#line 119 
    __retres = rc;
    
#line 119 
    goto return_label;
  }
  else ;
  
#line 120 
  if (outlen <= 7UL) {
    
#line 121 
    __retres = -5;
    
#line 121 
    goto return_label;
  }
  else ;
  
#line 123 
  nic_data->pf_index = ((efx_dword_t *)(& outbuf))->u32[0];
  
#line 124 
  __retres = 0;
  return_label: 
#line 124 
                return __retres;
}


#line 128  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_get_vf_index(struct efx_nic *efx)
{
  int __retres;
  size_t outlen;
  int rc;
  
#line 130 
  efx_dword_t outbuf[2U] = {{.u32 = {0U}}};
  
#line 131 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 135 
  rc = efx_mcdi_rpc(efx,236U,(efx_dword_t const *)0,0UL,(efx_dword_t *)(& outbuf),8UL,& outlen);
  
#line 137 
  if (rc != 0) {
    
#line 138 
    __retres = rc;
    
#line 138 
    goto return_label;
  }
  else ;
  
#line 139 
  if (outlen <= 7UL) {
    
#line 140 
    __retres = -5;
    
#line 140 
    goto return_label;
  }
  else ;
  
#line 142 
  nic_data->vf_index = ((efx_dword_t *)(& outbuf) + 1U)->u32[0];
  
#line 143 
  __retres = 0;
  return_label: 
#line 143 
                return __retres;
}


#line 154 
void __compiletime_assert_154(void);


#line 147  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_init_datapath_caps(struct efx_nic *efx)
{
  int __retres;
  size_t outlen;
  int rc;
  
#line 149 
  efx_dword_t outbuf[5U] = {{.u32 = {0U}}};
  
#line 150 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  {
    
#line 154 
    bool __cond = (_Bool)0;
    
#line 154 
    if ((int)__cond != 0) 
#line 154 
                          __compiletime_assert_154(); else ;
  }
  
#line 156 
  rc = efx_mcdi_rpc(efx,190U,(efx_dword_t const *)0,0UL,(efx_dword_t *)(& outbuf),20UL,& outlen);
  
#line 158 
  if (rc != 0) {
    
#line 159 
    __retres = rc;
    
#line 159 
    goto return_label;
  }
  else ;
  
#line 160 
  if (outlen <= 19UL) {
    
#line 161 
    if ((efx->msg_enable & 1U) != 0U) 
#line 161 
                                      netdev_err((struct net_device const *)efx->net_dev,"unable to read datapath firmware capabilities\n"); else ;
    
#line 163 
    __retres = -5;
    
#line 163 
    goto return_label;
  }
  else ;
  
#line 166 
  nic_data->datapath_caps = ((efx_dword_t *)(& outbuf))->u32[0];
  
#line 171 
  nic_data->rx_dpcpu_fw_id = (unsigned int)*((__le16 const *)(& outbuf) + 4U);
  
#line 173 
  nic_data->tx_dpcpu_fw_id = (unsigned int)*((__le16 const *)(& outbuf) + 6U);
  
#line 176 
  if ((nic_data->datapath_caps & 2097152U) == 0U) {
    
#line 178 
    if ((efx->msg_enable & 1U) != 0U) 
#line 178 
                                      netdev_err((struct net_device const *)efx->net_dev,"current firmware does not support TSO\n"); else ;
    
#line 180 
    __retres = -19;
    
#line 180 
    goto return_label;
  }
  else ;
  
#line 183 
  if ((nic_data->datapath_caps & 8388608U) == 0U) {
    
#line 185 
    if ((efx->msg_enable & 2U) != 0U) 
#line 185 
                                      netdev_err((struct net_device const *)efx->net_dev,"current firmware does not support an RX prefix\n"); else ;
    
#line 187 
    __retres = -19;
    
#line 187 
    goto return_label;
  }
  else ;
  
#line 190 
  __retres = 0;
  return_label: 
#line 190 
                return __retres;
}


#line 193  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_get_sysclk_freq(struct efx_nic *efx)
{
  int __retres;
  int rc;
  int tmp;
  
#line 195 
  efx_dword_t outbuf[2U] = {{.u32 = {0U}}};
  
#line 198 
  rc = efx_mcdi_rpc(efx,172U,(efx_dword_t const *)0,0UL,(efx_dword_t *)(& outbuf),8UL,(size_t *)0UL);
  
#line 200 
  if (rc != 0) {
    
#line 201 
    __retres = rc;
    
#line 201 
    goto return_label;
  }
  else ;
  
#line 202 
  rc = (int)((efx_dword_t *)(& outbuf))->u32[0];
  
#line 203 
  if (rc > 0) 
#line 203 
              tmp = rc; else 
#line 203 
                             tmp = -34;
  
#line 203 
  __retres = tmp;
  return_label: 
#line 203 
                return __retres;
}


#line 212 
void __compiletime_assert_212(void);


#line 206  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_get_mac_address_pf(struct efx_nic *efx, u8 *mac_address)
{
  int __retres;
  size_t outlen;
  int rc;
  
#line 208 
  efx_dword_t outbuf[4U] = {{.u32 = {0U}}};
  {
    
#line 212 
    bool __cond = (_Bool)0;
    
#line 212 
    if ((int)__cond != 0) 
#line 212 
                          __compiletime_assert_212(); else ;
  }
  
#line 214 
  rc = efx_mcdi_rpc(efx,85U,(efx_dword_t const *)0,0UL,(efx_dword_t *)(& outbuf),16UL,& outlen);
  
#line 216 
  if (rc != 0) {
    
#line 217 
    __retres = rc;
    
#line 217 
    goto return_label;
  }
  else ;
  
#line 218 
  if (outlen <= 15UL) {
    
#line 219 
    __retres = -5;
    
#line 219 
    goto return_label;
  }
  else ;
  
#line 221 
  ether_addr_copy(mac_address,(u8 const *)(& outbuf));
  
#line 223 
  __retres = 0;
  return_label: 
#line 223 
                return __retres;
}


#line 226  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_get_mac_address_vf(struct efx_nic *efx, u8 *mac_address)
{
  int __retres;
  size_t outlen;
  int num_addrs;
  int rc;
  
#line 228 
  efx_dword_t inbuf[1U] = {{.u32 = {0U}}};
  
#line 229 
  efx_dword_t outbuf[63U] = {{.u32 = {0U}}};
  
#line 233 
  ((efx_dword_t *)(& inbuf))->u32[0] = 16777216U;
  
#line 235 
  rc = efx_mcdi_rpc(efx,170U,(efx_dword_t const *)(& inbuf),4UL,(efx_dword_t *)(& outbuf),252UL,& outlen);
  
#line 238 
  if (rc != 0) {
    
#line 239 
    __retres = rc;
    
#line 239 
    goto return_label;
  }
  else ;
  
#line 240 
  if (outlen <= 3UL) {
    
#line 241 
    __retres = -5;
    
#line 241 
    goto return_label;
  }
  else ;
  
#line 243 
  num_addrs = (int)((efx_dword_t *)(& outbuf))->u32[0];
  {
    
#line 246 
    int __ret_warn_on = num_addrs != 1;
    
#line 246 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 246 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c",246); else ;
    
#line 246 
    long tmp = (long)(__ret_warn_on != 0);
  }
  
#line 248 
  ether_addr_copy(mac_address,(u8 const *)(& outbuf) + 4U);
  
#line 251 
  __retres = 0;
  return_label: 
#line 251 
                return __retres;
}


#line 254  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static ssize_t efx_ef10_show_link_control_flag(struct device *dev, struct device_attribute *attr, char *buf)
{
  ssize_t __retres;
  struct efx_nic *tmp_0;
  struct pci_dev *tmp;
  int tmp_1;
  {
    
#line 258 
    struct device const *__mptr = (struct device const *)dev;
    
#line 258 
    tmp = (struct pci_dev *)__mptr + 18446744073709551464U;
  }
  
#line 258 
  tmp_0 = (struct efx_nic *)pci_get_drvdata(tmp);
  
#line 258 
  struct efx_nic *efx = tmp_0;
  
#line 260 
  tmp_1 = sprintf(buf,"%d\n",(int)((efx->mcdi)->fn_flags >> 1) & 1);
  
#line 260 
  __retres = (long)tmp_1;
  
#line 260 
  return __retres;
}


#line 266  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static ssize_t efx_ef10_show_primary_flag(struct device *dev, struct device_attribute *attr, char *buf)
{
  ssize_t __retres;
  struct efx_nic *tmp_0;
  struct pci_dev *tmp;
  int tmp_1;
  {
    
#line 270 
    struct device const *__mptr = (struct device const *)dev;
    
#line 270 
    tmp = (struct pci_dev *)__mptr + 18446744073709551464U;
  }
  
#line 270 
  tmp_0 = (struct efx_nic *)pci_get_drvdata(tmp);
  
#line 270 
  struct efx_nic *efx = tmp_0;
  
#line 272 
  tmp_1 = sprintf(buf,"%d\n",(int)(efx->mcdi)->fn_flags & 1);
  
#line 272 
  __retres = (long)tmp_1;
  
#line 272 
  return __retres;
}


#line 278  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static struct device_attribute dev_attr_link_control_flag = {.attr = {.name = "link_control_flag", .mode = (unsigned short)292U, .ignore_lockdep = (_Bool)0, .key = (struct lock_class_key *)0, .skey = {.subkeys = {{.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}}}}, .show = & efx_ef10_show_link_control_flag, .store = (ssize_t (*)(struct device *, struct device_attribute *, char const *, size_t ))0};

#line 280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static struct device_attribute dev_attr_primary_flag = {.attr = {.name = "primary_flag", .mode = (unsigned short)292U, .ignore_lockdep = (_Bool)0, .key = (struct lock_class_key *)0, .skey = {.subkeys = {{.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}}}}, .show = & efx_ef10_show_primary_flag, .store = (ssize_t (*)(struct device *, struct device_attribute *, char const *, size_t ))0};

#line 305 
void __compiletime_assert_305(void);


#line 282  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_probe(struct efx_nic *efx)
{
  int __retres;
  struct efx_ef10_nic_data *nic_data;
  int i;
  int rc;
  unsigned int tmp_1;
  int tmp_2;
  
#line 285 
  struct net_device *net_dev = efx->net_dev;
  {
    unsigned int tmp;
    unsigned int tmp_0;
    
#line 292 
    unsigned int __min1 = 32U;
    
#line 292 
    tmp = efx_ef10_mem_map_size(efx);
    
#line 292 
    unsigned int __min2 = tmp / 32768U;
    
#line 292 
    if (__min1 < __min2) 
#line 292 
                         tmp_0 = __min1; else 
#line 292 
                                              tmp_0 = __min2;
    
#line 292 
    tmp_1 = tmp_0;
  }
  
#line 291 
  efx->max_channels = tmp_1;
  {
    
#line 296 
    int __ret_warn_on = efx->max_channels == 0U;
    
#line 296 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 296 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c",296); else ;
    
#line 296 
    tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 296 
  if ((long)tmp_2 != 0L) {
    
#line 297 
    __retres = -5;
    
#line 297 
    goto return_label;
  }
  else ;
  
#line 299 
  nic_data = (struct efx_ef10_nic_data *)kzalloc_6(784UL,208U);
  
#line 300 
  if (nic_data == (struct efx_ef10_nic_data *)0) {
    
#line 301 
    __retres = -12;
    
#line 301 
    goto return_label;
  }
  else ;
  
#line 302 
  efx->nic_data = (void *)nic_data;
  {
    
#line 305 
    bool __cond = (_Bool)0;
    
#line 305 
    if ((int)__cond != 0) 
#line 305 
                          __compiletime_assert_305(); else ;
  }
  
#line 307 
  rc = efx_nic_alloc_buffer(efx,& nic_data->mcdi_buf,1032U,208U);
  
#line 309 
  if (rc != 0) 
#line 310 
               goto fail1; else ;
  
#line 315 
  i = 0;
  ldv_56133: 
#line 316 
  ;
  
#line 317 
  rc = efx_ef10_get_warm_boot_count(efx);
  
#line 318 
  if (rc >= 0) 
#line 319 
               goto ldv_56131; else ;
  
#line 320 
  i += 1;
  
#line 320 
  if (i == 5) 
#line 321 
              goto fail2; else ;
  
#line 322 
  ssleep(1U);
  
#line 317 
  goto ldv_56133;
  ldv_56131: 
#line 318 
  ;
  
#line 324 
  nic_data->warm_boot_count = (unsigned short)rc;
  
#line 326 
  nic_data->rx_rss_context = 4294967295U;
  
#line 328 
  nic_data->vport_id = 16777216U;
  
#line 335 
  _efx_writed(efx,1U,516U);
  
#line 337 
  rc = efx_mcdi_init(efx);
  
#line 338 
  if (rc != 0) 
#line 339 
               goto fail2; else ;
  
#line 342 
  rc = efx_mcdi_reset(efx,(enum reset_type)RESET_TYPE_ALL);
  
#line 343 
  if (rc != 0) 
#line 344 
               goto fail3; else ;
  
#line 347 
  rc = efx_mcdi_log_ctrl(efx,(_Bool)1,(_Bool)0,0U);
  
#line 348 
  if (rc != 0) 
#line 349 
               goto fail3; else ;
  
#line 351 
  rc = ldv_device_create_file_97(& (efx->pci_dev)->dev,(struct device_attribute const *)(& dev_attr_link_control_flag));
  
#line 353 
  if (rc != 0) 
#line 354 
               goto fail3; else ;
  
#line 356 
  rc = ldv_device_create_file_98(& (efx->pci_dev)->dev,(struct device_attribute const *)(& dev_attr_primary_flag));
  
#line 357 
  if (rc != 0) 
#line 358 
               goto fail4; else ;
  
#line 360 
  rc = efx_ef10_get_pf_index(efx);
  
#line 361 
  if (rc != 0) 
#line 362 
               goto fail5; else ;
  
#line 364 
  rc = efx_ef10_init_datapath_caps(efx);
  
#line 365 
  if (rc < 0) 
#line 366 
              goto fail5; else ;
  
#line 368 
  efx->rx_packet_len_offset = -6;
  
#line 371 
  rc = efx_mcdi_port_get_number(efx);
  
#line 372 
  if (rc < 0) 
#line 373 
              goto fail5; else ;
  
#line 374 
  efx->port_num = (unsigned int)rc;
  
#line 375 
  net_dev->dev_port = (unsigned short)rc;
  
#line 377 
  rc = (*((efx->type)->get_mac_address))(efx,(unsigned char *)(& (efx->net_dev)->perm_addr));
  
#line 378 
  if (rc != 0) 
#line 379 
               goto fail5; else ;
  
#line 381 
  rc = efx_ef10_get_sysclk_freq(efx);
  
#line 382 
  if (rc < 0) 
#line 383 
              goto fail5; else ;
  
#line 384 
  efx->timer_quantum_ns = (unsigned int)(1536000 / rc);
  
#line 390 
  rc = efx_mcdi_set_workaround(efx,2U,(_Bool)1);
  
#line 391 
  if (rc == 0) 
#line 392 
               nic_data->workaround_35388 = (_Bool)1;
  else 
    
#line 393 
    if (rc == -1) {
      unsigned int enabled;
      
#line 396 
      rc = efx_mcdi_get_workarounds(efx,(unsigned int *)0U,& enabled);
      
#line 397 
      if (rc != 0) 
#line 398 
                   goto fail3; else ;
      
#line 399 
      nic_data->workaround_35388 = (_Bool)((enabled & 4U) != 0U);
    }
    else 
      
#line 401 
      if (rc != -38 && rc != -2) 
#line 402 
                                 goto fail5; else ;
  
#line 404 
  if ((efx->msg_enable & 2U) != 0U) {
    
#line 404 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_ef10_probe", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c", .format = "workaround for bug 35388 is %sabled\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))406U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 404 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      char *tmp_4;
      
#line 404 
      if ((int)nic_data->workaround_35388 != 0) 
#line 404 
                                                tmp_4 = (char *)"en"; else 
                                                                    
#line 404 
                                                                    tmp_4 = (char *)"dis";
      
#line 404 
      ;
      
#line 404 
      __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"workaround for bug 35388 is %sabled\n",tmp_4);
    }
    else ;
  }
  else ;
  
#line 408 
  rc = efx_mcdi_mon_probe(efx);
  
#line 409 
  if ((unsigned int)rc + 1U > 1U) 
#line 410 
                                  goto fail5; else ;
  
#line 412 
  efx_ptp_probe(efx,(struct efx_channel *)0);
  
#line 415 
  if ((efx->pci_dev)->__anonCompField_pci_dev_64.physfn != (struct pci_dev *)0 && (unsigned int)*((unsigned char *)efx->pci_dev + 2531UL) == 0U) {
    
#line 416 
    struct pci_dev *pci_dev_pf = (efx->pci_dev)->__anonCompField_pci_dev_64.physfn;
    
#line 417 
    struct efx_nic *efx_pf = pci_get_drvdata(pci_dev_pf);
    
#line 419 
    (*((efx_pf->type)->get_mac_address))(efx_pf,(unsigned char *)(& nic_data->port_id));
  }
  else 
#line 422 
       ether_addr_copy((u8 *)(& nic_data->port_id),(u8 const *)(& (efx->net_dev)->perm_addr));
  
#line 424 
  __retres = 0;
  
#line 424 
  goto return_label;
  fail5: 
#line 426 
  ;
  
#line 427 
  ldv_device_remove_file_99(& (efx->pci_dev)->dev,(struct device_attribute const *)(& dev_attr_primary_flag));
  fail4: 
#line 428 
  ;
  
#line 429 
  ldv_device_remove_file_100(& (efx->pci_dev)->dev,(struct device_attribute const *)(& dev_attr_link_control_flag));
  fail3: 
#line 430 
  ;
  
#line 431 
  efx_mcdi_fini(efx);
  fail2: 
#line 432 
  ;
  
#line 433 
  efx_nic_free_buffer(efx,& nic_data->mcdi_buf);
  fail1: 
#line 434 
  ;
  
#line 435 
  kfree((void const *)nic_data);
  
#line 436 
  efx->nic_data = (void *)0;
  
#line 437 
  __retres = rc;
  return_label: 
#line 437 
                return __retres;
}


#line 440  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_free_vis(struct efx_nic *efx)
{
  size_t outlen;
  
#line 442 
  efx_dword_t outbuf[2U] = {{.u32 = {0U}}};
  
#line 444 
  int rc = efx_mcdi_rpc_quiet(efx,140U,(efx_dword_t const *)0,0UL,(efx_dword_t *)(& outbuf),8UL,& outlen);
  
#line 448 
  if (rc == -114) 
#line 449 
                  rc = 0; else ;
  
#line 450 
  if (rc != 0) 
#line 451 
               efx_mcdi_display_error(efx,140U,0UL,(efx_dword_t *)(& outbuf),outlen,rc); else ;
  
#line 453 
  return rc;
}


#line 465 
void __compiletime_assert_465(void);


#line 458  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_free_piobufs(struct efx_nic *efx)
{
  unsigned int i;
  int rc;
  
#line 460 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 461 
  efx_dword_t inbuf[1U] = {{.u32 = {0U}}};
  {
    
#line 465 
    bool __cond = (_Bool)0;
    
#line 465 
    if ((int)__cond != 0) 
#line 465 
                          __compiletime_assert_465(); else ;
  }
  
#line 467 
  i = 0U;
  
#line 467 
  goto ldv_56165;
  ldv_56164: 
#line 468 
  ;
  
#line 468 
  ((efx_dword_t *)(& inbuf))->u32[0] = nic_data->piobuf_handle[i];
  
#line 470 
  rc = efx_mcdi_rpc(efx,144U,(efx_dword_t const *)(& inbuf),4UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  {
    
#line 472 
    int __ret_warn_on = rc != 0;
    
#line 472 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 472 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c",472); else ;
    
#line 472 
    long tmp = (long)(__ret_warn_on != 0);
  }
  
#line 467 
  i += 1U;
  ldv_56165: 
#line 468 
  ;
  
#line 467 
  if (nic_data->n_piobufs > i) 
#line 469 
                               goto ldv_56164; else 
#line 472 
                                                    goto ldv_56166;
  ldv_56166: 
#line 473 
  ;
  
#line 475 
  nic_data->n_piobufs = 0U;
  
#line 476 
  return;
}


#line 486 
void __compiletime_assert_486(void);


#line 478  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_alloc_piobufs(struct efx_nic *efx, unsigned int n)
{
  unsigned int i;
  size_t outlen;
  
#line 480 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 481 
  efx_dword_t outbuf[1U] = {{.u32 = {0U}}};
  
#line 484 
  int rc = 0;
  {
    
#line 486 
    bool __cond = (_Bool)0;
    
#line 486 
    if ((int)__cond != 0) 
#line 486 
                          __compiletime_assert_486(); else ;
  }
  
#line 488 
  i = 0U;
  
#line 488 
  goto ldv_56190;
  ldv_56189: 
#line 489 
  ;
  
#line 489 
  rc = efx_mcdi_rpc(efx,143U,(efx_dword_t const *)0,0UL,(efx_dword_t *)(& outbuf),4UL,& outlen);
  
#line 491 
  if (rc != 0) 
#line 492 
               goto ldv_56180; else ;
  
#line 493 
  if (outlen <= 3UL) {
    
#line 494 
    rc = -5;
    
#line 495 
    goto ldv_56180;
  }
  else ;
  
#line 497 
  nic_data->piobuf_handle[i] = ((efx_dword_t *)(& outbuf))->u32[0];
  
#line 499 
  if ((efx->msg_enable & 2U) != 0U) {
    
#line 499 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_ef10_alloc_piobufs", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c", .format = "allocated PIO buffer %u handle %x\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))501U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 499 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 499 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"allocated PIO buffer %u handle %x\n",i,nic_data->piobuf_handle[i]); else ;
  }
  else ;
  
#line 488 
  i += 1U;
  ldv_56190: 
#line 489 
  ;
  
#line 488 
  if (i < n) 
#line 490 
             goto ldv_56189; else 
#line 493 
                                  goto ldv_56180;
  ldv_56180: 
#line 494 
  ;
  
#line 504 
  nic_data->n_piobufs = i;
  
#line 505 
  if (rc != 0) 
#line 506 
               efx_ef10_free_piobufs(efx); else ;
  
#line 507 
  return rc;
}


#line 521 
void __compiletime_assert_521(void);


#line 522 
void __compiletime_assert_522(void);

 __attribute__((__FC_BUILTIN__)) void __fc_vla_free(void *p);

 __attribute__((__FC_BUILTIN__)) void *__fc_vla_alloc(unsigned long size);


#line 510  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_link_piobufs(struct efx_nic *efx)
{
  int __retres;
  unsigned long __lengthof_inbuf;
  int tmp_0;
  struct efx_channel *channel;
  struct efx_tx_queue *tx_queue;
  unsigned int offset;
  unsigned int index;
  int rc;
  int tmp_2;
  int tmp_4;
  int tmp_7;
  bool tmp_6;
  unsigned int tmp_8;
  
#line 512 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  {
    int tmp;
    
#line 513 
    int _max1 = 8;
    
#line 513 
    int _max2 = 4;
    
#line 513 
    if (_max1 > _max2) 
#line 513 
                       tmp = _max1; else 
#line 513 
                                         tmp = _max2;
    
#line 513 
    tmp_0 = tmp;
  }
  
#line 515 
  ;
  
#line 515 
  __lengthof_inbuf = (unsigned long)((long)((tmp_0 + 3) / 4) + 0L);
  
#line 515 
  efx_dword_t *inbuf = __fc_vla_alloc(sizeof(efx_dword_t) * __lengthof_inbuf);
  {
    int tmp_1;
    
#line 513 
    int _max1_0 = 8;
    
#line 513 
    int _max2_0 = 4;
    
#line 513 
    if (_max1_0 > _max2_0) 
#line 513 
                           tmp_1 = _max1_0; else 
#line 513 
                                                 tmp_1 = _max2_0;
    
#line 513 
    tmp_2 = tmp_1;
  }
  {
    
#line 521 
    bool __cond = (_Bool)0;
    
#line 521 
    if ((int)__cond != 0) 
#line 521 
                          __compiletime_assert_521(); else ;
  }
  {
    
#line 522 
    bool __cond_0 = (_Bool)0;
    
#line 522 
    if ((int)__cond_0 != 0) 
#line 522 
                            __compiletime_assert_522(); else ;
  }
  {
    int tmp_3;
    
#line 513 
    int _max1_1 = 8;
    
#line 513 
    int _max2_1 = 4;
    
#line 513 
    if (_max1_1 > _max2_1) 
#line 513 
                           tmp_3 = _max1_1; else 
#line 513 
                                                 tmp_3 = _max2_1;
    
#line 513 
    tmp_4 = tmp_3;
  }
  
#line 524 
  memset((void *)(& inbuf),0,(unsigned long)((unsigned int)((tmp_4 + 3) / 4) * 4U));
  
#line 527 
  index = 0U;
  
#line 527 
  goto ldv_56222;
  ldv_56221: 
#line 528 
  ;
  
#line 528 
  ((efx_dword_t *)(& inbuf))->u32[0] = nic_data->piobuf_handle[index];
  
#line 530 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = nic_data->pio_write_vi_base + index;
  
#line 532 
  rc = efx_mcdi_rpc(efx,146U,(efx_dword_t const *)(& inbuf),8UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 535 
  if (rc != 0) {
    
#line 536 
    if ((efx->msg_enable & 1U) != 0U) 
#line 536 
                                      netdev_err((struct net_device const *)efx->net_dev,"failed to link VI %u to PIO buffer %u (%d)\n",nic_data->pio_write_vi_base + index,index,rc); else ;
    
#line 540 
    goto fail;
  }
  else ;
  
#line 542 
  if ((efx->msg_enable & 2U) != 0U) {
    
#line 542 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_ef10_link_piobufs", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c", .format = "linked VI %u to PIO buffer %u\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))544U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 542 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 542 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"linked VI %u to PIO buffer %u\n",nic_data->pio_write_vi_base + index,index); else ;
  }
  else ;
  
#line 527 
  index += 1U;
  ldv_56222: 
#line 528 
  ;
  
#line 527 
  if (nic_data->n_piobufs > index) 
#line 529 
                                   goto ldv_56221; else 
#line 532 
                                                        goto ldv_56223;
  ldv_56223: 
#line 533 
  ;
  
#line 548 
  channel = efx->channel[0];
  
#line 548 
  goto ldv_56235;
  ldv_56234: 
#line 549 
  ;
  
#line 549 
  tmp_6 = efx_channel_has_tx_queues(channel);
  
#line 549 
  if (tmp_6) 
#line 549 
             tmp_7 = 0; else 
#line 549 
                             tmp_7 = 1;
  
#line 549 
  if (tmp_7) ;
  else {
    
#line 549 
    tx_queue = (struct efx_tx_queue *)(& channel->tx_queue);
    
#line 549 
    goto ldv_56232;
    ldv_56231: 
#line 550 
    ;
    
#line 554 
    offset = (((efx->tx_channel_offset + efx->n_tx_channels) - (unsigned int)(tx_queue->channel)->channel) + 4294967295U) * efx_piobuf_size;
    
#line 557 
    index = offset / 2048U;
    
#line 558 
    offset &= 2047U;
    
#line 565 
    if (tx_queue->queue == nic_data->pio_write_vi_base) {
      
#line 566 
      if ((long)(index != 0U) != 0L) {
        
#line 568 
        ldv_inline_asm();
        
#line 566 
        ;
      }
      else ;
      
#line 567 
      rc = 0;
    }
    else {
      
#line 569 
      ((efx_dword_t *)(& inbuf))->u32[0] = nic_data->piobuf_handle[index];
      
#line 572 
      ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = tx_queue->queue;
      
#line 575 
      rc = efx_mcdi_rpc(efx,146U,(efx_dword_t const *)(& inbuf),8UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
    }
    
#line 580 
    if (rc != 0) {
      
#line 584 
      if ((efx->msg_enable & 1U) != 0U) 
#line 584 
                                        netdev_err((struct net_device const *)efx->net_dev,"failed to link VI %u to PIO buffer %u (%d)\n",tx_queue->queue,index,rc); else ;
      
#line 587 
      tx_queue->piobuf = (void *)0;
    }
    else {
      
#line 589 
      tx_queue->piobuf = nic_data->pio_write_base + (index * 8192U + offset);
      
#line 592 
      tx_queue->piobuf_offset = offset;
      
#line 593 
      if ((efx->msg_enable & 2U) != 0U) {
        
#line 593 
        struct _ddebug descriptor_0 = {.modname = "sfc", .function = "efx_ef10_link_piobufs", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c", .format = "linked VI %u to PIO buffer %u offset %x addr %p\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))597U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 593 
        if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 593 
                                                              __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)efx->net_dev,"linked VI %u to PIO buffer %u offset %x addr %p\n",tx_queue->queue,index,tx_queue->piobuf_offset,tx_queue->piobuf); else ;
      }
      else ;
    }
    
#line 549 
    tx_queue += 1;
    ldv_56232: 
#line 550 
    ;
    
#line 549 
    if ((struct efx_tx_queue *)(& channel->tx_queue) + 4U > tx_queue) {
      bool tmp_5;
      
#line 549 
      tmp_5 = efx_tx_queue_used(tx_queue);
      
#line 549 
      if ((int)tmp_5 != 0) 
#line 551 
                           goto ldv_56231; else 
#line 554 
                                                goto ldv_56233;
    }
    else 
#line 554 
         goto ldv_56233;
    ldv_56233: 
#line 555 
    ;
  }
  
#line 548 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 548 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 548 
                                                                    channel = (struct efx_channel *)0;
  ldv_56235: 
#line 549 
  ;
  
#line 548 
  if (channel != (struct efx_channel *)0) 
#line 550 
                                          goto ldv_56234; else 
#line 553 
                                                               goto ldv_56236;
  ldv_56236: 
#line 554 
  ;
  
#line 602 
  __retres = 0;
  
#line 602 
  goto return_label;
  fail: 
#line 604 
  ;
  
#line 605 
  goto ldv_56241;
  ldv_56240: 
#line 606 
  ;
  
#line 606 
  ((efx_dword_t *)(& inbuf))->u32[0] = nic_data->pio_write_vi_base + index;
  
#line 608 
  efx_mcdi_rpc(efx,147U,(efx_dword_t const *)(& inbuf),4UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  ldv_56241: 
#line 610 
  ;
  
#line 605 
  tmp_8 = index;
  
#line 605 
  index -= 1U;
  
#line 605 
  ;
  
#line 605 
  if (tmp_8 != 0U) 
#line 607 
                   goto ldv_56240; else 
#line 610 
                                        goto ldv_56242;
  ldv_56242: 
#line 611 
  ;
  
#line 612 
  __retres = rc;
  return_label: 
#line 515 
  __fc_vla_free((void *)inbuf);
  
#line 612 
  return __retres;
}


#line 633  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_remove(struct efx_nic *efx)
{
  int rc;
  struct efx_ef10_nic_data *nic_data_pf;
  struct pci_dev *pci_dev_pf;
  struct efx_nic *efx_pf;
  struct ef10_vf *vf;
  
#line 635 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 644 
  if ((unsigned int)*((unsigned char *)efx->pci_dev + 2531UL) != 0U) {
    
#line 645 
    pci_dev_pf = (efx->pci_dev)->__anonCompField_pci_dev_64.physfn;
    
#line 646 
    if (pci_dev_pf != (struct pci_dev *)0) {
      
#line 647 
      efx_pf = (struct efx_nic *)pci_get_drvdata(pci_dev_pf);
      
#line 648 
      nic_data_pf = (struct efx_ef10_nic_data *)efx_pf->nic_data;
      
#line 649 
      vf = nic_data_pf->vf + nic_data->vf_index;
      
#line 650 
      vf->efx = (struct efx_nic *)0;
    }
    else 
      
#line 652 
      if ((efx->msg_enable & 1U) != 0U) 
#line 652 
                                        netdev_info((struct net_device const *)efx->net_dev,"Could not get the PF id from VF\n"); else ;
  }
  else ;
  
#line 657 
  efx_ptp_remove(efx);
  
#line 659 
  efx_mcdi_mon_remove(efx);
  
#line 661 
  efx_ef10_rx_free_indir_table(efx);
  
#line 663 
  if (nic_data->wc_membase != (void *)0) 
#line 664 
                                         iounmap((void volatile *)nic_data->wc_membase); else ;
  
#line 666 
  rc = efx_ef10_free_vis(efx);
  {
    
#line 667 
    int __ret_warn_on = rc != 0;
    
#line 667 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 667 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c",667); else ;
    
#line 667 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 669 
  if (! nic_data->must_restore_piobufs) 
#line 670 
                                        efx_ef10_free_piobufs(efx); else ;
  
#line 672 
  ldv_device_remove_file_101(& (efx->pci_dev)->dev,(struct device_attribute const *)(& dev_attr_primary_flag));
  
#line 673 
  ldv_device_remove_file_102(& (efx->pci_dev)->dev,(struct device_attribute const *)(& dev_attr_link_control_flag));
  
#line 675 
  efx_mcdi_fini(efx);
  
#line 676 
  efx_nic_free_buffer(efx,& nic_data->mcdi_buf);
  
#line 677 
  kfree((void const *)nic_data);
  
#line 678 
  return;
}


#line 680  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_probe_pf(struct efx_nic *efx)
{
  int tmp;
  
#line 682 
  tmp = efx_ef10_probe(efx);
  
#line 682 
  return tmp;
}


#line 685  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
int efx_ef10_vadaptor_alloc(struct efx_nic *efx, unsigned int port_id)
{
  int tmp;
  
#line 687 
  efx_dword_t inbuf[8U] = {{.u32 = {0U}}};
  
#line 689 
  ((efx_dword_t *)(& inbuf))->u32[0] = port_id;
  
#line 690 
  tmp = efx_mcdi_rpc(efx,152U,(efx_dword_t const *)(& inbuf),32UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 690 
  return tmp;
}


#line 694  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
int efx_ef10_vadaptor_free(struct efx_nic *efx, unsigned int port_id)
{
  int tmp;
  
#line 696 
  efx_dword_t inbuf[1U] = {{.u32 = {0U}}};
  
#line 698 
  ((efx_dword_t *)(& inbuf))->u32[0] = port_id;
  
#line 699 
  tmp = efx_mcdi_rpc(efx,153U,(efx_dword_t const *)(& inbuf),4UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 699 
  return tmp;
}


#line 703  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
int efx_ef10_vport_add_mac(struct efx_nic *efx, unsigned int port_id, u8 *mac)
{
  int tmp;
  
#line 706 
  efx_dword_t inbuf[3U] = {{.u32 = {0U}}};
  
#line 708 
  ((efx_dword_t *)(& inbuf))->u32[0] = port_id;
  
#line 709 
  ether_addr_copy((u8 *)(& inbuf) + 4U,(u8 const *)mac);
  
#line 711 
  tmp = efx_mcdi_rpc(efx,168U,(efx_dword_t const *)(& inbuf),12UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 711 
  return tmp;
}


#line 715  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
int efx_ef10_vport_del_mac(struct efx_nic *efx, unsigned int port_id, u8 *mac)
{
  int tmp;
  
#line 718 
  efx_dword_t inbuf[3U] = {{.u32 = {0U}}};
  
#line 720 
  ((efx_dword_t *)(& inbuf))->u32[0] = port_id;
  
#line 721 
  ether_addr_copy((u8 *)(& inbuf) + 4U,(u8 const *)mac);
  
#line 723 
  tmp = efx_mcdi_rpc(efx,169U,(efx_dword_t const *)(& inbuf),12UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 723 
  return tmp;
}


#line 728  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_probe_vf(struct efx_nic *efx)
{
  int __retres;
  int rc;
  struct pci_dev *pci_dev_pf;
  
#line 737 
  pci_dev_pf = (efx->pci_dev)->__anonCompField_pci_dev_64.physfn;
  
#line 738 
  if (pci_dev_pf != (struct pci_dev *)0) {
    
#line 739 
    struct efx_nic *efx_pf = pci_get_drvdata(pci_dev_pf);
    
#line 740 
    struct efx_ef10_nic_data *nic_data_pf = (struct efx_ef10_nic_data *)efx_pf->nic_data;
    
#line 742 
    if (nic_data_pf->vf == (struct ef10_vf *)0) {
      
#line 743 
      if ((efx->msg_enable & 1U) != 0U) 
#line 743 
                                        netdev_info((struct net_device const *)efx->net_dev,"The VF cannot link to its parent PF; "); else ;
      
#line 746 
      __retres = -16;
      
#line 746 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 750 
  rc = efx_ef10_probe(efx);
  
#line 751 
  if (rc != 0) {
    
#line 752 
    __retres = rc;
    
#line 752 
    goto return_label;
  }
  else ;
  
#line 754 
  rc = efx_ef10_get_vf_index(efx);
  
#line 755 
  if (rc != 0) 
#line 756 
               goto fail; else ;
  
#line 758 
  if ((unsigned int)*((unsigned char *)efx->pci_dev + 2531UL) != 0U) {
    
#line 759 
    if ((efx->pci_dev)->__anonCompField_pci_dev_64.physfn != (struct pci_dev *)0) {
      
#line 761 
      struct efx_nic *efx_pf_0 = pci_get_drvdata((efx->pci_dev)->__anonCompField_pci_dev_64.physfn);
      
#line 762 
      struct efx_ef10_nic_data *nic_data_p = (struct efx_ef10_nic_data *)efx_pf_0->nic_data;
      
#line 763 
      struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
      
#line 765 
      (nic_data_p->vf + nic_data->vf_index)->efx = efx;
      
#line 766 
      (nic_data_p->vf + nic_data->vf_index)->pci_dev = efx->pci_dev;
    }
    else 
      
#line 769 
      if ((efx->msg_enable & 1U) != 0U) 
#line 769 
                                        netdev_info((struct net_device const *)efx->net_dev,"Could not get the PF id from VF\n"); else ;
  }
  else ;
  
#line 773 
  __retres = 0;
  
#line 773 
  goto return_label;
  fail: 
#line 775 
  ;
  
#line 776 
  efx_ef10_remove(efx);
  
#line 777 
  __retres = rc;
  return_label: 
#line 777 
                return __retres;
}


#line 786  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_alloc_vis(struct efx_nic *efx, unsigned int min_vis, unsigned int max_vis)
{
  int __retres;
  size_t outlen;
  int rc;
  
#line 789 
  efx_dword_t inbuf[2U] = {{.u32 = {0U}}};
  
#line 790 
  efx_dword_t outbuf[2U] = {{.u32 = {0U}}};
  
#line 791 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 795 
  ((efx_dword_t *)(& inbuf))->u32[0] = min_vis;
  
#line 796 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = max_vis;
  
#line 797 
  rc = efx_mcdi_rpc(efx,139U,(efx_dword_t const *)(& inbuf),8UL,(efx_dword_t *)(& outbuf),8UL,& outlen);
  
#line 799 
  if (rc != 0) {
    
#line 800 
    __retres = rc;
    
#line 800 
    goto return_label;
  }
  else ;
  
#line 802 
  if (outlen <= 7UL) {
    
#line 803 
    __retres = -5;
    
#line 803 
    goto return_label;
  }
  else ;
  
#line 805 
  if ((efx->msg_enable & 1U) != 0U) {
    
#line 805 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_ef10_alloc_vis", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c", .format = "base VI is A0x%03x\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))806U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 805 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 805 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"base VI is A0x%03x\n",((efx_dword_t *)(& outbuf) + 1U)->u32[0]); else ;
  }
  else ;
  
#line 808 
  nic_data->vi_base = ((efx_dword_t *)(& outbuf) + 1U)->u32[0];
  
#line 809 
  nic_data->n_allocated_vis = ((efx_dword_t *)(& outbuf))->u32[0];
  
#line 810 
  __retres = 0;
  return_label: 
#line 810 
                return __retres;
}


#line 816  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_dimension_resources(struct efx_nic *efx)
{
  int __retres;
  unsigned int uc_mem_map_size;
  unsigned int wc_mem_map_size;
  unsigned int min_vis;
  unsigned int pio_write_vi_base;
  unsigned int max_vis;
  void *membase;
  int rc;
  unsigned int tmp_0;
  
#line 818 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  {
    unsigned int tmp;
    
#line 824 
    unsigned int _max1 = efx->n_channels;
    
#line 824 
    unsigned int _max2 = efx->n_tx_channels * 4U;
    
#line 824 
    if (_max1 > _max2) 
#line 824 
                       tmp = _max1; else 
#line 824 
                                         tmp = _max2;
    
#line 824 
    tmp_0 = tmp;
  }
  
#line 824 
  min_vis = tmp_0;
  
#line 833 
  if (efx_piobuf_size != 0U && (2048U / efx_piobuf_size) * 16U >= efx->n_tx_channels) {
    
#line 836 
    unsigned int n_piobufs = ((efx->n_tx_channels + 2048U / efx_piobuf_size) + 4294967295U) / (2048U / efx_piobuf_size);
    
#line 840 
    rc = efx_ef10_alloc_piobufs(efx,n_piobufs);
    
#line 841 
    if (rc != 0) {
      
#line 842 
      if ((efx->msg_enable & 2U) != 0U) 
#line 842 
                                        netdev_err((struct net_device const *)efx->net_dev,"failed to allocate PIO buffers (%d)\n",rc); else ;
    }
    else 
      
#line 845 
      if ((efx->msg_enable & 2U) != 0U) {
        
#line 845 
        struct _ddebug descriptor = {.modname = "sfc", .function = "efx_ef10_dimension_resources", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c", .format = "allocated %u PIO buffers\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))846U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 845 
        if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 845 
                                                            __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"allocated %u PIO buffers\n",n_piobufs); else ;
      }
      else ;
  }
  else ;
  
#line 862 
  uc_mem_map_size = ((min_vis + 524287U) * 8192U + 8191U) & 4294963200U;
  
#line 864 
  if (nic_data->n_piobufs != 0U) {
    
#line 868 
    pio_write_vi_base = uc_mem_map_size / 8192U;
    
#line 869 
    wc_mem_map_size = (((nic_data->n_piobufs + pio_write_vi_base) * 8192U + 4095U) & 4294963200U) - uc_mem_map_size;
    
#line 873 
    max_vis = nic_data->n_piobufs + pio_write_vi_base;
  }
  else {
    
#line 875 
    pio_write_vi_base = 0U;
    
#line 876 
    wc_mem_map_size = 0U;
    
#line 877 
    max_vis = min_vis;
  }
  
#line 881 
  rc = efx_ef10_free_vis(efx);
  
#line 882 
  if (rc != 0) {
    
#line 883 
    __retres = rc;
    
#line 883 
    goto return_label;
  }
  else ;
  
#line 885 
  rc = efx_ef10_alloc_vis(efx,min_vis,max_vis);
  
#line 886 
  if (rc != 0) {
    
#line 887 
    __retres = rc;
    
#line 887 
    goto return_label;
  }
  else ;
  
#line 892 
  if (nic_data->n_piobufs != 0U && nic_data->n_allocated_vis < nic_data->n_piobufs + pio_write_vi_base) {
    
#line 895 
    if ((efx->msg_enable & 2U) != 0U) {
      
#line 895 
      struct _ddebug descriptor_0 = {.modname = "sfc", .function = "efx_ef10_dimension_resources", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c", .format = "%u VIs are not sufficient to map %u PIO buffers\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))897U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 895 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 895 
                                                            __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)efx->net_dev,"%u VIs are not sufficient to map %u PIO buffers\n",nic_data->n_allocated_vis,nic_data->n_piobufs); else ;
    }
    else ;
    
#line 898 
    efx_ef10_free_piobufs(efx);
  }
  else ;
  
#line 902 
  membase = ioremap_nocache(efx->membase_phys,(unsigned long)uc_mem_map_size);
  
#line 903 
  if (membase == (void *)0) {
    
#line 904 
    if ((efx->msg_enable & 2U) != 0U) 
#line 904 
                                      netdev_err((struct net_device const *)efx->net_dev,"could not shrink memory BAR to %x\n",uc_mem_map_size); else ;
    
#line 907 
    __retres = -12;
    
#line 907 
    goto return_label;
  }
  else ;
  
#line 909 
  iounmap((void volatile *)efx->membase);
  
#line 910 
  efx->membase = membase;
  
#line 913 
  if (wc_mem_map_size != 0U) {
    
#line 914 
    nic_data->wc_membase = ioremap_wc(efx->membase_phys + (unsigned long long)uc_mem_map_size,(unsigned long)wc_mem_map_size);
    
#line 917 
    if (nic_data->wc_membase == (void *)0) {
      
#line 918 
      if ((efx->msg_enable & 2U) != 0U) 
#line 918 
                                        netdev_err((struct net_device const *)efx->net_dev,"could not allocate WC mapping of size %x\n",wc_mem_map_size); else ;
      
#line 921 
      __retres = -12;
      
#line 921 
      goto return_label;
    }
    else ;
    
#line 923 
    nic_data->pio_write_vi_base = pio_write_vi_base;
    
#line 924 
    nic_data->pio_write_base = nic_data->wc_membase + ((pio_write_vi_base * 8192U - uc_mem_map_size) + 4096U);
    
#line 929 
    rc = efx_ef10_link_piobufs(efx);
    
#line 930 
    if (rc != 0) 
#line 931 
                 efx_ef10_free_piobufs(efx); else ;
  }
  else ;
  
#line 934 
  if ((efx->msg_enable & 2U) != 0U) {
    
#line 934 
    struct _ddebug descriptor_1 = {.modname = "sfc", .function = "efx_ef10_dimension_resources", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c", .format = "memory BAR at %pa (virtual %p+%x UC, %p+%x WC)\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))937U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 934 
    if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) 
#line 934 
                                                          __dynamic_netdev_dbg(& descriptor_1,(struct net_device const *)efx->net_dev,"memory BAR at %pa (virtual %p+%x UC, %p+%x WC)\n",& efx->membase_phys,efx->membase,uc_mem_map_size,nic_data->wc_membase,wc_mem_map_size); else ;
  }
  else ;
  
#line 939 
  __retres = 0;
  return_label: 
#line 939 
                return __retres;
}


#line 942  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_init_nic(struct efx_nic *efx)
{
  int __retres;
  int rc;
  
#line 944 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 947 
  if ((int)nic_data->must_check_datapath_caps != 0) {
    
#line 948 
    rc = efx_ef10_init_datapath_caps(efx);
    
#line 949 
    if (rc != 0) {
      
#line 950 
      __retres = rc;
      
#line 950 
      goto return_label;
    }
    else ;
    
#line 951 
    nic_data->must_check_datapath_caps = (_Bool)0;
  }
  else ;
  
#line 954 
  if ((int)nic_data->must_realloc_vis != 0) {
    
#line 956 
    rc = efx_ef10_alloc_vis(efx,nic_data->n_allocated_vis,nic_data->n_allocated_vis);
    
#line 958 
    if (rc != 0) {
      
#line 959 
      __retres = rc;
      
#line 959 
      goto return_label;
    }
    else ;
    
#line 960 
    nic_data->must_realloc_vis = (_Bool)0;
  }
  else ;
  
#line 963 
  if ((int)nic_data->must_restore_piobufs != 0 && nic_data->n_piobufs != 0U) {
    
#line 964 
    rc = efx_ef10_alloc_piobufs(efx,nic_data->n_piobufs);
    
#line 965 
    if (rc == 0) {
      
#line 966 
      rc = efx_ef10_link_piobufs(efx);
      
#line 967 
      if (rc != 0) 
#line 968 
                   efx_ef10_free_piobufs(efx); else ;
    }
    else ;
    
#line 972 
    if (rc != 0) {
      
#line 973 
      if ((efx->msg_enable & 1U) != 0U) 
#line 973 
                                        netdev_err((struct net_device const *)efx->net_dev,"failed to restore PIO buffers (%d)\n",rc); else ;
    }
    else ;
    
#line 975 
    nic_data->must_restore_piobufs = (_Bool)0;
  }
  else ;
  
#line 979 
  (*((efx->type)->rx_push_rss_config))(efx,(_Bool)0,(u32 const *)(& efx->rx_indir_table));
  
#line 981 
  __retres = 0;
  return_label: 
#line 981 
                return __retres;
}


#line 984  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_reset_mc_allocations(struct efx_nic *efx)
{
  
#line 986 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 989 
  nic_data->must_realloc_vis = (_Bool)1;
  
#line 990 
  nic_data->must_restore_filters = (_Bool)1;
  
#line 991 
  nic_data->must_restore_piobufs = (_Bool)1;
  
#line 992 
  nic_data->rx_rss_context = 4294967295U;
  
#line 993 
  return;
}


#line 995  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static enum reset_type efx_ef10_map_reset_reason(enum reset_type reason)
{
  enum reset_type __retres;
  enum reset_type tmp;
  
#line 997 
  if (reason == (unsigned int)RESET_TYPE_MC_FAILURE) {
    
#line 998 
    __retres = RESET_TYPE_DATAPATH;
    
#line 998 
    goto return_label;
  }
  else ;
  
#line 1000 
  tmp = efx_mcdi_map_reset_reason(reason);
  
#line 1000 
  __retres = tmp;
  return_label: 
#line 1000 
                return __retres;
}


#line 1003  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_map_reset_flags(u32 *flags)
{
  int __retres;
  
#line 1018 
  if ((*flags & 8192000U) == 8192000U) {
    
#line 1019 
    *flags &= 4286775295U;
    
#line 1020 
    __retres = 3;
    
#line 1020 
    goto return_label;
  }
  else ;
  
#line 1023 
  if ((*flags & 6291456U) == 6291456U) {
    
#line 1024 
    *flags &= 4288675839U;
    
#line 1025 
    __retres = 2;
    
#line 1025 
    goto return_label;
  }
  else ;
  
#line 1030 
  __retres = -22;
  return_label: 
#line 1030 
                return __retres;
}


#line 1033  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_reset(struct efx_nic *efx, enum reset_type reset_type)
{
  
#line 1035 
  int rc = efx_mcdi_reset(efx,reset_type);
  
#line 1043 
  if ((reset_type == (unsigned int)RESET_TYPE_ALL || reset_type == (unsigned int)RESET_TYPE_MCDI_TIMEOUT) && rc == 0) 
    
#line 1045 
    efx_ef10_reset_mc_allocations(efx); else ;
  
#line 1046 
  return rc;
}


#line 1060  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static struct efx_hw_stat_desc const efx_ef10_stat_desc[73U] = {{.name = "rx_noskb_drops", .dma_width = (unsigned short)0U, .offset = (unsigned short)0U}, {.name = "rx_nodesc_trunc", .dma_width = (unsigned short)0U, .offset = (unsigned short)0U}, {.name = "port_tx_bytes", .dma_width = (unsigned short)64U, .offset = (unsigned short)56U}, {.name = "port_tx_packets", .dma_width = (unsigned short)64U, .offset = (unsigned short)8U}, {.name = "port_tx_pause", .dma_width = (unsigned short)64U, .offset = (unsigned short)16U}, {.name = "port_tx_control", .dma_width = (unsigned short)64U, .offset = (unsigned short)24U}, {.name = "port_tx_unicast", .dma_width = (unsigned short)64U, .offset = (unsigned short)32U}, {.name = "port_tx_multicast", .dma_width = (unsigned short)64U, .offset = (unsigned short)40U}, {.name = "port_tx_broadcast", .dma_width = (unsigned short)64U, .offset = (unsigned short)48U}, {.name = "port_tx_lt64", .dma_width = (unsigned short)64U, .offset = (unsigned short)72U}, {.name = "port_tx_64", .dma_width = (unsigned short)64U, .offset = (unsigned short)80U}, {.name = "port_tx_65_to_127", .dma_width = (unsigned short)64U, .offset = (unsigned short)88U}, {.name = "port_tx_128_to_255", .dma_width = (unsigned short)64U, .offset = (unsigned short)96U}, {.name = "port_tx_256_to_511", .dma_width = (unsigned short)64U, .offset = (unsigned short)104U}, {.name = "port_tx_512_to_1023", .dma_width = (unsigned short)64U, .offset = (unsigned short)112U}, {.name = "port_tx_1024_to_15xx", .dma_width = (unsigned short)64U, .offset = (unsigned short)120U}, {.name = "port_tx_15xx_to_jumbo", .dma_width = (unsigned short)64U, .offset = (unsigned short)128U}, {.name = "port_rx_bytes", .dma_width = (unsigned short)64U, .offset = (unsigned short)280U}, {.name = (char const *)0, .dma_width = (unsigned short)64U, .offset = (unsigned short)288U}, {.name = "port_rx_good_bytes", .dma_width = (unsigned short)0U, .offset = (unsigned short)0U}, {.name = "port_rx_bad_bytes", .dma_width = (unsigned short)0U, .offset = (unsigned short)0U}, {.name = "port_rx_packets", .dma_width = (unsigned short)64U, .offset = (unsigned short)224U}, {.name = "port_rx_good", .dma_width = (unsigned short)64U, .offset = (unsigned short)240U}, {.name = "port_rx_bad", .dma_width = (unsigned short)64U, .offset = (unsigned short)368U}, {.name = "port_rx_pause", .dma_width = (unsigned short)64U, .offset = (unsigned short)232U}, {.name = "port_rx_control", .dma_width = (unsigned short)64U, .offset = (unsigned short)248U}, {.name = "port_rx_unicast", .dma_width = (unsigned short)64U, .offset = (unsigned short)256U}, {.name = "port_rx_multicast", .dma_width = (unsigned short)64U, .offset = (unsigned short)264U}, {.name = "port_rx_broadcast", .dma_width = (unsigned short)64U, .offset = (unsigned short)272U}, {.name = "port_rx_lt64", .dma_width = (unsigned short)64U, .offset = (unsigned short)360U}, {.name = "port_rx_64", .dma_width = (unsigned short)64U, .offset = (unsigned short)296U}, {.name = "port_rx_65_to_127", .dma_width = (unsigned short)64U, .offset = (unsigned short)304U}, {.name = "port_rx_128_to_255", .dma_width = (unsigned short)64U, .offset = (unsigned short)312U}, {.name = "port_rx_256_to_511", .dma_width = (unsigned short)64U, .offset = (unsigned short)320U}, {.name = "port_rx_512_to_1023", .dma_width = (unsigned short)64U, .offset = (unsigned short)328U}, {.name = "port_rx_1024_to_15xx", .dma_width = (unsigned short)64U, .offset = (unsigned short)336U}, {.name = "port_rx_15xx_to_jumbo", .dma_width = (unsigned short)64U, .offset = (unsigned short)344U}, {.name = "port_rx_gtjumbo", .dma_width = (unsigned short)64U, .offset = (unsigned short)352U}, {.name = "port_rx_bad_gtjumbo", .dma_width = (unsigned short)64U, .offset = (unsigned short)424U}, {.name = "port_rx_overflow", .dma_width = (unsigned short)64U, .offset = (unsigned short)376U}, {.name = "port_rx_align_error", .dma_width = (unsigned short)64U, .offset = (unsigned short)400U}, {.name = "port_rx_length_error", .dma_width = (unsigned short)64U, .offset = (unsigned short)408U}, {.name = "port_rx_nodesc_drops", .dma_width = (unsigned short)64U, .offset = (unsigned short)432U}, {.name = "port_rx_pm_trunc_bb_overflow", .dma_width = (unsigned short)64U, .offset = (unsigned short)480U}, {.name = "port_rx_pm_discard_bb_overflow", .dma_width = (unsigned short)64U, .offset = (unsigned short)488U}, {.name = "port_rx_pm_trunc_vfifo_full", .dma_width = (unsigned short)64U, .offset = (unsigned short)496U}, {.name = "port_rx_pm_discard_vfifo_full", .dma_width = (unsigned short)64U, .offset = (unsigned short)504U}, {.name = "port_rx_pm_trunc_qbb", .dma_width = (unsigned short)64U, .offset = (unsigned short)512U}, {.name = "port_rx_pm_discard_qbb", .dma_width = (unsigned short)64U, .offset = (unsigned short)520U}, {.name = "port_rx_pm_discard_mapping", .dma_width = (unsigned short)64U, .offset = (unsigned short)528U}, {.name = "port_rx_dp_q_disabled_packets", .dma_width = (unsigned short)64U, .offset = (unsigned short)536U}, {.name = "port_rx_dp_di_dropped_packets", .dma_width = (unsigned short)64U, .offset = (unsigned short)552U}, {.name = "port_rx_dp_streaming_packets", .dma_width = (unsigned short)64U, .offset = (unsigned short)560U}, {.name = "port_rx_dp_hlb_fetch", .dma_width = (unsigned short)64U, .offset = (unsigned short)568U}, {.name = "port_rx_dp_hlb_wait", .dma_width = (unsigned short)64U, .offset = (unsigned short)576U}, {.name = "rx_unicast", .dma_width = (unsigned short)64U, .offset = (unsigned short)608U}, {.name = "rx_unicast_bytes", .dma_width = (unsigned short)64U, .offset = (unsigned short)616U}, {.name = "rx_multicast", .dma_width = (unsigned short)64U, .offset = (unsigned short)624U}, {.name = "rx_multicast_bytes", .dma_width = (unsigned short)64U, .offset = (unsigned short)632U}, {.name = "rx_broadcast", .dma_width = (unsigned short)64U, .offset = (unsigned short)640U}, {.name = "rx_broadcast_bytes", .dma_width = (unsigned short)64U, .offset = (unsigned short)648U}, {.name = "rx_bad", .dma_width = (unsigned short)64U, .offset = (unsigned short)656U}, {.name = "rx_bad_bytes", .dma_width = (unsigned short)64U, .offset = (unsigned short)664U}, {.name = "rx_overflow", .dma_width = (unsigned short)64U, .offset = (unsigned short)672U}, {.name = "tx_unicast", .dma_width = (unsigned short)64U, .offset = (unsigned short)696U}, {.name = "tx_unicast_bytes", .dma_width = (unsigned short)64U, .offset = (unsigned short)704U}, {.name = "tx_multicast", .dma_width = (unsigned short)64U, .offset = (unsigned short)712U}, {.name = "tx_multicast_bytes", .dma_width = (unsigned short)64U, .offset = (unsigned short)720U}, {.name = "tx_broadcast", .dma_width = (unsigned short)64U, .offset = (unsigned short)728U}, {.name = "tx_broadcast_bytes", .dma_width = (unsigned short)64U, .offset = (unsigned short)736U}, {.name = "tx_bad", .dma_width = (unsigned short)64U, .offset = (unsigned short)744U}, {.name = "tx_bad_bytes", .dma_width = (unsigned short)64U, .offset = (unsigned short)752U}, {.name = "tx_overflow", .dma_width = (unsigned short)64U, .offset = (unsigned short)760U}};

#line 1208  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static u64 efx_ef10_raw_stat_mask(struct efx_nic *efx)
{
  u64 __retres;
  
#line 1210 
  u64 raw_mask = 5497558008287ULL;
  
#line 1211 
  u32 port_caps = efx_mcdi_phy_get_caps(efx);
  
#line 1212 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 1214 
  if (((efx->mcdi)->fn_flags & 2U) == 0U) {
    
#line 1216 
    __retres = 0ULL;
    
#line 1216 
    goto return_label;
  }
  else ;
  
#line 1218 
  if ((port_caps & 2048U) != 0U) 
#line 1219 
                                 raw_mask |= 3298534883328ULL; else 
#line 1221 
                                                                    raw_mask |= 130592ULL;
  
#line 1223 
  if ((nic_data->datapath_caps & 134217728U) != 0U) 
#line 1225 
                                                    raw_mask |= 36020000925941760ULL; else ;
  
#line 1227 
  __retres = raw_mask;
  return_label: 
#line 1227 
                return __retres;
}


#line 1230  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_get_stat_mask(struct efx_nic *efx, unsigned long *mask)
{
  u64 raw_mask[2U];
  
#line 1232 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 1235 
  raw_mask[0] = efx_ef10_raw_stat_mask(efx);
  
#line 1238 
  if ((nic_data->datapath_caps & 1073741824U) != 0U) {
    
#line 1240 
    raw_mask[0] |= 18410715276690587648ULL;
    
#line 1241 
    raw_mask[1] = 1023ULL;
  }
  else 
#line 1243 
       raw_mask[1] = 0ULL;
  
#line 1247 
  *mask = (unsigned long)raw_mask[0];
  
#line 1248 
  *(mask + 1U) = (unsigned long)raw_mask[1];
  
#line 1249 
  return;
}


#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static size_t efx_ef10_describe_stats(struct efx_nic *efx, u8 *names)
{
  unsigned long mask[2U];
  size_t tmp;
  
#line 1261 
  efx_ef10_get_stat_mask(efx,(unsigned long *)(& mask));
  
#line 1262 
  tmp = efx_nic_describe_stats((struct efx_hw_stat_desc const *)(& efx_ef10_stat_desc),73UL,(unsigned long const *)(& mask),names);
  
#line 1262 
  return tmp;
}


#line 1266  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static size_t efx_ef10_update_stats_common(struct efx_nic *efx, u64 *full_stats, struct rtnl_link_stats64 *core_stats)
{
  size_t __retres;
  unsigned long mask[2U];
  size_t index;
  
#line 1270 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 1271 
  u64 *stats = (u64 *)(& nic_data->stats);
  
#line 1272 
  size_t stats_count = 0UL;
  
#line 1274 
  efx_ef10_get_stat_mask(efx,(unsigned long *)(& mask));
  
#line 1276 
  if (full_stats != (u64 *)0ULL) {
    
#line 1277 
    index = find_first_bit((unsigned long const *)(& mask),73UL);
    
#line 1277 
    goto ldv_56409;
    ldv_56408: 
#line 1278 
    ;
    
#line 1278 
    if (efx_ef10_stat_desc[index].name != (char const *)0) {
      u64 *tmp;
      
#line 1279 
      tmp = full_stats;
      
#line 1279 
      full_stats += 1;
      
#line 1279 
      *tmp = *(stats + index);
      
#line 1280 
      stats_count += 1UL;
    }
    else ;
    
#line 1277 
    index = find_next_bit((unsigned long const *)(& mask),73UL,index + 1UL);
    ldv_56409: 
#line 1278 
    ;
    
#line 1277 
    if (index <= 72UL) 
#line 1279 
                       goto ldv_56408; else 
#line 1282 
                                            goto ldv_56410;
    ldv_56410: 
#line 1283 
    ;
  }
  else ;
  
#line 1285 
  if (core_stats == (struct rtnl_link_stats64 *)0) {
    
#line 1286 
    __retres = stats_count;
    
#line 1286 
    goto return_label;
  }
  else ;
  
#line 1288 
  if ((nic_data->datapath_caps & 1073741824U) != 0U) {
    
#line 1291 
    core_stats->rx_packets = (*(stats + 55U) + *(stats + 57U)) + *(stats + 59U);
    
#line 1294 
    core_stats->tx_packets = (*(stats + 64U) + *(stats + 66U)) + *(stats + 68U);
    
#line 1297 
    core_stats->rx_bytes = (*(stats + 56U) + *(stats + 58U)) + *(stats + 60U);
    
#line 1300 
    core_stats->tx_bytes = (*(stats + 65U) + *(stats + 67U)) + *(stats + 69U);
    
#line 1303 
    core_stats->rx_dropped = *(stats + 1U) + *stats;
    
#line 1305 
    core_stats->multicast = *(stats + 57U);
    
#line 1306 
    core_stats->rx_crc_errors = *(stats + 61U);
    
#line 1307 
    core_stats->rx_fifo_errors = *(stats + 63U);
    
#line 1308 
    core_stats->rx_errors = core_stats->rx_crc_errors;
    
#line 1309 
    core_stats->tx_errors = *(stats + 70U);
  }
  else {
    
#line 1312 
    core_stats->rx_packets = *(stats + 21U);
    
#line 1313 
    core_stats->tx_packets = *(stats + 3U);
    
#line 1314 
    core_stats->rx_bytes = *(stats + 17U);
    
#line 1315 
    core_stats->tx_bytes = *(stats + 2U);
    
#line 1316 
    core_stats->rx_dropped = (*(stats + 42U) + *(stats + 1U)) + *stats;
    
#line 1319 
    core_stats->multicast = *(stats + 27U);
    
#line 1320 
    core_stats->rx_length_errors = *(stats + 37U) + *(stats + 41U);
    
#line 1323 
    core_stats->rx_crc_errors = *(stats + 23U);
    
#line 1324 
    core_stats->rx_frame_errors = *(stats + 40U);
    
#line 1326 
    core_stats->rx_fifo_errors = *(stats + 39U);
    
#line 1327 
    core_stats->rx_errors = (core_stats->rx_length_errors + core_stats->rx_crc_errors) + core_stats->rx_frame_errors;
  }
  
#line 1332 
  __retres = stats_count;
  return_label: 
#line 1332 
                return __retres;
}


#line 1335  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_try_update_nic_stats_pf(struct efx_nic *efx)
{
  int __retres;
  unsigned long mask[2U];
  __le64 generation_start;
  __le64 generation_end;
  __le64 *dma_stats;
  
#line 1337 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 1340 
  u64 *stats = (u64 *)(& nic_data->stats);
  
#line 1343 
  efx_ef10_get_stat_mask(efx,(unsigned long *)(& mask));
  
#line 1345 
  dma_stats = (__le64 *)efx->stats_buffer.addr;
  
#line 1346 
  nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 1348 
  generation_end = *(dma_stats + 96U);
  
#line 1349 
  if (generation_end == 18446744073709551615ULL) {
    
#line 1350 
    __retres = 0;
    
#line 1350 
    goto return_label;
  }
  else ;
  
#line 1351 
  ldv_inline_asm();
  
#line 1352 
  efx_nic_update_stats((struct efx_hw_stat_desc const *)(& efx_ef10_stat_desc),73UL,(unsigned long const *)(& mask),stats,(void const *)efx->stats_buffer.addr,(_Bool)0);
  
#line 1354 
  ldv_inline_asm();
  
#line 1355 
  generation_start = *dma_stats;
  
#line 1356 
  if (generation_end != generation_start) {
    
#line 1357 
    __retres = -11;
    
#line 1357 
    goto return_label;
  }
  else ;
  
#line 1360 
  efx_nic_fix_nodesc_drop_stat(efx,stats + 42U);
  
#line 1362 
  *(stats + 19U) = *(stats + 17U) - *(stats + 18U);
  
#line 1365 
  efx_update_diff_stat(stats + 20U,*(stats + 18U));
  
#line 1367 
  efx_update_sw_stats(efx,stats);
  
#line 1368 
  __retres = 0;
  return_label: 
#line 1368 
                return __retres;
}


#line 1372  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static size_t efx_ef10_update_stats_pf(struct efx_nic *efx, u64 *full_stats, struct rtnl_link_stats64 *core_stats)
{
  int retry;
  int tmp;
  size_t tmp_0;
  
#line 1380 
  retry = 0;
  
#line 1380 
  goto ldv_56428;
  ldv_56427: 
#line 1381 
  ;
  
#line 1381 
  tmp = efx_ef10_try_update_nic_stats_pf(efx);
  
#line 1381 
  if (tmp == 0) 
#line 1382 
                goto ldv_56426; else ;
  
#line 1383 
  __const_udelay(429500UL);
  
#line 1380 
  retry += 1;
  ldv_56428: 
#line 1381 
  ;
  
#line 1380 
  if (retry <= 99) 
#line 1382 
                   goto ldv_56427; else 
#line 1385 
                                        goto ldv_56426;
  ldv_56426: 
#line 1386 
  ;
  
#line 1386 
  tmp_0 = efx_ef10_update_stats_common(efx,full_stats,core_stats);
  
#line 1386 
  return tmp_0;
}


#line 1389  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_try_update_nic_stats_vf(struct efx_nic *efx)
{
  int __retres;
  unsigned long mask[2U];
  __le64 generation_start;
  __le64 generation_end;
  struct efx_buffer stats_buf;
  __le64 *dma_stats;
  int rc;
  int tmp;
  
#line 1391 
  efx_dword_t inbuf[5U] = {{.u32 = {0U}}};
  
#line 1392 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 1395 
  u64 *stats = (u64 *)(& nic_data->stats);
  
#line 1396 
  u32 dma_len = 776U;
  
#line 1401 
  ldv_spin_unlock_bh_103_0(& efx->stats_lock);
  
#line 1403 
  tmp = preempt_count();
  
#line 1403 
  if (((unsigned long)tmp & 2096896UL) != 0UL) {
    
#line 1407 
    ldv_spin_lock_bh_104_0(& efx->stats_lock);
    
#line 1408 
    efx_update_sw_stats(efx,stats);
    
#line 1409 
    __retres = 0;
    
#line 1409 
    goto return_label;
  }
  else ;
  
#line 1412 
  efx_ef10_get_stat_mask(efx,(unsigned long *)(& mask));
  
#line 1414 
  rc = efx_nic_alloc_buffer(efx,& stats_buf,dma_len,32U);
  
#line 1415 
  if (rc != 0) {
    
#line 1416 
    ldv_spin_lock_bh_105(& efx->stats_lock);
    
#line 1417 
    __retres = rc;
    
#line 1417 
    goto return_label;
  }
  else ;
  
#line 1420 
  dma_stats = (__le64 *)stats_buf.addr;
  
#line 1421 
  *(dma_stats + 96U) = 18446744073709551615ULL;
  
#line 1423 
  ((efx_dword_t *)(& inbuf))->u32[0] = (unsigned int)stats_buf.dma_addr;
  
#line 1423 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = (unsigned int)(stats_buf.dma_addr >> 32);
  
#line 1424 
  ((efx_dword_t *)(& inbuf) + 2U)->u32[0] = 1U;
  
#line 1426 
  ((efx_dword_t *)(& inbuf) + 3U)->u32[0] = dma_len;
  
#line 1427 
  ((efx_dword_t *)(& inbuf) + 4U)->u32[0] = 16777216U;
  
#line 1429 
  rc = efx_mcdi_rpc_quiet(efx,46U,(efx_dword_t const *)(& inbuf),20UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 1431 
  ldv_spin_lock_bh_106_0(& efx->stats_lock);
  
#line 1432 
  if (rc != 0) {
    
#line 1434 
    if (rc != -2) 
#line 1435 
                  efx_mcdi_display_error(efx,46U,20UL,(efx_dword_t *)0,0UL,rc);
    else {
      int tmp_0;
      
#line 1434 
      tmp_0 = atomic_read((atomic_t const *)(& efx->active_queues));
      
#line 1434 
      if (tmp_0 != 0) 
#line 1435 
                      efx_mcdi_display_error(efx,46U,20UL,(efx_dword_t *)0,0UL,rc); else ;
    }
    
#line 1437 
    goto out;
  }
  else ;
  
#line 1440 
  generation_end = *(dma_stats + 96U);
  
#line 1441 
  if (generation_end == 18446744073709551615ULL) {
    {
      bool __warned;
      
#line 1442 
      int __ret_warn_once = 1;
      
#line 1442 
      if ((long)(__ret_warn_once != 0) != 0L) {
        int tmp_1;
        {
          
#line 1442 
          int __ret_warn_on = ! __warned;
          
#line 1442 
          if ((long)(__ret_warn_on != 0) != 0L) 
#line 1442 
                                                warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c",1442); else ;
          
#line 1442 
          tmp_1 = (long)(__ret_warn_on != 0);
        }
        
#line 1442 
        if ((long)tmp_1 != 0L) 
#line 1442 
                               __warned = (_Bool)1; else ;
      }
      else ;
      
#line 1442 
      long tmp_2 = (long)(__ret_warn_once != 0);
    }
    
#line 1443 
    goto out;
  }
  else ;
  
#line 1445 
  ldv_inline_asm();
  
#line 1446 
  efx_nic_update_stats((struct efx_hw_stat_desc const *)(& efx_ef10_stat_desc),73UL,(unsigned long const *)(& mask),stats,(void const *)stats_buf.addr,(_Bool)0);
  
#line 1448 
  ldv_inline_asm();
  
#line 1449 
  generation_start = *dma_stats;
  
#line 1450 
  if (generation_end != generation_start) {
    
#line 1451 
    rc = -11;
    
#line 1452 
    goto out;
  }
  else ;
  
#line 1455 
  efx_update_sw_stats(efx,stats);
  out: 
#line 1456 
  ;
  
#line 1457 
  efx_nic_free_buffer(efx,& stats_buf);
  
#line 1458 
  __retres = rc;
  return_label: 
#line 1458 
                return __retres;
}


#line 1461  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static size_t efx_ef10_update_stats_vf(struct efx_nic *efx, u64 *full_stats, struct rtnl_link_stats64 *core_stats)
{
  size_t __retres;
  int tmp;
  size_t tmp_0;
  
#line 1464 
  tmp = efx_ef10_try_update_nic_stats_vf(efx);
  
#line 1464 
  if (tmp != 0) {
    
#line 1465 
    __retres = 0UL;
    
#line 1465 
    goto return_label;
  }
  else ;
  
#line 1467 
  tmp_0 = efx_ef10_update_stats_common(efx,full_stats,core_stats);
  
#line 1467 
  __retres = tmp_0;
  return_label: 
#line 1467 
                return __retres;
}


#line 1470  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_push_irq_moderation(struct efx_channel *channel)
{
  unsigned int mode;
  unsigned int value;
  efx_dword_t timer_cmd;
  
#line 1472 
  struct efx_nic *efx = channel->efx;
  
#line 1476 
  if (channel->irq_moderation != 0U) {
    
#line 1477 
    mode = 3U;
    
#line 1478 
    value = channel->irq_moderation + 4294967295U;
  }
  else {
    
#line 1480 
    mode = 0U;
    
#line 1481 
    value = 0U;
  }
  
#line 1484 
  if ((int)((struct efx_ef10_nic_data *)efx->nic_data)->workaround_35388 != 0) {
    
#line 1485 
    timer_cmd.u32[0] = ((mode << 8) | value) | 3072U;
    
#line 1489 
    _efx_writed_page(efx,(efx_dword_t const *)(& timer_cmd),2584U,(unsigned int)channel->channel);
  }
  else {
    
#line 1492 
    timer_cmd.u32[0] = (mode << 14) | value;
    
#line 1494 
    _efx_writed_page(efx,(efx_dword_t const *)(& timer_cmd),1056U,(unsigned int)channel->channel);
  }
  
#line 1496 
  return;
}


#line 1499  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_get_wol_vf(struct efx_nic *efx, struct ethtool_wolinfo *wol)
{
  
#line 1501 
  return;
}


#line 1502  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_set_wol_vf(struct efx_nic *efx, u32 type)
{
  int __retres;
  
#line 1504 
  __retres = -95;
  
#line 1504 
  return __retres;
}


#line 1507  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_get_wol(struct efx_nic *efx, struct ethtool_wolinfo *wol)
{
  
#line 1509 
  wol->supported = 0U;
  
#line 1510 
  wol->wolopts = 0U;
  
#line 1511 
  memset((void *)(& wol->sopass),0,6UL);
  
#line 1512 
  return;
}


#line 1514  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_set_wol(struct efx_nic *efx, u32 type)
{
  int __retres;
  
#line 1516 
  if (type != 0U) {
    
#line 1517 
    __retres = -22;
    
#line 1517 
    goto return_label;
  }
  else ;
  
#line 1518 
  __retres = 0;
  return_label: 
#line 1518 
                return __retres;
}


#line 1521  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_mcdi_request(struct efx_nic *efx, efx_dword_t const *hdr, size_t hdr_len, efx_dword_t const *sdu, size_t sdu_len)
{
  
#line 1525 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 1526 
  u8 *pdu = (u8 *)nic_data->mcdi_buf.addr;
  
#line 1528 
  memcpy((void *)pdu,(void const *)hdr,hdr_len);
  
#line 1529 
  memcpy((void *)(pdu + hdr_len),(void const *)sdu,sdu_len);
  
#line 1530 
  ldv_inline_asm();
  
#line 1538 
  _efx_writed(efx,(unsigned int)(nic_data->mcdi_buf.dma_addr >> 32),512U);
  
#line 1540 
  _efx_writed(efx,(unsigned int)nic_data->mcdi_buf.dma_addr,516U);
  
#line 1541 
  return;
}


#line 1544  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static bool efx_ef10_mcdi_poll_response(struct efx_nic *efx)
{
  bool __retres;
  
#line 1546 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 1547 
  efx_dword_t const hdr = *((efx_dword_t const *)nic_data->mcdi_buf.addr);
  
#line 1548 
  ldv_inline_asm();
  
#line 1550 
  __retres = (_Bool)(((hdr.u32[0] >> 23) & 1U) != 0U);
  
#line 1550 
  return __retres;
}


#line 1554  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_mcdi_read_response(struct efx_nic *efx, efx_dword_t *outbuf, size_t offset, size_t outlen)
{
  
#line 1557 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 1558 
  u8 const *pdu = (u8 const *)nic_data->mcdi_buf.addr;
  
#line 1560 
  memcpy((void *)outbuf,(void const *)(pdu + offset),outlen);
  
#line 1561 
  return;
}


#line 1563  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_mcdi_poll_reboot(struct efx_nic *efx)
{
  int __retres;
  int rc;
  
#line 1565 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 1568 
  rc = efx_ef10_get_warm_boot_count(efx);
  
#line 1569 
  if (rc < 0) {
    
#line 1575 
    __retres = 0;
    
#line 1575 
    goto return_label;
  }
  else ;
  
#line 1578 
  if ((int)nic_data->warm_boot_count == rc) {
    
#line 1579 
    __retres = 0;
    
#line 1579 
    goto return_label;
  }
  else ;
  
#line 1581 
  nic_data->warm_boot_count = (unsigned short)rc;
  
#line 1584 
  efx_ef10_reset_mc_allocations(efx);
  
#line 1587 
  nic_data->must_probe_vswitching = (_Bool)1;
  
#line 1588 
  nic_data->vport_id = 16777216U;
  
#line 1591 
  nic_data->must_check_datapath_caps = (_Bool)1;
  
#line 1596 
  nic_data->stats[20] = 0ULL;
  
#line 1598 
  __retres = -5;
  return_label: 
#line 1598 
                return __retres;
}


#line 1608  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static irqreturn_t efx_ef10_msi_interrupt(int irq, void *dev_id)
{
  irqreturn_t __retres;
  bool volatile *tmp_9;
  
#line 1610 
  struct efx_msi_context *context = (struct efx_msi_context *)dev_id;
  
#line 1611 
  struct efx_nic *efx = context->efx;
  
#line 1613 
  if (0) {
    
#line 1613 
    if ((efx->msg_enable & 512U) != 0U) {
      int tmp_3;
      {
        int pscr_ret__;
        {
          
#line 1613 
          void const *__vpp_verify = (void const *)0;
          
#line 1613 
          void const *tmp = __vpp_verify;
        }
        
#line 1613 
        switch (4UL) {
          int tmp_0;
          int tmp_0_0;
          int tmp_1;
          int tmp_2;
          case (unsigned long)1: 
#line 1613 
          ;
          {
            int pfo_ret__;
            
#line 1613 
            switch (4UL) {
              case (unsigned long)1: 
#line 1613 
              ;
              
#line 1614 
              ldv_inline_asm();
              
#line 1613 
              goto ldv_56535;
              case (unsigned long)2: 
#line 1613 
              ;
              
#line 1614 
              ldv_inline_asm();
              
#line 1613 
              goto ldv_56535;
              case (unsigned long)4: 
#line 1613 
              ;
              
#line 1614 
              ldv_inline_asm();
              
#line 1613 
              goto ldv_56535;
              case (unsigned long)8: 
#line 1613 
              ;
              
#line 1614 
              ldv_inline_asm();
              
#line 1613 
              goto ldv_56535;
              default: 
#line 1613 
              ;
              
#line 1613 
              __bad_percpu_size();
            }
            ldv_56535: 
#line 1613 
            ;
            
#line 1613 
            tmp_0 = pfo_ret__;
          }
          
#line 1613 
          pscr_ret__ = tmp_0;
          
#line 1613 
          goto ldv_56541;
          case (unsigned long)2: 
#line 1613 
          ;
          {
            int pfo_ret___0;
            
#line 1613 
            switch (4UL) {
              case (unsigned long)1: 
#line 1613 
              ;
              
#line 1614 
              ldv_inline_asm();
              
#line 1613 
              goto ldv_56545;
              case (unsigned long)2: 
#line 1613 
              ;
              
#line 1614 
              ldv_inline_asm();
              
#line 1613 
              goto ldv_56545;
              case (unsigned long)4: 
#line 1613 
              ;
              
#line 1614 
              ldv_inline_asm();
              
#line 1613 
              goto ldv_56545;
              case (unsigned long)8: 
#line 1613 
              ;
              
#line 1614 
              ldv_inline_asm();
              
#line 1613 
              goto ldv_56545;
              default: 
#line 1613 
              ;
              
#line 1613 
              __bad_percpu_size();
            }
            ldv_56545: 
#line 1613 
            ;
            
#line 1613 
            tmp_0_0 = pfo_ret___0;
          }
          
#line 1613 
          pscr_ret__ = tmp_0_0;
          
#line 1613 
          goto ldv_56541;
          case (unsigned long)4: 
#line 1613 
          ;
          {
            int pfo_ret___1;
            
#line 1613 
            switch (4UL) {
              case (unsigned long)1: 
#line 1613 
              ;
              
#line 1614 
              ldv_inline_asm();
              
#line 1613 
              goto ldv_56554;
              case (unsigned long)2: 
#line 1613 
              ;
              
#line 1614 
              ldv_inline_asm();
              
#line 1613 
              goto ldv_56554;
              case (unsigned long)4: 
#line 1613 
              ;
              
#line 1614 
              ldv_inline_asm();
              
#line 1613 
              goto ldv_56554;
              case (unsigned long)8: 
#line 1613 
              ;
              
#line 1614 
              ldv_inline_asm();
              
#line 1613 
              goto ldv_56554;
              default: 
#line 1613 
              ;
              
#line 1613 
              __bad_percpu_size();
            }
            ldv_56554: 
#line 1613 
            ;
            
#line 1613 
            tmp_1 = pfo_ret___1;
          }
          
#line 1613 
          pscr_ret__ = tmp_1;
          
#line 1613 
          goto ldv_56541;
          case (unsigned long)8: 
#line 1613 
          ;
          {
            int pfo_ret___2;
            
#line 1613 
            switch (4UL) {
              case (unsigned long)1: 
#line 1613 
              ;
              
#line 1614 
              ldv_inline_asm();
              
#line 1613 
              goto ldv_56563;
              case (unsigned long)2: 
#line 1613 
              ;
              
#line 1614 
              ldv_inline_asm();
              
#line 1613 
              goto ldv_56563;
              case (unsigned long)4: 
#line 1613 
              ;
              
#line 1614 
              ldv_inline_asm();
              
#line 1613 
              goto ldv_56563;
              case (unsigned long)8: 
#line 1613 
              ;
              
#line 1614 
              ldv_inline_asm();
              
#line 1613 
              goto ldv_56563;
              default: 
#line 1613 
              ;
              
#line 1613 
              __bad_percpu_size();
            }
            ldv_56563: 
#line 1613 
            ;
            
#line 1613 
            tmp_2 = pfo_ret___2;
          }
          
#line 1613 
          pscr_ret__ = tmp_2;
          
#line 1613 
          goto ldv_56541;
          default: 
#line 1613 
          ;
          
#line 1613 
          __bad_size_call_parameter();
          
#line 1613 
          goto ldv_56541;
        }
        ldv_56541: 
#line 1613 
        ;
        
#line 1613 
        tmp_3 = pscr_ret__;
      }
      
#line 1613 
      ;
      
#line 1613 
      ;
      
#line 1613 
      netdev_printk("\001",(struct net_device const *)efx->net_dev,"IRQ %d on CPU %d\n",irq,tmp_3);
    }
    else ;
  }
  else ;
  {
    
#line 1616 
    bool __var = (_Bool)0;
    
#line 1616 
    tmp_9 = (bool volatile *)(& efx->irq_soft_enabled);
  }
  
#line 1616 
  ;
  
#line 1616 
  if ((long)((int)*tmp_9 != 0) != 0L) {
    
#line 1618 
    if (context->index == efx->irq_level) {
      int tmp_8;
      {
        int pscr_ret___0;
        {
          
#line 1619 
          void const *__vpp_verify_0 = (void const *)0;
          
#line 1619 
          void const *tmp_4 = __vpp_verify_0;
        }
        
#line 1619 
        switch (4UL) {
          int tmp_4_0;
          int tmp_5;
          int tmp_6;
          int tmp_7;
          case (unsigned long)1: 
#line 1619 
          ;
          {
            int pfo_ret___3;
            
#line 1619 
            switch (4UL) {
              case (unsigned long)1: 
#line 1619 
              ;
              
#line 1620 
              ldv_inline_asm();
              
#line 1619 
              goto ldv_56579;
              case (unsigned long)2: 
#line 1619 
              ;
              
#line 1620 
              ldv_inline_asm();
              
#line 1619 
              goto ldv_56579;
              case (unsigned long)4: 
#line 1619 
              ;
              
#line 1620 
              ldv_inline_asm();
              
#line 1619 
              goto ldv_56579;
              case (unsigned long)8: 
#line 1619 
              ;
              
#line 1620 
              ldv_inline_asm();
              
#line 1619 
              goto ldv_56579;
              default: 
#line 1619 
              ;
              
#line 1619 
              __bad_percpu_size();
            }
            ldv_56579: 
#line 1619 
            ;
            
#line 1619 
            tmp_4_0 = pfo_ret___3;
          }
          
#line 1619 
          pscr_ret___0 = tmp_4_0;
          
#line 1619 
          goto ldv_56585;
          case (unsigned long)2: 
#line 1619 
          ;
          {
            int pfo_ret___4;
            
#line 1619 
            switch (4UL) {
              case (unsigned long)1: 
#line 1619 
              ;
              
#line 1620 
              ldv_inline_asm();
              
#line 1619 
              goto ldv_56589;
              case (unsigned long)2: 
#line 1619 
              ;
              
#line 1620 
              ldv_inline_asm();
              
#line 1619 
              goto ldv_56589;
              case (unsigned long)4: 
#line 1619 
              ;
              
#line 1620 
              ldv_inline_asm();
              
#line 1619 
              goto ldv_56589;
              case (unsigned long)8: 
#line 1619 
              ;
              
#line 1620 
              ldv_inline_asm();
              
#line 1619 
              goto ldv_56589;
              default: 
#line 1619 
              ;
              
#line 1619 
              __bad_percpu_size();
            }
            ldv_56589: 
#line 1619 
            ;
            
#line 1619 
            tmp_5 = pfo_ret___4;
          }
          
#line 1619 
          pscr_ret___0 = tmp_5;
          
#line 1619 
          goto ldv_56585;
          case (unsigned long)4: 
#line 1619 
          ;
          {
            int pfo_ret___5;
            
#line 1619 
            switch (4UL) {
              case (unsigned long)1: 
#line 1619 
              ;
              
#line 1620 
              ldv_inline_asm();
              
#line 1619 
              goto ldv_56598;
              case (unsigned long)2: 
#line 1619 
              ;
              
#line 1620 
              ldv_inline_asm();
              
#line 1619 
              goto ldv_56598;
              case (unsigned long)4: 
#line 1619 
              ;
              
#line 1620 
              ldv_inline_asm();
              
#line 1619 
              goto ldv_56598;
              case (unsigned long)8: 
#line 1619 
              ;
              
#line 1620 
              ldv_inline_asm();
              
#line 1619 
              goto ldv_56598;
              default: 
#line 1619 
              ;
              
#line 1619 
              __bad_percpu_size();
            }
            ldv_56598: 
#line 1619 
            ;
            
#line 1619 
            tmp_6 = pfo_ret___5;
          }
          
#line 1619 
          pscr_ret___0 = tmp_6;
          
#line 1619 
          goto ldv_56585;
          case (unsigned long)8: 
#line 1619 
          ;
          {
            int pfo_ret___6;
            
#line 1619 
            switch (4UL) {
              case (unsigned long)1: 
#line 1619 
              ;
              
#line 1620 
              ldv_inline_asm();
              
#line 1619 
              goto ldv_56607;
              case (unsigned long)2: 
#line 1619 
              ;
              
#line 1620 
              ldv_inline_asm();
              
#line 1619 
              goto ldv_56607;
              case (unsigned long)4: 
#line 1619 
              ;
              
#line 1620 
              ldv_inline_asm();
              
#line 1619 
              goto ldv_56607;
              case (unsigned long)8: 
#line 1619 
              ;
              
#line 1620 
              ldv_inline_asm();
              
#line 1619 
              goto ldv_56607;
              default: 
#line 1619 
              ;
              
#line 1619 
              __bad_percpu_size();
            }
            ldv_56607: 
#line 1619 
            ;
            
#line 1619 
            tmp_7 = pfo_ret___6;
          }
          
#line 1619 
          pscr_ret___0 = tmp_7;
          
#line 1619 
          goto ldv_56585;
          default: 
#line 1619 
          ;
          
#line 1619 
          __bad_size_call_parameter();
          
#line 1619 
          goto ldv_56585;
        }
        ldv_56585: 
#line 1619 
        ;
        
#line 1619 
        tmp_8 = pscr_ret___0;
      }
      
#line 1619 
      efx->last_irq_cpu = tmp_8;
    }
    else ;
    
#line 1622 
    efx_schedule_channel_irq_0(efx->channel[context->index]);
  }
  else ;
  
#line 1625 
  __retres = IRQ_HANDLED;
  
#line 1625 
  return __retres;
}


#line 1628  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static irqreturn_t efx_ef10_legacy_interrupt(int irq, void *dev_id)
{
  irqreturn_t __retres;
  bool volatile *tmp;
  struct efx_channel *channel;
  efx_dword_t reg;
  u32 queues;
  
#line 1630 
  struct efx_nic *efx = (struct efx_nic *)dev_id;
  {
    
#line 1631 
    bool __var = (_Bool)0;
    
#line 1631 
    tmp = (bool volatile *)(& efx->irq_soft_enabled);
  }
  
#line 1631 
  bool soft_enabled = *tmp;
  
#line 1637 
  efx_readd(efx,& reg,144U);
  
#line 1638 
  queues = reg.u32[0];
  
#line 1640 
  if (queues == 0U) {
    
#line 1641 
    __retres = IRQ_NONE;
    
#line 1641 
    goto return_label;
  }
  else ;
  
#line 1643 
  if ((long)((int)soft_enabled != 0) != 0L) {
    
#line 1645 
    if (((1U << efx->irq_level) & queues) != 0U) {
      int tmp_4;
      {
        int pscr_ret__;
        {
          
#line 1646 
          void const *__vpp_verify = (void const *)0;
          
#line 1646 
          void const *tmp_2 = __vpp_verify;
        }
        
#line 1646 
        switch (4UL) {
          int tmp_0;
          int tmp_1;
          int tmp_2_0;
          int tmp_3;
          case (unsigned long)1: 
#line 1646 
          ;
          {
            int pfo_ret__;
            
#line 1646 
            switch (4UL) {
              case (unsigned long)1: 
#line 1646 
              ;
              
#line 1647 
              ldv_inline_asm();
              
#line 1646 
              goto ldv_56631;
              case (unsigned long)2: 
#line 1646 
              ;
              
#line 1647 
              ldv_inline_asm();
              
#line 1646 
              goto ldv_56631;
              case (unsigned long)4: 
#line 1646 
              ;
              
#line 1647 
              ldv_inline_asm();
              
#line 1646 
              goto ldv_56631;
              case (unsigned long)8: 
#line 1646 
              ;
              
#line 1647 
              ldv_inline_asm();
              
#line 1646 
              goto ldv_56631;
              default: 
#line 1646 
              ;
              
#line 1646 
              __bad_percpu_size();
            }
            ldv_56631: 
#line 1646 
            ;
            
#line 1646 
            tmp_0 = pfo_ret__;
          }
          
#line 1646 
          pscr_ret__ = tmp_0;
          
#line 1646 
          goto ldv_56637;
          case (unsigned long)2: 
#line 1646 
          ;
          {
            int pfo_ret___0;
            
#line 1646 
            switch (4UL) {
              case (unsigned long)1: 
#line 1646 
              ;
              
#line 1647 
              ldv_inline_asm();
              
#line 1646 
              goto ldv_56641;
              case (unsigned long)2: 
#line 1646 
              ;
              
#line 1647 
              ldv_inline_asm();
              
#line 1646 
              goto ldv_56641;
              case (unsigned long)4: 
#line 1646 
              ;
              
#line 1647 
              ldv_inline_asm();
              
#line 1646 
              goto ldv_56641;
              case (unsigned long)8: 
#line 1646 
              ;
              
#line 1647 
              ldv_inline_asm();
              
#line 1646 
              goto ldv_56641;
              default: 
#line 1646 
              ;
              
#line 1646 
              __bad_percpu_size();
            }
            ldv_56641: 
#line 1646 
            ;
            
#line 1646 
            tmp_1 = pfo_ret___0;
          }
          
#line 1646 
          pscr_ret__ = tmp_1;
          
#line 1646 
          goto ldv_56637;
          case (unsigned long)4: 
#line 1646 
          ;
          {
            int pfo_ret___1;
            
#line 1646 
            switch (4UL) {
              case (unsigned long)1: 
#line 1646 
              ;
              
#line 1647 
              ldv_inline_asm();
              
#line 1646 
              goto ldv_56650;
              case (unsigned long)2: 
#line 1646 
              ;
              
#line 1647 
              ldv_inline_asm();
              
#line 1646 
              goto ldv_56650;
              case (unsigned long)4: 
#line 1646 
              ;
              
#line 1647 
              ldv_inline_asm();
              
#line 1646 
              goto ldv_56650;
              case (unsigned long)8: 
#line 1646 
              ;
              
#line 1647 
              ldv_inline_asm();
              
#line 1646 
              goto ldv_56650;
              default: 
#line 1646 
              ;
              
#line 1646 
              __bad_percpu_size();
            }
            ldv_56650: 
#line 1646 
            ;
            
#line 1646 
            tmp_2_0 = pfo_ret___1;
          }
          
#line 1646 
          pscr_ret__ = tmp_2_0;
          
#line 1646 
          goto ldv_56637;
          case (unsigned long)8: 
#line 1646 
          ;
          {
            int pfo_ret___2;
            
#line 1646 
            switch (4UL) {
              case (unsigned long)1: 
#line 1646 
              ;
              
#line 1647 
              ldv_inline_asm();
              
#line 1646 
              goto ldv_56659;
              case (unsigned long)2: 
#line 1646 
              ;
              
#line 1647 
              ldv_inline_asm();
              
#line 1646 
              goto ldv_56659;
              case (unsigned long)4: 
#line 1646 
              ;
              
#line 1647 
              ldv_inline_asm();
              
#line 1646 
              goto ldv_56659;
              case (unsigned long)8: 
#line 1646 
              ;
              
#line 1647 
              ldv_inline_asm();
              
#line 1646 
              goto ldv_56659;
              default: 
#line 1646 
              ;
              
#line 1646 
              __bad_percpu_size();
            }
            ldv_56659: 
#line 1646 
            ;
            
#line 1646 
            tmp_3 = pfo_ret___2;
          }
          
#line 1646 
          pscr_ret__ = tmp_3;
          
#line 1646 
          goto ldv_56637;
          default: 
#line 1646 
          ;
          
#line 1646 
          __bad_size_call_parameter();
          
#line 1646 
          goto ldv_56637;
        }
        ldv_56637: 
#line 1646 
        ;
        
#line 1646 
        tmp_4 = pscr_ret__;
      }
      
#line 1646 
      efx->last_irq_cpu = tmp_4;
    }
    else ;
    
#line 1648 
    channel = efx->channel[0];
    
#line 1648 
    goto ldv_56668;
    ldv_56667: 
#line 1649 
    ;
    
#line 1649 
    if ((queues & 1U) != 0U) 
#line 1650 
                             efx_schedule_channel_irq_0(channel); else ;
    
#line 1651 
    queues >>= 1;
    
#line 1648 
    if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 1648 
                                                                channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 1648 
                                                                    channel = (struct efx_channel *)0;
    ldv_56668: 
#line 1649 
    ;
    
#line 1648 
    if (channel != (struct efx_channel *)0) 
#line 1650 
                                            goto ldv_56667; else 
#line 1653 
                                                                 goto ldv_56669;
    ldv_56669: 
#line 1654 
    ;
  }
  else ;
  
#line 1655 
  if (0) {
    
#line 1655 
    if ((efx->msg_enable & 512U) != 0U) {
      int tmp_9;
      
#line 1655 
      ;
      {
        int pscr_ret___0;
        {
          
#line 1655 
          void const *__vpp_verify_0 = (void const *)0;
          
#line 1655 
          void const *tmp_5 = __vpp_verify_0;
        }
        
#line 1655 
        switch (4UL) {
          int tmp_5_0;
          int tmp_6;
          int tmp_7;
          int tmp_8;
          case (unsigned long)1: 
#line 1655 
          ;
          {
            int pfo_ret___3;
            
#line 1655 
            switch (4UL) {
              case (unsigned long)1: 
#line 1655 
              ;
              
#line 1656 
              ldv_inline_asm();
              
#line 1655 
              goto ldv_56675;
              case (unsigned long)2: 
#line 1655 
              ;
              
#line 1656 
              ldv_inline_asm();
              
#line 1655 
              goto ldv_56675;
              case (unsigned long)4: 
#line 1655 
              ;
              
#line 1656 
              ldv_inline_asm();
              
#line 1655 
              goto ldv_56675;
              case (unsigned long)8: 
#line 1655 
              ;
              
#line 1656 
              ldv_inline_asm();
              
#line 1655 
              goto ldv_56675;
              default: 
#line 1655 
              ;
              
#line 1655 
              __bad_percpu_size();
            }
            ldv_56675: 
#line 1655 
            ;
            
#line 1655 
            tmp_5_0 = pfo_ret___3;
          }
          
#line 1655 
          pscr_ret___0 = tmp_5_0;
          
#line 1655 
          goto ldv_56681;
          case (unsigned long)2: 
#line 1655 
          ;
          {
            int pfo_ret___4;
            
#line 1655 
            switch (4UL) {
              case (unsigned long)1: 
#line 1655 
              ;
              
#line 1656 
              ldv_inline_asm();
              
#line 1655 
              goto ldv_56685;
              case (unsigned long)2: 
#line 1655 
              ;
              
#line 1656 
              ldv_inline_asm();
              
#line 1655 
              goto ldv_56685;
              case (unsigned long)4: 
#line 1655 
              ;
              
#line 1656 
              ldv_inline_asm();
              
#line 1655 
              goto ldv_56685;
              case (unsigned long)8: 
#line 1655 
              ;
              
#line 1656 
              ldv_inline_asm();
              
#line 1655 
              goto ldv_56685;
              default: 
#line 1655 
              ;
              
#line 1655 
              __bad_percpu_size();
            }
            ldv_56685: 
#line 1655 
            ;
            
#line 1655 
            tmp_6 = pfo_ret___4;
          }
          
#line 1655 
          pscr_ret___0 = tmp_6;
          
#line 1655 
          goto ldv_56681;
          case (unsigned long)4: 
#line 1655 
          ;
          {
            int pfo_ret___5;
            
#line 1655 
            switch (4UL) {
              case (unsigned long)1: 
#line 1655 
              ;
              
#line 1656 
              ldv_inline_asm();
              
#line 1655 
              goto ldv_56694;
              case (unsigned long)2: 
#line 1655 
              ;
              
#line 1656 
              ldv_inline_asm();
              
#line 1655 
              goto ldv_56694;
              case (unsigned long)4: 
#line 1655 
              ;
              
#line 1656 
              ldv_inline_asm();
              
#line 1655 
              goto ldv_56694;
              case (unsigned long)8: 
#line 1655 
              ;
              
#line 1656 
              ldv_inline_asm();
              
#line 1655 
              goto ldv_56694;
              default: 
#line 1655 
              ;
              
#line 1655 
              __bad_percpu_size();
            }
            ldv_56694: 
#line 1655 
            ;
            
#line 1655 
            tmp_7 = pfo_ret___5;
          }
          
#line 1655 
          pscr_ret___0 = tmp_7;
          
#line 1655 
          goto ldv_56681;
          case (unsigned long)8: 
#line 1655 
          ;
          {
            int pfo_ret___6;
            
#line 1655 
            switch (4UL) {
              case (unsigned long)1: 
#line 1655 
              ;
              
#line 1656 
              ldv_inline_asm();
              
#line 1655 
              goto ldv_56703;
              case (unsigned long)2: 
#line 1655 
              ;
              
#line 1656 
              ldv_inline_asm();
              
#line 1655 
              goto ldv_56703;
              case (unsigned long)4: 
#line 1655 
              ;
              
#line 1656 
              ldv_inline_asm();
              
#line 1655 
              goto ldv_56703;
              case (unsigned long)8: 
#line 1655 
              ;
              
#line 1656 
              ldv_inline_asm();
              
#line 1655 
              goto ldv_56703;
              default: 
#line 1655 
              ;
              
#line 1655 
              __bad_percpu_size();
            }
            ldv_56703: 
#line 1655 
            ;
            
#line 1655 
            tmp_8 = pfo_ret___6;
          }
          
#line 1655 
          pscr_ret___0 = tmp_8;
          
#line 1655 
          goto ldv_56681;
          default: 
#line 1655 
          ;
          
#line 1655 
          __bad_size_call_parameter();
          
#line 1655 
          goto ldv_56681;
        }
        ldv_56681: 
#line 1655 
        ;
        
#line 1655 
        tmp_9 = pscr_ret___0;
      }
      
#line 1655 
      ;
      
#line 1655 
      ;
      
#line 1655 
      netdev_printk("\001",(struct net_device const *)efx->net_dev,"IRQ %d on CPU %d status ",irq,tmp_9,reg.u32[0]);
    }
    else ;
  }
  else ;
  
#line 1659 
  __retres = IRQ_HANDLED;
  return_label: 
#line 1659 
                return __retres;
}


#line 1666 
void __compiletime_assert_1666(void);


#line 1662  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_irq_test_generate(struct efx_nic *efx)
{
  
#line 1664 
  efx_dword_t inbuf[1U] = {{.u32 = {0U}}};
  {
    
#line 1666 
    bool __cond = (_Bool)0;
    
#line 1666 
    if ((int)__cond != 0) 
#line 1666 
                          __compiletime_assert_1666(); else ;
  }
  
#line 1668 
  ((efx_dword_t *)(& inbuf))->u32[0] = efx->irq_level;
  
#line 1669 
  efx_mcdi_rpc(efx,227U,(efx_dword_t const *)(& inbuf),4UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 1671 
  return;
}


#line 1673  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_tx_probe(struct efx_tx_queue *tx_queue)
{
  int tmp;
  
#line 1675 
  tmp = efx_nic_alloc_buffer(tx_queue->efx,& tx_queue->txd.buf,(tx_queue->ptr_mask + 1U) * 8U,208U);
  
#line 1675 
  return tmp;
}


#line 1682  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
__inline static void efx_ef10_push_tx_desc(struct efx_tx_queue *tx_queue, efx_qword_t const *txd)
{
  unsigned int write_ptr;
  efx_oword_t reg;
  
#line 1688 
  write_ptr = tx_queue->write_count & tx_queue->ptr_mask;
  
#line 1689 
  reg.u64[0] = 0ULL;
  
#line 1689 
  reg.u64[1] = (unsigned long long)write_ptr;
  
#line 1690 
  reg.qword[0] = *txd;
  
#line 1691 
  _efx_writeo_page(tx_queue->efx,& reg,2576U,tx_queue->queue);
  
#line 1692 
  return;
}


#line 1709 
void __compiletime_assert_1709(void);


#line 1695  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_tx_init(struct efx_tx_queue *tx_queue)
{
  size_t inlen;
  dma_addr_t dma_addr;
  efx_qword_t *txd;
  int rc;
  int i;
  
#line 1697 
  efx_dword_t inbuf[23U] = {{.u32 = {0U}}};
  
#line 1699 
  bool csum_offload = (_Bool)((tx_queue->queue & 1U) != 0U);
  
#line 1700 
  size_t entries = (unsigned long)(tx_queue->txd.buf.len / 4096U);
  
#line 1701 
  struct efx_channel *channel = tx_queue->channel;
  
#line 1702 
  struct efx_nic *efx = tx_queue->efx;
  
#line 1703 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  {
    
#line 1709 
    bool __cond = (_Bool)0;
    
#line 1709 
    if ((int)__cond != 0) 
#line 1709 
                          __compiletime_assert_1709(); else ;
  }
  
#line 1711 
  ((efx_dword_t *)(& inbuf))->u32[0] = tx_queue->ptr_mask + 1U;
  
#line 1712 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = (unsigned int)channel->channel;
  
#line 1713 
  ((efx_dword_t *)(& inbuf) + 2U)->u32[0] = tx_queue->queue;
  
#line 1714 
  ((efx_dword_t *)(& inbuf) + 3U)->u32[0] = tx_queue->queue;
  
#line 1715 
  ((efx_dword_t *)(& inbuf) + 4U)->u32[0] = ((unsigned int)(! csum_offload) << 1) | ((unsigned int)(! csum_offload) << 2);
  
#line 1718 
  ((efx_dword_t *)(& inbuf) + 5U)->u32[0] = 0U;
  
#line 1719 
  ((efx_dword_t *)(& inbuf) + 6U)->u32[0] = nic_data->vport_id;
  
#line 1721 
  dma_addr = tx_queue->txd.buf.dma_addr;
  
#line 1723 
  if ((efx->msg_enable & 8192U) != 0U) {
    
#line 1723 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_ef10_tx_init", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c", .format = "pushing TXQ %d. %zu entries (%llx)\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1724U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1723 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1723 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"pushing TXQ %d. %zu entries (%llx)\n",tx_queue->queue,entries,dma_addr); else ;
  }
  else ;
  
#line 1726 
  i = 0;
  
#line 1726 
  goto ldv_56813;
  ldv_56812: 
#line 1727 
  ;
  
#line 1727 
  ((efx_dword_t *)(& inbuf) + ((unsigned long)i * 8UL + (unsigned long)28U))->u32[0] = (unsigned int)dma_addr;
  
#line 1727 
  ((efx_dword_t *)(& inbuf) + ((unsigned long)i * 8UL + (unsigned long)29U))->u32[0] = (unsigned int)(dma_addr >> 32);
  
#line 1728 
  dma_addr += 4096ULL;
  
#line 1726 
  i += 1;
  ldv_56813: 
#line 1727 
  ;
  
#line 1726 
  if ((unsigned long)i < entries) 
#line 1728 
                                  goto ldv_56812; else 
#line 1731 
                                                       goto ldv_56814;
  ldv_56814: 
#line 1732 
  ;
  
#line 1731 
  inlen = entries * 8UL + 28UL;
  
#line 1733 
  rc = efx_mcdi_rpc(efx,130U,(efx_dword_t const *)(& inbuf),inlen,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 1735 
  if (rc != 0) 
#line 1736 
               goto fail; else ;
  
#line 1744 
  (tx_queue->buffer)->flags = (unsigned short)16U;
  
#line 1745 
  tx_queue->insert_count = 1U;
  
#line 1746 
  txd = efx_tx_desc(tx_queue,0U);
  
#line 1747 
  txd->u64[0] = (((unsigned long long)csum_offload << 1) | (unsigned long long)csum_offload) | 9223372036854775808ULL;
  
#line 1753 
  tx_queue->write_count = 1U;
  
#line 1754 
  ldv_inline_asm();
  
#line 1755 
  efx_ef10_push_tx_desc(tx_queue,(efx_qword_t const *)txd);
  
#line 1757 
  goto return_label;
  fail: 
#line 1759 
  ;
  {
    
#line 1760 
    int __ret_warn_on = 1;
    
#line 1760 
    if ((long)(__ret_warn_on != 0) != 0L) {
      char const *tmp;
      char const *tmp_0;
      
#line 1760 
      ;
      
#line 1760 
      tmp = netdev_reg_state((struct net_device const *)efx->net_dev);
      
#line 1760 
      tmp_0 = netdev_name((struct net_device const *)efx->net_dev);
      
#line 1760 
      warn_slowpath_fmt("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c",1761,"netdevice: %s%s\n",tmp_0,tmp,tx_queue->queue);
    }
    else ;
    
#line 1760 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  return_label: 
#line 1762 
                return;
}


#line 1764  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_tx_fini(struct efx_tx_queue *tx_queue)
{
  size_t outlen;
  int rc;
  
#line 1766 
  efx_dword_t inbuf[1U] = {{.u32 = {0U}}};
  
#line 1767 
  efx_dword_t outbuf[2U] = {{.u32 = {0U}}};
  
#line 1768 
  struct efx_nic *efx = tx_queue->efx;
  
#line 1772 
  ((efx_dword_t *)(& inbuf))->u32[0] = tx_queue->queue;
  
#line 1775 
  rc = efx_mcdi_rpc_quiet(efx,133U,(efx_dword_t const *)(& inbuf),4UL,(efx_dword_t *)(& outbuf),8UL,& outlen);
  
#line 1778 
  if (rc != 0 && rc != -114) 
#line 1779 
                             goto fail; else ;
  
#line 1781 
  goto return_label;
  fail: 
#line 1783 
  ;
  
#line 1784 
  efx_mcdi_display_error(efx,133U,4UL,(efx_dword_t *)(& outbuf),outlen,rc);
  return_label: 
#line 1786 
                return;
}


#line 1788  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_tx_remove(struct efx_tx_queue *tx_queue)
{
  
#line 1790 
  efx_nic_free_buffer(tx_queue->efx,& tx_queue->txd.buf);
  
#line 1791 
  return;
}


#line 1794  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
__inline static void efx_ef10_notify_tx_desc(struct efx_tx_queue *tx_queue)
{
  unsigned int write_ptr;
  efx_dword_t reg;
  
#line 1799 
  write_ptr = tx_queue->write_count & tx_queue->ptr_mask;
  
#line 1800 
  reg.u32[0] = write_ptr;
  
#line 1801 
  _efx_writed_page(tx_queue->efx,(efx_dword_t const *)(& reg),2584U,tx_queue->queue);
  
#line 1802 
  return;
}


#line 1824 
void __compiletime_assert_1824(void);


#line 1805  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_tx_write(struct efx_tx_queue *tx_queue)
{
  struct efx_tx_buffer *buffer;
  unsigned int write_ptr;
  efx_qword_t *txd;
  bool tmp;
  
#line 1807 
  unsigned int old_write_count = tx_queue->write_count;
  
#line 1812 
  if ((long)(tx_queue->write_count == tx_queue->insert_count) != 0L) {
    
#line 1814 
    ldv_inline_asm();
    
#line 1812 
    ;
  }
  else ;
  ldv_56852: 
#line 1814 
  ;
  
#line 1815 
  write_ptr = tx_queue->write_count & tx_queue->ptr_mask;
  
#line 1816 
  buffer = tx_queue->buffer + write_ptr;
  
#line 1817 
  txd = efx_tx_desc(tx_queue,write_ptr);
  
#line 1818 
  tx_queue->write_count += 1U;
  
#line 1821 
  if (((int)buffer->flags & 16) != 0) 
#line 1822 
                                      *txd = buffer->__anonCompField_efx_tx_buffer_116.option;
  else {
    {
      
#line 1824 
      bool __cond = (_Bool)0;
      
#line 1824 
      if ((int)__cond != 0) 
#line 1824 
                            __compiletime_assert_1824(); else ;
    }
    
#line 1825 
    txd->u64[0] = ((((unsigned long long)buffer->flags << 62) & 4611686018427387904ULL) | ((unsigned long long)buffer->len << 48)) | buffer->__anonCompField_efx_tx_buffer_116.dma_addr;
  }
  
#line 1832 
  if (tx_queue->write_count != tx_queue->insert_count) 
#line 1834 
                                                       goto ldv_56852; else 
                                                                    
#line 1837 
                                                                    goto ldv_56853;
  ldv_56853: 
#line 1838 
  ;
  
#line 1839 
  ldv_inline_asm();
  
#line 1836 
  tmp = efx_nic_may_push_tx_desc(tx_queue,old_write_count);
  
#line 1836 
  if ((int)tmp != 0) {
    
#line 1837 
    txd = efx_tx_desc(tx_queue,tx_queue->ptr_mask & old_write_count);
    
#line 1839 
    efx_ef10_push_tx_desc(tx_queue,(efx_qword_t const *)txd);
    
#line 1840 
    tx_queue->pushes += 1U;
  }
  else 
#line 1842 
       efx_ef10_notify_tx_desc(tx_queue);
  
#line 1843 
  return;
}


#line 1846  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_alloc_rss_context(struct efx_nic *efx, u32 *context, bool exclusive, unsigned int *context_size)
{
  int __retres;
  size_t outlen;
  int rc;
  unsigned int tmp_71;
  
#line 1849 
  efx_dword_t inbuf[3U] = {{.u32 = {0U}}};
  
#line 1850 
  efx_dword_t outbuf[1U] = {{.u32 = {0U}}};
  
#line 1851 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 1854 
  u32 alloc_type = (unsigned int)(! exclusive);
  
#line 1857 
  if ((int)exclusive != 0) 
#line 1857 
                           tmp_71 = efx->rss_spread;
  else {
    unsigned long tmp_70;
    {
      unsigned long tmp_68;
      unsigned long tmp_69;
      
#line 1859 
      if (0 != 0) {
        unsigned long tmp_66;
        
#line 1859 
        if (0 != 0) {
          unsigned long tmp_64;
          
#line 1859 
          if (efx->rss_spread == 0U) {
            int tmp;
            
#line 1859 
            tmp = ____ilog2_NaN();
            
#line 1859 
            tmp_64 = 1UL << tmp;
          }
          else {
            unsigned long tmp_63;
            
#line 1859 
            if (((unsigned long long)efx->rss_spread & 4611686018427387904ULL) == 0ULL) {
              unsigned long tmp_62;
              
#line 1859 
              if (((unsigned long long)efx->rss_spread & 2305843009213693952ULL) == 0ULL) {
                unsigned long tmp_61;
                
#line 1859 
                if (((unsigned long long)efx->rss_spread & 1152921504606846976ULL) == 0ULL) {
                  unsigned long tmp_60;
                  
#line 1859 
                  if (((unsigned long long)efx->rss_spread & 576460752303423488ULL) == 0ULL) {
                    unsigned long tmp_59;
                    
#line 1859 
                    if (((unsigned long long)efx->rss_spread & 288230376151711744ULL) == 0ULL) {
                      unsigned long tmp_58;
                      
#line 1859 
                      if (((unsigned long long)efx->rss_spread & 144115188075855872ULL) == 0ULL) {
                        unsigned long tmp_57;
                        
#line 1859 
                        if (((unsigned long long)efx->rss_spread & 72057594037927936ULL) == 0ULL) {
                          unsigned long tmp_56;
                          
#line 1859 
                          if (((unsigned long long)efx->rss_spread & 36028797018963968ULL) == 0ULL) {
                            unsigned long tmp_55;
                            
#line 1859 
                            if (((unsigned long long)efx->rss_spread & 18014398509481984ULL) == 0ULL) {
                              unsigned long tmp_54;
                              
#line 1859 
                              if (((unsigned long long)efx->rss_spread & 9007199254740992ULL) == 0ULL) {
                                unsigned long tmp_53;
                                
#line 1859 
                                if (((unsigned long long)efx->rss_spread & 4503599627370496ULL) == 0ULL) {
                                  unsigned long tmp_52;
                                  
#line 1859 
                                  if (((unsigned long long)efx->rss_spread & 2251799813685248ULL) == 0ULL) {
                                    unsigned long tmp_51;
                                    
#line 1859 
                                    if (((unsigned long long)efx->rss_spread & 1125899906842624ULL) == 0ULL) {
                                      unsigned long tmp_50;
                                      
#line 1859 
                                      if (((unsigned long long)efx->rss_spread & 562949953421312ULL) == 0ULL) {
                                        unsigned long tmp_49;
                                        
#line 1859 
                                        if (((unsigned long long)efx->rss_spread & 281474976710656ULL) == 0ULL) {
                                          unsigned long tmp_48;
                                          
#line 1859 
                                          if (((unsigned long long)efx->rss_spread & 140737488355328ULL) == 0ULL) {
                                            unsigned long tmp_47;
                                            
#line 1859 
                                            if (((unsigned long long)efx->rss_spread & 70368744177664ULL) == 0ULL) {
                                              unsigned long tmp_46;
                                              
#line 1859 
                                              if (((unsigned long long)efx->rss_spread & 35184372088832ULL) == 0ULL) {
                                                unsigned long tmp_45;
                                                
#line 1859 
                                                if (((unsigned long long)efx->rss_spread & 17592186044416ULL) == 0ULL) {
                                                  unsigned long tmp_44;
                                                  
#line 1859 
                                                  if (((unsigned long long)efx->rss_spread & 8796093022208ULL) == 0ULL) {
                                                    unsigned long tmp_43;
                                                    
#line 1859 
                                                    if (((unsigned long long)efx->rss_spread & 4398046511104ULL) == 0ULL) {
                                                      unsigned long tmp_42;
                                                      
#line 1859 
                                                      if (((unsigned long long)efx->rss_spread & 2199023255552ULL) == 0ULL) {
                                                        unsigned long tmp_41;
                                                        
#line 1859 
                                                        if (((unsigned long long)efx->rss_spread & 1099511627776ULL) == 0ULL) {
                                                          unsigned long tmp_40;
                                                          
#line 1859 
                                                          if (((unsigned long long)efx->rss_spread & 549755813888ULL) == 0ULL) {
                                                            unsigned long tmp_39;
                                                            
#line 1859 
                                                            if (((unsigned long long)efx->rss_spread & 274877906944ULL) == 0ULL) {
                                                              unsigned long tmp_38;
                                                              
#line 1859 
                                                              if (((unsigned long long)efx->rss_spread & 137438953472ULL) == 0ULL) {
                                                                unsigned long tmp_37;
                                                                
#line 1859 
                                                                if (((unsigned long long)efx->rss_spread & 68719476736ULL) == 0ULL) {
                                                                  unsigned long tmp_36;
                                                                  
#line 1859 
                                                                  if (
                                                                    ((unsigned long long)efx->rss_spread & 34359738368ULL) == 0ULL) {
                                                                    unsigned long tmp_35;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 17179869184ULL) == 0ULL) {
                                                                    unsigned long tmp_34;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 8589934592ULL) == 0ULL) {
                                                                    unsigned long tmp_33;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 4294967296ULL) == 0ULL) {
                                                                    unsigned long tmp_32;
                                                                    
#line 1859 
                                                                    if (
                                                                    efx->rss_spread >= (unsigned int)0) {
                                                                    unsigned long tmp_31;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 1073741824ULL) == 0ULL) {
                                                                    unsigned long tmp_30;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 536870912ULL) == 0ULL) {
                                                                    unsigned long tmp_29;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 268435456ULL) == 0ULL) {
                                                                    unsigned long tmp_28;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 134217728ULL) == 0ULL) {
                                                                    unsigned long tmp_27;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 67108864ULL) == 0ULL) {
                                                                    unsigned long tmp_26;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 33554432ULL) == 0ULL) {
                                                                    unsigned long tmp_25;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 16777216ULL) == 0ULL) {
                                                                    unsigned long tmp_24;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 8388608ULL) == 0ULL) {
                                                                    unsigned long tmp_23;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 4194304ULL) == 0ULL) {
                                                                    unsigned long tmp_22;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 2097152ULL) == 0ULL) {
                                                                    unsigned long tmp_21;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 1048576ULL) == 0ULL) {
                                                                    unsigned long tmp_20;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 524288ULL) == 0ULL) {
                                                                    unsigned long tmp_19;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 262144ULL) == 0ULL) {
                                                                    unsigned long tmp_18;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 131072ULL) == 0ULL) {
                                                                    unsigned long tmp_17;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 65536ULL) == 0ULL) {
                                                                    unsigned long tmp_16;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 32768ULL) == 0ULL) {
                                                                    unsigned long tmp_15;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 16384ULL) == 0ULL) {
                                                                    unsigned long tmp_14;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 8192ULL) == 0ULL) {
                                                                    unsigned long tmp_13;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 4096ULL) == 0ULL) {
                                                                    unsigned long tmp_12;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 2048ULL) == 0ULL) {
                                                                    unsigned long tmp_11;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 1024ULL) == 0ULL) {
                                                                    unsigned long tmp_10;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 512ULL) == 0ULL) {
                                                                    unsigned long tmp_9;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 256ULL) == 0ULL) {
                                                                    unsigned long tmp_8;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 128ULL) == 0ULL) {
                                                                    unsigned long tmp_7;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 64ULL) == 0ULL) {
                                                                    unsigned long tmp_6;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 32ULL) == 0ULL) {
                                                                    unsigned long tmp_5;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 16ULL) == 0ULL) {
                                                                    unsigned long tmp_4;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 8ULL) == 0ULL) {
                                                                    unsigned long tmp_3;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 4ULL) == 0ULL) {
                                                                    unsigned long tmp_2;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 2ULL) == 0ULL) {
                                                                    unsigned long tmp_1;
                                                                    
#line 1859 
                                                                    if (
                                                                    ((unsigned long long)efx->rss_spread & 1ULL) == 0ULL) {
                                                                    int tmp_0;
                                                                    
#line 1859 
                                                                    tmp_0 = ____ilog2_NaN();
                                                                    
#line 1859 
                                                                    tmp_1 = 1UL << tmp_0;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_1 = 1UL;
                                                                    
#line 1859 
                                                                    tmp_2 = tmp_1;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_2 = 2UL;
                                                                    
#line 1859 
                                                                    tmp_3 = tmp_2;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_3 = 4UL;
                                                                    
#line 1859 
                                                                    tmp_4 = tmp_3;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_4 = 8UL;
                                                                    
#line 1859 
                                                                    tmp_5 = tmp_4;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_5 = 16UL;
                                                                    
#line 1859 
                                                                    tmp_6 = tmp_5;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_6 = 32UL;
                                                                    
#line 1859 
                                                                    tmp_7 = tmp_6;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_7 = 64UL;
                                                                    
#line 1859 
                                                                    tmp_8 = tmp_7;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_8 = 128UL;
                                                                    
#line 1859 
                                                                    tmp_9 = tmp_8;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_9 = 256UL;
                                                                    
#line 1859 
                                                                    tmp_10 = tmp_9;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_10 = 512UL;
                                                                    
#line 1859 
                                                                    tmp_11 = tmp_10;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_11 = 1024UL;
                                                                    
#line 1859 
                                                                    tmp_12 = tmp_11;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_12 = 2048UL;
                                                                    
#line 1859 
                                                                    tmp_13 = tmp_12;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_13 = 4096UL;
                                                                    
#line 1859 
                                                                    tmp_14 = tmp_13;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_14 = 8192UL;
                                                                    
#line 1859 
                                                                    tmp_15 = tmp_14;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_15 = 16384UL;
                                                                    
#line 1859 
                                                                    tmp_16 = tmp_15;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_16 = 32768UL;
                                                                    
#line 1859 
                                                                    tmp_17 = tmp_16;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_17 = 65536UL;
                                                                    
#line 1859 
                                                                    tmp_18 = tmp_17;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_18 = 131072UL;
                                                                    
#line 1859 
                                                                    tmp_19 = tmp_18;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_19 = 262144UL;
                                                                    
#line 1859 
                                                                    tmp_20 = tmp_19;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_20 = 524288UL;
                                                                    
#line 1859 
                                                                    tmp_21 = tmp_20;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_21 = 1048576UL;
                                                                    
#line 1859 
                                                                    tmp_22 = tmp_21;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_22 = 2097152UL;
                                                                    
#line 1859 
                                                                    tmp_23 = tmp_22;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_23 = 4194304UL;
                                                                    
#line 1859 
                                                                    tmp_24 = tmp_23;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_24 = 8388608UL;
                                                                    
#line 1859 
                                                                    tmp_25 = tmp_24;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_25 = 16777216UL;
                                                                    
#line 1859 
                                                                    tmp_26 = tmp_25;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_26 = 33554432UL;
                                                                    
#line 1859 
                                                                    tmp_27 = tmp_26;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_27 = 67108864UL;
                                                                    
#line 1859 
                                                                    tmp_28 = tmp_27;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_28 = 134217728UL;
                                                                    
#line 1859 
                                                                    tmp_29 = tmp_28;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_29 = 268435456UL;
                                                                    
#line 1859 
                                                                    tmp_30 = tmp_29;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_30 = 536870912UL;
                                                                    
#line 1859 
                                                                    tmp_31 = tmp_30;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_31 = 1073741824UL;
                                                                    
#line 1859 
                                                                    tmp_32 = tmp_31;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_32 = 2147483648UL;
                                                                    
#line 1859 
                                                                    tmp_33 = tmp_32;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_33 = 4294967296UL;
                                                                    
#line 1859 
                                                                    tmp_34 = tmp_33;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_34 = 8589934592UL;
                                                                    
#line 1859 
                                                                    tmp_35 = tmp_34;
                                                                    }
                                                                    else 
                                                                    
#line 1859 
                                                                    tmp_35 = 17179869184UL;
                                                                    
#line 1859 
                                                                    tmp_36 = tmp_35;
                                                                  }
                                                                  else 
                                                                    
#line 1859 
                                                                    tmp_36 = 34359738368UL;
                                                                  
#line 1859 
                                                                  tmp_37 = tmp_36;
                                                                }
                                                                else 
                                                                  
#line 1859 
                                                                  tmp_37 = 68719476736UL;
                                                                
#line 1859 
                                                                tmp_38 = tmp_37;
                                                              }
                                                              else 
#line 1859 
                                                                   tmp_38 = 137438953472UL;
                                                              
#line 1859 
                                                              tmp_39 = tmp_38;
                                                            }
                                                            else 
#line 1859 
                                                                 tmp_39 = 274877906944UL;
                                                            
#line 1859 
                                                            tmp_40 = tmp_39;
                                                          }
                                                          else 
#line 1859 
                                                               tmp_40 = 549755813888UL;
                                                          
#line 1859 
                                                          tmp_41 = tmp_40;
                                                        }
                                                        else 
#line 1859 
                                                             tmp_41 = 1099511627776UL;
                                                        
#line 1859 
                                                        tmp_42 = tmp_41;
                                                      }
                                                      else 
#line 1859 
                                                           tmp_42 = 2199023255552UL;
                                                      
#line 1859 
                                                      tmp_43 = tmp_42;
                                                    }
                                                    else 
#line 1859 
                                                         tmp_43 = 4398046511104UL;
                                                    
#line 1859 
                                                    tmp_44 = tmp_43;
                                                  }
                                                  else 
#line 1859 
                                                       tmp_44 = 8796093022208UL;
                                                  
#line 1859 
                                                  tmp_45 = tmp_44;
                                                }
                                                else 
#line 1859 
                                                     tmp_45 = 17592186044416UL;
                                                
#line 1859 
                                                tmp_46 = tmp_45;
                                              }
                                              else 
#line 1859 
                                                   tmp_46 = 35184372088832UL;
                                              
#line 1859 
                                              tmp_47 = tmp_46;
                                            }
                                            else 
#line 1859 
                                                 tmp_47 = 70368744177664UL;
                                            
#line 1859 
                                            tmp_48 = tmp_47;
                                          }
                                          else 
#line 1859 
                                               tmp_48 = 140737488355328UL;
                                          
#line 1859 
                                          tmp_49 = tmp_48;
                                        }
                                        else 
#line 1859 
                                             tmp_49 = 281474976710656UL;
                                        
#line 1859 
                                        tmp_50 = tmp_49;
                                      }
                                      else 
#line 1859 
                                           tmp_50 = 562949953421312UL;
                                      
#line 1859 
                                      tmp_51 = tmp_50;
                                    }
                                    else 
#line 1859 
                                         tmp_51 = 1125899906842624UL;
                                    
#line 1859 
                                    tmp_52 = tmp_51;
                                  }
                                  else 
#line 1859 
                                       tmp_52 = 2251799813685248UL;
                                  
#line 1859 
                                  tmp_53 = tmp_52;
                                }
                                else 
#line 1859 
                                     tmp_53 = 4503599627370496UL;
                                
#line 1859 
                                tmp_54 = tmp_53;
                              }
                              else 
#line 1859 
                                   tmp_54 = 9007199254740992UL;
                              
#line 1859 
                              tmp_55 = tmp_54;
                            }
                            else 
#line 1859 
                                 tmp_55 = 18014398509481984UL;
                            
#line 1859 
                            tmp_56 = tmp_55;
                          }
                          else 
#line 1859 
                               tmp_56 = 36028797018963968UL;
                          
#line 1859 
                          tmp_57 = tmp_56;
                        }
                        else 
#line 1859 
                             tmp_57 = 72057594037927936UL;
                        
#line 1859 
                        tmp_58 = tmp_57;
                      }
                      else 
#line 1859 
                           tmp_58 = 144115188075855872UL;
                      
#line 1859 
                      tmp_59 = tmp_58;
                    }
                    else 
#line 1859 
                         tmp_59 = 288230376151711744UL;
                    
#line 1859 
                    tmp_60 = tmp_59;
                  }
                  else 
#line 1859 
                       tmp_60 = 576460752303423488UL;
                  
#line 1859 
                  tmp_61 = tmp_60;
                }
                else 
#line 1859 
                     tmp_61 = 1152921504606846976UL;
                
#line 1859 
                tmp_62 = tmp_61;
              }
              else 
#line 1859 
                   tmp_62 = 2305843009213693952UL;
              
#line 1859 
              tmp_63 = tmp_62;
            }
            else 
#line 1859 
                 tmp_63 = 4611686018427387904UL;
            
#line 1859 
            tmp_64 = tmp_63;
          }
          
#line 1859 
          tmp_66 = tmp_64;
        }
        else {
          int tmp_65;
          
#line 1859 
          tmp_65 = __ilog2_u32(efx->rss_spread);
          
#line 1859 
          tmp_66 = 1UL << tmp_65;
        }
        
#line 1859 
        tmp_68 = tmp_66;
      }
      else 
#line 1859 
           tmp_68 = __rounddown_pow_of_two((unsigned long)efx->rss_spread);
      
#line 1859 
      unsigned long _min1 = tmp_68;
      
#line 1859 
      unsigned long _min2 = 64UL;
      
#line 1859 
      if (_min1 < _min2) 
#line 1859 
                         tmp_69 = _min1; else 
#line 1859 
                                              tmp_69 = _min2;
      
#line 1859 
      tmp_70 = tmp_69;
    }
    
#line 1857 
    tmp_71 = (unsigned int)tmp_70;
  }
  
#line 1857 
  unsigned int rss_spread = tmp_71;
  
#line 1862 
  if (! exclusive && rss_spread == 1U) {
    
#line 1863 
    *context = 4294967295U;
    
#line 1864 
    if (context_size != (unsigned int *)0U) 
#line 1865 
                                            *context_size = 1U; else ;
    
#line 1866 
    __retres = 0;
    
#line 1866 
    goto return_label;
  }
  else ;
  
#line 1869 
  ((efx_dword_t *)(& inbuf))->u32[0] = nic_data->vport_id;
  
#line 1871 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = alloc_type;
  
#line 1872 
  ((efx_dword_t *)(& inbuf) + 2U)->u32[0] = rss_spread;
  
#line 1874 
  rc = efx_mcdi_rpc(efx,158U,(efx_dword_t const *)(& inbuf),12UL,(efx_dword_t *)(& outbuf),4UL,& outlen);
  
#line 1876 
  if (rc != 0) {
    
#line 1877 
    __retres = rc;
    
#line 1877 
    goto return_label;
  }
  else ;
  
#line 1879 
  if (outlen <= 3UL) {
    
#line 1880 
    __retres = -5;
    
#line 1880 
    goto return_label;
  }
  else ;
  
#line 1882 
  *context = ((efx_dword_t *)(& outbuf))->u32[0];
  
#line 1884 
  if (context_size != (unsigned int *)0U) 
#line 1885 
                                          *context_size = rss_spread; else ;
  
#line 1887 
  __retres = 0;
  return_label: 
#line 1887 
                return __retres;
}


#line 1890  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_free_rss_context(struct efx_nic *efx, u32 context)
{
  int rc;
  
#line 1892 
  efx_dword_t inbuf[1U] = {{.u32 = {0U}}};
  
#line 1895 
  ((efx_dword_t *)(& inbuf))->u32[0] = context;
  
#line 1898 
  rc = efx_mcdi_rpc(efx,159U,(efx_dword_t const *)(& inbuf),4UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  {
    
#line 1900 
    int __ret_warn_on = rc != 0;
    
#line 1900 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 1900 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c",1900); else ;
    
#line 1900 
    long tmp = (long)(__ret_warn_on != 0);
  }
  
#line 1902 
  return;
}


#line 1912 
void __compiletime_assert_1913(void);


#line 1927 
void __compiletime_assert_1928(void);


#line 1903  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_populate_rss_table(struct efx_nic *efx, u32 context, u32 const *rx_indir_table)
{
  int __retres;
  int i;
  int rc;
  int tmp;
  
#line 1906 
  efx_dword_t tablebuf[33U] = {{.u32 = {0U}}};
  
#line 1907 
  efx_dword_t keybuf[11U] = {{.u32 = {0U}}};
  
#line 1910 
  ((efx_dword_t *)(& tablebuf))->u32[0] = context;
  {
    
#line 1912 
    bool __cond = (_Bool)0;
    
#line 1912 
    if ((int)__cond != 0) 
#line 1912 
                          __compiletime_assert_1913(); else ;
  }
  
#line 1915 
  i = 0;
  
#line 1915 
  goto ldv_56919;
  ldv_56918: 
#line 1916 
  ;
  
#line 1917 
  *((u8 *)(& tablebuf) + ((unsigned int)i + 4U)) = (unsigned char)*(rx_indir_table + i);
  
#line 1915 
  i += 1;
  ldv_56919: 
#line 1916 
  ;
  
#line 1915 
  if ((unsigned int)i <= 127U) 
#line 1917 
                               goto ldv_56918; else 
#line 1920 
                                                    goto ldv_56920;
  ldv_56920: 
#line 1921 
  ;
  
#line 1920 
  rc = efx_mcdi_rpc(efx,162U,(efx_dword_t const *)(& tablebuf),132UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 1922 
  if (rc != 0) {
    
#line 1923 
    __retres = rc;
    
#line 1923 
    goto return_label;
  }
  else ;
  
#line 1925 
  ((efx_dword_t *)(& keybuf))->u32[0] = context;
  {
    
#line 1927 
    bool __cond_0 = (_Bool)0;
    
#line 1927 
    if ((int)__cond_0 != 0) 
#line 1927 
                            __compiletime_assert_1928(); else ;
  }
  
#line 1929 
  i = 0;
  
#line 1929 
  goto ldv_56935;
  ldv_56934: 
#line 1930 
  ;
  
#line 1930 
  *((u8 *)(& keybuf) + ((unsigned int)i + 4U)) = efx->rx_hash_key[i];
  
#line 1929 
  i += 1;
  ldv_56935: 
#line 1930 
  ;
  
#line 1929 
  if ((unsigned int)i <= 39U) 
#line 1931 
                              goto ldv_56934; else 
#line 1934 
                                                   goto ldv_56936;
  ldv_56936: 
#line 1935 
  ;
  
#line 1933 
  tmp = efx_mcdi_rpc(efx,160U,(efx_dword_t const *)(& keybuf),44UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 1933 
  __retres = tmp;
  return_label: 
#line 1933 
                return __retres;
}


#line 1937  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_rx_free_indir_table(struct efx_nic *efx)
{
  
#line 1939 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 1941 
  if (nic_data->rx_rss_context != 4294967295U) 
#line 1942 
                                               efx_ef10_free_rss_context(efx,nic_data->rx_rss_context); else ;
  
#line 1943 
  nic_data->rx_rss_context = 4294967295U;
  
#line 1944 
  return;
}


#line 1946  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_rx_push_shared_rss_config(struct efx_nic *efx, unsigned int *context_size)
{
  int __retres;
  u32 new_rx_rss_context;
  
#line 1950 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 1951 
  int rc = efx_ef10_alloc_rss_context(efx,& new_rx_rss_context,(_Bool)0,context_size);
  
#line 1954 
  if (rc != 0) {
    
#line 1955 
    __retres = rc;
    
#line 1955 
    goto return_label;
  }
  else ;
  
#line 1957 
  nic_data->rx_rss_context = new_rx_rss_context;
  
#line 1958 
  nic_data->rx_rss_context_exclusive = (_Bool)0;
  
#line 1959 
  efx_set_default_rx_indir_table(efx);
  
#line 1960 
  __retres = 0;
  return_label: 
#line 1960 
                return __retres;
}


#line 1963  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_rx_push_exclusive_rss_config(struct efx_nic *efx, u32 const *rx_indir_table)
{
  int __retres;
  int rc;
  u32 new_rx_rss_context;
  
#line 1966 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 1970 
  if (nic_data->rx_rss_context == 4294967295U || ! nic_data->rx_rss_context_exclusive) {
    
#line 1972 
    rc = efx_ef10_alloc_rss_context(efx,& new_rx_rss_context,(_Bool)1,(unsigned int *)0U);
    
#line 1974 
    if (rc == -95) {
      
#line 1975 
      __retres = rc;
      
#line 1975 
      goto return_label;
    }
    else 
      
#line 1976 
      if (rc != 0) 
#line 1977 
                   goto fail1; else ;
  }
  else 
#line 1979 
       new_rx_rss_context = nic_data->rx_rss_context;
  
#line 1982 
  rc = efx_ef10_populate_rss_table(efx,new_rx_rss_context,rx_indir_table);
  
#line 1984 
  if (rc != 0) 
#line 1985 
               goto fail2; else ;
  
#line 1987 
  if (nic_data->rx_rss_context != new_rx_rss_context) 
#line 1988 
                                                      efx_ef10_rx_free_indir_table(efx); else ;
  
#line 1989 
  nic_data->rx_rss_context = new_rx_rss_context;
  
#line 1990 
  nic_data->rx_rss_context_exclusive = (_Bool)1;
  
#line 1991 
  if ((unsigned int const *)(& efx->rx_indir_table) != rx_indir_table) 
    
#line 1992 
    memcpy((void *)(& efx->rx_indir_table),(void const *)rx_indir_table,512UL); else ;
  
#line 1994 
  __retres = 0;
  
#line 1994 
  goto return_label;
  fail2: 
#line 1996 
  ;
  
#line 1997 
  if (nic_data->rx_rss_context != new_rx_rss_context) 
#line 1998 
                                                      efx_ef10_free_rss_context(efx,new_rx_rss_context); else ;
  fail1: 
#line 1999 
  ;
  
#line 2000 
  if ((efx->msg_enable & 8192U) != 0U) 
#line 2000 
                                       netdev_err((struct net_device const *)efx->net_dev,"%s: failed rc=%d\n","efx_ef10_rx_push_exclusive_rss_config",rc); else ;
  
#line 2001 
  __retres = rc;
  return_label: 
#line 2001 
                return __retres;
}


#line 2004  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_pf_rx_push_rss_config(struct efx_nic *efx, bool user, u32 const *rx_indir_table)
{
  int __retres;
  int rc;
  
#line 2009 
  if (efx->rss_spread == 1U) {
    
#line 2010 
    __retres = 0;
    
#line 2010 
    goto return_label;
  }
  else ;
  
#line 2012 
  rc = efx_ef10_rx_push_exclusive_rss_config(efx,rx_indir_table);
  
#line 2014 
  if (rc == -105 && ! user) {
    unsigned int context_size;
    size_t i;
    u32 tmp;
    
#line 2016 
    bool mismatch = (_Bool)0;
    
#line 2019 
    i = 0UL;
    
#line 2019 
    goto ldv_56971;
    ldv_56970: 
#line 2020 
    ;
    
#line 2022 
    tmp = ethtool_rxfh_indir_default((unsigned int)i,efx->rss_spread);
    
#line 2021 
    mismatch = (_Bool)(*(rx_indir_table + i) != tmp);
    
#line 2020 
    i += 1UL;
    ldv_56971: 
#line 2021 
    ;
    
#line 2019 
    if (i <= 127UL && ! mismatch) 
#line 2021 
                                  goto ldv_56970; else 
#line 2024 
                                                       goto ldv_56972;
    ldv_56972: 
#line 2025 
    ;
    
#line 2024 
    rc = efx_ef10_rx_push_shared_rss_config(efx,& context_size);
    
#line 2025 
    if (rc == 0) {
      
#line 2026 
      if (efx->rss_spread != context_size) {
        
#line 2027 
        if ((efx->msg_enable & 2U) != 0U) 
#line 2027 
                                          netdev_warn((struct net_device const *)efx->net_dev,"Could not allocate an exclusive RSS",efx->rss_spread,context_size); else ;
      }
      else 
        
#line 2033 
        if ((int)mismatch != 0) {
          
#line 2034 
          if ((efx->msg_enable & 2U) != 0U) 
#line 2034 
                                            netdev_warn((struct net_device const *)efx->net_dev,"Could not allocate an exclusive RSS"); else ;
        }
        else 
          
#line 2040 
          if ((efx->msg_enable & 2U) != 0U) 
#line 2040 
                                            netdev_info((struct net_device const *)efx->net_dev,"Could not allocate an exclusive RSS"); else ;
    }
    else ;
  }
  else ;
  
#line 2045 
  __retres = rc;
  return_label: 
#line 2045 
                return __retres;
}


#line 2048  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_vf_rx_push_rss_config(struct efx_nic *efx, bool user, u32 const *rx_indir_table)
{
  int __retres;
  int tmp;
  
#line 2052 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 2054 
  if ((int)user != 0) {
    
#line 2055 
    __retres = -95;
    
#line 2055 
    goto return_label;
  }
  else ;
  
#line 2056 
  if (nic_data->rx_rss_context != 4294967295U) {
    
#line 2057 
    __retres = 0;
    
#line 2057 
    goto return_label;
  }
  else ;
  
#line 2058 
  tmp = efx_ef10_rx_push_shared_rss_config(efx,(unsigned int *)0U);
  
#line 2058 
  __retres = tmp;
  return_label: 
#line 2058 
                return __retres;
}


#line 2061  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_rx_probe(struct efx_rx_queue *rx_queue)
{
  int tmp;
  
#line 2063 
  tmp = efx_nic_alloc_buffer(rx_queue->efx,& rx_queue->rxd.buf,(rx_queue->ptr_mask + 1U) * 8U,208U);
  
#line 2063 
  return tmp;
}


#line 2082 
void __compiletime_assert_2082(void);


#line 2069  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_rx_init(struct efx_rx_queue *rx_queue)
{
  size_t inlen;
  dma_addr_t dma_addr;
  int rc;
  int i;
  
#line 2071 
  efx_dword_t inbuf[23U] = {{.u32 = {0U}}};
  
#line 2074 
  struct efx_channel *channel = efx_rx_queue_channel(rx_queue);
  
#line 2075 
  size_t entries = (unsigned long)(rx_queue->rxd.buf.len / 4096U);
  
#line 2076 
  struct efx_nic *efx = rx_queue->efx;
  
#line 2077 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  {
    
#line 2082 
    bool __cond = (_Bool)0;
    
#line 2082 
    if ((int)__cond != 0) 
#line 2082 
                          __compiletime_assert_2082(); else ;
  }
  
#line 2084 
  rx_queue->scatter_n = 0U;
  
#line 2085 
  rx_queue->scatter_len = 0U;
  
#line 2087 
  ((efx_dword_t *)(& inbuf))->u32[0] = rx_queue->ptr_mask + 1U;
  
#line 2088 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = (unsigned int)channel->channel;
  {
    int tmp_0;
    
#line 2089 
    tmp_0 = efx_rx_queue_index(rx_queue);
    
#line 2089 
    ((efx_dword_t *)(& inbuf) + 2U)->u32[0] = (unsigned int)tmp_0;
  }
  {
    int tmp_1;
    
#line 2090 
    tmp_1 = efx_rx_queue_index(rx_queue);
    
#line 2090 
    ((efx_dword_t *)(& inbuf) + 3U)->u32[0] = (unsigned int)tmp_1;
  }
  
#line 2092 
  ((efx_dword_t *)(& inbuf) + 4U)->u32[0] = 260U;
  
#line 2095 
  ((efx_dword_t *)(& inbuf) + 5U)->u32[0] = 0U;
  
#line 2096 
  ((efx_dword_t *)(& inbuf) + 6U)->u32[0] = nic_data->vport_id;
  
#line 2098 
  dma_addr = rx_queue->rxd.buf.dma_addr;
  
#line 2100 
  if ((efx->msg_enable & 8192U) != 0U) {
    
#line 2100 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_ef10_rx_init", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c", .format = "pushing RXQ %d. %zu entries (%llx)\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2101U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 2100 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      int tmp_2;
      
#line 2100 
      ;
      
#line 2100 
      ;
      
#line 2100 
      tmp_2 = efx_rx_queue_index(rx_queue);
      
#line 2100 
      ;
      
#line 2100 
      __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"pushing RXQ %d. %zu entries (%llx)\n",tmp_2,entries,dma_addr);
    }
    else ;
  }
  else ;
  
#line 2103 
  i = 0;
  
#line 2103 
  goto ldv_57058;
  ldv_57057: 
#line 2104 
  ;
  
#line 2104 
  ((efx_dword_t *)(& inbuf) + ((unsigned long)i * 8UL + (unsigned long)28U))->u32[0] = (unsigned int)dma_addr;
  
#line 2104 
  ((efx_dword_t *)(& inbuf) + ((unsigned long)i * 8UL + (unsigned long)29U))->u32[0] = (unsigned int)(dma_addr >> 32);
  
#line 2105 
  dma_addr += 4096ULL;
  
#line 2103 
  i += 1;
  ldv_57058: 
#line 2104 
  ;
  
#line 2103 
  if ((unsigned long)i < entries) 
#line 2105 
                                  goto ldv_57057; else 
#line 2108 
                                                       goto ldv_57059;
  ldv_57059: 
#line 2109 
  ;
  
#line 2108 
  inlen = entries * 8UL + 28UL;
  
#line 2110 
  rc = efx_mcdi_rpc(efx,129U,(efx_dword_t const *)(& inbuf),inlen,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 2112 
  if (rc != 0) {
    
#line 2113 
    int __ret_warn_on = 1;
    
#line 2113 
    if ((long)(__ret_warn_on != 0) != 0L) {
      int tmp_3;
      char const *tmp_4;
      char const *tmp_5;
      
#line 2113 
      tmp_3 = efx_rx_queue_index(rx_queue);
      
#line 2113 
      tmp_4 = netdev_reg_state((struct net_device const *)efx->net_dev);
      
#line 2113 
      tmp_5 = netdev_name((struct net_device const *)efx->net_dev);
      
#line 2113 
      warn_slowpath_fmt("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c",2114,"netdevice: %s%s\n",tmp_5,tmp_4,tmp_3);
    }
    else ;
    
#line 2113 
    long tmp_6 = (long)(__ret_warn_on != 0);
  }
  else ;
  
#line 2115 
  return;
}


#line 2117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_rx_fini(struct efx_rx_queue *rx_queue)
{
  size_t outlen;
  int rc;
  
#line 2119 
  efx_dword_t inbuf[1U] = {{.u32 = {0U}}};
  
#line 2120 
  efx_dword_t outbuf[2U] = {{.u32 = {0U}}};
  
#line 2121 
  struct efx_nic *efx = rx_queue->efx;
  {
    int tmp;
    
#line 2125 
    tmp = efx_rx_queue_index(rx_queue);
    
#line 2125 
    ((efx_dword_t *)(& inbuf))->u32[0] = (unsigned int)tmp;
  }
  
#line 2128 
  rc = efx_mcdi_rpc_quiet(efx,132U,(efx_dword_t const *)(& inbuf),4UL,(efx_dword_t *)(& outbuf),8UL,& outlen);
  
#line 2131 
  if (rc != 0 && rc != -114) 
#line 2132 
                             goto fail; else ;
  
#line 2134 
  goto return_label;
  fail: 
#line 2136 
  ;
  
#line 2137 
  efx_mcdi_display_error(efx,132U,4UL,(efx_dword_t *)(& outbuf),outlen,rc);
  return_label: 
#line 2139 
                return;
}


#line 2141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_rx_remove(struct efx_rx_queue *rx_queue)
{
  
#line 2143 
  efx_nic_free_buffer(rx_queue->efx,& rx_queue->rxd.buf);
  
#line 2144 
  return;
}


#line 2148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
__inline static void efx_ef10_build_rx_desc(struct efx_rx_queue *rx_queue, unsigned int index)
{
  struct efx_rx_buffer *rx_buf;
  efx_qword_t *rxd;
  
#line 2153 
  rxd = efx_rx_desc(rx_queue,index);
  
#line 2154 
  rx_buf = efx_rx_buffer(rx_queue,index);
  
#line 2155 
  rxd->u64[0] = ((unsigned long long)rx_buf->len << 48) | rx_buf->dma_addr;
  
#line 2156 
  return;
}


#line 2160  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_rx_write(struct efx_rx_queue *rx_queue)
{
  unsigned int write_count;
  efx_dword_t reg;
  int tmp;
  
#line 2162 
  struct efx_nic *efx = rx_queue->efx;
  
#line 2167 
  write_count = rx_queue->added_count & 4294967288U;
  
#line 2168 
  if (rx_queue->notified_count == write_count) 
#line 2169 
                                               goto return_label; else ;
  ldv_57089: 
#line 2170 
  ;
  
#line 2172 
  efx_ef10_build_rx_desc(rx_queue,rx_queue->notified_count & rx_queue->ptr_mask);
  
#line 2175 
  rx_queue->notified_count += 1U;
  
#line 2175 
  ;
  
#line 2175 
  if (rx_queue->notified_count != write_count) 
#line 2177 
                                               goto ldv_57089; else 
#line 2180 
                                                                    goto ldv_57090;
  ldv_57090: 
#line 2181 
  ;
  
#line 2182 
  ldv_inline_asm();
  
#line 2178 
  reg.u32[0] = rx_queue->ptr_mask & write_count;
  
#line 2180 
  tmp = efx_rx_queue_index(rx_queue);
  
#line 2180 
  ;
  
#line 2180 
  _efx_writed_page(efx,(efx_dword_t const *)(& reg),2096U,(unsigned int)tmp);
  return_label: 
#line 2181 
                return;
}


#line 2184 
static void efx_ef10_rx_defer_refill_complete(struct efx_nic *efx, unsigned long cookie, int rc, efx_dword_t *outbuf, size_t outlen_actual);


#line 2186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_rx_defer_refill(struct efx_rx_queue *rx_queue)
{
  efx_qword_t event;
  
#line 2188 
  struct efx_channel *channel = efx_rx_queue_channel(rx_queue);
  
#line 2189 
  efx_dword_t inbuf[3U] = {{.u32 = {0U}}};
  
#line 2192 
  event.u64[0] = 8070450532247928834ULL;
  
#line 2196 
  ((efx_dword_t *)(& inbuf))->u32[0] = (unsigned int)channel->channel;
  
#line 2201 
  memcpy((void *)(& inbuf) + 4U,(void const *)(& event.u64[0]),8UL);
  
#line 2204 
  efx_mcdi_rpc_async(channel->efx,134U,(efx_dword_t const *)(& inbuf),12UL,0UL,& efx_ef10_rx_defer_refill_complete,0UL);
  
#line 2207 
  return;
}


#line 2210  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_rx_defer_refill_complete(struct efx_nic *efx, unsigned long cookie, int rc, efx_dword_t *outbuf, size_t outlen_actual)
{
  
#line 2212 
  return;
}


#line 2217  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_ev_probe(struct efx_channel *channel)
{
  int tmp;
  
#line 2219 
  tmp = efx_nic_alloc_buffer(channel->efx,& channel->eventq.buf,(channel->eventq_mask + 1U) * 8U,208U);
  
#line 2219 
  return tmp;
}


#line 2225  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_ev_init(struct efx_channel *channel)
{
  struct efx_ef10_nic_data *nic_data;
  bool supports_rx_merge;
  size_t inlen;
  size_t outlen;
  dma_addr_t dma_addr;
  int rc;
  int i;
  
#line 2227 
  efx_dword_t inbuf[73U] = {{.u32 = {0U}}};
  
#line 2230 
  efx_dword_t outbuf[1U] = {{.u32 = {0U}}};
  
#line 2231 
  size_t entries = (unsigned long)(channel->eventq.buf.len / 4096U);
  
#line 2232 
  struct efx_nic *efx = channel->efx;
  
#line 2240 
  nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 2241 
  supports_rx_merge = (_Bool)((nic_data->datapath_caps & 33554432U) != 0U);
  
#line 2246 
  memset(channel->eventq.buf.addr,255,(unsigned long)channel->eventq.buf.len);
  
#line 2248 
  ((efx_dword_t *)(& inbuf))->u32[0] = channel->eventq_mask + 1U;
  
#line 2249 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = (unsigned int)channel->channel;
  
#line 2251 
  ((efx_dword_t *)(& inbuf) + 6U)->u32[0] = (unsigned int)channel->channel;
  
#line 2252 
  ((efx_dword_t *)(& inbuf) + 4U)->u32[0] = ((unsigned int)(! supports_rx_merge) << 3) | 49U;
  
#line 2257 
  ((efx_dword_t *)(& inbuf) + 5U)->u32[0] = 0U;
  
#line 2259 
  ((efx_dword_t *)(& inbuf) + 2U)->u32[0] = 0U;
  
#line 2260 
  ((efx_dword_t *)(& inbuf) + 3U)->u32[0] = 0U;
  
#line 2261 
  ((efx_dword_t *)(& inbuf) + 7U)->u32[0] = 0U;
  
#line 2263 
  ((efx_dword_t *)(& inbuf) + 8U)->u32[0] = 0U;
  
#line 2265 
  dma_addr = channel->eventq.buf.dma_addr;
  
#line 2266 
  i = 0;
  
#line 2266 
  goto ldv_57192;
  ldv_57191: 
#line 2267 
  ;
  
#line 2267 
  ((efx_dword_t *)(& inbuf) + ((unsigned long)i * 8UL + (unsigned long)36U))->u32[0] = (unsigned int)dma_addr;
  
#line 2267 
  ((efx_dword_t *)(& inbuf) + ((unsigned long)i * 8UL + (unsigned long)37U))->u32[0] = (unsigned int)(dma_addr >> 32);
  
#line 2268 
  dma_addr += 4096ULL;
  
#line 2266 
  i += 1;
  ldv_57192: 
#line 2267 
  ;
  
#line 2266 
  if ((unsigned long)i < entries) 
#line 2268 
                                  goto ldv_57191; else 
#line 2271 
                                                       goto ldv_57193;
  ldv_57193: 
#line 2272 
  ;
  
#line 2271 
  inlen = entries * 8UL + 36UL;
  
#line 2273 
  rc = efx_mcdi_rpc(efx,128U,(efx_dword_t const *)(& inbuf),inlen,(efx_dword_t *)(& outbuf),4UL,& outlen);
  
#line 2276 
  return rc;
}


#line 2279  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_ev_fini(struct efx_channel *channel)
{
  size_t outlen;
  int rc;
  
#line 2281 
  efx_dword_t inbuf[1U] = {{.u32 = {0U}}};
  
#line 2282 
  efx_dword_t outbuf[2U] = {{.u32 = {0U}}};
  
#line 2283 
  struct efx_nic *efx = channel->efx;
  
#line 2287 
  ((efx_dword_t *)(& inbuf))->u32[0] = (unsigned int)channel->channel;
  
#line 2289 
  rc = efx_mcdi_rpc_quiet(efx,131U,(efx_dword_t const *)(& inbuf),4UL,(efx_dword_t *)(& outbuf),8UL,& outlen);
  
#line 2292 
  if (rc != 0 && rc != -114) 
#line 2293 
                             goto fail; else ;
  
#line 2295 
  goto return_label;
  fail: 
#line 2297 
  ;
  
#line 2298 
  efx_mcdi_display_error(efx,131U,4UL,(efx_dword_t *)(& outbuf),outlen,rc);
  return_label: 
#line 2300 
                return;
}


#line 2302  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_ev_remove(struct efx_channel *channel)
{
  
#line 2304 
  efx_nic_free_buffer(channel->efx,& channel->eventq.buf);
  
#line 2305 
  return;
}


#line 2307  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_handle_rx_wrong_queue(struct efx_rx_queue *rx_queue, unsigned int rx_queue_label)
{
  
#line 2310 
  struct efx_nic *efx = rx_queue->efx;
  
#line 2312 
  if ((efx->msg_enable & 8192U) != 0U) {
    int tmp;
    
#line 2312 
    ;
    
#line 2312 
    tmp = efx_rx_queue_index(rx_queue);
    
#line 2312 
    ;
    
#line 2312 
    netdev_info((struct net_device const *)efx->net_dev,"rx event arrived on queue %d labeled as queue %u\n",tmp,rx_queue_label);
  }
  else ;
  
#line 2316 
  efx_schedule_reset(efx,(enum reset_type)RESET_TYPE_DISABLE);
  
#line 2317 
  return;
}


#line 2320  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_handle_rx_bad_lbits(struct efx_rx_queue *rx_queue, unsigned int actual, unsigned int expected)
{
  
#line 2323 
  unsigned int dropped = (actual - expected) & rx_queue->ptr_mask;
  
#line 2324 
  struct efx_nic *efx = rx_queue->efx;
  
#line 2326 
  if ((efx->msg_enable & 8192U) != 0U) 
#line 2326 
                                       netdev_info((struct net_device const *)efx->net_dev,"dropped %d events (index=%d expected=%d)\n",dropped,actual,expected); else ;
  
#line 2330 
  efx_schedule_reset(efx,(enum reset_type)RESET_TYPE_DISABLE);
  
#line 2331 
  return;
}


#line 2334  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_handle_rx_abort(struct efx_rx_queue *rx_queue)
{
  unsigned int rx_desc_ptr;
  struct efx_channel *tmp;
  
#line 2338 
  if (((rx_queue->efx)->msg_enable & 8192U) != 0U) {
    
#line 2338 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_ef10_handle_rx_abort", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c", .format = "scattered RX aborted (dropping %u buffers)\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2340U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 2338 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 2338 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)(rx_queue->efx)->net_dev,"scattered RX aborted (dropping %u buffers)\n",rx_queue->scatter_n); else ;
  }
  else ;
  
#line 2342 
  rx_desc_ptr = rx_queue->removed_count & rx_queue->ptr_mask;
  
#line 2344 
  efx_rx_packet(rx_queue,rx_desc_ptr,rx_queue->scatter_n,0U,(unsigned short)4);
  
#line 2347 
  rx_queue->removed_count += rx_queue->scatter_n;
  
#line 2348 
  rx_queue->scatter_n = 0U;
  
#line 2349 
  rx_queue->scatter_len = 0U;
  
#line 2350 
  tmp = efx_rx_queue_channel(rx_queue);
  
#line 2350 
  tmp->n_rx_nodesc_trunc += 1U;
  
#line 2351 
  return;
}


#line 2353  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_handle_rx_event(struct efx_channel *channel, efx_qword_t const *event)
{
  int __retres;
  unsigned int rx_bytes;
  unsigned int next_ptr_lbits;
  unsigned int rx_queue_label;
  unsigned int rx_l4_class;
  unsigned int n_descs;
  unsigned int n_packets;
  unsigned int i;
  struct efx_rx_queue *rx_queue;
  bool rx_cont;
  unsigned long volatile *tmp;
  int tmp_2_0;
  
#line 2358 
  struct efx_nic *efx = channel->efx;
  
#line 2361 
  u16 flags = (unsigned short)0U;
  {
    
#line 2363 
    unsigned long __var = 0UL;
    
#line 2363 
    tmp = (unsigned long volatile *)(& efx->reset_pending);
  }
  
#line 2363 
  ;
  
#line 2363 
  if ((long)(*tmp != 0UL) != 0L) {
    
#line 2364 
    __retres = 0;
    
#line 2364 
    goto return_label;
  }
  else ;
  
#line 2367 
  rx_bytes = (unsigned int)event->u64[0] & 16383U;
  
#line 2368 
  next_ptr_lbits = (unsigned int)(event->u64[0] >> 48) & 15U;
  
#line 2369 
  rx_queue_label = (unsigned int)(event->u64[0] >> 16) & 31U;
  
#line 2370 
  rx_l4_class = (unsigned int)(event->u64[0] >> 45) & 7U;
  
#line 2371 
  rx_cont = (_Bool)(((event->u64[0] >> 14) & 1ULL) != 0ULL);
  
#line 2373 
  if ((event->u64[0] & 288230376151711744ULL) != 0ULL) {
    
#line 2374 
    int __ret_warn_on = 1;
    
#line 2374 
    if ((long)(__ret_warn_on != 0) != 0L) {
      char const *tmp_0;
      char const *tmp_1;
      
#line 2374 
      ;
      
#line 2374 
      ;
      
#line 2374 
      tmp_0 = netdev_reg_state((struct net_device const *)efx->net_dev);
      
#line 2374 
      tmp_1 = netdev_name((struct net_device const *)efx->net_dev);
      
#line 2374 
      warn_slowpath_fmt("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c",2376,"netdevice: %s%s\n",tmp_1,tmp_0,event->u32[1],event->u32[0]);
    }
    else ;
    
#line 2374 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  else ;
  
#line 2378 
  rx_queue = efx_channel_get_rx_queue(channel);
  
#line 2380 
  tmp_2_0 = efx_rx_queue_index(rx_queue);
  
#line 2380 
  ;
  
#line 2380 
  if ((long)((unsigned int)tmp_2_0 != rx_queue_label) != 0L) 
#line 2381 
                                                             efx_ef10_handle_rx_wrong_queue(rx_queue,rx_queue_label); else ;
  
#line 2383 
  n_descs = (next_ptr_lbits - rx_queue->removed_count) & 15U;
  
#line 2386 
  if (rx_queue->scatter_n + 1U != n_descs) {
    
#line 2387 
    struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
    
#line 2390 
    if ((long)(rx_queue->scatter_n == n_descs) != 0L) {
      
#line 2391 
      if (rx_queue->scatter_n == 0U || rx_bytes != 0U) {
        
#line 2392 
        int __ret_warn_on_0 = 1;
        
#line 2392 
        if ((long)(__ret_warn_on_0 != 0) != 0L) {
          char const *tmp_3;
          char const *tmp_4;
          
#line 2392 
          ;
          
#line 2392 
          ;
          
#line 2392 
          ;
          
#line 2392 
          tmp_3 = netdev_reg_state((struct net_device const *)efx->net_dev);
          
#line 2392 
          tmp_4 = netdev_name((struct net_device const *)efx->net_dev);
          
#line 2392 
          warn_slowpath_fmt("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c",2396,"netdevice: %s%s\n",tmp_4,tmp_3,rx_queue->scatter_n,event->u32[1],event->u32[0]);
        }
        else ;
        
#line 2392 
        long tmp_5 = (long)(__ret_warn_on_0 != 0);
      }
      else ;
      
#line 2397 
      efx_ef10_handle_rx_abort(rx_queue);
      
#line 2398 
      __retres = 0;
      
#line 2398 
      goto return_label;
    }
    else ;
    
#line 2405 
    if (((nic_data->datapath_caps & 33554432U) == 0U || rx_queue->scatter_n != 0U) || (int)rx_cont != 0) {
      
#line 2408 
      efx_ef10_handle_rx_bad_lbits(rx_queue,next_ptr_lbits,((rx_queue->removed_count + rx_queue->scatter_n) + 1U) & 15U);
      
#line 2413 
      __retres = 0;
      
#line 2413 
      goto return_label;
    }
    else ;
    
#line 2417 
    rx_queue->scatter_n = 1U;
    
#line 2418 
    rx_queue->scatter_len = 0U;
    
#line 2419 
    n_packets = n_descs;
    
#line 2420 
    channel->n_rx_merge_events += 1U;
    
#line 2421 
    channel->n_rx_merge_packets += n_packets;
    
#line 2422 
    flags = (unsigned short)((unsigned int)flags | 128U);
  }
  else {
    
#line 2424 
    rx_queue->scatter_n += 1U;
    
#line 2425 
    rx_queue->scatter_len += rx_bytes;
    
#line 2426 
    if ((int)rx_cont != 0) {
      
#line 2427 
      __retres = 0;
      
#line 2427 
      goto return_label;
    }
    else ;
    
#line 2428 
    n_packets = 1U;
  }
  
#line 2431 
  if ((long)((event->u64[0] & 16777216ULL) != 0ULL) != 0L) 
#line 2432 
                                                           flags = (unsigned short)((unsigned int)flags | 4U); else ;
  
#line 2434 
  if ((long)((event->u64[0] & 33554432ULL) != 0ULL) != 0L) 
#line 2435 
                                                           channel->n_rx_ip_hdr_chksum_err += n_packets;
  else 
    
#line 2436 
    if ((long)((event->u64[0] & 67108864ULL) != 0ULL) != 0L) 
#line 2438 
                                                             channel->n_rx_tcp_udp_chksum_err += n_packets;
    else 
      
#line 2439 
      if (rx_l4_class + 4294967295U <= 1U) 
#line 2441 
                                           flags = (unsigned short)((unsigned int)flags | 2U); else ;
  
#line 2444 
  if (rx_l4_class == 1U) 
#line 2445 
                         flags = (unsigned short)((unsigned int)flags | 64U); else ;
  
#line 2447 
  channel->irq_mod_score += n_packets * 2U;
  
#line 2450 
  i = 0U;
  
#line 2450 
  goto ldv_57250;
  ldv_57249: 
#line 2451 
  ;
  
#line 2451 
  efx_rx_packet(rx_queue,rx_queue->removed_count & rx_queue->ptr_mask,rx_queue->scatter_n,rx_queue->scatter_len,(unsigned short)((int)flags));
  
#line 2455 
  rx_queue->removed_count += rx_queue->scatter_n;
  
#line 2450 
  i += 1U;
  ldv_57250: 
#line 2451 
  ;
  
#line 2450 
  if (i < n_packets) 
#line 2452 
                     goto ldv_57249; else 
#line 2455 
                                          goto ldv_57251;
  ldv_57251: 
#line 2456 
  ;
  
#line 2458 
  rx_queue->scatter_n = 0U;
  
#line 2459 
  rx_queue->scatter_len = 0U;
  
#line 2461 
  __retres = (int)n_packets;
  return_label: 
#line 2461 
                return __retres;
}


#line 2465  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_handle_tx_event(struct efx_channel *channel, efx_qword_t *event)
{
  int __retres;
  struct efx_tx_queue *tx_queue;
  unsigned int tx_ev_desc_ptr;
  unsigned int tx_ev_q_label;
  unsigned long volatile *tmp;
  
#line 2467 
  struct efx_nic *efx = channel->efx;
  
#line 2471 
  int tx_descs = 0;
  {
    
#line 2473 
    unsigned long __var = 0UL;
    
#line 2473 
    tmp = (unsigned long volatile *)(& efx->reset_pending);
  }
  
#line 2473 
  ;
  
#line 2473 
  if ((long)(*tmp != 0UL) != 0L) {
    
#line 2474 
    __retres = 0;
    
#line 2474 
    goto return_label;
  }
  else ;
  
#line 2476 
  if ((long)((event->u64[0] & 288230376151711744ULL) != 0ULL) != 0L) {
    
#line 2477 
    __retres = 0;
    
#line 2477 
    goto return_label;
  }
  else ;
  
#line 2480 
  tx_ev_desc_ptr = (unsigned int)event->u64[0] & 65535U;
  
#line 2481 
  tx_ev_q_label = (unsigned int)(event->u64[0] >> 16) & 31U;
  
#line 2482 
  tx_queue = efx_channel_get_tx_queue(channel,tx_ev_q_label & 3U);
  
#line 2484 
  tx_descs = (int)(((tx_ev_desc_ptr - tx_queue->read_count) + 1U) & tx_queue->ptr_mask);
  
#line 2486 
  efx_xmit_done(tx_queue,tx_queue->ptr_mask & tx_ev_desc_ptr);
  
#line 2488 
  __retres = tx_descs;
  return_label: 
#line 2488 
                return __retres;
}


#line 2492  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_handle_driver_event(struct efx_channel *channel, efx_qword_t *event)
{
  int subcode;
  
#line 2494 
  struct efx_nic *efx = channel->efx;
  
#line 2497 
  subcode = (int)(event->u64[0] >> 56) & 15;
  
#line 2499 
  switch (subcode) {
    case 3: 
#line 2500 
    ;
    case 1: 
#line 2501 
    ;
    
#line 2502 
    goto ldv_57271;
    case 2: 
#line 2503 
    ;
    
#line 2505 
    goto ldv_57271;
    default: 
#line 2506 
    ;
    
#line 2507 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 2507 
                                         netdev_err((struct net_device const *)efx->net_dev,"channel %d unknown driver event type %d",channel->channel,subcode,event->u32[1],event->u32[0]); else ;
  }
  ldv_57271: 
#line 2514 
  ;
  
#line 2515 
  return;
}


#line 2516  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_handle_driver_generated_event(struct efx_channel *channel, efx_qword_t *event)
{
  u32 subcode;
  
#line 2519 
  struct efx_nic *efx = channel->efx;
  
#line 2522 
  subcode = (unsigned int)event->u64[0];
  
#line 2524 
  switch (subcode) {
    int tmp_3;
    case (u32)1: 
#line 2525 
    ;
    {
      int pscr_ret__;
      {
        
#line 2526 
        void const *__vpp_verify = (void const *)0;
        
#line 2526 
        void const *tmp = __vpp_verify;
      }
      
#line 2526 
      switch (4UL) {
        int tmp_0;
        int tmp_0_0;
        int tmp_1;
        int tmp_2;
        case (unsigned long)1: 
#line 2526 
        ;
        {
          int pfo_ret__;
          
#line 2526 
          switch (4UL) {
            case (unsigned long)1: 
#line 2526 
            ;
            
#line 2527 
            ldv_inline_asm();
            
#line 2526 
            goto ldv_57286;
            case (unsigned long)2: 
#line 2526 
            ;
            
#line 2527 
            ldv_inline_asm();
            
#line 2526 
            goto ldv_57286;
            case (unsigned long)4: 
#line 2526 
            ;
            
#line 2527 
            ldv_inline_asm();
            
#line 2526 
            goto ldv_57286;
            case (unsigned long)8: 
#line 2526 
            ;
            
#line 2527 
            ldv_inline_asm();
            
#line 2526 
            goto ldv_57286;
            default: 
#line 2526 
            ;
            
#line 2526 
            __bad_percpu_size();
          }
          ldv_57286: 
#line 2526 
          ;
          
#line 2526 
          tmp_0 = pfo_ret__;
        }
        
#line 2526 
        pscr_ret__ = tmp_0;
        
#line 2526 
        goto ldv_57292;
        case (unsigned long)2: 
#line 2526 
        ;
        {
          int pfo_ret___0;
          
#line 2526 
          switch (4UL) {
            case (unsigned long)1: 
#line 2526 
            ;
            
#line 2527 
            ldv_inline_asm();
            
#line 2526 
            goto ldv_57296;
            case (unsigned long)2: 
#line 2526 
            ;
            
#line 2527 
            ldv_inline_asm();
            
#line 2526 
            goto ldv_57296;
            case (unsigned long)4: 
#line 2526 
            ;
            
#line 2527 
            ldv_inline_asm();
            
#line 2526 
            goto ldv_57296;
            case (unsigned long)8: 
#line 2526 
            ;
            
#line 2527 
            ldv_inline_asm();
            
#line 2526 
            goto ldv_57296;
            default: 
#line 2526 
            ;
            
#line 2526 
            __bad_percpu_size();
          }
          ldv_57296: 
#line 2526 
          ;
          
#line 2526 
          tmp_0_0 = pfo_ret___0;
        }
        
#line 2526 
        pscr_ret__ = tmp_0_0;
        
#line 2526 
        goto ldv_57292;
        case (unsigned long)4: 
#line 2526 
        ;
        {
          int pfo_ret___1;
          
#line 2526 
          switch (4UL) {
            case (unsigned long)1: 
#line 2526 
            ;
            
#line 2527 
            ldv_inline_asm();
            
#line 2526 
            goto ldv_57305;
            case (unsigned long)2: 
#line 2526 
            ;
            
#line 2527 
            ldv_inline_asm();
            
#line 2526 
            goto ldv_57305;
            case (unsigned long)4: 
#line 2526 
            ;
            
#line 2527 
            ldv_inline_asm();
            
#line 2526 
            goto ldv_57305;
            case (unsigned long)8: 
#line 2526 
            ;
            
#line 2527 
            ldv_inline_asm();
            
#line 2526 
            goto ldv_57305;
            default: 
#line 2526 
            ;
            
#line 2526 
            __bad_percpu_size();
          }
          ldv_57305: 
#line 2526 
          ;
          
#line 2526 
          tmp_1 = pfo_ret___1;
        }
        
#line 2526 
        pscr_ret__ = tmp_1;
        
#line 2526 
        goto ldv_57292;
        case (unsigned long)8: 
#line 2526 
        ;
        {
          int pfo_ret___2;
          
#line 2526 
          switch (4UL) {
            case (unsigned long)1: 
#line 2526 
            ;
            
#line 2527 
            ldv_inline_asm();
            
#line 2526 
            goto ldv_57314;
            case (unsigned long)2: 
#line 2526 
            ;
            
#line 2527 
            ldv_inline_asm();
            
#line 2526 
            goto ldv_57314;
            case (unsigned long)4: 
#line 2526 
            ;
            
#line 2527 
            ldv_inline_asm();
            
#line 2526 
            goto ldv_57314;
            case (unsigned long)8: 
#line 2526 
            ;
            
#line 2527 
            ldv_inline_asm();
            
#line 2526 
            goto ldv_57314;
            default: 
#line 2526 
            ;
            
#line 2526 
            __bad_percpu_size();
          }
          ldv_57314: 
#line 2526 
          ;
          
#line 2526 
          tmp_2 = pfo_ret___2;
        }
        
#line 2526 
        pscr_ret__ = tmp_2;
        
#line 2526 
        goto ldv_57292;
        default: 
#line 2526 
        ;
        
#line 2526 
        __bad_size_call_parameter();
        
#line 2526 
        goto ldv_57292;
      }
      ldv_57292: 
#line 2526 
      ;
      
#line 2526 
      tmp_3 = pscr_ret__;
    }
    
#line 2526 
    channel->event_test_cpu = tmp_3;
    
#line 2527 
    goto ldv_57322;
    case (u32)2: 
#line 2528 
    ;
    
#line 2533 
    efx_fast_push_rx_descriptors(& channel->rx_queue,(_Bool)1);
    
#line 2534 
    goto ldv_57322;
    default: 
#line 2535 
    ;
    
#line 2536 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 2536 
                                         netdev_err((struct net_device const *)efx->net_dev,"channel %d unknown driver event type %u",channel->channel,subcode,event->u32[1],event->u32[0]); else ;
  }
  ldv_57322: 
#line 2542 
  ;
  
#line 2543 
  return;
}


#line 2544  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_ev_process(struct efx_channel *channel, int quota)
{
  int __retres;
  efx_qword_t event;
  efx_qword_t *p_event;
  unsigned int read_ptr;
  int ev_code;
  int tmp;
  
#line 2546 
  struct efx_nic *efx = channel->efx;
  
#line 2550 
  int tx_descs = 0;
  
#line 2551 
  int spent = 0;
  
#line 2553 
  if (quota <= 0) {
    
#line 2554 
    __retres = spent;
    
#line 2554 
    goto return_label;
  }
  else ;
  
#line 2556 
  read_ptr = channel->eventq_read_ptr;
  ldv_57346: 
#line 2557 
  ;
  
#line 2559 
  p_event = efx_event(channel,read_ptr);
  
#line 2560 
  event = *p_event;
  
#line 2562 
  tmp = efx_event_present(& event);
  
#line 2562 
  if (tmp == 0) 
#line 2563 
                goto ldv_57336; else ;
  
#line 2565 
  p_event->u64[0] = 18446744073709551615ULL;
  
#line 2567 
  read_ptr += 1U;
  
#line 2569 
  ev_code = (int)(event.u64[0] >> 60);
  
#line 2575 
  switch (ev_code) {
    int tmp_0;
    int tmp_1;
    case 12: 
#line 2576 
    ;
    
#line 2577 
    efx_mcdi_process_event(channel,& event);
    
#line 2578 
    goto ldv_57339;
    case 0: 
#line 2579 
    ;
    
#line 2580 
    tmp_0 = efx_ef10_handle_rx_event(channel,(efx_qword_t const *)(& event));
    
#line 2580 
    spent = tmp_0 + spent;
    
#line 2581 
    if (spent >= quota) {
      
#line 2585 
      spent = quota;
      
#line 2586 
      goto out;
    }
    else ;
    
#line 2588 
    goto ldv_57339;
    case 2: 
#line 2589 
    ;
    
#line 2590 
    tmp_1 = efx_ef10_handle_tx_event(channel,& event);
    
#line 2590 
    tx_descs = tmp_1 + tx_descs;
    
#line 2591 
    if (efx->txq_entries < (unsigned int)tx_descs) {
      
#line 2592 
      spent = quota;
      
#line 2593 
      goto out;
    }
    else {
      
#line 2594 
      spent += 1;
      
#line 2594 
      ;
      
#line 2594 
      if (spent == quota) 
#line 2595 
                          goto out; else ;
    }
    
#line 2597 
    goto ldv_57339;
    case 5: 
#line 2598 
    ;
    
#line 2599 
    efx_ef10_handle_driver_event(channel,& event);
    
#line 2600 
    spent += 1;
    
#line 2600 
    ;
    
#line 2600 
    if (spent == quota) 
#line 2601 
                        goto out; else ;
    
#line 2602 
    goto ldv_57339;
    case 7: 
#line 2603 
    ;
    
#line 2604 
    efx_ef10_handle_driver_generated_event(channel,& event);
    
#line 2605 
    goto ldv_57339;
    default: 
#line 2606 
    ;
    
#line 2607 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 2607 
                                         netdev_err((struct net_device const *)efx->net_dev,"channel %d unknown event type %d",channel->channel,ev_code,event.u32[1],event.u32[0]); else ;
  }
  ldv_57339: 
#line 2613 
  ;
  
#line 2559 
  goto ldv_57346;
  ldv_57336: 
#line 2560 
  ;
  out: 
#line 2615 
  ;
  
#line 2616 
  channel->eventq_read_ptr = read_ptr;
  
#line 2617 
  __retres = spent;
  return_label: 
#line 2617 
                return __retres;
}


#line 2626 
void __compiletime_assert_2627(void);


#line 2628 
void __compiletime_assert_2629(void);


#line 2620  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_ev_read_ack(struct efx_channel *channel)
{
  efx_dword_t rptr;
  
#line 2622 
  struct efx_nic *efx = channel->efx;
  
#line 2625 
  if ((int)((struct efx_ef10_nic_data *)efx->nic_data)->workaround_35388 != 0) {
    {
      
#line 2626 
      bool __cond = (_Bool)0;
      
#line 2626 
      if ((int)__cond != 0) 
#line 2626 
                            __compiletime_assert_2627(); else ;
    }
    {
      
#line 2628 
      bool __cond_0 = (_Bool)0;
      
#line 2628 
      if ((int)__cond_0 != 0) 
#line 2628 
                              __compiletime_assert_2629(); else ;
    }
    
#line 2631 
    rptr.u32[0] = ((channel->eventq_read_ptr & channel->eventq_mask) >> 8) | 2048U;
    
#line 2637 
    _efx_writed_page(efx,(efx_dword_t const *)(& rptr),2584U,(unsigned int)channel->channel);
    
#line 2639 
    rptr.u32[0] = (channel->eventq_read_ptr & 255U) | 2304U;
    
#line 2644 
    _efx_writed_page(efx,(efx_dword_t const *)(& rptr),2584U,(unsigned int)channel->channel);
  }
  else {
    
#line 2647 
    rptr.u32[0] = channel->eventq_read_ptr & channel->eventq_mask;
    
#line 2650 
    _efx_writed_page(efx,(efx_dword_t const *)(& rptr),1024U,(unsigned int)channel->channel);
  }
  
#line 2652 
  return;
}


#line 2654  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_ev_test_generate(struct efx_channel *channel)
{
  efx_qword_t event;
  int rc;
  
#line 2656 
  efx_dword_t inbuf[3U] = {{.u32 = {0U}}};
  
#line 2657 
  struct efx_nic *efx = channel->efx;
  
#line 2661 
  event.u64[0] = 8070450532247928833ULL;
  
#line 2665 
  ((efx_dword_t *)(& inbuf))->u32[0] = (unsigned int)channel->channel;
  
#line 2670 
  memcpy((void *)(& inbuf) + 4U,(void const *)(& event.u64[0]),8UL);
  
#line 2673 
  rc = efx_mcdi_rpc(efx,134U,(efx_dword_t const *)(& inbuf),12UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 2675 
  if (rc != 0) 
#line 2676 
               goto fail; else ;
  
#line 2678 
  goto return_label;
  fail: 
#line 2680 
  ;
  {
    
#line 2681 
    int __ret_warn_on = 1;
    
#line 2681 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 2681 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c",2681); else ;
    
#line 2681 
    long tmp = (long)(__ret_warn_on != 0);
  }
  
#line 2682 
  if ((efx->msg_enable & 8192U) != 0U) 
#line 2682 
                                       netdev_err((struct net_device const *)efx->net_dev,"%s: failed rc=%d\n","efx_ef10_ev_test_generate",rc); else ;
  return_label: 
#line 2683 
                return;
}


#line 2685  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
void efx_ef10_handle_drain_event(struct efx_nic *efx)
{
  int tmp;
  
#line 2687 
  tmp = atomic_dec_and_test(& efx->active_queues);
  
#line 2687 
  if (tmp != 0) 
#line 2688 
                __wake_up(& efx->flush_wq,3U,1,(void *)0); else ;
  {
    int tmp_0;
    
#line 2690 
    tmp_0 = atomic_read((atomic_t const *)(& efx->active_queues));
    
#line 2690 
    int __ret_warn_on = tmp_0 < 0;
    
#line 2690 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 2690 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c",2690); else ;
    
#line 2690 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 2692 
  return;
}


#line 2693  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_fini_dmaq(struct efx_nic *efx)
{
  int __retres;
  struct efx_channel *channel;
  struct efx_tx_queue *tx_queue;
  struct efx_rx_queue *rx_queue;
  int pending;
  
#line 2695 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 2704 
  if ((int)nic_data->must_realloc_vis != 0) {
    
#line 2705 
    atomic_set(& efx->active_queues,0);
    
#line 2706 
    __retres = 0;
    
#line 2706 
    goto return_label;
  }
  else ;
  
#line 2710 
  if (efx->state != (unsigned int)STATE_RECOVERY) {
    int tmp_0;
    bool tmp;
    int tmp_3;
    bool tmp_2;
    
#line 2711 
    channel = efx->channel[0];
    
#line 2711 
    goto ldv_57403;
    ldv_57402: 
#line 2712 
    ;
    
#line 2712 
    tmp = efx_channel_has_rx_queue(channel);
    
#line 2712 
    if (tmp) 
#line 2712 
             tmp_0 = 0; else 
#line 2712 
                             tmp_0 = 1;
    
#line 2712 
    if (tmp_0) ;
    else {
      
#line 2712 
      rx_queue = & channel->rx_queue;
      
#line 2712 
      goto ldv_57397;
      ldv_57396: 
#line 2713 
      ;
      
#line 2713 
      efx_ef10_rx_fini(rx_queue);
      
#line 2712 
      rx_queue = (struct efx_rx_queue *)0;
      ldv_57397: 
#line 2713 
      ;
      
#line 2712 
      if (rx_queue != (struct efx_rx_queue *)0) 
#line 2714 
                                                goto ldv_57396; else 
                                                                  
#line 2717 
                                                                  goto ldv_57398;
      ldv_57398: 
#line 2718 
      ;
    }
    
#line 2714 
    tmp_2 = efx_channel_has_tx_queues(channel);
    
#line 2714 
    if (tmp_2) 
#line 2714 
               tmp_3 = 0; else 
#line 2714 
                               tmp_3 = 1;
    
#line 2714 
    if (tmp_3) ;
    else {
      
#line 2714 
      tx_queue = (struct efx_tx_queue *)(& channel->tx_queue);
      
#line 2714 
      goto ldv_57400;
      ldv_57399: 
#line 2715 
      ;
      
#line 2715 
      efx_ef10_tx_fini(tx_queue);
      
#line 2714 
      tx_queue += 1;
      ldv_57400: 
#line 2715 
      ;
      
#line 2714 
      if ((struct efx_tx_queue *)(& channel->tx_queue) + 4U > tx_queue) {
        bool tmp_1;
        
#line 2714 
        tmp_1 = efx_tx_queue_used(tx_queue);
        
#line 2714 
        if ((int)tmp_1 != 0) 
#line 2716 
                             goto ldv_57399; else 
#line 2719 
                                                  goto ldv_57401;
      }
      else 
#line 2719 
           goto ldv_57401;
      ldv_57401: 
#line 2720 
      ;
    }
    
#line 2711 
    if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 2711 
                                                                channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 2711 
                                                                    channel = (struct efx_channel *)0;
    ldv_57403: 
#line 2712 
    ;
    
#line 2711 
    if (channel != (struct efx_channel *)0) 
#line 2713 
                                            goto ldv_57402; else 
#line 2716 
                                                                 goto ldv_57404;
    ldv_57404: 
#line 2717 
    ;
    {
      unsigned long tmp_4;
      
#line 2718 
      tmp_4 = msecs_to_jiffies(5000U);
      
#line 2718 
      long __ret = (long)tmp_4;
      
#line 2718 
      __might_sleep("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c",2720,0);
      {
        int tmp_11;
        {
          int tmp_10;
          
#line 2718 
          tmp_10 = atomic_read((atomic_t const *)(& efx->active_queues));
          
#line 2718 
          bool __cond_0 = (_Bool)(tmp_10 == 0);
          
#line 2718 
          if ((int)__cond_0 != 0 && __ret == 0L) 
#line 2718 
                                                 __ret = 1L; else ;
          
#line 2718 
          tmp_11 = ((int)__cond_0 != 0 || __ret == 0L) != 0;
        }
        
#line 2718 
        if (tmp_11 == 0) {
          long tmp_9;
          {
            wait_queue_t __wait;
            unsigned long tmp_5;
            
#line 2718 
            tmp_5 = msecs_to_jiffies(5000U);
            
#line 2718 
            long __ret_0 = (long)tmp_5;
            
#line 2718 
            INIT_LIST_HEAD(& __wait.task_list);
            
#line 2718 
            __wait.flags = 0U;
            ldv_57415: 
#line 2721 
            ;
            {
              int tmp_8;
              
#line 2718 
              long __int = prepare_to_wait_event(& efx->flush_wq,& __wait,2);
              {
                int tmp_7;
                
#line 2718 
                tmp_7 = atomic_read((atomic_t const *)(& efx->active_queues));
                
#line 2718 
                bool __cond = (_Bool)(tmp_7 == 0);
                
#line 2718 
                if ((int)__cond != 0 && __ret_0 == 0L) 
#line 2718 
                                                       __ret_0 = 1L; else ;
                
#line 2718 
                tmp_8 = ((int)__cond != 0 || __ret_0 == 0L) != 0;
              }
              
#line 2718 
              if (tmp_8 != 0) 
#line 2718 
                              goto ldv_57414; else ;
              
#line 2718 
              __ret_0 = schedule_timeout(__ret_0);
            }
            
#line 2718 
            goto ldv_57415;
            ldv_57414: 
#line 2719 
            ;
            
#line 2718 
            finish_wait(& efx->flush_wq,& __wait);
            __out_0: 
#line 2718 
            ;
            
#line 2718 
            tmp_9 = __ret_0;
          }
          
#line 2718 
          __ret = tmp_9;
        }
        else ;
      }
      
#line 2718 
      long tmp_12 = __ret;
    }
    
#line 2721 
    pending = atomic_read((atomic_t const *)(& efx->active_queues));
    
#line 2722 
    if (pending != 0) {
      
#line 2723 
      if ((efx->msg_enable & 8192U) != 0U) 
#line 2723 
                                           netdev_err((struct net_device const *)efx->net_dev,"failed to flush %d queues\n",pending); else ;
      
#line 2725 
      __retres = -110;
      
#line 2725 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 2729 
  __retres = 0;
  return_label: 
#line 2729 
                return __retres;
}


#line 2732  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_prepare_flr(struct efx_nic *efx)
{
  
#line 2734 
  atomic_set(& efx->active_queues,0);
  
#line 2735 
  return;
}


#line 2737  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static bool efx_ef10_filter_equal(struct efx_filter_spec const *left, struct efx_filter_spec const *right)
{
  bool __retres;
  int tmp;
  
#line 2740 
  if ((((int)left->match_flags ^ (int)right->match_flags) | (((int)left->flags ^ (int)right->flags) & 24)) != 0) {
    
#line 2743 
    __retres = (_Bool)0;
    
#line 2743 
    goto return_label;
  }
  else ;
  
#line 2747 
  tmp = memcmp((void const *)(& left->outer_vid),(void const *)(& right->outer_vid),56UL);
  
#line 2747 
  __retres = (_Bool)(tmp == 0);
  return_label: 
#line 2747 
                return __retres;
}


#line 2752 
void __compiletime_assert_2752(void);


#line 2750  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static unsigned int efx_ef10_filter_hash(struct efx_filter_spec const *spec)
{
  unsigned int tmp;
  {
    
#line 2752 
    bool __cond = (_Bool)0;
    
#line 2752 
    if ((int)__cond != 0) 
#line 2752 
                          __compiletime_assert_2752(); else ;
  }
  
#line 2753 
  tmp = jhash2((u32 const *)(& spec->outer_vid),14U,0U);
  
#line 2753 
  return tmp;
}


#line 2765  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static bool efx_ef10_filter_is_exclusive(struct efx_filter_spec const *spec)
{
  bool __retres;
  
#line 2767 
  if (((int)spec->match_flags & 16) != 0) {
    int tmp_0;
    bool tmp;
    
#line 2768 
    tmp = is_multicast_ether_addr((u8 const *)(& spec->loc_mac));
    
#line 2768 
    if (tmp) 
#line 2768 
             tmp_0 = 0; else 
#line 2768 
                             tmp_0 = 1;
    
#line 2768 
    if (tmp_0) {
      
#line 2769 
      __retres = (_Bool)1;
      
#line 2769 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 2771 
  if (((int)spec->match_flags & 66) == 66) {
    
#line 2774 
    if ((unsigned int)spec->ether_type == 8U) {
      int tmp_2;
      bool tmp_1;
      
#line 2775 
      tmp_1 = ipv4_is_multicast(spec->loc_host[0]);
      
#line 2775 
      if (tmp_1) 
#line 2775 
                 tmp_2 = 0; else 
#line 2775 
                                 tmp_2 = 1;
      
#line 2775 
      if (tmp_2) {
        
#line 2776 
        __retres = (_Bool)1;
        
#line 2776 
        goto return_label;
      }
      else ;
    }
    else ;
    
#line 2777 
    if ((unsigned int)spec->ether_type == 56710U && (unsigned int)*((u8 const *)(& spec->loc_host)) != 255U) {
      
#line 2779 
      __retres = (_Bool)1;
      
#line 2779 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 2782 
  __retres = (_Bool)0;
  return_label: 
#line 2782 
                return __retres;
}


#line 2786  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static struct efx_filter_spec *efx_ef10_filter_entry_spec(struct efx_ef10_filter_table const *table, unsigned int filter_idx)
{
  struct efx_filter_spec *__retres;
  
#line 2789 
  __retres = (struct efx_filter_spec *)((table->entry + filter_idx)->spec & 18446744073709551612UL);
  
#line 2789 
  return __retres;
}


#line 2794  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static unsigned int efx_ef10_filter_entry_flags(struct efx_ef10_filter_table const *table, unsigned int filter_idx)
{
  unsigned int __retres;
  
#line 2797 
  __retres = (unsigned int)(table->entry + filter_idx)->spec & 3U;
  
#line 2797 
  return __retres;
}


#line 2801  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_filter_set_entry(struct efx_ef10_filter_table *table, unsigned int filter_idx, struct efx_filter_spec const *spec, unsigned int flags)
{
  
#line 2806 
  (table->entry + filter_idx)->spec = (unsigned long)flags | (unsigned long)spec;
  
#line 2807 
  return;
}


#line 2850 
void __compiletime_assert_2850(void);


#line 2851 
void __compiletime_assert_2851(void);


#line 2852 
void __compiletime_assert_2852(void);


#line 2853 
void __compiletime_assert_2853(void);


#line 2854 
void __compiletime_assert_2854(void);


#line 2855 
void __compiletime_assert_2855(void);


#line 2856 
void __compiletime_assert_2856(void);


#line 2857 
void __compiletime_assert_2857(void);


#line 2858 
void __compiletime_assert_2858(void);


#line 2859 
void __compiletime_assert_2859(void);


#line 2809  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_filter_push_prep(struct efx_nic *efx, struct efx_filter_spec const *spec, efx_dword_t *inbuf, u64 handle, bool replacing)
{
  
#line 2814 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 2816 
  memset((void *)inbuf,0,108UL);
  
#line 2818 
  if ((int)replacing != 0) {
    
#line 2819 
    inbuf->u32[0] = 4U;
    
#line 2821 
    (inbuf + 1U)->u32[0] = (unsigned int)handle;
    
#line 2821 
    (inbuf + 2U)->u32[0] = (unsigned int)(handle >> 32);
  }
  else {
    
#line 2823 
    u32 match_fields = 0U;
    {
      int tmp_0;
      bool tmp;
      
#line 2825 
      tmp = efx_ef10_filter_is_exclusive(spec);
      
#line 2825 
      if ((int)tmp != 0) 
#line 2825 
                         tmp_0 = 0; else 
#line 2825 
                                         tmp_0 = 2;
      
#line 2825 
      inbuf->u32[0] = (unsigned int)tmp_0;
    }
    
#line 2834 
    if (((int)spec->match_flags & 1024) != 0) {
      unsigned int tmp_2;
      bool tmp_1;
      
#line 2837 
      tmp_1 = is_multicast_ether_addr((u8 const *)(& spec->loc_mac));
      
#line 2837 
      if ((int)tmp_1 != 0) 
#line 2837 
                           tmp_2 = (unsigned int)1073741824; else 
#line 2837 
                                                                  tmp_2 = -2147483648;
      
#line 2838 
      match_fields = tmp_2 | match_fields;
    }
    else ;
    
#line 2850 
    if (((int)spec->match_flags & 1) != 0) {
      
#line 2850 
      match_fields |= 1U;
      {
        
#line 2850 
        bool __cond = (_Bool)0;
        
#line 2850 
        if ((int)__cond != 0) 
#line 2850 
                              __compiletime_assert_2850(); else ;
      }
      
#line 2850 
      memcpy((void *)inbuf + 76U,(void const *)(& spec->rem_host),16UL);
    }
    else ;
    
#line 2851 
    if (((int)spec->match_flags & 2) != 0) {
      
#line 2851 
      match_fields |= 2U;
      {
        
#line 2851 
        bool __cond_0 = (_Bool)0;
        
#line 2851 
        if ((int)__cond_0 != 0) 
#line 2851 
                                __compiletime_assert_2851(); else ;
      }
      
#line 2851 
      memcpy((void *)inbuf + 92U,(void const *)(& spec->loc_host),16UL);
    }
    else ;
    
#line 2852 
    if (((int)spec->match_flags & 4) != 0) {
      
#line 2852 
      match_fields |= 4U;
      {
        
#line 2852 
        bool __cond_1 = (_Bool)0;
        
#line 2852 
        if ((int)__cond_1 != 0) 
#line 2852 
                                __compiletime_assert_2852(); else ;
      }
      
#line 2852 
      memcpy((void *)inbuf + 44U,(void const *)(& spec->rem_mac),6UL);
    }
    else ;
    
#line 2853 
    if (((int)spec->match_flags & 8) != 0) {
      
#line 2853 
      match_fields |= 8U;
      {
        
#line 2853 
        bool __cond_2 = (_Bool)0;
        
#line 2853 
        if ((int)__cond_2 != 0) 
#line 2853 
                                __compiletime_assert_2853(); else ;
      }
      
#line 2853 
      memcpy((void *)inbuf + 50U,(void const *)(& spec->rem_port),2UL);
    }
    else ;
    
#line 2854 
    if (((int)spec->match_flags & 16) != 0) {
      
#line 2854 
      match_fields |= 16U;
      {
        
#line 2854 
        bool __cond_3 = (_Bool)0;
        
#line 2854 
        if ((int)__cond_3 != 0) 
#line 2854 
                                __compiletime_assert_2854(); else ;
      }
      
#line 2854 
      memcpy((void *)inbuf + 52U,(void const *)(& spec->loc_mac),6UL);
    }
    else ;
    
#line 2855 
    if (((int)spec->match_flags & 32) != 0) {
      
#line 2855 
      match_fields |= 32U;
      {
        
#line 2855 
        bool __cond_4 = (_Bool)0;
        
#line 2855 
        if ((int)__cond_4 != 0) 
#line 2855 
                                __compiletime_assert_2855(); else ;
      }
      
#line 2855 
      memcpy((void *)inbuf + 58U,(void const *)(& spec->loc_port),2UL);
    }
    else ;
    
#line 2856 
    if (((int)spec->match_flags & 64) != 0) {
      
#line 2856 
      match_fields |= 64U;
      {
        
#line 2856 
        bool __cond_5 = (_Bool)0;
        
#line 2856 
        if ((int)__cond_5 != 0) 
#line 2856 
                                __compiletime_assert_2856(); else ;
      }
      
#line 2856 
      memcpy((void *)inbuf + 60U,(void const *)(& spec->ether_type),2UL);
    }
    else ;
    
#line 2857 
    if (((int)spec->match_flags & 128) != 0) {
      
#line 2857 
      match_fields |= 128U;
      {
        
#line 2857 
        bool __cond_6 = (_Bool)0;
        
#line 2857 
        if ((int)__cond_6 != 0) 
#line 2857 
                                __compiletime_assert_2857(); else ;
      }
      
#line 2857 
      memcpy((void *)inbuf + 62U,(void const *)(& spec->inner_vid),2UL);
    }
    else ;
    
#line 2858 
    if (((int)spec->match_flags & 256) != 0) {
      
#line 2858 
      match_fields |= 256U;
      {
        
#line 2858 
        bool __cond_7 = (_Bool)0;
        
#line 2858 
        if ((int)__cond_7 != 0) 
#line 2858 
                                __compiletime_assert_2858(); else ;
      }
      
#line 2858 
      memcpy((void *)inbuf + 64U,(void const *)(& spec->outer_vid),2UL);
    }
    else ;
    
#line 2859 
    if (((int)spec->match_flags & 512) != 0) {
      
#line 2859 
      match_fields |= 512U;
      {
        
#line 2859 
        bool __cond_8 = (_Bool)0;
        
#line 2859 
        if ((int)__cond_8 != 0) 
#line 2859 
                                __compiletime_assert_2859(); else ;
      }
      
#line 2859 
      memcpy((void *)inbuf + 66U,(void const *)(& spec->ip_proto),1UL);
    }
    else ;
    
#line 2861 
    (inbuf + 4U)->u32[0] = match_fields;
  }
  
#line 2865 
  (inbuf + 3U)->u32[0] = nic_data->vport_id;
  
#line 2866 
  (inbuf + 5U)->u32[0] = (unsigned int)((unsigned int)*((unsigned short *)spec + 1UL) != 65520U);
  
#line 2870 
  (inbuf + 9U)->u32[0] = 0U;
  
#line 2871 
  (inbuf + 10U)->u32[0] = 4294967295U;
  {
    int tmp_3;
    
#line 2873 
    if ((unsigned int)*((unsigned short *)spec + 1UL) != 65520U) 
#line 2873 
                                                                 tmp_3 = (int)spec->dmaq_id; else 
                                                                    
#line 2873 
                                                                    tmp_3 = 0;
    
#line 2873 
    (inbuf + 6U)->u32[0] = (unsigned int)tmp_3;
  }
  
#line 2876 
  (inbuf + 7U)->u32[0] = (unsigned int)spec->flags & 1U;
  
#line 2880 
  if (((int)spec->flags & 1) != 0) {
    unsigned int tmp_4;
    
#line 2881 
    if (spec->rss_context != 4294967295U) 
#line 2881 
                                          tmp_4 = spec->rss_context; else 
                                                                    
#line 2881 
                                                                    tmp_4 = nic_data->rx_rss_context;
    
#line 2881 
    (inbuf + 8U)->u32[0] = tmp_4;
  }
  else ;
  
#line 2883 
  return;
}


#line 2887  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_filter_push(struct efx_nic *efx, struct efx_filter_spec const *spec, u64 *handle, bool replacing)
{
  int rc;
  
#line 2891 
  efx_dword_t inbuf[27U] = {{.u32 = {0U}}};
  
#line 2892 
  efx_dword_t outbuf[3U] = {{.u32 = {0U}}};
  
#line 2895 
  efx_ef10_filter_push_prep(efx,spec,(efx_dword_t *)(& inbuf),*handle,(_Bool)((bool)((int)replacing) != 0));
  
#line 2896 
  rc = efx_mcdi_rpc(efx,138U,(efx_dword_t const *)(& inbuf),108UL,(efx_dword_t *)(& outbuf),12UL,(size_t *)0UL);
  
#line 2898 
  if (rc == 0) 
#line 2899 
               *handle = (unsigned long long)((efx_dword_t *)(& outbuf) + 1U)->u32[0] | ((unsigned long long)((efx_dword_t *)(& outbuf) + 2U)->u32[0] << 32); else ;
  
#line 2900 
  if (rc == -28) 
#line 2901 
                 rc = -16; else ;
  
#line 2902 
  return rc;
}


#line 2905  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_filter_rx_match_pri(struct efx_ef10_filter_table *table, enum efx_filter_match_flags match_flags)
{
  int __retres;
  unsigned int match_pri;
  
#line 2910 
  match_pri = 0U;
  
#line 2910 
  goto ldv_57561;
  ldv_57560: 
#line 2911 
  ;
  
#line 2913 
  if (table->rx_match_flags[match_pri] == match_flags) {
    
#line 2914 
    __retres = (int)match_pri;
    
#line 2914 
    goto return_label;
  }
  else ;
  
#line 2912 
  match_pri += 1U;
  ldv_57561: 
#line 2913 
  ;
  
#line 2910 
  if (table->rx_match_count > match_pri) 
#line 2913 
                                         goto ldv_57560; else 
#line 2916 
                                                              goto ldv_57562;
  ldv_57562: 
#line 2917 
  ;
  
#line 2916 
  __retres = -93;
  return_label: 
#line 2916 
                return __retres;
}


#line 2919  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static s32 efx_ef10_filter_insert(struct efx_nic *efx, struct efx_filter_spec *spec, bool replace_equal)
{
  s32 __retres;
  unsigned long mc_rem_map[4U];
  struct efx_filter_spec *saved_spec;
  unsigned int match_pri;
  unsigned int hash;
  unsigned int priv_flags;
  void *tmp;
  bool is_mc_recip;
  s32 rc;
  
#line 2923 
  struct efx_ef10_filter_table *table = (struct efx_ef10_filter_table *)efx->filter_state;
  
#line 2928 
  bool replacing = (_Bool)0;
  
#line 2929 
  int ins_index = -1;
  
#line 2930 
  tmp = (void *)get_current();
  
#line 2930 
  wait_queue_t wait = {.flags = 0U, .private = tmp, .func = & autoremove_wake_function, .task_list = {.next = & wait.task_list, .prev = & wait.task_list}};
  
#line 2935 
  if (((int)spec->flags & 24) != 8) {
    
#line 2937 
    __retres = -22;
    
#line 2937 
    goto return_label;
  }
  else ;
  
#line 2939 
  rc = efx_ef10_filter_rx_match_pri(table,(enum efx_filter_match_flags)spec->match_flags);
  
#line 2940 
  if (rc < 0) {
    
#line 2941 
    __retres = rc;
    
#line 2941 
    goto return_label;
  }
  else ;
  
#line 2942 
  match_pri = (unsigned int)rc;
  
#line 2944 
  hash = efx_ef10_filter_hash((struct efx_filter_spec const *)spec);
  
#line 2945 
  is_mc_recip = efx_filter_is_mc_recipient((struct efx_filter_spec const *)spec);
  
#line 2946 
  if ((int)is_mc_recip != 0) 
#line 2947 
                             bitmap_zero((unsigned long *)(& mc_rem_map),200U); else ;
  ldv_57585: 
#line 2948 
  ;
  {
    unsigned int i;
    
#line 2954 
    unsigned int depth = 1U;
    
#line 2957 
    ldv_spin_lock_bh_107(& efx->filter_lock);
    ldv_57584: 
#line 2958 
    ;
    
#line 2960 
    i = (hash + depth) & 8191U;
    
#line 2961 
    saved_spec = efx_ef10_filter_entry_spec((struct efx_ef10_filter_table const *)table,i);
    
#line 2963 
    if (saved_spec == (struct efx_filter_spec *)0) {
      
#line 2964 
      if (ins_index < 0) 
#line 2965 
                         ins_index = (int)i; else ;
    }
    else {
      bool tmp_0;
      
#line 2966 
      tmp_0 = efx_ef10_filter_equal((struct efx_filter_spec const *)spec,(struct efx_filter_spec const *)saved_spec);
      
#line 2966 
      if ((int)tmp_0 != 0) {
        
#line 2967 
        if (((table->entry + i)->spec & 1UL) != 0UL) 
#line 2969 
                                                     goto ldv_57581; else ;
        
#line 2970 
        if ((int)spec->priority < (int)saved_spec->priority && (unsigned int)*((unsigned char *)spec + 1UL) != 16U) {
          
#line 2972 
          rc = -1;
          
#line 2973 
          goto out_unlock;
        }
        else ;
        
#line 2975 
        if (! is_mc_recip) {
          
#line 2977 
          if (((unsigned int)((int)*((unsigned char *)spec + 1UL) ^ (int)*((unsigned char *)saved_spec + 1UL)) & 48U) == 0U && ! replace_equal) {
            
#line 2980 
            rc = -17;
            
#line 2981 
            goto out_unlock;
          }
          else ;
          
#line 2983 
          ins_index = (int)i;
          
#line 2984 
          goto found;
        }
        else 
          
#line 2985 
          if ((int)spec->priority > (int)saved_spec->priority || (((unsigned int)((int)*((unsigned char *)spec + 1UL) ^ (int)*((unsigned char *)saved_spec + 1UL)) & 48U) == 0U && (int)replace_equal != 0)) 
            
#line 2990 
            if (ins_index < 0) 
#line 2991 
                               ins_index = (int)i; else 
#line 2993 
                                                        __set_bit((long)depth,(unsigned long volatile *)(& mc_rem_map));
          else ;
      }
      else ;
    }
    
#line 3001 
    if (depth == 200U) {
      
#line 3002 
      if (ins_index < 0) {
        
#line 3003 
        rc = -16;
        
#line 3004 
        goto out_unlock;
      }
      else ;
      
#line 3006 
      goto found;
    }
    else ;
    
#line 3009 
    depth += 1U;
    
#line 2960 
    goto ldv_57584;
    ldv_57581: 
#line 2961 
    ;
    
#line 3012 
    prepare_to_wait(& table->waitq,& wait,2);
    
#line 3013 
    ldv_spin_unlock_bh_108(& efx->filter_lock);
    
#line 3014 
    schedule();
  }
  
#line 2953 
  goto ldv_57585;
  found: 
#line 3017 
  ;
  
#line 3023 
  saved_spec = efx_ef10_filter_entry_spec((struct efx_ef10_filter_table const *)table,(unsigned int)ins_index);
  
#line 3024 
  if (saved_spec != (struct efx_filter_spec *)0) {
    
#line 3025 
    if ((unsigned int)*((unsigned char *)spec + 1UL) == 16U && (unsigned int)*((unsigned char *)saved_spec + 1UL) != 0U) {
      
#line 3028 
      if ((unsigned int)saved_spec->priority > 1U) 
#line 3029 
                                                   saved_spec->flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))((unsigned int)saved_spec->flags | 4U); else ;
      
#line 3030 
      (table->entry + ins_index)->spec &= 18446744073709551613UL;
      
#line 3032 
      rc = ins_index;
      
#line 3033 
      goto out_unlock;
    }
    else ;
    
#line 3035 
    replacing = (_Bool)1;
    
#line 3036 
    priv_flags = efx_ef10_filter_entry_flags((struct efx_ef10_filter_table const *)table,(unsigned int)ins_index);
  }
  else {
    
#line 3038 
    saved_spec = (struct efx_filter_spec *)kmalloc_1(64UL,32U);
    
#line 3039 
    if (saved_spec == (struct efx_filter_spec *)0) {
      
#line 3040 
      rc = -12;
      
#line 3041 
      goto out_unlock;
    }
    else ;
    
#line 3043 
    *saved_spec = *spec;
    
#line 3044 
    priv_flags = 0U;
  }
  
#line 3046 
  efx_ef10_filter_set_entry(table,(unsigned int)ins_index,(struct efx_filter_spec const *)saved_spec,priv_flags | 1U);
  
#line 3050 
  if ((int)is_mc_recip != 0) {
    unsigned int depth_0;
    unsigned int i_0;
    int tmp_4;
    
#line 3053 
    depth_0 = 0U;
    
#line 3053 
    goto ldv_57589;
    ldv_57588: 
#line 3054 
    ;
    
#line 3054 
    i_0 = (hash + depth_0) & 8191U;
    
#line 3055 
    if (0 != 0) {
      int tmp_2;
      
#line 3055 
      tmp_2 = constant_test_bit((long)depth_0,(unsigned long const volatile *)(& mc_rem_map));
      
#line 3055 
      tmp_4 = tmp_2 != 0;
    }
    else {
      int tmp_3;
      
#line 3055 
      tmp_3 = variable_test_bit((long)depth_0,(unsigned long const volatile *)(& mc_rem_map));
      
#line 3055 
      tmp_4 = tmp_3 != 0;
    }
    
#line 3055 
    if (tmp_4) 
#line 3056 
               (table->entry + i_0)->spec |= 1UL; else ;
    
#line 3053 
    depth_0 += 1U;
    ldv_57589: 
#line 3054 
    ;
    
#line 3053 
    if (depth_0 <= 199U) 
#line 3055 
                         goto ldv_57588; else 
#line 3058 
                                              goto ldv_57590;
    ldv_57590: 
#line 3059 
    ;
  }
  else ;
  
#line 3061 
  ldv_spin_unlock_bh_109_0(& efx->filter_lock);
  
#line 3063 
  rc = efx_ef10_filter_push(efx,(struct efx_filter_spec const *)spec,& (table->entry + ins_index)->handle,(_Bool)((bool)((int)replacing) != 0));
  
#line 3067 
  ldv_spin_lock_bh_110_0(& efx->filter_lock);
  
#line 3068 
  if (rc == 0) {
    
#line 3069 
    if ((int)replacing != 0) {
      
#line 3071 
      if ((unsigned int)*((unsigned char *)saved_spec + 1UL) == 16U) 
        
#line 3072 
        saved_spec->flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))((unsigned int)saved_spec->flags | 4U); else ;
      
#line 3074 
      saved_spec->priority = spec->priority;
      
#line 3075 
      saved_spec->flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))((unsigned int)saved_spec->flags & 4U);
      
#line 3076 
      saved_spec->flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))((int)saved_spec->flags | (int)spec->flags);
      
#line 3077 
      saved_spec->rss_context = spec->rss_context;
      
#line 3078 
      saved_spec->dmaq_id = spec->dmaq_id;
    }
    else ;
  }
  else 
    
#line 3080 
    if (! replacing) {
      
#line 3081 
      kfree((void const *)saved_spec);
      
#line 3082 
      saved_spec = (struct efx_filter_spec *)0;
    }
    else ;
  
#line 3084 
  efx_ef10_filter_set_entry(table,(unsigned int)ins_index,(struct efx_filter_spec const *)saved_spec,priv_flags);
  
#line 3089 
  if ((int)is_mc_recip != 0) {
    unsigned int depth_1;
    unsigned int i_1;
    int tmp_7;
    
#line 3090 
    efx_dword_t inbuf[27U] = {{.u32 = {0U}}};
    
#line 3093 
    memset((void *)(& inbuf),0,108UL);
    
#line 3095 
    depth_1 = 0U;
    
#line 3095 
    goto ldv_57605;
    ldv_57604: 
#line 3096 
    ;
    
#line 3096 
    if (0 != 0) {
      int tmp_5;
      
#line 3096 
      tmp_5 = constant_test_bit((long)depth_1,(unsigned long const volatile *)(& mc_rem_map));
      
#line 3096 
      tmp_7 = tmp_5 == 0;
    }
    else {
      int tmp_6;
      
#line 3096 
      tmp_6 = variable_test_bit((long)depth_1,(unsigned long const volatile *)(& mc_rem_map));
      
#line 3096 
      tmp_7 = tmp_6 == 0;
    }
    
#line 3096 
    if (tmp_7) 
#line 3097 
               goto ldv_57594; else ;
    
#line 3099 
    i_1 = (hash + depth_1) & 8191U;
    
#line 3100 
    saved_spec = efx_ef10_filter_entry_spec((struct efx_ef10_filter_table const *)table,i_1);
    
#line 3101 
    priv_flags = efx_ef10_filter_entry_flags((struct efx_ef10_filter_table const *)table,i_1);
    
#line 3103 
    if (rc == 0) {
      
#line 3104 
      ldv_spin_unlock_bh_111_0(& efx->filter_lock);
      
#line 3105 
      ((efx_dword_t *)(& inbuf))->u32[0] = 3U;
      
#line 3107 
      ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = (unsigned int)(table->entry + i_1)->handle;
      
#line 3107 
      ((efx_dword_t *)(& inbuf) + 2U)->u32[0] = (unsigned int)((table->entry + i_1)->handle >> 32);
      
#line 3109 
      rc = efx_mcdi_rpc(efx,138U,(efx_dword_t const *)(& inbuf),108UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
      
#line 3112 
      ldv_spin_lock_bh_112_0(& efx->filter_lock);
    }
    else ;
    
#line 3115 
    if (rc == 0) {
      
#line 3116 
      kfree((void const *)saved_spec);
      
#line 3117 
      saved_spec = (struct efx_filter_spec *)0;
      
#line 3118 
      priv_flags = 0U;
    }
    else 
#line 3120 
         priv_flags &= 4294967294U;
    
#line 3122 
    efx_ef10_filter_set_entry(table,i_1,(struct efx_filter_spec const *)saved_spec,priv_flags);
    ldv_57594: 
#line 3123 
    ;
    
#line 3095 
    depth_1 += 1U;
    ldv_57605: 
#line 3096 
    ;
    
#line 3095 
    if (depth_1 <= 199U) 
#line 3097 
                         goto ldv_57604; else 
#line 3100 
                                              goto ldv_57606;
    ldv_57606: 
#line 3101 
    ;
  }
  else ;
  
#line 3128 
  if (rc == 0) 
#line 3129 
               rc = (int)(match_pri * 8192U + (unsigned int)ins_index); else ;
  
#line 3131 
  __wake_up(& table->waitq,3U,0,(void *)0);
  out_unlock: 
#line 3132 
  ;
  
#line 3133 
  ldv_spin_unlock_bh_113_0(& efx->filter_lock);
  
#line 3134 
  finish_wait(& table->waitq,& wait);
  
#line 3135 
  __retres = rc;
  return_label: 
#line 3135 
                return __retres;
}


#line 3138  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_filter_update_rx_scatter(struct efx_nic *efx)
{
  
#line 3140 
  return;
}


#line 3148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_filter_remove_internal(struct efx_nic *efx, unsigned int priority_mask, u32 filter_id, bool by_index)
{
  struct efx_filter_spec *spec;
  void *tmp;
  int rc;
  
#line 3152 
  unsigned int filter_idx = filter_id & 8191U;
  
#line 3153 
  struct efx_ef10_filter_table *table = (struct efx_ef10_filter_table *)efx->filter_state;
  
#line 3154 
  efx_dword_t inbuf[3U] = {{.u32 = {0U}}};
  
#line 3158 
  tmp = (void *)get_current();
  
#line 3158 
  wait_queue_t wait = {.flags = 0U, .private = tmp, .func = & autoremove_wake_function, .task_list = {.next = & wait.task_list, .prev = & wait.task_list}};
  ldv_57623: 
#line 3160 
  ;
  
#line 3166 
  ldv_spin_lock_bh_114(& efx->filter_lock);
  
#line 3167 
  if (((table->entry + filter_idx)->spec & 1UL) == 0UL) 
#line 3169 
                                                        goto ldv_57622; else ;
  
#line 3170 
  prepare_to_wait(& table->waitq,& wait,2);
  
#line 3171 
  ldv_spin_unlock_bh_115(& efx->filter_lock);
  
#line 3172 
  schedule();
  
#line 3166 
  goto ldv_57623;
  ldv_57622: 
#line 3167 
  ;
  
#line 3175 
  spec = efx_ef10_filter_entry_spec((struct efx_ef10_filter_table const *)table,filter_idx);
  
#line 3176 
  if (spec == (struct efx_filter_spec *)0) 
#line 3176 
                                           goto _LOR;
  else 
    
#line 3177 
    if (! by_index) {
      int tmp_0;
      
#line 3178 
      tmp_0 = efx_ef10_filter_rx_match_pri(table,(enum efx_filter_match_flags)spec->match_flags);
      
#line 3178 
      ;
      
#line 3178 
      if ((unsigned int)tmp_0 != filter_id / 8192U) {
        _LOR: {
                
#line 3180 
                rc = -2;
                
#line 3181 
                goto out_unlock;
              }
      }
      else ;
    }
    else ;
  
#line 3184 
  if (((int)spec->flags & 4) != 0 && priority_mask == 2U) {
    
#line 3187 
    spec->flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))((unsigned int)spec->flags & 59U);
    
#line 3188 
    (table->entry + filter_idx)->spec &= 18446744073709551613UL;
    
#line 3189 
    rc = 0;
    
#line 3190 
    goto out_unlock;
  }
  else ;
  
#line 3193 
  if (((priority_mask >> (int)spec->priority) & 1U) == 0U) {
    
#line 3194 
    rc = -2;
    
#line 3195 
    goto out_unlock;
  }
  else ;
  
#line 3198 
  (table->entry + filter_idx)->spec |= 1UL;
  
#line 3199 
  ldv_spin_unlock_bh_116_0(& efx->filter_lock);
  
#line 3201 
  if (((int)spec->flags & 4) != 0) {
    
#line 3204 
    struct efx_filter_spec new_spec = *spec;
    
#line 3206 
    new_spec.priority = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U;
    
#line 3207 
    new_spec.flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))9U;
    
#line 3209 
    new_spec.dmaq_id = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))))0U;
    
#line 3210 
    new_spec.rss_context = 4294967295U;
    
#line 3211 
    rc = efx_ef10_filter_push(efx,(struct efx_filter_spec const *)(& new_spec),& (table->entry + filter_idx)->handle,(_Bool)1);
    
#line 3215 
    ldv_spin_lock_bh_117_0(& efx->filter_lock);
    
#line 3216 
    if (rc == 0) 
#line 3217 
                 *spec = new_spec; else ;
  }
  else {
    {
      int tmp_2;
      bool tmp_1;
      
#line 3221 
      tmp_1 = efx_ef10_filter_is_exclusive((struct efx_filter_spec const *)spec);
      
#line 3221 
      if ((int)tmp_1 != 0) 
#line 3221 
                           tmp_2 = 1; else 
#line 3221 
                                           tmp_2 = 3;
      
#line 3221 
      ((efx_dword_t *)(& inbuf))->u32[0] = (unsigned int)tmp_2;
    }
    
#line 3225 
    ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = (unsigned int)(table->entry + filter_idx)->handle;
    
#line 3225 
    ((efx_dword_t *)(& inbuf) + 2U)->u32[0] = (unsigned int)((table->entry + filter_idx)->handle >> 32);
    
#line 3227 
    rc = efx_mcdi_rpc(efx,138U,(efx_dword_t const *)(& inbuf),12UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
    
#line 3230 
    ldv_spin_lock_bh_118(& efx->filter_lock);
    
#line 3231 
    if (rc == 0) {
      
#line 3232 
      kfree((void const *)spec);
      
#line 3233 
      efx_ef10_filter_set_entry(table,filter_idx,(struct efx_filter_spec const *)0,0U);
    }
    else ;
  }
  
#line 3237 
  (table->entry + filter_idx)->spec &= 18446744073709551614UL;
  
#line 3238 
  __wake_up(& table->waitq,3U,0,(void *)0);
  out_unlock: 
#line 3239 
  ;
  
#line 3240 
  ldv_spin_unlock_bh_119_0(& efx->filter_lock);
  
#line 3241 
  finish_wait(& table->waitq,& wait);
  
#line 3242 
  return rc;
}


#line 3245  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_filter_remove_safe(struct efx_nic *efx, enum efx_filter_priority priority, u32 filter_id)
{
  int tmp;
  
#line 3249 
  tmp = efx_ef10_filter_remove_internal(efx,1U << (unsigned int)priority,filter_id,(_Bool)0);
  
#line 3249 
  return tmp;
}


#line 3253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_filter_get_safe(struct efx_nic *efx, enum efx_filter_priority priority, u32 filter_id, struct efx_filter_spec *spec)
{
  struct efx_filter_spec const *saved_spec;
  int rc;
  
#line 3257 
  unsigned int filter_idx = filter_id & 8191U;
  
#line 3258 
  struct efx_ef10_filter_table *table = (struct efx_ef10_filter_table *)efx->filter_state;
  
#line 3262 
  ldv_spin_lock_bh_120(& efx->filter_lock);
  
#line 3263 
  saved_spec = (struct efx_filter_spec const *)efx_ef10_filter_entry_spec((struct efx_ef10_filter_table const *)table,filter_idx);
  
#line 3264 
  if (saved_spec != (struct efx_filter_spec const *)0 && (unsigned int)saved_spec->priority == (unsigned int)priority) {
    int tmp_0;
    
#line 3265 
    tmp_0 = efx_ef10_filter_rx_match_pri(table,(enum efx_filter_match_flags)saved_spec->match_flags);
    
#line 3265 
    ;
    
#line 3265 
    if ((unsigned int)tmp_0 == filter_id / 8192U) {
      
#line 3267 
      *spec = *saved_spec;
      
#line 3268 
      rc = 0;
    }
    else 
#line 3270 
         rc = -2;
  }
  else 
#line 3270 
       rc = -2;
  
#line 3272 
  ldv_spin_unlock_bh_121(& efx->filter_lock);
  
#line 3273 
  return rc;
}


#line 3276  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_filter_clear_rx(struct efx_nic *efx, enum efx_filter_priority priority)
{
  int __retres;
  unsigned int priority_mask;
  unsigned int i;
  int rc;
  
#line 3283 
  priority_mask = ~ (4294967295U << ((unsigned int)priority + 1U)) & 4294967293U;
  
#line 3286 
  i = 0U;
  
#line 3286 
  goto ldv_57658;
  ldv_57657: 
#line 3287 
  ;
  
#line 3287 
  rc = efx_ef10_filter_remove_internal(efx,priority_mask,i,(_Bool)1);
  
#line 3289 
  if (rc != 0 && rc != -2) {
    
#line 3290 
    __retres = rc;
    
#line 3290 
    goto return_label;
  }
  else ;
  
#line 3286 
  i += 1U;
  ldv_57658: 
#line 3287 
  ;
  
#line 3286 
  if (i <= 8191U) 
#line 3288 
                  goto ldv_57657; else 
#line 3291 
                                       goto ldv_57659;
  ldv_57659: 
#line 3292 
  ;
  
#line 3293 
  __retres = 0;
  return_label: 
#line 3293 
                return __retres;
}


#line 3296  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static u32 efx_ef10_filter_count_rx_used(struct efx_nic *efx, enum efx_filter_priority priority)
{
  u32 __retres;
  unsigned int filter_idx;
  
#line 3299 
  struct efx_ef10_filter_table *table = (struct efx_ef10_filter_table *)efx->filter_state;
  
#line 3301 
  s32 count = 0;
  
#line 3303 
  ldv_spin_lock_bh_122(& efx->filter_lock);
  
#line 3304 
  filter_idx = 0U;
  
#line 3304 
  goto ldv_57668;
  ldv_57667: 
#line 3305 
  ;
  
#line 3305 
  if ((table->entry + filter_idx)->spec != 0UL) {
    struct efx_filter_spec *tmp;
    
#line 3306 
    tmp = efx_ef10_filter_entry_spec((struct efx_ef10_filter_table const *)table,filter_idx);
    
#line 3306 
    ;
    
#line 3306 
    if ((unsigned int)tmp->priority == (unsigned int)priority) 
#line 3308 
                                                               count += 1; else ;
  }
  else ;
  
#line 3304 
  filter_idx += 1U;
  ldv_57668: 
#line 3305 
  ;
  
#line 3304 
  if (filter_idx <= 8191U) 
#line 3306 
                           goto ldv_57667; else 
#line 3309 
                                                goto ldv_57669;
  ldv_57669: 
#line 3310 
  ;
  
#line 3310 
  ldv_spin_unlock_bh_123(& efx->filter_lock);
  
#line 3311 
  __retres = (unsigned int)count;
  
#line 3311 
  return __retres;
}


#line 3314  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static u32 efx_ef10_filter_get_rx_id_limit(struct efx_nic *efx)
{
  u32 __retres;
  
#line 3316 
  struct efx_ef10_filter_table *table = (struct efx_ef10_filter_table *)efx->filter_state;
  
#line 3318 
  __retres = table->rx_match_count * 8192U;
  
#line 3318 
  return __retres;
}


#line 3321  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static s32 efx_ef10_filter_get_rx_ids(struct efx_nic *efx, enum efx_filter_priority priority, u32 *buf, u32 size)
{
  struct efx_filter_spec *spec;
  unsigned int filter_idx;
  
#line 3325 
  struct efx_ef10_filter_table *table = (struct efx_ef10_filter_table *)efx->filter_state;
  
#line 3328 
  s32 count = 0;
  
#line 3330 
  ldv_spin_lock_bh_124(& efx->filter_lock);
  
#line 3331 
  filter_idx = 0U;
  
#line 3331 
  goto ldv_57686;
  ldv_57685: 
#line 3332 
  ;
  
#line 3332 
  spec = efx_ef10_filter_entry_spec((struct efx_ef10_filter_table const *)table,filter_idx);
  
#line 3333 
  if (spec != (struct efx_filter_spec *)0 && (unsigned int)spec->priority == (unsigned int)priority) {
    s32 tmp;
    int tmp_0;
    
#line 3334 
    if ((unsigned int)count == size) {
      
#line 3335 
      count = -90;
      
#line 3336 
      goto ldv_57684;
    }
    else ;
    
#line 3338 
    tmp = count;
    
#line 3338 
    count += 1;
    
#line 3339 
    tmp_0 = efx_ef10_filter_rx_match_pri(table,(enum efx_filter_match_flags)spec->match_flags);
    
#line 3338 
    *(buf + tmp) = (unsigned int)(tmp_0 * 8192) + filter_idx;
  }
  else ;
  
#line 3331 
  filter_idx += 1U;
  ldv_57686: 
#line 3332 
  ;
  
#line 3331 
  if (filter_idx <= 8191U) 
#line 3333 
                           goto ldv_57685; else 
#line 3336 
                                                goto ldv_57684;
  ldv_57684: 
#line 3337 
  ;
  
#line 3344 
  ldv_spin_unlock_bh_125(& efx->filter_lock);
  
#line 3345 
  return count;
}


#line 3350 
static void efx_ef10_filter_rfs_insert_complete(struct efx_nic *efx, unsigned long cookie, int rc, efx_dword_t *outbuf, size_t outlen_actual);


#line 3352  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static s32 efx_ef10_filter_rfs_insert(struct efx_nic *efx, struct efx_filter_spec *spec)
{
  s32 __retres;
  struct efx_filter_spec *saved_spec;
  unsigned int hash;
  unsigned int i;
  u64 cookie;
  s32 rc;
  
#line 3355 
  struct efx_ef10_filter_table *table = (struct efx_ef10_filter_table *)efx->filter_state;
  
#line 3356 
  efx_dword_t inbuf[27U] = {{.u32 = {0U}}};
  
#line 3358 
  unsigned int depth = 1U;
  
#line 3359 
  bool replacing = (_Bool)0;
  
#line 3360 
  int ins_index = -1;
  
#line 3374 
  hash = efx_ef10_filter_hash((struct efx_filter_spec const *)spec);
  
#line 3376 
  ldv_spin_lock_bh_126(& efx->filter_lock);
  ldv_57704: 
#line 3377 
  ;
  
#line 3383 
  i = (hash + depth) & 8191U;
  
#line 3384 
  saved_spec = efx_ef10_filter_entry_spec((struct efx_ef10_filter_table const *)table,i);
  
#line 3386 
  if (saved_spec == (struct efx_filter_spec *)0) {
    
#line 3387 
    if (ins_index < 0) 
#line 3388 
                       ins_index = (int)i; else ;
  }
  else {
    bool tmp;
    
#line 3389 
    tmp = efx_ef10_filter_equal((struct efx_filter_spec const *)spec,(struct efx_filter_spec const *)saved_spec);
    
#line 3389 
    if ((int)tmp != 0) {
      
#line 3390 
      if (((table->entry + i)->spec & 1UL) != 0UL) {
        
#line 3391 
        rc = -16;
        
#line 3392 
        goto fail_unlock;
      }
      else ;
      
#line 3394 
      if ((int)spec->priority < (int)saved_spec->priority) {
        
#line 3395 
        rc = -1;
        
#line 3396 
        goto fail_unlock;
      }
      else ;
      
#line 3398 
      ins_index = (int)i;
      
#line 3399 
      goto ldv_57703;
    }
    else ;
  }
  
#line 3406 
  if (depth == 200U) {
    
#line 3407 
    if (ins_index < 0) {
      
#line 3408 
      rc = -16;
      
#line 3409 
      goto fail_unlock;
    }
    else ;
    
#line 3411 
    goto ldv_57703;
  }
  else ;
  
#line 3414 
  depth += 1U;
  
#line 3383 
  goto ldv_57704;
  ldv_57703: 
#line 3384 
  ;
  
#line 3422 
  saved_spec = efx_ef10_filter_entry_spec((struct efx_ef10_filter_table const *)table,(unsigned int)ins_index);
  
#line 3423 
  if (saved_spec != (struct efx_filter_spec *)0) 
#line 3424 
                                                 replacing = (_Bool)1;
  else {
    
#line 3426 
    saved_spec = (struct efx_filter_spec *)kmalloc_1(64UL,32U);
    
#line 3427 
    if (saved_spec == (struct efx_filter_spec *)0) {
      
#line 3428 
      rc = -12;
      
#line 3429 
      goto fail_unlock;
    }
    else ;
    
#line 3431 
    *saved_spec = *spec;
  }
  
#line 3433 
  efx_ef10_filter_set_entry(table,(unsigned int)ins_index,(struct efx_filter_spec const *)saved_spec,1U);
  
#line 3436 
  ldv_spin_unlock_bh_127(& efx->filter_lock);
  
#line 3439 
  cookie = (unsigned long long)((((int)replacing << 31) | (ins_index << 16)) | (int)spec->dmaq_id);
  
#line 3441 
  efx_ef10_filter_push_prep(efx,(struct efx_filter_spec const *)spec,(efx_dword_t *)(& inbuf),(table->entry + ins_index)->handle,(_Bool)((bool)((int)replacing) != 0));
  
#line 3443 
  efx_mcdi_rpc_async(efx,138U,(efx_dword_t const *)(& inbuf),108UL,12UL,& efx_ef10_filter_rfs_insert_complete,(unsigned long)cookie);
  
#line 3447 
  __retres = ins_index;
  
#line 3447 
  goto return_label;
  fail_unlock: 
#line 3449 
  ;
  
#line 3450 
  ldv_spin_unlock_bh_128(& efx->filter_lock);
  
#line 3451 
  __retres = rc;
  return_label: 
#line 3451 
                return __retres;
}


#line 3455  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_filter_rfs_insert_complete(struct efx_nic *efx, unsigned long cookie, int rc, efx_dword_t *outbuf, size_t outlen_actual)
{
  unsigned int ins_index;
  unsigned int dmaq_id;
  struct efx_filter_spec *spec;
  bool replacing;
  
#line 3459 
  struct efx_ef10_filter_table *table = (struct efx_ef10_filter_table *)efx->filter_state;
  
#line 3465 
  replacing = (_Bool)(cookie >> 31 != 0UL);
  
#line 3466 
  ins_index = (unsigned int)(cookie >> 16) & 8191U;
  
#line 3467 
  dmaq_id = (unsigned int)cookie & 65535U;
  
#line 3469 
  ldv_spin_lock_bh_129(& efx->filter_lock);
  
#line 3470 
  spec = efx_ef10_filter_entry_spec((struct efx_ef10_filter_table const *)table,ins_index);
  
#line 3471 
  if (rc == 0) {
    
#line 3472 
    (table->entry + ins_index)->handle = (unsigned long long)(outbuf + 1U)->u32[0] | ((unsigned long long)(outbuf + 2U)->u32[0] << 32);
    
#line 3474 
    if ((int)replacing != 0) 
#line 3475 
                             spec->dmaq_id = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))))dmaq_id; else ;
  }
  else 
    
#line 3476 
    if (! replacing) {
      
#line 3477 
      kfree((void const *)spec);
      
#line 3478 
      spec = (struct efx_filter_spec *)0;
    }
    else ;
  
#line 3480 
  efx_ef10_filter_set_entry(table,ins_index,(struct efx_filter_spec const *)spec,0U);
  
#line 3481 
  ldv_spin_unlock_bh_130(& efx->filter_lock);
  
#line 3483 
  __wake_up(& table->waitq,3U,0,(void *)0);
  
#line 3484 
  return;
}


#line 3487 
static void efx_ef10_filter_rfs_expire_complete(struct efx_nic *efx, unsigned long filter_idx, int rc, efx_dword_t *outbuf, size_t outlen_actual);


#line 3492  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static bool efx_ef10_filter_rfs_expire_one(struct efx_nic *efx, u32 flow_id, unsigned int filter_idx)
{
  bool __retres;
  int tmp_2;
  
#line 3495 
  struct efx_ef10_filter_table *table = (struct efx_ef10_filter_table *)efx->filter_state;
  
#line 3496 
  struct efx_filter_spec *spec = efx_ef10_filter_entry_spec((struct efx_ef10_filter_table const *)table,filter_idx);
  
#line 3498 
  efx_dword_t inbuf[3U] = {{.u32 = {0U}}};
  
#line 3502 
  if ((spec == (struct efx_filter_spec *)0 || ((table->entry + filter_idx)->spec & 1UL) != 0UL) || (unsigned int)*((unsigned char *)spec + 1UL) != 0U) {
    
#line 3507 
    __retres = (_Bool)0;
    
#line 3507 
    goto return_label;
  }
  else {
    int tmp_1;
    bool tmp_0;
    
#line 3505 
    tmp_0 = rps_may_expire_flow(efx->net_dev,(unsigned short)((int)spec->dmaq_id),flow_id,(unsigned short)((int)((unsigned short)filter_idx)));
    
#line 3505 
    if (tmp_0) 
#line 3505 
               tmp_1 = 0; else 
#line 3505 
                               tmp_1 = 1;
    
#line 3505 
    if (tmp_1) {
      
#line 3507 
      __retres = (_Bool)0;
      
#line 3507 
      goto return_label;
    }
    else ;
  }
  
#line 3509 
  ((efx_dword_t *)(& inbuf))->u32[0] = 1U;
  
#line 3511 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = (unsigned int)(table->entry + filter_idx)->handle;
  
#line 3511 
  ((efx_dword_t *)(& inbuf) + 2U)->u32[0] = (unsigned int)((table->entry + filter_idx)->handle >> 32);
  
#line 3513 
  tmp_2 = efx_mcdi_rpc_async(efx,138U,(efx_dword_t const *)(& inbuf),12UL,0UL,& efx_ef10_filter_rfs_expire_complete,(unsigned long)filter_idx);
  
#line 3513 
  if (tmp_2 != 0) {
    
#line 3515 
    __retres = (_Bool)0;
    
#line 3515 
    goto return_label;
  }
  else ;
  
#line 3517 
  (table->entry + filter_idx)->spec |= 1UL;
  
#line 3518 
  __retres = (_Bool)1;
  return_label: 
#line 3518 
                return __retres;
}


#line 3522  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_filter_rfs_expire_complete(struct efx_nic *efx, unsigned long filter_idx, int rc, efx_dword_t *outbuf, size_t outlen_actual)
{
  
#line 3527 
  struct efx_ef10_filter_table *table = (struct efx_ef10_filter_table *)efx->filter_state;
  
#line 3528 
  struct efx_filter_spec *spec = efx_ef10_filter_entry_spec((struct efx_ef10_filter_table const *)table,(unsigned int)filter_idx);
  
#line 3531 
  ldv_spin_lock_bh_131(& efx->filter_lock);
  
#line 3532 
  if (rc == 0) {
    
#line 3533 
    kfree((void const *)spec);
    
#line 3534 
    efx_ef10_filter_set_entry(table,(unsigned int)filter_idx,(struct efx_filter_spec const *)0,0U);
  }
  else ;
  
#line 3536 
  (table->entry + filter_idx)->spec &= 18446744073709551614UL;
  
#line 3537 
  __wake_up(& table->waitq,3U,0,(void *)0);
  
#line 3538 
  ldv_spin_unlock_bh_132(& efx->filter_lock);
  
#line 3539 
  return;
}


#line 3543  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_filter_match_flags_from_mcdi(u32 mcdi_flags)
{
  int __retres;
  
#line 3545 
  int match_flags = 0;
  {
    
#line 3554 
    u32 old_mcdi_flags = mcdi_flags;
    
#line 3554 
    mcdi_flags &= 2147483647U;
    
#line 3554 
    if (mcdi_flags != old_mcdi_flags) 
#line 3554 
                                      match_flags |= 1024; else ;
  }
  {
    
#line 3555 
    u32 old_mcdi_flags_0 = mcdi_flags;
    
#line 3555 
    mcdi_flags &= 3221225471U;
    
#line 3555 
    if (mcdi_flags != old_mcdi_flags_0) 
#line 3555 
                                        match_flags |= 1024; else ;
  }
  {
    
#line 3556 
    u32 old_mcdi_flags_1 = mcdi_flags;
    
#line 3556 
    mcdi_flags &= 4294967294U;
    
#line 3556 
    if (mcdi_flags != old_mcdi_flags_1) 
#line 3556 
                                        match_flags |= 1; else ;
  }
  {
    
#line 3557 
    u32 old_mcdi_flags_2 = mcdi_flags;
    
#line 3557 
    mcdi_flags &= 4294967293U;
    
#line 3557 
    if (mcdi_flags != old_mcdi_flags_2) 
#line 3557 
                                        match_flags |= 2; else ;
  }
  {
    
#line 3558 
    u32 old_mcdi_flags_3 = mcdi_flags;
    
#line 3558 
    mcdi_flags &= 4294967291U;
    
#line 3558 
    if (mcdi_flags != old_mcdi_flags_3) 
#line 3558 
                                        match_flags |= 4; else ;
  }
  {
    
#line 3559 
    u32 old_mcdi_flags_4 = mcdi_flags;
    
#line 3559 
    mcdi_flags &= 4294967287U;
    
#line 3559 
    if (mcdi_flags != old_mcdi_flags_4) 
#line 3559 
                                        match_flags |= 8; else ;
  }
  {
    
#line 3560 
    u32 old_mcdi_flags_5 = mcdi_flags;
    
#line 3560 
    mcdi_flags &= 4294967279U;
    
#line 3560 
    if (mcdi_flags != old_mcdi_flags_5) 
#line 3560 
                                        match_flags |= 16; else ;
  }
  {
    
#line 3561 
    u32 old_mcdi_flags_6 = mcdi_flags;
    
#line 3561 
    mcdi_flags &= 4294967263U;
    
#line 3561 
    if (mcdi_flags != old_mcdi_flags_6) 
#line 3561 
                                        match_flags |= 32; else ;
  }
  {
    
#line 3562 
    u32 old_mcdi_flags_7 = mcdi_flags;
    
#line 3562 
    mcdi_flags &= 4294967231U;
    
#line 3562 
    if (mcdi_flags != old_mcdi_flags_7) 
#line 3562 
                                        match_flags |= 64; else ;
  }
  {
    
#line 3563 
    u32 old_mcdi_flags_8 = mcdi_flags;
    
#line 3563 
    mcdi_flags &= 4294967167U;
    
#line 3563 
    if (mcdi_flags != old_mcdi_flags_8) 
#line 3563 
                                        match_flags |= 128; else ;
  }
  {
    
#line 3564 
    u32 old_mcdi_flags_9 = mcdi_flags;
    
#line 3564 
    mcdi_flags &= 4294967039U;
    
#line 3564 
    if (mcdi_flags != old_mcdi_flags_9) 
#line 3564 
                                        match_flags |= 256; else ;
  }
  {
    
#line 3565 
    u32 old_mcdi_flags_10 = mcdi_flags;
    
#line 3565 
    mcdi_flags &= 4294966783U;
    
#line 3565 
    if (mcdi_flags != old_mcdi_flags_10) 
#line 3565 
                                         match_flags |= 512; else ;
  }
  
#line 3569 
  if (mcdi_flags != 0U) {
    
#line 3570 
    __retres = -22;
    
#line 3570 
    goto return_label;
  }
  else ;
  
#line 3572 
  __retres = match_flags;
  return_label: 
#line 3572 
                return __retres;
}


#line 3575  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_filter_table_probe(struct efx_nic *efx)
{
  int __retres;
  unsigned int pd_match_pri;
  unsigned int pd_match_count;
  struct efx_ef10_filter_table *table;
  size_t outlen;
  int rc;
  size_t tmp_1;
  
#line 3577 
  efx_dword_t inbuf[1U] = {{.u32 = {0U}}};
  
#line 3578 
  efx_dword_t outbuf[63U] = {{.u32 = {0U}}};
  
#line 3584 
  table = (struct efx_ef10_filter_table *)kzalloc_6(2656UL,208U);
  
#line 3585 
  if (table == (struct efx_ef10_filter_table *)0) {
    
#line 3586 
    __retres = -12;
    
#line 3586 
    goto return_label;
  }
  else ;
  
#line 3589 
  ((efx_dword_t *)(& inbuf))->u32[0] = 1U;
  
#line 3591 
  rc = efx_mcdi_rpc(efx,228U,(efx_dword_t const *)(& inbuf),4UL,(efx_dword_t *)(& outbuf),252UL,& outlen);
  
#line 3594 
  if (rc != 0) 
#line 3595 
               goto fail; else ;
  {
    size_t tmp_0;
    
#line 3596 
    size_t __min1 = 61UL;
    
#line 3596 
    size_t __min2 = (outlen + 18446744073709551608UL) / 4UL;
    
#line 3596 
    if (__min1 < __min2) 
#line 3596 
                         tmp_0 = __min1; else 
#line 3596 
                                              tmp_0 = __min2;
    
#line 3596 
    tmp_1 = tmp_0;
  }
  
#line 3596 
  pd_match_count = (unsigned int)tmp_1;
  
#line 3598 
  table->rx_match_count = 0U;
  
#line 3600 
  pd_match_pri = 0U;
  
#line 3600 
  goto ldv_57817;
  ldv_57816: 
#line 3601 
  ;
  {
    
#line 3601 
    u32 mcdi_flags = ((efx_dword_t *)(& outbuf) + (pd_match_pri + 2U) * 4U)->u32[0];
    
#line 3606 
    rc = efx_ef10_filter_match_flags_from_mcdi(mcdi_flags);
    
#line 3607 
    if (rc < 0) {
      
#line 3608 
      if ((efx->msg_enable & 2U) != 0U) {
        
#line 3608 
        struct _ddebug descriptor = {.modname = "sfc", .function = "efx_ef10_filter_table_probe", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c", .format = "%s: fw flags %#x pri %u not supported in driver\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3610U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 3608 
        if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 3608 
                                                            __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"%s: fw flags %#x pri %u not supported in driver\n","efx_ef10_filter_table_probe",mcdi_flags,pd_match_pri); else ;
      }
      else ;
    }
    else {
      unsigned int tmp_2;
      
#line 3612 
      if ((efx->msg_enable & 2U) != 0U) {
        
#line 3612 
        struct _ddebug descriptor_0 = {.modname = "sfc", .function = "efx_ef10_filter_table_probe", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c", .format = "%s: fw flags %#x pri %u supported as driver flags %#x pri %u\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3615U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 3612 
        if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 3612 
                                                              __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)efx->net_dev,"%s: fw flags %#x pri %u supported as driver flags %#x pri %u\n","efx_ef10_filter_table_probe",mcdi_flags,pd_match_pri,rc,table->rx_match_count); else ;
      }
      else ;
      
#line 3616 
      tmp_2 = table->rx_match_count;
      
#line 3616 
      table->rx_match_count += 1U;
      
#line 3616 
      table->rx_match_flags[tmp_2] = (enum efx_filter_match_flags)rc;
    }
  }
  
#line 3600 
  pd_match_pri += 1U;
  ldv_57817: 
#line 3601 
  ;
  
#line 3600 
  if (pd_match_pri < pd_match_count) 
#line 3602 
                                     goto ldv_57816; else 
#line 3605 
                                                          goto ldv_57818;
  ldv_57818: 
#line 3606 
  ;
  
#line 67 
  table->entry = (struct __anonstruct_entry_6217 *)vzalloc(131072UL);
  
#line 3621 
  if (table->entry == (struct __anonstruct_entry_6217 *)0) {
    
#line 3622 
    rc = -12;
    
#line 3623 
    goto fail;
  }
  else ;
  
#line 3626 
  efx->filter_state = (void *)table;
  {
    struct lock_class_key __key;
    
#line 3627 
    __init_waitqueue_head(& table->waitq,"&table->waitq",& __key);
  }
  
#line 3628 
  __retres = 0;
  
#line 3628 
  goto return_label;
  fail: 
#line 3630 
  ;
  
#line 3631 
  kfree((void const *)table);
  
#line 3632 
  __retres = rc;
  return_label: 
#line 3632 
                return __retres;
}


#line 3638  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_filter_table_restore(struct efx_nic *efx)
{
  struct efx_filter_spec *spec;
  unsigned int filter_idx;
  int rc;
  
#line 3640 
  struct efx_ef10_filter_table *table = (struct efx_ef10_filter_table *)efx->filter_state;
  
#line 3641 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 3644 
  bool failed = (_Bool)0;
  {
    int tmp;
    
#line 3647 
    tmp = rwsem_is_locked(& efx->filter_sem);
    
#line 3647 
    int __ret_warn_on = tmp == 0;
    
#line 3647 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 3647 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c",3647); else ;
    
#line 3647 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 3649 
  if (! nic_data->must_restore_filters) 
#line 3650 
                                        goto return_label; else ;
  
#line 3652 
  if (table == (struct efx_ef10_filter_table *)0) 
#line 3653 
                                                  goto return_label; else ;
  
#line 3655 
  ldv_spin_lock_bh_133(& efx->filter_lock);
  
#line 3657 
  filter_idx = 0U;
  
#line 3657 
  goto ldv_57833;
  ldv_57832: 
#line 3658 
  ;
  
#line 3658 
  spec = efx_ef10_filter_entry_spec((struct efx_ef10_filter_table const *)table,filter_idx);
  
#line 3659 
  if (spec == (struct efx_filter_spec *)0) 
#line 3660 
                                           goto ldv_57831; else ;
  
#line 3662 
  (table->entry + filter_idx)->spec |= 1UL;
  
#line 3663 
  ldv_spin_unlock_bh_134(& efx->filter_lock);
  
#line 3665 
  rc = efx_ef10_filter_push(efx,(struct efx_filter_spec const *)spec,& (table->entry + filter_idx)->handle,(_Bool)0);
  
#line 3668 
  if (rc != 0) 
#line 3669 
               failed = (_Bool)1; else ;
  
#line 3671 
  ldv_spin_lock_bh_135(& efx->filter_lock);
  
#line 3672 
  if (rc != 0) {
    
#line 3673 
    kfree((void const *)spec);
    
#line 3674 
    efx_ef10_filter_set_entry(table,filter_idx,(struct efx_filter_spec const *)0,0U);
  }
  else 
#line 3676 
       (table->entry + filter_idx)->spec &= 18446744073709551614UL;
  ldv_57831: 
#line 3677 
  ;
  
#line 3657 
  filter_idx += 1U;
  ldv_57833: 
#line 3658 
  ;
  
#line 3657 
  if (filter_idx <= 8191U) 
#line 3659 
                           goto ldv_57832; else 
#line 3662 
                                                goto ldv_57834;
  ldv_57834: 
#line 3663 
  ;
  
#line 3681 
  ldv_spin_unlock_bh_136(& efx->filter_lock);
  
#line 3683 
  if ((int)failed != 0) {
    
#line 3684 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 3684 
                                         netdev_err((struct net_device const *)efx->net_dev,"unable to restore all filters\n"); else ;
  }
  else 
#line 3687 
       nic_data->must_restore_filters = (_Bool)0;
  return_label: 
#line 3688 
                return;
}


#line 3691  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_filter_table_remove(struct efx_nic *efx)
{
  struct efx_filter_spec *spec;
  unsigned int filter_idx;
  int rc;
  
#line 3693 
  struct efx_ef10_filter_table *table = (struct efx_ef10_filter_table *)efx->filter_state;
  
#line 3694 
  efx_dword_t inbuf[27U] = {{.u32 = {0U}}};
  
#line 3699 
  efx->filter_state = (void *)0;
  
#line 3700 
  if (table == (struct efx_ef10_filter_table *)0) 
#line 3701 
                                                  goto return_label; else ;
  
#line 3703 
  filter_idx = 0U;
  
#line 3703 
  goto ldv_57856;
  ldv_57855: 
#line 3704 
  ;
  
#line 3704 
  spec = efx_ef10_filter_entry_spec((struct efx_ef10_filter_table const *)table,filter_idx);
  
#line 3705 
  if (spec == (struct efx_filter_spec *)0) 
#line 3706 
                                           goto ldv_57843; else ;
  {
    int tmp_0;
    bool tmp;
    
#line 3708 
    tmp = efx_ef10_filter_is_exclusive((struct efx_filter_spec const *)spec);
    
#line 3708 
    if ((int)tmp != 0) 
#line 3708 
                       tmp_0 = 1; else 
#line 3708 
                                       tmp_0 = 3;
    
#line 3708 
    ((efx_dword_t *)(& inbuf))->u32[0] = (unsigned int)tmp_0;
  }
  
#line 3712 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = (unsigned int)(table->entry + filter_idx)->handle;
  
#line 3712 
  ((efx_dword_t *)(& inbuf) + 2U)->u32[0] = (unsigned int)((table->entry + filter_idx)->handle >> 32);
  
#line 3714 
  rc = efx_mcdi_rpc(efx,138U,(efx_dword_t const *)(& inbuf),108UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 3716 
  if (rc != 0) {
    
#line 3717 
    int __ret_warn_on = 1;
    
#line 3717 
    if ((long)(__ret_warn_on != 0) != 0L) {
      char const *tmp_1;
      char const *tmp_2;
      
#line 3717 
      ;
      
#line 3717 
      ;
      
#line 3717 
      tmp_1 = netdev_reg_state((struct net_device const *)efx->net_dev);
      
#line 3717 
      tmp_2 = netdev_name((struct net_device const *)efx->net_dev);
      
#line 3717 
      warn_slowpath_fmt("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c",3720,"netdevice: %s%s\n",tmp_2,tmp_1,filter_idx,(table->entry + filter_idx)->handle);
    }
    else ;
    
#line 3717 
    long tmp_3 = (long)(__ret_warn_on != 0);
  }
  else ;
  
#line 3721 
  kfree((void const *)spec);
  ldv_57843: 
#line 3722 
  ;
  
#line 3703 
  filter_idx += 1U;
  ldv_57856: 
#line 3704 
  ;
  
#line 3703 
  if (filter_idx <= 8191U) 
#line 3705 
                           goto ldv_57855; else 
#line 3708 
                                                goto ldv_57857;
  ldv_57857: 
#line 3709 
  ;
  
#line 3724 
  vfree((void const *)table->entry);
  
#line 3725 
  kfree((void const *)table);
  return_label: 
#line 3726 
                return;
}


#line 3731  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_filter_sync_rx_mode(struct efx_nic *efx)
{
  struct efx_filter_spec spec;
  struct netdev_hw_addr *uc;
  struct netdev_hw_addr *mc;
  unsigned int filter_idx;
  int i;
  int n;
  int rc;
  int tmp;
  unsigned long volatile *tmp_7_0;
  
#line 3733 
  struct efx_ef10_filter_table *table = (struct efx_ef10_filter_table *)efx->filter_state;
  
#line 3734 
  struct net_device *net_dev = efx->net_dev;
  
#line 3736 
  bool remove_failed = (_Bool)0;
  
#line 3742 
  tmp = efx_dev_registered(efx);
  
#line 3742 
  if (tmp == 0) 
#line 3743 
                goto return_label; else ;
  
#line 3745 
  if (table == (struct efx_ef10_filter_table *)0) 
#line 3746 
                                                  goto return_label; else ;
  
#line 3749 
  ldv_spin_lock_bh_137(& efx->filter_lock);
  
#line 3750 
  if (table->dev_uc_count >= 0) 
#line 3750 
                                n = table->dev_uc_count; else 
#line 3750 
                                                              n = 1;
  
#line 3751 
  i = 0;
  
#line 3751 
  goto ldv_57872;
  ldv_57871: 
#line 3752 
  ;
  
#line 3752 
  filter_idx = (unsigned int)table->dev_uc_list[i].id & 8191U;
  
#line 3753 
  (table->entry + filter_idx)->spec |= 2UL;
  
#line 3751 
  i += 1;
  ldv_57872: 
#line 3752 
  ;
  
#line 3751 
  if (i < n) 
#line 3753 
             goto ldv_57871; else 
#line 3756 
                                  goto ldv_57873;
  ldv_57873: 
#line 3757 
  ;
  
#line 3755 
  if (table->dev_mc_count >= 0) 
#line 3755 
                                n = table->dev_mc_count; else 
#line 3755 
                                                              n = 1;
  
#line 3756 
  i = 0;
  
#line 3756 
  goto ldv_57875;
  ldv_57874: 
#line 3757 
  ;
  
#line 3757 
  filter_idx = (unsigned int)table->dev_mc_list[i].id & 8191U;
  
#line 3758 
  (table->entry + filter_idx)->spec |= 2UL;
  
#line 3756 
  i += 1;
  ldv_57875: 
#line 3757 
  ;
  
#line 3756 
  if (i < n) 
#line 3758 
             goto ldv_57874; else 
#line 3761 
                                  goto ldv_57876;
  ldv_57876: 
#line 3762 
  ;
  
#line 3760 
  ldv_spin_unlock_bh_138(& efx->filter_lock);
  
#line 3765 
  netif_addr_lock_bh_0(net_dev);
  
#line 3766 
  if ((net_dev->flags & 256U) != 0U || net_dev->uc.count > 31) 
#line 3768 
                                                               table->dev_uc_count = -1;
  else {
    struct netdev_hw_addr *tmp_0;
    struct netdev_hw_addr *tmp_1;
    
#line 3770 
    table->dev_uc_count = net_dev->uc.count + 1;
    
#line 3771 
    ether_addr_copy((u8 *)(& table->dev_uc_list[0].addr),(u8 const *)net_dev->dev_addr);
    
#line 3772 
    i = 1;
    {
      
#line 3773 
      struct list_head const *__mptr = (struct list_head const *)net_dev->uc.list.next;
      
#line 3773 
      tmp_0 = (struct netdev_hw_addr *)__mptr;
    }
    
#line 3773 
    uc = tmp_0;
    
#line 3773 
    goto ldv_57882;
    ldv_57881: 
#line 3774 
    ;
    
#line 3774 
    ether_addr_copy((u8 *)(& table->dev_uc_list[i].addr),(u8 const *)(& uc->addr));
    
#line 3775 
    i += 1;
    {
      
#line 3773 
      struct list_head const *__mptr_0 = (struct list_head const *)uc->list.next;
      
#line 3773 
      tmp_1 = (struct netdev_hw_addr *)__mptr_0;
    }
    
#line 3773 
    uc = tmp_1;
    ldv_57882: 
#line 3775 
    ;
    
#line 3773 
    if (& uc->list != & net_dev->uc.list) 
#line 3775 
                                          goto ldv_57881; else 
#line 3778 
                                                               goto ldv_57883;
    ldv_57883: 
#line 3779 
    ;
  }
  
#line 3778 
  if ((net_dev->flags & 768U) != 0U || net_dev->mc.count > 255) 
#line 3780 
                                                                table->dev_mc_count = -1;
  else {
    struct netdev_hw_addr *tmp_2;
    struct netdev_hw_addr *tmp_3;
    
#line 3782 
    table->dev_mc_count = net_dev->mc.count + 1;
    
#line 3783 
    eth_broadcast_addr((u8 *)(& table->dev_mc_list[0].addr));
    
#line 3784 
    i = 1;
    {
      
#line 3785 
      struct list_head const *__mptr_1 = (struct list_head const *)net_dev->mc.list.next;
      
#line 3785 
      tmp_2 = (struct netdev_hw_addr *)__mptr_1;
    }
    
#line 3785 
    mc = tmp_2;
    
#line 3785 
    goto ldv_57889;
    ldv_57888: 
#line 3786 
    ;
    
#line 3786 
    ether_addr_copy((u8 *)(& table->dev_mc_list[i].addr),(u8 const *)(& mc->addr));
    
#line 3787 
    i += 1;
    {
      
#line 3785 
      struct list_head const *__mptr_2 = (struct list_head const *)mc->list.next;
      
#line 3785 
      tmp_3 = (struct netdev_hw_addr *)__mptr_2;
    }
    
#line 3785 
    mc = tmp_3;
    ldv_57889: 
#line 3787 
    ;
    
#line 3785 
    if (& mc->list != & net_dev->mc.list) 
#line 3787 
                                          goto ldv_57888; else 
#line 3790 
                                                               goto ldv_57890;
    ldv_57890: 
#line 3791 
    ;
  }
  
#line 3790 
  netif_addr_unlock_bh_0(net_dev);
  
#line 3793 
  if (table->dev_uc_count >= 0) {
    
#line 3794 
    i = 0;
    
#line 3794 
    goto ldv_57896;
    ldv_57895: 
#line 3795 
    ;
    
#line 3795 
    efx_filter_init_rx(& spec,(enum efx_filter_priority)EFX_FILTER_PRI_AUTO,(enum efx_filter_flags)EFX_FILTER_FLAG_RX_RSS,0U);
    
#line 3798 
    efx_filter_set_eth_local(& spec,(unsigned short)65535,(u8 const *)(& table->dev_uc_list[i].addr));
    
#line 3800 
    rc = efx_ef10_filter_insert(efx,& spec,(_Bool)1);
    
#line 3801 
    if (rc < 0) {
      int tmp_4;
      
#line 3803 
      goto ldv_57892;
      ldv_57891: 
#line 3804 
      ;
      
#line 3804 
      efx_ef10_filter_remove_safe(efx,(enum efx_filter_priority)EFX_FILTER_PRI_AUTO,(unsigned int)table->dev_uc_list[i].id);
      ldv_57892: 
#line 3807 
      ;
      
#line 3803 
      tmp_4 = i;
      
#line 3803 
      i -= 1;
      
#line 3803 
      ;
      
#line 3803 
      if (tmp_4 != 0) 
#line 3805 
                      goto ldv_57891; else 
#line 3808 
                                           goto ldv_57893;
      ldv_57893: 
#line 3809 
      ;
      
#line 3807 
      table->dev_uc_count = -1;
      
#line 3808 
      goto ldv_57894;
    }
    else ;
    
#line 3810 
    table->dev_uc_list[i].id = (unsigned short)rc;
    
#line 3794 
    i += 1;
    ldv_57896: 
#line 3795 
    ;
    
#line 3794 
    if (table->dev_uc_count > i) 
#line 3796 
                                 goto ldv_57895; else 
#line 3799 
                                                      goto ldv_57894;
    ldv_57894: 
#line 3800 
    ;
  }
  else ;
  
#line 3813 
  if (table->dev_uc_count < 0) {
    
#line 3814 
    efx_filter_init_rx(& spec,(enum efx_filter_priority)EFX_FILTER_PRI_AUTO,(enum efx_filter_flags)EFX_FILTER_FLAG_RX_RSS,0U);
    
#line 3817 
    efx_filter_set_uc_def(& spec);
    
#line 3818 
    rc = efx_ef10_filter_insert(efx,& spec,(_Bool)1);
    
#line 3819 
    if (rc < 0) {
      {
        
#line 3820 
        int __ret_warn_on = 1;
        
#line 3820 
        if ((long)(__ret_warn_on != 0) != 0L) 
#line 3820 
                                              warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c",3820); else ;
        
#line 3820 
        long tmp_5 = (long)(__ret_warn_on != 0);
      }
      
#line 3821 
      table->dev_uc_count = 0;
    }
    else 
#line 3823 
         table->dev_uc_list[0].id = (unsigned short)rc;
  }
  else ;
  
#line 3828 
  if (table->dev_mc_count >= 0) {
    
#line 3829 
    i = 0;
    
#line 3829 
    goto ldv_57904;
    ldv_57903: 
#line 3830 
    ;
    
#line 3830 
    efx_filter_init_rx(& spec,(enum efx_filter_priority)EFX_FILTER_PRI_AUTO,(enum efx_filter_flags)EFX_FILTER_FLAG_RX_RSS,0U);
    
#line 3833 
    efx_filter_set_eth_local(& spec,(unsigned short)65535,(u8 const *)(& table->dev_mc_list[i].addr));
    
#line 3835 
    rc = efx_ef10_filter_insert(efx,& spec,(_Bool)1);
    
#line 3836 
    if (rc < 0) {
      int tmp_5_0;
      
#line 3838 
      goto ldv_57900;
      ldv_57899: 
#line 3839 
      ;
      
#line 3839 
      efx_ef10_filter_remove_safe(efx,(enum efx_filter_priority)EFX_FILTER_PRI_AUTO,(unsigned int)table->dev_mc_list[i].id);
      ldv_57900: 
#line 3842 
      ;
      
#line 3838 
      tmp_5_0 = i;
      
#line 3838 
      i -= 1;
      
#line 3838 
      ;
      
#line 3838 
      if (tmp_5_0 != 0) 
#line 3840 
                        goto ldv_57899; else 
#line 3843 
                                             goto ldv_57901;
      ldv_57901: 
#line 3844 
      ;
      
#line 3842 
      table->dev_mc_count = -1;
      
#line 3843 
      goto ldv_57902;
    }
    else ;
    
#line 3845 
    table->dev_mc_list[i].id = (unsigned short)rc;
    
#line 3829 
    i += 1;
    ldv_57904: 
#line 3830 
    ;
    
#line 3829 
    if (table->dev_mc_count > i) 
#line 3831 
                                 goto ldv_57903; else 
#line 3834 
                                                      goto ldv_57902;
    ldv_57902: 
#line 3835 
    ;
  }
  else ;
  
#line 3848 
  if (table->dev_mc_count < 0) {
    
#line 3849 
    efx_filter_init_rx(& spec,(enum efx_filter_priority)EFX_FILTER_PRI_AUTO,(enum efx_filter_flags)EFX_FILTER_FLAG_RX_RSS,0U);
    
#line 3852 
    efx_filter_set_mc_def(& spec);
    
#line 3853 
    rc = efx_ef10_filter_insert(efx,& spec,(_Bool)1);
    
#line 3854 
    if (rc < 0) {
      {
        
#line 3855 
        int __ret_warn_on_0 = 1;
        
#line 3855 
        if ((long)(__ret_warn_on_0 != 0) != 0L) 
#line 3855 
                                                warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c",3855); else ;
        
#line 3855 
        long tmp_7 = (long)(__ret_warn_on_0 != 0);
      }
      
#line 3856 
      table->dev_mc_count = 0;
    }
    else 
#line 3858 
         table->dev_mc_list[0].id = (unsigned short)rc;
  }
  else ;
  
#line 3867 
  i = 0;
  
#line 3867 
  goto ldv_57910;
  ldv_57909: 
#line 3868 
  ;
  {
    
#line 3868 
    unsigned long __var = 0UL;
    
#line 3868 
    tmp_7_0 = (unsigned long volatile *)(& (table->entry + i)->spec);
  }
  
#line 3868 
  ;
  
#line 3868 
  if ((*tmp_7_0 & 2UL) != 0UL) {
    int tmp_6;
    
#line 3870 
    tmp_6 = efx_ef10_filter_remove_internal(efx,2U,(unsigned int)i,(_Bool)1);
    
#line 3870 
    if (tmp_6 < 0) 
#line 3873 
                   remove_failed = (_Bool)1; else ;
  }
  else ;
  
#line 3867 
  i += 1;
  ldv_57910: 
#line 3868 
  ;
  
#line 3867 
  if (i <= 8191) 
#line 3869 
                 goto ldv_57909; else 
#line 3872 
                                      goto ldv_57911;
  ldv_57911: 
#line 3873 
  ;
  {
    
#line 3876 
    int __ret_warn_on_1 = (int)remove_failed != 0;
    
#line 3876 
    if ((long)(__ret_warn_on_1 != 0) != 0L) 
#line 3876 
                                            warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c",3876); else ;
    
#line 3876 
    long tmp_9 = (long)(__ret_warn_on_1 != 0);
  }
  return_label: 
#line 3878 
                return;
}


#line 3879  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_vport_set_mac_address(struct efx_nic *efx)
{
  int __retres;
  u8 mac_old[6U];
  int rc;
  int rc2;
  bool tmp;
  int tmp_0;
  
#line 3881 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 3886 
  tmp = is_zero_ether_addr((u8 const *)(& nic_data->vport_mac));
  
#line 3886 
  if ((int)tmp != 0) {
    
#line 3887 
    __retres = 0;
    
#line 3887 
    goto return_label;
  }
  else ;
  
#line 3889 
  efx_device_detach_sync_1(efx);
  
#line 3890 
  efx_net_stop(efx->net_dev);
  
#line 3891 
  down_write(& efx->filter_sem);
  
#line 3892 
  efx_ef10_filter_table_remove(efx);
  
#line 3893 
  up_write(& efx->filter_sem);
  
#line 3895 
  rc = efx_ef10_vadaptor_free(efx,nic_data->vport_id);
  
#line 3896 
  if (rc != 0) 
#line 3897 
               goto restore_filters; else ;
  
#line 3899 
  ether_addr_copy((u8 *)(& mac_old),(u8 const *)(& nic_data->vport_mac));
  
#line 3900 
  rc = efx_ef10_vport_del_mac(efx,nic_data->vport_id,(u8 *)(& nic_data->vport_mac));
  
#line 3902 
  if (rc != 0) 
#line 3903 
               goto restore_vadaptor; else ;
  
#line 3905 
  rc = efx_ef10_vport_add_mac(efx,nic_data->vport_id,(efx->net_dev)->dev_addr);
  
#line 3907 
  if (rc == 0) 
#line 3908 
               ether_addr_copy((u8 *)(& nic_data->vport_mac),(u8 const *)(efx->net_dev)->dev_addr);
  else {
    
#line 3910 
    rc2 = efx_ef10_vport_add_mac(efx,nic_data->vport_id,(u8 *)(& mac_old));
    
#line 3911 
    if (rc2 != 0) {
      
#line 3913 
      eth_zero_addr((u8 *)(& nic_data->vport_mac));
      
#line 3914 
      goto reset_nic;
    }
    else ;
  }
  restore_vadaptor: 
#line 3918 
  ;
  
#line 3919 
  rc2 = efx_ef10_vadaptor_alloc(efx,nic_data->vport_id);
  
#line 3920 
  if (rc2 != 0) 
#line 3921 
                goto reset_nic; else ;
  restore_filters: 
#line 3922 
  ;
  
#line 3923 
  down_write(& efx->filter_sem);
  
#line 3924 
  rc2 = efx_ef10_filter_table_probe(efx);
  
#line 3925 
  up_write(& efx->filter_sem);
  
#line 3926 
  if (rc2 != 0) 
#line 3927 
                goto reset_nic; else ;
  
#line 3929 
  rc2 = efx_net_open(efx->net_dev);
  
#line 3930 
  if (rc2 != 0) 
#line 3931 
                goto reset_nic; else ;
  
#line 3933 
  netif_device_attach(efx->net_dev);
  
#line 3935 
  __retres = rc;
  
#line 3935 
  goto return_label;
  reset_nic: 
#line 3937 
  ;
  
#line 3938 
  if ((efx->msg_enable & 1U) != 0U) 
#line 3938 
                                    netdev_err((struct net_device const *)efx->net_dev,"Failed to restore when changing MAC address - scheduling reset\n"); else ;
  
#line 3940 
  efx_schedule_reset(efx,(enum reset_type)RESET_TYPE_DATAPATH);
  
#line 3942 
  if (rc != 0) 
#line 3942 
               tmp_0 = rc; else 
#line 3942 
                                tmp_0 = rc2;
  
#line 3942 
  __retres = tmp_0;
  return_label: 
#line 3942 
                return __retres;
}


#line 3945  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_set_mac_address(struct efx_nic *efx)
{
  int __retres;
  int rc;
  
#line 3947 
  efx_dword_t inbuf[3U] = {{.u32 = {0U}}};
  
#line 3948 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 3949 
  bool was_enabled = efx->port_enabled;
  
#line 3952 
  efx_device_detach_sync_1(efx);
  
#line 3953 
  efx_net_stop(efx->net_dev);
  
#line 3954 
  down_write(& efx->filter_sem);
  
#line 3955 
  efx_ef10_filter_table_remove(efx);
  
#line 3957 
  ether_addr_copy((u8 *)(& inbuf) + 4U,(u8 const *)(efx->net_dev)->dev_addr);
  
#line 3959 
  ((efx_dword_t *)(& inbuf))->u32[0] = nic_data->vport_id;
  
#line 3961 
  rc = efx_mcdi_rpc_quiet(efx,93U,(efx_dword_t const *)(& inbuf),12UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 3964 
  efx_ef10_filter_table_probe(efx);
  
#line 3965 
  up_write(& efx->filter_sem);
  
#line 3966 
  if ((int)was_enabled != 0) 
#line 3967 
                             efx_net_open(efx->net_dev); else ;
  
#line 3968 
  netif_device_attach(efx->net_dev);
  
#line 3971 
  if ((unsigned int)*((unsigned char *)efx->pci_dev + 2531UL) != 0U && (efx->pci_dev)->__anonCompField_pci_dev_64.physfn != (struct pci_dev *)0) {
    
#line 3972 
    struct pci_dev *pci_dev_pf = (efx->pci_dev)->__anonCompField_pci_dev_64.physfn;
    
#line 3974 
    if (rc == -1) {
      struct efx_nic *efx_pf;
      
#line 3978 
      efx_pf = (struct efx_nic *)pci_get_drvdata(pci_dev_pf);
      
#line 3980 
      rc = efx_ef10_sriov_set_vf_mac(efx_pf,(int)nic_data->vf_index,(efx->net_dev)->dev_addr);
    }
    else 
      
#line 3983 
      if (rc == 0) {
        unsigned int i;
        
#line 3984 
        struct efx_nic *efx_pf_0 = pci_get_drvdata(pci_dev_pf);
        
#line 3985 
        struct efx_ef10_nic_data *nic_data_0 = (struct efx_ef10_nic_data *)efx_pf_0->nic_data;
        
#line 3991 
        i = 0U;
        
#line 3991 
        goto ldv_57941;
        ldv_57940: 
#line 3992 
        ;
        {
          
#line 3992 
          struct ef10_vf *vf = nic_data_0->vf + i;
          
#line 3994 
          if (vf->efx == efx) {
            
#line 3995 
            ether_addr_copy((u8 *)(& vf->mac),(u8 const *)(efx->net_dev)->dev_addr);
            
#line 3997 
            __retres = 0;
            
#line 3997 
            goto return_label;
          }
          else ;
        }
        
#line 3991 
        i += 1U;
        ldv_57941: 
#line 3992 
        ;
        
#line 3991 
        if (efx_pf_0->vf_count > i) 
#line 3993 
                                    goto ldv_57940; else 
#line 3996 
                                                         goto ldv_57942;
        ldv_57942: 
#line 3997 
        ;
      }
      else ;
  }
  else 
    
#line 4003 
    if (rc == -1) {
      
#line 4004 
      if ((efx->msg_enable & 1U) != 0U) 
#line 4004 
                                        netdev_err((struct net_device const *)efx->net_dev,"Cannot change MAC address; use sfboot to enable"); else ;
    }
    else 
      
#line 4007 
      if (rc == -38) {
        int tmp_2;
        bool tmp_1;
        
#line 4007 
        tmp_1 = efx_ef10_is_vf(efx);
        
#line 4007 
        if (tmp_1) 
#line 4007 
                   tmp_2 = 0; else 
#line 4007 
                                   tmp_2 = 1;
        
#line 4007 
        if (tmp_2) 
#line 4013 
                   rc = efx_ef10_vport_set_mac_address(efx); else 
#line 4015 
                                                                  efx_mcdi_display_error(efx,93U,12UL,(efx_dword_t *)0,0UL,rc);
      }
      else 
#line 4015 
           efx_mcdi_display_error(efx,93U,12UL,(efx_dword_t *)0,0UL,rc);
  
#line 4019 
  __retres = rc;
  return_label: 
#line 4019 
                return __retres;
}


#line 4022  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_mac_reconfigure(struct efx_nic *efx)
{
  int tmp;
  
#line 4024 
  efx_ef10_filter_sync_rx_mode(efx);
  
#line 4026 
  tmp = efx_mcdi_set_mac(efx);
  
#line 4026 
  return tmp;
}


#line 4029  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_mac_reconfigure_vf(struct efx_nic *efx)
{
  int __retres;
  
#line 4031 
  efx_ef10_filter_sync_rx_mode(efx);
  
#line 4033 
  __retres = 0;
  
#line 4033 
  return __retres;
}


#line 4036  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_start_bist(struct efx_nic *efx, u32 bist_type)
{
  int tmp;
  
#line 4038 
  efx_dword_t inbuf[1U] = {{.u32 = {0U}}};
  
#line 4040 
  ((efx_dword_t *)(& inbuf))->u32[0] = bist_type;
  
#line 4041 
  tmp = efx_mcdi_rpc(efx,37U,(efx_dword_t const *)(& inbuf),4UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 4041 
  return tmp;
}


#line 4049  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_poll_bist(struct efx_nic *efx)
{
  int __retres;
  int rc;
  size_t outlen;
  u32 result;
  
#line 4052 
  efx_dword_t outbuf[2U] = {{.u32 = {0U}}};
  
#line 4056 
  rc = efx_mcdi_rpc(efx,38U,(efx_dword_t const *)0,0UL,(efx_dword_t *)(& outbuf),8UL,& outlen);
  
#line 4058 
  if (rc != 0) {
    
#line 4059 
    __retres = rc;
    
#line 4059 
    goto return_label;
  }
  else ;
  
#line 4061 
  if (outlen <= 7UL) {
    
#line 4062 
    __retres = -5;
    
#line 4062 
    goto return_label;
  }
  else ;
  
#line 4064 
  result = ((efx_dword_t *)(& outbuf))->u32[0];
  
#line 4065 
  switch (result) {
    case (u32)2: 
#line 4066 
    ;
    
#line 4067 
    if ((efx->msg_enable & 8192U) != 0U) {
      
#line 4067 
      struct _ddebug descriptor = {.modname = "sfc", .function = "efx_ef10_poll_bist", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c", .format = "BIST passed.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))4067U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 4067 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 4067 
                                                          __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"BIST passed.\n"); else ;
    }
    else ;
    
#line 4068 
    __retres = 0;
    
#line 4068 
    goto return_label;
    case (u32)4: 
#line 4069 
    ;
    
#line 4070 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 4070 
                                         netdev_err((struct net_device const *)efx->net_dev,"BIST timed out\n"); else ;
    
#line 4071 
    __retres = -5;
    
#line 4071 
    goto return_label;
    case (u32)3: 
#line 4072 
    ;
    
#line 4073 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 4073 
                                         netdev_err((struct net_device const *)efx->net_dev,"BIST failed.\n"); else ;
    
#line 4074 
    __retres = -5;
    
#line 4074 
    goto return_label;
    default: 
#line 4075 
    ;
    
#line 4076 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 4076 
                                         netdev_err((struct net_device const *)efx->net_dev,"BIST returned unknown result %u",result); else ;
    
#line 4078 
    __retres = -5;
    
#line 4078 
    goto return_label;
  }
  return_label: 
#line 4065 
                return __retres;
}


#line 4082  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_run_bist(struct efx_nic *efx, u32 bist_type)
{
  int __retres;
  int rc;
  int tmp;
  
#line 4086 
  if ((efx->msg_enable & 1U) != 0U) {
    
#line 4086 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_ef10_run_bist", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c", .format = "starting BIST type %u\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))4086U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 4086 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 4086 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"starting BIST type %u\n",bist_type); else ;
  }
  else ;
  
#line 4088 
  rc = efx_ef10_start_bist(efx,bist_type);
  
#line 4089 
  if (rc != 0) {
    
#line 4090 
    __retres = rc;
    
#line 4090 
    goto return_label;
  }
  else ;
  
#line 4092 
  tmp = efx_ef10_poll_bist(efx);
  
#line 4092 
  __retres = tmp;
  return_label: 
#line 4092 
                return __retres;
}


#line 4096  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_test_chip(struct efx_nic *efx, struct efx_self_tests *tests)
{
  int rc;
  int rc2;
  int tmp;
  int tmp_0;
  int tmp_1;
  
#line 4100 
  efx_reset_down(efx,(enum reset_type)RESET_TYPE_WORLD);
  
#line 4102 
  rc = efx_mcdi_rpc(efx,237U,(efx_dword_t const *)0,0UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 4104 
  if (rc != 0) 
#line 4105 
               goto out; else ;
  
#line 4107 
  tmp = efx_ef10_run_bist(efx,6U);
  
#line 4107 
  if (tmp != 0) 
#line 4107 
                tests->memory = -1; else 
#line 4107 
                                         tests->memory = 1;
  
#line 4108 
  tmp_0 = efx_ef10_run_bist(efx,8U);
  
#line 4108 
  if (tmp_0 != 0) 
#line 4108 
                  tests->registers = -1; else 
#line 4108 
                                              tests->registers = 1;
  
#line 4110 
  rc = efx_mcdi_reset(efx,(enum reset_type)RESET_TYPE_WORLD);
  out: 
#line 4112 
  ;
  
#line 4113 
  rc2 = efx_reset_up(efx,(enum reset_type)RESET_TYPE_WORLD,(_Bool)(rc == 0));
  
#line 4114 
  if (rc != 0) 
#line 4114 
               tmp_1 = rc; else 
#line 4114 
                                tmp_1 = rc2;
  
#line 4114 
  return tmp_1;
}


#line 4125  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static struct efx_ef10_nvram_type_info const efx_ef10_nvram_types[11U] = {{.type = (unsigned short)256U, .type_mask = (unsigned short)0U, .port = (unsigned char)0U, .name = "sfc_mcfw"}, {.type = (unsigned short)512U, .type_mask = (unsigned short)0U, .port = (unsigned char)0U, .name = "sfc_mcfw_backup"}, {.type = (unsigned short)768U, .type_mask = (unsigned short)0U, .port = (unsigned char)0U, .name = "sfc_exp_rom"}, {.type = (unsigned short)1024U, .type_mask = (unsigned short)0U, .port = (unsigned char)0U, .name = "sfc_static_cfg"}, {.type = (unsigned short)1280U, .type_mask = (unsigned short)0U, .port = (unsigned char)0U, .name = "sfc_dynamic_cfg"}, {.type = (unsigned short)1536U, .type_mask = (unsigned short)0U, .port = (unsigned char)0U, .name = "sfc_exp_rom_cfg"}, {.type = (unsigned short)1537U, .type_mask = (unsigned short)0U, .port = (unsigned char)1U, .name = "sfc_exp_rom_cfg"}, {.type = (unsigned short)1538U, .type_mask = (unsigned short)0U, .port = (unsigned char)2U, .name = "sfc_exp_rom_cfg"}, {.type = (unsigned short)1539U, .type_mask = (unsigned short)0U, .port = (unsigned char)3U, .name = "sfc_exp_rom_cfg"}, {.type = (unsigned short)2304U, .type_mask = (unsigned short)0U, .port = (unsigned char)0U, .name = "sfc_license"}, {.type = (unsigned short)2560U, .type_mask = (unsigned short)255U, .port = (unsigned char)0U, .name = "sfc_phy_fw"}};

#line 4139  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_mtd_probe_partition(struct efx_nic *efx, struct efx_mcdi_mtd_partition *part, unsigned int type)
{
  int __retres;
  struct efx_ef10_nvram_type_info const *info;
  size_t size;
  size_t erase_size;
  size_t outlen;
  bool protected;
  int rc;
  unsigned int tmp;
  
#line 4143 
  efx_dword_t inbuf[1U] = {{.u32 = {0U}}};
  
#line 4144 
  efx_dword_t outbuf[63U] = {{.u32 = {0U}}};
  
#line 4150 
  info = (struct efx_ef10_nvram_type_info const *)(& efx_ef10_nvram_types);
  ldv_58013: 
#line 4151 
  ;
  
#line 4151 
  if (info == (struct efx_ef10_nvram_type_info const *)(& efx_ef10_nvram_types) + 11U) {
    
#line 4153 
    __retres = -19;
    
#line 4153 
    goto return_label;
  }
  else ;
  
#line 4154 
  if (((unsigned int)(~ ((int)info->type_mask)) & type) == (unsigned int)info->type) 
    
#line 4155 
    goto ldv_58012; else ;
  
#line 4150 
  info += 1;
  
#line 4150 
  goto ldv_58013;
  ldv_58012: 
#line 4151 
  ;
  
#line 4157 
  tmp = efx_port_num(efx);
  
#line 4157 
  ;
  
#line 4157 
  if ((unsigned int)info->port != tmp) {
    
#line 4158 
    __retres = -19;
    
#line 4158 
    goto return_label;
  }
  else ;
  
#line 4160 
  rc = efx_mcdi_nvram_info(efx,type,& size,& erase_size,& protected);
  
#line 4161 
  if (rc != 0) {
    
#line 4162 
    __retres = rc;
    
#line 4162 
    goto return_label;
  }
  else ;
  
#line 4163 
  if ((int)protected != 0) {
    
#line 4164 
    __retres = -19;
    
#line 4164 
    goto return_label;
  }
  else ;
  
#line 4166 
  part->nvram_type = (unsigned short)type;
  
#line 4168 
  ((efx_dword_t *)(& inbuf))->u32[0] = type;
  
#line 4169 
  rc = efx_mcdi_rpc(efx,82U,(efx_dword_t const *)(& inbuf),4UL,(efx_dword_t *)(& outbuf),252UL,& outlen);
  
#line 4171 
  if (rc != 0) {
    
#line 4172 
    __retres = rc;
    
#line 4172 
    goto return_label;
  }
  else ;
  
#line 4173 
  if (outlen <= 19UL) {
    
#line 4174 
    __retres = -5;
    
#line 4174 
    goto return_label;
  }
  else ;
  
#line 4175 
  if ((((efx_dword_t *)(& outbuf) + 1U)->u32[0] & 1U) != 0U) 
#line 4177 
                                                             part->fw_subtype = (unsigned short)((efx_dword_t *)(& outbuf) + 2U)->u32[0]; else ;
  
#line 4180 
  part->common.dev_type_name = "EF10 NVRAM manager";
  
#line 4181 
  part->common.type_name = info->name;
  
#line 4183 
  part->common.mtd.type = (unsigned char)3U;
  
#line 4184 
  part->common.mtd.flags = 3072U;
  
#line 4185 
  part->common.mtd.size = (unsigned long long)size;
  
#line 4186 
  part->common.mtd.erasesize = (unsigned int)erase_size;
  
#line 4188 
  __retres = 0;
  return_label: 
#line 4188 
                return __retres;
}


#line 4201 
void __compiletime_assert_4201(void);


#line 4191  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_mtd_probe(struct efx_nic *efx)
{
  int __retres;
  struct efx_mcdi_mtd_partition *parts;
  size_t outlen;
  size_t n_parts_total;
  size_t i;
  size_t n_parts;
  unsigned int type;
  int rc;
  int tmp;
  size_t tmp_1;
  
#line 4193 
  efx_dword_t outbuf[63U] = {{.u32 = {0U}}};
  
#line 4199 
  tmp = rtnl_is_locked();
  
#line 4199 
  if ((long)(tmp == 0) != 0L) {
    
#line 4199 
    printk("\001",(char *)"/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c",4199);
    
#line 4199 
    dump_stack();
  }
  else ;
  {
    
#line 4201 
    bool __cond = (_Bool)0;
    
#line 4201 
    if ((int)__cond != 0) 
#line 4201 
                          __compiletime_assert_4201(); else ;
  }
  
#line 4202 
  rc = efx_mcdi_rpc(efx,81U,(efx_dword_t const *)0,0UL,(efx_dword_t *)(& outbuf),252UL,& outlen);
  
#line 4204 
  if (rc != 0) {
    
#line 4205 
    __retres = rc;
    
#line 4205 
    goto return_label;
  }
  else ;
  
#line 4206 
  if (outlen <= 3UL) {
    
#line 4207 
    __retres = -5;
    
#line 4207 
    goto return_label;
  }
  else ;
  
#line 4209 
  n_parts_total = (unsigned long)((efx_dword_t *)(& outbuf))->u32[0];
  {
    size_t tmp_0;
    
#line 4211 
    size_t __min1 = 62UL;
    
#line 4211 
    size_t __min2 = (outlen + 18446744073709551612UL) / 4UL;
    
#line 4211 
    if (__min1 < __min2) 
#line 4211 
                         tmp_0 = __min1; else 
#line 4211 
                                              tmp_0 = __min2;
    
#line 4211 
    tmp_1 = tmp_0;
  }
  
#line 4210 
  ;
  
#line 4210 
  if (tmp_1 < n_parts_total) {
    
#line 4212 
    __retres = -5;
    
#line 4212 
    goto return_label;
  }
  else ;
  
#line 4214 
  parts = (struct efx_mcdi_mtd_partition *)kcalloc_6(n_parts_total,1904UL,208U);
  
#line 4215 
  if (parts == (struct efx_mcdi_mtd_partition *)0) {
    
#line 4216 
    __retres = -12;
    
#line 4216 
    goto return_label;
  }
  else ;
  
#line 4218 
  n_parts = 0UL;
  
#line 4219 
  i = 0UL;
  
#line 4219 
  goto ldv_58073;
  ldv_58072: 
#line 4220 
  ;
  
#line 4220 
  type = ((efx_dword_t *)(& outbuf) + (i + (size_t)1U) * (size_t)4U)->u32[0];
  
#line 4222 
  rc = efx_ef10_mtd_probe_partition(efx,parts + n_parts,type);
  
#line 4223 
  if (rc == 0) 
#line 4224 
               n_parts += 1UL;
  else 
    
#line 4225 
    if (rc != -19) 
#line 4226 
                   goto fail; else ;
  
#line 4219 
  i += 1UL;
  ldv_58073: 
#line 4220 
  ;
  
#line 4219 
  if (i < n_parts_total) 
#line 4221 
                         goto ldv_58072; else 
#line 4224 
                                              goto ldv_58074;
  ldv_58074: 
#line 4225 
  ;
  
#line 4229 
  rc = efx_mtd_add(efx,& parts->common,n_parts,1904UL);
  fail: 
#line 4230 
  ;
  
#line 4231 
  if (rc != 0) 
#line 4232 
               kfree((void const *)parts); else ;
  
#line 4233 
  __retres = rc;
  return_label: 
#line 4233 
                return __retres;
}


#line 4238  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_ptp_write_host_time(struct efx_nic *efx, u32 host_time)
{
  
#line 4240 
  _efx_writed(efx,host_time,512U);
  
#line 4241 
  return;
}


#line 4243  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static void efx_ef10_ptp_write_host_time_vf(struct efx_nic *efx, u32 host_time)
{
  
#line 4245 
  return;
}


#line 4246  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_rx_enable_timestamping(struct efx_channel *channel, bool temp)
{
  int __retres;
  int rc;
  
#line 4249 
  efx_dword_t inbuf[3U] = {{.u32 = {0U}}};
  
#line 4252 
  if ((unsigned int)channel->sync_events_state + 4294967294U <= 1U || ((int)temp != 0 && channel->sync_events_state == (unsigned int)SYNC_EVENTS_DISABLED)) {
    
#line 4255 
    __retres = 0;
    
#line 4255 
    goto return_label;
  }
  else ;
  
#line 4256 
  channel->sync_events_state = SYNC_EVENTS_REQUESTED;
  
#line 4258 
  ((efx_dword_t *)(& inbuf))->u32[0] = 24U;
  
#line 4259 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = 0U;
  
#line 4260 
  ((efx_dword_t *)(& inbuf) + 2U)->u32[0] = (unsigned int)channel->channel;
  
#line 4263 
  rc = efx_mcdi_rpc(channel->efx,11U,(efx_dword_t const *)(& inbuf),12UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 4266 
  if (rc != 0) 
#line 4267 
               channel->sync_events_state = (enum efx_sync_events_state)((int)temp != 0); else ;
  
#line 4270 
  __retres = rc;
  return_label: 
#line 4270 
                return __retres;
}


#line 4273  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_rx_disable_timestamping(struct efx_channel *channel, bool temp)
{
  int __retres;
  int rc;
  
#line 4276 
  efx_dword_t inbuf[4U] = {{.u32 = {0U}}};
  
#line 4279 
  if (channel->sync_events_state == (unsigned int)SYNC_EVENTS_DISABLED || ((int)temp != 0 && channel->sync_events_state == (unsigned int)SYNC_EVENTS_QUIESCENT)) {
    
#line 4281 
    __retres = 0;
    
#line 4281 
    goto return_label;
  }
  else ;
  
#line 4282 
  if (channel->sync_events_state == (unsigned int)SYNC_EVENTS_QUIESCENT) {
    
#line 4283 
    channel->sync_events_state = SYNC_EVENTS_DISABLED;
    
#line 4284 
    __retres = 0;
    
#line 4284 
    goto return_label;
  }
  else ;
  
#line 4286 
  channel->sync_events_state = (enum efx_sync_events_state)((int)temp != 0);
  
#line 4289 
  ((efx_dword_t *)(& inbuf))->u32[0] = 25U;
  
#line 4290 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = 0U;
  
#line 4291 
  ((efx_dword_t *)(& inbuf) + 2U)->u32[0] = 0U;
  
#line 4293 
  ((efx_dword_t *)(& inbuf) + 3U)->u32[0] = (unsigned int)channel->channel;
  
#line 4296 
  rc = efx_mcdi_rpc(channel->efx,11U,(efx_dword_t const *)(& inbuf),16UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 4299 
  __retres = rc;
  return_label: 
#line 4299 
                return __retres;
}


#line 4302  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_ptp_set_ts_sync_events(struct efx_nic *efx, bool en, bool temp)
{
  int __retres;
  int (*set)(struct efx_channel *, bool );
  struct efx_channel *channel;
  
#line 4308 
  if ((int)en != 0) 
#line 4308 
                    set = & efx_ef10_rx_enable_timestamping; else 
#line 4308 
                                                                  set = & efx_ef10_rx_disable_timestamping;
  
#line 4312 
  channel = efx->channel[0];
  
#line 4312 
  goto ldv_58127;
  ldv_58126: 
#line 4313 
  ;
  {
    int tmp;
    
#line 4313 
    tmp = (*set)(channel,(_Bool)((bool)((int)temp) != 0));
    
#line 4313 
    int rc = tmp;
    
#line 4314 
    if ((int)en != 0 && rc != 0) {
      
#line 4315 
      efx_ef10_ptp_set_ts_sync_events(efx,(_Bool)0,(_Bool)((bool)((int)temp) != 0));
      
#line 4316 
      __retres = rc;
      
#line 4316 
      goto return_label;
    }
    else ;
  }
  
#line 4312 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 4312 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 4312 
                                                                    channel = (struct efx_channel *)0;
  ldv_58127: 
#line 4313 
  ;
  
#line 4312 
  if (channel != (struct efx_channel *)0) 
#line 4314 
                                          goto ldv_58126; else 
#line 4317 
                                                               goto ldv_58128;
  ldv_58128: 
#line 4318 
  ;
  
#line 4320 
  __retres = 0;
  return_label: 
#line 4320 
                return __retres;
}


#line 4323  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_ptp_set_ts_config_vf(struct efx_nic *efx, struct hwtstamp_config *init)
{
  int __retres;
  
#line 4326 
  __retres = -95;
  
#line 4326 
  return __retres;
}


#line 4329  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
static int efx_ef10_ptp_set_ts_config(struct efx_nic *efx, struct hwtstamp_config *init)
{
  int __retres;
  int rc;
  
#line 4334 
  switch (init->rx_filter) {
    int tmp;
    case 0: 
#line 4335 
    ;
    
#line 4336 
    efx_ef10_ptp_set_ts_sync_events(efx,(_Bool)0,(_Bool)0);
    
#line 4338 
    tmp = efx_ptp_change_mode(efx,(_Bool)(init->tx_type != 0),0U);
    
#line 4338 
    __retres = tmp;
    
#line 4338 
    goto return_label;
    case 1: 
#line 4340 
    ;
    case 3: 
#line 4341 
    ;
    case 4: 
#line 4342 
    ;
    case 5: 
#line 4343 
    ;
    case 6: 
#line 4344 
    ;
    case 7: 
#line 4345 
    ;
    case 8: 
#line 4346 
    ;
    case 9: 
#line 4347 
    ;
    case 10: 
#line 4348 
    ;
    case 11: 
#line 4349 
    ;
    case 12: 
#line 4350 
    ;
    case 13: 
#line 4351 
    ;
    case 14: 
#line 4352 
    ;
    
#line 4353 
    init->rx_filter = 1;
    
#line 4354 
    rc = efx_ptp_change_mode(efx,(_Bool)1,0U);
    
#line 4355 
    if (rc == 0) 
#line 4356 
                 rc = efx_ef10_ptp_set_ts_sync_events(efx,(_Bool)1,(_Bool)0); else ;
    
#line 4357 
    if (rc != 0) 
#line 4358 
                 efx_ptp_change_mode(efx,(_Bool)0,0U); else ;
    
#line 4359 
    __retres = rc;
    
#line 4359 
    goto return_label;
    default: 
#line 4360 
    ;
    
#line 4361 
    __retres = -34;
    
#line 4361 
    goto return_label;
  }
  return_label: 
#line 4334 
                return __retres;
}


#line 4365  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
struct efx_nic_type const efx_hunt_a0_vf_nic_type = {.is_vf = (_Bool)1, .mem_bar = 0U, .mem_map_size = & efx_ef10_mem_map_size, .probe = & efx_ef10_probe_vf, .remove = & efx_ef10_remove, .init = & efx_ef10_init_nic, .dimension_resources = & efx_ef10_dimension_resources, .fini = & efx_port_dummy_op_void, .monitor = (void (*)(struct efx_nic *))0, .map_reset_reason = & efx_ef10_map_reset_reason, .map_reset_flags = & efx_ef10_map_reset_flags, .reset = & efx_ef10_reset, .probe_port = & efx_mcdi_port_probe, .remove_port = & efx_mcdi_port_remove, .handle_global_event = (bool (*)(struct efx_channel *, efx_qword_t *))0, .fini_dmaq = & efx_ef10_fini_dmaq, .prepare_flush = (void (*)(struct efx_nic *))0, .finish_flush = (void (*)(struct efx_nic *))0, .prepare_flr = & efx_ef10_prepare_flr, .finish_flr = & efx_port_dummy_op_void, .describe_stats = & efx_ef10_describe_stats, .update_stats = & efx_ef10_update_stats_vf, .start_stats = & efx_port_dummy_op_void, .pull_stats = & efx_port_dummy_op_void, .stop_stats = & efx_port_dummy_op_void, .set_id_led = & efx_mcdi_set_id_led, .push_irq_moderation = & efx_ef10_push_irq_moderation, .reconfigure_port = & efx_mcdi_port_reconfigure, .prepare_enable_fc_tx = (void (*)(struct efx_nic *))0, .reconfigure_mac = & efx_ef10_mac_reconfigure_vf, .check_mac_fault = & efx_mcdi_mac_check_fault, .get_wol = & efx_ef10_get_wol_vf, .set_wol = & efx_ef10_set_wol_vf, .resume_wol = & efx_port_dummy_op_void, .test_chip = (int (*)(struct efx_nic *, struct efx_self_tests *))0, .test_nvram = (int (*)(struct efx_nic *))0, .mcdi_request = & efx_ef10_mcdi_request, .mcdi_poll_response = & efx_ef10_mcdi_poll_response, .mcdi_read_response = & efx_ef10_mcdi_read_response, .mcdi_poll_reboot = & efx_ef10_mcdi_poll_reboot, .irq_enable_master = & efx_port_dummy_op_void, .irq_test_generate = & efx_ef10_irq_test_generate, .irq_disable_non_ev = & efx_port_dummy_op_void, .irq_handle_msi = & efx_ef10_msi_interrupt, .irq_handle_legacy = & efx_ef10_legacy_interrupt, .tx_probe = & efx_ef10_tx_probe, .tx_init = & efx_ef10_tx_init, .tx_remove = & efx_ef10_tx_remove, .tx_write = & efx_ef10_tx_write, .rx_push_rss_config = & efx_ef10_vf_rx_push_rss_config, .rx_probe = & efx_ef10_rx_probe, .rx_init = & efx_ef10_rx_init, .rx_remove = & efx_ef10_rx_remove, .rx_write = & efx_ef10_rx_write, .rx_defer_refill = & efx_ef10_rx_defer_refill, .ev_probe = & efx_ef10_ev_probe, .ev_init = & efx_ef10_ev_init, .ev_fini = & efx_ef10_ev_fini, .ev_remove = & efx_ef10_ev_remove, .ev_process = & efx_ef10_ev_process, .ev_read_ack = & efx_ef10_ev_read_ack, .ev_test_generate = & efx_ef10_ev_test_generate, .filter_table_probe = & efx_ef10_filter_table_probe, .filter_table_restore = & efx_ef10_filter_table_restore, .filter_table_remove = & efx_ef10_filter_table_remove, .filter_update_rx_scatter = & efx_ef10_filter_update_rx_scatter, .filter_insert = & efx_ef10_filter_insert, .filter_remove_safe = & efx_ef10_filter_remove_safe, .filter_get_safe = & efx_ef10_filter_get_safe, .filter_clear_rx = & efx_ef10_filter_clear_rx, .filter_count_rx_used = & efx_ef10_filter_count_rx_used, .filter_get_rx_id_limit = & efx_ef10_filter_get_rx_id_limit, .filter_get_rx_ids = & efx_ef10_filter_get_rx_ids, .filter_rfs_insert = & efx_ef10_filter_rfs_insert, .filter_rfs_expire_one = & efx_ef10_filter_rfs_expire_one, .mtd_probe = & efx_port_dummy_op_int, .mtd_rename = (void (*)(struct efx_mtd_partition *))0, .mtd_read = (int (*)(struct mtd_info *, loff_t , size_t , size_t *, u8 *))0, .mtd_erase = (int (*)(struct mtd_info *, loff_t , size_t ))0, .mtd_write = (int (*)(struct mtd_info *, loff_t , size_t , size_t *, u8 const *))0, .mtd_sync = (int (*)(struct mtd_info *))0, .ptp_write_host_time = & efx_ef10_ptp_write_host_time_vf, .ptp_set_ts_sync_events = (int (*)(struct efx_nic *, bool , bool ))0, .ptp_set_ts_config = & efx_ef10_ptp_set_ts_config_vf, .sriov_configure = (int (*)(struct efx_nic *, int ))0, .sriov_init = (int (*)(struct efx_nic *))0, .sriov_fini = (void (*)(struct efx_nic *))0, .sriov_wanted = (bool (*)(struct efx_nic *))0, .sriov_reset = (void (*)(struct efx_nic *))0, .sriov_flr = (void (*)(struct efx_nic *, unsigned int ))0, .sriov_set_vf_mac = (int (*)(struct efx_nic *, int , u8 *))0, .sriov_set_vf_vlan = (int (*)(struct efx_nic *, int , u16 , u8 ))0, .sriov_set_vf_spoofchk = (int (*)(struct efx_nic *, int , bool ))0, .sriov_get_vf_config = (int (*)(struct efx_nic *, int , struct ifla_vf_info *))0, .sriov_set_vf_link_state = (int (*)(struct efx_nic *, int , int ))0, .sriov_get_phys_port_id = & efx_ef10_sriov_get_phys_port_id, .vswitching_probe = & efx_ef10_vswitching_probe_vf, .vswitching_restore = & efx_ef10_vswitching_restore_vf, .vswitching_remove = & efx_ef10_vswitching_remove_vf, .get_mac_address = & efx_ef10_get_mac_address_vf, .set_mac_address = & efx_ef10_set_mac_address, .revision = 4, .txd_ptr_tbl_base = 0U, .rxd_ptr_tbl_base = 0U, .buf_tbl_base = 0U, .evq_ptr_tbl_base = 0U, .evq_rptr_tbl_base = 0U, .max_dma_mask = 281474976710655ULL, .rx_prefix_size = 14U, .rx_hash_offset = 0U, .rx_ts_offset = 10U, .rx_buffer_padding = 0U, .can_rx_scatter = (_Bool)1, .always_rx_scatter = (_Bool)1, .max_interrupt_mode = 0U, .timer_period_max = 256U, .offload_features = 12884901906ULL, .mcdi_max_ver = 2, .max_rx_ip_filters = 8192U, .hwtstamp_filters = 3U};

#line 4467  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ef10.c"
struct efx_nic_type const efx_hunt_a0_nic_type = {.is_vf = (_Bool)0, .mem_bar = 2U, .mem_map_size = & efx_ef10_mem_map_size, .probe = & efx_ef10_probe_pf, .remove = & efx_ef10_remove, .init = & efx_ef10_init_nic, .dimension_resources = & efx_ef10_dimension_resources, .fini = & efx_port_dummy_op_void, .monitor = (void (*)(struct efx_nic *))0, .map_reset_reason = & efx_ef10_map_reset_reason, .map_reset_flags = & efx_ef10_map_reset_flags, .reset = & efx_ef10_reset, .probe_port = & efx_mcdi_port_probe, .remove_port = & efx_mcdi_port_remove, .handle_global_event = (bool (*)(struct efx_channel *, efx_qword_t *))0, .fini_dmaq = & efx_ef10_fini_dmaq, .prepare_flush = (void (*)(struct efx_nic *))0, .finish_flush = (void (*)(struct efx_nic *))0, .prepare_flr = & efx_ef10_prepare_flr, .finish_flr = & efx_port_dummy_op_void, .describe_stats = & efx_ef10_describe_stats, .update_stats = & efx_ef10_update_stats_pf, .start_stats = & efx_mcdi_mac_start_stats, .pull_stats = & efx_mcdi_mac_pull_stats, .stop_stats = & efx_mcdi_mac_stop_stats, .set_id_led = & efx_mcdi_set_id_led, .push_irq_moderation = & efx_ef10_push_irq_moderation, .reconfigure_port = & efx_mcdi_port_reconfigure, .prepare_enable_fc_tx = (void (*)(struct efx_nic *))0, .reconfigure_mac = & efx_ef10_mac_reconfigure, .check_mac_fault = & efx_mcdi_mac_check_fault, .get_wol = & efx_ef10_get_wol, .set_wol = & efx_ef10_set_wol, .resume_wol = & efx_port_dummy_op_void, .test_chip = & efx_ef10_test_chip, .test_nvram = & efx_mcdi_nvram_test_all, .mcdi_request = & efx_ef10_mcdi_request, .mcdi_poll_response = & efx_ef10_mcdi_poll_response, .mcdi_read_response = & efx_ef10_mcdi_read_response, .mcdi_poll_reboot = & efx_ef10_mcdi_poll_reboot, .irq_enable_master = & efx_port_dummy_op_void, .irq_test_generate = & efx_ef10_irq_test_generate, .irq_disable_non_ev = & efx_port_dummy_op_void, .irq_handle_msi = & efx_ef10_msi_interrupt, .irq_handle_legacy = & efx_ef10_legacy_interrupt, .tx_probe = & efx_ef10_tx_probe, .tx_init = & efx_ef10_tx_init, .tx_remove = & efx_ef10_tx_remove, .tx_write = & efx_ef10_tx_write, .rx_push_rss_config = & efx_ef10_pf_rx_push_rss_config, .rx_probe = & efx_ef10_rx_probe, .rx_init = & efx_ef10_rx_init, .rx_remove = & efx_ef10_rx_remove, .rx_write = & efx_ef10_rx_write, .rx_defer_refill = & efx_ef10_rx_defer_refill, .ev_probe = & efx_ef10_ev_probe, .ev_init = & efx_ef10_ev_init, .ev_fini = & efx_ef10_ev_fini, .ev_remove = & efx_ef10_ev_remove, .ev_process = & efx_ef10_ev_process, .ev_read_ack = & efx_ef10_ev_read_ack, .ev_test_generate = & efx_ef10_ev_test_generate, .filter_table_probe = & efx_ef10_filter_table_probe, .filter_table_restore = & efx_ef10_filter_table_restore, .filter_table_remove = & efx_ef10_filter_table_remove, .filter_update_rx_scatter = & efx_ef10_filter_update_rx_scatter, .filter_insert = & efx_ef10_filter_insert, .filter_remove_safe = & efx_ef10_filter_remove_safe, .filter_get_safe = & efx_ef10_filter_get_safe, .filter_clear_rx = & efx_ef10_filter_clear_rx, .filter_count_rx_used = & efx_ef10_filter_count_rx_used, .filter_get_rx_id_limit = & efx_ef10_filter_get_rx_id_limit, .filter_get_rx_ids = & efx_ef10_filter_get_rx_ids, .filter_rfs_insert = & efx_ef10_filter_rfs_insert, .filter_rfs_expire_one = & efx_ef10_filter_rfs_expire_one, .mtd_probe = & efx_ef10_mtd_probe, .mtd_rename = & efx_mcdi_mtd_rename, .mtd_read = & efx_mcdi_mtd_read, .mtd_erase = & efx_mcdi_mtd_erase, .mtd_write = & efx_mcdi_mtd_write, .mtd_sync = & efx_mcdi_mtd_sync, .ptp_write_host_time = & efx_ef10_ptp_write_host_time, .ptp_set_ts_sync_events = & efx_ef10_ptp_set_ts_sync_events, .ptp_set_ts_config = & efx_ef10_ptp_set_ts_config, .sriov_configure = & efx_ef10_sriov_configure, .sriov_init = & efx_ef10_sriov_init, .sriov_fini = & efx_ef10_sriov_fini, .sriov_wanted = & efx_ef10_sriov_wanted, .sriov_reset = & efx_ef10_sriov_reset, .sriov_flr = & efx_ef10_sriov_flr, .sriov_set_vf_mac = & efx_ef10_sriov_set_vf_mac, .sriov_set_vf_vlan = & efx_ef10_sriov_set_vf_vlan, .sriov_set_vf_spoofchk = & efx_ef10_sriov_set_vf_spoofchk, .sriov_get_vf_config = & efx_ef10_sriov_get_vf_config, .sriov_set_vf_link_state = & efx_ef10_sriov_set_vf_link_state, .sriov_get_phys_port_id = (int (*)(struct efx_nic *, struct netdev_phys_item_id *))0, .vswitching_probe = & efx_ef10_vswitching_probe_pf, .vswitching_restore = & efx_ef10_vswitching_restore_pf, .vswitching_remove = & efx_ef10_vswitching_remove_pf, .get_mac_address = & efx_ef10_get_mac_address_pf, .set_mac_address = & efx_ef10_set_mac_address, .revision = 4, .txd_ptr_tbl_base = 0U, .rxd_ptr_tbl_base = 0U, .buf_tbl_base = 0U, .evq_ptr_tbl_base = 0U, .evq_rptr_tbl_base = 0U, .max_dma_mask = 281474976710655ULL, .rx_prefix_size = 14U, .rx_hash_offset = 0U, .rx_ts_offset = 10U, .rx_buffer_padding = 0U, .can_rx_scatter = (_Bool)1, .always_rx_scatter = (_Bool)1, .max_interrupt_mode = 0U, .timer_period_max = 256U, .offload_features = 12884901906ULL, .mcdi_max_ver = 2, .max_rx_ip_filters = 8192U, .hwtstamp_filters = 3U};

#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
struct device_attribute *ldv_emg_alias_dev_attr_link_control_flag_3 = & dev_attr_link_control_flag;

#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
struct device_attribute *ldv_emg_alias_dev_attr_primary_flag_3 = & dev_attr_primary_flag;

#line 77  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
long ldv_emg_wrapper_efx_ef10_show_link_control_flag_2(struct device *arg0, struct device_attribute *arg1, char *arg2)
{
  long tmp;
  
#line 78 
  tmp = efx_ef10_show_link_control_flag(arg0,arg1,arg2);
  
#line 78 
  return tmp;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
long ldv_emg_wrapper_efx_ef10_show_primary_flag_2(struct device *arg0, struct device_attribute *arg1, char *arg2)
{
  long tmp;
  
#line 83 
  tmp = efx_ef10_show_primary_flag(arg0,arg1,arg2);
  
#line 83 
  return tmp;
}


#line 155  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static int atomic_dec_and_test(atomic_t *v)
{
  int tmp;
  
#line 158 
  tmp = ldv_atomic_dec_and_test(v);
  
#line 158 
  return tmp;
}


#line 613  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void *kmalloc_1(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 616 
  tmp = ldv_kmalloc(size,flags);
  
#line 616 
  return tmp;
}


#line 627  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void *kcalloc_6(size_t n, size_t size, gfp_t flags)
{
  void *tmp;
  
#line 630 
  tmp = ldv_kcalloc(n,size,flags);
  
#line 630 
  return tmp;
}


#line 634  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void *kzalloc_6(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 637 
  tmp = ldv_kzalloc(size,flags);
  
#line 637 
  return tmp;
}


#line 641  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_lock_62_2(spinlock_t *lock)
{
  
#line 645 
  ldv_spin_model_lock((char *)"_xmit_lock_of_netdev_queue");
  
#line 647 
  spin_lock_3(lock);
  
#line 648 
  return;
}


#line 684  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_unlock_65_2(spinlock_t *lock)
{
  
#line 688 
  ldv_spin_model_unlock((char *)"_xmit_lock_of_netdev_queue");
  
#line 690 
  spin_unlock_3(lock);
  
#line 691 
  return;
}


#line 704  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_lock_67_2(spinlock_t *lock)
{
  
#line 708 
  ldv_spin_model_lock((char *)"tx_global_lock_of_net_device");
  
#line 710 
  spin_lock_3(lock);
  
#line 711 
  return;
}


#line 714  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_unlock_68_2(spinlock_t *lock)
{
  
#line 718 
  ldv_spin_model_unlock((char *)"tx_global_lock_of_net_device");
  
#line 720 
  spin_unlock_3(lock);
  
#line 721 
  return;
}


#line 744  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_lock_bh_71_0(spinlock_t *lock)
{
  
#line 748 
  ldv_spin_model_lock((char *)"addr_list_lock_of_net_device");
  
#line 750 
  spin_lock_bh_2(lock);
  
#line 751 
  return;
}


#line 764  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_unlock_bh_73_0(spinlock_t *lock)
{
  
#line 768 
  ldv_spin_model_unlock((char *)"addr_list_lock_of_net_device");
  
#line 770 
  spin_unlock_bh_3(lock);
  
#line 771 
  return;
}


#line 1004  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static int ldv_device_create_file_97(struct device *ldv_func_arg1, struct device_attribute const *ldv_func_arg2)
{
  int tmp;
  
#line 1008 
  tmp = ldv_emg_device_create_file(ldv_func_arg1,(struct device_attribute *)ldv_func_arg2);
  
#line 1008 
  return tmp;
}


#line 1012  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static int ldv_device_create_file_98(struct device *ldv_func_arg1, struct device_attribute const *ldv_func_arg2)
{
  int tmp;
  
#line 1016 
  tmp = ldv_emg_device_create_file(ldv_func_arg1,(struct device_attribute *)ldv_func_arg2);
  
#line 1016 
  return tmp;
}


#line 1020  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_device_remove_file_99(struct device *ldv_func_arg1, struct device_attribute const *ldv_func_arg2)
{
  
#line 1024 
  ldv_emg_device_remove_file(ldv_func_arg1,(struct device_attribute *)ldv_func_arg2);
  
#line 1025 
  return;
}


#line 1028  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_device_remove_file_100(struct device *ldv_func_arg1, struct device_attribute const *ldv_func_arg2)
{
  
#line 1032 
  ldv_emg_device_remove_file(ldv_func_arg1,(struct device_attribute *)ldv_func_arg2);
  
#line 1033 
  return;
}


#line 1036  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_device_remove_file_101(struct device *ldv_func_arg1, struct device_attribute const *ldv_func_arg2)
{
  
#line 1040 
  ldv_emg_device_remove_file(ldv_func_arg1,(struct device_attribute *)ldv_func_arg2);
  
#line 1041 
  return;
}


#line 1044  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_device_remove_file_102(struct device *ldv_func_arg1, struct device_attribute const *ldv_func_arg2)
{
  
#line 1048 
  ldv_emg_device_remove_file(ldv_func_arg1,(struct device_attribute *)ldv_func_arg2);
  
#line 1049 
  return;
}


#line 1052  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_unlock_bh_103_0(spinlock_t *lock)
{
  
#line 1056 
  ldv_spin_model_unlock((char *)"stats_lock_of_efx_nic");
  
#line 1058 
  spin_unlock_bh_3(lock);
  
#line 1059 
  return;
}


#line 1062  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_lock_bh_104_0(spinlock_t *lock)
{
  
#line 1066 
  ldv_spin_model_lock((char *)"stats_lock_of_efx_nic");
  
#line 1068 
  spin_lock_bh_2(lock);
  
#line 1069 
  return;
}


#line 1072  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_lock_bh_105(spinlock_t *lock)
{
  
#line 1076 
  ldv_spin_model_lock((char *)"stats_lock_of_efx_nic");
  
#line 1078 
  spin_lock_bh_2(lock);
  
#line 1079 
  return;
}


#line 1082  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_lock_bh_106_0(spinlock_t *lock)
{
  
#line 1086 
  ldv_spin_model_lock((char *)"stats_lock_of_efx_nic");
  
#line 1088 
  spin_lock_bh_2(lock);
  
#line 1089 
  return;
}


#line 1092  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_lock_bh_107(spinlock_t *lock)
{
  
#line 1096 
  ldv_spin_model_lock((char *)"filter_lock_of_efx_nic");
  
#line 1098 
  spin_lock_bh_2(lock);
  
#line 1099 
  return;
}


#line 1102  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_unlock_bh_108(spinlock_t *lock)
{
  
#line 1106 
  ldv_spin_model_unlock((char *)"filter_lock_of_efx_nic");
  
#line 1108 
  spin_unlock_bh_3(lock);
  
#line 1109 
  return;
}


#line 1112  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_unlock_bh_109_0(spinlock_t *lock)
{
  
#line 1116 
  ldv_spin_model_unlock((char *)"filter_lock_of_efx_nic");
  
#line 1118 
  spin_unlock_bh_3(lock);
  
#line 1119 
  return;
}


#line 1122  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_lock_bh_110_0(spinlock_t *lock)
{
  
#line 1126 
  ldv_spin_model_lock((char *)"filter_lock_of_efx_nic");
  
#line 1128 
  spin_lock_bh_2(lock);
  
#line 1129 
  return;
}


#line 1132  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_unlock_bh_111_0(spinlock_t *lock)
{
  
#line 1136 
  ldv_spin_model_unlock((char *)"filter_lock_of_efx_nic");
  
#line 1138 
  spin_unlock_bh_3(lock);
  
#line 1139 
  return;
}


#line 1142  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_lock_bh_112_0(spinlock_t *lock)
{
  
#line 1146 
  ldv_spin_model_lock((char *)"filter_lock_of_efx_nic");
  
#line 1148 
  spin_lock_bh_2(lock);
  
#line 1149 
  return;
}


#line 1152  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_unlock_bh_113_0(spinlock_t *lock)
{
  
#line 1156 
  ldv_spin_model_unlock((char *)"filter_lock_of_efx_nic");
  
#line 1158 
  spin_unlock_bh_3(lock);
  
#line 1159 
  return;
}


#line 1162  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_lock_bh_114(spinlock_t *lock)
{
  
#line 1166 
  ldv_spin_model_lock((char *)"filter_lock_of_efx_nic");
  
#line 1168 
  spin_lock_bh_2(lock);
  
#line 1169 
  return;
}


#line 1172  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_unlock_bh_115(spinlock_t *lock)
{
  
#line 1176 
  ldv_spin_model_unlock((char *)"filter_lock_of_efx_nic");
  
#line 1178 
  spin_unlock_bh_3(lock);
  
#line 1179 
  return;
}


#line 1182  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_unlock_bh_116_0(spinlock_t *lock)
{
  
#line 1186 
  ldv_spin_model_unlock((char *)"filter_lock_of_efx_nic");
  
#line 1188 
  spin_unlock_bh_3(lock);
  
#line 1189 
  return;
}


#line 1192  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_lock_bh_117_0(spinlock_t *lock)
{
  
#line 1196 
  ldv_spin_model_lock((char *)"filter_lock_of_efx_nic");
  
#line 1198 
  spin_lock_bh_2(lock);
  
#line 1199 
  return;
}


#line 1202  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_lock_bh_118(spinlock_t *lock)
{
  
#line 1206 
  ldv_spin_model_lock((char *)"filter_lock_of_efx_nic");
  
#line 1208 
  spin_lock_bh_2(lock);
  
#line 1209 
  return;
}


#line 1212  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_unlock_bh_119_0(spinlock_t *lock)
{
  
#line 1216 
  ldv_spin_model_unlock((char *)"filter_lock_of_efx_nic");
  
#line 1218 
  spin_unlock_bh_3(lock);
  
#line 1219 
  return;
}


#line 1222  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_lock_bh_120(spinlock_t *lock)
{
  
#line 1226 
  ldv_spin_model_lock((char *)"filter_lock_of_efx_nic");
  
#line 1228 
  spin_lock_bh_2(lock);
  
#line 1229 
  return;
}


#line 1232  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_unlock_bh_121(spinlock_t *lock)
{
  
#line 1236 
  ldv_spin_model_unlock((char *)"filter_lock_of_efx_nic");
  
#line 1238 
  spin_unlock_bh_3(lock);
  
#line 1239 
  return;
}


#line 1242  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_lock_bh_122(spinlock_t *lock)
{
  
#line 1246 
  ldv_spin_model_lock((char *)"filter_lock_of_efx_nic");
  
#line 1248 
  spin_lock_bh_2(lock);
  
#line 1249 
  return;
}


#line 1252  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_unlock_bh_123(spinlock_t *lock)
{
  
#line 1256 
  ldv_spin_model_unlock((char *)"filter_lock_of_efx_nic");
  
#line 1258 
  spin_unlock_bh_3(lock);
  
#line 1259 
  return;
}


#line 1262  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_lock_bh_124(spinlock_t *lock)
{
  
#line 1266 
  ldv_spin_model_lock((char *)"filter_lock_of_efx_nic");
  
#line 1268 
  spin_lock_bh_2(lock);
  
#line 1269 
  return;
}


#line 1272  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_unlock_bh_125(spinlock_t *lock)
{
  
#line 1276 
  ldv_spin_model_unlock((char *)"filter_lock_of_efx_nic");
  
#line 1278 
  spin_unlock_bh_3(lock);
  
#line 1279 
  return;
}


#line 1282  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_lock_bh_126(spinlock_t *lock)
{
  
#line 1286 
  ldv_spin_model_lock((char *)"filter_lock_of_efx_nic");
  
#line 1288 
  spin_lock_bh_2(lock);
  
#line 1289 
  return;
}


#line 1292  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_unlock_bh_127(spinlock_t *lock)
{
  
#line 1296 
  ldv_spin_model_unlock((char *)"filter_lock_of_efx_nic");
  
#line 1298 
  spin_unlock_bh_3(lock);
  
#line 1299 
  return;
}


#line 1302  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_unlock_bh_128(spinlock_t *lock)
{
  
#line 1306 
  ldv_spin_model_unlock((char *)"filter_lock_of_efx_nic");
  
#line 1308 
  spin_unlock_bh_3(lock);
  
#line 1309 
  return;
}


#line 1312  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_lock_bh_129(spinlock_t *lock)
{
  
#line 1316 
  ldv_spin_model_lock((char *)"filter_lock_of_efx_nic");
  
#line 1318 
  spin_lock_bh_2(lock);
  
#line 1319 
  return;
}


#line 1322  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_unlock_bh_130(spinlock_t *lock)
{
  
#line 1326 
  ldv_spin_model_unlock((char *)"filter_lock_of_efx_nic");
  
#line 1328 
  spin_unlock_bh_3(lock);
  
#line 1329 
  return;
}


#line 1332  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_lock_bh_131(spinlock_t *lock)
{
  
#line 1336 
  ldv_spin_model_lock((char *)"filter_lock_of_efx_nic");
  
#line 1338 
  spin_lock_bh_2(lock);
  
#line 1339 
  return;
}


#line 1342  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_unlock_bh_132(spinlock_t *lock)
{
  
#line 1346 
  ldv_spin_model_unlock((char *)"filter_lock_of_efx_nic");
  
#line 1348 
  spin_unlock_bh_3(lock);
  
#line 1349 
  return;
}


#line 1352  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_lock_bh_133(spinlock_t *lock)
{
  
#line 1356 
  ldv_spin_model_lock((char *)"filter_lock_of_efx_nic");
  
#line 1358 
  spin_lock_bh_2(lock);
  
#line 1359 
  return;
}


#line 1362  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_unlock_bh_134(spinlock_t *lock)
{
  
#line 1366 
  ldv_spin_model_unlock((char *)"filter_lock_of_efx_nic");
  
#line 1368 
  spin_unlock_bh_3(lock);
  
#line 1369 
  return;
}


#line 1372  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_lock_bh_135(spinlock_t *lock)
{
  
#line 1376 
  ldv_spin_model_lock((char *)"filter_lock_of_efx_nic");
  
#line 1378 
  spin_lock_bh_2(lock);
  
#line 1379 
  return;
}


#line 1382  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_unlock_bh_136(spinlock_t *lock)
{
  
#line 1386 
  ldv_spin_model_unlock((char *)"filter_lock_of_efx_nic");
  
#line 1388 
  spin_unlock_bh_3(lock);
  
#line 1389 
  return;
}


#line 1392  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_lock_bh_137(spinlock_t *lock)
{
  
#line 1396 
  ldv_spin_model_lock((char *)"filter_lock_of_efx_nic");
  
#line 1398 
  spin_lock_bh_2(lock);
  
#line 1399 
  return;
}


#line 1402  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ef10.c.aux"
static void ldv_spin_unlock_bh_138(spinlock_t *lock)
{
  
#line 1406 
  ldv_spin_model_unlock((char *)"filter_lock_of_efx_nic");
  
#line 1408 
  spin_unlock_bh_3(lock);
  
#line 1409 
  return;
}


#line 231  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int __test_and_set_bit(long nr, unsigned long volatile *addr)
{
  int oldbit;
  
#line 234 
  ldv_inline_asm();
  
#line 239 
  return oldbit;
}


#line 274  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void __list_splice(struct list_head const *list, struct list_head *prev, struct list_head *next)
{
  
#line 278 
  struct list_head *first = list->next;
  
#line 279 
  struct list_head *last = list->prev;
  
#line 281 
  first->prev = prev;
  
#line 282 
  prev->next = first;
  
#line 284 
  last->next = next;
  
#line 285 
  next->prev = last;
  
#line 286 
  return;
}


#line 336  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void list_splice_tail_init(struct list_head *list, struct list_head *head)
{
  int tmp;
  
#line 339 
  tmp = list_empty((struct list_head const *)list);
  
#line 339 
  if (tmp == 0) {
    
#line 340 
    __list_splice((struct list_head const *)list,head->prev,head);
    
#line 341 
    INIT_LIST_HEAD(list);
  }
  else ;
  
#line 343 
  return;
}


#line 98  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/atomic.h"
static void atomic_inc_2(atomic_t *v);


#line 114 
static void atomic_dec_1(atomic_t *v);


#line 280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
void lockdep_init_map(struct lockdep_map *, char const *, struct lock_class_key *, int);


#line 470  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_irqrestore_2(spinlock_t *lock, unsigned long flags)
{
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
  }
  
#line 472 
  _raw_spin_unlock_irqrestore(& lock->__anonCompField_spinlock_18.rlock,flags);
  
#line 473 
  return;
}


#line 502 
static void ldv_spin_unlock_irqrestore_88_1(spinlock_t *lock, unsigned long flags);


#line 506 
static void ldv_spin_unlock_irqrestore_90_0(spinlock_t *lock, unsigned long flags);


#line 37  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void ldv_mutex_lock_99(struct mutex *ldv_func_arg1);


#line 41 
static void ldv_mutex_lock_103(struct mutex *ldv_func_arg1);


#line 45 
static void ldv_mutex_lock_104(struct mutex *ldv_func_arg1);


#line 49 
static void ldv_mutex_lock_107(struct mutex *ldv_func_arg1);


#line 53 
static void ldv_mutex_lock_109(struct mutex *ldv_func_arg1);


#line 57 
static void ldv_mutex_lock_111(struct mutex *ldv_func_arg1);


#line 61 
static void ldv_mutex_lock_112(struct mutex *ldv_func_arg1);


#line 65 
static void ldv_mutex_lock_115(struct mutex *ldv_func_arg1);


#line 69 
static void ldv_mutex_lock_120(struct mutex *ldv_func_arg1);


#line 73 
static void ldv_mutex_lock_122(struct mutex *ldv_func_arg1);


#line 77 
static void ldv_mutex_lock_124(struct mutex *ldv_func_arg1);


#line 114 
static void ldv___ldv_spin_lock_87_1(spinlock_t *ldv_func_arg1);


#line 118 
static void ldv___ldv_spin_lock_89_0(spinlock_t *ldv_func_arg1);


#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
static int ldv_mutex_is_locked_98(struct mutex *lock);


#line 193 
static void ldv_mutex_unlock_100(struct mutex *ldv_func_arg1);


#line 197 
static void ldv_mutex_unlock_105(struct mutex *ldv_func_arg1);


#line 201 
static void ldv_mutex_unlock_106(struct mutex *ldv_func_arg1);


#line 205 
static void ldv_mutex_unlock_108(struct mutex *ldv_func_arg1);


#line 209 
static void ldv_mutex_unlock_110(struct mutex *ldv_func_arg1);


#line 213 
static void ldv_mutex_unlock_113(struct mutex *ldv_func_arg1);


#line 217 
static void ldv_mutex_unlock_114(struct mutex *ldv_func_arg1);


#line 221 
static void ldv_mutex_unlock_116(struct mutex *ldv_func_arg1);


#line 225 
static void ldv_mutex_unlock_121(struct mutex *ldv_func_arg1);


#line 229 
static void ldv_mutex_unlock_123(struct mutex *ldv_func_arg1);


#line 233 
static void ldv_mutex_unlock_125(struct mutex *ldv_func_arg1);


#line 181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
void __init_work(struct work_struct *, int);


#line 361 
struct workqueue_struct *__alloc_workqueue_key(char const *, unsigned int, int, struct lock_class_key *, char const * , ...);


#line 421 
void destroy_workqueue(struct workqueue_struct *);


#line 444 
bool cancel_work_sync(struct work_struct *);


#line 490 
static bool ldv_queue_work_97(struct workqueue_struct *wq, struct work_struct *work);


#line 494 
static bool ldv_queue_work_101(struct workqueue_struct *wq, struct work_struct *work);


#line 498 
static bool ldv_queue_work_102(struct workqueue_struct *wq, struct work_struct *work);


#line 502 
static bool ldv_queue_work_117(struct workqueue_struct *wq, struct work_struct *work);


#line 506 
static bool ldv_queue_work_118(struct workqueue_struct *wq, struct work_struct *work);


#line 510 
static bool ldv_queue_work_119(struct workqueue_struct *wq, struct work_struct *work);


#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kmalloc_2(size_t size, gfp_t flags);


#line 542 
static void *kcalloc_7(size_t n, size_t size, gfp_t flags);


#line 837  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
int pci_find_ext_capability(struct pci_dev *, int);


#line 861 
int pci_bus_read_config_word(struct pci_bus *, unsigned int, int, u16 *);


#line 887  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_read_config_word(struct pci_dev const *dev, int where, u16 *val)
{
  int tmp;
  
#line 889 
  tmp = pci_bus_read_config_word(dev->bus,dev->devfn,where,val);
  
#line 889 
  return tmp;
}


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pci.h"
__inline static int pci_domain_nr(struct pci_bus *bus)
{
  int __retres;
  
#line 34 
  struct pci_sysdata *sd = (struct pci_sysdata *)bus->sysdata;
  
#line 35 
  __retres = sd->domain;
  
#line 35 
  return __retres;
}


#line 167  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/filter.h"
__inline static void efx_filter_init_tx(struct efx_filter_spec *spec, unsigned int txq_id)
{
  
#line 170 
  memset((void *)spec,0,64UL);
  
#line 171 
  spec->priority = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))3U;
  
#line 172 
  spec->flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))16U;
  
#line 173 
  spec->dmaq_id = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))))txq_id;
  
#line 174 
  return;
}


#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
void efx_channel_dummy_op_void(struct efx_channel *channel);


#line 553  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
int efx_init_sriov(void);


#line 554 
void efx_fini_sriov(void);


#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/io.h"
__inline static void efx_writeo_1(struct efx_nic *efx, efx_oword_t const *value, unsigned int reg)
{
  unsigned long flags;
  
#line 113 
  ldv___ldv_spin_lock_87_1(& efx->biu_lock);
  
#line 115 
  _efx_writeq(efx,value->u64[0],reg);
  
#line 116 
  _efx_writeq(efx,value->u64[1],reg + 8U);
  
#line 117 
  ldv_inline_asm();
  
#line 124 
  ldv_spin_unlock_irqrestore_88_1(& efx->biu_lock,flags);
  
#line 125 
  return;
}


#line 128  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/io.h"
__inline static void efx_sram_writeq_0(struct efx_nic *efx, void *membase, efx_qword_t const *value, unsigned int index)
{
  unsigned long flags;
  
#line 131 
  unsigned int addr = index * 8U;
  
#line 138 
  ldv___ldv_spin_lock_89_0(& efx->biu_lock);
  
#line 140 
  writeq((unsigned long)value->u64[0],(void volatile *)(membase + addr));
  
#line 141 
  ldv_inline_asm();
  
#line 146 
  ldv_spin_unlock_irqrestore_90_0(& efx->biu_lock,flags);
  
#line 147 
  return;
}


#line 212  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/io.h"
__inline static void efx_writeo_table_0(struct efx_nic *efx, efx_oword_t const *value, unsigned int reg, unsigned int index)
{
  
#line 215 
  efx_writeo_1(efx,value,index * 16U + reg);
  
#line 216 
  return;
}


#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static unsigned int vf_max_tx_channels = 2U;

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static int max_vfs = -1;

#line 191  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static struct workqueue_struct *vfdi_workqueue;

#line 193  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static unsigned int abs_index(struct siena_vf *vf, unsigned int index)
{
  unsigned int __retres;
  unsigned int tmp;
  
#line 195 
  tmp = efx_vf_size(vf->efx);
  
#line 195 
  ;
  
#line 195 
  __retres = (vf->index * tmp + index) + 128U;
  
#line 195 
  return __retres;
}


#line 198  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static int efx_siena_sriov_cmd(struct efx_nic *efx, bool enable, unsigned int *vi_scale_out, unsigned int *vf_total_out)
{
  int __retres;
  unsigned int vi_scale;
  unsigned int vf_total;
  size_t outlen;
  int rc;
  
#line 201 
  efx_dword_t inbuf[3U] = {{.u32 = {0U}}};
  
#line 202 
  efx_dword_t outbuf[2U] = {{.u32 = {0U}}};
  
#line 207 
  ((efx_dword_t *)(& inbuf))->u32[0] = (unsigned int)((int)enable != 0);
  
#line 208 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = 128U;
  
#line 209 
  ((efx_dword_t *)(& inbuf) + 2U)->u32[0] = efx->vf_count;
  
#line 211 
  rc = efx_mcdi_rpc_quiet(efx,48U,(efx_dword_t const *)(& inbuf),12UL,(efx_dword_t *)(& outbuf),8UL,& outlen);
  
#line 213 
  if (rc != 0) {
    
#line 214 
    __retres = rc;
    
#line 214 
    goto return_label;
  }
  else ;
  
#line 215 
  if (outlen <= 7UL) {
    
#line 216 
    __retres = -5;
    
#line 216 
    goto return_label;
  }
  else ;
  
#line 218 
  vf_total = ((efx_dword_t *)(& outbuf) + 1U)->u32[0];
  
#line 219 
  vi_scale = ((efx_dword_t *)(& outbuf))->u32[0];
  
#line 220 
  if (vi_scale > 6U) {
    
#line 221 
    __retres = -95;
    
#line 221 
    goto return_label;
  }
  else ;
  
#line 223 
  if (vi_scale_out != (unsigned int *)0U) 
#line 224 
                                          *vi_scale_out = vi_scale; else ;
  
#line 225 
  if (vf_total_out != (unsigned int *)0U) 
#line 226 
                                          *vf_total_out = vf_total; else ;
  
#line 228 
  __retres = 0;
  return_label: 
#line 228 
                return __retres;
}


#line 231  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static void efx_siena_sriov_usrev(struct efx_nic *efx, bool enabled)
{
  efx_oword_t reg;
  
#line 233 
  struct siena_nic_data *nic_data = (struct siena_nic_data *)efx->nic_data;
  
#line 236 
  reg.u64[0] = ((unsigned long long)((int)enabled == 0) << 16) | (unsigned long long)(nic_data->vfdi_channel)->channel;
  
#line 236 
  reg.u64[1] = 0ULL;
  
#line 239 
  efx_writeo_1(efx,(efx_oword_t const *)(& reg),256U);
  
#line 240 
  return;
}


#line 242  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static int efx_siena_sriov_memcpy(struct efx_nic *efx, struct efx_memcpy_req *req, unsigned int count)
{
  int __retres;
  efx_dword_t *record;
  unsigned int index;
  unsigned int used;
  u64 from_addr;
  u32 from_rid;
  int rc;
  int tmp;
  
#line 246 
  efx_dword_t inbuf[63U] = {{.u32 = {0U}}};
  
#line 252 
  ldv_inline_asm();
  {
    
#line 255 
    int __ret_warn_on = count > 7U;
    
#line 255 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 255 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c",255); else ;
    
#line 255 
    tmp = (long)(__ret_warn_on != 0);
  }
  
#line 255 
  if ((long)tmp != 0L) {
    
#line 256 
    __retres = -105;
    
#line 256 
    goto return_label;
  }
  else ;
  
#line 257 
  used = count * 32U;
  
#line 259 
  index = 0U;
  
#line 259 
  goto ldv_56971;
  ldv_56970: 
#line 260 
  ;
  
#line 260 
  record = (efx_dword_t *)(& inbuf) + (unsigned long)index * 32UL;
  
#line 261 
  record->u32[0] = count;
  
#line 263 
  (record + 1U)->u32[0] = req->to_rid;
  
#line 265 
  (record + 2U)->u32[0] = (unsigned int)req->to_addr;
  
#line 265 
  (record + 3U)->u32[0] = (unsigned int)(req->to_addr >> 32);
  
#line 267 
  if (req->from_buf == (void *)0) {
    
#line 268 
    from_rid = req->from_rid;
    
#line 269 
    from_addr = req->from_addr;
  }
  else {
    int tmp_0;
    {
      
#line 271 
      int __ret_warn_on_0 = req->length + used > 252U;
      
#line 271 
      if ((long)(__ret_warn_on_0 != 0) != 0L) 
#line 271 
                                              warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c",272); else ;
      
#line 271 
      tmp_0 = (long)(__ret_warn_on_0 != 0);
    }
    
#line 271 
    if ((long)tmp_0 != 0L) {
      
#line 273 
      rc = -105;
      
#line 274 
      goto out;
    }
    else ;
    
#line 277 
    from_rid = 256U;
    
#line 278 
    from_addr = (unsigned long long)used;
    
#line 279 
    memcpy((void *)(& inbuf) + used,(void const *)req->from_buf,(unsigned long)req->length);
    
#line 281 
    used = req->length + used;
  }
  
#line 284 
  (record + 4U)->u32[0] = from_rid;
  
#line 285 
  (record + 5U)->u32[0] = (unsigned int)from_addr;
  
#line 285 
  (record + 6U)->u32[0] = (unsigned int)(from_addr >> 32);
  
#line 287 
  (record + 7U)->u32[0] = req->length;
  
#line 290 
  req += 1;
  
#line 259 
  index += 1U;
  ldv_56971: 
#line 260 
  ;
  
#line 259 
  if (index < count) 
#line 261 
                     goto ldv_56970; else 
#line 264 
                                          goto ldv_56972;
  ldv_56972: 
#line 265 
  ;
  
#line 293 
  rc = efx_mcdi_rpc(efx,49U,(efx_dword_t const *)(& inbuf),(unsigned long)used,(efx_dword_t *)0,0UL,(size_t *)0UL);
  out: 
#line 294 
  ;
  
#line 295 
  ldv_inline_asm();
  
#line 297 
  __retres = rc;
  return_label: 
#line 297 
                return __retres;
}


#line 303  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static void efx_siena_sriov_reset_tx_filter(struct siena_vf *vf)
{
  struct efx_filter_spec filter;
  u16 vlan;
  int rc;
  bool tmp;
  unsigned int tmp_1;
  unsigned int tmp_2;
  
#line 305 
  struct efx_nic *efx = vf->efx;
  
#line 310 
  if (vf->tx_filter_id != -1) {
    
#line 311 
    efx_filter_remove_id_safe(efx,(enum efx_filter_priority)EFX_FILTER_PRI_REQUIRED,(unsigned int)vf->tx_filter_id);
    
#line 313 
    if ((efx->msg_enable & 8192U) != 0U) {
      
#line 313 
      struct _ddebug descriptor = {.modname = "sfc", .function = "efx_siena_sriov_reset_tx_filter", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c", .format = "Removed vf %s tx filter %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))314U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 313 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 313 
                                                          __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"Removed vf %s tx filter %d\n",(char *)(& vf->pci_name),vf->tx_filter_id); else ;
    }
    else ;
    
#line 315 
    vf->tx_filter_id = -1;
  }
  else ;
  
#line 318 
  tmp = is_zero_ether_addr((u8 const *)(& vf->addr.mac_addr));
  
#line 318 
  if ((int)tmp != 0) 
#line 319 
                     goto return_label; else ;
  
#line 324 
  if (vf->tx_filter_mode == (unsigned int)VF_TX_FILTER_AUTO && vf_max_tx_channels <= 2U) 
    
#line 325 
    vf->tx_filter_mode = VF_TX_FILTER_ON; else ;
  
#line 327 
  if (0 != 0) 
#line 327 
              vlan = (unsigned short)((unsigned int)((unsigned short)(((int)vf->addr.tci << 8) | ((int)vf->addr.tci >> 8))) & 4095U);
  else {
    __u16 tmp_0;
    
#line 327 
    tmp_0 = __fswab16((unsigned short)((int)vf->addr.tci));
    
#line 327 
    vlan = (unsigned short)((unsigned int)tmp_0 & 4095U);
  }
  
#line 328 
  tmp_1 = abs_index(vf,0U);
  
#line 328 
  efx_filter_init_tx(& filter,tmp_1);
  
#line 329 
  ;
  
#line 329 
  if ((unsigned int)vlan != 0U) 
#line 329 
                                tmp_2 = (unsigned int)vlan; else 
#line 329 
                                                                 tmp_2 = 65535U;
  
#line 329 
  rc = efx_filter_set_eth_local(& filter,(unsigned short)((int)tmp_2),(u8 const *)(& vf->addr.mac_addr));
  
#line 332 
  if ((long)(rc != 0) != 0L) {
    
#line 334 
    ldv_inline_asm();
    
#line 332 
    ;
  }
  else ;
  
#line 334 
  rc = efx_filter_insert_filter(efx,& filter,(_Bool)1);
  
#line 335 
  if (rc < 0) {
    
#line 336 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 336 
                                         netdev_warn((struct net_device const *)efx->net_dev,"Unable to migrate tx filter for vf %s\n",(char *)(& vf->pci_name)); else ;
  }
  else {
    
#line 340 
    if ((efx->msg_enable & 8192U) != 0U) {
      
#line 340 
      struct _ddebug descriptor_0 = {.modname = "sfc", .function = "efx_siena_sriov_reset_tx_filter", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c", .format = "Inserted vf %s tx filter %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))341U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 340 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 340 
                                                            __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)efx->net_dev,"Inserted vf %s tx filter %d\n",(char *)(& vf->pci_name),rc); else ;
    }
    else ;
    
#line 342 
    vf->tx_filter_id = rc;
  }
  return_label: 
#line 344 
                return;
}


#line 347  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static void efx_siena_sriov_reset_rx_filter(struct siena_vf *vf)
{
  struct efx_filter_spec filter;
  u16 vlan;
  int rc;
  unsigned int tmp_1;
  unsigned int tmp_2;
  
#line 349 
  struct efx_nic *efx = vf->efx;
  
#line 354 
  if (vf->rx_filter_id != -1) {
    
#line 355 
    efx_filter_remove_id_safe(efx,(enum efx_filter_priority)EFX_FILTER_PRI_REQUIRED,(unsigned int)vf->rx_filter_id);
    
#line 357 
    if ((efx->msg_enable & 8192U) != 0U) {
      
#line 357 
      struct _ddebug descriptor = {.modname = "sfc", .function = "efx_siena_sriov_reset_rx_filter", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c", .format = "Removed vf %s rx filter %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))358U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 357 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 357 
                                                          __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"Removed vf %s rx filter %d\n",(char *)(& vf->pci_name),vf->rx_filter_id); else ;
    }
    else ;
    
#line 359 
    vf->rx_filter_id = -1;
  }
  else ;
  
#line 362 
  if (! vf->rx_filtering) 
#line 363 
                          goto return_label;
  else {
    bool tmp;
    
#line 362 
    tmp = is_zero_ether_addr((u8 const *)(& vf->addr.mac_addr));
    
#line 362 
    if ((int)tmp != 0) 
#line 363 
                       goto return_label; else ;
  }
  
#line 365 
  if (0 != 0) 
#line 365 
              vlan = (unsigned short)((unsigned int)((unsigned short)(((int)vf->addr.tci << 8) | ((int)vf->addr.tci >> 8))) & 4095U);
  else {
    __u16 tmp_0;
    
#line 365 
    tmp_0 = __fswab16((unsigned short)((int)vf->addr.tci));
    
#line 365 
    vlan = (unsigned short)((unsigned int)tmp_0 & 4095U);
  }
  
#line 367 
  tmp_1 = abs_index(vf,vf->rx_filter_qid);
  
#line 366 
  ;
  
#line 366 
  efx_filter_init_rx(& filter,(enum efx_filter_priority)EFX_FILTER_PRI_REQUIRED,vf->rx_filter_flags,tmp_1);
  
#line 369 
  ;
  
#line 369 
  if ((unsigned int)vlan != 0U) 
#line 369 
                                tmp_2 = (unsigned int)vlan; else 
#line 369 
                                                                 tmp_2 = 65535U;
  
#line 369 
  rc = efx_filter_set_eth_local(& filter,(unsigned short)((int)tmp_2),(u8 const *)(& vf->addr.mac_addr));
  
#line 372 
  if ((long)(rc != 0) != 0L) {
    
#line 374 
    ldv_inline_asm();
    
#line 372 
    ;
  }
  else ;
  
#line 374 
  rc = efx_filter_insert_filter(efx,& filter,(_Bool)1);
  
#line 375 
  if (rc < 0) {
    
#line 376 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 376 
                                         netdev_warn((struct net_device const *)efx->net_dev,"Unable to insert rx filter for vf %s\n",(char *)(& vf->pci_name)); else ;
  }
  else {
    
#line 380 
    if ((efx->msg_enable & 8192U) != 0U) {
      
#line 380 
      struct _ddebug descriptor_0 = {.modname = "sfc", .function = "efx_siena_sriov_reset_rx_filter", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c", .format = "Inserted vf %s rx filter %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))381U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 380 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 380 
                                                            __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)efx->net_dev,"Inserted vf %s rx filter %d\n",(char *)(& vf->pci_name),rc); else ;
    }
    else ;
    
#line 382 
    vf->rx_filter_id = rc;
  }
  return_label: 
#line 384 
                return;
}


#line 386  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static void __efx_siena_sriov_update_vf_addr(struct siena_vf *vf)
{
  
#line 388 
  struct efx_nic *efx = vf->efx;
  
#line 389 
  struct siena_nic_data *nic_data = (struct siena_nic_data *)efx->nic_data;
  
#line 391 
  efx_siena_sriov_reset_tx_filter(vf);
  
#line 392 
  efx_siena_sriov_reset_rx_filter(vf);
  
#line 393 
  ldv_queue_work_97(vfdi_workqueue,& nic_data->peer_work);
  
#line 394 
  return;
}


#line 401  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static void __efx_siena_sriov_push_vf_status(struct siena_vf *vf)
{
  struct efx_memcpy_req copy[4U];
  struct efx_endpoint_page *epp;
  unsigned int pos;
  unsigned int count;
  unsigned int data_offset;
  efx_qword_t event;
  struct efx_endpoint_page *tmp_0;
  struct efx_endpoint_page *tmp_1;
  unsigned int tmp_2_0;
  
#line 403 
  struct efx_nic *efx = vf->efx;
  
#line 404 
  struct siena_nic_data *nic_data = (struct siena_nic_data *)efx->nic_data;
  
#line 405 
  struct vfdi_status *status = (struct vfdi_status *)nic_data->vfdi_status.addr;
  {
    int tmp;
    
#line 412 
    tmp = ldv_mutex_is_locked_98(& vf->status_lock);
    
#line 412 
    int __ret_warn_on = tmp == 0;
    
#line 412 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 412 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c",412); else ;
    
#line 412 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  {
    
#line 413 
    int __ret_warn_on_0 = vf->status_addr == 0ULL;
    
#line 413 
    if ((long)(__ret_warn_on_0 != 0) != 0L) 
#line 413 
                                            warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c",413); else ;
    
#line 413 
    long tmp_4 = (long)(__ret_warn_on_0 != 0);
  }
  
#line 415 
  status->local = vf->addr;
  
#line 416 
  status->generation_start += 1U;
  
#line 416 
  status->generation_end = status->generation_start;
  
#line 418 
  memset((void *)(& copy),0,192UL);
  
#line 420 
  copy[0].from_buf = (void *)(& status->generation_start);
  
#line 421 
  copy[0].to_rid = vf->pci_rid;
  
#line 422 
  copy[0].to_addr = vf->status_addr;
  
#line 424 
  copy[0].length = 4U;
  
#line 429 
  data_offset = 8U;
  
#line 430 
  copy[1].from_rid = (efx->pci_dev)->devfn;
  
#line 431 
  copy[1].from_addr = nic_data->vfdi_status.dma_addr + (unsigned long long)data_offset;
  
#line 432 
  copy[1].to_rid = vf->pci_rid;
  
#line 433 
  copy[1].to_addr = vf->status_addr + (unsigned long long)data_offset;
  
#line 434 
  copy[1].length = status->length - data_offset;
  
#line 437 
  pos = 2U;
  
#line 438 
  count = 0U;
  {
    
#line 439 
    struct list_head const *__mptr = (struct list_head const *)nic_data->local_page_list.next;
    
#line 439 
    tmp_0 = (struct efx_endpoint_page *)__mptr;
  }
  
#line 439 
  epp = tmp_0;
  
#line 439 
  goto ldv_57026;
  ldv_57025: 
#line 440 
  ;
  
#line 440 
  if (vf->peer_page_count == count) 
#line 444 
                                    goto ldv_57018; else ;
  
#line 446 
  copy[pos].from_buf = (void *)0;
  
#line 447 
  copy[pos].from_rid = (efx->pci_dev)->devfn;
  
#line 448 
  copy[pos].from_addr = epp->addr;
  
#line 449 
  copy[pos].to_rid = vf->pci_rid;
  
#line 450 
  copy[pos].to_addr = *(vf->peer_page_addrs + count);
  
#line 451 
  copy[pos].length = 4096U;
  
#line 453 
  pos += 1U;
  
#line 453 
  if (pos == 4U) {
    
#line 454 
    efx_siena_sriov_memcpy(efx,(struct efx_memcpy_req *)(& copy),4U);
    
#line 455 
    pos = 0U;
  }
  else ;
  
#line 457 
  count += 1U;
  {
    
#line 439 
    struct list_head const *__mptr_0 = (struct list_head const *)epp->link.next;
    
#line 439 
    tmp_1 = (struct efx_endpoint_page *)__mptr_0;
  }
  
#line 439 
  epp = tmp_1;
  ldv_57026: 
#line 441 
  ;
  
#line 439 
  if (& epp->link != & nic_data->local_page_list) 
#line 441 
                                                  goto ldv_57025; else 
                                                                    
#line 444 
                                                                    goto ldv_57018;
  ldv_57018: 
#line 445 
  ;
  
#line 461 
  copy[pos].from_buf = (void *)(& status->generation_end);
  
#line 462 
  copy[pos].to_rid = vf->pci_rid;
  
#line 463 
  copy[pos].to_addr = vf->status_addr + 4ULL;
  
#line 465 
  copy[pos].length = 4U;
  
#line 466 
  efx_siena_sriov_memcpy(efx,(struct efx_memcpy_req *)(& copy),pos + 1U);
  
#line 469 
  event.u64[0] = (((unsigned long long)vf->msg_seqno << 24) & 4294967295ULL) | 9223372036855037952ULL;
  
#line 473 
  vf->msg_seqno += 1U;
  
#line 475 
  tmp_2_0 = efx_vf_size(efx);
  
#line 474 
  ;
  
#line 474 
  ;
  
#line 474 
  efx_farch_generate_event(efx,vf->index * tmp_2_0 + 128U,& event);
  
#line 477 
  return;
}


#line 479  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static void efx_siena_sriov_bufs(struct efx_nic *efx, unsigned int offset, u64 *addr, unsigned int count)
{
  efx_qword_t buf;
  unsigned int pos;
  
#line 485 
  pos = 0U;
  
#line 485 
  goto ldv_57036;
  ldv_57035: 
#line 486 
  ;
  
#line 486 
  if (addr != (u64 *)0ULL) 
#line 486 
                           buf.u64[0] = (*(addr + pos) >> 12) << 14; else 
                                                                    
#line 486 
                                                                    buf.u64[0] = 0ULL;
  
#line 491 
  efx_sram_writeq_0(efx,efx->membase + 8388608U,(efx_qword_t const *)(& buf),offset + pos);
  
#line 485 
  pos += 1U;
  ldv_57036: 
#line 486 
  ;
  
#line 485 
  if (pos < count) 
#line 487 
                   goto ldv_57035; else 
#line 490 
                                        goto ldv_57037;
  ldv_57037: 
#line 491 
  ;
  
#line 492 
  return;
}


#line 496  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static bool bad_vf_index(struct efx_nic *efx, unsigned int index)
{
  bool __retres;
  unsigned int tmp;
  
#line 498 
  tmp = efx_vf_size(efx);
  
#line 498 
  ;
  
#line 498 
  __retres = (_Bool)(tmp <= index);
  
#line 498 
  return __retres;
}


#line 501  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static bool bad_buf_count(unsigned int buf_count, unsigned int max_entry_count)
{
  bool __retres;
  
#line 503 
  unsigned int max_buf_count = (unsigned int)(((unsigned long)max_entry_count * 8UL) / 4096UL);
  
#line 506 
  __retres = (_Bool)((((buf_count + 4294967295U) & buf_count) != 0U || buf_count > max_buf_count) != 0);
  
#line 506 
  return __retres;
}


#line 512  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static bool map_vi_index(struct efx_nic *efx, unsigned int abs_index_0, struct siena_vf **vf_out, unsigned int *rel_index_out)
{
  bool __retres;
  unsigned int vf_i;
  unsigned int tmp;
  
#line 515 
  struct siena_nic_data *nic_data = (struct siena_nic_data *)efx->nic_data;
  
#line 518 
  if (abs_index_0 <= 127U) {
    
#line 519 
    __retres = (_Bool)1;
    
#line 519 
    goto return_label;
  }
  else ;
  
#line 520 
  tmp = efx_vf_size(efx);
  
#line 520 
  vf_i = (abs_index_0 + 4294967168U) / tmp;
  
#line 521 
  if (efx->vf_init_count <= vf_i) {
    
#line 522 
    __retres = (_Bool)1;
    
#line 522 
    goto return_label;
  }
  else ;
  
#line 524 
  if (vf_out != (struct siena_vf **)0) 
#line 525 
                                       *vf_out = nic_data->vf + vf_i; else ;
  
#line 526 
  if (rel_index_out != (unsigned int *)0U) {
    unsigned int tmp_0;
    
#line 527 
    tmp_0 = efx_vf_size(efx);
    
#line 527 
    *rel_index_out = abs_index_0 % tmp_0;
  }
  else ;
  
#line 528 
  __retres = (_Bool)0;
  return_label: 
#line 528 
                return __retres;
}


#line 531  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static int efx_vfdi_init_evq(struct siena_vf *vf)
{
  int __retres;
  efx_oword_t reg;
  bool tmp_1;
  unsigned long tmp_3;
  
#line 533 
  struct efx_nic *efx = vf->efx;
  
#line 534 
  struct vfdi_req *req = (struct vfdi_req *)vf->buf.addr;
  
#line 535 
  unsigned int vf_evq = req->u.init_evq.index;
  
#line 536 
  unsigned int buf_count = req->u.init_evq.buf_count;
  
#line 537 
  unsigned int abs_evq = abs_index(vf,vf_evq);
  
#line 538 
  unsigned int buftbl = (vf->buftbl_base + vf_evq * 32U) + 16U;
  
#line 541 
  tmp_1 = bad_vf_index(efx,vf_evq);
  
#line 541 
  if ((int)tmp_1 != 0) 
#line 541 
                       goto _LOR;
  else {
    bool tmp_2;
    
#line 541 
    tmp_2 = bad_buf_count(buf_count,8192U);
    
#line 541 
    if ((int)tmp_2 != 0) {
      _LOR: {
              int tmp_0;
              
#line 543 
              tmp_0 = net_ratelimit();
              
#line 543 
              if (tmp_0 != 0) {
                
#line 544 
                if ((efx->msg_enable & 8192U) != 0U) 
#line 544 
                                                     netdev_err((struct net_device const *)efx->net_dev,"ERROR: Invalid INIT_EVQ from %s: evq %d bufs %d\n",(char *)(& vf->pci_name),vf_evq,buf_count); else ;
              }
              else ;
              
#line 547 
              __retres = -22;
              
#line 547 
              goto return_label;
            }
    }
    else ;
  }
  
#line 550 
  efx_siena_sriov_bufs(efx,buftbl,(u64 *)(& req->u.init_evq.addr),buf_count);
  
#line 552 
  reg.u64[0] = 8589934592ULL;
  
#line 552 
  reg.u64[1] = 0ULL;
  
#line 556 
  efx_writeo_table_0(efx,(efx_oword_t const *)(& reg),16187392U,abs_evq);
  
#line 557 
  tmp_3 = __ffs((unsigned long)buf_count);
  
#line 557 
  reg.u64[0] = (((unsigned long long)tmp_3 << 20) | (unsigned long long)buftbl) | 8388608ULL;
  
#line 557 
  reg.u64[1] = 0ULL;
  
#line 561 
  efx_writeo_table_0(efx,(efx_oword_t const *)(& reg),16121856U,abs_evq);
  
#line 563 
  if (vf_evq == 0U) {
    
#line 564 
    memcpy((void *)(& vf->evq0_addrs),(void const *)(& req->u.init_evq.addr),(unsigned long)buf_count * 8UL);
    
#line 566 
    vf->evq0_count = buf_count;
  }
  else ;
  
#line 569 
  __retres = 0;
  return_label: 
#line 569 
                return __retres;
}


#line 572  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static int efx_vfdi_init_rxq(struct siena_vf *vf)
{
  int __retres;
  unsigned int label;
  efx_oword_t reg;
  bool tmp_0;
  int tmp_3;
  unsigned int tmp_4;
  unsigned long tmp_5;
  unsigned int tmp_6;
  
#line 574 
  struct efx_nic *efx = vf->efx;
  
#line 575 
  struct vfdi_req *req = (struct vfdi_req *)vf->buf.addr;
  
#line 576 
  unsigned int vf_rxq = req->u.init_rxq.index;
  
#line 577 
  unsigned int vf_evq = req->u.init_rxq.evq;
  
#line 578 
  unsigned int buf_count = req->u.init_rxq.buf_count;
  
#line 579 
  unsigned int buftbl = (vf->buftbl_base + vf_rxq * 32U) + 8U;
  
#line 583 
  tmp_0 = bad_vf_index(efx,vf_evq);
  
#line 583 
  if ((int)tmp_0 != 0) 
#line 583 
                       goto _LOR;
  else {
    bool tmp_1;
    
#line 583 
    tmp_1 = bad_vf_index(efx,vf_rxq);
    
#line 583 
    if ((int)tmp_1 != 0) 
#line 583 
                         goto _LOR;
    else 
      
#line 583 
      if (vf_rxq > 62U) 
#line 583 
                        goto _LOR;
      else {
        bool tmp_2;
        
#line 584 
        tmp_2 = bad_buf_count(buf_count,4096U);
        
#line 584 
        if ((int)tmp_2 != 0) {
          _LOR: {
                  int tmp;
                  
#line 586 
                  tmp = net_ratelimit();
                  
#line 586 
                  if (tmp != 0) {
                    
#line 587 
                    if ((efx->msg_enable & 8192U) != 0U) 
#line 587 
                                                         netdev_err((struct net_device const *)efx->net_dev,"ERROR: Invalid INIT_RXQ from %s: rxq %d evq %d ",(char *)(& vf->pci_name),vf_rxq,vf_evq,buf_count); else ;
                  }
                  else ;
                  
#line 591 
                  __retres = -22;
                  
#line 591 
                  goto return_label;
                }
        }
        else ;
      }
  }
  
#line 593 
  tmp_3 = __test_and_set_bit((long)req->u.init_rxq.index,(unsigned long volatile *)(& vf->rxq_mask));
  
#line 593 
  if (tmp_3 != 0) 
#line 594 
                  vf->rxq_count += 1U; else ;
  
#line 595 
  efx_siena_sriov_bufs(efx,buftbl,(u64 *)(& req->u.init_rxq.addr),buf_count);
  
#line 597 
  label = req->u.init_rxq.label & 31U;
  
#line 598 
  tmp_4 = abs_index(vf,vf_evq);
  
#line 598 
  tmp_5 = __ffs((unsigned long)buf_count);
  
#line 598 
  reg.u64[0] = ((((((unsigned long long)buftbl << 36) | ((unsigned long long)tmp_4 << 24)) | ((unsigned long long)label << 5)) | ((unsigned long long)tmp_5 << 3)) | (((unsigned long long)req->u.init_rxq.flags << 1) & 2ULL)) | 1ULL;
  
#line 598 
  reg.u64[1] = 0ULL;
  
#line 607 
  tmp_6 = abs_index(vf,vf_rxq);
  
#line 607 
  ;
  
#line 607 
  efx_writeo_table_0(efx,(efx_oword_t const *)(& reg),15990784U,tmp_6);
  
#line 610 
  __retres = 0;
  return_label: 
#line 610 
                return __retres;
}


#line 613  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static int efx_vfdi_init_txq(struct siena_vf *vf)
{
  int __retres;
  unsigned int label;
  unsigned int eth_filt_en;
  efx_oword_t reg;
  bool tmp_0;
  int tmp_3;
  unsigned int tmp_4;
  unsigned long tmp_5;
  unsigned int tmp_7;
  unsigned int tmp_8;
  
#line 615 
  struct efx_nic *efx = vf->efx;
  
#line 616 
  struct vfdi_req *req = (struct vfdi_req *)vf->buf.addr;
  
#line 617 
  unsigned int vf_txq = req->u.init_txq.index;
  
#line 618 
  unsigned int vf_evq = req->u.init_txq.evq;
  
#line 619 
  unsigned int buf_count = req->u.init_txq.buf_count;
  
#line 620 
  unsigned int buftbl = vf->buftbl_base + vf_txq * 32U;
  
#line 624 
  tmp_0 = bad_vf_index(efx,vf_evq);
  
#line 624 
  if ((int)tmp_0 != 0) 
#line 624 
                       goto _LOR;
  else {
    bool tmp_1;
    
#line 624 
    tmp_1 = bad_vf_index(efx,vf_txq);
    
#line 624 
    if ((int)tmp_1 != 0) 
#line 624 
                         goto _LOR;
    else 
      
#line 624 
      if (vf_txq >= vf_max_tx_channels) 
#line 624 
                                        goto _LOR;
      else {
        bool tmp_2;
        
#line 625 
        tmp_2 = bad_buf_count(buf_count,4096U);
        
#line 625 
        if ((int)tmp_2 != 0) {
          _LOR: {
                  int tmp;
                  
#line 627 
                  tmp = net_ratelimit();
                  
#line 627 
                  if (tmp != 0) {
                    
#line 628 
                    if ((efx->msg_enable & 8192U) != 0U) 
#line 628 
                                                         netdev_err((struct net_device const *)efx->net_dev,"ERROR: Invalid INIT_TXQ from %s: txq %d evq %d ",(char *)(& vf->pci_name),vf_txq,vf_evq,buf_count); else ;
                  }
                  else ;
                  
#line 632 
                  __retres = -22;
                  
#line 632 
                  goto return_label;
                }
        }
        else ;
      }
  }
  
#line 635 
  ldv_mutex_lock_99(& vf->txq_lock);
  
#line 636 
  tmp_3 = __test_and_set_bit((long)req->u.init_txq.index,(unsigned long volatile *)(& vf->txq_mask));
  
#line 636 
  if (tmp_3 != 0) 
#line 637 
                  vf->txq_count += 1U; else ;
  
#line 638 
  ldv_mutex_unlock_100(& vf->txq_lock);
  
#line 639 
  efx_siena_sriov_bufs(efx,buftbl,(u64 *)(& req->u.init_txq.addr),buf_count);
  
#line 641 
  eth_filt_en = (unsigned int)(vf->tx_filter_mode == (unsigned int)VF_TX_FILTER_ON);
  
#line 643 
  label = req->u.init_txq.label & 31U;
  
#line 644 
  tmp_4 = abs_index(vf,vf_evq);
  
#line 644 
  tmp_5 = __ffs((unsigned long)buf_count);
  
#line 644 
  reg.u64[0] = ((((unsigned long long)buftbl << 36) | ((unsigned long long)tmp_4 << 24)) | ((unsigned long long)label << 5)) | ((unsigned long long)tmp_5 << 3);
  {
    unsigned int tmp_6;
    
#line 644 
    unsigned int _min1 = efx->vi_scale;
    
#line 644 
    unsigned int _min2 = 1U;
    
#line 644 
    if (_min1 < _min2) 
#line 644 
                       tmp_6 = _min1; else 
#line 644 
                                           tmp_6 = _min2;
    
#line 644 
    tmp_7 = tmp_6;
  }
  
#line 644 
  reg.u64[1] = (((unsigned long long)tmp_7 << 30) | ((unsigned long long)eth_filt_en << 29)) | 150994944ULL;
  
#line 653 
  tmp_8 = abs_index(vf,vf_txq);
  
#line 653 
  ;
  
#line 653 
  efx_writeo_table_0(efx,(efx_oword_t const *)(& reg),16056320U,tmp_8);
  
#line 656 
  __retres = 0;
  return_label: 
#line 656 
                return __retres;
}


#line 660  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static bool efx_vfdi_flush_wake(struct siena_vf *vf)
{
  bool __retres;
  int tmp_0;
  
#line 662 
  ldv_inline_asm();
  
#line 665 
  if (vf->txq_count == 0U && vf->rxq_count == 0U) 
#line 665 
                                                  tmp_0 = 1;
  else {
    int tmp;
    
#line 665 
    tmp = atomic_read((atomic_t const *)(& vf->rxq_retry_count));
    
#line 665 
    if (tmp != 0) 
#line 665 
                  tmp_0 = 1; else 
#line 665 
                                  tmp_0 = 0;
  }
  
#line 665 
  __retres = (_Bool)(tmp_0 != 0);
  
#line 665 
  return __retres;
}


#line 669  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static void efx_vfdi_flush_clear(struct siena_vf *vf)
{
  
#line 671 
  memset((void *)(& vf->txq_mask),0,8UL);
  
#line 672 
  vf->txq_count = 0U;
  
#line 673 
  memset((void *)(& vf->rxq_mask),0,8UL);
  
#line 674 
  vf->rxq_count = 0U;
  
#line 675 
  memset((void *)(& vf->rxq_retry_mask),0,8UL);
  
#line 676 
  atomic_set(& vf->rxq_retry_count,0);
  
#line 677 
  return;
}


#line 690 
void __compiletime_assert_691(void);


#line 679  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static int efx_vfdi_fini_all_queues(struct siena_vf *vf)
{
  efx_oword_t reg;
  unsigned int tmp_0;
  unsigned int index;
  unsigned int rxqs_count;
  int rc;
  int tmp_3;
  int tmp_6;
  long tmp_13;
  int tmp_14;
  unsigned int tmp_15;
  int tmp_16;
  
#line 681 
  struct efx_nic *efx = vf->efx;
  
#line 683 
  unsigned int count = efx_vf_size(efx);
  
#line 684 
  tmp_0 = efx_vf_size(efx);
  
#line 684 
  unsigned int vf_offset = vf->index * tmp_0 + 128U;
  
#line 685 
  unsigned int timeout = 250U;
  
#line 687 
  efx_dword_t inbuf[63U] = {{.u32 = {0U}}};
  {
    
#line 690 
    bool __cond = (_Bool)0;
    
#line 690 
    if ((int)__cond != 0) 
#line 690 
                          __compiletime_assert_691(); else ;
  }
  
#line 693 
  rtnl_lock();
  
#line 694 
  siena_prepare_flush(efx);
  
#line 695 
  rtnl_unlock();
  
#line 698 
  rxqs_count = 0U;
  
#line 699 
  index = 0U;
  
#line 699 
  goto ldv_57153;
  ldv_57152: 
#line 700 
  ;
  
#line 700 
  if (0 != 0) {
    int tmp_1;
    
#line 700 
    tmp_1 = constant_test_bit((long)index,(unsigned long const volatile *)(& vf->txq_mask));
    
#line 700 
    tmp_3 = tmp_1 != 0;
  }
  else {
    int tmp_2;
    
#line 700 
    tmp_2 = variable_test_bit((long)index,(unsigned long const volatile *)(& vf->txq_mask));
    
#line 700 
    tmp_3 = tmp_2 != 0;
  }
  
#line 700 
  if (tmp_3) {
    
#line 701 
    reg.u64[0] = (unsigned long long)((vf_offset + index) | 4096U);
    
#line 701 
    reg.u64[1] = 0ULL;
    
#line 705 
    efx_writeo_1(efx,(efx_oword_t const *)(& reg),2560U);
  }
  else ;
  
#line 707 
  if (0 != 0) {
    int tmp_4;
    
#line 707 
    tmp_4 = constant_test_bit((long)index,(unsigned long const volatile *)(& vf->rxq_mask));
    
#line 707 
    tmp_6 = tmp_4 != 0;
  }
  else {
    int tmp_5;
    
#line 707 
    tmp_5 = variable_test_bit((long)index,(unsigned long const volatile *)(& vf->rxq_mask));
    
#line 707 
    tmp_6 = tmp_5 != 0;
  }
  
#line 707 
  if (tmp_6) {
    
#line 708 
    ((efx_dword_t *)(& inbuf) + (unsigned long)rxqs_count * 4UL)->u32[0] = vf_offset + index;
    
#line 711 
    rxqs_count += 1U;
  }
  else ;
  
#line 699 
  index += 1U;
  ldv_57153: 
#line 700 
  ;
  
#line 699 
  if (index < count) 
#line 701 
                     goto ldv_57152; else 
#line 704 
                                          goto ldv_57154;
  ldv_57154: 
#line 705 
  ;
  
#line 715 
  atomic_set(& vf->rxq_retry_count,0);
  
#line 716 
  goto ldv_57192;
  ldv_57191: 
#line 717 
  ;
  
#line 717 
  rc = efx_mcdi_rpc(efx,39U,(efx_dword_t const *)(& inbuf),(unsigned long)(rxqs_count * 4U),(efx_dword_t *)0,0UL,(size_t *)0UL);
  {
    
#line 720 
    int __ret_warn_on = rc < 0;
    
#line 720 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 720 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c",720); else ;
    
#line 720 
    long tmp_7 = (long)(__ret_warn_on != 0);
  }
  {
    
#line 722 
    long __ret = (long)timeout;
    
#line 722 
    __might_sleep("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c",724,0);
    {
      int tmp_12;
      {
        
#line 722 
        bool __cond_1 = efx_vfdi_flush_wake(vf);
        
#line 722 
        if ((int)__cond_1 != 0 && __ret == 0L) 
#line 722 
                                               __ret = 1L; else ;
        
#line 722 
        tmp_12 = ((int)__cond_1 != 0 || __ret == 0L) != 0;
      }
      
#line 722 
      if (tmp_12 == 0) {
        long tmp_10;
        {
          wait_queue_t __wait;
          
#line 722 
          long __ret_0 = (long)timeout;
          
#line 722 
          INIT_LIST_HEAD(& __wait.task_list);
          
#line 722 
          __wait.flags = 0U;
          ldv_57167: 
#line 725 
          ;
          {
            int tmp_9;
            
#line 722 
            long __int = prepare_to_wait_event(& vf->flush_waitq,& __wait,2);
            {
              
#line 722 
              bool __cond_0 = efx_vfdi_flush_wake(vf);
              
#line 722 
              if ((int)__cond_0 != 0 && __ret_0 == 0L) 
#line 722 
                                                       __ret_0 = 1L; else ;
              
#line 722 
              tmp_9 = ((int)__cond_0 != 0 || __ret_0 == 0L) != 0;
            }
            
#line 722 
            if (tmp_9 != 0) 
#line 722 
                            goto ldv_57166; else ;
            
#line 722 
            __ret_0 = schedule_timeout(__ret_0);
          }
          
#line 722 
          goto ldv_57167;
          ldv_57166: 
#line 723 
          ;
          
#line 722 
          finish_wait(& vf->flush_waitq,& __wait);
          __out_0: 
#line 722 
          ;
          
#line 722 
          tmp_10 = __ret_0;
        }
        
#line 722 
        __ret = tmp_10;
      }
      else ;
    }
    
#line 722 
    tmp_13 = __ret;
  }
  
#line 722 
  timeout = (unsigned int)tmp_13;
  
#line 725 
  rxqs_count = 0U;
  
#line 726 
  index = 0U;
  
#line 726 
  goto ldv_57189;
  ldv_57188: 
#line 727 
  ;
  
#line 727 
  tmp_14 = test_and_set_bit((long)index,(unsigned long volatile *)(& vf->rxq_retry_mask));
  
#line 727 
  if (tmp_14 != 0) {
    
#line 728 
    atomic_dec_1(& vf->rxq_retry_count);
    
#line 729 
    ((efx_dword_t *)(& inbuf) + (unsigned long)rxqs_count * 4UL)->u32[0] = vf_offset + index;
    
#line 732 
    rxqs_count += 1U;
  }
  else ;
  
#line 726 
  index += 1U;
  ldv_57189: 
#line 727 
  ;
  
#line 726 
  if (index < count) 
#line 728 
                     goto ldv_57188; else 
#line 731 
                                          goto ldv_57190;
  ldv_57190: 
#line 732 
  ;
  ldv_57192: 
#line 733 
  ;
  
#line 716 
  if (timeout != 0U && (vf->rxq_count != 0U || vf->txq_count != 0U)) 
    
#line 718 
    goto ldv_57191; else 
#line 721 
                         goto ldv_57193;
  ldv_57193: 
#line 722 
  ;
  
#line 737 
  rtnl_lock();
  
#line 738 
  siena_finish_flush(efx);
  
#line 739 
  rtnl_unlock();
  
#line 742 
  reg.u64[0] = 0ULL;
  
#line 742 
  reg.u64[1] = 0ULL;
  
#line 743 
  index = 0U;
  
#line 743 
  goto ldv_57195;
  ldv_57194: 
#line 744 
  ;
  
#line 744 
  efx_writeo_table_0(efx,(efx_oword_t const *)(& reg),15990784U,vf_offset + index);
  
#line 746 
  efx_writeo_table_0(efx,(efx_oword_t const *)(& reg),16056320U,vf_offset + index);
  
#line 748 
  efx_writeo_table_0(efx,(efx_oword_t const *)(& reg),16121856U,vf_offset + index);
  
#line 750 
  efx_writeo_table_0(efx,(efx_oword_t const *)(& reg),16187392U,vf_offset + index);
  
#line 743 
  index += 1U;
  ldv_57195: 
#line 744 
  ;
  
#line 743 
  if (index < count) 
#line 745 
                     goto ldv_57194; else 
#line 748 
                                          goto ldv_57196;
  ldv_57196: 
#line 749 
  ;
  
#line 753 
  tmp_15 = efx_vf_size(efx);
  
#line 753 
  ;
  
#line 753 
  ;
  
#line 753 
  efx_siena_sriov_bufs(efx,vf->buftbl_base,(u64 *)0ULL,tmp_15 * 32U);
  
#line 755 
  efx_vfdi_flush_clear(vf);
  
#line 757 
  vf->evq0_count = 0U;
  
#line 759 
  if (timeout != 0U) 
#line 759 
                     tmp_16 = 0; else 
#line 759 
                                      tmp_16 = -110;
  
#line 759 
  return tmp_16;
}


#line 762  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static int efx_vfdi_insert_filter(struct siena_vf *vf)
{
  int __retres;
  unsigned int flags;
  bool tmp_0;
  
#line 764 
  struct efx_nic *efx = vf->efx;
  
#line 765 
  struct siena_nic_data *nic_data = (struct siena_nic_data *)efx->nic_data;
  
#line 766 
  struct vfdi_req *req = (struct vfdi_req *)vf->buf.addr;
  
#line 767 
  unsigned int vf_rxq = req->u.mac_filter.rxq;
  
#line 770 
  tmp_0 = bad_vf_index(efx,vf_rxq);
  
#line 770 
  if ((int)tmp_0 != 0) 
#line 770 
                       goto _LOR;
  else 
    
#line 770 
    if ((int)vf->rx_filtering != 0) {
      _LOR: {
              int tmp;
              
#line 771 
              tmp = net_ratelimit();
              
#line 771 
              if (tmp != 0) {
                
#line 772 
                if ((efx->msg_enable & 8192U) != 0U) 
#line 772 
                                                     netdev_err((struct net_device const *)efx->net_dev,"ERROR: Invalid INSERT_FILTER from %s: rxq %d ",(char *)(& vf->pci_name),vf_rxq,req->u.mac_filter.flags); else ;
              }
              else ;
              
#line 776 
              __retres = -22;
              
#line 776 
              goto return_label;
            }
    }
    else ;
  
#line 779 
  flags = 0U;
  
#line 780 
  if ((req->u.mac_filter.flags & 1U) != 0U) 
#line 781 
                                            flags |= 1U; else ;
  
#line 782 
  if ((req->u.mac_filter.flags & 2U) != 0U) 
#line 783 
                                            flags |= 2U; else ;
  
#line 784 
  vf->rx_filter_flags = (enum efx_filter_flags)flags;
  
#line 785 
  vf->rx_filter_qid = vf_rxq;
  
#line 786 
  vf->rx_filtering = (_Bool)1;
  
#line 788 
  efx_siena_sriov_reset_rx_filter(vf);
  
#line 789 
  ldv_queue_work_101(vfdi_workqueue,& nic_data->peer_work);
  
#line 791 
  __retres = 0;
  return_label: 
#line 791 
                return __retres;
}


#line 794  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static int efx_vfdi_remove_all_filters(struct siena_vf *vf)
{
  int __retres;
  
#line 796 
  struct efx_nic *efx = vf->efx;
  
#line 797 
  struct siena_nic_data *nic_data = (struct siena_nic_data *)efx->nic_data;
  
#line 799 
  vf->rx_filtering = (_Bool)0;
  
#line 800 
  efx_siena_sriov_reset_rx_filter(vf);
  
#line 801 
  ldv_queue_work_102(vfdi_workqueue,& nic_data->peer_work);
  
#line 803 
  __retres = 0;
  
#line 803 
  return __retres;
}


#line 806  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static int efx_vfdi_set_status_page(struct siena_vf *vf)
{
  int __retres;
  
#line 808 
  struct efx_nic *efx = vf->efx;
  
#line 809 
  struct siena_nic_data *nic_data = (struct siena_nic_data *)efx->nic_data;
  
#line 810 
  struct vfdi_req *req = (struct vfdi_req *)vf->buf.addr;
  
#line 811 
  u64 page_count_0 = req->u.set_status_page.peer_page_count;
  
#line 812 
  u64 max_page_count = 508ULL;
  
#line 817 
  if (req->u.set_status_page.dma_addr == 0ULL || page_count_0 > max_page_count) {
    int tmp;
    
#line 818 
    tmp = net_ratelimit();
    
#line 818 
    if (tmp != 0) {
      
#line 819 
      if ((efx->msg_enable & 8192U) != 0U) 
#line 819 
                                           netdev_err((struct net_device const *)efx->net_dev,"ERROR: Invalid SET_STATUS_PAGE from %s\n",(char *)(& vf->pci_name)); else ;
    }
    else ;
    
#line 822 
    __retres = -22;
    
#line 822 
    goto return_label;
  }
  else ;
  
#line 825 
  ldv_mutex_lock_103(& nic_data->local_lock);
  
#line 826 
  ldv_mutex_lock_104(& vf->status_lock);
  
#line 827 
  vf->status_addr = req->u.set_status_page.dma_addr;
  
#line 829 
  kfree((void const *)vf->peer_page_addrs);
  
#line 830 
  vf->peer_page_addrs = (u64 *)0ULL;
  
#line 831 
  vf->peer_page_count = 0U;
  
#line 833 
  if (page_count_0 != 0ULL) {
    
#line 834 
    vf->peer_page_addrs = (u64 *)kcalloc_7((unsigned long)page_count_0,8UL,208U);
    
#line 836 
    if (vf->peer_page_addrs != (u64 *)0ULL) {
      
#line 837 
      memcpy((void *)vf->peer_page_addrs,(void const *)(& req->u.set_status_page.peer_page_addr),(unsigned long)(page_count_0 * 8ULL));
      
#line 840 
      vf->peer_page_count = (unsigned int)page_count_0;
    }
    else ;
  }
  else ;
  
#line 844 
  __efx_siena_sriov_push_vf_status(vf);
  
#line 845 
  ldv_mutex_unlock_105(& vf->status_lock);
  
#line 846 
  ldv_mutex_unlock_106(& nic_data->local_lock);
  
#line 848 
  __retres = 0;
  return_label: 
#line 848 
                return __retres;
}


#line 851  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static int efx_vfdi_clear_status_page(struct siena_vf *vf)
{
  int __retres;
  
#line 853 
  ldv_mutex_lock_107(& vf->status_lock);
  
#line 854 
  vf->status_addr = 0ULL;
  
#line 855 
  ldv_mutex_unlock_108(& vf->status_lock);
  
#line 857 
  __retres = 0;
  
#line 857 
  return __retres;
}


#line 862  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static efx_vfdi_op_t vfdi_ops[9U] = {[1] = & efx_vfdi_init_evq, & efx_vfdi_init_rxq, & efx_vfdi_init_txq, & efx_vfdi_fini_all_queues, & efx_vfdi_insert_filter, & efx_vfdi_remove_all_filters, & efx_vfdi_set_status_page, & efx_vfdi_clear_status_page};

#line 873  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static void efx_siena_sriov_vfdi(struct work_struct *work)
{
  struct siena_vf *tmp;
  struct efx_memcpy_req copy[2U];
  int rc;
  {
    
#line 875 
    struct work_struct const *__mptr = (struct work_struct const *)work;
    
#line 875 
    tmp = (struct siena_vf *)__mptr + 18446744073709551584U;
  }
  
#line 875 
  struct siena_vf *vf = tmp;
  
#line 876 
  struct efx_nic *efx = vf->efx;
  
#line 877 
  struct vfdi_req *req = (struct vfdi_req *)vf->buf.addr;
  
#line 882 
  memset((void *)(& copy),0,96UL);
  
#line 883 
  copy[0].from_rid = vf->pci_rid;
  
#line 884 
  copy[0].from_addr = vf->req_addr;
  
#line 885 
  copy[0].to_rid = (efx->pci_dev)->devfn;
  
#line 886 
  copy[0].to_addr = vf->buf.dma_addr;
  
#line 887 
  copy[0].length = 4096U;
  
#line 888 
  rc = efx_siena_sriov_memcpy(efx,(struct efx_memcpy_req *)(& copy),1U);
  
#line 889 
  if (rc != 0) {
    int tmp_0;
    
#line 891 
    tmp_0 = net_ratelimit();
    
#line 891 
    if (tmp_0 != 0) {
      
#line 892 
      if ((efx->msg_enable & 8192U) != 0U) 
#line 892 
                                           netdev_err((struct net_device const *)efx->net_dev,"ERROR: Unable to fetch VFDI request from %s rc %d\n",(char *)(& vf->pci_name),- rc); else ;
    }
    else ;
    
#line 895 
    vf->busy = (_Bool)0;
    
#line 896 
    goto return_label;
  }
  else ;
  
#line 899 
  if (req->op <= 8U && vfdi_ops[req->op] != (int (*)(struct siena_vf *))0) {
    
#line 900 
    rc = (*(vfdi_ops[req->op]))(vf);
    
#line 901 
    if (rc == 0) {
      
#line 902 
      if ((efx->msg_enable & 8192U) != 0U) {
        
#line 902 
        struct _ddebug descriptor = {.modname = "sfc", .function = "efx_siena_sriov_vfdi", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c", .format = "vfdi request %d from %s ok\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))904U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 902 
        if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 902 
                                                            __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"vfdi request %d from %s ok\n",req->op,(char *)(& vf->pci_name)); else ;
      }
      else ;
    }
    else ;
  }
  else {
    
#line 907 
    if ((efx->msg_enable & 8192U) != 0U) {
      
#line 907 
      struct _ddebug descriptor_0 = {.modname = "sfc", .function = "efx_siena_sriov_vfdi", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c", .format = "ERROR: Unrecognised request %d from VF %s addr ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))910U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 907 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 907 
                                                            __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)efx->net_dev,"ERROR: Unrecognised request %d from VF %s addr ",req->op,(char *)(& vf->pci_name),vf->req_addr); else ;
    }
    else ;
    
#line 911 
    rc = -95;
  }
  
#line 915 
  vf->busy = (_Bool)0;
  
#line 916 
  ldv_inline_asm();
  
#line 919 
  req->rc = rc;
  
#line 920 
  req->op = 0U;
  
#line 922 
  memset((void *)(& copy),0,96UL);
  
#line 923 
  copy[0].from_buf = (void *)(& req->rc);
  
#line 924 
  copy[0].to_rid = vf->pci_rid;
  
#line 925 
  copy[0].to_addr = vf->req_addr + 8ULL;
  
#line 926 
  copy[0].length = 4U;
  
#line 927 
  copy[1].from_buf = (void *)(& req->op);
  
#line 928 
  copy[1].to_rid = vf->pci_rid;
  
#line 929 
  copy[1].to_addr = vf->req_addr;
  
#line 930 
  copy[1].length = 4U;
  
#line 932 
  efx_siena_sriov_memcpy(efx,(struct efx_memcpy_req *)(& copy),2U);
  return_label: 
#line 933 
                return;
}


#line 942  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static void efx_siena_sriov_reset_vf(struct siena_vf *vf, struct efx_buffer *buffer)
{
  struct efx_memcpy_req copy_req[4U];
  efx_qword_t event;
  unsigned int pos;
  unsigned int count;
  unsigned int k;
  unsigned int buftbl;
  unsigned int abs_evq;
  efx_oword_t reg;
  efx_dword_t ptr;
  int rc;
  unsigned int tmp_0;
  unsigned long tmp_2;
  
#line 945 
  struct efx_nic *efx = vf->efx;
  
#line 953 
  if ((long)(buffer->len != 4096U) != 0L) {
    
#line 955 
    ldv_inline_asm();
    
#line 953 
    ;
  }
  else ;
  
#line 955 
  if (vf->evq0_count == 0U) 
#line 956 
                            goto return_label; else ;
  
#line 957 
  if ((long)((vf->evq0_count & (vf->evq0_count + 4294967295U)) != 0U) != 0L) {
    
#line 959 
    ldv_inline_asm();
    
#line 957 
    ;
  }
  else ;
  
#line 959 
  ldv_mutex_lock_109(& vf->status_lock);
  
#line 960 
  event.u64[0] = ((unsigned long long)vf->msg_seqno << 24) | 9223372036855103488ULL;
  
#line 964 
  vf->msg_seqno += 1U;
  
#line 965 
  pos = 0U;
  
#line 965 
  goto ldv_57256;
  ldv_57255: 
#line 966 
  ;
  
#line 966 
  memcpy(buffer->addr + pos,(void const *)(& event),8UL);
  
#line 965 
  pos += 8U;
  ldv_57256: 
#line 966 
  ;
  
#line 965 
  if (pos <= 4095U) 
#line 967 
                    goto ldv_57255; else 
#line 970 
                                         goto ldv_57257;
  ldv_57257: 
#line 971 
  ;
  
#line 968 
  pos = 0U;
  
#line 968 
  goto ldv_57269;
  ldv_57268: 
#line 969 
  ;
  {
    unsigned int tmp;
    
#line 969 
    unsigned int __min1 = vf->evq0_count - pos;
    
#line 969 
    unsigned int __min2 = 4U;
    
#line 969 
    if (__min1 < __min2) 
#line 969 
                         tmp = __min1; else 
#line 969 
                                            tmp = __min2;
    
#line 969 
    tmp_0 = tmp;
  }
  
#line 969 
  count = tmp_0;
  
#line 971 
  k = 0U;
  
#line 971 
  goto ldv_57265;
  ldv_57264: 
#line 972 
  ;
  
#line 972 
  copy_req[k].from_buf = (void *)0;
  
#line 973 
  copy_req[k].from_rid = (efx->pci_dev)->devfn;
  
#line 974 
  copy_req[k].from_addr = buffer->dma_addr;
  
#line 975 
  copy_req[k].to_rid = vf->pci_rid;
  
#line 976 
  copy_req[k].to_addr = vf->evq0_addrs[pos + k];
  
#line 977 
  copy_req[k].length = 4096U;
  
#line 971 
  k += 1U;
  ldv_57265: 
#line 972 
  ;
  
#line 971 
  if (k < count) 
#line 973 
                 goto ldv_57264; else 
#line 976 
                                      goto ldv_57266;
  ldv_57266: 
#line 977 
  ;
  
#line 979 
  rc = efx_siena_sriov_memcpy(efx,(struct efx_memcpy_req *)(& copy_req),count);
  
#line 980 
  if (rc != 0) {
    int tmp_1;
    
#line 981 
    tmp_1 = net_ratelimit();
    
#line 981 
    if (tmp_1 != 0) {
      
#line 982 
      if ((efx->msg_enable & 8192U) != 0U) 
#line 982 
                                           netdev_err((struct net_device const *)efx->net_dev,"ERROR: Unable to notify %s of reset",(char *)(& vf->pci_name),- rc); else ;
    }
    else ;
    
#line 985 
    goto ldv_57267;
  }
  else ;
  
#line 968 
  pos += count;
  ldv_57269: 
#line 969 
  ;
  
#line 968 
  if (vf->evq0_count > pos) 
#line 970 
                            goto ldv_57268; else 
#line 973 
                                                 goto ldv_57267;
  ldv_57267: 
#line 974 
  ;
  
#line 990 
  abs_evq = abs_index(vf,0U);
  
#line 991 
  buftbl = vf->buftbl_base + 16U;
  
#line 992 
  efx_siena_sriov_bufs(efx,buftbl,(u64 *)(& vf->evq0_addrs),vf->evq0_count);
  
#line 994 
  reg.u64[0] = 8589934592ULL;
  
#line 994 
  reg.u64[1] = 0ULL;
  
#line 998 
  efx_writeo_table_0(efx,(efx_oword_t const *)(& reg),16187392U,abs_evq);
  
#line 999 
  tmp_2 = __ffs((unsigned long)vf->evq0_count);
  
#line 999 
  reg.u64[0] = (((unsigned long long)tmp_2 << 20) | (unsigned long long)buftbl) | 8388608ULL;
  
#line 999 
  reg.u64[1] = 0ULL;
  
#line 1003 
  efx_writeo_table_0(efx,(efx_oword_t const *)(& reg),16121856U,abs_evq);
  
#line 1004 
  ptr.u32[0] = 0U;
  
#line 1005 
  efx_writed(efx,(efx_dword_t const *)(& ptr),(abs_evq + 1024000U) * 16U);
  
#line 1007 
  ldv_mutex_unlock_110(& vf->status_lock);
  return_label: 
#line 1008 
                return;
}


#line 1010  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static void efx_siena_sriov_reset_vf_work(struct work_struct *work)
{
  struct siena_vf *tmp;
  struct efx_buffer buf;
  int tmp_0;
  {
    
#line 1012 
    struct work_struct const *__mptr = (struct work_struct const *)work;
    
#line 1012 
    tmp = (struct siena_vf *)__mptr + 18446744073709551584U;
  }
  
#line 1012 
  struct siena_vf *vf = tmp;
  
#line 1013 
  struct efx_nic *efx = vf->efx;
  
#line 1016 
  tmp_0 = efx_nic_alloc_buffer(efx,& buf,4096U,16U);
  
#line 1016 
  if (tmp_0 == 0) {
    
#line 1017 
    efx_siena_sriov_reset_vf(vf,& buf);
    
#line 1018 
    efx_nic_free_buffer(efx,& buf);
  }
  else ;
  
#line 1020 
  return;
}


#line 1022  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static void efx_siena_sriov_handle_no_channel(struct efx_nic *efx)
{
  
#line 1024 
  if ((efx->msg_enable & 1U) != 0U) 
#line 1024 
                                    netdev_err((struct net_device const *)efx->net_dev,"ERROR: IOV requires MSI-X and 1 additional interrupt"); else ;
  
#line 1027 
  efx->vf_count = 0U;
  
#line 1028 
  return;
}


#line 1030  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static int efx_siena_sriov_probe_channel(struct efx_channel *channel)
{
  int __retres;
  
#line 1032 
  struct siena_nic_data *nic_data = (struct siena_nic_data *)(channel->efx)->nic_data;
  
#line 1033 
  nic_data->vfdi_channel = channel;
  
#line 1035 
  __retres = 0;
  
#line 1035 
  return __retres;
}


#line 1039  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static void efx_siena_sriov_get_channel_name(struct efx_channel *channel, char *buf, size_t len)
{
  
#line 1042 
  snprintf(buf,len,"%s-iov",(char *)(& (channel->efx)->name));
  
#line 1043 
  return;
}


#line 1045  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static struct efx_channel_type const efx_siena_sriov_channel_type = {.handle_no_channel = & efx_siena_sriov_handle_no_channel, .pre_probe = & efx_siena_sriov_probe_channel, .post_remove = & efx_channel_dummy_op_void, .get_name = & efx_siena_sriov_get_channel_name, .copy = (struct efx_channel *(*)(struct efx_channel const *))0, .receive_skb = (bool (*)(struct efx_channel *, struct sk_buff *))0, .keep_eventq = (_Bool)1};

#line 1054  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
void efx_siena_sriov_probe(struct efx_nic *efx)
{
  unsigned int count;
  int tmp;
  
#line 1058 
  if (max_vfs == 0) 
#line 1059 
                    goto return_label; else ;
  
#line 1061 
  tmp = efx_siena_sriov_cmd(efx,(_Bool)0,& efx->vi_scale,& count);
  
#line 1061 
  if (tmp != 0) {
    
#line 1062 
    if ((efx->msg_enable & 2U) != 0U) 
#line 1062 
                                      netdev_info((struct net_device const *)efx->net_dev,"no SR-IOV VFs probed\n"); else ;
    
#line 1063 
    goto return_label;
  }
  else ;
  
#line 1065 
  if (count != 0U && count > (unsigned int)max_vfs) 
#line 1066 
                                                    count = (unsigned int)max_vfs; else ;
  
#line 1069 
  efx->vf_count = count;
  
#line 1071 
  efx->extra_channel_type[0] = & efx_siena_sriov_channel_type;
  return_label: 
#line 1072 
                return;
}


#line 1078  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static void efx_siena_sriov_peer_work(struct work_struct *data)
{
  struct siena_nic_data *tmp;
  struct siena_vf *vf;
  struct efx_local_addr *local_addr;
  struct vfdi_endpoint *peer;
  struct efx_endpoint_page *epp;
  struct list_head pages;
  unsigned int peer_space;
  unsigned int peer_count;
  unsigned int pos;
  struct efx_local_addr *tmp_3;
  struct efx_local_addr *tmp_7;
  struct efx_endpoint_page *tmp_8;
  int tmp_9;
  {
    
#line 1080 
    struct work_struct const *__mptr = (struct work_struct const *)data;
    
#line 1080 
    tmp = (struct siena_nic_data *)__mptr + 18446744073709550888U;
  }
  
#line 1080 
  struct siena_nic_data *nic_data = tmp;
  
#line 1083 
  struct efx_nic *efx = nic_data->efx;
  
#line 1084 
  struct vfdi_status *vfdi_status = (struct vfdi_status *)nic_data->vfdi_status.addr;
  
#line 1094 
  ldv_mutex_lock_111(& nic_data->local_lock);
  
#line 1097 
  INIT_LIST_HEAD(& pages);
  
#line 1098 
  list_splice_tail_init(& nic_data->local_page_list,& pages);
  
#line 1103 
  peer = (struct vfdi_endpoint *)(& vfdi_status->peers) + 1U;
  
#line 1104 
  peer_space = 255U;
  
#line 1105 
  peer_count = 1U;
  
#line 1106 
  pos = 0U;
  
#line 1106 
  goto ldv_57315;
  ldv_57314: 
#line 1107 
  ;
  
#line 1107 
  vf = nic_data->vf + pos;
  
#line 1109 
  ldv_mutex_lock_112(& vf->status_lock);
  
#line 1110 
  if ((int)vf->rx_filtering != 0) {
    int tmp_2;
    bool tmp_1;
    
#line 1110 
    tmp_1 = is_zero_ether_addr((u8 const *)(& vf->addr.mac_addr));
    
#line 1110 
    if (tmp_1) 
#line 1110 
               tmp_2 = 0; else 
#line 1110 
                               tmp_2 = 1;
    
#line 1110 
    if (tmp_2) {
      struct vfdi_endpoint *tmp_0;
      
#line 1111 
      tmp_0 = peer;
      
#line 1111 
      peer += 1;
      
#line 1111 
      *tmp_0 = vf->addr;
      
#line 1112 
      peer_count += 1U;
      
#line 1113 
      peer_space -= 1U;
      
#line 1114 
      if ((long)(peer_space == 0U) != 0L) {
        
#line 1116 
        ldv_inline_asm();
        
#line 1114 
        ;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 1116 
  ldv_mutex_unlock_113(& vf->status_lock);
  
#line 1106 
  pos += 1U;
  ldv_57315: 
#line 1107 
  ;
  
#line 1106 
  if (efx->vf_count > pos) 
#line 1108 
                           goto ldv_57314; else 
#line 1111 
                                                goto ldv_57316;
  ldv_57316: 
#line 1112 
  ;
  {
    
#line 1120 
    struct list_head const *__mptr_0 = (struct list_head const *)nic_data->local_addr_list.next;
    
#line 1120 
    tmp_3 = (struct efx_local_addr *)__mptr_0;
  }
  
#line 1120 
  local_addr = tmp_3;
  
#line 1120 
  goto ldv_57325;
  ldv_57324: 
#line 1121 
  ;
  
#line 1121 
  ether_addr_copy((u8 *)(& peer->mac_addr),(u8 const *)(& local_addr->addr));
  
#line 1122 
  peer->tci = (unsigned short)0U;
  
#line 1123 
  peer += 1;
  
#line 1124 
  peer_count += 1U;
  
#line 1125 
  peer_space -= 1U;
  
#line 1125 
  if (peer_space == 0U) {
    int tmp_6;
    
#line 1126 
    tmp_6 = list_empty((struct list_head const *)(& pages));
    
#line 1126 
    if (tmp_6 != 0) {
      
#line 1127 
      epp = (struct efx_endpoint_page *)kmalloc_2(32UL,208U);
      
#line 1128 
      if (epp == (struct efx_endpoint_page *)0) 
#line 1129 
                                                goto ldv_57321; else ;
      
#line 1130 
      epp->ptr = dma_alloc_attrs(& (efx->pci_dev)->dev,4096UL,& epp->addr,208U,(struct dma_attrs *)0);
      
#line 1133 
      if (epp->ptr == (void *)0) {
        
#line 1134 
        kfree((void const *)epp);
        
#line 1135 
        goto ldv_57321;
      }
      else ;
    }
    else {
      struct efx_endpoint_page *tmp_5;
      {
        
#line 1138 
        struct list_head const *__mptr_1 = (struct list_head const *)pages.next;
        
#line 1138 
        tmp_5 = (struct efx_endpoint_page *)__mptr_1;
      }
      
#line 1138 
      epp = tmp_5;
      
#line 1140 
      list_del(& epp->link);
    }
    
#line 1143 
    list_add_tail(& epp->link,& nic_data->local_page_list);
    
#line 1144 
    peer = (struct vfdi_endpoint *)epp->ptr;
    
#line 1145 
    peer_space = 512U;
  }
  else ;
  {
    
#line 1120 
    struct list_head const *__mptr_2 = (struct list_head const *)local_addr->link.next;
    
#line 1120 
    tmp_7 = (struct efx_local_addr *)__mptr_2;
  }
  
#line 1120 
  local_addr = tmp_7;
  ldv_57325: 
#line 1122 
  ;
  
#line 1120 
  if (& local_addr->link != & nic_data->local_addr_list) 
#line 1122 
                                                         goto ldv_57324; else 
                                                                    
#line 1125 
                                                                    goto ldv_57321;
  ldv_57321: 
#line 1126 
  ;
  
#line 1148 
  vfdi_status->peer_count = (unsigned short)peer_count;
  
#line 1149 
  ldv_mutex_unlock_114(& nic_data->local_lock);
  
#line 1152 
  goto ldv_57329;
  ldv_57328: 
#line 1153 
  ;
  {
    
#line 1153 
    struct list_head const *__mptr_3 = (struct list_head const *)pages.next;
    
#line 1153 
    tmp_8 = (struct efx_endpoint_page *)__mptr_3;
  }
  
#line 1153 
  epp = tmp_8;
  
#line 1155 
  list_del(& epp->link);
  
#line 1156 
  dma_free_attrs(& (efx->pci_dev)->dev,4096UL,epp->ptr,epp->addr,(struct dma_attrs *)0);
  
#line 1158 
  kfree((void const *)epp);
  ldv_57329: 
#line 1159 
  ;
  
#line 1152 
  tmp_9 = list_empty((struct list_head const *)(& pages));
  
#line 1152 
  if (tmp_9 == 0) 
#line 1154 
                  goto ldv_57328; else 
#line 1157 
                                       goto ldv_57330;
  ldv_57330: 
#line 1158 
  ;
  
#line 1162 
  pos = 0U;
  
#line 1162 
  goto ldv_57332;
  ldv_57331: 
#line 1163 
  ;
  
#line 1163 
  vf = nic_data->vf + pos;
  
#line 1165 
  ldv_mutex_lock_115(& vf->status_lock);
  
#line 1166 
  if (vf->status_addr != 0ULL) 
#line 1167 
                               __efx_siena_sriov_push_vf_status(vf); else ;
  
#line 1168 
  ldv_mutex_unlock_116(& vf->status_lock);
  
#line 1162 
  pos += 1U;
  ldv_57332: 
#line 1163 
  ;
  
#line 1162 
  if (efx->vf_count > pos) 
#line 1164 
                           goto ldv_57331; else 
#line 1167 
                                                goto ldv_57333;
  ldv_57333: 
#line 1168 
  ;
  
#line 1169 
  return;
}


#line 1172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static void efx_siena_sriov_free_local(struct efx_nic *efx)
{
  struct efx_local_addr *local_addr;
  struct efx_endpoint_page *epp;
  struct efx_local_addr *tmp;
  int tmp_0;
  struct efx_endpoint_page *tmp_1;
  int tmp_2;
  
#line 1174 
  struct siena_nic_data *nic_data = (struct siena_nic_data *)efx->nic_data;
  
#line 1178 
  goto ldv_57343;
  ldv_57342: 
#line 1179 
  ;
  {
    
#line 1179 
    struct list_head const *__mptr = (struct list_head const *)nic_data->local_addr_list.next;
    
#line 1179 
    tmp = (struct efx_local_addr *)__mptr;
  }
  
#line 1179 
  local_addr = tmp;
  
#line 1181 
  list_del(& local_addr->link);
  
#line 1182 
  kfree((void const *)local_addr);
  ldv_57343: 
#line 1183 
  ;
  
#line 1178 
  tmp_0 = list_empty((struct list_head const *)(& nic_data->local_addr_list));
  
#line 1178 
  if (tmp_0 == 0) 
#line 1180 
                  goto ldv_57342; else 
#line 1183 
                                       goto ldv_57344;
  ldv_57344: 
#line 1184 
  ;
  
#line 1185 
  goto ldv_57348;
  ldv_57347: 
#line 1186 
  ;
  {
    
#line 1186 
    struct list_head const *__mptr_0 = (struct list_head const *)nic_data->local_page_list.next;
    
#line 1186 
    tmp_1 = (struct efx_endpoint_page *)__mptr_0;
  }
  
#line 1186 
  epp = tmp_1;
  
#line 1188 
  list_del(& epp->link);
  
#line 1189 
  dma_free_attrs(& (efx->pci_dev)->dev,4096UL,epp->ptr,epp->addr,(struct dma_attrs *)0);
  
#line 1191 
  kfree((void const *)epp);
  ldv_57348: 
#line 1192 
  ;
  
#line 1185 
  tmp_2 = list_empty((struct list_head const *)(& nic_data->local_page_list));
  
#line 1185 
  if (tmp_2 == 0) 
#line 1187 
                  goto ldv_57347; else 
#line 1190 
                                       goto ldv_57349;
  ldv_57349: 
#line 1191 
  ;
  
#line 1192 
  return;
}


#line 1195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static int efx_siena_sriov_vf_alloc(struct efx_nic *efx)
{
  int __retres;
  unsigned int index;
  struct siena_vf *vf;
  
#line 1199 
  struct siena_nic_data *nic_data = (struct siena_nic_data *)efx->nic_data;
  
#line 1201 
  nic_data->vf = (struct siena_vf *)kcalloc_7((unsigned long)efx->vf_count,896UL,208U);
  
#line 1203 
  if (nic_data->vf == (struct siena_vf *)0) {
    
#line 1204 
    __retres = -12;
    
#line 1204 
    goto return_label;
  }
  else ;
  
#line 1206 
  index = 0U;
  
#line 1206 
  goto ldv_57364;
  ldv_57363: 
#line 1207 
  ;
  
#line 1207 
  vf = nic_data->vf + index;
  
#line 1209 
  vf->efx = efx;
  
#line 1210 
  vf->index = index;
  
#line 1211 
  vf->rx_filter_id = -1;
  
#line 1212 
  vf->tx_filter_mode = VF_TX_FILTER_AUTO;
  
#line 1213 
  vf->tx_filter_id = -1;
  {
    struct lock_class_key __key;
    
#line 1214 
    __init_work(& vf->req,0);
    
#line 1214 
    atomic_long_t __constr_expr_37 = {.counter = WORK_STRUCT_NO_POOL};
    
#line 1214 
    vf->req.data = __constr_expr_37;
    
#line 1214 
    lockdep_init_map(& vf->req.lockdep_map,"(&vf->req)",& __key,0);
    
#line 1214 
    INIT_LIST_HEAD(& vf->req.entry);
    
#line 1214 
    vf->req.func = & efx_siena_sriov_vfdi;
  }
  {
    struct lock_class_key __key_0;
    
#line 1215 
    __init_work(& vf->reset_work,0);
    
#line 1215 
    atomic_long_t __constr_expr_38 = {.counter = WORK_STRUCT_NO_POOL};
    
#line 1215 
    vf->reset_work.data = __constr_expr_38;
    
#line 1215 
    lockdep_init_map(& vf->reset_work.lockdep_map,"(&vf->reset_work)",& __key_0,0);
    
#line 1215 
    INIT_LIST_HEAD(& vf->reset_work.entry);
    
#line 1215 
    vf->reset_work.func = & efx_siena_sriov_reset_vf_work;
  }
  {
    struct lock_class_key __key_1;
    
#line 1216 
    __init_waitqueue_head(& vf->flush_waitq,"&vf->flush_waitq",& __key_1);
  }
  {
    struct lock_class_key __key_2;
    
#line 1217 
    __mutex_init(& vf->status_lock,"&vf->status_lock",& __key_2);
  }
  {
    struct lock_class_key __key_3;
    
#line 1218 
    __mutex_init(& vf->txq_lock,"&vf->txq_lock",& __key_3);
  }
  
#line 1206 
  index += 1U;
  ldv_57364: 
#line 1207 
  ;
  
#line 1206 
  if (efx->vf_count > index) 
#line 1208 
                             goto ldv_57363; else 
#line 1211 
                                                  goto ldv_57365;
  ldv_57365: 
#line 1212 
  ;
  
#line 1221 
  __retres = 0;
  return_label: 
#line 1221 
                return __retres;
}


#line 1224  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static void efx_siena_sriov_vfs_fini(struct efx_nic *efx)
{
  struct siena_vf *vf;
  unsigned int pos;
  
#line 1226 
  struct siena_nic_data *nic_data = (struct siena_nic_data *)efx->nic_data;
  
#line 1230 
  pos = 0U;
  
#line 1230 
  goto ldv_57373;
  ldv_57372: 
#line 1231 
  ;
  
#line 1231 
  vf = nic_data->vf + pos;
  
#line 1233 
  efx_nic_free_buffer(efx,& vf->buf);
  
#line 1234 
  kfree((void const *)vf->peer_page_addrs);
  
#line 1235 
  vf->peer_page_addrs = (u64 *)0ULL;
  
#line 1236 
  vf->peer_page_count = 0U;
  
#line 1238 
  vf->evq0_count = 0U;
  
#line 1230 
  pos += 1U;
  ldv_57373: 
#line 1231 
  ;
  
#line 1230 
  if (efx->vf_count > pos) 
#line 1232 
                           goto ldv_57372; else 
#line 1235 
                                                goto ldv_57374;
  ldv_57374: 
#line 1236 
  ;
  
#line 1237 
  return;
}


#line 1242  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
static int efx_siena_sriov_vfs_init(struct efx_nic *efx)
{
  int __retres;
  unsigned int index;
  unsigned int devfn;
  unsigned int sriov;
  unsigned int buftbl_base;
  u16 offset;
  u16 stride;
  struct siena_vf *vf;
  int rc;
  int tmp;
  unsigned int tmp_0;
  int tmp_1;
  
#line 1244 
  struct pci_dev *pci_dev = efx->pci_dev;
  
#line 1245 
  struct siena_nic_data *nic_data = (struct siena_nic_data *)efx->nic_data;
  
#line 1251 
  tmp = pci_find_ext_capability(pci_dev,16);
  
#line 1251 
  sriov = (unsigned int)tmp;
  
#line 1252 
  if (sriov == 0U) {
    
#line 1253 
    __retres = -2;
    
#line 1253 
    goto return_label;
  }
  else ;
  
#line 1255 
  pci_read_config_word((struct pci_dev const *)pci_dev,(int)(sriov + 20U),& offset);
  
#line 1256 
  pci_read_config_word((struct pci_dev const *)pci_dev,(int)(sriov + 22U),& stride);
  
#line 1258 
  buftbl_base = nic_data->vf_buftbl_base;
  
#line 1259 
  devfn = pci_dev->devfn + (unsigned int)offset;
  
#line 1260 
  index = 0U;
  
#line 1260 
  goto ldv_57390;
  ldv_57389: 
#line 1261 
  ;
  
#line 1261 
  vf = nic_data->vf + index;
  
#line 1264 
  vf->buftbl_base = buftbl_base;
  
#line 1265 
  tmp_0 = efx_vf_size(efx);
  
#line 1265 
  buftbl_base = (unsigned int)((unsigned long)tmp_0 * 32UL) + buftbl_base;
  
#line 1267 
  vf->pci_rid = devfn;
  
#line 1268 
  ;
  
#line 1268 
  ;
  
#line 1268 
  ;
  
#line 1269 
  tmp_1 = pci_domain_nr(pci_dev->bus);
  
#line 1268 
  ;
  
#line 1268 
  snprintf((char *)(& vf->pci_name),13UL,"%04x:%02x:%02x.%d",tmp_1,(int)(pci_dev->bus)->number,(devfn >> 3) & 31U,devfn & 7U);
  
#line 1273 
  rc = efx_nic_alloc_buffer(efx,& vf->buf,4096U,208U);
  
#line 1275 
  if (rc != 0) 
#line 1276 
               goto fail; else ;
  
#line 1278 
  devfn = (unsigned int)stride + devfn;
  
#line 1260 
  index += 1U;
  ldv_57390: 
#line 1261 
  ;
  
#line 1260 
  if (efx->vf_count > index) 
#line 1262 
                             goto ldv_57389; else 
#line 1265 
                                                  goto ldv_57391;
  ldv_57391: 
#line 1266 
  ;
  
#line 1281 
  __retres = 0;
  
#line 1281 
  goto return_label;
  fail: 
#line 1283 
  ;
  
#line 1284 
  efx_siena_sriov_vfs_fini(efx);
  
#line 1285 
  __retres = rc;
  return_label: 
#line 1285 
                return __retres;
}


#line 1296 
void __compiletime_assert_1296(void);


#line 1298 
void __compiletime_assert_1298(void);


#line 1288  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
int efx_siena_sriov_init(struct efx_nic *efx)
{
  int __retres;
  struct vfdi_status *vfdi_status;
  int rc;
  
#line 1290 
  struct net_device *net_dev = efx->net_dev;
  
#line 1291 
  struct siena_nic_data *nic_data = (struct siena_nic_data *)efx->nic_data;
  {
    
#line 1296 
    bool __cond = (_Bool)0;
    
#line 1296 
    if ((int)__cond != 0) 
#line 1296 
                          __compiletime_assert_1296(); else ;
  }
  {
    
#line 1298 
    bool __cond_0 = (_Bool)0;
    
#line 1298 
    if ((int)__cond_0 != 0) 
#line 1298 
                            __compiletime_assert_1298(); else ;
  }
  
#line 1300 
  if (efx->vf_count == 0U) {
    
#line 1301 
    __retres = 0;
    
#line 1301 
    goto return_label;
  }
  else ;
  
#line 1303 
  rc = efx_siena_sriov_cmd(efx,(_Bool)1,(unsigned int *)0U,(unsigned int *)0U);
  
#line 1304 
  if (rc != 0) 
#line 1305 
               goto fail_cmd; else ;
  
#line 1307 
  rc = efx_nic_alloc_buffer(efx,& nic_data->vfdi_status,2084U,208U);
  
#line 1309 
  if (rc != 0) 
#line 1310 
               goto fail_status; else ;
  
#line 1311 
  vfdi_status = (struct vfdi_status *)nic_data->vfdi_status.addr;
  
#line 1312 
  memset((void *)vfdi_status,0,2084UL);
  
#line 1313 
  vfdi_status->version = 1U;
  
#line 1314 
  vfdi_status->length = 2084U;
  
#line 1315 
  vfdi_status->max_tx_channels = (unsigned char)vf_max_tx_channels;
  
#line 1316 
  vfdi_status->vi_scale = (unsigned char)efx->vi_scale;
  
#line 1317 
  vfdi_status->rss_rxq_count = (unsigned char)efx->rss_spread;
  
#line 1318 
  vfdi_status->peer_count = (unsigned short)((unsigned int)((unsigned short)efx->vf_count) + 1U);
  
#line 1319 
  vfdi_status->timer_quantum_ns = efx->timer_quantum_ns;
  
#line 1321 
  rc = efx_siena_sriov_vf_alloc(efx);
  
#line 1322 
  if (rc != 0) 
#line 1323 
               goto fail_alloc; else ;
  {
    struct lock_class_key __key;
    
#line 1325 
    __mutex_init(& nic_data->local_lock,"&nic_data->local_lock",& __key);
  }
  {
    struct lock_class_key __key_0;
    
#line 1326 
    __init_work(& nic_data->peer_work,0);
    
#line 1326 
    atomic_long_t __constr_expr_39 = {.counter = WORK_STRUCT_NO_POOL};
    
#line 1326 
    nic_data->peer_work.data = __constr_expr_39;
    
#line 1326 
    lockdep_init_map(& nic_data->peer_work.lockdep_map,"(&nic_data->peer_work)",& __key_0,0);
    
#line 1326 
    INIT_LIST_HEAD(& nic_data->peer_work.entry);
    
#line 1326 
    nic_data->peer_work.func = & efx_siena_sriov_peer_work;
  }
  
#line 1327 
  INIT_LIST_HEAD(& nic_data->local_addr_list);
  
#line 1328 
  INIT_LIST_HEAD(& nic_data->local_page_list);
  
#line 1330 
  rc = efx_siena_sriov_vfs_init(efx);
  
#line 1331 
  if (rc != 0) 
#line 1332 
               goto fail_vfs; else ;
  
#line 1334 
  rtnl_lock();
  
#line 1335 
  ether_addr_copy((u8 *)(& vfdi_status->peers[0].mac_addr),(u8 const *)net_dev->dev_addr);
  
#line 1336 
  efx->vf_init_count = efx->vf_count;
  
#line 1337 
  rtnl_unlock();
  
#line 1339 
  efx_siena_sriov_usrev(efx,(_Bool)1);
  
#line 1343 
  rc = pci_enable_sriov(efx->pci_dev,(int)efx->vf_count);
  
#line 1344 
  if (rc != 0) 
#line 1345 
               goto fail_pci; else ;
  
#line 1347 
  if ((efx->msg_enable & 2U) != 0U) {
    unsigned int tmp;
    
#line 1347 
    tmp = efx_vf_size(efx);
    
#line 1347 
    ;
    
#line 1347 
    ;
    
#line 1347 
    netdev_info((struct net_device const *)net_dev,"enabled SR-IOV for %d VFs, %d VI per VF\n",efx->vf_count,tmp);
  }
  else ;
  
#line 1350 
  __retres = 0;
  
#line 1350 
  goto return_label;
  fail_pci: 
#line 1352 
  ;
  
#line 1353 
  efx_siena_sriov_usrev(efx,(_Bool)0);
  
#line 1354 
  rtnl_lock();
  
#line 1355 
  efx->vf_init_count = 0U;
  
#line 1356 
  rtnl_unlock();
  
#line 1357 
  efx_siena_sriov_vfs_fini(efx);
  fail_vfs: 
#line 1358 
  ;
  
#line 1359 
  cancel_work_sync(& nic_data->peer_work);
  
#line 1360 
  efx_siena_sriov_free_local(efx);
  
#line 1361 
  kfree((void const *)nic_data->vf);
  fail_alloc: 
#line 1362 
  ;
  
#line 1363 
  efx_nic_free_buffer(efx,& nic_data->vfdi_status);
  fail_status: 
#line 1364 
  ;
  
#line 1365 
  efx_siena_sriov_cmd(efx,(_Bool)0,(unsigned int *)0U,(unsigned int *)0U);
  fail_cmd: 
#line 1366 
  ;
  
#line 1367 
  __retres = rc;
  return_label: 
#line 1367 
                return __retres;
}


#line 1370  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
void efx_siena_sriov_fini(struct efx_nic *efx)
{
  struct siena_vf *vf;
  unsigned int pos;
  
#line 1374 
  struct siena_nic_data *nic_data = (struct siena_nic_data *)efx->nic_data;
  
#line 1376 
  if (efx->vf_init_count == 0U) 
#line 1377 
                                goto return_label; else ;
  
#line 1380 
  if ((long)((int)(nic_data->vfdi_channel)->enabled != 0) != 0L) {
    
#line 1382 
    ldv_inline_asm();
    
#line 1380 
    ;
  }
  else ;
  
#line 1381 
  efx_siena_sriov_usrev(efx,(_Bool)0);
  
#line 1382 
  rtnl_lock();
  
#line 1383 
  efx->vf_init_count = 0U;
  
#line 1384 
  rtnl_unlock();
  
#line 1387 
  pos = 0U;
  
#line 1387 
  goto ldv_57422;
  ldv_57421: 
#line 1388 
  ;
  
#line 1388 
  vf = nic_data->vf + pos;
  
#line 1389 
  cancel_work_sync(& vf->req);
  
#line 1390 
  cancel_work_sync(& vf->reset_work);
  
#line 1387 
  pos += 1U;
  ldv_57422: 
#line 1388 
  ;
  
#line 1387 
  if (efx->vf_count > pos) 
#line 1389 
                           goto ldv_57421; else 
#line 1392 
                                                goto ldv_57423;
  ldv_57423: 
#line 1393 
  ;
  
#line 1392 
  cancel_work_sync(& nic_data->peer_work);
  
#line 1394 
  pci_disable_sriov(efx->pci_dev);
  
#line 1397 
  efx_siena_sriov_vfs_fini(efx);
  
#line 1398 
  efx_siena_sriov_free_local(efx);
  
#line 1399 
  kfree((void const *)nic_data->vf);
  
#line 1400 
  efx_nic_free_buffer(efx,& nic_data->vfdi_status);
  
#line 1401 
  efx_siena_sriov_cmd(efx,(_Bool)0,(unsigned int *)0U,(unsigned int *)0U);
  return_label: 
#line 1402 
                return;
}


#line 1413 
void __compiletime_assert_1413(void);


#line 1404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
void efx_siena_sriov_event(struct efx_channel *channel, efx_qword_t *event)
{
  struct siena_vf *vf;
  unsigned int qid;
  unsigned int seq;
  unsigned int type;
  unsigned int data;
  bool tmp;
  int tmp_1;
  
#line 1406 
  struct efx_nic *efx = channel->efx;
  
#line 1410 
  qid = (unsigned int)(event->u64[0] >> 32) & 1023U;
  {
    
#line 1413 
    bool __cond = (_Bool)0;
    
#line 1413 
    if ((int)__cond != 0) 
#line 1413 
                          __compiletime_assert_1413(); else ;
  }
  
#line 1414 
  seq = (unsigned int)(event->u64[0] >> 24) & 255U;
  
#line 1415 
  type = (unsigned int)(event->u64[0] >> 16) & 255U;
  
#line 1416 
  data = (unsigned int)event->u64[0] & 65535U;
  
#line 1422 
  tmp = map_vi_index(efx,qid,& vf,(unsigned int *)0U);
  
#line 1422 
  if ((int)tmp != 0) 
#line 1423 
                     goto return_label; else ;
  
#line 1424 
  if ((int)vf->busy != 0) 
#line 1425 
                          goto error; else ;
  
#line 1427 
  if (type == 0U) {
    
#line 1429 
    vf->req_type = 0;
    
#line 1430 
    vf->req_seqno = seq + 1U;
    
#line 1431 
    vf->req_addr = 0ULL;
  }
  else {
    unsigned int tmp_0;
    
#line 1432 
    tmp_0 = vf->req_seqno;
    
#line 1432 
    vf->req_seqno += 1U;
    
#line 1432 
    ;
    
#line 1432 
    if ((tmp_0 & 255U) != seq) 
#line 1433 
                               goto error;
    else 
      
#line 1432 
      if ((unsigned int)vf->req_type != type) 
#line 1433 
                                              goto error; else ;
  }
  
#line 1435 
  switch (vf->req_type) {
    case 0: 
#line 1436 
    ;
    case 1: 
#line 1437 
    ;
    case 2: 
#line 1438 
    ;
    
#line 1439 
    vf->req_addr |= (unsigned long long)data << (vf->req_type << 4);
    
#line 1440 
    vf->req_type += 1;
    
#line 1441 
    goto return_label;
    case 3: 
#line 1443 
    ;
    
#line 1444 
    vf->req_addr |= (unsigned long long)data << 48;
    
#line 1445 
    vf->req_type = 0;
    
#line 1446 
    vf->busy = (_Bool)1;
    
#line 1447 
    ldv_queue_work_117(vfdi_workqueue,& vf->req);
    
#line 1448 
    goto return_label;
  }
  error: 
#line 1451 
  ;
  
#line 1452 
  tmp_1 = net_ratelimit();
  
#line 1452 
  if (tmp_1 != 0) {
    
#line 1453 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 1453 
                                         netdev_err((struct net_device const *)efx->net_dev,"ERROR: Screaming VFDI request from %s\n",(char *)(& vf->pci_name)); else ;
  }
  else ;
  
#line 1457 
  vf->req_type = 0;
  
#line 1458 
  vf->req_seqno = seq + 1U;
  return_label: 
#line 1459 
                return;
}


#line 1461  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
void efx_siena_sriov_flr(struct efx_nic *efx, unsigned int vf_i)
{
  struct siena_vf *vf;
  
#line 1463 
  struct siena_nic_data *nic_data = (struct siena_nic_data *)efx->nic_data;
  
#line 1466 
  if (efx->vf_init_count < vf_i) 
#line 1467 
                                 goto return_label; else ;
  
#line 1468 
  vf = nic_data->vf + vf_i;
  
#line 1469 
  if ((efx->msg_enable & 8192U) != 0U) 
#line 1469 
                                       netdev_info((struct net_device const *)efx->net_dev,"FLR on VF %s\n",(char *)(& vf->pci_name)); else ;
  
#line 1472 
  vf->status_addr = 0ULL;
  
#line 1473 
  efx_vfdi_remove_all_filters(vf);
  
#line 1474 
  efx_vfdi_flush_clear(vf);
  
#line 1476 
  vf->evq0_count = 0U;
  return_label: 
#line 1477 
                return;
}


#line 1479  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
int efx_siena_sriov_mac_address_changed(struct efx_nic *efx)
{
  int __retres;
  
#line 1481 
  struct siena_nic_data *nic_data = (struct siena_nic_data *)efx->nic_data;
  
#line 1482 
  struct vfdi_status *vfdi_status = (struct vfdi_status *)nic_data->vfdi_status.addr;
  
#line 1484 
  if (efx->vf_init_count == 0U) {
    
#line 1485 
    __retres = 0;
    
#line 1485 
    goto return_label;
  }
  else ;
  
#line 1486 
  ether_addr_copy((u8 *)(& vfdi_status->peers[0].mac_addr),(u8 const *)(efx->net_dev)->dev_addr);
  
#line 1488 
  ldv_queue_work_118(vfdi_workqueue,& nic_data->peer_work);
  
#line 1490 
  __retres = 0;
  return_label: 
#line 1490 
                return __retres;
}


#line 1493  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
void efx_siena_sriov_tx_flush_done(struct efx_nic *efx, efx_qword_t *event)
{
  struct siena_vf *vf;
  unsigned int queue;
  unsigned int qid;
  bool tmp;
  int tmp_2;
  bool tmp_3;
  
#line 1498 
  queue = (unsigned int)event->u64[0] & 16383U;
  
#line 1499 
  tmp = map_vi_index(efx,queue,& vf,& qid);
  
#line 1499 
  if ((int)tmp != 0) 
#line 1500 
                     goto return_label; else ;
  
#line 1502 
  if (0 != 0) {
    int tmp_0;
    
#line 1502 
    tmp_0 = constant_test_bit((long)qid,(unsigned long const volatile *)(& vf->txq_mask));
    
#line 1502 
    tmp_2 = tmp_0 == 0;
  }
  else {
    int tmp_1;
    
#line 1502 
    tmp_1 = variable_test_bit((long)qid,(unsigned long const volatile *)(& vf->txq_mask));
    
#line 1502 
    tmp_2 = tmp_1 == 0;
  }
  
#line 1502 
  if (tmp_2) 
#line 1503 
             goto return_label; else ;
  
#line 1505 
  __set_bit((long)qid,(unsigned long volatile *)(& vf->txq_mask));
  
#line 1506 
  vf->txq_count -= 1U;
  
#line 1508 
  tmp_3 = efx_vfdi_flush_wake(vf);
  
#line 1508 
  if ((int)tmp_3 != 0) 
#line 1509 
                       __wake_up(& vf->flush_waitq,3U,1,(void *)0); else ;
  return_label: 
#line 1510 
                return;
}


#line 1512  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
void efx_siena_sriov_rx_flush_done(struct efx_nic *efx, efx_qword_t *event)
{
  struct siena_vf *vf;
  unsigned int ev_failed;
  unsigned int queue;
  unsigned int qid;
  bool tmp;
  int tmp_2;
  bool tmp_3;
  
#line 1517 
  queue = (unsigned int)event->u64[0] & 4095U;
  
#line 1518 
  ev_failed = (unsigned int)(event->u64[0] >> 12) & 1U;
  
#line 1520 
  tmp = map_vi_index(efx,queue,& vf,& qid);
  
#line 1520 
  if ((int)tmp != 0) 
#line 1521 
                     goto return_label; else ;
  
#line 1522 
  if (0 != 0) {
    int tmp_0;
    
#line 1522 
    tmp_0 = constant_test_bit((long)qid,(unsigned long const volatile *)(& vf->rxq_mask));
    
#line 1522 
    tmp_2 = tmp_0 == 0;
  }
  else {
    int tmp_1;
    
#line 1522 
    tmp_1 = variable_test_bit((long)qid,(unsigned long const volatile *)(& vf->rxq_mask));
    
#line 1522 
    tmp_2 = tmp_1 == 0;
  }
  
#line 1522 
  if (tmp_2) 
#line 1523 
             goto return_label; else ;
  
#line 1525 
  if (ev_failed != 0U) {
    
#line 1526 
    set_bit((long)qid,(unsigned long volatile *)(& vf->rxq_retry_mask));
    
#line 1527 
    atomic_inc_2(& vf->rxq_retry_count);
  }
  else {
    
#line 1529 
    __set_bit((long)qid,(unsigned long volatile *)(& vf->rxq_mask));
    
#line 1530 
    vf->rxq_count -= 1U;
  }
  
#line 1532 
  tmp_3 = efx_vfdi_flush_wake(vf);
  
#line 1532 
  if ((int)tmp_3 != 0) 
#line 1533 
                       __wake_up(& vf->flush_waitq,3U,1,(void *)0); else ;
  return_label: 
#line 1534 
                return;
}


#line 1537  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
void efx_siena_sriov_desc_fetch_err(struct efx_nic *efx, unsigned int dmaq)
{
  struct siena_vf *vf;
  unsigned int rel;
  bool tmp;
  int tmp_0;
  
#line 1542 
  tmp = map_vi_index(efx,dmaq,& vf,& rel);
  
#line 1542 
  if ((int)tmp != 0) 
#line 1543 
                     goto return_label; else ;
  
#line 1545 
  tmp_0 = net_ratelimit();
  
#line 1545 
  if (tmp_0 != 0) {
    
#line 1546 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 1546 
                                         netdev_err((struct net_device const *)efx->net_dev,"VF %d DMA Q %d reports descriptor fetch error.\n",vf->index,rel); else ;
  }
  else ;
  
#line 1549 
  ldv_queue_work_119(vfdi_workqueue,& vf->reset_work);
  return_label: 
#line 1550 
                return;
}


#line 1553  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
void efx_siena_sriov_reset(struct efx_nic *efx)
{
  unsigned int vf_i;
  struct efx_buffer buf;
  struct siena_vf *vf;
  int tmp;
  int tmp_0;
  
#line 1555 
  struct siena_nic_data *nic_data = (struct siena_nic_data *)efx->nic_data;
  
#line 1560 
  tmp = rtnl_is_locked();
  
#line 1560 
  if ((long)(tmp == 0) != 0L) {
    
#line 1560 
    printk("\001",(char *)"/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c",1560);
    
#line 1560 
    dump_stack();
  }
  else ;
  
#line 1562 
  if (efx->vf_init_count == 0U) 
#line 1563 
                                goto return_label; else ;
  
#line 1565 
  efx_siena_sriov_usrev(efx,(_Bool)1);
  
#line 1566 
  efx_siena_sriov_cmd(efx,(_Bool)1,(unsigned int *)0U,(unsigned int *)0U);
  
#line 1568 
  tmp_0 = efx_nic_alloc_buffer(efx,& buf,4096U,16U);
  
#line 1568 
  if (tmp_0 != 0) 
#line 1569 
                  goto return_label; else ;
  
#line 1571 
  vf_i = 0U;
  
#line 1571 
  goto ldv_57484;
  ldv_57483: 
#line 1572 
  ;
  
#line 1572 
  vf = nic_data->vf + vf_i;
  
#line 1573 
  efx_siena_sriov_reset_vf(vf,& buf);
  
#line 1571 
  vf_i += 1U;
  ldv_57484: 
#line 1572 
  ;
  
#line 1571 
  if (efx->vf_init_count > vf_i) 
#line 1573 
                                 goto ldv_57483; else 
#line 1576 
                                                      goto ldv_57485;
  ldv_57485: 
#line 1577 
  ;
  
#line 1576 
  efx_nic_free_buffer(efx,& buf);
  return_label: 
#line 1577 
                return;
}


#line 1579  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
int efx_init_sriov(void)
{
  int __retres;
  struct workqueue_struct *tmp_0;
  {
    struct lock_class_key __key;
    char const *__lock_name;
    
#line 1585 
    __lock_name = "\"%s\"";
    
#line 1585 
    tmp_0 = __alloc_workqueue_key("%s",131082U,1,& __key,__lock_name,(char *)"sfc_vfdi");
  }
  
#line 1585 
  vfdi_workqueue = tmp_0;
  
#line 1586 
  if (vfdi_workqueue == (struct workqueue_struct *)0) {
    
#line 1587 
    __retres = -12;
    
#line 1587 
    goto return_label;
  }
  else ;
  
#line 1588 
  __retres = 0;
  return_label: 
#line 1588 
                return __retres;
}


#line 1591  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
void efx_fini_sriov(void)
{
  
#line 1593 
  destroy_workqueue(vfdi_workqueue);
  
#line 1594 
  return;
}


#line 1596  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
int efx_siena_sriov_set_vf_mac(struct efx_nic *efx, int vf_i, u8 *mac)
{
  int __retres;
  struct siena_vf *vf;
  
#line 1598 
  struct siena_nic_data *nic_data = (struct siena_nic_data *)efx->nic_data;
  
#line 1601 
  if (efx->vf_init_count <= (unsigned int)vf_i) {
    
#line 1602 
    __retres = -22;
    
#line 1602 
    goto return_label;
  }
  else ;
  
#line 1603 
  vf = nic_data->vf + vf_i;
  
#line 1605 
  ldv_mutex_lock_120(& vf->status_lock);
  
#line 1606 
  ether_addr_copy((u8 *)(& vf->addr.mac_addr),(u8 const *)mac);
  
#line 1607 
  __efx_siena_sriov_update_vf_addr(vf);
  
#line 1608 
  ldv_mutex_unlock_121(& vf->status_lock);
  
#line 1610 
  __retres = 0;
  return_label: 
#line 1610 
                return __retres;
}


#line 1613  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
int efx_siena_sriov_set_vf_vlan(struct efx_nic *efx, int vf_i, u16 vlan, u8 qos)
{
  int __retres;
  struct siena_vf *vf;
  u16 tci;
  
#line 1616 
  struct siena_nic_data *nic_data = (struct siena_nic_data *)efx->nic_data;
  
#line 1620 
  if (efx->vf_init_count <= (unsigned int)vf_i) {
    
#line 1621 
    __retres = -22;
    
#line 1621 
    goto return_label;
  }
  else ;
  
#line 1622 
  vf = nic_data->vf + vf_i;
  
#line 1624 
  ldv_mutex_lock_122(& vf->status_lock);
  
#line 1625 
  tci = (unsigned short)(((int)vlan & 4095) | ((int)qos << 13));
  
#line 1626 
  if (0 != 0) 
#line 1626 
              vf->addr.tci = (unsigned short)(((int)tci << 8) | ((int)tci >> 8)); else 
                                                                    
#line 1626 
                                                                    vf->addr.tci = __fswab16((unsigned short)((int)tci));
  
#line 1627 
  __efx_siena_sriov_update_vf_addr(vf);
  
#line 1628 
  ldv_mutex_unlock_123(& vf->status_lock);
  
#line 1630 
  __retres = 0;
  return_label: 
#line 1630 
                return __retres;
}


#line 1633  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
int efx_siena_sriov_set_vf_spoofchk(struct efx_nic *efx, int vf_i, bool spoofchk)
{
  int __retres;
  struct siena_vf *vf;
  int rc;
  
#line 1636 
  struct siena_nic_data *nic_data = (struct siena_nic_data *)efx->nic_data;
  
#line 1640 
  if (efx->vf_init_count <= (unsigned int)vf_i) {
    
#line 1641 
    __retres = -22;
    
#line 1641 
    goto return_label;
  }
  else ;
  
#line 1642 
  vf = nic_data->vf + vf_i;
  
#line 1644 
  ldv_mutex_lock_124(& vf->txq_lock);
  
#line 1645 
  if (vf->txq_count == 0U) {
    int tmp;
    
#line 1647 
    if ((int)spoofchk != 0) 
#line 1647 
                            tmp = 2; else 
#line 1647 
                                          tmp = 0;
    
#line 1646 
    vf->tx_filter_mode = (enum efx_vf_tx_filter_mode)tmp;
    
#line 1648 
    rc = 0;
  }
  else 
#line 1651 
       rc = -16;
  
#line 1653 
  ldv_mutex_unlock_125(& vf->txq_lock);
  
#line 1654 
  __retres = rc;
  return_label: 
#line 1654 
                return __retres;
}


#line 1657  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
int efx_siena_sriov_get_vf_config(struct efx_nic *efx, int vf_i, struct ifla_vf_info *ivi)
{
  int __retres;
  struct siena_vf *vf;
  u16 tci;
  
#line 1660 
  struct siena_nic_data *nic_data = (struct siena_nic_data *)efx->nic_data;
  
#line 1664 
  if (efx->vf_init_count <= (unsigned int)vf_i) {
    
#line 1665 
    __retres = -22;
    
#line 1665 
    goto return_label;
  }
  else ;
  
#line 1666 
  vf = nic_data->vf + vf_i;
  
#line 1668 
  ivi->vf = (unsigned int)vf_i;
  
#line 1669 
  ether_addr_copy((u8 *)(& ivi->mac),(u8 const *)(& vf->addr.mac_addr));
  
#line 1670 
  ivi->max_tx_rate = 0U;
  
#line 1671 
  ivi->min_tx_rate = 0U;
  
#line 1672 
  if (0 != 0) 
#line 1672 
              tci = (unsigned short)(((int)vf->addr.tci << 8) | ((int)vf->addr.tci >> 8)); else 
                                                                    
#line 1672 
                                                                    tci = __fswab16((unsigned short)((int)vf->addr.tci));
  
#line 1673 
  ivi->vlan = (unsigned int)tci & 4095U;
  
#line 1674 
  ivi->qos = (unsigned int)((int)tci >> 13) & 7U;
  
#line 1675 
  ivi->spoofchk = (unsigned int)(vf->tx_filter_mode == (unsigned int)VF_TX_FILTER_ON);
  
#line 1677 
  __retres = 0;
  return_label: 
#line 1677 
                return __retres;
}


#line 1680  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
bool efx_siena_sriov_wanted(struct efx_nic *efx)
{
  bool __retres;
  
#line 1682 
  __retres = (_Bool)(efx->vf_count != 0U);
  
#line 1682 
  return __retres;
}


#line 1685  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/siena_sriov.c"
int efx_siena_sriov_configure(struct efx_nic *efx, int num_vfs)
{
  int __retres;
  
#line 1687 
  __retres = 0;
  
#line 1687 
  return __retres;
}


#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
_Bool ldv_emg_queue_work(struct workqueue_struct *arg0, struct work_struct *arg1);


#line 125  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void atomic_inc_2(atomic_t *v)
{
  
#line 128 
  ldv_atomic_inc(v);
  
#line 129 
  return;
}


#line 132  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void atomic_dec_1(atomic_t *v)
{
  
#line 135 
  ldv_atomic_dec(v);
  
#line 136 
  return;
}


#line 491  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void *kmalloc_2(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 494 
  tmp = ldv_kmalloc(size,flags);
  
#line 494 
  return tmp;
}


#line 505  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void *kcalloc_7(size_t n, size_t size, gfp_t flags)
{
  void *tmp;
  
#line 508 
  tmp = ldv_kcalloc(n,size,flags);
  
#line 508 
  return tmp;
}


#line 888  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void ldv___ldv_spin_lock_87_1(spinlock_t *ldv_func_arg1)
{
  
#line 892 
  ldv_spin_model_lock((char *)"biu_lock_of_efx_nic");
  
#line 894 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 895 
  return;
}


#line 898  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void ldv_spin_unlock_irqrestore_88_1(spinlock_t *lock, unsigned long flags)
{
  
#line 902 
  ldv_spin_model_unlock((char *)"biu_lock_of_efx_nic");
  
#line 904 
  spin_unlock_irqrestore_2(lock,flags);
  
#line 905 
  return;
}


#line 908  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void ldv___ldv_spin_lock_89_0(spinlock_t *ldv_func_arg1)
{
  
#line 912 
  ldv_spin_model_lock((char *)"biu_lock_of_efx_nic");
  
#line 914 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 915 
  return;
}


#line 918  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void ldv_spin_unlock_irqrestore_90_0(spinlock_t *lock, unsigned long flags)
{
  
#line 922 
  ldv_spin_model_unlock((char *)"biu_lock_of_efx_nic");
  
#line 924 
  spin_unlock_irqrestore_2(lock,flags);
  
#line 925 
  return;
}


#line 988  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static bool ldv_queue_work_97(struct workqueue_struct *wq, struct work_struct *work)
{
  bool __retres;
  bool tmp;
  
#line 992 
  tmp = ldv_emg_queue_work(wq,work);
  
#line 992 
  __retres = tmp != 0;
  
#line 992 
  return __retres;
}


#line 996  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static int ldv_mutex_is_locked_98(struct mutex *lock)
{
  int tmp;
  
#line 999 
  tmp = ldv_mutex_model_is_locked(lock,(char *)"status_lock_of_siena_vf");
  
#line 999 
  return tmp;
}


#line 1003  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void ldv_mutex_lock_99(struct mutex *ldv_func_arg1)
{
  
#line 1007 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"txq_lock_of_siena_vf");
  
#line 1008 
  return;
}


#line 1011  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void ldv_mutex_unlock_100(struct mutex *ldv_func_arg1)
{
  
#line 1015 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"txq_lock_of_siena_vf");
  
#line 1016 
  return;
}


#line 1019  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static bool ldv_queue_work_101(struct workqueue_struct *wq, struct work_struct *work)
{
  bool __retres;
  bool tmp;
  
#line 1023 
  tmp = ldv_emg_queue_work(wq,work);
  
#line 1023 
  __retres = tmp != 0;
  
#line 1023 
  return __retres;
}


#line 1027  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static bool ldv_queue_work_102(struct workqueue_struct *wq, struct work_struct *work)
{
  bool __retres;
  bool tmp;
  
#line 1031 
  tmp = ldv_emg_queue_work(wq,work);
  
#line 1031 
  __retres = tmp != 0;
  
#line 1031 
  return __retres;
}


#line 1035  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void ldv_mutex_lock_103(struct mutex *ldv_func_arg1)
{
  
#line 1039 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"local_lock_of_siena_nic_data");
  
#line 1040 
  return;
}


#line 1043  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void ldv_mutex_lock_104(struct mutex *ldv_func_arg1)
{
  
#line 1047 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"status_lock_of_siena_vf");
  
#line 1048 
  return;
}


#line 1051  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void ldv_mutex_unlock_105(struct mutex *ldv_func_arg1)
{
  
#line 1055 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"status_lock_of_siena_vf");
  
#line 1056 
  return;
}


#line 1059  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void ldv_mutex_unlock_106(struct mutex *ldv_func_arg1)
{
  
#line 1063 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"local_lock_of_siena_nic_data");
  
#line 1064 
  return;
}


#line 1067  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void ldv_mutex_lock_107(struct mutex *ldv_func_arg1)
{
  
#line 1071 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"status_lock_of_siena_vf");
  
#line 1072 
  return;
}


#line 1075  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void ldv_mutex_unlock_108(struct mutex *ldv_func_arg1)
{
  
#line 1079 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"status_lock_of_siena_vf");
  
#line 1080 
  return;
}


#line 1083  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void ldv_mutex_lock_109(struct mutex *ldv_func_arg1)
{
  
#line 1087 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"status_lock_of_siena_vf");
  
#line 1088 
  return;
}


#line 1091  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void ldv_mutex_unlock_110(struct mutex *ldv_func_arg1)
{
  
#line 1095 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"status_lock_of_siena_vf");
  
#line 1096 
  return;
}


#line 1099  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void ldv_mutex_lock_111(struct mutex *ldv_func_arg1)
{
  
#line 1103 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"local_lock_of_siena_nic_data");
  
#line 1104 
  return;
}


#line 1107  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void ldv_mutex_lock_112(struct mutex *ldv_func_arg1)
{
  
#line 1111 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"status_lock_of_siena_vf");
  
#line 1112 
  return;
}


#line 1115  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void ldv_mutex_unlock_113(struct mutex *ldv_func_arg1)
{
  
#line 1119 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"status_lock_of_siena_vf");
  
#line 1120 
  return;
}


#line 1123  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void ldv_mutex_unlock_114(struct mutex *ldv_func_arg1)
{
  
#line 1127 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"local_lock_of_siena_nic_data");
  
#line 1128 
  return;
}


#line 1131  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void ldv_mutex_lock_115(struct mutex *ldv_func_arg1)
{
  
#line 1135 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"status_lock_of_siena_vf");
  
#line 1136 
  return;
}


#line 1139  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void ldv_mutex_unlock_116(struct mutex *ldv_func_arg1)
{
  
#line 1143 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"status_lock_of_siena_vf");
  
#line 1144 
  return;
}


#line 1147  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static bool ldv_queue_work_117(struct workqueue_struct *wq, struct work_struct *work)
{
  bool __retres;
  bool tmp;
  
#line 1151 
  tmp = ldv_emg_queue_work(wq,work);
  
#line 1151 
  __retres = tmp != 0;
  
#line 1151 
  return __retres;
}


#line 1155  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static bool ldv_queue_work_118(struct workqueue_struct *wq, struct work_struct *work)
{
  bool __retres;
  bool tmp;
  
#line 1159 
  tmp = ldv_emg_queue_work(wq,work);
  
#line 1159 
  __retres = tmp != 0;
  
#line 1159 
  return __retres;
}


#line 1163  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static bool ldv_queue_work_119(struct workqueue_struct *wq, struct work_struct *work)
{
  bool __retres;
  bool tmp;
  
#line 1167 
  tmp = ldv_emg_queue_work(wq,work);
  
#line 1167 
  __retres = tmp != 0;
  
#line 1167 
  return __retres;
}


#line 1171  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void ldv_mutex_lock_120(struct mutex *ldv_func_arg1)
{
  
#line 1175 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"status_lock_of_siena_vf");
  
#line 1176 
  return;
}


#line 1179  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void ldv_mutex_unlock_121(struct mutex *ldv_func_arg1)
{
  
#line 1183 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"status_lock_of_siena_vf");
  
#line 1184 
  return;
}


#line 1187  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void ldv_mutex_lock_122(struct mutex *ldv_func_arg1)
{
  
#line 1191 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"status_lock_of_siena_vf");
  
#line 1192 
  return;
}


#line 1195  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void ldv_mutex_unlock_123(struct mutex *ldv_func_arg1)
{
  
#line 1199 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"status_lock_of_siena_vf");
  
#line 1200 
  return;
}


#line 1203  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void ldv_mutex_lock_124(struct mutex *ldv_func_arg1)
{
  
#line 1207 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"txq_lock_of_siena_vf");
  
#line 1208 
  return;
}


#line 1211  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_siena_sriov.c.aux"
static void ldv_mutex_unlock_125(struct mutex *ldv_func_arg1)
{
  
#line 1215 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"txq_lock_of_siena_vf");
  
#line 1216 
  return;
}


#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/sriov.h"
int efx_sriov_set_vf_mac(struct net_device *net_dev, int vf_i, u8 *mac);


#line 18 
int efx_sriov_set_vf_vlan(struct net_device *net_dev, int vf_i, u16 vlan, u8 qos);


#line 20 
int efx_sriov_set_vf_spoofchk(struct net_device *net_dev, int vf_i, bool spoofchk);


#line 22 
int efx_sriov_get_vf_config(struct net_device *net_dev, int vf_i, struct ifla_vf_info *ivi);


#line 24 
int efx_sriov_set_vf_link_state(struct net_device *net_dev, int vf_i, int link_state);


#line 26 
int efx_sriov_get_phys_port_id(struct net_device *net_dev, struct netdev_phys_item_id *ppid);


#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/sriov.c"
int efx_sriov_set_vf_mac(struct net_device *net_dev, int vf_i, u8 *mac)
{
  int __retres;
  
#line 16 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 18 
  if ((efx->type)->sriov_set_vf_mac != (int (*)(struct efx_nic *, int , u8 *))0) {
    int tmp_0;
    
#line 19 
    tmp_0 = (*((efx->type)->sriov_set_vf_mac))(efx,vf_i,mac);
    
#line 19 
    __retres = tmp_0;
    
#line 19 
    goto return_label;
  }
  else {
    
#line 21 
    __retres = -95;
    
#line 21 
    goto return_label;
  }
  return_label: 
#line 18 
                return __retres;
}


#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/sriov.c"
int efx_sriov_set_vf_vlan(struct net_device *net_dev, int vf_i, u16 vlan, u8 qos)
{
  int __retres;
  
#line 27 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 29 
  if ((efx->type)->sriov_set_vf_vlan != (int (*)(struct efx_nic *, int , u16 , u8 ))0) {
    int tmp_0;
    
#line 30 
    if (((int)vlan & -4096) != 0 || ((int)qos & -8) != 0) {
      
#line 32 
      __retres = -22;
      
#line 32 
      goto return_label;
    }
    else ;
    
#line 34 
    tmp_0 = (*((efx->type)->sriov_set_vf_vlan))(efx,vf_i,(unsigned short)((int)vlan),(unsigned char)((int)qos));
    
#line 34 
    __retres = tmp_0;
    
#line 34 
    goto return_label;
  }
  else {
    
#line 36 
    __retres = -95;
    
#line 36 
    goto return_label;
  }
  return_label: 
#line 29 
                return __retres;
}


#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/sriov.c"
int efx_sriov_set_vf_spoofchk(struct net_device *net_dev, int vf_i, bool spoofchk)
{
  int __retres;
  
#line 43 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 45 
  if ((efx->type)->sriov_set_vf_spoofchk != (int (*)(struct efx_nic *, int , bool ))0) {
    int tmp_0;
    
#line 46 
    tmp_0 = (*((efx->type)->sriov_set_vf_spoofchk))(efx,vf_i,(_Bool)((bool)((int)spoofchk) != 0));
    
#line 46 
    __retres = tmp_0;
    
#line 46 
    goto return_label;
  }
  else {
    
#line 48 
    __retres = -95;
    
#line 48 
    goto return_label;
  }
  return_label: 
#line 45 
                return __retres;
}


#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/sriov.c"
int efx_sriov_get_vf_config(struct net_device *net_dev, int vf_i, struct ifla_vf_info *ivi)
{
  int __retres;
  
#line 54 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 56 
  if ((efx->type)->sriov_get_vf_config != (int (*)(struct efx_nic *, int , struct ifla_vf_info *))0) {
    int tmp_0;
    
#line 57 
    tmp_0 = (*((efx->type)->sriov_get_vf_config))(efx,vf_i,ivi);
    
#line 57 
    __retres = tmp_0;
    
#line 57 
    goto return_label;
  }
  else {
    
#line 59 
    __retres = -95;
    
#line 59 
    goto return_label;
  }
  return_label: 
#line 56 
                return __retres;
}


#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/sriov.c"
int efx_sriov_set_vf_link_state(struct net_device *net_dev, int vf_i, int link_state)
{
  int __retres;
  
#line 65 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 67 
  if ((efx->type)->sriov_set_vf_link_state != (int (*)(struct efx_nic *, int , int ))0) {
    int tmp_0;
    
#line 68 
    tmp_0 = (*((efx->type)->sriov_set_vf_link_state))(efx,vf_i,link_state);
    
#line 68 
    __retres = tmp_0;
    
#line 68 
    goto return_label;
  }
  else {
    
#line 71 
    __retres = -95;
    
#line 71 
    goto return_label;
  }
  return_label: 
#line 67 
                return __retres;
}


#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/sriov.c"
int efx_sriov_get_phys_port_id(struct net_device *net_dev, struct netdev_phys_item_id *ppid)
{
  int __retres;
  
#line 77 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 79 
  if ((efx->type)->sriov_get_phys_port_id != (int (*)(struct efx_nic *, struct netdev_phys_item_id *))0) {
    int tmp_0;
    
#line 80 
    tmp_0 = (*((efx->type)->sriov_get_phys_port_id))(efx,ppid);
    
#line 80 
    __retres = tmp_0;
    
#line 80 
    goto return_label;
  }
  else {
    
#line 82 
    __retres = -95;
    
#line 82 
    goto return_label;
  }
  return_label: 
#line 79 
                return __retres;
}


#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
void ___might_sleep(char const *, int, int);


#line 98  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/atomic.h"
static void atomic_inc_3(atomic_t *v);


#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/thread_info.h"
__inline static int test_ti_thread_flag(struct thread_info *ti, int flag)
{
  int tmp_1;
  
#line 91 
  if (0 != 0) 
#line 91 
              tmp_1 = constant_test_bit((long)flag,(unsigned long const volatile *)(& ti->flags)); else 
                                                                    
#line 91 
                                                                    tmp_1 = variable_test_bit((long)flag,(unsigned long const volatile *)(& ti->flags));
  
#line 91 
  return tmp_1;
}


#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_4(spinlock_t *lock)
{
  
#line 312 
  _raw_spin_lock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 313 
  return;
}


#line 358 
static void ldv_spin_lock_107(spinlock_t *lock);


#line 359  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_bh_3(spinlock_t *lock)
{
  
#line 361 
  _raw_spin_lock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 362 
  return;
}


#line 411 
static void ldv_spin_lock_bh_121(spinlock_t *lock);


#line 415 
static void ldv_spin_lock_bh_123(spinlock_t *lock);


#line 419 
static void ldv_spin_lock_bh_126_0(spinlock_t *lock);


#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_4(spinlock_t *lock)
{
  
#line 365 
  _raw_spin_unlock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 366 
  return;
}


#line 407 
static void ldv_spin_unlock_108(spinlock_t *lock);


#line 408  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_bh_4(spinlock_t *lock)
{
  
#line 410 
  _raw_spin_unlock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 411 
  return;
}


#line 464 
static void ldv_spin_unlock_bh_122(spinlock_t *lock);


#line 468 
static void ldv_spin_unlock_bh_124(spinlock_t *lock);


#line 472 
static void ldv_spin_unlock_bh_127_0(spinlock_t *lock);


#line 486  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_irqrestore_3(spinlock_t *lock, unsigned long flags)
{
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
  }
  
#line 488 
  _raw_spin_unlock_irqrestore(& lock->__anonCompField_spinlock_18.rlock,flags);
  
#line 489 
  return;
}


#line 518 
static void ldv_spin_unlock_irqrestore_88_2(spinlock_t *lock, unsigned long flags);


#line 526 
static void ldv_spin_unlock_irqrestore_92_2(spinlock_t *lock, unsigned long flags);


#line 534 
static void ldv_spin_unlock_irqrestore_96_0(spinlock_t *lock, unsigned long flags);


#line 37  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void ldv_mutex_lock_103_0(struct mutex *ldv_func_arg1);


#line 41 
static void ldv_mutex_lock_110(struct mutex *ldv_func_arg1);


#line 45 
static void ldv_mutex_lock_112_0(struct mutex *ldv_func_arg1);


#line 49 
static void ldv_mutex_lock_114(struct mutex *ldv_func_arg1);


#line 53 
static void ldv_mutex_lock_116(struct mutex *ldv_func_arg1);


#line 57 
static void ldv_mutex_lock_118(struct mutex *ldv_func_arg1);


#line 63 
static int ldv_mutex_lock_interruptible_97(struct mutex *ldv_func_arg1);


#line 67 
static int ldv_mutex_lock_interruptible_99(struct mutex *ldv_func_arg1);


#line 71 
static int ldv_mutex_lock_interruptible_101(struct mutex *ldv_func_arg1);


#line 106 
static void ldv___ldv_spin_lock_87_2(spinlock_t *ldv_func_arg1);


#line 114 
static void ldv___ldv_spin_lock_91_2(spinlock_t *ldv_func_arg1);


#line 122 
static void ldv___ldv_spin_lock_95_0(spinlock_t *ldv_func_arg1);


#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
static int ldv_mutex_is_locked_105(struct mutex *lock);


#line 145 
static int ldv_mutex_is_locked_109(struct mutex *lock);


#line 149 
static int ldv_mutex_is_locked_120(struct mutex *lock);


#line 193 
static void ldv_mutex_unlock_98_1(struct mutex *ldv_func_arg1);


#line 197 
static void ldv_mutex_unlock_100_0(struct mutex *ldv_func_arg1);


#line 201 
static void ldv_mutex_unlock_102(struct mutex *ldv_func_arg1);


#line 205 
static void ldv_mutex_unlock_104(struct mutex *ldv_func_arg1);


#line 209 
static void ldv_mutex_unlock_111(struct mutex *ldv_func_arg1);


#line 213 
static void ldv_mutex_unlock_113_0(struct mutex *ldv_func_arg1);


#line 217 
static void ldv_mutex_unlock_115(struct mutex *ldv_func_arg1);


#line 221 
static void ldv_mutex_unlock_117(struct mutex *ldv_func_arg1);


#line 225 
static void ldv_mutex_unlock_119(struct mutex *ldv_func_arg1);


#line 173  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
static int ldv_mod_timer_106(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2);


#line 232 
static int ldv_del_timer_sync_125(struct timer_list *ldv_func_arg1);


#line 257 
unsigned long round_jiffies_up(unsigned long);


#line 2845  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
__inline static int test_tsk_thread_flag(struct task_struct *tsk, int flag)
{
  int tmp;
  
#line 2847 
  tmp = test_ti_thread_flag((struct thread_info *)tsk->stack,flag);
  
#line 2847 
  return tmp;
}


#line 2871  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
__inline static int signal_pending(struct task_struct *p)
{
  int __retres;
  int tmp;
  
#line 2873 
  tmp = test_tsk_thread_flag(p,2);
  
#line 2873 
  __retres = (long)(tmp != 0);
  
#line 2873 
  return __retres;
}


#line 2903 
int _cond_resched(void);


#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kmalloc_3(size_t size, gfp_t flags);


#line 542 
static void *kcalloc_8(size_t n, size_t size, gfp_t flags);


#line 581 
static void *kzalloc_7(size_t size, gfp_t flags);


#line 813  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_dev *pci_dev_get(struct pci_dev *);


#line 814 
void pci_dev_put(struct pci_dev *);


#line 843 
struct pci_dev *pci_get_device(unsigned int, unsigned int, struct pci_dev *);


#line 1026 
int pci_save_state(struct pci_dev *);


#line 1027 
void pci_restore_state(struct pci_dev *);


#line 580  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/i2c.h"
void i2c_del_adapter(struct i2c_adapter *);


#line 663  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
char const * const efx_reset_type_names[16U];


#line 664 
unsigned int const efx_reset_type_max;


#line 706  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
__inline static bool efx_link_state_equal(struct efx_link_state const *left, struct efx_link_state const *right)
{
  bool __retres;
  
#line 710 
  __retres = (_Bool)(((((int)left->up == (int)right->up && (int)left->fd == (int)right->fd) && (int)left->fc == (int)right->fc) && left->speed == right->speed) != 0);
  
#line 710 
  return __retres;
}


#line 238  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
__inline static void efx_schedule_channel_1(struct efx_channel *channel)
{
  
#line 240 
  if (0) {
    
#line 240 
    if (((channel->efx)->msg_enable & 512U) != 0U) {
      int tmp_3;
      {
        int pscr_ret__;
        {
          
#line 240 
          void const *__vpp_verify = (void const *)0;
          
#line 240 
          void const *tmp = __vpp_verify;
        }
        
#line 240 
        switch (4UL) {
          int tmp_0;
          int tmp_0_0;
          int tmp_1;
          int tmp_2;
          case (unsigned long)1: 
#line 240 
          ;
          {
            int pfo_ret__;
            
#line 240 
            switch (4UL) {
              case (unsigned long)1: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55584;
              case (unsigned long)2: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55584;
              case (unsigned long)4: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55584;
              case (unsigned long)8: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55584;
              default: 
#line 240 
              ;
              
#line 240 
              __bad_percpu_size();
            }
            ldv_55584: 
#line 240 
            ;
            
#line 240 
            tmp_0 = pfo_ret__;
          }
          
#line 240 
          pscr_ret__ = tmp_0;
          
#line 240 
          goto ldv_55590;
          case (unsigned long)2: 
#line 240 
          ;
          {
            int pfo_ret___0;
            
#line 240 
            switch (4UL) {
              case (unsigned long)1: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55594;
              case (unsigned long)2: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55594;
              case (unsigned long)4: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55594;
              case (unsigned long)8: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55594;
              default: 
#line 240 
              ;
              
#line 240 
              __bad_percpu_size();
            }
            ldv_55594: 
#line 240 
            ;
            
#line 240 
            tmp_0_0 = pfo_ret___0;
          }
          
#line 240 
          pscr_ret__ = tmp_0_0;
          
#line 240 
          goto ldv_55590;
          case (unsigned long)4: 
#line 240 
          ;
          {
            int pfo_ret___1;
            
#line 240 
            switch (4UL) {
              case (unsigned long)1: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55603;
              case (unsigned long)2: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55603;
              case (unsigned long)4: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55603;
              case (unsigned long)8: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55603;
              default: 
#line 240 
              ;
              
#line 240 
              __bad_percpu_size();
            }
            ldv_55603: 
#line 240 
            ;
            
#line 240 
            tmp_1 = pfo_ret___1;
          }
          
#line 240 
          pscr_ret__ = tmp_1;
          
#line 240 
          goto ldv_55590;
          case (unsigned long)8: 
#line 240 
          ;
          {
            int pfo_ret___2;
            
#line 240 
            switch (4UL) {
              case (unsigned long)1: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55612;
              case (unsigned long)2: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55612;
              case (unsigned long)4: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55612;
              case (unsigned long)8: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55612;
              default: 
#line 240 
              ;
              
#line 240 
              __bad_percpu_size();
            }
            ldv_55612: 
#line 240 
            ;
            
#line 240 
            tmp_2 = pfo_ret___2;
          }
          
#line 240 
          pscr_ret__ = tmp_2;
          
#line 240 
          goto ldv_55590;
          default: 
#line 240 
          ;
          
#line 240 
          __bad_size_call_parameter();
          
#line 240 
          goto ldv_55590;
        }
        ldv_55590: 
#line 240 
        ;
        
#line 240 
        tmp_3 = pscr_ret__;
      }
      
#line 240 
      ;
      
#line 240 
      ;
      
#line 240 
      netdev_printk("\001",(struct net_device const *)(channel->efx)->net_dev,"channel %d scheduling NAPI poll on CPU%d\n",channel->channel,tmp_3);
    }
    else ;
  }
  else ;
  
#line 244 
  napi_schedule(& channel->napi_str);
  
#line 245 
  return;
}


#line 247  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
__inline static void efx_schedule_channel_irq_1(struct efx_channel *channel)
{
  int tmp_3;
  {
    int pscr_ret__;
    {
      
#line 249 
      void const *__vpp_verify = (void const *)0;
      
#line 249 
      void const *tmp = __vpp_verify;
    }
    
#line 249 
    switch (4UL) {
      int tmp_0;
      int tmp_0_0;
      int tmp_1;
      int tmp_2;
      case (unsigned long)1: 
#line 249 
      ;
      {
        int pfo_ret__;
        
#line 249 
        switch (4UL) {
          case (unsigned long)1: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55629;
          case (unsigned long)2: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55629;
          case (unsigned long)4: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55629;
          case (unsigned long)8: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55629;
          default: 
#line 249 
          ;
          
#line 249 
          __bad_percpu_size();
        }
        ldv_55629: 
#line 249 
        ;
        
#line 249 
        tmp_0 = pfo_ret__;
      }
      
#line 249 
      pscr_ret__ = tmp_0;
      
#line 249 
      goto ldv_55635;
      case (unsigned long)2: 
#line 249 
      ;
      {
        int pfo_ret___0;
        
#line 249 
        switch (4UL) {
          case (unsigned long)1: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55639;
          case (unsigned long)2: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55639;
          case (unsigned long)4: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55639;
          case (unsigned long)8: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55639;
          default: 
#line 249 
          ;
          
#line 249 
          __bad_percpu_size();
        }
        ldv_55639: 
#line 249 
        ;
        
#line 249 
        tmp_0_0 = pfo_ret___0;
      }
      
#line 249 
      pscr_ret__ = tmp_0_0;
      
#line 249 
      goto ldv_55635;
      case (unsigned long)4: 
#line 249 
      ;
      {
        int pfo_ret___1;
        
#line 249 
        switch (4UL) {
          case (unsigned long)1: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55648;
          case (unsigned long)2: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55648;
          case (unsigned long)4: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55648;
          case (unsigned long)8: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55648;
          default: 
#line 249 
          ;
          
#line 249 
          __bad_percpu_size();
        }
        ldv_55648: 
#line 249 
        ;
        
#line 249 
        tmp_1 = pfo_ret___1;
      }
      
#line 249 
      pscr_ret__ = tmp_1;
      
#line 249 
      goto ldv_55635;
      case (unsigned long)8: 
#line 249 
      ;
      {
        int pfo_ret___2;
        
#line 249 
        switch (4UL) {
          case (unsigned long)1: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55657;
          case (unsigned long)2: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55657;
          case (unsigned long)4: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55657;
          case (unsigned long)8: 
#line 249 
          ;
          
#line 250 
          ldv_inline_asm();
          
#line 249 
          goto ldv_55657;
          default: 
#line 249 
          ;
          
#line 249 
          __bad_percpu_size();
        }
        ldv_55657: 
#line 249 
        ;
        
#line 249 
        tmp_2 = pfo_ret___2;
      }
      
#line 249 
      pscr_ret__ = tmp_2;
      
#line 249 
      goto ldv_55635;
      default: 
#line 249 
      ;
      
#line 249 
      __bad_size_call_parameter();
      
#line 249 
      goto ldv_55635;
    }
    ldv_55635: 
#line 249 
    ;
    
#line 249 
    tmp_3 = pscr_ret__;
  }
  
#line 249 
  channel->event_test_cpu = tmp_3;
  
#line 250 
  efx_schedule_channel_1(channel);
  
#line 251 
  return;
}


#line 253 
void efx_link_status_changed(struct efx_nic *efx);


#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/i2c-algo-bit.h"
int i2c_bit_add_bus(struct i2c_adapter *);


#line 228  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
__inline static bool falcon_spi_present(struct falcon_spi_device const *spi)
{
  bool __retres;
  
#line 230 
  __retres = (_Bool)(spi->size != 0U);
  
#line 230 
  return __retres;
}


#line 583 
struct efx_nic_type const falcon_a1_nic_type;


#line 584 
struct efx_nic_type const falcon_b0_nic_type;


#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/io.h"
__inline static void efx_writeo_2(struct efx_nic *efx, efx_oword_t const *value, unsigned int reg)
{
  unsigned long flags;
  
#line 113 
  ldv___ldv_spin_lock_87_2(& efx->biu_lock);
  
#line 115 
  _efx_writeq(efx,value->u64[0],reg);
  
#line 116 
  _efx_writeq(efx,value->u64[1],reg + 8U);
  
#line 117 
  ldv_inline_asm();
  
#line 124 
  ldv_spin_unlock_irqrestore_88_2(& efx->biu_lock,flags);
  
#line 125 
  return;
}


#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/io.h"
__inline static void efx_reado_2(struct efx_nic *efx, efx_oword_t *value, unsigned int reg)
{
  unsigned long flags;
  
#line 167 
  ldv___ldv_spin_lock_91_2(& efx->biu_lock);
  
#line 168 
  value->u32[0] = _efx_readd(efx,reg);
  
#line 169 
  value->u32[1] = _efx_readd(efx,reg + 4U);
  
#line 170 
  value->u32[2] = _efx_readd(efx,reg + 8U);
  
#line 171 
  value->u32[3] = _efx_readd(efx,reg + 12U);
  
#line 172 
  ldv_spin_unlock_irqrestore_92_2(& efx->biu_lock,flags);
  
#line 176 
  return;
}


#line 282  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/io.h"
__inline static void _efx_writed_page_locked_0(struct efx_nic *efx, efx_dword_t const *value, unsigned int reg, unsigned int page)
{
  unsigned long flags;
  
#line 289 
  if (page == 0U) {
    
#line 290 
    ldv___ldv_spin_lock_95_0(& efx->biu_lock);
    
#line 291 
    efx_writed(efx,value,page * 8192U + reg);
    
#line 292 
    ldv_spin_unlock_irqrestore_96_0(& efx->biu_lock,flags);
  }
  else 
#line 294 
       efx_writed(efx,value,page * 8192U + reg);
  
#line 295 
  return;
}


#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/phy.h"
struct efx_phy_operations const falcon_sfx7101_phy_ops;


#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mdio_10g.h"
__inline static bool efx_mdio_phyxgxs_lane_sync(struct efx_nic *efx)
{
  int i;
  int lane_status;
  bool sync;
  
#line 48 
  i = 0;
  
#line 48 
  goto ldv_56733;
  ldv_56732: 
#line 49 
  ;
  
#line 49 
  lane_status = efx_mdio_read(efx,4,24);
  
#line 48 
  i += 1;
  ldv_56733: 
#line 49 
  ;
  
#line 48 
  if (i <= 1) 
#line 50 
              goto ldv_56732; else 
#line 53 
                                   goto ldv_56734;
  ldv_56734: 
#line 54 
  ;
  
#line 52 
  sync = (_Bool)((lane_status & 4096) != 0);
  
#line 53 
  if (! sync) {
    
#line 54 
    if ((efx->msg_enable & 8192U) != 0U) {
      
#line 54 
      struct _ddebug descriptor = {.modname = "sfc", .function = "efx_mdio_phyxgxs_lane_sync", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mdio_10g.h", .format = "XGXS lane status: %x\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))55U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 54 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 54 
                                                          __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"XGXS lane status: %x\n",lane_status); else ;
    }
    else ;
  }
  else ;
  
#line 56 
  return sync;
}


#line 148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static struct efx_hw_stat_desc const falcon_stat_desc[49U] = {{.name = "rx_noskb_drops", .dma_width = (unsigned short)0U, .offset = (unsigned short)0U}, {.name = "rx_nodesc_trunc", .dma_width = (unsigned short)0U, .offset = (unsigned short)0U}, {.name = "tx_bytes", .dma_width = (unsigned short)64U, .offset = (unsigned short)136U}, {.name = "tx_packets", .dma_width = (unsigned short)32U, .offset = (unsigned short)128U}, {.name = "tx_pause", .dma_width = (unsigned short)32U, .offset = (unsigned short)160U}, {.name = "tx_control", .dma_width = (unsigned short)32U, .offset = (unsigned short)156U}, {.name = "tx_unicast", .dma_width = (unsigned short)32U, .offset = (unsigned short)152U}, {.name = "tx_multicast", .dma_width = (unsigned short)32U, .offset = (unsigned short)144U}, {.name = "tx_broadcast", .dma_width = (unsigned short)32U, .offset = (unsigned short)148U}, {.name = "tx_lt64", .dma_width = (unsigned short)32U, .offset = (unsigned short)192U}, {.name = "tx_64", .dma_width = (unsigned short)32U, .offset = (unsigned short)164U}, {.name = "tx_65_to_127", .dma_width = (unsigned short)32U, .offset = (unsigned short)168U}, {.name = "tx_128_to_255", .dma_width = (unsigned short)32U, .offset = (unsigned short)172U}, {.name = "tx_256_to_511", .dma_width = (unsigned short)32U, .offset = (unsigned short)176U}, {.name = "tx_512_to_1023", .dma_width = (unsigned short)32U, .offset = (unsigned short)180U}, {.name = "tx_1024_to_15xx", .dma_width = (unsigned short)32U, .offset = (unsigned short)184U}, {.name = "tx_15xx_to_jumbo", .dma_width = (unsigned short)32U, .offset = (unsigned short)188U}, {.name = "tx_gtjumbo", .dma_width = (unsigned short)32U, .offset = (unsigned short)196U}, {.name = "tx_non_tcpudp", .dma_width = (unsigned short)16U, .offset = (unsigned short)200U}, {.name = "tx_mac_src_error", .dma_width = (unsigned short)16U, .offset = (unsigned short)204U}, {.name = "tx_ip_src_error", .dma_width = (unsigned short)16U, .offset = (unsigned short)208U}, {.name = "rx_bytes", .dma_width = (unsigned short)64U, .offset = (unsigned short)0U}, {.name = "rx_good_bytes", .dma_width = (unsigned short)64U, .offset = (unsigned short)8U}, {.name = "rx_bad_bytes", .dma_width = (unsigned short)0U, .offset = (unsigned short)0U}, {.name = "rx_packets", .dma_width = (unsigned short)32U, .offset = (unsigned short)16U}, {.name = "rx_good", .dma_width = (unsigned short)32U, .offset = (unsigned short)20U}, {.name = "rx_bad", .dma_width = (unsigned short)32U, .offset = (unsigned short)56U}, {.name = "rx_pause", .dma_width = (unsigned short)32U, .offset = (unsigned short)76U}, {.name = "rx_control", .dma_width = (unsigned short)32U, .offset = (unsigned short)72U}, {.name = "rx_unicast", .dma_width = (unsigned short)32U, .offset = (unsigned short)32U}, {.name = "rx_multicast", .dma_width = (unsigned short)32U, .offset = (unsigned short)28U}, {.name = "rx_broadcast", .dma_width = (unsigned short)32U, .offset = (unsigned short)24U}, {.name = "rx_lt64", .dma_width = (unsigned short)32U, .offset = (unsigned short)36U}, {.name = "rx_64", .dma_width = (unsigned short)32U, .offset = (unsigned short)80U}, {.name = "rx_65_to_127", .dma_width = (unsigned short)32U, .offset = (unsigned short)84U}, {.name = "rx_128_to_255", .dma_width = (unsigned short)32U, .offset = (unsigned short)88U}, {.name = "rx_256_to_511", .dma_width = (unsigned short)32U, .offset = (unsigned short)92U}, {.name = "rx_512_to_1023", .dma_width = (unsigned short)32U, .offset = (unsigned short)96U}, {.name = "rx_1024_to_15xx", .dma_width = (unsigned short)32U, .offset = (unsigned short)100U}, {.name = "rx_15xx_to_jumbo", .dma_width = (unsigned short)32U, .offset = (unsigned short)104U}, {.name = "rx_gtjumbo", .dma_width = (unsigned short)32U, .offset = (unsigned short)40U}, {.name = "rx_bad_lt64", .dma_width = (unsigned short)32U, .offset = (unsigned short)48U}, {.name = "rx_bad_gtjumbo", .dma_width = (unsigned short)32U, .offset = (unsigned short)44U}, {.name = "rx_overflow", .dma_width = (unsigned short)32U, .offset = (unsigned short)52U}, {.name = "rx_symbol_error", .dma_width = (unsigned short)32U, .offset = (unsigned short)64U}, {.name = "rx_align_error", .dma_width = (unsigned short)32U, .offset = (unsigned short)60U}, {.name = "rx_length_error", .dma_width = (unsigned short)32U, .offset = (unsigned short)108U}, {.name = "rx_internal_error", .dma_width = (unsigned short)32U, .offset = (unsigned short)68U}, {.name = "rx_nodesc_drop_cnt", .dma_width = (unsigned short)0U, .offset = (unsigned short)0U}};

#line 199  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static unsigned long const falcon_stat_mask[1U] = {18446744073709551615UL};

#line 302 
static int falcon_reset_hw(struct efx_nic *efx, enum reset_type method);


#line 303 
static void falcon_reconfigure_mac_wrapper(struct efx_nic *efx);


#line 308  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static unsigned int const large_eeprom_type = 83886221U;

#line 313  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static unsigned int const default_flash_type = 135221969U;

#line 327  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static void falcon_setsda(void *data, int state)
{
  efx_oword_t reg;
  unsigned long long tmp;
  
#line 329 
  struct efx_nic *efx = (struct efx_nic *)data;
  
#line 332 
  efx_reado_2(efx,& reg,528U);
  
#line 333 
  if (state == 0) 
#line 333 
                  tmp = 134217728ULL; else 
#line 333 
                                           tmp = 0ULL;
  
#line 333 
  reg.u64[0] = (reg.u64[0] & 18446744073575333887ULL) | tmp;
  
#line 333 
  reg.u64[1] = reg.u64[1];
  
#line 334 
  efx_writeo_2(efx,(efx_oword_t const *)(& reg),528U);
  
#line 335 
  return;
}


#line 337  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static void falcon_setscl(void *data, int state)
{
  efx_oword_t reg;
  unsigned long long tmp;
  
#line 339 
  struct efx_nic *efx = (struct efx_nic *)data;
  
#line 342 
  efx_reado_2(efx,& reg,528U);
  
#line 343 
  if (state == 0) 
#line 343 
                  tmp = 16777216ULL; else 
#line 343 
                                          tmp = 0ULL;
  
#line 343 
  reg.u64[0] = (reg.u64[0] & 18446744073692774399ULL) | tmp;
  
#line 343 
  reg.u64[1] = reg.u64[1];
  
#line 344 
  efx_writeo_2(efx,(efx_oword_t const *)(& reg),528U);
  
#line 345 
  return;
}


#line 347  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_getsda(void *data)
{
  int __retres;
  efx_oword_t reg;
  
#line 349 
  struct efx_nic *efx = (struct efx_nic *)data;
  
#line 352 
  efx_reado_2(efx,& reg,528U);
  
#line 353 
  __retres = (int)(reg.u64[0] >> 11) & 1;
  
#line 353 
  return __retres;
}


#line 356  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_getscl(void *data)
{
  int __retres;
  efx_oword_t reg;
  
#line 358 
  struct efx_nic *efx = (struct efx_nic *)data;
  
#line 361 
  efx_reado_2(efx,& reg,528U);
  
#line 362 
  __retres = (int)(reg.u64[0] >> 8) & 1;
  
#line 362 
  return __retres;
}


#line 365  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static struct i2c_algo_bit_data const falcon_i2c_bit_operations = {.data = (void *)0, .setsda = & falcon_setsda, .setscl = & falcon_setscl, .getsda = & falcon_getsda, .getscl = & falcon_getscl, .pre_xfer = (int (*)(struct i2c_adapter *))0, .post_xfer = (void (*)(struct i2c_adapter *))0, .udelay = 5, .timeout = 13};

#line 393 
void __compiletime_assert_393(void);


#line 375  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static void falcon_push_irq_moderation(struct efx_channel *channel)
{
  efx_dword_t timer_cmd;
  
#line 378 
  struct efx_nic *efx = channel->efx;
  
#line 381 
  if (channel->irq_moderation != 0U) 
#line 382 
                                     timer_cmd.u32[0] = (channel->irq_moderation + 4294967295U) | 8192U; else 
                                                                    
#line 388 
                                                                    timer_cmd.u32[0] = 0U;
  {
    
#line 393 
    bool __cond = (_Bool)0;
    
#line 393 
    if ((int)__cond != 0) 
#line 393 
                          __compiletime_assert_393(); else ;
  }
  
#line 394 
  _efx_writed_page_locked_0(efx,(efx_dword_t const *)(& timer_cmd),1056U,(unsigned int)channel->channel);
  
#line 395 
  return;
}


#line 398 
static void falcon_deconfigure_mac_wrapper(struct efx_nic *efx);


#line 400  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static void falcon_prepare_flush(struct efx_nic *efx)
{
  
#line 402 
  falcon_deconfigure_mac_wrapper(efx);
  
#line 407 
  msleep(10U);
  
#line 408 
  return;
}


#line 420  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
__inline static void falcon_irq_ack_a1(struct efx_nic *efx)
{
  efx_dword_t reg;
  
#line 424 
  reg.u32[0] = 12053374U;
  
#line 425 
  efx_writed(efx,(efx_dword_t const *)(& reg),80U);
  
#line 426 
  efx_readd(efx,& reg,112U);
  
#line 427 
  return;
}


#line 461 
void __compiletime_assert_461(void);


#line 429  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static irqreturn_t falcon_legacy_interrupt_a1(int irq, void *dev_id)
{
  irqreturn_t __retres;
  int syserr;
  int queues;
  int tmp_8;
  bool volatile *tmp_14;
  
#line 431 
  struct efx_nic *efx = (struct efx_nic *)dev_id;
  
#line 432 
  efx_oword_t *int_ker = (efx_oword_t *)efx->irq_status.addr;
  
#line 439 
  if ((long)((int_ker->u64[0] | int_ker->u64[1]) == 0ULL) != 0L) {
    
#line 440 
    if (0) {
      
#line 440 
      if ((efx->msg_enable & 512U) != 0U) {
        int tmp_3;
        {
          int pscr_ret__;
          {
            
#line 440 
            void const *__vpp_verify = (void const *)0;
            
#line 440 
            void const *tmp = __vpp_verify;
          }
          
#line 440 
          switch (4UL) {
            int tmp_0;
            int tmp_0_0;
            int tmp_1;
            int tmp_2;
            case (unsigned long)1: 
#line 440 
            ;
            {
              int pfo_ret__;
              
#line 440 
              switch (4UL) {
                case (unsigned long)1: 
#line 440 
                ;
                
#line 441 
                ldv_inline_asm();
                
#line 440 
                goto ldv_56870;
                case (unsigned long)2: 
#line 440 
                ;
                
#line 441 
                ldv_inline_asm();
                
#line 440 
                goto ldv_56870;
                case (unsigned long)4: 
#line 440 
                ;
                
#line 441 
                ldv_inline_asm();
                
#line 440 
                goto ldv_56870;
                case (unsigned long)8: 
#line 440 
                ;
                
#line 441 
                ldv_inline_asm();
                
#line 440 
                goto ldv_56870;
                default: 
#line 440 
                ;
                
#line 440 
                __bad_percpu_size();
              }
              ldv_56870: 
#line 440 
              ;
              
#line 440 
              tmp_0 = pfo_ret__;
            }
            
#line 440 
            pscr_ret__ = tmp_0;
            
#line 440 
            goto ldv_56876;
            case (unsigned long)2: 
#line 440 
            ;
            {
              int pfo_ret___0;
              
#line 440 
              switch (4UL) {
                case (unsigned long)1: 
#line 440 
                ;
                
#line 441 
                ldv_inline_asm();
                
#line 440 
                goto ldv_56880;
                case (unsigned long)2: 
#line 440 
                ;
                
#line 441 
                ldv_inline_asm();
                
#line 440 
                goto ldv_56880;
                case (unsigned long)4: 
#line 440 
                ;
                
#line 441 
                ldv_inline_asm();
                
#line 440 
                goto ldv_56880;
                case (unsigned long)8: 
#line 440 
                ;
                
#line 441 
                ldv_inline_asm();
                
#line 440 
                goto ldv_56880;
                default: 
#line 440 
                ;
                
#line 440 
                __bad_percpu_size();
              }
              ldv_56880: 
#line 440 
              ;
              
#line 440 
              tmp_0_0 = pfo_ret___0;
            }
            
#line 440 
            pscr_ret__ = tmp_0_0;
            
#line 440 
            goto ldv_56876;
            case (unsigned long)4: 
#line 440 
            ;
            {
              int pfo_ret___1;
              
#line 440 
              switch (4UL) {
                case (unsigned long)1: 
#line 440 
                ;
                
#line 441 
                ldv_inline_asm();
                
#line 440 
                goto ldv_56889;
                case (unsigned long)2: 
#line 440 
                ;
                
#line 441 
                ldv_inline_asm();
                
#line 440 
                goto ldv_56889;
                case (unsigned long)4: 
#line 440 
                ;
                
#line 441 
                ldv_inline_asm();
                
#line 440 
                goto ldv_56889;
                case (unsigned long)8: 
#line 440 
                ;
                
#line 441 
                ldv_inline_asm();
                
#line 440 
                goto ldv_56889;
                default: 
#line 440 
                ;
                
#line 440 
                __bad_percpu_size();
              }
              ldv_56889: 
#line 440 
              ;
              
#line 440 
              tmp_1 = pfo_ret___1;
            }
            
#line 440 
            pscr_ret__ = tmp_1;
            
#line 440 
            goto ldv_56876;
            case (unsigned long)8: 
#line 440 
            ;
            {
              int pfo_ret___2;
              
#line 440 
              switch (4UL) {
                case (unsigned long)1: 
#line 440 
                ;
                
#line 441 
                ldv_inline_asm();
                
#line 440 
                goto ldv_56898;
                case (unsigned long)2: 
#line 440 
                ;
                
#line 441 
                ldv_inline_asm();
                
#line 440 
                goto ldv_56898;
                case (unsigned long)4: 
#line 440 
                ;
                
#line 441 
                ldv_inline_asm();
                
#line 440 
                goto ldv_56898;
                case (unsigned long)8: 
#line 440 
                ;
                
#line 441 
                ldv_inline_asm();
                
#line 440 
                goto ldv_56898;
                default: 
#line 440 
                ;
                
#line 440 
                __bad_percpu_size();
              }
              ldv_56898: 
#line 440 
              ;
              
#line 440 
              tmp_2 = pfo_ret___2;
            }
            
#line 440 
            pscr_ret__ = tmp_2;
            
#line 440 
            goto ldv_56876;
            default: 
#line 440 
            ;
            
#line 440 
            __bad_size_call_parameter();
            
#line 440 
            goto ldv_56876;
          }
          ldv_56876: 
#line 440 
          ;
          
#line 440 
          tmp_3 = pscr_ret__;
        }
        
#line 440 
        ;
        
#line 440 
        ;
        
#line 440 
        netdev_printk("\001",(struct net_device const *)efx->net_dev,"IRQ %d on CPU %d not for me\n",irq,tmp_3);
      }
      else ;
    }
    else ;
    
#line 443 
    __retres = IRQ_NONE;
    
#line 443 
    goto return_label;
  }
  else ;
  {
    int pscr_ret___0;
    {
      
#line 445 
      void const *__vpp_verify_0 = (void const *)0;
      
#line 445 
      void const *tmp_4 = __vpp_verify_0;
    }
    
#line 445 
    switch (4UL) {
      int tmp_4_0;
      int tmp_5;
      int tmp_6;
      int tmp_7;
      case (unsigned long)1: 
#line 445 
      ;
      {
        int pfo_ret___3;
        
#line 445 
        switch (4UL) {
          case (unsigned long)1: 
#line 445 
          ;
          
#line 446 
          ldv_inline_asm();
          
#line 445 
          goto ldv_56912;
          case (unsigned long)2: 
#line 445 
          ;
          
#line 446 
          ldv_inline_asm();
          
#line 445 
          goto ldv_56912;
          case (unsigned long)4: 
#line 445 
          ;
          
#line 446 
          ldv_inline_asm();
          
#line 445 
          goto ldv_56912;
          case (unsigned long)8: 
#line 445 
          ;
          
#line 446 
          ldv_inline_asm();
          
#line 445 
          goto ldv_56912;
          default: 
#line 445 
          ;
          
#line 445 
          __bad_percpu_size();
        }
        ldv_56912: 
#line 445 
        ;
        
#line 445 
        tmp_4_0 = pfo_ret___3;
      }
      
#line 445 
      pscr_ret___0 = tmp_4_0;
      
#line 445 
      goto ldv_56918;
      case (unsigned long)2: 
#line 445 
      ;
      {
        int pfo_ret___4;
        
#line 445 
        switch (4UL) {
          case (unsigned long)1: 
#line 445 
          ;
          
#line 446 
          ldv_inline_asm();
          
#line 445 
          goto ldv_56922;
          case (unsigned long)2: 
#line 445 
          ;
          
#line 446 
          ldv_inline_asm();
          
#line 445 
          goto ldv_56922;
          case (unsigned long)4: 
#line 445 
          ;
          
#line 446 
          ldv_inline_asm();
          
#line 445 
          goto ldv_56922;
          case (unsigned long)8: 
#line 445 
          ;
          
#line 446 
          ldv_inline_asm();
          
#line 445 
          goto ldv_56922;
          default: 
#line 445 
          ;
          
#line 445 
          __bad_percpu_size();
        }
        ldv_56922: 
#line 445 
        ;
        
#line 445 
        tmp_5 = pfo_ret___4;
      }
      
#line 445 
      pscr_ret___0 = tmp_5;
      
#line 445 
      goto ldv_56918;
      case (unsigned long)4: 
#line 445 
      ;
      {
        int pfo_ret___5;
        
#line 445 
        switch (4UL) {
          case (unsigned long)1: 
#line 445 
          ;
          
#line 446 
          ldv_inline_asm();
          
#line 445 
          goto ldv_56931;
          case (unsigned long)2: 
#line 445 
          ;
          
#line 446 
          ldv_inline_asm();
          
#line 445 
          goto ldv_56931;
          case (unsigned long)4: 
#line 445 
          ;
          
#line 446 
          ldv_inline_asm();
          
#line 445 
          goto ldv_56931;
          case (unsigned long)8: 
#line 445 
          ;
          
#line 446 
          ldv_inline_asm();
          
#line 445 
          goto ldv_56931;
          default: 
#line 445 
          ;
          
#line 445 
          __bad_percpu_size();
        }
        ldv_56931: 
#line 445 
        ;
        
#line 445 
        tmp_6 = pfo_ret___5;
      }
      
#line 445 
      pscr_ret___0 = tmp_6;
      
#line 445 
      goto ldv_56918;
      case (unsigned long)8: 
#line 445 
      ;
      {
        int pfo_ret___6;
        
#line 445 
        switch (4UL) {
          case (unsigned long)1: 
#line 445 
          ;
          
#line 446 
          ldv_inline_asm();
          
#line 445 
          goto ldv_56940;
          case (unsigned long)2: 
#line 445 
          ;
          
#line 446 
          ldv_inline_asm();
          
#line 445 
          goto ldv_56940;
          case (unsigned long)4: 
#line 445 
          ;
          
#line 446 
          ldv_inline_asm();
          
#line 445 
          goto ldv_56940;
          case (unsigned long)8: 
#line 445 
          ;
          
#line 446 
          ldv_inline_asm();
          
#line 445 
          goto ldv_56940;
          default: 
#line 445 
          ;
          
#line 445 
          __bad_percpu_size();
        }
        ldv_56940: 
#line 445 
        ;
        
#line 445 
        tmp_7 = pfo_ret___6;
      }
      
#line 445 
      pscr_ret___0 = tmp_7;
      
#line 445 
      goto ldv_56918;
      default: 
#line 445 
      ;
      
#line 445 
      __bad_size_call_parameter();
      
#line 445 
      goto ldv_56918;
    }
    ldv_56918: 
#line 445 
    ;
    
#line 445 
    tmp_8 = pscr_ret___0;
  }
  
#line 445 
  efx->last_irq_cpu = tmp_8;
  
#line 446 
  if (0) {
    
#line 446 
    if ((efx->msg_enable & 512U) != 0U) {
      int tmp_13;
      
#line 446 
      ;
      
#line 446 
      ;
      
#line 446 
      ;
      
#line 446 
      ;
      {
        int pscr_ret___1;
        {
          
#line 446 
          void const *__vpp_verify_1 = (void const *)0;
          
#line 446 
          void const *tmp_9 = __vpp_verify_1;
        }
        
#line 446 
        switch (4UL) {
          int tmp_9_0;
          int tmp_10;
          int tmp_11;
          int tmp_12;
          case (unsigned long)1: 
#line 446 
          ;
          {
            int pfo_ret___7;
            
#line 446 
            switch (4UL) {
              case (unsigned long)1: 
#line 446 
              ;
              
#line 447 
              ldv_inline_asm();
              
#line 446 
              goto ldv_56953;
              case (unsigned long)2: 
#line 446 
              ;
              
#line 447 
              ldv_inline_asm();
              
#line 446 
              goto ldv_56953;
              case (unsigned long)4: 
#line 446 
              ;
              
#line 447 
              ldv_inline_asm();
              
#line 446 
              goto ldv_56953;
              case (unsigned long)8: 
#line 446 
              ;
              
#line 447 
              ldv_inline_asm();
              
#line 446 
              goto ldv_56953;
              default: 
#line 446 
              ;
              
#line 446 
              __bad_percpu_size();
            }
            ldv_56953: 
#line 446 
            ;
            
#line 446 
            tmp_9_0 = pfo_ret___7;
          }
          
#line 446 
          pscr_ret___1 = tmp_9_0;
          
#line 446 
          goto ldv_56959;
          case (unsigned long)2: 
#line 446 
          ;
          {
            int pfo_ret___8;
            
#line 446 
            switch (4UL) {
              case (unsigned long)1: 
#line 446 
              ;
              
#line 447 
              ldv_inline_asm();
              
#line 446 
              goto ldv_56963;
              case (unsigned long)2: 
#line 446 
              ;
              
#line 447 
              ldv_inline_asm();
              
#line 446 
              goto ldv_56963;
              case (unsigned long)4: 
#line 446 
              ;
              
#line 447 
              ldv_inline_asm();
              
#line 446 
              goto ldv_56963;
              case (unsigned long)8: 
#line 446 
              ;
              
#line 447 
              ldv_inline_asm();
              
#line 446 
              goto ldv_56963;
              default: 
#line 446 
              ;
              
#line 446 
              __bad_percpu_size();
            }
            ldv_56963: 
#line 446 
            ;
            
#line 446 
            tmp_10 = pfo_ret___8;
          }
          
#line 446 
          pscr_ret___1 = tmp_10;
          
#line 446 
          goto ldv_56959;
          case (unsigned long)4: 
#line 446 
          ;
          {
            int pfo_ret___9;
            
#line 446 
            switch (4UL) {
              case (unsigned long)1: 
#line 446 
              ;
              
#line 447 
              ldv_inline_asm();
              
#line 446 
              goto ldv_56972;
              case (unsigned long)2: 
#line 446 
              ;
              
#line 447 
              ldv_inline_asm();
              
#line 446 
              goto ldv_56972;
              case (unsigned long)4: 
#line 446 
              ;
              
#line 447 
              ldv_inline_asm();
              
#line 446 
              goto ldv_56972;
              case (unsigned long)8: 
#line 446 
              ;
              
#line 447 
              ldv_inline_asm();
              
#line 446 
              goto ldv_56972;
              default: 
#line 446 
              ;
              
#line 446 
              __bad_percpu_size();
            }
            ldv_56972: 
#line 446 
            ;
            
#line 446 
            tmp_11 = pfo_ret___9;
          }
          
#line 446 
          pscr_ret___1 = tmp_11;
          
#line 446 
          goto ldv_56959;
          case (unsigned long)8: 
#line 446 
          ;
          {
            int pfo_ret___10;
            
#line 446 
            switch (4UL) {
              case (unsigned long)1: 
#line 446 
              ;
              
#line 447 
              ldv_inline_asm();
              
#line 446 
              goto ldv_56981;
              case (unsigned long)2: 
#line 446 
              ;
              
#line 447 
              ldv_inline_asm();
              
#line 446 
              goto ldv_56981;
              case (unsigned long)4: 
#line 446 
              ;
              
#line 447 
              ldv_inline_asm();
              
#line 446 
              goto ldv_56981;
              case (unsigned long)8: 
#line 446 
              ;
              
#line 447 
              ldv_inline_asm();
              
#line 446 
              goto ldv_56981;
              default: 
#line 446 
              ;
              
#line 446 
              __bad_percpu_size();
            }
            ldv_56981: 
#line 446 
            ;
            
#line 446 
            tmp_12 = pfo_ret___10;
          }
          
#line 446 
          pscr_ret___1 = tmp_12;
          
#line 446 
          goto ldv_56959;
          default: 
#line 446 
          ;
          
#line 446 
          __bad_size_call_parameter();
          
#line 446 
          goto ldv_56959;
        }
        ldv_56959: 
#line 446 
        ;
        
#line 446 
        tmp_13 = pscr_ret___1;
      }
      
#line 446 
      ;
      
#line 446 
      ;
      
#line 446 
      netdev_printk("\001",(struct net_device const *)efx->net_dev,"IRQ %d on CPU %d status ",irq,tmp_13,int_ker->u32[3],int_ker->u32[2],int_ker->u32[1],int_ker->u32[0]);
    }
    else ;
  }
  else ;
  {
    
#line 450 
    bool __var = (_Bool)0;
    
#line 450 
    tmp_14 = (bool volatile *)(& efx->irq_soft_enabled);
  }
  
#line 450 
  ;
  
#line 450 
  if ((long)((int)*tmp_14 != 0) == 0L) {
    
#line 451 
    __retres = IRQ_HANDLED;
    
#line 451 
    goto return_label;
  }
  else ;
  
#line 454 
  syserr = (int)int_ker->u64[1] & 1;
  
#line 455 
  if ((long)(syserr != 0) != 0L) {
    irqreturn_t tmp_15;
    
#line 456 
    tmp_15 = efx_farch_fatal_interrupt(efx);
    
#line 456 
    __retres = tmp_15;
    
#line 456 
    goto return_label;
  }
  else ;
  {
    
#line 461 
    bool __cond = (_Bool)0;
    
#line 461 
    if ((int)__cond != 0) 
#line 461 
                          __compiletime_assert_461(); else ;
  }
  
#line 462 
  queues = (int)(int_ker->u64[0] >> 40) & 15;
  
#line 463 
  int_ker->u64[0] = 0ULL;
  
#line 463 
  int_ker->u64[1] = 0ULL;
  
#line 464 
  ldv_inline_asm();
  
#line 465 
  falcon_irq_ack_a1(efx);
  
#line 467 
  if ((queues & 1) != 0) {
    struct efx_channel *tmp_16;
    
#line 468 
    tmp_16 = efx_get_channel(efx,0U);
    
#line 468 
    efx_schedule_channel_irq_1(tmp_16);
  }
  else ;
  
#line 469 
  if ((queues & 2) != 0) {
    struct efx_channel *tmp_17;
    
#line 470 
    tmp_17 = efx_get_channel(efx,1U);
    
#line 470 
    efx_schedule_channel_irq_1(tmp_17);
  }
  else ;
  
#line 471 
  __retres = IRQ_HANDLED;
  return_label: 
#line 471 
                return __retres;
}


#line 480  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int dummy_rx_push_rss_config(struct efx_nic *efx, bool user, u32 const *rx_indir_table)
{
  int __retres;
  
#line 486 
  __retres = -38;
  
#line 486 
  return __retres;
}


#line 489  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_b0_rx_push_rss_config(struct efx_nic *efx, bool user, u32 const *rx_indir_table)
{
  int __retres;
  efx_oword_t temp;
  
#line 496 
  memcpy((void *)(& temp),(void const *)(& efx->rx_hash_key),16UL);
  
#line 497 
  efx_writeo_2(efx,(efx_oword_t const *)(& temp),2144U);
  
#line 499 
  memcpy((void *)(& efx->rx_indir_table),(void const *)rx_indir_table,512UL);
  
#line 501 
  efx_farch_rx_push_indir_table(efx);
  
#line 502 
  __retres = 0;
  
#line 502 
  return __retres;
}


#line 514  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_spi_poll(struct efx_nic *efx)
{
  efx_oword_t reg;
  int tmp;
  
#line 517 
  efx_reado_2(efx,& reg,256U);
  
#line 518 
  if ((reg.u64[0] & 2147483648ULL) != 0ULL) 
#line 518 
                                            tmp = -16; else 
#line 518 
                                                            tmp = 0;
  
#line 518 
  return tmp;
}


#line 522  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_spi_wait(struct efx_nic *efx)
{
  int __retres;
  int i;
  int tmp;
  int tmp_0;
  int tmp_1;
  
#line 528 
  unsigned long timeout = jiffies + 26UL;
  
#line 531 
  i = 0;
  
#line 531 
  goto ldv_57017;
  ldv_57016: 
#line 532 
  ;
  
#line 532 
  tmp = falcon_spi_poll(efx);
  
#line 532 
  if (tmp == 0) {
    
#line 533 
    __retres = 0;
    
#line 533 
    goto return_label;
  }
  else ;
  
#line 534 
  __const_udelay(42950UL);
  
#line 531 
  i += 1;
  ldv_57017: 
#line 532 
  ;
  
#line 531 
  if (i <= 9) 
#line 533 
              goto ldv_57016; else 
#line 536 
                                   goto ldv_57018;
  ldv_57018: 
#line 537 
  ;
  ldv_57025: 
#line 538 
  ;
  
#line 538 
  tmp_0 = falcon_spi_poll(efx);
  
#line 538 
  if (tmp_0 == 0) {
    
#line 539 
    __retres = 0;
    
#line 539 
    goto return_label;
  }
  else ;
  {
    unsigned long __dummy;
    unsigned long volatile __dummy2;
    
#line 540 
    tmp_1 = 1;
  }
  
#line 540 
  if (tmp_1 != 0) {
    int tmp_2;
    {
      unsigned long __dummy_0;
      unsigned long __dummy2_0;
      
#line 540 
      tmp_2 = 1;
    }
    
#line 540 
    if (tmp_2 != 0) {
      
#line 540 
      if ((long)(jiffies - timeout) >= 0L) {
        
#line 541 
        if ((efx->msg_enable & 8192U) != 0U) 
#line 541 
                                             netdev_err((struct net_device const *)efx->net_dev,"timed out waiting for SPI\n"); else ;
        
#line 543 
        __retres = -110;
        
#line 543 
        goto return_label;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 545 
  schedule_timeout_uninterruptible(1L);
  
#line 538 
  goto ldv_57025;
  return_label: 
#line 538 
                return __retres;
}


#line 550  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_spi_cmd(struct efx_nic *efx, struct falcon_spi_device const *spi, unsigned int command, int address, void const *in, void *out, size_t len)
{
  int __retres;
  efx_oword_t reg;
  int rc;
  unsigned int tmp;
  
#line 554 
  bool addressed = (_Bool)(address >= 0);
  
#line 555 
  bool reading = (_Bool)(out != (void *)0);
  
#line 560 
  if (len > 16UL) {
    
#line 561 
    __retres = -22;
    
#line 561 
    goto return_label;
  }
  else ;
  
#line 564 
  rc = falcon_spi_poll(efx);
  
#line 565 
  if (rc != 0) {
    
#line 566 
    __retres = rc;
    
#line 566 
    goto return_label;
  }
  else ;
  
#line 569 
  if ((int)addressed != 0) {
    
#line 570 
    reg.u64[0] = (unsigned long long)address;
    
#line 570 
    reg.u64[1] = 0ULL;
    
#line 571 
    efx_writeo_2(efx,(efx_oword_t const *)(& reg),272U);
  }
  else ;
  
#line 575 
  if (in != (void const *)0) {
    
#line 576 
    memcpy((void *)(& reg),in,len);
    
#line 577 
    efx_writeo_2(efx,(efx_oword_t const *)(& reg),288U);
  }
  else ;
  
#line 581 
  if ((int)addressed != 0) 
#line 581 
                           tmp = spi->addr_len; else 
#line 581 
                                                     tmp = 0U;
  
#line 581 
  reg.u64[0] = ((((((unsigned long long)spi->device_id << 24) | ((unsigned long long)len << 16)) | ((unsigned long long)reading << 15)) | ((unsigned long long)tmp << 8)) | (unsigned long long)command) | 2147483648ULL;
  
#line 581 
  reg.u64[1] = 0ULL;
  
#line 590 
  efx_writeo_2(efx,(efx_oword_t const *)(& reg),256U);
  
#line 593 
  rc = falcon_spi_wait(efx);
  
#line 594 
  if (rc != 0) {
    
#line 595 
    __retres = rc;
    
#line 595 
    goto return_label;
  }
  else ;
  
#line 598 
  if (out != (void *)0) {
    
#line 599 
    efx_reado_2(efx,& reg,288U);
    
#line 600 
    memcpy(out,(void const *)(& reg),len);
  }
  else ;
  
#line 603 
  __retres = 0;
  return_label: 
#line 603 
                return __retres;
}


#line 607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
__inline static u8 falcon_spi_munge_command(struct falcon_spi_device const *spi, u8 const command, unsigned int const address)
{
  u8 __retres;
  
#line 610 
  __retres = (unsigned char)((((int)((unsigned char)(address >> 8)) & (int)((unsigned char)spi->munge_address)) << 3U) | (int)command);
  
#line 610 
  return __retres;
}


#line 614  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_spi_read(struct efx_nic *efx, struct falcon_spi_device const *spi, loff_t start, size_t len, size_t *retlen, u8 *buffer)
{
  size_t block_len;
  unsigned int command;
  unsigned long tmp_0;
  u8 tmp_1;
  int tmp_3;
  struct task_struct *tmp_2;
  
#line 617 
  size_t pos = 0UL;
  
#line 619 
  int rc = 0;
  
#line 621 
  goto ldv_57062;
  ldv_57061: 
#line 622 
  ;
  {
    unsigned long tmp;
    
#line 622 
    size_t _min1 = len - pos;
    
#line 622 
    unsigned long _min2 = 16UL;
    
#line 622 
    if (_min1 < _min2) 
#line 622 
                       tmp = _min1; else 
#line 622 
                                         tmp = _min2;
    
#line 622 
    tmp_0 = tmp;
  }
  
#line 622 
  block_len = tmp_0;
  
#line 624 
  tmp_1 = falcon_spi_munge_command(spi,(unsigned char)3,(unsigned int)start + (unsigned int)pos);
  
#line 624 
  command = (unsigned int)tmp_1;
  
#line 625 
  rc = falcon_spi_cmd(efx,spi,command,(int)((unsigned long long)start + (unsigned long long)pos),(void const *)0,(void *)(buffer + pos),block_len);
  
#line 627 
  if (rc != 0) 
#line 628 
               goto ldv_57059; else ;
  
#line 629 
  pos += block_len;
  
#line 632 
  ___might_sleep("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c",632,0);
  
#line 632 
  _cond_resched();
  
#line 633 
  tmp_2 = get_current();
  
#line 633 
  tmp_3 = signal_pending(tmp_2);
  
#line 633 
  if (tmp_3 != 0) {
    
#line 634 
    rc = -4;
    
#line 635 
    goto ldv_57059;
  }
  else ;
  ldv_57062: 
#line 637 
  ;
  
#line 621 
  if (pos < len) 
#line 623 
                 goto ldv_57061; else 
#line 626 
                                      goto ldv_57059;
  ldv_57059: 
#line 627 
  ;
  
#line 639 
  if (retlen != (size_t *)0UL) 
#line 640 
                               *retlen = pos; else ;
  
#line 641 
  return rc;
}


#line 656  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static size_t falcon_spi_write_limit(struct falcon_spi_device const *spi, size_t start)
{
  unsigned long tmp_0;
  {
    unsigned long tmp;
    
#line 658 
    unsigned long _min1 = 16UL;
    
#line 658 
    size_t _min2 = (unsigned long)spi->block_size - ((unsigned long)(spi->block_size + 4294967295U) & start);
    
#line 658 
    if (_min1 < _min2) 
#line 658 
                       tmp = _min1; else 
#line 658 
                                         tmp = _min2;
    
#line 658 
    tmp_0 = tmp;
  }
  
#line 658 
  return tmp_0;
}


#line 664  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_spi_wait_write(struct efx_nic *efx, struct falcon_spi_device const *spi)
{
  int __retres;
  u8 status;
  int rc;
  int tmp;
  
#line 666 
  unsigned long timeout = jiffies + 4UL;
  ldv_57087: 
#line 669 
  ;
  
#line 671 
  rc = falcon_spi_cmd(efx,spi,5U,-1,(void const *)0,(void *)(& status),1UL);
  
#line 673 
  if (rc != 0) {
    
#line 674 
    __retres = rc;
    
#line 674 
    goto return_label;
  }
  else ;
  
#line 675 
  if (((int)status & 1) == 0) {
    
#line 676 
    __retres = 0;
    
#line 676 
    goto return_label;
  }
  else ;
  {
    unsigned long __dummy;
    unsigned long volatile __dummy2;
    
#line 677 
    tmp = 1;
  }
  
#line 677 
  if (tmp != 0) {
    int tmp_0;
    {
      unsigned long __dummy_0;
      unsigned long __dummy2_0;
      
#line 677 
      tmp_0 = 1;
    }
    
#line 677 
    if (tmp_0 != 0) {
      
#line 677 
      if ((long)(jiffies - timeout) >= 0L) {
        
#line 678 
        if ((efx->msg_enable & 8192U) != 0U) 
#line 678 
                                             netdev_err((struct net_device const *)efx->net_dev,"SPI write timeout on device %d",spi->device_id,(int)status); else ;
        
#line 682 
        __retres = -110;
        
#line 682 
        goto return_label;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 684 
  schedule_timeout_uninterruptible(1L);
  
#line 671 
  goto ldv_57087;
  return_label: 
#line 671 
                return __retres;
}


#line 689  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_spi_write(struct efx_nic *efx, struct falcon_spi_device const *spi, loff_t start, size_t len, size_t *retlen, u8 const *buffer)
{
  u8 verify_buffer[16U];
  size_t block_len;
  unsigned int command;
  size_t tmp_1;
  u8 tmp_2;
  u8 tmp_3;
  int tmp_4;
  int tmp_6;
  struct task_struct *tmp_5;
  
#line 693 
  size_t pos = 0UL;
  
#line 695 
  int rc = 0;
  
#line 697 
  goto ldv_57107;
  ldv_57106: 
#line 698 
  ;
  
#line 698 
  rc = falcon_spi_cmd(efx,spi,6U,-1,(void const *)0,(void *)0,0UL);
  
#line 699 
  if (rc != 0) 
#line 700 
               goto ldv_57101; else ;
  {
    size_t tmp_0;
    
#line 702 
    size_t _min1 = len - pos;
    
#line 702 
    size_t _min2 = falcon_spi_write_limit(spi,(unsigned long)((unsigned long long)start + (unsigned long long)pos));
    
#line 702 
    if (_min1 < _min2) 
#line 702 
                       tmp_0 = _min1; else 
#line 702 
                                           tmp_0 = _min2;
    
#line 702 
    tmp_1 = tmp_0;
  }
  
#line 702 
  block_len = tmp_1;
  
#line 704 
  tmp_2 = falcon_spi_munge_command(spi,(unsigned char)2,(unsigned int)start + (unsigned int)pos);
  
#line 704 
  command = (unsigned int)tmp_2;
  
#line 705 
  rc = falcon_spi_cmd(efx,spi,command,(int)((unsigned long long)start + (unsigned long long)pos),(void const *)(buffer + pos),(void *)0,block_len);
  
#line 707 
  if (rc != 0) 
#line 708 
               goto ldv_57101; else ;
  
#line 710 
  rc = falcon_spi_wait_write(efx,spi);
  
#line 711 
  if (rc != 0) 
#line 712 
               goto ldv_57101; else ;
  
#line 714 
  tmp_3 = falcon_spi_munge_command(spi,(unsigned char)3,(unsigned int)start + (unsigned int)pos);
  
#line 714 
  command = (unsigned int)tmp_3;
  
#line 715 
  rc = falcon_spi_cmd(efx,spi,command,(int)((unsigned long long)start + (unsigned long long)pos),(void const *)0,(void *)(& verify_buffer),block_len);
  
#line 717 
  tmp_4 = memcmp((void const *)(& verify_buffer),(void const *)(buffer + pos),block_len);
  
#line 717 
  if (tmp_4 != 0) {
    
#line 718 
    rc = -5;
    
#line 719 
    goto ldv_57101;
  }
  else ;
  
#line 722 
  pos += block_len;
  
#line 725 
  ___might_sleep("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c",725,0);
  
#line 725 
  _cond_resched();
  
#line 726 
  tmp_5 = get_current();
  
#line 726 
  tmp_6 = signal_pending(tmp_5);
  
#line 726 
  if (tmp_6 != 0) {
    
#line 727 
    rc = -4;
    
#line 728 
    goto ldv_57101;
  }
  else ;
  ldv_57107: 
#line 730 
  ;
  
#line 697 
  if (pos < len) 
#line 699 
                 goto ldv_57106; else 
#line 702 
                                      goto ldv_57101;
  ldv_57101: 
#line 703 
  ;
  
#line 732 
  if (retlen != (size_t *)0UL) 
#line 733 
                               *retlen = pos; else ;
  
#line 734 
  return rc;
}


#line 738  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_spi_slow_wait(struct falcon_mtd_partition *part, bool uninterruptible)
{
  int __retres;
  u8 status;
  int rc;
  int i;
  struct task_struct *tmp;
  struct task_struct *tmp_0;
  int tmp_1;
  int tmp_3;
  struct task_struct *tmp_2;
  
#line 740 
  struct falcon_spi_device const *spi = part->spi;
  
#line 741 
  struct efx_nic *efx = (struct efx_nic *)part->common.mtd.priv;
  
#line 746 
  i = 0;
  
#line 746 
  goto ldv_57120;
  ldv_57119: 
#line 747 
  ;
  
#line 747 
  tmp = get_current();
  __here_0: 
#line 747 
  ;
  
#line 747 
  tmp->task_state_change = (unsigned long)((void *)0);
  
#line 747 
  tmp_0 = get_current();
  
#line 747 
  if ((int)uninterruptible != 0) 
#line 747 
                                 tmp_1 = 2; else 
#line 747 
                                                 tmp_1 = 1;
  
#line 747 
  tmp_0->state = (long)tmp_1;
  
#line 749 
  schedule_timeout(25L);
  
#line 750 
  rc = falcon_spi_cmd(efx,spi,5U,-1,(void const *)0,(void *)(& status),1UL);
  
#line 752 
  if (rc != 0) {
    
#line 753 
    __retres = rc;
    
#line 753 
    goto return_label;
  }
  else ;
  
#line 754 
  if (((int)status & 1) == 0) {
    
#line 755 
    __retres = 0;
    
#line 755 
    goto return_label;
  }
  else ;
  
#line 756 
  tmp_2 = get_current();
  
#line 756 
  tmp_3 = signal_pending(tmp_2);
  
#line 756 
  if (tmp_3 != 0) {
    
#line 757 
    __retres = -4;
    
#line 757 
    goto return_label;
  }
  else ;
  
#line 746 
  i += 1;
  ldv_57120: 
#line 747 
  ;
  
#line 746 
  if (i <= 39) 
#line 748 
               goto ldv_57119; else 
#line 751 
                                    goto ldv_57121;
  ldv_57121: 
#line 752 
  ;
  
#line 759 
  printk("\001",(char *)(& part->common.name),part->common.dev_type_name);
  
#line 761 
  __retres = -110;
  return_label: 
#line 761 
                return __retres;
}


#line 765  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_spi_unlock(struct efx_nic *efx, struct falcon_spi_device const *spi)
{
  int __retres;
  u8 status;
  int rc;
  
#line 767 
  u8 const unlock_mask = (unsigned char)28U;
  
#line 772 
  rc = falcon_spi_cmd(efx,spi,5U,-1,(void const *)0,(void *)(& status),1UL);
  
#line 774 
  if (rc != 0) {
    
#line 775 
    __retres = rc;
    
#line 775 
    goto return_label;
  }
  else ;
  
#line 777 
  if (((unsigned int)status & 28U) == 0U) {
    
#line 778 
    __retres = 0;
    
#line 778 
    goto return_label;
  }
  else ;
  
#line 780 
  rc = falcon_spi_cmd(efx,spi,6U,-1,(void const *)0,(void *)0,0UL);
  
#line 781 
  if (rc != 0) {
    
#line 782 
    __retres = rc;
    
#line 782 
    goto return_label;
  }
  else ;
  
#line 783 
  rc = falcon_spi_cmd(efx,spi,80U,-1,(void const *)0,(void *)0,0UL);
  
#line 784 
  if (rc != 0) {
    
#line 785 
    __retres = rc;
    
#line 785 
    goto return_label;
  }
  else ;
  
#line 787 
  status = (unsigned char)((unsigned int)status & 227U);
  
#line 788 
  rc = falcon_spi_cmd(efx,spi,1U,-1,(void const *)(& status),(void *)0,1UL);
  
#line 790 
  if (rc != 0) {
    
#line 791 
    __retres = rc;
    
#line 791 
    goto return_label;
  }
  else ;
  
#line 792 
  rc = falcon_spi_wait_write(efx,spi);
  
#line 793 
  if (rc != 0) {
    
#line 794 
    __retres = rc;
    
#line 794 
    goto return_label;
  }
  else ;
  
#line 796 
  __retres = 0;
  return_label: 
#line 796 
                return __retres;
}


#line 802  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_spi_erase(struct falcon_mtd_partition *part, loff_t start, size_t len)
{
  int __retres;
  unsigned int pos;
  unsigned int block_len;
  u8 empty[16U];
  u8 buffer[16U];
  int rc;
  unsigned long tmp_0;
  int tmp_1;
  int tmp_3;
  struct task_struct *tmp_2;
  
#line 804 
  struct falcon_spi_device const *spi = part->spi;
  
#line 805 
  struct efx_nic *efx = (struct efx_nic *)part->common.mtd.priv;
  
#line 811 
  if ((unsigned long)spi->erase_size != len) {
    
#line 812 
    __retres = -22;
    
#line 812 
    goto return_label;
  }
  else ;
  
#line 814 
  if ((unsigned int)spi->erase_command == 0U) {
    
#line 815 
    __retres = -95;
    
#line 815 
    goto return_label;
  }
  else ;
  
#line 817 
  rc = falcon_spi_unlock(efx,spi);
  
#line 818 
  if (rc != 0) {
    
#line 819 
    __retres = rc;
    
#line 819 
    goto return_label;
  }
  else ;
  
#line 820 
  rc = falcon_spi_cmd(efx,spi,6U,-1,(void const *)0,(void *)0,0UL);
  
#line 821 
  if (rc != 0) {
    
#line 822 
    __retres = rc;
    
#line 822 
    goto return_label;
  }
  else ;
  
#line 823 
  rc = falcon_spi_cmd(efx,spi,(unsigned int)spi->erase_command,(int)start,(void const *)0,(void *)0,0UL);
  
#line 825 
  if (rc != 0) {
    
#line 826 
    __retres = rc;
    
#line 826 
    goto return_label;
  }
  else ;
  
#line 827 
  rc = falcon_spi_slow_wait(part,(_Bool)0);
  
#line 830 
  memset((void *)(& empty),255,16UL);
  
#line 831 
  pos = 0U;
  
#line 831 
  goto ldv_57146;
  ldv_57145: 
#line 832 
  ;
  {
    unsigned long tmp;
    
#line 832 
    size_t _min1 = len - (unsigned long)pos;
    
#line 832 
    unsigned long _min2 = 16UL;
    
#line 832 
    if (_min1 < _min2) 
#line 832 
                       tmp = _min1; else 
#line 832 
                                         tmp = _min2;
    
#line 832 
    tmp_0 = tmp;
  }
  
#line 832 
  block_len = (unsigned int)tmp_0;
  
#line 833 
  rc = falcon_spi_read(efx,spi,(long long)pos + start,(unsigned long)block_len,(size_t *)0UL,(u8 *)(& buffer));
  
#line 835 
  if (rc != 0) {
    
#line 836 
    __retres = rc;
    
#line 836 
    goto return_label;
  }
  else ;
  
#line 837 
  tmp_1 = memcmp((void const *)(& empty),(void const *)(& buffer),(unsigned long)block_len);
  
#line 837 
  if (tmp_1 != 0) {
    
#line 838 
    __retres = -5;
    
#line 838 
    goto return_label;
  }
  else ;
  
#line 841 
  ___might_sleep("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c",841,0);
  
#line 841 
  _cond_resched();
  
#line 842 
  tmp_2 = get_current();
  
#line 842 
  tmp_3 = signal_pending(tmp_2);
  
#line 842 
  if (tmp_3 != 0) {
    
#line 843 
    __retres = -4;
    
#line 843 
    goto return_label;
  }
  else ;
  
#line 831 
  pos += block_len;
  ldv_57146: 
#line 832 
  ;
  
#line 831 
  if ((unsigned long)pos < len) 
#line 833 
                                goto ldv_57145; else 
#line 836 
                                                     goto ldv_57147;
  ldv_57147: 
#line 837 
  ;
  
#line 846 
  __retres = rc;
  return_label: 
#line 846 
                return __retres;
}


#line 849  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static void falcon_mtd_rename(struct efx_mtd_partition *part)
{
  
#line 851 
  struct efx_nic *efx = (struct efx_nic *)part->mtd.priv;
  
#line 853 
  snprintf((char *)(& part->name),36UL,"%s %s",(char *)(& efx->name),part->type_name);
  
#line 855 
  return;
}


#line 857  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_mtd_read(struct mtd_info *mtd, loff_t start, size_t len, size_t *retlen, u8 *buffer)
{
  int __retres;
  struct falcon_mtd_partition *tmp;
  int rc;
  {
    
#line 860 
    struct mtd_info const *__mptr = (struct mtd_info const *)mtd;
    
#line 860 
    tmp = (struct falcon_mtd_partition *)__mptr + 18446744073709551600U;
  }
  
#line 860 
  struct falcon_mtd_partition *part = tmp;
  
#line 861 
  struct efx_nic *efx = (struct efx_nic *)mtd->priv;
  
#line 862 
  struct falcon_nic_data *nic_data = (struct falcon_nic_data *)efx->nic_data;
  
#line 865 
  rc = ldv_mutex_lock_interruptible_97(& nic_data->spi_lock);
  
#line 866 
  if (rc != 0) {
    
#line 867 
    __retres = rc;
    
#line 867 
    goto return_label;
  }
  else ;
  
#line 868 
  rc = falcon_spi_read(efx,part->spi,(long long)((unsigned long long)part->offset + (unsigned long long)start),len,retlen,buffer);
  
#line 870 
  ldv_mutex_unlock_98_1(& nic_data->spi_lock);
  
#line 871 
  __retres = rc;
  return_label: 
#line 871 
                return __retres;
}


#line 874  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_mtd_erase(struct mtd_info *mtd, loff_t start, size_t len)
{
  int __retres;
  struct falcon_mtd_partition *tmp;
  int rc;
  {
    
#line 876 
    struct mtd_info const *__mptr = (struct mtd_info const *)mtd;
    
#line 876 
    tmp = (struct falcon_mtd_partition *)__mptr + 18446744073709551600U;
  }
  
#line 876 
  struct falcon_mtd_partition *part = tmp;
  
#line 877 
  struct efx_nic *efx = (struct efx_nic *)mtd->priv;
  
#line 878 
  struct falcon_nic_data *nic_data = (struct falcon_nic_data *)efx->nic_data;
  
#line 881 
  rc = ldv_mutex_lock_interruptible_99(& nic_data->spi_lock);
  
#line 882 
  if (rc != 0) {
    
#line 883 
    __retres = rc;
    
#line 883 
    goto return_label;
  }
  else ;
  
#line 884 
  rc = falcon_spi_erase(part,(long long)((unsigned long long)part->offset + (unsigned long long)start),len);
  
#line 885 
  ldv_mutex_unlock_100_0(& nic_data->spi_lock);
  
#line 886 
  __retres = rc;
  return_label: 
#line 886 
                return __retres;
}


#line 889  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_mtd_write(struct mtd_info *mtd, loff_t start, size_t len, size_t *retlen, u8 const *buffer)
{
  int __retres;
  struct falcon_mtd_partition *tmp;
  int rc;
  {
    
#line 892 
    struct mtd_info const *__mptr = (struct mtd_info const *)mtd;
    
#line 892 
    tmp = (struct falcon_mtd_partition *)__mptr + 18446744073709551600U;
  }
  
#line 892 
  struct falcon_mtd_partition *part = tmp;
  
#line 893 
  struct efx_nic *efx = (struct efx_nic *)mtd->priv;
  
#line 894 
  struct falcon_nic_data *nic_data = (struct falcon_nic_data *)efx->nic_data;
  
#line 897 
  rc = ldv_mutex_lock_interruptible_101(& nic_data->spi_lock);
  
#line 898 
  if (rc != 0) {
    
#line 899 
    __retres = rc;
    
#line 899 
    goto return_label;
  }
  else ;
  
#line 900 
  rc = falcon_spi_write(efx,part->spi,(long long)((unsigned long long)part->offset + (unsigned long long)start),len,retlen,buffer);
  
#line 902 
  ldv_mutex_unlock_102(& nic_data->spi_lock);
  
#line 903 
  __retres = rc;
  return_label: 
#line 903 
                return __retres;
}


#line 906  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_mtd_sync(struct mtd_info *mtd)
{
  struct falcon_mtd_partition *tmp;
  int rc;
  {
    
#line 908 
    struct mtd_info const *__mptr = (struct mtd_info const *)mtd;
    
#line 908 
    tmp = (struct falcon_mtd_partition *)__mptr + 18446744073709551600U;
  }
  
#line 908 
  struct falcon_mtd_partition *part = tmp;
  
#line 909 
  struct efx_nic *efx = (struct efx_nic *)mtd->priv;
  
#line 910 
  struct falcon_nic_data *nic_data = (struct falcon_nic_data *)efx->nic_data;
  
#line 913 
  ldv_mutex_lock_103_0(& nic_data->spi_lock);
  
#line 914 
  rc = falcon_spi_slow_wait(part,(_Bool)1);
  
#line 915 
  ldv_mutex_unlock_104(& nic_data->spi_lock);
  
#line 916 
  return rc;
}


#line 919  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_mtd_probe(struct efx_nic *efx)
{
  int __retres;
  struct falcon_mtd_partition *parts;
  struct falcon_spi_device *spi;
  size_t n_parts;
  int tmp;
  bool tmp_1;
  bool tmp_4;
  
#line 921 
  struct falcon_nic_data *nic_data = (struct falcon_nic_data *)efx->nic_data;
  
#line 925 
  int rc = -19;
  
#line 927 
  tmp = rtnl_is_locked();
  
#line 927 
  if ((long)(tmp == 0) != 0L) {
    
#line 927 
    printk("\001",(char *)"/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c",927);
    
#line 927 
    dump_stack();
  }
  else ;
  
#line 930 
  parts = (struct falcon_mtd_partition *)kcalloc_8(2UL,1912UL,208U);
  
#line 931 
  if (parts == (struct falcon_mtd_partition *)0) {
    
#line 932 
    __retres = -12;
    
#line 932 
    goto return_label;
  }
  else ;
  
#line 933 
  n_parts = 0UL;
  
#line 935 
  spi = & nic_data->spi_flash;
  
#line 936 
  tmp_1 = falcon_spi_present((struct falcon_spi_device const *)spi);
  
#line 936 
  if ((int)tmp_1 != 0) {
    
#line 936 
    if (spi->size > 32768U) {
      
#line 937 
      (parts + n_parts)->spi = (struct falcon_spi_device const *)spi;
      
#line 938 
      (parts + n_parts)->offset = 32768UL;
      
#line 939 
      (parts + n_parts)->common.dev_type_name = "flash";
      
#line 940 
      (parts + n_parts)->common.type_name = "sfc_flash_bootrom";
      
#line 941 
      (parts + n_parts)->common.mtd.type = (unsigned char)3U;
      
#line 942 
      (parts + n_parts)->common.mtd.flags = 3072U;
      
#line 943 
      (parts + n_parts)->common.mtd.size = (unsigned long long)(spi->size + 4294934528U);
      
#line 944 
      (parts + n_parts)->common.mtd.erasesize = spi->erase_size;
      
#line 945 
      n_parts += 1UL;
    }
    else ;
  }
  else ;
  
#line 948 
  spi = & nic_data->spi_eeprom;
  
#line 949 
  tmp_4 = falcon_spi_present((struct falcon_spi_device const *)spi);
  
#line 949 
  if ((int)tmp_4 != 0) {
    
#line 949 
    if (spi->size > 2048U) {
      unsigned int tmp_3;
      
#line 950 
      (parts + n_parts)->spi = (struct falcon_spi_device const *)spi;
      
#line 951 
      (parts + n_parts)->offset = 2048UL;
      
#line 952 
      (parts + n_parts)->common.dev_type_name = "EEPROM";
      
#line 953 
      (parts + n_parts)->common.type_name = "sfc_bootconfig";
      
#line 954 
      (parts + n_parts)->common.mtd.type = (unsigned char)1U;
      
#line 955 
      (parts + n_parts)->common.mtd.flags = 7168U;
      {
        unsigned int tmp_2;
        
#line 957 
        unsigned int _min1 = spi->size;
        
#line 957 
        unsigned int _min2 = 6144U;
        
#line 957 
        if (_min1 < _min2) 
#line 957 
                           tmp_2 = _min1; else 
#line 957 
                                               tmp_2 = _min2;
        
#line 957 
        tmp_3 = tmp_2;
      }
      
#line 956 
      (parts + n_parts)->common.mtd.size = (unsigned long long)(tmp_3 + 4294965248U);
      
#line 959 
      (parts + n_parts)->common.mtd.erasesize = spi->erase_size;
      
#line 960 
      n_parts += 1UL;
    }
    else ;
  }
  else ;
  
#line 963 
  rc = efx_mtd_add(efx,& parts->common,n_parts,1912UL);
  
#line 964 
  if (rc != 0) 
#line 965 
               kfree((void const *)parts); else ;
  
#line 966 
  __retres = rc;
  return_label: 
#line 966 
                return __retres;
}


#line 979  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static void falcon_setup_xaui(struct efx_nic *efx)
{
  efx_oword_t sdctl;
  efx_oword_t txdrv;
  
#line 985 
  if (efx->phy_type == 0U) 
#line 986 
                           goto return_label; else ;
  
#line 988 
  efx_reado_2(efx,& sdctl,4880U);
  
#line 989 
  sdctl.u64[0] &= 18446744073709518847ULL;
  
#line 989 
  sdctl.u64[1] = sdctl.u64[1];
  
#line 990 
  sdctl.u64[0] &= 18446744073709535231ULL;
  
#line 990 
  sdctl.u64[1] = sdctl.u64[1];
  
#line 991 
  sdctl.u64[0] &= 18446744073709543423ULL;
  
#line 991 
  sdctl.u64[1] = sdctl.u64[1];
  
#line 992 
  sdctl.u64[0] &= 18446744073709547519ULL;
  
#line 992 
  sdctl.u64[1] = sdctl.u64[1];
  
#line 993 
  sdctl.u64[0] &= 18446744073709549567ULL;
  
#line 993 
  sdctl.u64[1] = sdctl.u64[1];
  
#line 994 
  sdctl.u64[0] &= 18446744073709550591ULL;
  
#line 994 
  sdctl.u64[1] = sdctl.u64[1];
  
#line 995 
  sdctl.u64[0] &= 18446744073709551103ULL;
  
#line 995 
  sdctl.u64[1] = sdctl.u64[1];
  
#line 996 
  sdctl.u64[0] &= 18446744073709551359ULL;
  
#line 996 
  sdctl.u64[1] = sdctl.u64[1];
  
#line 997 
  efx_writeo_2(efx,(efx_oword_t const *)(& sdctl),4880U);
  
#line 999 
  txdrv.u64[0] = 4008596821ULL;
  
#line 999 
  txdrv.u64[1] = 0ULL;
  
#line 1008 
  efx_writeo_2(efx,(efx_oword_t const *)(& txdrv),4896U);
  return_label: 
#line 1009 
                return;
}


#line 1011  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
int falcon_reset_xaui(struct efx_nic *efx)
{
  int __retres;
  efx_oword_t reg;
  int count;
  
#line 1013 
  struct falcon_nic_data *nic_data = (struct falcon_nic_data *)efx->nic_data;
  {
    
#line 1018 
    int __ret_warn_on = nic_data->stats_disable_count == 0U;
    
#line 1018 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 1018 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c",1018); else ;
    
#line 1018 
    long tmp = (long)(__ret_warn_on != 0);
  }
  
#line 1021 
  reg.u64[0] = 1ULL;
  
#line 1021 
  reg.u64[1] = 0ULL;
  
#line 1022 
  efx_writeo_2(efx,(efx_oword_t const *)(& reg),4864U);
  
#line 1025 
  count = 0;
  
#line 1025 
  goto ldv_57223;
  ldv_57222: 
#line 1026 
  ;
  
#line 1026 
  efx_reado_2(efx,& reg,4864U);
  
#line 1027 
  if ((reg.u64[0] & 1ULL) == 0ULL && (reg.u64[0] & 65536ULL) == 0ULL) {
    
#line 1029 
    falcon_setup_xaui(efx);
    
#line 1030 
    __retres = 0;
    
#line 1030 
    goto return_label;
  }
  else ;
  
#line 1032 
  __const_udelay(42950UL);
  
#line 1025 
  count += 1;
  ldv_57223: 
#line 1026 
  ;
  
#line 1025 
  if (count <= 999) 
#line 1027 
                    goto ldv_57222; else 
#line 1030 
                                         goto ldv_57224;
  ldv_57224: 
#line 1031 
  ;
  
#line 1034 
  if ((efx->msg_enable & 8192U) != 0U) 
#line 1034 
                                       netdev_err((struct net_device const *)efx->net_dev,"timed out waiting for XAUI/XGXS reset\n"); else ;
  
#line 1036 
  __retres = -110;
  return_label: 
#line 1036 
                return __retres;
}


#line 1039  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static void falcon_ack_status_intr(struct efx_nic *efx)
{
  efx_oword_t reg;
  int tmp;
  
#line 1041 
  struct falcon_nic_data *nic_data = (struct falcon_nic_data *)efx->nic_data;
  
#line 1044 
  tmp = efx_nic_rev(efx);
  
#line 1044 
  if (tmp != 2) 
#line 1045 
                goto return_label;
  else 
    
#line 1044 
    if (((66600958 >> (unsigned int)efx->loopback_mode) & 1) != 0) 
#line 1045 
                                                                   goto return_label; else ;
  
#line 1048 
  if (! efx->link_state.up) 
#line 1049 
                            goto return_label; else ;
  
#line 1053 
  if ((int)nic_data->xmac_poll_required != 0) 
#line 1054 
                                              goto return_label; else ;
  
#line 1056 
  efx_reado_2(efx,& reg,4848U);
  return_label: 
#line 1057 
                return;
}


#line 1059  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static bool falcon_xgxs_link_ok(struct efx_nic *efx)
{
  efx_oword_t reg;
  bool align_done;
  int sync_status;
  
#line 1062 
  bool link_ok = (_Bool)0;
  
#line 1066 
  efx_reado_2(efx,& reg,4960U);
  
#line 1068 
  align_done = (_Bool)(((reg.u64[0] >> 20) & 1ULL) != 0ULL);
  
#line 1069 
  sync_status = (int)(reg.u64[0] >> 16) & 15;
  
#line 1070 
  if ((int)align_done != 0 && sync_status == 15) 
#line 1071 
                                                 link_ok = (_Bool)1; else ;
  
#line 1074 
  reg.u64[0] |= 61440ULL;
  
#line 1074 
  reg.u64[1] = reg.u64[1];
  
#line 1075 
  reg.u64[0] |= 240ULL;
  
#line 1075 
  reg.u64[1] = reg.u64[1];
  
#line 1076 
  reg.u64[0] |= 15ULL;
  
#line 1076 
  reg.u64[1] = reg.u64[1];
  
#line 1077 
  efx_writeo_2(efx,(efx_oword_t const *)(& reg),4960U);
  
#line 1079 
  return link_ok;
}


#line 1082  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static bool falcon_xmac_link_ok(struct efx_nic *efx)
{
  bool __retres;
  int tmp_1;
  
#line 1091 
  if (efx->loopback_mode == (unsigned int)LOOPBACK_XGMII) 
#line 1091 
                                                          goto _LOR;
  else {
    bool tmp;
    
#line 1090 
    tmp = falcon_xgxs_link_ok(efx);
    
#line 1090 
    if ((int)tmp != 0) 
      _LOR: 
#line 1091 
            if ((efx->mdio.mmds & 16U) == 0U || ((66600958 >> (unsigned int)efx->loopback_mode) & 1) != 0) 
              
#line 1091 
              tmp_1 = 1;
            else {
              bool tmp_0;
              
#line 1093 
              tmp_0 = efx_mdio_phyxgxs_lane_sync(efx);
              
#line 1093 
              if ((int)tmp_0 != 0) 
#line 1091 
                                   tmp_1 = 1; else 
#line 1091 
                                                   tmp_1 = 0;
            }
    else 
#line 1091 
         tmp_1 = 0;
  }
  
#line 1091 
  __retres = (_Bool)(tmp_1 != 0);
  
#line 1091 
  return __retres;
}


#line 1097  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static void falcon_reconfigure_xmac_core(struct efx_nic *efx)
{
  unsigned int max_frame_len;
  efx_oword_t reg;
  
#line 1101 
  bool rx_fc = (_Bool)(((int)efx->link_state.fc & 2) != 0);
  
#line 1102 
  bool tx_fc = (_Bool)(((int)efx->link_state.fc & 1) != 0);
  
#line 1105 
  reg.u64[0] = 3136ULL;
  
#line 1105 
  reg.u64[1] = 0ULL;
  
#line 1109 
  efx_writeo_2(efx,(efx_oword_t const *)(& reg),4640U);
  
#line 1112 
  reg.u64[0] = ((unsigned long long)tx_fc << 10) | 196902ULL;
  
#line 1112 
  reg.u64[1] = 0ULL;
  
#line 1119 
  efx_writeo_2(efx,(efx_oword_t const *)(& reg),4656U);
  
#line 1122 
  reg.u64[0] = ((unsigned long long)(! efx->unicast_filter) << 9) | 33556482ULL;
  
#line 1122 
  reg.u64[1] = 0ULL;
  
#line 1128 
  efx_writeo_2(efx,(efx_oword_t const *)(& reg),4672U);
  
#line 1131 
  max_frame_len = (((efx->net_dev)->mtu + 29U) & 4294967288U) + 16U;
  
#line 1132 
  reg.u64[0] = (unsigned long long)max_frame_len;
  
#line 1132 
  reg.u64[1] = 0ULL;
  
#line 1133 
  efx_writeo_2(efx,(efx_oword_t const *)(& reg),4832U);
  
#line 1134 
  reg.u64[0] = ((unsigned long long)max_frame_len << 16) | 2147483648ULL;
  
#line 1134 
  reg.u64[1] = 0ULL;
  
#line 1137 
  efx_writeo_2(efx,(efx_oword_t const *)(& reg),4816U);
  
#line 1139 
  reg.u64[0] = (unsigned long long)(! rx_fc) | 4294836224ULL;
  
#line 1139 
  reg.u64[1] = 0ULL;
  
#line 1142 
  efx_writeo_2(efx,(efx_oword_t const *)(& reg),4720U);
  
#line 1145 
  memcpy((void *)(& reg),(void const *)(efx->net_dev)->dev_addr,4UL);
  
#line 1146 
  efx_writeo_2(efx,(efx_oword_t const *)(& reg),4608U);
  
#line 1147 
  memcpy((void *)(& reg),(void const *)((efx->net_dev)->dev_addr + 4U),2UL);
  
#line 1148 
  efx_writeo_2(efx,(efx_oword_t const *)(& reg),4624U);
  
#line 1149 
  return;
}


#line 1151  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static void falcon_reconfigure_xgxs_core(struct efx_nic *efx)
{
  efx_oword_t reg;
  bool old_xgmii_loopback;
  bool old_xgxs_loopback;
  bool old_xaui_loopback;
  int tmp;
  
#line 1154 
  bool xgxs_loopback = (_Bool)(efx->loopback_mode == (unsigned int)LOOPBACK_XGXS);
  
#line 1155 
  bool xaui_loopback = (_Bool)(efx->loopback_mode == (unsigned int)LOOPBACK_XAUI);
  
#line 1156 
  bool xgmii_loopback = (_Bool)(efx->loopback_mode == (unsigned int)LOOPBACK_XGMII);
  
#line 1161 
  efx_reado_2(efx,& reg,4960U);
  
#line 1162 
  old_xgxs_loopback = (_Bool)(((reg.u64[0] >> 23) & 1ULL) != 0ULL);
  
#line 1163 
  old_xgmii_loopback = (_Bool)(((reg.u64[0] >> 22) & 1ULL) != 0ULL);
  
#line 1165 
  efx_reado_2(efx,& reg,4880U);
  
#line 1166 
  old_xaui_loopback = (_Bool)((reg.u64[0] & 1ULL) != 0ULL);
  
#line 1169 
  if (((int)xgxs_loopback != (int)old_xgxs_loopback || (int)xaui_loopback != (int)old_xaui_loopback) || (int)xgmii_loopback != (int)old_xgmii_loopback) 
    
#line 1172 
    falcon_reset_xaui(efx); else ;
  
#line 1174 
  efx_reado_2(efx,& reg,4960U);
  
#line 1175 
  if ((int)xgxs_loopback != 0 || (int)xaui_loopback != 0) 
#line 1175 
                                                          tmp = 255; else 
                                                                    
#line 1175 
                                                                    tmp = 0;
  
#line 1175 
  reg.u64[0] = (reg.u64[0] & 18446744069431361535ULL) | ((unsigned long long)tmp << 24);
  
#line 1175 
  reg.u64[1] = reg.u64[1];
  
#line 1178 
  reg.u64[0] = (reg.u64[0] & 18446744073701163007ULL) | ((unsigned long long)xgxs_loopback << 23);
  
#line 1178 
  reg.u64[1] = reg.u64[1];
  
#line 1179 
  reg.u64[0] = (reg.u64[0] & 18446744073705357311ULL) | ((unsigned long long)xgmii_loopback << 22);
  
#line 1179 
  reg.u64[1] = reg.u64[1];
  
#line 1180 
  efx_writeo_2(efx,(efx_oword_t const *)(& reg),4960U);
  
#line 1182 
  efx_reado_2(efx,& reg,4880U);
  
#line 1183 
  reg.u64[0] = (reg.u64[0] & 18446744073709551607ULL) | ((unsigned long long)xaui_loopback << 3);
  
#line 1183 
  reg.u64[1] = reg.u64[1];
  
#line 1184 
  reg.u64[0] = (reg.u64[0] & 18446744073709551611ULL) | ((unsigned long long)xaui_loopback << 2);
  
#line 1184 
  reg.u64[1] = reg.u64[1];
  
#line 1185 
  reg.u64[0] = (reg.u64[0] & 18446744073709551613ULL) | ((unsigned long long)xaui_loopback << 1);
  
#line 1185 
  reg.u64[1] = reg.u64[1];
  
#line 1186 
  reg.u64[0] = (reg.u64[0] & 18446744073709551614ULL) | (unsigned long long)xaui_loopback;
  
#line 1186 
  reg.u64[1] = reg.u64[1];
  
#line 1187 
  efx_writeo_2(efx,(efx_oword_t const *)(& reg),4880U);
  
#line 1188 
  return;
}


#line 1192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static bool falcon_xmac_link_ok_retry(struct efx_nic *efx, int tries)
{
  bool __retres;
  
#line 1194 
  bool mac_up = falcon_xmac_link_ok(efx);
  
#line 1196 
  if ((((unsigned long long)(1 << (unsigned int)efx->loopback_mode) & efx->loopback_modes) & 67108864ULL) != 0ULL) {
    
#line 1199 
    __retres = mac_up;
    
#line 1199 
    goto return_label;
  }
  else {
    bool tmp_0;
    
#line 1196 
    tmp_0 = efx_phy_mode_disabled(efx->phy_mode);
    
#line 1196 
    if ((int)tmp_0 != 0) {
      
#line 1199 
      __retres = mac_up;
      
#line 1199 
      goto return_label;
    }
    else ;
  }
  
#line 1201 
  falcon_stop_nic_stats(efx);
  
#line 1203 
  goto ldv_57265;
  ldv_57264: 
#line 1204 
  ;
  
#line 1204 
  if ((efx->msg_enable & 8192U) != 0U) {
    
#line 1204 
    struct _ddebug descriptor = {.modname = "sfc", .function = "falcon_xmac_link_ok_retry", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c", .format = "bashing xaui\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1204U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1204 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1204 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"bashing xaui\n"); else ;
  }
  else ;
  
#line 1205 
  falcon_reset_xaui(efx);
  
#line 1206 
  __const_udelay(859000UL);
  
#line 1208 
  mac_up = falcon_xmac_link_ok(efx);
  
#line 1209 
  tries -= 1;
  ldv_57265: 
#line 1210 
  ;
  
#line 1203 
  if (! mac_up && tries != 0) 
#line 1205 
                              goto ldv_57264; else 
#line 1208 
                                                   goto ldv_57266;
  ldv_57266: 
#line 1209 
  ;
  
#line 1212 
  falcon_start_nic_stats(efx);
  
#line 1214 
  __retres = mac_up;
  return_label: 
#line 1214 
                return __retres;
}


#line 1217  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static bool falcon_xmac_check_fault(struct efx_nic *efx)
{
  bool __retres;
  int tmp_0;
  bool tmp;
  
#line 1219 
  tmp = falcon_xmac_link_ok_retry(efx,5);
  
#line 1219 
  if ((int)tmp != 0) 
#line 1219 
                     tmp_0 = 0; else 
#line 1219 
                                     tmp_0 = 1;
  
#line 1219 
  __retres = (_Bool)(tmp_0 != 0);
  
#line 1219 
  return __retres;
}


#line 1222  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_reconfigure_xmac(struct efx_nic *efx)
{
  int __retres;
  int tmp_0;
  bool tmp;
  
#line 1224 
  struct falcon_nic_data *nic_data = (struct falcon_nic_data *)efx->nic_data;
  
#line 1226 
  efx_farch_filter_sync_rx_mode(efx);
  
#line 1228 
  falcon_reconfigure_xgxs_core(efx);
  
#line 1229 
  falcon_reconfigure_xmac_core(efx);
  
#line 1231 
  falcon_reconfigure_mac_wrapper(efx);
  
#line 1233 
  tmp = falcon_xmac_link_ok_retry(efx,5);
  
#line 1233 
  if ((int)tmp != 0) 
#line 1233 
                     tmp_0 = 0; else 
#line 1233 
                                     tmp_0 = 1;
  
#line 1233 
  nic_data->xmac_poll_required = (_Bool)(tmp_0 != 0);
  
#line 1234 
  falcon_ack_status_intr(efx);
  
#line 1236 
  __retres = 0;
  
#line 1236 
  return __retres;
}


#line 1239  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static void falcon_poll_xmac(struct efx_nic *efx)
{
  int tmp_0;
  bool tmp;
  
#line 1241 
  struct falcon_nic_data *nic_data = (struct falcon_nic_data *)efx->nic_data;
  
#line 1244 
  if (! efx->link_state.up || ! nic_data->xmac_poll_required) 
#line 1245 
                                                              goto return_label; else ;
  
#line 1247 
  tmp = falcon_xmac_link_ok_retry(efx,1);
  
#line 1247 
  if ((int)tmp != 0) 
#line 1247 
                     tmp_0 = 0; else 
#line 1247 
                                     tmp_0 = 1;
  
#line 1247 
  nic_data->xmac_poll_required = (_Bool)(tmp_0 != 0);
  
#line 1248 
  falcon_ack_status_intr(efx);
  return_label: 
#line 1249 
                return;
}


#line 1258  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static void falcon_push_multicast_hash(struct efx_nic *efx)
{
  
#line 1260 
  union efx_multicast_hash *mc_hash = & efx->multicast_hash;
  {
    int tmp;
    
#line 1262 
    tmp = ldv_mutex_is_locked_105(& efx->mac_lock);
    
#line 1262 
    int __ret_warn_on = tmp == 0;
    
#line 1262 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 1262 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c",1262); else ;
    
#line 1262 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 1264 
  efx_writeo_2(efx,(efx_oword_t const *)(& mc_hash->oword[0]),3232U);
  
#line 1265 
  efx_writeo_2(efx,(efx_oword_t const *)(& mc_hash->oword[1]),3248U);
  
#line 1266 
  return;
}


#line 1268  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static void falcon_reset_macs(struct efx_nic *efx)
{
  efx_oword_t reg;
  efx_oword_t mac_ctrl;
  int count;
  int tmp;
  
#line 1270 
  struct falcon_nic_data *nic_data = (struct falcon_nic_data *)efx->nic_data;
  
#line 1274 
  tmp = efx_nic_rev(efx);
  
#line 1274 
  if (tmp <= 1) {
    
#line 1278 
    reg.u64[0] = 1ULL;
    
#line 1278 
    reg.u64[1] = 0ULL;
    
#line 1279 
    efx_writeo_2(efx,(efx_oword_t const *)(& reg),4640U);
    
#line 1281 
    count = 0;
    
#line 1281 
    goto ldv_57292;
    ldv_57291: 
#line 1282 
    ;
    
#line 1282 
    efx_reado_2(efx,& reg,4640U);
    
#line 1283 
    if ((reg.u64[0] & 1ULL) == 0ULL) 
#line 1285 
                                     goto return_label; else ;
    
#line 1286 
    __const_udelay(42950UL);
    
#line 1281 
    count += 1;
    ldv_57292: 
#line 1282 
    ;
    
#line 1281 
    if (count <= 9999) 
#line 1283 
                       goto ldv_57291; else 
#line 1286 
                                            goto ldv_57293;
    ldv_57293: 
#line 1287 
    ;
    
#line 1289 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 1289 
                                         netdev_err((struct net_device const *)efx->net_dev,"timed out waiting for XMAC core reset\n"); else ;
  }
  else ;
  {
    
#line 1294 
    int __ret_warn_on = nic_data->stats_disable_count == 0U;
    
#line 1294 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 1294 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c",1294); else ;
    
#line 1294 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 1296 
  efx_reado_2(efx,& mac_ctrl,3200U);
  
#line 1297 
  mac_ctrl.u64[0] |= 128ULL;
  
#line 1297 
  mac_ctrl.u64[1] = mac_ctrl.u64[1];
  
#line 1298 
  efx_writeo_2(efx,(efx_oword_t const *)(& mac_ctrl),3200U);
  
#line 1300 
  efx_reado_2(efx,& reg,544U);
  
#line 1301 
  reg.u64[0] |= 8388608ULL;
  
#line 1301 
  reg.u64[1] = reg.u64[1];
  
#line 1302 
  reg.u64[0] |= 16777216ULL;
  
#line 1302 
  reg.u64[1] = reg.u64[1];
  
#line 1303 
  reg.u64[0] |= 4194304ULL;
  
#line 1303 
  reg.u64[1] = reg.u64[1];
  
#line 1304 
  efx_writeo_2(efx,(efx_oword_t const *)(& reg),544U);
  
#line 1306 
  count = 0;
  ldv_57299: 
#line 1307 
  ;
  
#line 1308 
  efx_reado_2(efx,& reg,544U);
  
#line 1309 
  if (((reg.u64[0] & 8388608ULL) == 0ULL && (reg.u64[0] & 16777216ULL) == 0ULL) && (reg.u64[0] & 4194304ULL) == 0ULL) {
    
#line 1312 
    if ((efx->msg_enable & 8192U) != 0U) {
      
#line 1312 
      struct _ddebug descriptor = {.modname = "sfc", .function = "falcon_reset_macs", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c", .format = "Completed MAC reset after %d loops\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1314U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1312 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1312 
                                                          __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"Completed MAC reset after %d loops\n",count); else ;
    }
    else ;
    
#line 1315 
    goto ldv_57298;
  }
  else ;
  
#line 1317 
  if (count > 20) {
    
#line 1318 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 1318 
                                         netdev_err((struct net_device const *)efx->net_dev,"MAC reset failed\n"); else ;
    
#line 1319 
    goto ldv_57298;
  }
  else ;
  
#line 1321 
  count += 1;
  
#line 1322 
  __const_udelay(42950UL);
  
#line 1308 
  goto ldv_57299;
  ldv_57298: 
#line 1309 
  ;
  
#line 1327 
  efx_writeo_2(efx,(efx_oword_t const *)(& mac_ctrl),3200U);
  
#line 1329 
  falcon_setup_xaui(efx);
  return_label: 
#line 1330 
                return;
}


#line 1332  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static void falcon_drain_tx_fifo(struct efx_nic *efx)
{
  efx_oword_t reg;
  int tmp;
  
#line 1336 
  tmp = efx_nic_rev(efx);
  
#line 1336 
  if (tmp <= 1) 
#line 1338 
                goto return_label;
  else 
    
#line 1336 
    if (efx->loopback_mode != (unsigned int)LOOPBACK_NONE) 
#line 1338 
                                                           goto return_label; else ;
  
#line 1340 
  efx_reado_2(efx,& reg,3200U);
  
#line 1342 
  if ((reg.u64[0] & 128ULL) != 0ULL) 
#line 1343 
                                     goto return_label; else ;
  
#line 1345 
  falcon_reset_macs(efx);
  return_label: 
#line 1346 
                return;
}


#line 1348  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static void falcon_deconfigure_mac_wrapper(struct efx_nic *efx)
{
  efx_oword_t reg;
  int tmp;
  
#line 1352 
  tmp = efx_nic_rev(efx);
  
#line 1352 
  if (tmp <= 1) 
#line 1353 
                goto return_label; else ;
  
#line 1356 
  efx_reado_2(efx,& reg,2048U);
  
#line 1357 
  reg.u64[0] &= 18446603336221196287ULL;
  
#line 1357 
  reg.u64[1] = reg.u64[1];
  
#line 1358 
  efx_writeo_2(efx,(efx_oword_t const *)(& reg),2048U);
  
#line 1361 
  falcon_drain_tx_fifo(efx);
  return_label: 
#line 1362 
                return;
}


#line 1364  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static void falcon_reconfigure_mac_wrapper(struct efx_nic *efx)
{
  efx_oword_t reg;
  int link_speed;
  int isolate;
  unsigned long volatile *tmp;
  int tmp_0;
  int tmp_2;
  
#line 1366 
  struct efx_link_state *link_state = & efx->link_state;
  {
    
#line 1370 
    unsigned long __var = 0UL;
    
#line 1370 
    tmp = (unsigned long volatile *)(& efx->reset_pending);
  }
  
#line 1370 
  isolate = *tmp != 0UL;
  
#line 1372 
  switch (link_state->speed) {
    case (unsigned int)10000: 
#line 1373 
    ;
    
#line 1373 
    link_speed = 3;
    
#line 1373 
    goto ldv_57318;
    case (unsigned int)1000: 
#line 1374 
    ;
    
#line 1374 
    link_speed = 2;
    
#line 1374 
    goto ldv_57318;
    case (unsigned int)100: 
#line 1375 
    ;
    
#line 1375 
    link_speed = 1;
    
#line 1375 
    goto ldv_57318;
    default: 
#line 1376 
    ;
    
#line 1376 
    link_speed = 0;
    
#line 1376 
    goto ldv_57318;
  }
  ldv_57318: 
#line 1383 
  ;
  
#line 1383 
  reg.u64[0] = (((unsigned long long)(! efx->unicast_filter) << 3) | (unsigned long long)link_speed) | 4294901780ULL;
  
#line 1383 
  reg.u64[1] = 0ULL;
  
#line 1391 
  tmp_0 = efx_nic_rev(efx);
  
#line 1391 
  if (tmp_0 > 1) {
    
#line 1392 
    reg.u64[0] = (reg.u64[0] & 18446744073709551487ULL) | ((unsigned long long)((! link_state->up || isolate != 0) != 0) << 7);
    
#line 1392 
    reg.u64[1] = reg.u64[1];
  }
  else ;
  
#line 1396 
  efx_writeo_2(efx,(efx_oword_t const *)(& reg),3200U);
  
#line 1399 
  falcon_push_multicast_hash(efx);
  
#line 1401 
  efx_reado_2(efx,& reg,2048U);
  
#line 1404 
  reg.u64[0] |= 1ULL;
  
#line 1404 
  reg.u64[1] = reg.u64[1];
  
#line 1406 
  tmp_2 = efx_nic_rev(efx);
  
#line 1406 
  if (tmp_2 > 1) {
    unsigned long long tmp_1;
    
#line 1407 
    if (isolate == 0) 
#line 1407 
                      tmp_1 = 140737488355328ULL; else 
#line 1407 
                                                       tmp_1 = 0ULL;
    
#line 1407 
    reg.u64[0] = (reg.u64[0] & 18446603336221196287ULL) | tmp_1;
    
#line 1407 
    reg.u64[1] = reg.u64[1];
  }
  else ;
  
#line 1408 
  efx_writeo_2(efx,(efx_oword_t const *)(& reg),2048U);
  
#line 1409 
  return;
}


#line 1411  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static void falcon_stats_request(struct efx_nic *efx)
{
  efx_oword_t reg;
  unsigned long tmp_0;
  
#line 1413 
  struct falcon_nic_data *nic_data = (struct falcon_nic_data *)efx->nic_data;
  {
    
#line 1416 
    int __ret_warn_on = (int)nic_data->stats_pending != 0;
    
#line 1416 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 1416 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c",1416); else ;
    
#line 1416 
    long tmp = (long)(__ret_warn_on != 0);
  }
  {
    
#line 1417 
    int __ret_warn_on_0 = nic_data->stats_disable_count != 0U;
    
#line 1417 
    if ((long)(__ret_warn_on_0 != 0) != 0L) 
#line 1417 
                                            warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c",1417); else ;
    
#line 1417 
    long tmp_3 = (long)(__ret_warn_on_0 != 0);
  }
  
#line 1419 
  *((u32 *)(efx->stats_buffer.addr + 212U)) = 0U;
  
#line 1420 
  nic_data->stats_pending = (_Bool)1;
  
#line 1421 
  ldv_inline_asm();
  
#line 1424 
  reg.u64[0] = efx->stats_buffer.dma_addr | 281474976710656ULL;
  
#line 1424 
  reg.u64[1] = 0ULL;
  
#line 1428 
  efx_writeo_2(efx,(efx_oword_t const *)(& reg),3168U);
  
#line 1430 
  tmp_0 = round_jiffies_up(jiffies + 125UL);
  
#line 1430 
  ;
  
#line 1430 
  ldv_mod_timer_106(& nic_data->stats_timer,tmp_0);
  
#line 1431 
  return;
}


#line 1433  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static void falcon_stats_complete(struct efx_nic *efx)
{
  
#line 1435 
  struct falcon_nic_data *nic_data = (struct falcon_nic_data *)efx->nic_data;
  
#line 1437 
  if (! nic_data->stats_pending) 
#line 1438 
                                 goto return_label; else ;
  
#line 1440 
  nic_data->stats_pending = (_Bool)0;
  
#line 1441 
  if (*((u32 *)(efx->stats_buffer.addr + 212U)) != 0U) {
    
#line 1443 
    ldv_inline_asm();
    
#line 1443 
    efx_nic_update_stats((struct efx_hw_stat_desc const *)(& falcon_stat_desc),49UL,(unsigned long const *)(& falcon_stat_mask),(u64 *)(& nic_data->stats),(void const *)efx->stats_buffer.addr,(_Bool)1);
  }
  else 
    
#line 1447 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 1447 
                                         netdev_err((struct net_device const *)efx->net_dev,"timed out waiting for statistics\n"); else ;
  return_label: 
#line 1448 
                return;
}


#line 1452  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static void falcon_stats_timer_func(unsigned long context)
{
  
#line 1454 
  struct efx_nic *efx = (struct efx_nic *)context;
  
#line 1455 
  struct falcon_nic_data *nic_data = (struct falcon_nic_data *)efx->nic_data;
  
#line 1457 
  ldv_spin_lock_107(& efx->stats_lock);
  
#line 1459 
  falcon_stats_complete(efx);
  
#line 1460 
  if (nic_data->stats_disable_count == 0U) 
#line 1461 
                                           falcon_stats_request(efx); else ;
  
#line 1463 
  ldv_spin_unlock_108(& efx->stats_lock);
  
#line 1464 
  return;
}


#line 1466  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static bool falcon_loopback_link_poll(struct efx_nic *efx)
{
  bool __retres;
  int tmp_1;
  bool tmp_0;
  
#line 1468 
  struct efx_link_state old_state = efx->link_state;
  {
    int tmp;
    
#line 1470 
    tmp = ldv_mutex_is_locked_109(& efx->mac_lock);
    
#line 1470 
    int __ret_warn_on = tmp == 0;
    
#line 1470 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 1470 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c",1470); else ;
    
#line 1470 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  {
    
#line 1471 
    int __ret_warn_on_0 = ((66600958 >> (unsigned int)efx->loopback_mode) & 1) == 0;
    
#line 1471 
    if ((long)(__ret_warn_on_0 != 0) != 0L) 
#line 1471 
                                            warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c",1471); else ;
    
#line 1471 
    long tmp_4 = (long)(__ret_warn_on_0 != 0);
  }
  
#line 1473 
  efx->link_state.fd = (_Bool)1;
  
#line 1474 
  efx->link_state.fc = efx->wanted_fc;
  
#line 1475 
  efx->link_state.up = (_Bool)1;
  
#line 1476 
  efx->link_state.speed = 10000U;
  
#line 1478 
  tmp_0 = efx_link_state_equal((struct efx_link_state const *)(& efx->link_state),(struct efx_link_state const *)(& old_state));
  
#line 1478 
  if ((int)tmp_0 != 0) 
#line 1478 
                       tmp_1 = 0; else 
#line 1478 
                                       tmp_1 = 1;
  
#line 1478 
  __retres = (_Bool)(tmp_1 != 0);
  
#line 1478 
  return __retres;
}


#line 1481  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_reconfigure_port(struct efx_nic *efx)
{
  int __retres;
  int rc;
  {
    int tmp;
    
#line 1485 
    tmp = efx_nic_rev(efx);
    
#line 1485 
    int __ret_warn_on = tmp > 2;
    
#line 1485 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 1485 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c",1485); else ;
    
#line 1485 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 1491 
  if (((66600958 >> (unsigned int)efx->loopback_mode) & 1) != 0) 
#line 1492 
                                                                 falcon_loopback_link_poll(efx); else 
                                                                    
#line 1494 
                                                                    (*((efx->phy_op)->poll))(efx);
  
#line 1496 
  falcon_stop_nic_stats(efx);
  
#line 1497 
  falcon_deconfigure_mac_wrapper(efx);
  
#line 1499 
  falcon_reset_macs(efx);
  
#line 1501 
  (*((efx->phy_op)->reconfigure))(efx);
  
#line 1502 
  rc = falcon_reconfigure_xmac(efx);
  
#line 1503 
  if ((long)(rc != 0) != 0L) {
    
#line 1505 
    ldv_inline_asm();
    
#line 1503 
    ;
  }
  else ;
  
#line 1505 
  falcon_start_nic_stats(efx);
  
#line 1508 
  efx_link_status_changed(efx);
  
#line 1510 
  __retres = 0;
  
#line 1510 
  return __retres;
}


#line 1520  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static void falcon_a1_prepare_enable_fc_tx(struct efx_nic *efx)
{
  
#line 1523 
  efx_schedule_reset(efx,(enum reset_type)RESET_TYPE_INVISIBLE);
  
#line 1524 
  return;
}


#line 1526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static void falcon_b0_prepare_enable_fc_tx(struct efx_nic *efx)
{
  
#line 1529 
  falcon_stop_nic_stats(efx);
  
#line 1530 
  falcon_drain_tx_fifo(efx);
  
#line 1531 
  falcon_reconfigure_xmac(efx);
  
#line 1532 
  falcon_start_nic_stats(efx);
  
#line 1533 
  return;
}


#line 1543  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_gmii_wait(struct efx_nic *efx)
{
  int __retres;
  efx_oword_t md_stat;
  int count;
  
#line 1549 
  count = 0;
  
#line 1549 
  goto ldv_57366;
  ldv_57365: 
#line 1550 
  ;
  
#line 1550 
  efx_reado_2(efx,& md_stat,3152U);
  
#line 1551 
  if ((md_stat.u64[0] & 1ULL) == 0ULL) {
    
#line 1552 
    if ((md_stat.u64[0] & 2ULL) != 0ULL || (md_stat.u64[0] & 4ULL) != 0ULL) {
      
#line 1554 
      if ((efx->msg_enable & 8192U) != 0U) 
#line 1554 
                                           netdev_err((struct net_device const *)efx->net_dev,"error from GMII access ",md_stat.u32[3],md_stat.u32[2],md_stat.u32[1],md_stat.u32[0]); else ;
      
#line 1558 
      __retres = -5;
      
#line 1558 
      goto return_label;
    }
    else ;
    
#line 1560 
    __retres = 0;
    
#line 1560 
    goto return_label;
  }
  else ;
  
#line 1562 
  __const_udelay(42950UL);
  
#line 1549 
  count += 1;
  ldv_57366: 
#line 1550 
  ;
  
#line 1549 
  if (count <= 4999) 
#line 1551 
                     goto ldv_57365; else 
#line 1554 
                                          goto ldv_57367;
  ldv_57367: 
#line 1555 
  ;
  
#line 1564 
  if ((efx->msg_enable & 8192U) != 0U) 
#line 1564 
                                       netdev_err((struct net_device const *)efx->net_dev,"timed out waiting for GMII\n"); else ;
  
#line 1565 
  __retres = -110;
  return_label: 
#line 1565 
                return __retres;
}


#line 1569  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_mdio_write(struct net_device *net_dev, int prtad, int devad, u16 addr, u16 value)
{
  efx_oword_t reg;
  int rc;
  
#line 1572 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 1573 
  struct falcon_nic_data *nic_data = (struct falcon_nic_data *)efx->nic_data;
  
#line 1581 
  ldv_mutex_lock_110(& nic_data->mdio_lock);
  
#line 1584 
  rc = falcon_gmii_wait(efx);
  
#line 1585 
  if (rc != 0) 
#line 1586 
               goto out; else ;
  
#line 1589 
  reg.u64[0] = (unsigned long long)addr;
  
#line 1589 
  reg.u64[1] = 0ULL;
  
#line 1590 
  efx_writeo_2(efx,(efx_oword_t const *)(& reg),3120U);
  
#line 1592 
  reg.u64[0] = ((unsigned long long)prtad << 11) | ((unsigned long long)devad << 6);
  
#line 1592 
  reg.u64[1] = 0ULL;
  
#line 1594 
  efx_writeo_2(efx,(efx_oword_t const *)(& reg),3136U);
  
#line 1597 
  reg.u64[0] = (unsigned long long)value;
  
#line 1597 
  reg.u64[1] = 0ULL;
  
#line 1598 
  efx_writeo_2(efx,(efx_oword_t const *)(& reg),3072U);
  
#line 1600 
  reg.u64[0] = 1ULL;
  
#line 1600 
  reg.u64[1] = 0ULL;
  
#line 1603 
  efx_writeo_2(efx,(efx_oword_t const *)(& reg),3104U);
  
#line 1606 
  rc = falcon_gmii_wait(efx);
  
#line 1607 
  if (rc != 0) {
    
#line 1609 
    reg.u64[0] = 16ULL;
    
#line 1609 
    reg.u64[1] = 0ULL;
    
#line 1612 
    efx_writeo_2(efx,(efx_oword_t const *)(& reg),3104U);
    
#line 1613 
    __const_udelay(42950UL);
  }
  else ;
  out: 
#line 1616 
  ;
  
#line 1617 
  ldv_mutex_unlock_111(& nic_data->mdio_lock);
  
#line 1618 
  return rc;
}


#line 1622  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_mdio_read(struct net_device *net_dev, int prtad, int devad, u16 addr)
{
  efx_oword_t reg;
  int rc;
  
#line 1625 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 1626 
  struct falcon_nic_data *nic_data = (struct falcon_nic_data *)efx->nic_data;
  
#line 1630 
  ldv_mutex_lock_112_0(& nic_data->mdio_lock);
  
#line 1633 
  rc = falcon_gmii_wait(efx);
  
#line 1634 
  if (rc != 0) 
#line 1635 
               goto out; else ;
  
#line 1637 
  reg.u64[0] = (unsigned long long)addr;
  
#line 1637 
  reg.u64[1] = 0ULL;
  
#line 1638 
  efx_writeo_2(efx,(efx_oword_t const *)(& reg),3120U);
  
#line 1640 
  reg.u64[0] = ((unsigned long long)prtad << 11) | ((unsigned long long)devad << 6);
  
#line 1640 
  reg.u64[1] = 0ULL;
  
#line 1642 
  efx_writeo_2(efx,(efx_oword_t const *)(& reg),3136U);
  
#line 1645 
  reg.u64[0] = 2ULL;
  
#line 1645 
  reg.u64[1] = 0ULL;
  
#line 1646 
  efx_writeo_2(efx,(efx_oword_t const *)(& reg),3104U);
  
#line 1649 
  rc = falcon_gmii_wait(efx);
  
#line 1650 
  if (rc == 0) {
    
#line 1651 
    efx_reado_2(efx,& reg,3088U);
    
#line 1652 
    rc = (int)reg.u64[0] & 65535;
  }
  else {
    
#line 1658 
    reg.u64[0] = 16ULL;
    
#line 1658 
    reg.u64[1] = 0ULL;
    
#line 1661 
    efx_writeo_2(efx,(efx_oword_t const *)(& reg),3104U);
    
#line 1663 
    if ((efx->msg_enable & 8192U) != 0U) {
      
#line 1663 
      struct _ddebug descriptor = {.modname = "sfc", .function = "falcon_mdio_read", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c", .format = "read from MDIO %d register %d.%d, got error %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1665U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1663 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1663 
                                                          __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"read from MDIO %d register %d.%d, got error %d\n",prtad,devad,(int)addr,rc); else ;
    }
    else ;
  }
  out: 
#line 1668 
  ;
  
#line 1669 
  ldv_mutex_unlock_113_0(& nic_data->mdio_lock);
  
#line 1670 
  return rc;
}


#line 1674  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_probe_port(struct efx_nic *efx)
{
  int __retres;
  int rc;
  int tmp;
  
#line 1676 
  struct falcon_nic_data *nic_data = (struct falcon_nic_data *)efx->nic_data;
  
#line 1679 
  switch (efx->phy_type) {
    case (unsigned int)3: 
#line 1680 
    ;
    
#line 1681 
    efx->phy_op = & falcon_sfx7101_phy_ops;
    
#line 1682 
    goto ldv_57401;
    case (unsigned int)4: 
#line 1683 
    ;
    case (unsigned int)9: 
#line 1684 
    ;
    
#line 1685 
    efx->phy_op = & falcon_qt202x_phy_ops;
    
#line 1686 
    goto ldv_57401;
    case (unsigned int)1: 
#line 1687 
    ;
    
#line 1688 
    efx->phy_op = & falcon_txc_phy_ops;
    
#line 1689 
    goto ldv_57401;
    default: 
#line 1690 
    ;
    
#line 1691 
    if ((efx->msg_enable & 2U) != 0U) 
#line 1691 
                                      netdev_err((struct net_device const *)efx->net_dev,"Unknown PHY type %d\n",efx->phy_type); else ;
    
#line 1693 
    __retres = -19;
    
#line 1693 
    goto return_label;
  }
  ldv_57401: 
#line 1697 
  ;
  {
    struct lock_class_key __key;
    
#line 1697 
    __mutex_init(& nic_data->mdio_lock,"&nic_data->mdio_lock",& __key);
  }
  
#line 1698 
  efx->mdio.mdio_read = & falcon_mdio_read;
  
#line 1699 
  efx->mdio.mdio_write = & falcon_mdio_write;
  
#line 1700 
  rc = (*((efx->phy_op)->probe))(efx);
  
#line 1701 
  if (rc != 0) {
    
#line 1702 
    __retres = rc;
    
#line 1702 
    goto return_label;
  }
  else ;
  
#line 1705 
  efx->link_state.speed = 10000U;
  
#line 1706 
  efx->link_state.fd = (_Bool)1;
  
#line 1709 
  tmp = efx_nic_rev(efx);
  
#line 1709 
  if (tmp > 1) 
#line 1710 
               efx->wanted_fc = (unsigned char)3U; else 
#line 1712 
                                                        efx->wanted_fc = (unsigned char)2U;
  
#line 1713 
  if ((efx->mdio.mmds & 128U) != 0U) 
#line 1714 
                                     efx->wanted_fc = (unsigned char)((unsigned int)efx->wanted_fc | 4U); else ;
  
#line 1717 
  rc = efx_nic_alloc_buffer(efx,& efx->stats_buffer,256U,208U);
  
#line 1719 
  if (rc != 0) {
    
#line 1720 
    __retres = rc;
    
#line 1720 
    goto return_label;
  }
  else ;
  
#line 1721 
  if ((efx->msg_enable & 2U) != 0U) {
    
#line 1721 
    struct _ddebug descriptor = {.modname = "sfc", .function = "falcon_probe_port", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c", .format = "stats buffer at %llx (virt %p phys %llx)\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1725U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1721 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      phys_addr_t tmp_0;
      
#line 1721 
      tmp_0 = virt_to_phys((void volatile *)efx->stats_buffer.addr);
      
#line 1721 
      ;
      
#line 1721 
      ;
      
#line 1721 
      ;
      
#line 1721 
      __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"stats buffer at %llx (virt %p phys %llx)\n",efx->stats_buffer.dma_addr,efx->stats_buffer.addr,tmp_0);
    }
    else ;
  }
  else ;
  
#line 1727 
  __retres = 0;
  return_label: 
#line 1727 
                return __retres;
}


#line 1730  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static void falcon_remove_port(struct efx_nic *efx)
{
  
#line 1732 
  (*((efx->phy_op)->remove))(efx);
  
#line 1733 
  efx_nic_free_buffer(efx,& efx->stats_buffer);
  
#line 1734 
  return;
}


#line 1738  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static bool falcon_handle_global_event(struct efx_channel *channel, efx_qword_t *event)
{
  bool __retres;
  int tmp;
  int tmp_3;
  int tmp_2;
  
#line 1740 
  struct efx_nic *efx = channel->efx;
  
#line 1741 
  struct falcon_nic_data *nic_data = (struct falcon_nic_data *)efx->nic_data;
  
#line 1743 
  if (((event->u64[0] & 128ULL) != 0ULL || (event->u64[0] & 512ULL) != 0ULL) || (event->u64[0] & 1024ULL) != 0ULL) {
    
#line 1747 
    __retres = (_Bool)1;
    
#line 1747 
    goto return_label;
  }
  else ;
  
#line 1749 
  tmp = efx_nic_rev(efx);
  
#line 1749 
  if (tmp == 2) {
    
#line 1749 
    if ((event->u64[0] & 2048ULL) != 0ULL) {
      
#line 1751 
      nic_data->xmac_poll_required = (_Bool)1;
      
#line 1752 
      __retres = (_Bool)1;
      
#line 1752 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 1755 
  tmp_2 = efx_nic_rev(efx);
  
#line 1755 
  if (tmp_2 <= 1) 
#line 1755 
                  tmp_3 = (event->u64[0] & 2048ULL) != 0ULL; else 
#line 1755 
                                                                  tmp_3 = (event->u64[0] & 4096ULL) != 0ULL;
  
#line 1755 
  if (tmp_3) {
    int tmp_1;
    int tmp_0;
    
#line 1758 
    if ((efx->msg_enable & 64U) != 0U) 
#line 1758 
                                       netdev_err((struct net_device const *)efx->net_dev,"channel %d seen global RX_RESET event. Resetting.\n",channel->channel); else ;
    
#line 1762 
    atomic_inc_3(& efx->rx_reset);
    
#line 1764 
    tmp_0 = efx_nic_rev(efx);
    
#line 1764 
    if (tmp_0 <= 1) 
#line 1764 
                    tmp_1 = 11; else 
#line 1764 
                                     tmp_1 = 7;
    
#line 1763 
    ;
    
#line 1763 
    efx_schedule_reset(efx,(enum reset_type)tmp_1);
    
#line 1765 
    __retres = (_Bool)1;
    
#line 1765 
    goto return_label;
  }
  else ;
  
#line 1768 
  __retres = (_Bool)0;
  return_label: 
#line 1768 
                return __retres;
}


#line 1778  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_read_nvram(struct efx_nic *efx, struct falcon_nvconfig *nvconfig_out)
{
  int __retres;
  struct falcon_nvconfig *nvconfig;
  struct falcon_spi_device *spi;
  void *region;
  int rc;
  int magic_num;
  int struct_ver;
  __le16 *word;
  __le16 *limit;
  u32 csum;
  bool tmp_0;
  
#line 1780 
  struct falcon_nic_data *nic_data = (struct falcon_nic_data *)efx->nic_data;
  
#line 1788 
  tmp_0 = falcon_spi_present((struct falcon_spi_device const *)(& nic_data->spi_flash));
  
#line 1788 
  if ((int)tmp_0 != 0) 
#line 1789 
                       spi = & nic_data->spi_flash;
  else {
    bool tmp;
    
#line 1790 
    tmp = falcon_spi_present((struct falcon_spi_device const *)(& nic_data->spi_eeprom));
    
#line 1790 
    if ((int)tmp != 0) 
#line 1791 
                       spi = & nic_data->spi_eeprom;
    else {
      
#line 1793 
      __retres = -22;
      
#line 1793 
      goto return_label;
    }
  }
  
#line 1795 
  region = kmalloc_3(1024UL,208U);
  
#line 1796 
  if (region == (void *)0) {
    
#line 1797 
    __retres = -12;
    
#line 1797 
    goto return_label;
  }
  else ;
  
#line 1798 
  nvconfig = (struct falcon_nvconfig *)(region + 768U);
  
#line 1800 
  ldv_mutex_lock_114(& nic_data->spi_lock);
  
#line 1801 
  rc = falcon_spi_read(efx,(struct falcon_spi_device const *)spi,0LL,1024UL,(size_t *)0UL,(u8 *)region);
  
#line 1802 
  ldv_mutex_unlock_115(& nic_data->spi_lock);
  
#line 1803 
  if (rc != 0) {
    
#line 1804 
    if ((efx->msg_enable & 8192U) != 0U) {
      char *tmp_2;
      bool tmp_1;
      
#line 1804 
      tmp_1 = falcon_spi_present((struct falcon_spi_device const *)(& nic_data->spi_flash));
      
#line 1804 
      if ((int)tmp_1 != 0) 
#line 1804 
                           tmp_2 = (char *)"flash"; else 
#line 1804 
                                                         tmp_2 = (char *)"EEPROM";
      
#line 1804 
      ;
      
#line 1804 
      netdev_err((struct net_device const *)efx->net_dev,"Failed to read %s\n",tmp_2);
    }
    else ;
    
#line 1807 
    rc = -5;
    
#line 1808 
    goto out;
  }
  else ;
  
#line 1811 
  magic_num = (int)nvconfig->board_magic_num;
  
#line 1812 
  struct_ver = (int)nvconfig->board_struct_ver;
  
#line 1814 
  rc = -22;
  
#line 1815 
  if (magic_num != 64028) {
    
#line 1816 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 1816 
                                         netdev_err((struct net_device const *)efx->net_dev,"NVRAM bad magic 0x%x\n",magic_num); else ;
    
#line 1818 
    goto out;
  }
  else ;
  
#line 1820 
  if (struct_ver <= 1) {
    
#line 1821 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 1821 
                                         netdev_err((struct net_device const *)efx->net_dev,"NVRAM has ancient version 0x%x\n",struct_ver); else ;
    
#line 1823 
    goto out;
  }
  else 
    
#line 1824 
    if (struct_ver <= 3) {
      
#line 1825 
      word = & nvconfig->board_magic_num;
      
#line 1826 
      limit = (__le16 *)(nvconfig + 1U);
    }
    else {
      
#line 1828 
      word = (__le16 *)region;
      
#line 1829 
      limit = (__le16 *)(region + 1024U);
    }
  
#line 1831 
  csum = 0U;
  
#line 1831 
  goto ldv_57434;
  ldv_57433: 
#line 1832 
  ;
  
#line 1832 
  csum = (unsigned int)*word + csum;
  
#line 1831 
  word += 1;
  ldv_57434: 
#line 1832 
  ;
  
#line 1831 
  if (word < limit) 
#line 1833 
                    goto ldv_57433; else 
#line 1836 
                                         goto ldv_57435;
  ldv_57435: 
#line 1837 
  ;
  
#line 1834 
  if ((~ csum & 65535U) != 0U) {
    
#line 1835 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 1835 
                                         netdev_err((struct net_device const *)efx->net_dev,"NVRAM has incorrect checksum\n"); else ;
    
#line 1837 
    goto out;
  }
  else ;
  
#line 1840 
  rc = 0;
  
#line 1841 
  if (nvconfig_out != (struct falcon_nvconfig *)0) 
#line 1842 
                                                   memcpy((void *)nvconfig_out,(void const *)nvconfig,200UL); else ;
  out: 
#line 1844 
  ;
  
#line 1845 
  kfree((void const *)region);
  
#line 1846 
  __retres = rc;
  return_label: 
#line 1846 
                return __retres;
}


#line 1849  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_test_nvram(struct efx_nic *efx)
{
  int tmp;
  
#line 1851 
  tmp = falcon_read_nvram(efx,(struct falcon_nvconfig *)0);
  
#line 1851 
  return tmp;
}


#line 1854  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static struct efx_farch_register_test const falcon_b0_register_tests[18U] = {{.address = 0U, .mask = {.u32 = {262143U, 262143U, 262143U, 262143U}}}, {.address = 2048U, .mask = {.u32 = {4294967294U, 98303U, 0U, 0U}}}, {.address = 2640U, .mask = {.u32 = {2147418167U, 0U, 0U, 0U}}}, {.address = 2688U, .mask = {.u32 = {4294901376U, 536870911U, 33554686U, 8388607U}}}, {.address = 3200U, .mask = {.u32 = {4294901760U, 0U, 0U, 0U}}}, {.address = 1568U, .mask = {.u32 = {2097151U, 0U, 0U, 0U}}}, {.address = 2112U, .mask = {.u32 = {15U, 0U, 0U, 0U}}}, {.address = 2128U, .mask = {.u32 = {1023U, 0U, 0U, 0U}}}, {.address = 592U, .mask = {.u32 = {4095U, 0U, 0U, 0U}}}, {.address = 3600U, .mask = {.u32 = {29495U, 0U, 0U, 0U}}}, {.address = 3872U, .mask = {.u32 = {7967U, 0U, 0U, 0U}}}, {.address = 4640U, .mask = {.u32 = {3176U, 0U, 0U, 0U}}}, {.address = 4656U, .mask = {.u32 = {524644U, 0U, 0U, 0U}}}, {.address = 4672U, .mask = {.u32 = {118491660U, 0U, 0U, 0U}}}, {.address = 4832U, .mask = {.u32 = {8184U, 0U, 0U, 0U}}}, {.address = 4720U, .mask = {.u32 = {4294901761U, 0U, 0U, 0U}}}, {.address = 4608U, .mask = {.u32 = {4294967295U, 0U, 0U, 0U}}}, {.address = 4880U, .mask = {.u32 = {261903U, 0U, 0U, 0U}}}};

#line 1894  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_b0_test_chip(struct efx_nic *efx, struct efx_self_tests *tests)
{
  int rc;
  int rc2;
  int tmp_0;
  int tmp_1;
  
#line 1896 
  enum reset_type reset_method = RESET_TYPE_INVISIBLE;
  
#line 1899 
  ldv_mutex_lock_116(& efx->mac_lock);
  
#line 1900 
  if (efx->loopback_modes != 0ULL) 
    
#line 1903 
    if ((efx->loopback_modes & 8ULL) != 0ULL) 
#line 1904 
                                              efx->loopback_mode = LOOPBACK_XGMII;
    else {
      unsigned long tmp;
      
#line 1906 
      tmp = __ffs((unsigned long)efx->loopback_modes);
      
#line 1906 
      efx->loopback_mode = (enum efx_loopback_mode)tmp;
    }
  else ;
  
#line 1908 
  __efx_reconfigure_port(efx);
  
#line 1909 
  ldv_mutex_unlock_117(& efx->mac_lock);
  
#line 1911 
  efx_reset_down(efx,reset_method);
  
#line 1913 
  tmp_0 = efx_farch_test_registers(efx,(struct efx_farch_register_test const *)(& falcon_b0_register_tests),18UL);
  
#line 1913 
  if (tmp_0 != 0) 
#line 1913 
                  tests->registers = -1; else 
#line 1913 
                                              tests->registers = 1;
  
#line 1918 
  rc = falcon_reset_hw(efx,reset_method);
  
#line 1919 
  rc2 = efx_reset_up(efx,reset_method,(_Bool)(rc == 0));
  
#line 1920 
  if (rc != 0) 
#line 1920 
               tmp_1 = rc; else 
#line 1920 
                                tmp_1 = rc2;
  
#line 1920 
  return tmp_1;
}


#line 1930  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static enum reset_type falcon_map_reset_reason(enum reset_type reason)
{
  enum reset_type __retres;
  
#line 1932 
  switch ((unsigned int)reason) {
    case (unsigned int)11: 
#line 1933 
    ;
    case (unsigned int)12: 
#line 1934 
    ;
    case (unsigned int)13: 
#line 1935 
    ;
    
#line 1939 
    __retres = RESET_TYPE_INVISIBLE;
    
#line 1939 
    goto return_label;
    default: 
#line 1940 
    ;
    
#line 1941 
    __retres = RESET_TYPE_ALL;
    
#line 1941 
    goto return_label;
  }
  return_label: 
#line 1932 
                return __retres;
}


#line 1945  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_map_reset_flags(u32 *flags)
{
  int __retres;
  
#line 1954 
  if ((*flags & 126U) == 126U) {
    
#line 1955 
    *flags &= 4294967169U;
    
#line 1956 
    __retres = 3;
    
#line 1956 
    goto return_label;
  }
  else ;
  
#line 1959 
  if ((*flags & 124U) == 124U) {
    
#line 1960 
    *flags &= 4294967171U;
    
#line 1961 
    __retres = 2;
    
#line 1961 
    goto return_label;
  }
  else ;
  
#line 1964 
  if ((*flags & 60U) == 60U) {
    
#line 1965 
    *flags &= 4294967235U;
    
#line 1966 
    __retres = 0;
    
#line 1966 
    goto return_label;
  }
  else ;
  
#line 1969 
  __retres = -22;
  return_label: 
#line 1969 
                return __retres;
}


#line 1974  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int __falcon_reset_hw(struct efx_nic *efx, enum reset_type method)
{
  int __retres;
  efx_oword_t glb_ctl_reg_ker;
  int rc;
  
#line 1976 
  struct falcon_nic_data *nic_data = (struct falcon_nic_data *)efx->nic_data;
  
#line 1980 
  if ((efx->msg_enable & 8192U) != 0U) {
    
#line 1980 
    struct _ddebug descriptor = {.modname = "sfc", .function = "__falcon_reset_hw", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c", .format = "performing %s hardware reset\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1981U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1980 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      char const *tmp;
      
#line 1980 
      if ((unsigned int)method < efx_reset_type_max) 
#line 1980 
                                                     tmp = efx_reset_type_names[(unsigned int)method]; else 
                                                                    
#line 1980 
                                                                    tmp = "(invalid)";
      
#line 1980 
      ;
      
#line 1980 
      __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"performing %s hardware reset\n",tmp);
    }
    else ;
  }
  else ;
  
#line 1984 
  if (method == (unsigned int)RESET_TYPE_WORLD) {
    bool tmp_0;
    
#line 1985 
    rc = pci_save_state(efx->pci_dev);
    
#line 1986 
    if (rc != 0) {
      
#line 1987 
      if ((efx->msg_enable & 1U) != 0U) 
#line 1987 
                                        netdev_err((struct net_device const *)efx->net_dev,"failed to backup PCI state of primary "); else ;
      
#line 1990 
      goto fail1;
    }
    else ;
    
#line 1992 
    tmp_0 = efx_nic_is_dual_func(efx);
    
#line 1992 
    if ((int)tmp_0 != 0) {
      
#line 1993 
      rc = pci_save_state(nic_data->pci_dev2);
      
#line 1994 
      if (rc != 0) {
        
#line 1995 
        if ((efx->msg_enable & 1U) != 0U) 
#line 1995 
                                          netdev_err((struct net_device const *)efx->net_dev,"failed to backup PCI state of "); else ;
        
#line 1999 
        goto fail2;
      }
      else ;
    }
    else ;
    
#line 2003 
    glb_ctl_reg_ker.u64[0] = 15ULL;
    
#line 2003 
    glb_ctl_reg_ker.u64[1] = 0ULL;
  }
  else {
    
#line 2008 
    if (method == (unsigned int)RESET_TYPE_INVISIBLE) 
#line 2008 
                                                      glb_ctl_reg_ker.u64[0] = 11962123560249458703ULL; else 
                                                                    
#line 2008 
                                                                    glb_ctl_reg_ker.u64[0] = 2738751523394682895ULL;
    
#line 2008 
    glb_ctl_reg_ker.u64[1] = 0ULL;
  }
  
#line 2021 
  efx_writeo_2(efx,(efx_oword_t const *)(& glb_ctl_reg_ker),544U);
  
#line 2023 
  if ((efx->msg_enable & 8192U) != 0U) {
    
#line 2023 
    struct _ddebug descriptor_0 = {.modname = "sfc", .function = "__falcon_reset_hw", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c", .format = "waiting for hardware reset\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2023U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 2023 
    if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 2023 
                                                          __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)efx->net_dev,"waiting for hardware reset\n"); else ;
  }
  else ;
  
#line 2024 
  schedule_timeout_uninterruptible(12L);
  
#line 2027 
  if (method == (unsigned int)RESET_TYPE_WORLD) {
    bool tmp_1;
    
#line 2028 
    tmp_1 = efx_nic_is_dual_func(efx);
    
#line 2028 
    if ((int)tmp_1 != 0) 
#line 2029 
                         pci_restore_state(nic_data->pci_dev2); else ;
    
#line 2030 
    pci_restore_state(efx->pci_dev);
    
#line 2031 
    if ((efx->msg_enable & 1U) != 0U) {
      
#line 2031 
      struct _ddebug descriptor_1 = {.modname = "sfc", .function = "__falcon_reset_hw", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c", .format = "successfully restored PCI config\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2032U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 2031 
      if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) 
#line 2031 
                                                            __dynamic_netdev_dbg(& descriptor_1,(struct net_device const *)efx->net_dev,"successfully restored PCI config\n"); else ;
    }
    else ;
  }
  else ;
  
#line 2036 
  efx_reado_2(efx,& glb_ctl_reg_ker,544U);
  
#line 2037 
  if ((glb_ctl_reg_ker.u64[0] & 1ULL) != 0ULL) {
    
#line 2038 
    rc = -110;
    
#line 2039 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 2039 
                                         netdev_err((struct net_device const *)efx->net_dev,"timed out waiting for hardware reset\n"); else ;
    
#line 2041 
    goto fail3;
  }
  else ;
  
#line 2043 
  if ((efx->msg_enable & 8192U) != 0U) {
    
#line 2043 
    struct _ddebug descriptor_2 = {.modname = "sfc", .function = "__falcon_reset_hw", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c", .format = "hardware reset complete\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2043U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 2043 
    if ((long)(((int)descriptor_2.flags & 1) != 0) != 0L) 
#line 2043 
                                                          __dynamic_netdev_dbg(& descriptor_2,(struct net_device const *)efx->net_dev,"hardware reset complete\n"); else ;
  }
  else ;
  
#line 2045 
  __retres = 0;
  
#line 2045 
  goto return_label;
  fail2: 
#line 2048 
  ;
  
#line 2049 
  pci_restore_state(efx->pci_dev);
  fail1: 
#line 2050 
  ;
  fail3: 
#line 2051 
  ;
  
#line 2052 
  __retres = rc;
  return_label: 
#line 2052 
                return __retres;
}


#line 2055  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_reset_hw(struct efx_nic *efx, enum reset_type method)
{
  int rc;
  
#line 2057 
  struct falcon_nic_data *nic_data = (struct falcon_nic_data *)efx->nic_data;
  
#line 2060 
  ldv_mutex_lock_118(& nic_data->spi_lock);
  
#line 2061 
  rc = __falcon_reset_hw(efx,method);
  
#line 2062 
  ldv_mutex_unlock_119(& nic_data->spi_lock);
  
#line 2064 
  return rc;
}


#line 2067  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static void falcon_monitor(struct efx_nic *efx)
{
  bool link_changed;
  int rc;
  int tmp;
  struct falcon_board *tmp_0;
  
#line 2072 
  tmp = ldv_mutex_is_locked_120(& efx->mac_lock);
  
#line 2072 
  if ((long)(tmp == 0) != 0L) {
    
#line 2074 
    ldv_inline_asm();
    
#line 2072 
    ;
  }
  else ;
  
#line 2074 
  tmp_0 = falcon_board(efx);
  
#line 2074 
  rc = (*((tmp_0->type)->monitor))(efx);
  
#line 2075 
  if (rc != 0) {
    
#line 2076 
    if ((efx->msg_enable & 8192U) != 0U) {
      char *tmp_1;
      
#line 2076 
      if (rc == -34) 
#line 2076 
                     tmp_1 = (char *)"reported fault"; else 
#line 2076 
                                                            tmp_1 = (char *)"failed";
      
#line 2076 
      ;
      
#line 2076 
      netdev_err((struct net_device const *)efx->net_dev,"Board sensor %s; shutting down PHY\n",tmp_1);
    }
    else ;
    
#line 2079 
    efx->phy_mode = (enum efx_phy_mode)((unsigned int)efx->phy_mode | 2U);
    
#line 2080 
    rc = __efx_reconfigure_port(efx);
    {
      
#line 2081 
      int __ret_warn_on = rc != 0;
      
#line 2081 
      if ((long)(__ret_warn_on != 0) != 0L) 
#line 2081 
                                            warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c",2081); else ;
      
#line 2081 
      long tmp_2 = (long)(__ret_warn_on != 0);
    }
  }
  else ;
  
#line 2084 
  if (((66600958 >> (unsigned int)efx->loopback_mode) & 1) != 0) 
#line 2085 
                                                                 link_changed = falcon_loopback_link_poll(efx); else 
                                                                    
#line 2087 
                                                                    link_changed = (*((efx->phy_op)->poll))(efx);
  
#line 2089 
  if ((int)link_changed != 0) {
    
#line 2090 
    falcon_stop_nic_stats(efx);
    
#line 2091 
    falcon_deconfigure_mac_wrapper(efx);
    
#line 2093 
    falcon_reset_macs(efx);
    
#line 2094 
    rc = falcon_reconfigure_xmac(efx);
    
#line 2095 
    if ((long)(rc != 0) != 0L) {
      
#line 2097 
      ldv_inline_asm();
      
#line 2095 
      ;
    }
    else ;
    
#line 2097 
    falcon_start_nic_stats(efx);
    
#line 2099 
    efx_link_status_changed(efx);
  }
  else ;
  
#line 2102 
  falcon_poll_xmac(efx);
  
#line 2103 
  return;
}


#line 2108  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_reset_sram(struct efx_nic *efx)
{
  int __retres;
  efx_oword_t srm_cfg_reg_ker;
  efx_oword_t gpio_cfg_reg_ker;
  int count;
  
#line 2114 
  efx_reado_2(efx,& gpio_cfg_reg_ker,528U);
  
#line 2115 
  gpio_cfg_reg_ker.u64[0] |= 33554432ULL;
  
#line 2115 
  gpio_cfg_reg_ker.u64[1] = gpio_cfg_reg_ker.u64[1];
  
#line 2116 
  gpio_cfg_reg_ker.u64[0] |= 131072ULL;
  
#line 2116 
  gpio_cfg_reg_ker.u64[1] = gpio_cfg_reg_ker.u64[1];
  
#line 2117 
  efx_writeo_2(efx,(efx_oword_t const *)(& gpio_cfg_reg_ker),528U);
  
#line 2120 
  srm_cfg_reg_ker.u64[0] = 8ULL;
  
#line 2120 
  srm_cfg_reg_ker.u64[1] = 0ULL;
  
#line 2123 
  efx_writeo_2(efx,(efx_oword_t const *)(& srm_cfg_reg_ker),1584U);
  
#line 2126 
  count = 0;
  ldv_57501: 
#line 2127 
  ;
  
#line 2128 
  if ((efx->msg_enable & 8192U) != 0U) {
    
#line 2128 
    struct _ddebug descriptor = {.modname = "sfc", .function = "falcon_reset_sram", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c", .format = "waiting for SRAM reset (attempt %d)...\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2129U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 2128 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 2128 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"waiting for SRAM reset (attempt %d)...\n",count); else ;
  }
  else ;
  
#line 2132 
  schedule_timeout_uninterruptible(5L);
  
#line 2135 
  efx_reado_2(efx,& srm_cfg_reg_ker,1584U);
  
#line 2136 
  if ((srm_cfg_reg_ker.u64[0] & 8ULL) == 0ULL) {
    
#line 2137 
    if ((efx->msg_enable & 8192U) != 0U) {
      
#line 2137 
      struct _ddebug descriptor_0 = {.modname = "sfc", .function = "falcon_reset_sram", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c", .format = "SRAM reset complete\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2138U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 2137 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 2137 
                                                            __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)efx->net_dev,"SRAM reset complete\n"); else ;
    }
    else ;
    
#line 2140 
    __retres = 0;
    
#line 2140 
    goto return_label;
  }
  else ;
  
#line 2142 
  count += 1;
  
#line 2142 
  if (count <= 19) 
#line 2144 
                   goto ldv_57501; else 
#line 2147 
                                        goto ldv_57502;
  ldv_57502: 
#line 2148 
  ;
  
#line 2144 
  if ((efx->msg_enable & 8192U) != 0U) 
#line 2144 
                                       netdev_err((struct net_device const *)efx->net_dev,"timed out waiting for SRAM reset\n"); else ;
  
#line 2145 
  __retres = -110;
  return_label: 
#line 2145 
                return __retres;
}


#line 2148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static void falcon_spi_device_init(struct efx_nic *efx, struct falcon_spi_device *spi_device, unsigned int device_id, u32 device_type)
{
  
#line 2152 
  if (device_type != 0U) {
    
#line 2153 
    spi_device->device_id = (int)device_id;
    
#line 2154 
    spi_device->size = (unsigned int)(1 << (device_type & 31U));
    
#line 2156 
    spi_device->addr_len = (device_type >> 6) & 3U;
    
#line 2158 
    spi_device->munge_address = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))((spi_device->size == 512U && spi_device->addr_len == 1U) != 0);
    
#line 2160 
    spi_device->erase_command = (unsigned char)(device_type >> 8);
    
#line 2162 
    spi_device->erase_size = (unsigned int)(1 << ((device_type >> 16) & 31U));
    
#line 2165 
    spi_device->block_size = (unsigned int)(1 << ((device_type >> 24) & 31U));
  }
  else 
#line 2169 
       spi_device->size = 0U;
  
#line 2170 
  return;
}


#line 2174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_probe_nvconfig(struct efx_nic *efx)
{
  int __retres;
  struct falcon_nvconfig *nvconfig;
  int rc;
  
#line 2176 
  struct falcon_nic_data *nic_data = (struct falcon_nic_data *)efx->nic_data;
  
#line 2180 
  nvconfig = (struct falcon_nvconfig *)kmalloc_3(200UL,208U);
  
#line 2181 
  if (nvconfig == (struct falcon_nvconfig *)0) {
    
#line 2182 
    __retres = -12;
    
#line 2182 
    goto return_label;
  }
  else ;
  
#line 2184 
  rc = falcon_read_nvram(efx,nvconfig);
  
#line 2185 
  if (rc != 0) 
#line 2186 
               goto out; else ;
  
#line 2188 
  efx->phy_type = (unsigned int)nvconfig->board_v2.port0_phy_type;
  
#line 2189 
  efx->mdio.prtad = (int)nvconfig->board_v2.port0_phy_addr;
  
#line 2191 
  if ((unsigned int)nvconfig->board_struct_ver > 2U) {
    
#line 2192 
    falcon_spi_device_init(efx,& nic_data->spi_flash,1U,nvconfig->board_v3.spi_device_type[1]);
    
#line 2196 
    falcon_spi_device_init(efx,& nic_data->spi_eeprom,0U,nvconfig->board_v3.spi_device_type[0]);
  }
  else ;
  
#line 2203 
  ether_addr_copy((u8 *)(& (efx->net_dev)->perm_addr),(u8 const *)(& nvconfig->mac_address[0]));
  
#line 2205 
  if ((efx->msg_enable & 2U) != 0U) {
    
#line 2205 
    struct _ddebug descriptor = {.modname = "sfc", .function = "falcon_probe_nvconfig", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c", .format = "PHY is %d phy_id %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2206U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 2205 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 2205 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"PHY is %d phy_id %d\n",efx->phy_type,efx->mdio.prtad); else ;
  }
  else ;
  
#line 2208 
  rc = falcon_probe_board(efx,(unsigned short)((int)nvconfig->board_v2.board_revision));
  out: 
#line 2210 
  ;
  
#line 2211 
  kfree((void const *)nvconfig);
  
#line 2212 
  __retres = rc;
  return_label: 
#line 2212 
                return __retres;
}


#line 2215  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_dimension_resources(struct efx_nic *efx)
{
  int __retres;
  
#line 2217 
  efx->rx_dc_base = 131072U;
  
#line 2218 
  efx->tx_dc_base = 155648U;
  
#line 2219 
  __retres = 0;
  
#line 2219 
  return __retres;
}


#line 2223  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static void falcon_probe_spi_devices(struct efx_nic *efx)
{
  efx_oword_t nic_stat;
  efx_oword_t gpio_ctl;
  efx_oword_t ee_vpd_cfg;
  int boot_dev;
  
#line 2225 
  struct falcon_nic_data *nic_data = (struct falcon_nic_data *)efx->nic_data;
  
#line 2229 
  efx_reado_2(efx,& gpio_ctl,528U);
  
#line 2230 
  efx_reado_2(efx,& nic_stat,512U);
  
#line 2231 
  efx_reado_2(efx,& ee_vpd_cfg,320U);
  
#line 2233 
  if ((gpio_ctl.u64[0] & 8ULL) != 0ULL) {
    
#line 2234 
    boot_dev = (int)(nic_stat.u64[0] >> 9) & 1;
    
#line 2236 
    if ((efx->msg_enable & 2U) != 0U) {
      
#line 2236 
      struct _ddebug descriptor = {.modname = "sfc", .function = "falcon_probe_spi_devices", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c", .format = "Booted from %s\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2238U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 2236 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
        char *tmp;
        
#line 2236 
        if (boot_dev == 1) 
#line 2236 
                           tmp = (char *)"flash"; else 
#line 2236 
                                                       tmp = (char *)"EEPROM";
        
#line 2236 
        ;
        
#line 2236 
        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"Booted from %s\n",tmp);
      }
      else ;
    }
    else ;
  }
  else {
    
#line 2242 
    boot_dev = -1;
    
#line 2243 
    if ((efx->msg_enable & 2U) != 0U) {
      
#line 2243 
      struct _ddebug descriptor_0 = {.modname = "sfc", .function = "falcon_probe_spi_devices", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c", .format = "Booted from internal ASIC settings;", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2245U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 2243 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 2243 
                                                            __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)efx->net_dev,"Booted from internal ASIC settings;"); else ;
    }
    else ;
    
#line 2246 
    ee_vpd_cfg.u64[0] = 0ULL;
    
#line 2246 
    ee_vpd_cfg.u64[1] = 522136081798266880ULL;
    
#line 2251 
    efx_writeo_2(efx,(efx_oword_t const *)(& ee_vpd_cfg),320U);
  }
  {
    struct lock_class_key __key;
    
#line 2254 
    __mutex_init(& nic_data->spi_lock,"&nic_data->spi_lock",& __key);
  }
  
#line 2256 
  if (boot_dev == 1) 
#line 2257 
                     falcon_spi_device_init(efx,& nic_data->spi_flash,1U,default_flash_type); else ;
  
#line 2260 
  if (boot_dev == 0) 
#line 2261 
                     falcon_spi_device_init(efx,& nic_data->spi_eeprom,0U,large_eeprom_type); else ;
  
#line 2262 
  return;
}


#line 2266  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static unsigned int falcon_a1_mem_map_size(struct efx_nic *efx)
{
  unsigned int __retres;
  
#line 2268 
  __retres = 131072U;
  
#line 2268 
  return __retres;
}


#line 2271  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static unsigned int falcon_b0_mem_map_size(struct efx_nic *efx)
{
  unsigned int __retres;
  
#line 2276 
  __retres = 16451584U;
  
#line 2276 
  return __retres;
}


#line 2280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_probe_nic(struct efx_nic *efx)
{
  int __retres;
  struct falcon_nic_data *nic_data;
  struct falcon_board *board;
  int rc;
  u32 tmp_0;
  int tmp_1;
  int tmp_3;
  struct falcon_board *tmp_4;
  
#line 2286 
  efx->primary = efx;
  
#line 2289 
  nic_data = (struct falcon_nic_data *)kzalloc_7(2944UL,208U);
  
#line 2290 
  if (nic_data == (struct falcon_nic_data *)0) {
    
#line 2291 
    __retres = -12;
    
#line 2291 
    goto return_label;
  }
  else ;
  
#line 2292 
  efx->nic_data = (void *)nic_data;
  
#line 2294 
  rc = -19;
  
#line 2296 
  tmp_0 = efx_farch_fpga_ver(efx);
  
#line 2296 
  if (tmp_0 != 0U) {
    
#line 2297 
    if ((efx->msg_enable & 2U) != 0U) 
#line 2297 
                                      netdev_err((struct net_device const *)efx->net_dev,"Falcon FPGA not supported\n"); else ;
    
#line 2299 
    goto fail1;
  }
  else ;
  
#line 2302 
  tmp_1 = efx_nic_rev(efx);
  
#line 2302 
  if (tmp_1 <= 1) {
    efx_oword_t nic_stat;
    struct pci_dev *dev;
    
#line 2305 
    u8 pci_rev = (efx->pci_dev)->revision;
    
#line 2307 
    if ((unsigned int)pci_rev + 255U > 253U) {
      
#line 2308 
      if ((efx->msg_enable & 2U) != 0U) 
#line 2308 
                                        netdev_err((struct net_device const *)efx->net_dev,"Falcon rev A0 not supported\n"); else ;
      
#line 2310 
      goto fail1;
    }
    else ;
    
#line 2312 
    efx_reado_2(efx,& nic_stat,512U);
    
#line 2313 
    if ((nic_stat.u64[0] & 4ULL) == 0ULL) {
      
#line 2314 
      if ((efx->msg_enable & 2U) != 0U) 
#line 2314 
                                        netdev_err((struct net_device const *)efx->net_dev,"Falcon rev A1 1G not supported\n"); else ;
      
#line 2316 
      goto fail1;
    }
    else ;
    
#line 2318 
    if ((nic_stat.u64[0] & 1ULL) == 0ULL) {
      
#line 2319 
      if ((efx->msg_enable & 2U) != 0U) 
#line 2319 
                                        netdev_err((struct net_device const *)efx->net_dev,"Falcon rev A1 PCI-X not supported\n"); else ;
      
#line 2321 
      goto fail1;
    }
    else ;
    
#line 2324 
    dev = pci_dev_get(efx->pci_dev);
    
#line 2325 
    goto ldv_57551;
    ldv_57550: 
#line 2326 
    ;
    
#line 2328 
    if (dev->bus == (efx->pci_dev)->bus && dev->devfn == (efx->pci_dev)->devfn + 1U) {
      
#line 2330 
      nic_data->pci_dev2 = dev;
      
#line 2331 
      goto ldv_57549;
    }
    else ;
    ldv_57551: 
#line 2333 
    ;
    
#line 2325 
    dev = pci_get_device(6436U,26371U,dev);
    
#line 2325 
    if (dev != (struct pci_dev *)0) 
#line 2327 
                                    goto ldv_57550; else 
#line 2330 
                                                         goto ldv_57549;
    ldv_57549: 
#line 2331 
    ;
    
#line 2334 
    if (nic_data->pci_dev2 == (struct pci_dev *)0) {
      
#line 2335 
      if ((efx->msg_enable & 2U) != 0U) 
#line 2335 
                                        netdev_err((struct net_device const *)efx->net_dev,"failed to find secondary function\n"); else ;
      
#line 2337 
      rc = -19;
      
#line 2338 
      goto fail2;
    }
    else ;
  }
  else ;
  
#line 2343 
  rc = __falcon_reset_hw(efx,(enum reset_type)RESET_TYPE_ALL);
  
#line 2344 
  if (rc != 0) {
    
#line 2345 
    if ((efx->msg_enable & 2U) != 0U) 
#line 2345 
                                      netdev_err((struct net_device const *)efx->net_dev,"failed to reset NIC\n"); else ;
    
#line 2346 
    goto fail3;
  }
  else ;
  
#line 2350 
  rc = efx_nic_alloc_buffer(efx,& efx->irq_status,16U,208U);
  
#line 2352 
  if (rc != 0) 
#line 2353 
               goto fail4; else ;
  
#line 2354 
  if ((long)((efx->irq_status.dma_addr & 15ULL) != 0ULL) != 0L) {
    
#line 2356 
    ldv_inline_asm();
    
#line 2354 
    ;
  }
  else ;
  
#line 2356 
  if ((efx->msg_enable & 2U) != 0U) {
    
#line 2356 
    struct _ddebug descriptor = {.modname = "sfc", .function = "falcon_probe_nic", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c", .format = "INT_KER at %llx (virt %p phys %llx)\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2360U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 2356 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      phys_addr_t tmp_2;
      
#line 2356 
      tmp_2 = virt_to_phys((void volatile *)efx->irq_status.addr);
      
#line 2356 
      ;
      
#line 2356 
      ;
      
#line 2356 
      ;
      
#line 2356 
      __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"INT_KER at %llx (virt %p phys %llx)\n",efx->irq_status.dma_addr,efx->irq_status.addr,tmp_2);
    }
    else ;
  }
  else ;
  
#line 2362 
  falcon_probe_spi_devices(efx);
  
#line 2365 
  rc = falcon_probe_nvconfig(efx);
  
#line 2366 
  if (rc != 0) {
    
#line 2367 
    if (rc == -22) {
      
#line 2368 
      if ((efx->msg_enable & 2U) != 0U) 
#line 2368 
                                        netdev_err((struct net_device const *)efx->net_dev,"NVRAM is invalid\n"); else ;
    }
    else ;
    
#line 2369 
    goto fail5;
  }
  else ;
  
#line 2372 
  tmp_3 = efx_nic_rev(efx);
  
#line 2372 
  if (tmp_3 <= 1) 
#line 2372 
                  efx->max_channels = 4U; else 
#line 2372 
                                               efx->max_channels = 32U;
  
#line 2374 
  efx->timer_quantum_ns = 4968U;
  
#line 2377 
  board = falcon_board(efx);
  
#line 2378 
  board->i2c_adap.owner = & __this_module;
  
#line 2379 
  board->i2c_data = falcon_i2c_bit_operations;
  
#line 2380 
  board->i2c_data.data = (void *)efx;
  
#line 2381 
  board->i2c_adap.algo_data = (void *)(& board->i2c_data);
  
#line 2382 
  board->i2c_adap.dev.parent = & (efx->pci_dev)->dev;
  
#line 2383 
  strlcpy((char *)(& board->i2c_adap.name),"SFC4000 GPIO",48UL);
  
#line 2385 
  rc = i2c_bit_add_bus(& board->i2c_adap);
  
#line 2386 
  if (rc != 0) 
#line 2387 
               goto fail5; else ;
  
#line 2389 
  tmp_4 = falcon_board(efx);
  
#line 2389 
  rc = (*((tmp_4->type)->init))(efx);
  
#line 2390 
  if (rc != 0) {
    
#line 2391 
    if ((efx->msg_enable & 2U) != 0U) 
#line 2391 
                                      netdev_err((struct net_device const *)efx->net_dev,"failed to initialise board\n"); else ;
    
#line 2393 
    goto fail6;
  }
  else ;
  
#line 2396 
  nic_data->stats_disable_count = 1U;
  {
    struct lock_class_key __key;
    
#line 2397 
    init_timer_key(& nic_data->stats_timer,0U,"((&nic_data->stats_timer))",& __key);
  }
  
#line 2397 
  nic_data->stats_timer.function = & falcon_stats_timer_func;
  
#line 2397 
  nic_data->stats_timer.data = (unsigned long)efx;
  
#line 2400 
  __retres = 0;
  
#line 2400 
  goto return_label;
  fail6: 
#line 2402 
  ;
  
#line 2403 
  i2c_del_adapter(& board->i2c_adap);
  
#line 2404 
  memset((void *)(& board->i2c_adap),0,1936UL);
  fail5: 
#line 2405 
  ;
  
#line 2406 
  efx_nic_free_buffer(efx,& efx->irq_status);
  fail4: 
#line 2407 
  ;
  fail3: 
#line 2408 
  ;
  
#line 2409 
  if (nic_data->pci_dev2 != (struct pci_dev *)0) {
    
#line 2410 
    pci_dev_put(nic_data->pci_dev2);
    
#line 2411 
    nic_data->pci_dev2 = (struct pci_dev *)0;
  }
  else ;
  fail2: 
#line 2413 
  ;
  fail1: 
#line 2414 
  ;
  
#line 2415 
  kfree((void const *)efx->nic_data);
  
#line 2416 
  __retres = rc;
  return_label: 
#line 2416 
                return __retres;
}


#line 2419  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static void falcon_init_rx_cfg(struct efx_nic *efx)
{
  efx_oword_t reg;
  int tmp;
  
#line 2422 
  unsigned int const ctrl_xon_thr = 20U;
  
#line 2423 
  unsigned int const ctrl_xoff_thr = 25U;
  
#line 2426 
  efx_reado_2(efx,& reg,2048U);
  
#line 2427 
  tmp = efx_nic_rev(efx);
  
#line 2427 
  if (tmp <= 1) {
    
#line 2434 
    reg.u64[0] &= 18446744039349813247ULL;
    
#line 2434 
    reg.u64[1] = reg.u64[1];
    
#line 2435 
    reg.u64[0] = (reg.u64[0] & 18446744073708505087ULL) | 786432ULL;
    
#line 2435 
    reg.u64[1] = reg.u64[1];
    
#line 2437 
    reg.u64[0] = (reg.u64[0] & 18446744073709549631ULL) | 128ULL;
    
#line 2437 
    reg.u64[1] = reg.u64[1];
    
#line 2438 
    reg.u64[0] = (reg.u64[0] & 18446744073709551553ULL) | 16ULL;
    
#line 2438 
    reg.u64[1] = reg.u64[1];
    
#line 2439 
    reg.u64[0] = (reg.u64[0] & 18446744072669364223ULL) | 671088640ULL;
    
#line 2439 
    reg.u64[1] = reg.u64[1];
    
#line 2440 
    reg.u64[0] = (reg.u64[0] & 18446744073677045759ULL) | 26214400ULL;
    
#line 2440 
    reg.u64[1] = reg.u64[1];
  }
  else {
    
#line 2443 
    reg.u64[0] &= 18446735277616529407ULL;
    
#line 2443 
    reg.u64[1] = reg.u64[1];
    
#line 2444 
    reg.u64[0] = (reg.u64[0] & 18446744073441640447ULL) | 29360128ULL;
    
#line 2444 
    reg.u64[1] = reg.u64[1];
    
#line 2447 
    reg.u64[0] = (reg.u64[0] & 18446744073709028351ULL) | 110592ULL;
    
#line 2447 
    reg.u64[1] = reg.u64[1];
    
#line 2448 
    reg.u64[0] = (reg.u64[0] & 18446744073709550593ULL) | 424ULL;
    
#line 2448 
    reg.u64[1] = reg.u64[1];
    
#line 2449 
    reg.u64[0] = (reg.u64[0] & 18446743807421579263ULL) | 171798691840ULL;
    
#line 2449 
    reg.u64[1] = reg.u64[1];
    
#line 2450 
    reg.u64[0] = (reg.u64[0] & 18446744065388052479ULL) | 6710886400ULL;
    
#line 2450 
    reg.u64[1] = reg.u64[1];
    
#line 2451 
    reg.u64[0] |= 140737488355328ULL;
    
#line 2451 
    reg.u64[1] = reg.u64[1];
    
#line 2456 
    reg.u64[0] |= 17592186044416ULL;
    
#line 2456 
    reg.u64[1] = reg.u64[1];
    
#line 2457 
    reg.u64[0] |= 35184372088832ULL;
    
#line 2457 
    reg.u64[1] = reg.u64[1];
    
#line 2458 
    reg.u64[0] |= 70368744177664ULL;
    
#line 2458 
    reg.u64[1] = reg.u64[1];
  }
  
#line 2462 
  reg.u64[0] |= 1ULL;
  
#line 2462 
  reg.u64[1] = reg.u64[1];
  
#line 2463 
  efx_writeo_2(efx,(efx_oword_t const *)(& reg),2048U);
  
#line 2464 
  return;
}


#line 2470  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_init_nic(struct efx_nic *efx)
{
  int __retres;
  efx_oword_t temp;
  int rc;
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  
#line 2476 
  efx_reado_2(efx,& temp,512U);
  
#line 2477 
  temp.u64[0] |= 65536ULL;
  
#line 2477 
  temp.u64[1] = temp.u64[1];
  
#line 2478 
  efx_writeo_2(efx,(efx_oword_t const *)(& temp),512U);
  
#line 2480 
  rc = falcon_reset_sram(efx);
  
#line 2481 
  if (rc != 0) {
    
#line 2482 
    __retres = rc;
    
#line 2482 
    goto return_label;
  }
  else ;
  
#line 2487 
  tmp = efx_nic_rev(efx);
  
#line 2487 
  if (tmp <= 1) {
    
#line 2488 
    efx_reado_2(efx,& temp,784U);
    
#line 2489 
    temp.u64[0] = temp.u64[0];
    
#line 2489 
    temp.u64[1] &= 18446744073709550847ULL;
    
#line 2490 
    efx_writeo_2(efx,(efx_oword_t const *)(& temp),784U);
  }
  else ;
  
#line 2493 
  tmp_0 = efx_nic_rev(efx);
  
#line 2493 
  if (tmp_0 <= 1) {
    
#line 2494 
    efx_reado_2(efx,& temp,2064U);
    
#line 2495 
    temp.u64[0] = (temp.u64[0] & 18446742978492891135ULL) | 34359738368ULL;
    
#line 2495 
    temp.u64[1] = temp.u64[1];
    
#line 2496 
    temp.u64[0] = (temp.u64[0] & 18446744073692839935ULL) | 524288ULL;
    
#line 2496 
    temp.u64[1] = temp.u64[1];
    
#line 2497 
    temp.u64[0] = (temp.u64[0] & 18446744073709551360ULL) | 8ULL;
    
#line 2497 
    temp.u64[1] = temp.u64[1];
    
#line 2498 
    temp.u64[0] = (temp.u64[0] & 18446744073709486335ULL) | 2048ULL;
    
#line 2498 
    temp.u64[1] = temp.u64[1];
    
#line 2499 
    efx_writeo_2(efx,(efx_oword_t const *)(& temp),2064U);
  }
  else ;
  
#line 2506 
  efx_reado_2(efx,& temp,2192U);
  
#line 2507 
  temp.u64[0] |= 512ULL;
  
#line 2507 
  temp.u64[1] = temp.u64[1];
  
#line 2508 
  temp.u64[0] |= 256ULL;
  
#line 2508 
  temp.u64[1] = temp.u64[1];
  
#line 2509 
  tmp_1 = efx_nic_rev(efx);
  
#line 2509 
  if (tmp_1 <= 1) {
    
#line 2510 
    temp.u64[0] |= 131072ULL;
    
#line 2510 
    temp.u64[1] = temp.u64[1];
  }
  else ;
  
#line 2511 
  efx_writeo_2(efx,(efx_oword_t const *)(& temp),2192U);
  
#line 2516 
  efx_reado_2(efx,& temp,2640U);
  
#line 2517 
  temp.u64[0] &= 18446744073709551583ULL;
  
#line 2517 
  temp.u64[1] = temp.u64[1];
  
#line 2518 
  efx_writeo_2(efx,(efx_oword_t const *)(& temp),2640U);
  
#line 2520 
  falcon_init_rx_cfg(efx);
  
#line 2522 
  tmp_2 = efx_nic_rev(efx);
  
#line 2522 
  if (tmp_2 > 1) {
    
#line 2523 
    falcon_b0_rx_push_rss_config(efx,(_Bool)0,(u32 const *)(& efx->rx_indir_table));
    
#line 2526 
    temp.u64[0] = 0ULL;
    
#line 2526 
    temp.u64[1] = 0ULL;
    
#line 2527 
    efx_writeo_2(efx,(efx_oword_t const *)(& temp),592U);
  }
  else ;
  
#line 2530 
  efx_farch_init_common(efx);
  
#line 2532 
  __retres = 0;
  return_label: 
#line 2532 
                return __retres;
}


#line 2535  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static void falcon_remove_nic(struct efx_nic *efx)
{
  
#line 2537 
  struct falcon_nic_data *nic_data = (struct falcon_nic_data *)efx->nic_data;
  
#line 2538 
  struct falcon_board *board = falcon_board(efx);
  
#line 2540 
  (*((board->type)->fini))(efx);
  
#line 2543 
  i2c_del_adapter(& board->i2c_adap);
  
#line 2544 
  memset((void *)(& board->i2c_adap),0,1936UL);
  
#line 2546 
  efx_nic_free_buffer(efx,& efx->irq_status);
  
#line 2548 
  __falcon_reset_hw(efx,(enum reset_type)RESET_TYPE_ALL);
  
#line 2551 
  if (nic_data->pci_dev2 != (struct pci_dev *)0) {
    
#line 2552 
    pci_dev_put(nic_data->pci_dev2);
    
#line 2553 
    nic_data->pci_dev2 = (struct pci_dev *)0;
  }
  else ;
  
#line 2557 
  kfree((void const *)efx->nic_data);
  
#line 2558 
  efx->nic_data = (void *)0;
  
#line 2559 
  return;
}


#line 2561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static size_t falcon_describe_nic_stats(struct efx_nic *efx, u8 *names)
{
  size_t tmp;
  
#line 2563 
  tmp = efx_nic_describe_stats((struct efx_hw_stat_desc const *)(& falcon_stat_desc),49UL,(unsigned long const *)(& falcon_stat_mask),names);
  
#line 2563 
  return tmp;
}


#line 2567  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static size_t falcon_update_nic_stats(struct efx_nic *efx, u64 *full_stats, struct rtnl_link_stats64 *core_stats)
{
  size_t __retres;
  efx_oword_t cnt;
  
#line 2570 
  struct falcon_nic_data *nic_data = (struct falcon_nic_data *)efx->nic_data;
  
#line 2571 
  u64 *stats = (u64 *)(& nic_data->stats);
  
#line 2574 
  if (nic_data->stats_disable_count == 0U) {
    
#line 2575 
    efx_reado_2(efx,& cnt,2176U);
    
#line 2576 
    *(stats + 48U) += cnt.u64[0] & 65535ULL;
    
#line 2579 
    if ((int)nic_data->stats_pending != 0 && *((u32 *)(efx->stats_buffer.addr + 212U)) != 0U) {
      
#line 2581 
      nic_data->stats_pending = (_Bool)0;
      
#line 2582 
      ldv_inline_asm();
      
#line 2583 
      efx_nic_update_stats((struct efx_hw_stat_desc const *)(& falcon_stat_desc),49UL,(unsigned long const *)(& falcon_stat_mask),stats,(void const *)efx->stats_buffer.addr,(_Bool)1);
    }
    else ;
    
#line 2590 
    efx_update_diff_stat(stats + 23U,(*(stats + 21U) - *(stats + 22U)) - *(stats + 28U) * 64ULL);
    
#line 2594 
    efx_update_sw_stats(efx,stats);
  }
  else ;
  
#line 2597 
  if (full_stats != (u64 *)0ULL) 
#line 2598 
                                 memcpy((void *)full_stats,(void const *)stats,392UL); else ;
  
#line 2600 
  if (core_stats != (struct rtnl_link_stats64 *)0) {
    
#line 2601 
    core_stats->rx_packets = *(stats + 24U);
    
#line 2602 
    core_stats->tx_packets = *(stats + 3U);
    
#line 2603 
    core_stats->rx_bytes = *(stats + 21U);
    
#line 2604 
    core_stats->tx_bytes = *(stats + 2U);
    
#line 2605 
    core_stats->rx_dropped = (*(stats + 48U) + *(stats + 1U)) + *stats;
    
#line 2608 
    core_stats->multicast = *(stats + 30U);
    
#line 2609 
    core_stats->rx_length_errors = *(stats + 40U) + *(stats + 46U);
    
#line 2612 
    core_stats->rx_crc_errors = *(stats + 26U);
    
#line 2613 
    core_stats->rx_frame_errors = *(stats + 45U);
    
#line 2614 
    core_stats->rx_fifo_errors = *(stats + 43U);
    
#line 2616 
    core_stats->rx_errors = ((core_stats->rx_length_errors + core_stats->rx_crc_errors) + core_stats->rx_frame_errors) + *(stats + 44U);
  }
  else ;
  
#line 2622 
  __retres = 49UL;
  
#line 2622 
  return __retres;
}


#line 2625  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
void falcon_start_nic_stats(struct efx_nic *efx)
{
  
#line 2627 
  struct falcon_nic_data *nic_data = (struct falcon_nic_data *)efx->nic_data;
  
#line 2629 
  ldv_spin_lock_bh_121(& efx->stats_lock);
  
#line 2630 
  nic_data->stats_disable_count -= 1U;
  
#line 2630 
  if (nic_data->stats_disable_count == 0U) 
#line 2631 
                                           falcon_stats_request(efx); else ;
  
#line 2632 
  ldv_spin_unlock_bh_122(& efx->stats_lock);
  
#line 2633 
  return;
}


#line 2638  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static void falcon_pull_nic_stats(struct efx_nic *efx)
{
  
#line 2640 
  msleep(10U);
  
#line 2641 
  return;
}


#line 2643  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
void falcon_stop_nic_stats(struct efx_nic *efx)
{
  int i;
  
#line 2645 
  struct falcon_nic_data *nic_data = (struct falcon_nic_data *)efx->nic_data;
  
#line 2648 
  __might_sleep("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c",2648,0);
  
#line 2650 
  ldv_spin_lock_bh_123(& efx->stats_lock);
  
#line 2651 
  nic_data->stats_disable_count += 1U;
  
#line 2652 
  ldv_spin_unlock_bh_124(& efx->stats_lock);
  
#line 2654 
  ldv_del_timer_sync_125(& nic_data->stats_timer);
  
#line 2658 
  i = 0;
  
#line 2658 
  goto ldv_57602;
  ldv_57601: 
#line 2659 
  ;
  
#line 2659 
  if (*((u32 *)(efx->stats_buffer.addr + 212U)) != 0U) 
#line 2660 
                                                       goto ldv_57600; else ;
  
#line 2661 
  msleep(1U);
  
#line 2658 
  i += 1;
  ldv_57602: 
#line 2659 
  ;
  
#line 2658 
  if (i <= 3 && (int)nic_data->stats_pending != 0) 
#line 2660 
                                                   goto ldv_57601; else 
                                                                    
#line 2663 
                                                                    goto ldv_57600;
  ldv_57600: 
#line 2664 
  ;
  
#line 2664 
  ldv_spin_lock_bh_126_0(& efx->stats_lock);
  
#line 2665 
  falcon_stats_complete(efx);
  
#line 2666 
  ldv_spin_unlock_bh_127_0(& efx->stats_lock);
  
#line 2667 
  return;
}


#line 2669  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static void falcon_set_id_led(struct efx_nic *efx, enum efx_led_mode mode)
{
  struct falcon_board *tmp;
  
#line 2671 
  tmp = falcon_board(efx);
  
#line 2671 
  (*((tmp->type)->set_id_led))(efx,mode);
  
#line 2672 
  return;
}


#line 2681  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static void falcon_get_wol(struct efx_nic *efx, struct ethtool_wolinfo *wol)
{
  
#line 2683 
  wol->supported = 0U;
  
#line 2684 
  wol->wolopts = 0U;
  
#line 2685 
  memset((void *)(& wol->sopass),0,6UL);
  
#line 2686 
  return;
}


#line 2688  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
static int falcon_set_wol(struct efx_nic *efx, u32 type)
{
  int __retres;
  
#line 2690 
  if (type != 0U) {
    
#line 2691 
    __retres = -22;
    
#line 2691 
    goto return_label;
  }
  else ;
  
#line 2692 
  __retres = 0;
  return_label: 
#line 2692 
                return __retres;
}


#line 2702  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
struct efx_nic_type const falcon_a1_nic_type = {.is_vf = (_Bool)0, .mem_bar = 2U, .mem_map_size = & falcon_a1_mem_map_size, .probe = & falcon_probe_nic, .remove = & falcon_remove_nic, .init = & falcon_init_nic, .dimension_resources = & falcon_dimension_resources, .fini = & falcon_irq_ack_a1, .monitor = & falcon_monitor, .map_reset_reason = & falcon_map_reset_reason, .map_reset_flags = & falcon_map_reset_flags, .reset = & falcon_reset_hw, .probe_port = & falcon_probe_port, .remove_port = & falcon_remove_port, .handle_global_event = & falcon_handle_global_event, .fini_dmaq = & efx_farch_fini_dmaq, .prepare_flush = & falcon_prepare_flush, .finish_flush = & efx_port_dummy_op_void, .prepare_flr = & efx_port_dummy_op_void, .finish_flr = & efx_farch_finish_flr, .describe_stats = & falcon_describe_nic_stats, .update_stats = & falcon_update_nic_stats, .start_stats = & falcon_start_nic_stats, .pull_stats = & falcon_pull_nic_stats, .stop_stats = & falcon_stop_nic_stats, .set_id_led = & falcon_set_id_led, .push_irq_moderation = & falcon_push_irq_moderation, .reconfigure_port = & falcon_reconfigure_port, .prepare_enable_fc_tx = & falcon_a1_prepare_enable_fc_tx, .reconfigure_mac = & falcon_reconfigure_xmac, .check_mac_fault = & falcon_xmac_check_fault, .get_wol = & falcon_get_wol, .set_wol = & falcon_set_wol, .resume_wol = & efx_port_dummy_op_void, .test_chip = (int (*)(struct efx_nic *, struct efx_self_tests *))0, .test_nvram = & falcon_test_nvram, .mcdi_request = (void (*)(struct efx_nic *, efx_dword_t const *, size_t , efx_dword_t const *, size_t ))0, .mcdi_poll_response = (bool (*)(struct efx_nic *))0, .mcdi_read_response = (void (*)(struct efx_nic *, efx_dword_t *, size_t , size_t ))0, .mcdi_poll_reboot = (int (*)(struct efx_nic *))0, .irq_enable_master = & efx_farch_irq_enable_master, .irq_test_generate = & efx_farch_irq_test_generate, .irq_disable_non_ev = & efx_farch_irq_disable_master, .irq_handle_msi = & efx_farch_msi_interrupt, .irq_handle_legacy = & falcon_legacy_interrupt_a1, .tx_probe = & efx_farch_tx_probe, .tx_init = & efx_farch_tx_init, .tx_remove = & efx_farch_tx_remove, .tx_write = & efx_farch_tx_write, .rx_push_rss_config = & dummy_rx_push_rss_config, .rx_probe = & efx_farch_rx_probe, .rx_init = & efx_farch_rx_init, .rx_remove = & efx_farch_rx_remove, .rx_write = & efx_farch_rx_write, .rx_defer_refill = & efx_farch_rx_defer_refill, .ev_probe = & efx_farch_ev_probe, .ev_init = & efx_farch_ev_init, .ev_fini = & efx_farch_ev_fini, .ev_remove = & efx_farch_ev_remove, .ev_process = & efx_farch_ev_process, .ev_read_ack = & efx_farch_ev_read_ack, .ev_test_generate = & efx_farch_ev_test_generate, .filter_table_probe = & efx_farch_filter_table_probe, .filter_table_restore = & efx_farch_filter_table_restore, .filter_table_remove = & efx_farch_filter_table_remove, .filter_update_rx_scatter = (void (*)(struct efx_nic *))0, .filter_insert = & efx_farch_filter_insert, .filter_remove_safe = & efx_farch_filter_remove_safe, .filter_get_safe = & efx_farch_filter_get_safe, .filter_clear_rx = & efx_farch_filter_clear_rx, .filter_count_rx_used = & efx_farch_filter_count_rx_used, .filter_get_rx_id_limit = & efx_farch_filter_get_rx_id_limit, .filter_get_rx_ids = & efx_farch_filter_get_rx_ids, .filter_rfs_insert = (s32 (*)(struct efx_nic *, struct efx_filter_spec *))0, .filter_rfs_expire_one = (bool (*)(struct efx_nic *, u32 , unsigned int ))0, .mtd_probe = & falcon_mtd_probe, .mtd_rename = & falcon_mtd_rename, .mtd_read = & falcon_mtd_read, .mtd_erase = & falcon_mtd_erase, .mtd_write = & falcon_mtd_write, .mtd_sync = & falcon_mtd_sync, .ptp_write_host_time = (void (*)(struct efx_nic *, u32 ))0, .ptp_set_ts_sync_events = (int (*)(struct efx_nic *, bool , bool ))0, .ptp_set_ts_config = (int (*)(struct efx_nic *, struct hwtstamp_config *))0, .sriov_configure = (int (*)(struct efx_nic *, int ))0, .sriov_init = (int (*)(struct efx_nic *))0, .sriov_fini = (void (*)(struct efx_nic *))0, .sriov_wanted = (bool (*)(struct efx_nic *))0, .sriov_reset = (void (*)(struct efx_nic *))0, .sriov_flr = (void (*)(struct efx_nic *, unsigned int ))0, .sriov_set_vf_mac = (int (*)(struct efx_nic *, int , u8 *))0, .sriov_set_vf_vlan = (int (*)(struct efx_nic *, int , u16 , u8 ))0, .sriov_set_vf_spoofchk = (int (*)(struct efx_nic *, int , bool ))0, .sriov_get_vf_config = (int (*)(struct efx_nic *, int , struct ifla_vf_info *))0, .sriov_set_vf_link_state = (int (*)(struct efx_nic *, int , int ))0, .sriov_get_phys_port_id = (int (*)(struct efx_nic *, struct netdev_phys_item_id *))0, .vswitching_probe = (int (*)(struct efx_nic *))0, .vswitching_restore = (int (*)(struct efx_nic *))0, .vswitching_remove = (void (*)(struct efx_nic *))0, .get_mac_address = (int (*)(struct efx_nic *, unsigned char *))0, .set_mac_address = (int (*)(struct efx_nic *))0, .revision = 1, .txd_ptr_tbl_base = 71936U, .rxd_ptr_tbl_base = 71680U, .buf_tbl_base = 98304U, .evq_ptr_tbl_base = 72192U, .evq_rptr_tbl_base = 72448U, .max_dma_mask = 70368744177663ULL, .rx_prefix_size = 0U, .rx_hash_offset = 0U, .rx_ts_offset = 0U, .rx_buffer_padding = 36U, .can_rx_scatter = (_Bool)0, .always_rx_scatter = (_Bool)0, .max_interrupt_mode = 1U, .timer_period_max = 4096U, .offload_features = 2ULL, .mcdi_max_ver = -1, .max_rx_ip_filters = 0U, .hwtstamp_filters = 0U};

#line 2800  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/falcon.c"
struct efx_nic_type const falcon_b0_nic_type = {.is_vf = (_Bool)0, .mem_bar = 2U, .mem_map_size = & falcon_b0_mem_map_size, .probe = & falcon_probe_nic, .remove = & falcon_remove_nic, .init = & falcon_init_nic, .dimension_resources = & falcon_dimension_resources, .fini = & efx_port_dummy_op_void, .monitor = & falcon_monitor, .map_reset_reason = & falcon_map_reset_reason, .map_reset_flags = & falcon_map_reset_flags, .reset = & falcon_reset_hw, .probe_port = & falcon_probe_port, .remove_port = & falcon_remove_port, .handle_global_event = & falcon_handle_global_event, .fini_dmaq = & efx_farch_fini_dmaq, .prepare_flush = & falcon_prepare_flush, .finish_flush = & efx_port_dummy_op_void, .prepare_flr = & efx_port_dummy_op_void, .finish_flr = & efx_farch_finish_flr, .describe_stats = & falcon_describe_nic_stats, .update_stats = & falcon_update_nic_stats, .start_stats = & falcon_start_nic_stats, .pull_stats = & falcon_pull_nic_stats, .stop_stats = & falcon_stop_nic_stats, .set_id_led = & falcon_set_id_led, .push_irq_moderation = & falcon_push_irq_moderation, .reconfigure_port = & falcon_reconfigure_port, .prepare_enable_fc_tx = & falcon_b0_prepare_enable_fc_tx, .reconfigure_mac = & falcon_reconfigure_xmac, .check_mac_fault = & falcon_xmac_check_fault, .get_wol = & falcon_get_wol, .set_wol = & falcon_set_wol, .resume_wol = & efx_port_dummy_op_void, .test_chip = & falcon_b0_test_chip, .test_nvram = & falcon_test_nvram, .mcdi_request = (void (*)(struct efx_nic *, efx_dword_t const *, size_t , efx_dword_t const *, size_t ))0, .mcdi_poll_response = (bool (*)(struct efx_nic *))0, .mcdi_read_response = (void (*)(struct efx_nic *, efx_dword_t *, size_t , size_t ))0, .mcdi_poll_reboot = (int (*)(struct efx_nic *))0, .irq_enable_master = & efx_farch_irq_enable_master, .irq_test_generate = & efx_farch_irq_test_generate, .irq_disable_non_ev = & efx_farch_irq_disable_master, .irq_handle_msi = & efx_farch_msi_interrupt, .irq_handle_legacy = & efx_farch_legacy_interrupt, .tx_probe = & efx_farch_tx_probe, .tx_init = & efx_farch_tx_init, .tx_remove = & efx_farch_tx_remove, .tx_write = & efx_farch_tx_write, .rx_push_rss_config = & falcon_b0_rx_push_rss_config, .rx_probe = & efx_farch_rx_probe, .rx_init = & efx_farch_rx_init, .rx_remove = & efx_farch_rx_remove, .rx_write = & efx_farch_rx_write, .rx_defer_refill = & efx_farch_rx_defer_refill, .ev_probe = & efx_farch_ev_probe, .ev_init = & efx_farch_ev_init, .ev_fini = & efx_farch_ev_fini, .ev_remove = & efx_farch_ev_remove, .ev_process = & efx_farch_ev_process, .ev_read_ack = & efx_farch_ev_read_ack, .ev_test_generate = & efx_farch_ev_test_generate, .filter_table_probe = & efx_farch_filter_table_probe, .filter_table_restore = & efx_farch_filter_table_restore, .filter_table_remove = & efx_farch_filter_table_remove, .filter_update_rx_scatter = & efx_farch_filter_update_rx_scatter, .filter_insert = & efx_farch_filter_insert, .filter_remove_safe = & efx_farch_filter_remove_safe, .filter_get_safe = & efx_farch_filter_get_safe, .filter_clear_rx = & efx_farch_filter_clear_rx, .filter_count_rx_used = & efx_farch_filter_count_rx_used, .filter_get_rx_id_limit = & efx_farch_filter_get_rx_id_limit, .filter_get_rx_ids = & efx_farch_filter_get_rx_ids, .filter_rfs_insert = & efx_farch_filter_rfs_insert, .filter_rfs_expire_one = & efx_farch_filter_rfs_expire_one, .mtd_probe = & falcon_mtd_probe, .mtd_rename = & falcon_mtd_rename, .mtd_read = & falcon_mtd_read, .mtd_erase = & falcon_mtd_erase, .mtd_write = & falcon_mtd_write, .mtd_sync = & falcon_mtd_sync, .ptp_write_host_time = (void (*)(struct efx_nic *, u32 ))0, .ptp_set_ts_sync_events = (int (*)(struct efx_nic *, bool , bool ))0, .ptp_set_ts_config = (int (*)(struct efx_nic *, struct hwtstamp_config *))0, .sriov_configure = (int (*)(struct efx_nic *, int ))0, .sriov_init = (int (*)(struct efx_nic *))0, .sriov_fini = (void (*)(struct efx_nic *))0, .sriov_wanted = (bool (*)(struct efx_nic *))0, .sriov_reset = (void (*)(struct efx_nic *))0, .sriov_flr = (void (*)(struct efx_nic *, unsigned int ))0, .sriov_set_vf_mac = (int (*)(struct efx_nic *, int , u8 *))0, .sriov_set_vf_vlan = (int (*)(struct efx_nic *, int , u16 , u8 ))0, .sriov_set_vf_spoofchk = (int (*)(struct efx_nic *, int , bool ))0, .sriov_get_vf_config = (int (*)(struct efx_nic *, int , struct ifla_vf_info *))0, .sriov_set_vf_link_state = (int (*)(struct efx_nic *, int , int ))0, .sriov_get_phys_port_id = (int (*)(struct efx_nic *, struct netdev_phys_item_id *))0, .vswitching_probe = (int (*)(struct efx_nic *))0, .vswitching_restore = (int (*)(struct efx_nic *))0, .vswitching_remove = (void (*)(struct efx_nic *))0, .get_mac_address = (int (*)(struct efx_nic *, unsigned char *))0, .set_mac_address = (int (*)(struct efx_nic *))0, .revision = 2, .txd_ptr_tbl_base = 16056320U, .rxd_ptr_tbl_base = 15990784U, .buf_tbl_base = 8388608U, .evq_ptr_tbl_base = 16121856U, .evq_rptr_tbl_base = 16384000U, .max_dma_mask = 70368744177663ULL, .rx_prefix_size = 16U, .rx_hash_offset = 12U, .rx_ts_offset = 0U, .rx_buffer_padding = 0U, .can_rx_scatter = (_Bool)1, .always_rx_scatter = (_Bool)0, .max_interrupt_mode = 0U, .timer_period_max = 4096U, .offload_features = 12884901890ULL, .mcdi_max_ver = -1, .max_rx_ip_filters = 8192U, .hwtstamp_filters = 0U};

#line 125  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void atomic_inc_3(atomic_t *v)
{
  
#line 128 
  ldv_atomic_inc(v);
  
#line 129 
  return;
}


#line 491  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void *kmalloc_3(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 494 
  tmp = ldv_kmalloc(size,flags);
  
#line 494 
  return tmp;
}


#line 505  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void *kcalloc_8(size_t n, size_t size, gfp_t flags)
{
  void *tmp;
  
#line 508 
  tmp = ldv_kcalloc(n,size,flags);
  
#line 508 
  return tmp;
}


#line 512  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void *kzalloc_7(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 515 
  tmp = ldv_kzalloc(size,flags);
  
#line 515 
  return tmp;
}


#line 888  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void ldv___ldv_spin_lock_87_2(spinlock_t *ldv_func_arg1)
{
  
#line 892 
  ldv_spin_model_lock((char *)"biu_lock_of_efx_nic");
  
#line 894 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 895 
  return;
}


#line 898  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void ldv_spin_unlock_irqrestore_88_2(spinlock_t *lock, unsigned long flags)
{
  
#line 902 
  ldv_spin_model_unlock((char *)"biu_lock_of_efx_nic");
  
#line 904 
  spin_unlock_irqrestore_3(lock,flags);
  
#line 905 
  return;
}


#line 928  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void ldv___ldv_spin_lock_91_2(spinlock_t *ldv_func_arg1)
{
  
#line 932 
  ldv_spin_model_lock((char *)"biu_lock_of_efx_nic");
  
#line 934 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 935 
  return;
}


#line 938  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void ldv_spin_unlock_irqrestore_92_2(spinlock_t *lock, unsigned long flags)
{
  
#line 942 
  ldv_spin_model_unlock((char *)"biu_lock_of_efx_nic");
  
#line 944 
  spin_unlock_irqrestore_3(lock,flags);
  
#line 945 
  return;
}


#line 968  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void ldv___ldv_spin_lock_95_0(spinlock_t *ldv_func_arg1)
{
  
#line 972 
  ldv_spin_model_lock((char *)"biu_lock_of_efx_nic");
  
#line 974 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 975 
  return;
}


#line 978  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void ldv_spin_unlock_irqrestore_96_0(spinlock_t *lock, unsigned long flags)
{
  
#line 982 
  ldv_spin_model_unlock((char *)"biu_lock_of_efx_nic");
  
#line 984 
  spin_unlock_irqrestore_3(lock,flags);
  
#line 985 
  return;
}


#line 988  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static int ldv_mutex_lock_interruptible_97(struct mutex *ldv_func_arg1)
{
  int __retres;
  
#line 991 
  int nondetermined = ldv_undef_int();
  
#line 993 
  if (nondetermined != 0) {
    
#line 996 
    ldv_mutex_model_lock(ldv_func_arg1,(char *)"spi_lock_of_falcon_nic_data");
    
#line 997 
    __retres = 0;
    
#line 997 
    goto return_label;
  }
  else {
    
#line 1002 
    __retres = -4;
    
#line 1002 
    goto return_label;
  }
  return_label: 
#line 993 
                return __retres;
}


#line 1007  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void ldv_mutex_unlock_98_1(struct mutex *ldv_func_arg1)
{
  
#line 1011 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"spi_lock_of_falcon_nic_data");
  
#line 1012 
  return;
}


#line 1015  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static int ldv_mutex_lock_interruptible_99(struct mutex *ldv_func_arg1)
{
  int __retres;
  
#line 1018 
  int nondetermined = ldv_undef_int();
  
#line 1020 
  if (nondetermined != 0) {
    
#line 1023 
    ldv_mutex_model_lock(ldv_func_arg1,(char *)"spi_lock_of_falcon_nic_data");
    
#line 1024 
    __retres = 0;
    
#line 1024 
    goto return_label;
  }
  else {
    
#line 1029 
    __retres = -4;
    
#line 1029 
    goto return_label;
  }
  return_label: 
#line 1020 
                return __retres;
}


#line 1034  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void ldv_mutex_unlock_100_0(struct mutex *ldv_func_arg1)
{
  
#line 1038 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"spi_lock_of_falcon_nic_data");
  
#line 1039 
  return;
}


#line 1042  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static int ldv_mutex_lock_interruptible_101(struct mutex *ldv_func_arg1)
{
  int __retres;
  
#line 1045 
  int nondetermined = ldv_undef_int();
  
#line 1047 
  if (nondetermined != 0) {
    
#line 1050 
    ldv_mutex_model_lock(ldv_func_arg1,(char *)"spi_lock_of_falcon_nic_data");
    
#line 1051 
    __retres = 0;
    
#line 1051 
    goto return_label;
  }
  else {
    
#line 1056 
    __retres = -4;
    
#line 1056 
    goto return_label;
  }
  return_label: 
#line 1047 
                return __retres;
}


#line 1061  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void ldv_mutex_unlock_102(struct mutex *ldv_func_arg1)
{
  
#line 1065 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"spi_lock_of_falcon_nic_data");
  
#line 1066 
  return;
}


#line 1069  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void ldv_mutex_lock_103_0(struct mutex *ldv_func_arg1)
{
  
#line 1073 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"spi_lock_of_falcon_nic_data");
  
#line 1074 
  return;
}


#line 1077  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void ldv_mutex_unlock_104(struct mutex *ldv_func_arg1)
{
  
#line 1081 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"spi_lock_of_falcon_nic_data");
  
#line 1082 
  return;
}


#line 1085  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static int ldv_mutex_is_locked_105(struct mutex *lock)
{
  int tmp;
  
#line 1088 
  tmp = ldv_mutex_model_is_locked(lock,(char *)"mac_lock_of_efx_nic");
  
#line 1088 
  return tmp;
}


#line 1092  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static int ldv_mod_timer_106(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2)
{
  int tmp;
  
#line 1096 
  tmp = ldv_emg_mod_timer(ldv_func_arg1,ldv_func_arg2);
  
#line 1096 
  return tmp;
}


#line 1100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void ldv_spin_lock_107(spinlock_t *lock)
{
  
#line 1104 
  ldv_spin_model_lock((char *)"stats_lock_of_efx_nic");
  
#line 1106 
  spin_lock_4(lock);
  
#line 1107 
  return;
}


#line 1110  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void ldv_spin_unlock_108(spinlock_t *lock)
{
  
#line 1114 
  ldv_spin_model_unlock((char *)"stats_lock_of_efx_nic");
  
#line 1116 
  spin_unlock_4(lock);
  
#line 1117 
  return;
}


#line 1120  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static int ldv_mutex_is_locked_109(struct mutex *lock)
{
  int tmp;
  
#line 1123 
  tmp = ldv_mutex_model_is_locked(lock,(char *)"mac_lock_of_efx_nic");
  
#line 1123 
  return tmp;
}


#line 1127  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void ldv_mutex_lock_110(struct mutex *ldv_func_arg1)
{
  
#line 1131 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mdio_lock_of_falcon_nic_data");
  
#line 1132 
  return;
}


#line 1135  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void ldv_mutex_unlock_111(struct mutex *ldv_func_arg1)
{
  
#line 1139 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mdio_lock_of_falcon_nic_data");
  
#line 1140 
  return;
}


#line 1143  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void ldv_mutex_lock_112_0(struct mutex *ldv_func_arg1)
{
  
#line 1147 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mdio_lock_of_falcon_nic_data");
  
#line 1148 
  return;
}


#line 1151  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void ldv_mutex_unlock_113_0(struct mutex *ldv_func_arg1)
{
  
#line 1155 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mdio_lock_of_falcon_nic_data");
  
#line 1156 
  return;
}


#line 1159  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void ldv_mutex_lock_114(struct mutex *ldv_func_arg1)
{
  
#line 1163 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"spi_lock_of_falcon_nic_data");
  
#line 1164 
  return;
}


#line 1167  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void ldv_mutex_unlock_115(struct mutex *ldv_func_arg1)
{
  
#line 1171 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"spi_lock_of_falcon_nic_data");
  
#line 1172 
  return;
}


#line 1175  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void ldv_mutex_lock_116(struct mutex *ldv_func_arg1)
{
  
#line 1179 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 1180 
  return;
}


#line 1183  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void ldv_mutex_unlock_117(struct mutex *ldv_func_arg1)
{
  
#line 1187 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 1188 
  return;
}


#line 1191  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void ldv_mutex_lock_118(struct mutex *ldv_func_arg1)
{
  
#line 1195 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"spi_lock_of_falcon_nic_data");
  
#line 1196 
  return;
}


#line 1199  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void ldv_mutex_unlock_119(struct mutex *ldv_func_arg1)
{
  
#line 1203 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"spi_lock_of_falcon_nic_data");
  
#line 1204 
  return;
}


#line 1207  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static int ldv_mutex_is_locked_120(struct mutex *lock)
{
  int tmp;
  
#line 1210 
  tmp = ldv_mutex_model_is_locked(lock,(char *)"mac_lock_of_efx_nic");
  
#line 1210 
  return tmp;
}


#line 1214  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void ldv_spin_lock_bh_121(spinlock_t *lock)
{
  
#line 1218 
  ldv_spin_model_lock((char *)"stats_lock_of_efx_nic");
  
#line 1220 
  spin_lock_bh_3(lock);
  
#line 1221 
  return;
}


#line 1224  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void ldv_spin_unlock_bh_122(spinlock_t *lock)
{
  
#line 1228 
  ldv_spin_model_unlock((char *)"stats_lock_of_efx_nic");
  
#line 1230 
  spin_unlock_bh_4(lock);
  
#line 1231 
  return;
}


#line 1234  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void ldv_spin_lock_bh_123(spinlock_t *lock)
{
  
#line 1238 
  ldv_spin_model_lock((char *)"stats_lock_of_efx_nic");
  
#line 1240 
  spin_lock_bh_3(lock);
  
#line 1241 
  return;
}


#line 1244  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void ldv_spin_unlock_bh_124(spinlock_t *lock)
{
  
#line 1248 
  ldv_spin_model_unlock((char *)"stats_lock_of_efx_nic");
  
#line 1250 
  spin_unlock_bh_4(lock);
  
#line 1251 
  return;
}


#line 1254  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static int ldv_del_timer_sync_125(struct timer_list *ldv_func_arg1)
{
  int tmp;
  
#line 1258 
  tmp = ldv_emg_del_timer_sync(ldv_func_arg1);
  
#line 1258 
  return tmp;
}


#line 1262  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void ldv_spin_lock_bh_126_0(spinlock_t *lock)
{
  
#line 1266 
  ldv_spin_model_lock((char *)"stats_lock_of_efx_nic");
  
#line 1268 
  spin_lock_bh_3(lock);
  
#line 1269 
  return;
}


#line 1272  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_falcon.c.aux"
static void ldv_spin_unlock_bh_127_0(spinlock_t *lock)
{
  
#line 1276 
  ldv_spin_model_unlock((char *)"stats_lock_of_efx_nic");
  
#line 1278 
  spin_unlock_bh_4(lock);
  
#line 1279 
  return;
}


#line 248  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
void __might_fault(char const *, int);


#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void list_add(struct list_head *new, struct list_head *head)
{
  
#line 63 
  __list_add(new,head,head->next);
  
#line 64 
  return;
}


#line 112 
void __list_del_entry(struct list_head *);


#line 154  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void list_move(struct list_head *list, struct list_head *head)
{
  
#line 156 
  __list_del_entry(list);
  
#line 157 
  list_add(list,head);
  
#line 158 
  return;
}


#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/math64.h"
__inline static u32 __iter_div_u64_rem(u64 dividend, u32 divisor, u64 *remainder)
{
  
#line 120 
  u32 ret = 0U;
  
#line 122 
  goto ldv_5449;
  ldv_5448: 
#line 123 
  ;
  
#line 124 
  ldv_inline_asm();
  
#line 127 
  dividend -= (unsigned long long)divisor;
  
#line 128 
  ret += 1U;
  ldv_5449: 
#line 129 
  ;
  
#line 122 
  if ((unsigned long long)divisor <= dividend) 
#line 124 
                                               goto ldv_5448; else 
#line 127 
                                                                   goto ldv_5450;
  ldv_5450: 
#line 128 
  ;
  
#line 131 
  *remainder = dividend;
  
#line 133 
  return ret;
}


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/err.h"
static long PTR_ERR_0(void const *ptr);


#line 41 
static bool IS_ERR_0(void const *ptr);


#line 355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_bh_4(spinlock_t *lock)
{
  
#line 357 
  _raw_spin_lock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 358 
  return;
}


#line 407 
static void ldv_spin_lock_bh_97_1(spinlock_t *lock);


#line 411 
static void ldv_spin_lock_bh_99_0(spinlock_t *lock);


#line 415 
static void ldv_spin_lock_bh_101_0(spinlock_t *lock);


#line 419 
static void ldv_spin_lock_bh_103_0(spinlock_t *lock);


#line 423 
static void ldv_spin_lock_bh_108_0(spinlock_t *lock);


#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_bh_5(spinlock_t *lock)
{
  
#line 406 
  _raw_spin_unlock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 407 
  return;
}


#line 460 
static void ldv_spin_unlock_bh_98_0(spinlock_t *lock);


#line 464 
static void ldv_spin_unlock_bh_100_0(spinlock_t *lock);


#line 468 
static void ldv_spin_unlock_bh_102_0(spinlock_t *lock);


#line 472 
static void ldv_spin_unlock_bh_104(spinlock_t *lock);


#line 476 
static void ldv_spin_unlock_bh_110(spinlock_t *lock);


#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/time.h"
__inline static int timespec_compare(struct timespec const *lhs, struct timespec const *rhs)
{
  int __retres;
  
#line 26 
  if (lhs->tv_sec < rhs->tv_sec) {
    
#line 27 
    __retres = -1;
    
#line 27 
    goto return_label;
  }
  else ;
  
#line 28 
  if (lhs->tv_sec > rhs->tv_sec) {
    
#line 29 
    __retres = 1;
    
#line 29 
    goto return_label;
  }
  else ;
  
#line 30 
  __retres = (int)(lhs->tv_nsec - rhs->tv_nsec);
  return_label: 
#line 30 
                return __retres;
}


#line 57 
void set_normalized_timespec(struct timespec *, time_t, s64);


#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/time.h"
__inline static struct timespec timespec_sub(struct timespec lhs, struct timespec rhs)
{
  struct timespec ts_delta;
  
#line 84 
  set_normalized_timespec(& ts_delta,lhs.tv_sec - rhs.tv_sec,(long long)(lhs.tv_nsec - rhs.tv_nsec));
  
#line 86 
  return ts_delta;
}


#line 191  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/time.h"
__inline static s64 timespec_to_ns(struct timespec const *ts)
{
  s64 __retres;
  
#line 193 
  __retres = (long long)ts->tv_sec * 1000000000LL + (long long)ts->tv_nsec;
  
#line 193 
  return __retres;
}


#line 215 
struct timespec ns_to_timespec(s64 const);


#line 233  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/time.h"
__inline static void timespec_add_ns(struct timespec *a, u64 ns)
{
  u32 tmp;
  
#line 235 
  tmp = __iter_div_u64_rem((unsigned long long)a->tv_nsec + ns,1000000000U,& ns);
  
#line 235 
  a->tv_sec += (long)tmp;
  
#line 236 
  a->tv_nsec = (long)ns;
  
#line 237 
  return;
}


#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ktime.h"
__inline static ktime_t ktime_set(s64 const secs, unsigned long const nsecs)
{
  ktime_t __retres;
  
#line 52 
  if ((long)(secs > 9223372035LL) != 0L) {
    
#line 53 
    ktime_t __constr_expr_10 = {.tv64 = 9223372036854775807LL};
    
#line 53 
    __retres = __constr_expr_10;
    
#line 53 
    goto return_label;
  }
  else ;
  
#line 55 
  ktime_t __constr_expr_11 = {.tv64 = secs * 1000000000LL + (long long)nsecs};
  
#line 55 
  __retres = __constr_expr_11;
  return_label: 
#line 55 
                return __retres;
}


#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timekeeping.h"
void getnstimeofday64(struct timespec *);


#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timekeeping.h"
__inline static void getnstimeofday(struct timespec *ts)
{
  
#line 54 
  getnstimeofday64(ts);
  
#line 55 
  return;
}


#line 490  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
static bool ldv_queue_work_105(struct workqueue_struct *wq, struct work_struct *work);


#line 494 
static bool ldv_queue_work_106(struct workqueue_struct *wq, struct work_struct *work);


#line 498 
static bool ldv_queue_work_107(struct workqueue_struct *wq, struct work_struct *work);


#line 502 
static bool ldv_queue_work_109(struct workqueue_struct *wq, struct work_struct *work);


#line 506 
static bool ldv_queue_work_111(struct workqueue_struct *wq, struct work_struct *work);


#line 581  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kzalloc_8(size_t size, gfp_t flags);


#line 650  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
unsigned long _copy_from_user(void *, void const *, unsigned int);


#line 652 
unsigned long _copy_to_user(void *, void const *, unsigned int);


#line 662 
void copy_from_user_overflow(void);


#line 664 
void copy_to_user_overflow(void);


#line 672 
void __copy_from_user_overflow(void);


#line 677 
void __copy_to_user_overflow(void);


#line 693  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_from_user(void *to, void const *from, unsigned long n)
{
  
#line 695 
  int sz = -1;
  
#line 697 
  __might_fault("./arch/x86/include/asm/uaccess.h",697);
  
#line 717 
  if ((long)(sz < 0) != 0L || (long)((unsigned long)sz >= n) != 0L) 
#line 718 
                                                                    n = _copy_from_user(to,from,(unsigned int)n);
  else 
    
#line 719 
    if (0 != 0) 
#line 720 
                copy_from_user_overflow(); else 
#line 722 
                                                __copy_from_user_overflow();
  
#line 724 
  return n;
}


#line 728  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_to_user(void *to, void const *from, unsigned long n)
{
  
#line 730 
  int sz = -1;
  
#line 732 
  __might_fault("./arch/x86/include/asm/uaccess.h",732);
  
#line 735 
  if ((long)(sz < 0) != 0L || (long)((unsigned long)sz >= n) != 0L) 
#line 736 
                                                                    n = _copy_to_user(to,from,(unsigned int)n);
  else 
    
#line 737 
    if (0 != 0) 
#line 738 
                copy_to_user_overflow(); else 
#line 740 
                                              __copy_to_user_overflow();
  
#line 742 
  return n;
}


#line 1000  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct skb_shared_hwtstamps *skb_hwtstamps(struct sk_buff *skb)
{
  struct skb_shared_hwtstamps *__retres;
  unsigned char *tmp;
  
#line 1002 
  tmp = skb_end_pointer((struct sk_buff const *)skb);
  
#line 1002 
  __retres = & ((struct skb_shared_info *)tmp)->hwtstamps;
  
#line 1002 
  return __retres;
}


#line 1259  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct sk_buff *skb_peek(struct sk_buff_head const *list_)
{
  
#line 1261 
  struct sk_buff *skb = list_->next;
  
#line 1263 
  if (skb == (struct sk_buff *)list_) 
#line 1264 
                                      skb = (struct sk_buff *)0; else ;
  
#line 1265 
  return skb;
}


#line 1331  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void __skb_queue_head_init(struct sk_buff_head *list)
{
  struct sk_buff *tmp;
  
#line 1333 
  tmp = (struct sk_buff *)list;
  
#line 1333 
  list->next = tmp;
  
#line 1333 
  list->prev = tmp;
  
#line 1334 
  list->qlen = 0U;
  
#line 1335 
  return;
}


#line 1345  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_queue_head_init(struct sk_buff_head *list)
{
  
#line 1347 
  spinlock_check(& list->lock);
  {
    struct lock_class_key __key;
    
#line 1347 
    __raw_spin_lock_init(& list->lock.__anonCompField_spinlock_18.rlock,"&(&list->lock)->rlock",& __key);
  }
  
#line 1348 
  __skb_queue_head_init(list);
  
#line 1349 
  return;
}


#line 1366  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void __skb_insert(struct sk_buff *newsk, struct sk_buff *prev, struct sk_buff *next, struct sk_buff_head *list)
{
  struct sk_buff *tmp;
  
#line 1370 
  newsk->__anonCompField_sk_buff_87.__anonCompField___anonunion_290_86.next = next;
  
#line 1371 
  newsk->__anonCompField_sk_buff_87.__anonCompField___anonunion_290_86.prev = prev;
  
#line 1372 
  tmp = newsk;
  
#line 1372 
  prev->__anonCompField_sk_buff_87.__anonCompField___anonunion_290_86.next = tmp;
  
#line 1372 
  next->__anonCompField_sk_buff_87.__anonCompField___anonunion_290_86.prev = tmp;
  
#line 1373 
  list->qlen += 1U;
  
#line 1374 
  return;
}


#line 1474  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void __skb_queue_before(struct sk_buff_head *list, struct sk_buff *next, struct sk_buff *newsk)
{
  
#line 1478 
  __skb_insert(newsk,next->__anonCompField_sk_buff_87.__anonCompField___anonunion_290_86.prev,next,list);
  
#line 1479 
  return;
}


#line 1491 
void skb_queue_head(struct sk_buff_head *, struct sk_buff *);


#line 1508 
void skb_queue_tail(struct sk_buff_head *, struct sk_buff *);


#line 1509  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void __skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
{
  
#line 1512 
  __skb_queue_before(list,(struct sk_buff *)list,newsk);
  
#line 1513 
  return;
}


#line 1520  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void __skb_unlink(struct sk_buff *skb, struct sk_buff_head *list)
{
  struct sk_buff *next;
  struct sk_buff *prev;
  struct sk_buff *tmp;
  
#line 1524 
  list->qlen -= 1U;
  
#line 1525 
  next = skb->__anonCompField_sk_buff_87.__anonCompField___anonunion_290_86.next;
  
#line 1526 
  prev = skb->__anonCompField_sk_buff_87.__anonCompField___anonunion_290_86.prev;
  
#line 1527 
  tmp = (struct sk_buff *)0;
  
#line 1527 
  skb->__anonCompField_sk_buff_87.__anonCompField___anonunion_290_86.prev = tmp;
  
#line 1527 
  skb->__anonCompField_sk_buff_87.__anonCompField___anonunion_290_86.next = tmp;
  
#line 1528 
  next->__anonCompField_sk_buff_87.__anonCompField___anonunion_290_86.prev = prev;
  
#line 1529 
  prev->__anonCompField_sk_buff_87.__anonCompField___anonunion_290_86.next = next;
  
#line 1530 
  return;
}


#line 1540 
struct sk_buff *skb_dequeue(struct sk_buff_head *);


#line 1541  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct sk_buff *__skb_dequeue(struct sk_buff_head *list)
{
  
#line 1543 
  struct sk_buff *skb = skb_peek((struct sk_buff_head const *)list);
  
#line 1544 
  if (skb != (struct sk_buff *)0) 
#line 1545 
                                  __skb_unlink(skb,list); else ;
  
#line 1546 
  return skb;
}


#line 1719 
unsigned char *__pskb_pull_tail(struct sk_buff *, int);


#line 1735  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int pskb_may_pull(struct sk_buff *skb, unsigned int len)
{
  int __retres;
  unsigned int tmp;
  unsigned char *tmp_1;
  unsigned int tmp_0;
  
#line 1737 
  tmp = skb_headlen((struct sk_buff const *)skb);
  
#line 1737 
  ;
  
#line 1737 
  if ((long)(tmp >= len) != 0L) {
    
#line 1738 
    __retres = 1;
    
#line 1738 
    goto return_label;
  }
  else ;
  
#line 1739 
  if ((long)(skb->len < len) != 0L) {
    
#line 1740 
    __retres = 0;
    
#line 1740 
    goto return_label;
  }
  else ;
  
#line 1741 
  tmp_0 = skb_headlen((struct sk_buff const *)skb);
  
#line 1741 
  ;
  
#line 1741 
  ;
  
#line 1741 
  tmp_1 = __pskb_pull_tail(skb,(int)(len - tmp_0));
  
#line 1741 
  __retres = tmp_1 != (unsigned char *)0U;
  return_label: 
#line 1741 
                return __retres;
}


#line 1875  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static bool skb_transport_header_was_set(struct sk_buff const *skb)
{
  bool __retres;
  
#line 1877 
  __retres = (_Bool)((unsigned int)skb->transport_header != 65535U);
  
#line 1877 
  return __retres;
}


#line 1913  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_mac_header(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 1915 
  __retres = skb->head + (int)skb->mac_header;
  
#line 1915 
  return __retres;
}


#line 1967  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int skb_transport_offset(struct sk_buff const *skb)
{
  int __retres;
  unsigned char *tmp;
  
#line 1969 
  tmp = skb_transport_header(skb);
  
#line 1969 
  ;
  
#line 1969 
  __retres = (int)((long)tmp - (long)skb->data);
  
#line 1969 
  return __retres;
}


#line 1972  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static u32 skb_network_header_len(struct sk_buff const *skb)
{
  u32 __retres;
  
#line 1974 
  __retres = (unsigned int)((int)skb->transport_header - (int)skb->network_header);
  
#line 1974 
  return __retres;
}


#line 2130 
void skb_queue_purge(struct sk_buff_head *);


#line 2545  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int __skb_linearize(struct sk_buff *skb)
{
  int tmp_0;
  unsigned char *tmp;
  
#line 2547 
  tmp = __pskb_pull_tail(skb,(int)skb->data_len);
  
#line 2547 
  if (tmp != (unsigned char *)0U) 
#line 2547 
                                  tmp_0 = 0; else 
#line 2547 
                                                  tmp_0 = -12;
  
#line 2547 
  return tmp_0;
}


#line 2557  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int skb_linearize(struct sk_buff *skb)
{
  int tmp_1;
  bool tmp;
  
#line 2559 
  tmp = skb_is_nonlinear((struct sk_buff const *)skb);
  
#line 2559 
  if ((int)tmp != 0) 
#line 2559 
                     tmp_1 = __skb_linearize(skb); else 
#line 2559 
                                                        tmp_1 = 0;
  
#line 2559 
  return tmp_1;
}


#line 2789  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_copy_from_linear_data(struct sk_buff const *skb, void *to, unsigned int const len)
{
  
#line 2793 
  memcpy(to,(void const *)skb->data,(unsigned long)len);
  
#line 2794 
  return;
}


#line 2911 
void skb_tstamp_tx(struct sk_buff *, struct skb_shared_hwtstamps *);


#line 3553  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
int skb_checksum_help(struct sk_buff *);


#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/udp.h"
__inline static struct udphdr *udp_hdr(struct sk_buff const *skb)
{
  struct udphdr *tmp;
  
#line 27 
  tmp = (struct udphdr *)skb_transport_header(skb);
  
#line 27 
  return tmp;
}


#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pps_kernel.h"
__inline static void pps_get_ts(struct pps_event_time *ts)
{
  
#line 125 
  getnstimeofday(& ts->ts_real);
  
#line 126 
  return;
}


#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pps_kernel.h"
__inline static void pps_sub_ts(struct pps_event_time *ts, struct timespec delta)
{
  
#line 133 
  ts->ts_real = timespec_sub(ts->ts_real,delta);
  
#line 134 
  return;
}


#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ptp_clock_kernel.h"
struct ptp_clock *ptp_clock_register(struct ptp_clock_info *, struct device *);


#line 133 
int ptp_clock_unregister(struct ptp_clock *);


#line 168 
void ptp_clock_event(struct ptp_clock *, struct ptp_clock_event *);


#line 177 
int ptp_clock_index(struct ptp_clock *);


#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/filter.h"
__inline static int efx_filter_set_ipv4_local(struct efx_filter_spec *spec, u8 proto, __be32 host, __be16 port)
{
  int __retres;
  
#line 187 
  spec->match_flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))))((unsigned int)spec->match_flags | 610U);
  
#line 190 
  spec->ether_type = (unsigned short)8U;
  
#line 191 
  spec->ip_proto = proto;
  
#line 192 
  spec->loc_host[0] = host;
  
#line 193 
  spec->loc_port = port;
  
#line 194 
  __retres = 0;
  
#line 194 
  return __retres;
}


#line 1523  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
__inline static void efx_xmit_hwtstamp_pending(struct sk_buff *skb)
{
  unsigned char *tmp;
  unsigned char *tmp_0;
  
#line 1525 
  tmp = skb_end_pointer((struct sk_buff const *)skb);
  
#line 1525 
  tmp_0 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 1525 
  ((struct skb_shared_info *)tmp)->tx_flags = (unsigned char)((unsigned int)((struct skb_shared_info *)tmp_0)->tx_flags | 4U);
  
#line 1526 
  return;
}


#line 560  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
int efx_ptp_set_ts_config(struct efx_nic *efx, struct ifreq *ifr);


#line 561 
int efx_ptp_get_ts_config(struct efx_nic *efx, struct ifreq *ifr);


#line 580 
void efx_ptp_start_datapath(struct efx_nic *efx);


#line 581 
void efx_ptp_stop_datapath(struct efx_nic *efx);


#line 324  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static int efx_phc_adjfreq(struct ptp_clock_info *ptp, s32 delta);


#line 325 
static int efx_phc_adjtime(struct ptp_clock_info *ptp, s64 delta);


#line 326 
static int efx_phc_gettime(struct ptp_clock_info *ptp, struct timespec *ts);


#line 327 
static int efx_phc_settime(struct ptp_clock_info *ptp, struct timespec const *e_ts);


#line 329 
static int efx_phc_enable(struct ptp_clock_info *ptp, struct ptp_clock_request *request, int enable);


#line 336  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static struct efx_hw_stat_desc const efx_ptp_stat_desc[14U] = {{.name = "ptp_good_syncs", .dma_width = (unsigned short)0U, .offset = (unsigned short)1344U}, {.name = "ptp_fast_syncs", .dma_width = (unsigned short)0U, .offset = (unsigned short)1348U}, {.name = "ptp_bad_syncs", .dma_width = (unsigned short)0U, .offset = (unsigned short)1352U}, {.name = "ptp_sync_timeouts", .dma_width = (unsigned short)0U, .offset = (unsigned short)1356U}, {.name = "ptp_no_time_syncs", .dma_width = (unsigned short)0U, .offset = (unsigned short)1360U}, {.name = "ptp_invalid_sync_windows", .dma_width = (unsigned short)0U, .offset = (unsigned short)1364U}, {.name = "ptp_undersize_sync_windows", .dma_width = (unsigned short)0U, .offset = (unsigned short)1368U}, {.name = "ptp_oversize_sync_windows", .dma_width = (unsigned short)0U, .offset = (unsigned short)1372U}, {.name = "ptp_rx_no_timestamp", .dma_width = (unsigned short)0U, .offset = (unsigned short)1376U}, {.name = "ptp_tx_timestamp_packets", .dma_width = (unsigned short)32U, .offset = (unsigned short)4U}, {.name = "ptp_rx_timestamp_packets", .dma_width = (unsigned short)32U, .offset = (unsigned short)8U}, {.name = "ptp_timestamp_packets", .dma_width = (unsigned short)32U, .offset = (unsigned short)12U}, {.name = "ptp_filter_matches", .dma_width = (unsigned short)32U, .offset = (unsigned short)16U}, {.name = "ptp_non_filter_matches", .dma_width = (unsigned short)32U, .offset = (unsigned short)20U}};

#line 353  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static unsigned long const efx_ptp_stat_mask[1U] = {18446744073709551615UL};

#line 357  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
size_t efx_ptp_describe_stats(struct efx_nic *efx, u8 *strings)
{
  size_t __retres;
  size_t tmp;
  
#line 359 
  if (efx->ptp_data == (struct efx_ptp_data *)0) {
    
#line 360 
    __retres = 0UL;
    
#line 360 
    goto return_label;
  }
  else ;
  
#line 362 
  tmp = efx_nic_describe_stats((struct efx_hw_stat_desc const *)(& efx_ptp_stat_desc),14UL,(unsigned long const *)(& efx_ptp_stat_mask),strings);
  
#line 362 
  __retres = tmp;
  return_label: 
#line 362 
                return __retres;
}


#line 366  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
size_t efx_ptp_update_stats(struct efx_nic *efx, u64 *stats)
{
  size_t __retres;
  size_t i;
  int rc;
  
#line 368 
  efx_dword_t inbuf[2U] = {{.u32 = {0U}}};
  
#line 369 
  efx_dword_t outbuf[16U] = {{.u32 = {0U}}};
  
#line 373 
  if (efx->ptp_data == (struct efx_ptp_data *)0) {
    
#line 374 
    __retres = 0UL;
    
#line 374 
    goto return_label;
  }
  else ;
  
#line 377 
  i = 0UL;
  
#line 377 
  goto ldv_56936;
  ldv_56935: 
#line 378 
  ;
  
#line 378 
  if ((unsigned int)efx_ptp_stat_desc[i].dma_width != 0U) 
#line 379 
                                                          goto ldv_56934; else ;
  
#line 380 
  *(stats + i) = (unsigned long long)*((unsigned int *)efx->ptp_data + (int)efx_ptp_stat_desc[i].offset);
  ldv_56934: 
#line 382 
  ;
  
#line 377 
  i += 1UL;
  ldv_56936: 
#line 378 
  ;
  
#line 377 
  if (i <= 13UL) 
#line 379 
                 goto ldv_56935; else 
#line 382 
                                      goto ldv_56937;
  ldv_56937: 
#line 383 
  ;
  
#line 388 
  ((efx_dword_t *)(& inbuf))->u32[0] = 5U;
  
#line 389 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = 0U;
  
#line 390 
  rc = efx_mcdi_rpc(efx,11U,(efx_dword_t const *)(& inbuf),8UL,(efx_dword_t *)(& outbuf),64UL,(size_t *)0UL);
  
#line 392 
  if (rc != 0) 
#line 393 
               memset((void *)(& outbuf),0,64UL); else ;
  
#line 394 
  efx_nic_update_stats((struct efx_hw_stat_desc const *)(& efx_ptp_stat_desc),14UL,(unsigned long const *)(& efx_ptp_stat_mask),stats,(void const *)(& outbuf),(_Bool)0);
  
#line 398 
  __retres = 14UL;
  return_label: 
#line 398 
                return __retres;
}


#line 402  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static void efx_ptp_ns_to_s_ns(s64 ns, u32 *nic_major, u32 *nic_minor)
{
  
#line 404 
  struct timespec ts = ns_to_timespec(ns);
  
#line 405 
  *nic_major = (unsigned int)ts.tv_sec;
  
#line 406 
  *nic_minor = (unsigned int)ts.tv_nsec;
  
#line 407 
  return;
}


#line 409  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static ktime_t efx_ptp_s_ns_to_ktime_correction(u32 nic_major, u32 nic_minor, s32 correction)
{
  
#line 412 
  ktime_t kt = ktime_set((long long)nic_major,(unsigned long)nic_minor);
  
#line 413 
  if (correction >= 0) {
    
#line 414 
    ktime_t __constr_expr_37 = {.tv64 = (long long)((unsigned long long)kt.tv64 + (unsigned long long)correction)};
    
#line 414 
    kt = __constr_expr_37;
  }
  else {
    
#line 416 
    ktime_t __constr_expr_38 = {.tv64 = (long long)((unsigned long long)kt.tv64 - (unsigned long long)(- correction))};
    
#line 416 
    kt = __constr_expr_38;
  }
  
#line 417 
  return kt;
}


#line 432  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static void efx_ptp_ns_to_s27(s64 ns, u32 *nic_major, u32 *nic_minor)
{
  
#line 434 
  struct timespec ts = ns_to_timespec(ns);
  
#line 435 
  u32 maj = (unsigned int)ts.tv_sec;
  
#line 436 
  u32 min = (unsigned int)(((unsigned long long)ts.tv_nsec * 9223372037ULL + 34359738368ULL) >> 36);
  
#line 442 
  if (min > 134217727U) {
    
#line 443 
    min += 4160749568U;
    
#line 444 
    maj += 1U;
  }
  else ;
  
#line 447 
  *nic_major = maj;
  
#line 448 
  *nic_minor = min;
  
#line 449 
  return;
}


#line 451  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
__inline static ktime_t efx_ptp_s27_to_ktime(u32 nic_major, u32 nic_minor)
{
  ktime_t tmp;
  
#line 453 
  u32 ns = (unsigned int)(((unsigned long long)nic_minor * 1000000000ULL + 67108864ULL) >> 27);
  
#line 455 
  tmp = ktime_set((long long)nic_major,(unsigned long)ns);
  
#line 455 
  return tmp;
}


#line 458  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static ktime_t efx_ptp_s27_to_ktime_correction(u32 nic_major, u32 nic_minor, s32 correction)
{
  ktime_t tmp;
  
#line 462 
  nic_minor += (unsigned int)correction;
  
#line 463 
  if ((int)nic_minor < 0) {
    
#line 464 
    nic_minor += 134217728U;
    
#line 465 
    nic_major -= 1U;
  }
  else 
    
#line 466 
    if (nic_minor > 134217727U) {
      
#line 467 
      nic_minor += 4160749568U;
      
#line 468 
      nic_major += 1U;
    }
    else ;
  
#line 471 
  tmp = efx_ptp_s27_to_ktime(nic_major,nic_minor);
  
#line 471 
  return tmp;
}


#line 475  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static int efx_ptp_get_attributes(struct efx_nic *efx)
{
  int __retres;
  int rc;
  u32 fmt;
  size_t out_len;
  
#line 477 
  efx_dword_t inbuf[2U] = {{.u32 = {0U}}};
  
#line 478 
  efx_dword_t outbuf[2U] = {{.u32 = {0U}}};
  
#line 479 
  struct efx_ptp_data *ptp = efx->ptp_data;
  
#line 488 
  ((efx_dword_t *)(& inbuf))->u32[0] = 22U;
  
#line 489 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = 0U;
  
#line 490 
  rc = efx_mcdi_rpc_quiet(efx,11U,(efx_dword_t const *)(& inbuf),8UL,(efx_dword_t *)(& outbuf),8UL,& out_len);
  
#line 492 
  if (rc == 0) 
#line 493 
               fmt = ((efx_dword_t *)(& outbuf))->u32[0];
  else 
    
#line 494 
    if (rc == -22) 
#line 495 
                   fmt = 0U;
    else 
      
#line 496 
      if (rc == -1) {
        
#line 497 
        if ((efx->msg_enable & 2U) != 0U) 
#line 497 
                                          netdev_info((struct net_device const *)efx->net_dev,"no PTP support\n"); else ;
        
#line 498 
        __retres = rc;
        
#line 498 
        goto return_label;
      }
      else {
        
#line 500 
        efx_mcdi_display_error(efx,11U,8UL,(efx_dword_t *)(& outbuf),8UL,rc);
        
#line 502 
        __retres = rc;
        
#line 502 
        goto return_label;
      }
  
#line 505 
  if (fmt == 2U) {
    
#line 506 
    ptp->ns_to_nic_time = & efx_ptp_ns_to_s27;
    
#line 507 
    ptp->nic_to_kernel_time = & efx_ptp_s27_to_ktime_correction;
  }
  else 
    
#line 508 
    if (fmt == 0U) {
      
#line 509 
      ptp->ns_to_nic_time = & efx_ptp_ns_to_s_ns;
      
#line 510 
      ptp->nic_to_kernel_time = & efx_ptp_s_ns_to_ktime_correction;
    }
    else {
      
#line 512 
      __retres = -34;
      
#line 512 
      goto return_label;
    }
  
#line 515 
  ptp->time_format = fmt;
  
#line 523 
  if (rc == 0 && out_len > 7UL) 
#line 524 
                                ptp->min_synchronisation_ns = ((efx_dword_t *)(& outbuf) + 1U)->u32[0]; else 
                                                                    
#line 528 
                                                                    ptp->min_synchronisation_ns = 120U;
  
#line 530 
  __retres = 0;
  return_label: 
#line 530 
                return __retres;
}


#line 534  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static int efx_ptp_get_timestamp_corrections(struct efx_nic *efx)
{
  int __retres;
  int rc;
  
#line 536 
  efx_dword_t inbuf[2U] = {{.u32 = {0U}}};
  
#line 537 
  efx_dword_t outbuf[4U] = {{.u32 = {0U}}};
  
#line 543 
  ((efx_dword_t *)(& inbuf))->u32[0] = 23U;
  
#line 545 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = 0U;
  
#line 547 
  rc = efx_mcdi_rpc_quiet(efx,11U,(efx_dword_t const *)(& inbuf),8UL,(efx_dword_t *)(& outbuf),16UL,(size_t *)0UL);
  
#line 549 
  if (rc == 0) {
    
#line 550 
    (efx->ptp_data)->ts_corrections.tx = (int)((efx_dword_t *)(& outbuf))->u32[0];
    
#line 552 
    (efx->ptp_data)->ts_corrections.rx = (int)((efx_dword_t *)(& outbuf) + 1U)->u32[0];
    
#line 554 
    (efx->ptp_data)->ts_corrections.pps_out = (int)((efx_dword_t *)(& outbuf) + 2U)->u32[0];
    
#line 556 
    (efx->ptp_data)->ts_corrections.pps_in = (int)((efx_dword_t *)(& outbuf) + 3U)->u32[0];
  }
  else 
    
#line 558 
    if (rc == -22) {
      
#line 559 
      (efx->ptp_data)->ts_corrections.tx = 0;
      
#line 560 
      (efx->ptp_data)->ts_corrections.rx = 0;
      
#line 561 
      (efx->ptp_data)->ts_corrections.pps_out = 0;
      
#line 562 
      (efx->ptp_data)->ts_corrections.pps_in = 0;
    }
    else {
      
#line 564 
      efx_mcdi_display_error(efx,11U,8UL,(efx_dword_t *)(& outbuf),16UL,rc);
      
#line 566 
      __retres = rc;
      
#line 566 
      goto return_label;
    }
  
#line 569 
  __retres = 0;
  return_label: 
#line 569 
                return __retres;
}


#line 573  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static int efx_ptp_enable(struct efx_nic *efx)
{
  int rc;
  
#line 575 
  efx_dword_t inbuf[4U] = {{.u32 = {0U}}};
  
#line 576 
  efx_dword_t outbuf[2U] = {{.u32 = {0U}}};
  
#line 579 
  ((efx_dword_t *)(& inbuf))->u32[0] = 1U;
  
#line 580 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = 0U;
  {
    int tmp;
    
#line 581 
    if ((efx->ptp_data)->channel != (struct efx_channel *)0) 
#line 581 
                                                             tmp = ((efx->ptp_data)->channel)->channel; else 
                                                                    
#line 581 
                                                                    tmp = 0;
    
#line 581 
    ((efx_dword_t *)(& inbuf) + 2U)->u32[0] = (unsigned int)tmp;
  }
  
#line 584 
  ((efx_dword_t *)(& inbuf) + 3U)->u32[0] = (efx->ptp_data)->mode;
  
#line 586 
  rc = efx_mcdi_rpc_quiet(efx,11U,(efx_dword_t const *)(& inbuf),16UL,(efx_dword_t *)(& outbuf),8UL,(size_t *)0UL);
  
#line 588 
  if (rc != -114) 
#line 588 
                  rc = rc; else 
#line 588 
                                rc = 0;
  
#line 589 
  if (rc != 0) 
#line 590 
               efx_mcdi_display_error(efx,11U,16UL,(efx_dword_t *)(& outbuf),8UL,rc); else ;
  
#line 593 
  return rc;
}


#line 601  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static int efx_ptp_disable(struct efx_nic *efx)
{
  int rc;
  
#line 603 
  efx_dword_t inbuf[2U] = {{.u32 = {0U}}};
  
#line 604 
  efx_dword_t outbuf[2U] = {{.u32 = {0U}}};
  
#line 607 
  ((efx_dword_t *)(& inbuf))->u32[0] = 2U;
  
#line 608 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = 0U;
  
#line 609 
  rc = efx_mcdi_rpc_quiet(efx,11U,(efx_dword_t const *)(& inbuf),8UL,(efx_dword_t *)(& outbuf),8UL,(size_t *)0UL);
  
#line 611 
  if (rc != -114) 
#line 611 
                  rc = rc; else 
#line 611 
                                rc = 0;
  
#line 615 
  if (rc == -38 || rc == -1) {
    
#line 616 
    if ((efx->msg_enable & 2U) != 0U) 
#line 616 
                                      netdev_info((struct net_device const *)efx->net_dev,"no PTP support\n"); else ;
  }
  else 
    
#line 617 
    if (rc != 0) 
#line 618 
                 efx_mcdi_display_error(efx,11U,8UL,(efx_dword_t *)(& outbuf),8UL,rc); else ;
  
#line 621 
  return rc;
}


#line 624  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static void efx_ptp_deliver_rx_queue(struct sk_buff_head *q)
{
  struct sk_buff *skb;
  
#line 628 
  goto ldv_57080;
  ldv_57079: 
#line 629 
  ;
  
#line 629 
  local_bh_disable();
  
#line 630 
  netif_receive_skb(skb);
  
#line 631 
  local_bh_enable();
  ldv_57080: 
#line 632 
  ;
  
#line 628 
  skb = skb_dequeue(q);
  
#line 628 
  if (skb != (struct sk_buff *)0) 
#line 630 
                                  goto ldv_57079; else 
#line 633 
                                                       goto ldv_57081;
  ldv_57081: 
#line 634 
  ;
  
#line 635 
  return;
}


#line 635  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static void efx_ptp_handle_no_channel(struct efx_nic *efx)
{
  
#line 637 
  if ((efx->msg_enable & 1U) != 0U) 
#line 637 
                                    netdev_err((struct net_device const *)efx->net_dev,"ERROR: PTP requires MSI-X and 1 additional interrupt"); else ;
  
#line 638 
  return;
}


#line 645  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static void efx_ptp_send_times(struct efx_nic *efx, struct pps_event_time *last_time)
{
  struct pps_event_time now;
  struct timespec limit;
  struct timespec start;
  int tmp_1;
  
#line 650 
  struct efx_ptp_data *ptp = efx->ptp_data;
  
#line 652 
  int *mc_running = (int *)ptp->start.addr;
  
#line 654 
  pps_get_ts(& now);
  
#line 655 
  start = now.ts_real;
  
#line 656 
  limit = now.ts_real;
  
#line 657 
  timespec_add_ns(& limit,250000ULL);
  
#line 660 
  goto ldv_57103;
  ldv_57102: 
#line 661 
  ;
  {
    struct timespec update_time;
    unsigned int host_time;
    int tmp;
    
#line 666 
    update_time = now.ts_real;
    
#line 667 
    timespec_add_ns(& update_time,200ULL);
    ldv_57100: 
#line 668 
    ;
    
#line 669 
    pps_get_ts(& now);
    
#line 671 
    tmp = timespec_compare((struct timespec const *)(& now.ts_real),(struct timespec const *)(& update_time));
    
#line 671 
    if (tmp < 0) {
      int volatile *tmp_0;
      {
        
#line 671 
        int __var = 0;
        
#line 671 
        tmp_0 = (int volatile *)mc_running;
      }
      
#line 671 
      ;
      
#line 671 
      if (*tmp_0 != 0) 
#line 672 
                       goto ldv_57100; else 
#line 675 
                                            goto ldv_57101;
    }
    else 
#line 675 
         goto ldv_57101;
    ldv_57101: 
#line 676 
    ;
    
#line 674 
    host_time = (unsigned int)((now.ts_real.tv_sec << 30) | now.ts_real.tv_nsec);
    
#line 677 
    (*((efx->type)->ptp_write_host_time))(efx,host_time);
  }
  ldv_57103: 
#line 679 
  ;
  
#line 660 
  tmp_1 = timespec_compare((struct timespec const *)(& now.ts_real),(struct timespec const *)(& limit));
  
#line 660 
  if (tmp_1 < 0) {
    int volatile *tmp_2;
    {
      
#line 661 
      int __var_0 = 0;
      
#line 661 
      tmp_2 = (int volatile *)mc_running;
    }
    
#line 661 
    ;
    
#line 661 
    if (*tmp_2 != 0) 
#line 662 
                     goto ldv_57102; else 
#line 665 
                                          goto ldv_57104;
  }
  else 
#line 665 
       goto ldv_57104;
  ldv_57104: 
#line 666 
  ;
  
#line 679 
  *last_time = now;
  
#line 680 
  return;
}


#line 683  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static void efx_ptp_read_timeset(efx_dword_t *data, struct efx_ptp_timeset *timeset)
{
  unsigned int start_ns;
  unsigned int end_ns;
  
#line 688 
  timeset->host_start = data->u32[0];
  
#line 689 
  timeset->major = (data + 1U)->u32[0];
  
#line 690 
  timeset->minor = (data + 2U)->u32[0];
  
#line 691 
  timeset->host_end = (data + 3U)->u32[0];
  
#line 691 
  timeset->wait = (data + 4U)->u32[0];
  
#line 695 
  start_ns = timeset->host_start & 1073741823U;
  
#line 696 
  end_ns = timeset->host_end & 1073741823U;
  
#line 698 
  if (end_ns < start_ns) 
#line 699 
                         end_ns += 1000000000U; else ;
  
#line 701 
  timeset->window = end_ns - start_ns;
  
#line 702 
  return;
}


#line 713  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static int efx_ptp_process_times(struct efx_nic *efx, efx_dword_t *synch_buf, size_t response_length, struct pps_event_time const *last_time)
{
  int __retres;
  size_t tmp_0;
  unsigned int i;
  u32 last_sec;
  u32 start_sec;
  struct timespec delta;
  ktime_t mc_time;
  struct timespec tmp_2;
  {
    size_t tmp;
    
#line 718 
    size_t __min1 = 12UL;
    
#line 718 
    size_t __min2 = response_length / 20UL;
    
#line 718 
    if (__min1 < __min2) 
#line 718 
                         tmp = __min1; else 
#line 718 
                                            tmp = __min2;
    
#line 718 
    tmp_0 = tmp;
  }
  
#line 717 
  unsigned int number_readings = (unsigned int)tmp_0;
  
#line 721 
  unsigned int ngood = 0U;
  
#line 722 
  unsigned int last_good = 0U;
  
#line 723 
  struct efx_ptp_data *ptp = efx->ptp_data;
  
#line 729 
  if (number_readings == 0U) {
    
#line 730 
    __retres = -11;
    
#line 730 
    goto return_label;
  }
  else ;
  
#line 738 
  i = 0U;
  
#line 738 
  goto ldv_57169;
  ldv_57168: 
#line 739 
  ;
  {
    s32 window;
    s32 corrected;
    struct timespec wait;
    ktime_t tmp_1;
    
#line 742 
    efx_ptp_read_timeset(synch_buf + (unsigned long)i * 20UL,& ptp->timeset[i]);
    
#line 747 
    tmp_1 = (*(ptp->nic_to_kernel_time))(0U,ptp->timeset[i].wait,0);
    
#line 747 
    wait = ns_to_timespec(tmp_1.tv64);
    
#line 749 
    window = (int)ptp->timeset[i].window;
    
#line 750 
    corrected = (int)((long)window - wait.tv_nsec);
    
#line 761 
    if (window <= 199) 
#line 762 
                       ptp->invalid_sync_windows += 1U;
    else 
      
#line 763 
      if (corrected > 999) 
#line 764 
                           ptp->oversize_sync_windows += 1U;
      else 
        
#line 765 
        if (ptp->min_synchronisation_ns > (unsigned int)corrected) 
#line 766 
                                                                   ptp->undersize_sync_windows += 1U;
        else {
          
#line 768 
          ngood += 1U;
          
#line 769 
          last_good = i;
        }
  }
  
#line 738 
  i += 1U;
  ldv_57169: 
#line 739 
  ;
  
#line 738 
  if (i < number_readings) 
#line 740 
                           goto ldv_57168; else 
#line 743 
                                                goto ldv_57170;
  ldv_57170: 
#line 744 
  ;
  
#line 773 
  if (ngood == 0U) {
    
#line 774 
    if ((efx->msg_enable & 1U) != 0U) 
#line 774 
                                      netdev_warn((struct net_device const *)efx->net_dev,"PTP no suitable synchronisations\n"); else ;
    
#line 776 
    __retres = -11;
    
#line 776 
    goto return_label;
  }
  else ;
  
#line 785 
  start_sec = ptp->timeset[last_good].host_start >> 30;
  
#line 786 
  last_sec = (unsigned int)last_time->ts_real.tv_sec & 3U;
  
#line 787 
  if (start_sec != last_sec && ((start_sec + 1U) & 3U) != last_sec) {
    
#line 789 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 789 
                                         netdev_warn((struct net_device const *)efx->net_dev,"PTP bad synchronisation seconds\n"); else ;
    
#line 791 
    __retres = -11;
    
#line 791 
    goto return_label;
  }
  else ;
  
#line 793 
  delta.tv_sec = (long)(last_sec - start_sec) & 1L;
  
#line 794 
  delta.tv_nsec = last_time->ts_real.tv_nsec - ((long)ptp->timeset[last_good].host_start & 1073741823L);
  
#line 802 
  mc_time = (*(ptp->nic_to_kernel_time))(ptp->timeset[last_good].major,ptp->timeset[last_good].minor,0);
  
#line 806 
  tmp_2 = ns_to_timespec(mc_time.tv64);
  
#line 806 
  delta.tv_nsec += tmp_2.tv_nsec;
  
#line 809 
  ptp->host_time_pps = *last_time;
  
#line 810 
  pps_sub_ts(& ptp->host_time_pps,delta);
  
#line 812 
  __retres = 0;
  return_label: 
#line 812 
                return __retres;
}


#line 816  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static int efx_ptp_synchronize(struct efx_nic *efx, unsigned int num_readings)
{
  size_t response_length;
  int rc;
  unsigned long timeout;
  int volatile *tmp;
  unsigned long tmp_0;
  int volatile *tmp_1;
  int tmp_4;
  int volatile *tmp_6;
  
#line 818 
  struct efx_ptp_data *ptp = efx->ptp_data;
  
#line 819 
  efx_dword_t synch_buf[60U] = {{.u32 = {0U}}};
  
#line 823 
  struct pps_event_time last_time = {.ts_real = {.tv_sec = 0L, .tv_nsec = 0L}};
  
#line 824 
  unsigned int loops = 0U;
  
#line 825 
  int *start = (int *)ptp->start.addr;
  
#line 827 
  ((efx_dword_t *)(& synch_buf))->u32[0] = 7U;
  
#line 828 
  ((efx_dword_t *)(& synch_buf) + 1U)->u32[0] = 0U;
  
#line 829 
  ((efx_dword_t *)(& synch_buf) + 2U)->u32[0] = num_readings;
  
#line 831 
  ((efx_dword_t *)(& synch_buf) + 3U)->u32[0] = (unsigned int)ptp->start.dma_addr;
  
#line 831 
  ((efx_dword_t *)(& synch_buf) + 4U)->u32[0] = (unsigned int)(ptp->start.dma_addr >> 32);
  {
    
#line 835 
    int __var = 0;
    
#line 835 
    tmp = (int volatile *)start;
  }
  
#line 835 
  *tmp = 0;
  
#line 836 
  rc = efx_mcdi_rpc_start(efx,11U,(efx_dword_t const *)(& synch_buf),20UL);
  
#line 841 
  tmp_0 = msecs_to_jiffies(2U);
  
#line 841 
  timeout = tmp_0 + jiffies;
  
#line 842 
  goto ldv_57209;
  ldv_57208: 
#line 843 
  ;
  
#line 843 
  __const_udelay(85900UL);
  
#line 844 
  loops += 1U;
  ldv_57209: 
#line 845 
  ;
  {
    
#line 842 
    int __var_0 = 0;
    
#line 842 
    tmp_1 = (int volatile *)start;
  }
  
#line 842 
  ;
  
#line 842 
  if (*tmp_1 == 0) {
    int tmp_2;
    {
      unsigned long __dummy;
      unsigned long __dummy2;
      
#line 842 
      tmp_2 = 1;
    }
    
#line 842 
    if (tmp_2 != 0) {
      int tmp_3;
      {
        unsigned long __dummy_0;
        unsigned long volatile __dummy2_0;
        
#line 842 
        tmp_3 = 1;
      }
      
#line 842 
      if (tmp_3 != 0) {
        
#line 842 
        if ((long)(jiffies - timeout) < 0L) 
#line 844 
                                            goto ldv_57208; else 
#line 847 
                                                                 goto ldv_57210;
      }
      else 
#line 847 
           goto ldv_57210;
    }
    else 
#line 847 
         goto ldv_57210;
  }
  else 
#line 847 
       goto ldv_57210;
  ldv_57210: 
#line 848 
  ;
  
#line 847 
  if (loops <= 1U) 
#line 848 
                   ptp->fast_syncs += 1U; else ;
  {
    unsigned long __dummy_1;
    unsigned long __dummy2_1;
    
#line 849 
    tmp_4 = 1;
  }
  
#line 849 
  if (tmp_4 == 0) 
#line 850 
                  ptp->sync_timeouts += 1U;
  else {
    int tmp_5;
    {
      unsigned long __dummy_2;
      unsigned long volatile __dummy2_2;
      
#line 849 
      tmp_5 = 1;
    }
    
#line 849 
    if (tmp_5 == 0) 
#line 850 
                    ptp->sync_timeouts += 1U;
    else 
      
#line 849 
      if ((long)(jiffies - timeout) >= 0L) 
#line 850 
                                           ptp->sync_timeouts += 1U; else ;
  }
  {
    
#line 852 
    int __var_1 = 0;
    
#line 852 
    tmp_6 = (int volatile *)start;
  }
  
#line 852 
  ;
  
#line 852 
  if (*tmp_6 != 0) 
#line 853 
                   efx_ptp_send_times(efx,& last_time); else ;
  
#line 856 
  rc = efx_mcdi_rpc_finish(efx,11U,20UL,(efx_dword_t *)(& synch_buf),240UL,& response_length);
  
#line 860 
  if (rc == 0) {
    
#line 861 
    rc = efx_ptp_process_times(efx,(efx_dword_t *)(& synch_buf),response_length,(struct pps_event_time const *)(& last_time));
    
#line 863 
    if (rc == 0) 
#line 864 
                 ptp->good_syncs += 1U; else 
#line 866 
                                             ptp->no_time_syncs += 1U;
  }
  else ;
  
#line 872 
  if (rc != 0) 
#line 873 
               ptp->bad_syncs += 1U; else ;
  
#line 875 
  return rc;
}


#line 879  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static int efx_ptp_xmit_skb(struct efx_nic *efx, struct sk_buff *skb)
{
  struct skb_shared_hwtstamps timestamps;
  size_t len;
  unsigned char *tmp;
  
#line 881 
  struct efx_ptp_data *ptp_data = efx->ptp_data;
  
#line 883 
  int rc = -5;
  
#line 884 
  efx_dword_t txtime[2U] = {{.u32 = {0U}}};
  
#line 887 
  ((efx_dword_t *)(& ptp_data->txbuf))->u32[0] = 3U;
  
#line 888 
  ((efx_dword_t *)(& ptp_data->txbuf) + 1U)->u32[0] = 0U;
  
#line 889 
  ((efx_dword_t *)(& ptp_data->txbuf) + 2U)->u32[0] = skb->len;
  
#line 890 
  tmp = skb_end_pointer((struct sk_buff const *)skb);
  
#line 890 
  ;
  
#line 890 
  if ((unsigned int)((struct skb_shared_info *)tmp)->nr_frags != 0U) {
    
#line 891 
    rc = skb_linearize(skb);
    
#line 892 
    if (rc != 0) 
#line 893 
                 goto fail; else ;
  }
  else ;
  
#line 896 
  if ((unsigned int)*((unsigned char *)skb + 145UL) == 6U) {
    
#line 897 
    rc = skb_checksum_help(skb);
    
#line 898 
    if (rc != 0) 
#line 899 
                 goto fail; else ;
  }
  else ;
  
#line 901 
  skb_copy_from_linear_data((struct sk_buff const *)skb,(void *)(& ptp_data->txbuf) + 12U,skb->len);
  
#line 905 
  rc = efx_mcdi_rpc(efx,11U,(efx_dword_t const *)(& ptp_data->txbuf),(unsigned long)(skb->len + 12U),(efx_dword_t *)(& txtime),8UL,& len);
  
#line 908 
  if (rc != 0) 
#line 909 
               goto fail; else ;
  
#line 911 
  memset((void *)(& timestamps),0,8UL);
  
#line 912 
  timestamps.hwtstamp = (*(ptp_data->nic_to_kernel_time))(((efx_dword_t *)(& txtime))->u32[0],((efx_dword_t *)(& txtime) + 1U)->u32[0],ptp_data->ts_corrections.tx);
  
#line 917 
  skb_tstamp_tx(skb,& timestamps);
  
#line 919 
  rc = 0;
  fail: 
#line 921 
  ;
  
#line 922 
  consume_skb(skb);
  
#line 924 
  return rc;
}


#line 927  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static void efx_ptp_drop_time_expired_events(struct efx_nic *efx)
{
  struct list_head *cursor;
  struct list_head *next;
  int tmp_2;
  
#line 929 
  struct efx_ptp_data *ptp = efx->ptp_data;
  
#line 933 
  if ((int)ptp->rx_ts_inline != 0) 
#line 934 
                                   goto return_label; else ;
  
#line 937 
  ldv_spin_lock_bh_97_1(& ptp->evt_lock);
  
#line 938 
  tmp_2 = list_empty((struct list_head const *)(& ptp->evt_list));
  
#line 938 
  if (tmp_2 == 0) {
    
#line 939 
    cursor = ptp->evt_list.next;
    
#line 939 
    next = cursor->next;
    
#line 939 
    goto ldv_57266;
    ldv_57265: 
#line 940 
    ;
    {
      struct efx_ptp_event_rx *evt;
      struct efx_ptp_event_rx *tmp;
      int tmp_0;
      {
        
#line 942 
        struct list_head const *__mptr = (struct list_head const *)cursor;
        
#line 942 
        tmp = (struct efx_ptp_event_rx *)__mptr;
      }
      
#line 942 
      evt = tmp;
      {
        unsigned long __dummy;
        unsigned long volatile __dummy2;
        
#line 944 
        tmp_0 = 1;
      }
      
#line 944 
      if (tmp_0 != 0) {
        int tmp_1;
        {
          unsigned long __dummy_0;
          unsigned long __dummy2_0;
          
#line 944 
          tmp_1 = 1;
        }
        
#line 944 
        if (tmp_1 != 0) {
          
#line 944 
          if ((long)(evt->expiry - jiffies) < 0L) {
            
#line 945 
            list_move(& evt->link,& ptp->evt_free_list);
            
#line 946 
            if ((efx->msg_enable & 8192U) != 0U) 
#line 946 
                                                 netdev_warn((struct net_device const *)efx->net_dev,"PTP rx event dropped\n"); else ;
          }
          else ;
        }
        else ;
      }
      else ;
    }
    
#line 939 
    cursor = next;
    
#line 939 
    next = cursor->next;
    ldv_57266: 
#line 940 
    ;
    
#line 939 
    if (& ptp->evt_list != cursor) 
#line 941 
                                   goto ldv_57265; else 
#line 944 
                                                        goto ldv_57267;
    ldv_57267: 
#line 945 
    ;
  }
  else ;
  
#line 951 
  ldv_spin_unlock_bh_98_0(& ptp->evt_lock);
  return_label: 
#line 952 
                return;
}


#line 954  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static enum ptp_packet_state efx_ptp_match_rx(struct efx_nic *efx, struct sk_buff *skb)
{
  enum ptp_packet_state __retres;
  bool evts_waiting;
  struct list_head *cursor;
  struct list_head *next;
  struct efx_ptp_match *match;
  int tmp_0;
  
#line 957 
  struct efx_ptp_data *ptp = efx->ptp_data;
  
#line 962 
  enum ptp_packet_state rc = PTP_PACKET_STATE_UNMATCHED;
  {
    bool __warned;
    
#line 964 
    int __ret_warn_once = (int)ptp->rx_ts_inline != 0;
    
#line 964 
    if ((long)(__ret_warn_once != 0) != 0L) {
      int tmp;
      {
        
#line 964 
        int __ret_warn_on = ! __warned;
        
#line 964 
        if ((long)(__ret_warn_on != 0) != 0L) 
#line 964 
                                              warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c",964); else ;
        
#line 964 
        tmp = (long)(__ret_warn_on != 0);
      }
      
#line 964 
      if ((long)tmp != 0L) 
#line 964 
                           __warned = (_Bool)1; else ;
    }
    else ;
    
#line 964 
    long tmp_2 = (long)(__ret_warn_once != 0);
  }
  
#line 966 
  ldv_spin_lock_bh_99_0(& ptp->evt_lock);
  
#line 967 
  tmp_0 = list_empty((struct list_head const *)(& ptp->evt_list));
  
#line 967 
  evts_waiting = (_Bool)(tmp_0 == 0);
  
#line 968 
  ldv_spin_unlock_bh_100_0(& ptp->evt_lock);
  
#line 970 
  if (! evts_waiting) {
    
#line 971 
    __retres = PTP_PACKET_STATE_UNMATCHED;
    
#line 971 
    goto return_label;
  }
  else ;
  
#line 973 
  match = (struct efx_ptp_match *)(& skb->cb);
  
#line 975 
  ldv_spin_lock_bh_101_0(& ptp->evt_lock);
  
#line 976 
  cursor = ptp->evt_list.next;
  
#line 976 
  next = cursor->next;
  
#line 976 
  goto ldv_57289;
  ldv_57288: 
#line 977 
  ;
  {
    struct efx_ptp_event_rx *evt;
    struct efx_ptp_event_rx *tmp_1;
    {
      
#line 979 
      struct list_head const *__mptr = (struct list_head const *)cursor;
      
#line 979 
      tmp_1 = (struct efx_ptp_event_rx *)__mptr;
    }
    
#line 979 
    evt = tmp_1;
    
#line 980 
    if (evt->seq0 == match->words[0] && evt->seq1 == match->words[1]) {
      struct skb_shared_hwtstamps *timestamps;
      
#line 985 
      timestamps = skb_hwtstamps(skb);
      
#line 986 
      timestamps->hwtstamp = evt->hwtimestamp;
      
#line 988 
      match->state = PTP_PACKET_STATE_MATCHED;
      
#line 989 
      rc = PTP_PACKET_STATE_MATCHED;
      
#line 990 
      list_move(& evt->link,& ptp->evt_free_list);
      
#line 991 
      goto ldv_57287;
    }
    else ;
  }
  
#line 976 
  cursor = next;
  
#line 976 
  next = cursor->next;
  ldv_57289: 
#line 977 
  ;
  
#line 976 
  if (& ptp->evt_list != cursor) 
#line 978 
                                 goto ldv_57288; else 
#line 981 
                                                      goto ldv_57287;
  ldv_57287: 
#line 982 
  ;
  
#line 994 
  ldv_spin_unlock_bh_102_0(& ptp->evt_lock);
  
#line 996 
  __retres = rc;
  return_label: 
#line 996 
                return __retres;
}


#line 1003  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static void efx_ptp_process_events(struct efx_nic *efx, struct sk_buff_head *q)
{
  struct sk_buff *skb;
  
#line 1005 
  struct efx_ptp_data *ptp = efx->ptp_data;
  
#line 1008 
  goto ldv_57305;
  ldv_57304: 
#line 1009 
  ;
  {
    struct efx_ptp_match *match;
    
#line 1011 
    match = (struct efx_ptp_match *)(& skb->cb);
    
#line 1012 
    if (match->state == (unsigned int)PTP_PACKET_STATE_MATCH_UNWANTED) 
      
#line 1013 
      __skb_queue_tail(q,skb);
    else {
      enum ptp_packet_state tmp_1;
      
#line 1014 
      tmp_1 = efx_ptp_match_rx(efx,skb);
      
#line 1014 
      if (tmp_1 == (unsigned int)PTP_PACKET_STATE_MATCHED) 
#line 1016 
                                                           __skb_queue_tail(q,skb);
      else {
        int tmp;
        {
          unsigned long __dummy;
          unsigned long volatile __dummy2;
          
#line 1017 
          tmp = 1;
        }
        
#line 1017 
        if (tmp != 0) {
          int tmp_0;
          {
            unsigned long __dummy_0;
            unsigned long __dummy2_0;
            
#line 1017 
            tmp_0 = 1;
          }
          
#line 1017 
          if (tmp_0 != 0) {
            
#line 1017 
            if ((long)(match->expiry - jiffies) < 0L) {
              
#line 1018 
              match->state = PTP_PACKET_STATE_TIMED_OUT;
              
#line 1019 
              ptp->rx_no_timestamp += 1U;
              
#line 1020 
              __skb_queue_tail(q,skb);
            }
            else 
#line 1017 
                 goto _LAND_0;
          }
          else 
#line 1017 
               goto _LAND_0;
        }
        else {
          _LAND_0: {
                     
#line 1023 
                     skb_queue_head(& ptp->rxq,skb);
                     
#line 1024 
                     goto ldv_57303;
                   }
        }
      }
    }
  }
  ldv_57305: 
#line 1027 
  ;
  
#line 1008 
  skb = skb_dequeue(& ptp->rxq);
  
#line 1008 
  if (skb != (struct sk_buff *)0) 
#line 1010 
                                  goto ldv_57304; else 
#line 1013 
                                                       goto ldv_57303;
  ldv_57303: 
#line 1014 
  ;
  
#line 1015 
  return;
}


#line 1030  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
__inline static void efx_ptp_process_rx(struct efx_nic *efx, struct sk_buff *skb)
{
  
#line 1032 
  local_bh_disable();
  
#line 1033 
  netif_receive_skb(skb);
  
#line 1034 
  local_bh_enable();
  
#line 1035 
  return;
}


#line 1037  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static void efx_ptp_remove_multicast_filters(struct efx_nic *efx)
{
  
#line 1039 
  struct efx_ptp_data *ptp = efx->ptp_data;
  
#line 1041 
  if ((int)ptp->rxfilter_installed != 0) {
    
#line 1042 
    efx_filter_remove_id_safe(efx,(enum efx_filter_priority)EFX_FILTER_PRI_REQUIRED,ptp->rxfilter_general);
    
#line 1044 
    efx_filter_remove_id_safe(efx,(enum efx_filter_priority)EFX_FILTER_PRI_REQUIRED,ptp->rxfilter_event);
    
#line 1046 
    ptp->rxfilter_installed = (_Bool)0;
  }
  else ;
  
#line 1048 
  return;
}


#line 1050  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static int efx_ptp_insert_multicast_filters(struct efx_nic *efx)
{
  int __retres;
  struct efx_filter_spec rxfilter;
  int rc;
  int tmp_0;
  struct efx_rx_queue *tmp;
  int tmp_2;
  struct efx_rx_queue *tmp_1;
  
#line 1052 
  struct efx_ptp_data *ptp = efx->ptp_data;
  
#line 1056 
  if (ptp->channel == (struct efx_channel *)0 || (int)ptp->rxfilter_installed != 0) {
    
#line 1057 
    __retres = 0;
    
#line 1057 
    goto return_label;
  }
  else ;
  
#line 1063 
  tmp = efx_channel_get_rx_queue(ptp->channel);
  
#line 1063 
  tmp_0 = efx_rx_queue_index(tmp);
  
#line 1062 
  efx_filter_init_rx(& rxfilter,(enum efx_filter_priority)EFX_FILTER_PRI_REQUIRED,(enum efx_filter_flags)0,(unsigned int)tmp_0);
  
#line 1065 
  rc = efx_filter_set_ipv4_local(& rxfilter,(unsigned char)17,2164326624U,(unsigned short)16129);
  
#line 1068 
  if (rc != 0) {
    
#line 1069 
    __retres = rc;
    
#line 1069 
    goto return_label;
  }
  else ;
  
#line 1071 
  rc = efx_filter_insert_filter(efx,& rxfilter,(_Bool)1);
  
#line 1072 
  if (rc < 0) {
    
#line 1073 
    __retres = rc;
    
#line 1073 
    goto return_label;
  }
  else ;
  
#line 1074 
  ptp->rxfilter_event = (unsigned int)rc;
  
#line 1077 
  tmp_1 = efx_channel_get_rx_queue(ptp->channel);
  
#line 1077 
  tmp_2 = efx_rx_queue_index(tmp_1);
  
#line 1076 
  efx_filter_init_rx(& rxfilter,(enum efx_filter_priority)EFX_FILTER_PRI_REQUIRED,(enum efx_filter_flags)0,(unsigned int)tmp_2);
  
#line 1079 
  rc = efx_filter_set_ipv4_local(& rxfilter,(unsigned char)17,2164326624U,(unsigned short)16385);
  
#line 1082 
  if (rc != 0) 
#line 1083 
               goto fail; else ;
  
#line 1085 
  rc = efx_filter_insert_filter(efx,& rxfilter,(_Bool)1);
  
#line 1086 
  if (rc < 0) 
#line 1087 
              goto fail; else ;
  
#line 1088 
  ptp->rxfilter_general = (unsigned int)rc;
  
#line 1090 
  ptp->rxfilter_installed = (_Bool)1;
  
#line 1091 
  __retres = 0;
  
#line 1091 
  goto return_label;
  fail: 
#line 1093 
  ;
  
#line 1094 
  efx_filter_remove_id_safe(efx,(enum efx_filter_priority)EFX_FILTER_PRI_REQUIRED,ptp->rxfilter_event);
  
#line 1096 
  __retres = rc;
  return_label: 
#line 1096 
                return __retres;
}


#line 1099  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static int efx_ptp_start(struct efx_nic *efx)
{
  int __retres;
  int rc;
  
#line 1101 
  struct efx_ptp_data *ptp = efx->ptp_data;
  
#line 1104 
  ptp->reset_required = (_Bool)0;
  
#line 1106 
  rc = efx_ptp_insert_multicast_filters(efx);
  
#line 1107 
  if (rc != 0) {
    
#line 1108 
    __retres = rc;
    
#line 1108 
    goto return_label;
  }
  else ;
  
#line 1110 
  rc = efx_ptp_enable(efx);
  
#line 1111 
  if (rc != 0) 
#line 1112 
               goto fail; else ;
  
#line 1114 
  ptp->evt_frag_idx = 0;
  
#line 1115 
  ptp->current_adjfreq = 0LL;
  
#line 1117 
  __retres = 0;
  
#line 1117 
  goto return_label;
  fail: 
#line 1119 
  ;
  
#line 1120 
  efx_ptp_remove_multicast_filters(efx);
  
#line 1121 
  __retres = rc;
  return_label: 
#line 1121 
                return __retres;
}


#line 1124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static int efx_ptp_stop(struct efx_nic *efx)
{
  int __retres;
  struct list_head *cursor;
  struct list_head *next;
  int rc;
  
#line 1126 
  struct efx_ptp_data *ptp = efx->ptp_data;
  
#line 1131 
  if (ptp == (struct efx_ptp_data *)0) {
    
#line 1132 
    __retres = 0;
    
#line 1132 
    goto return_label;
  }
  else ;
  
#line 1134 
  rc = efx_ptp_disable(efx);
  
#line 1136 
  efx_ptp_remove_multicast_filters(efx);
  
#line 1139 
  efx_ptp_deliver_rx_queue(& (efx->ptp_data)->rxq);
  
#line 1140 
  skb_queue_purge(& (efx->ptp_data)->txq);
  
#line 1143 
  ldv_spin_lock_bh_103_0(& (efx->ptp_data)->evt_lock);
  
#line 1144 
  cursor = (efx->ptp_data)->evt_list.next;
  
#line 1144 
  next = cursor->next;
  
#line 1144 
  goto ldv_57335;
  ldv_57334: 
#line 1145 
  ;
  
#line 1145 
  list_move(cursor,& (efx->ptp_data)->evt_free_list);
  
#line 1144 
  cursor = next;
  
#line 1144 
  next = cursor->next;
  ldv_57335: 
#line 1145 
  ;
  
#line 1144 
  if (& (efx->ptp_data)->evt_list != cursor) 
#line 1146 
                                             goto ldv_57334; else 
#line 1149 
                                                                  goto ldv_57336;
  ldv_57336: 
#line 1150 
  ;
  
#line 1147 
  ldv_spin_unlock_bh_104(& (efx->ptp_data)->evt_lock);
  
#line 1149 
  __retres = rc;
  return_label: 
#line 1149 
                return __retres;
}


#line 1152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static int efx_ptp_restart(struct efx_nic *efx)
{
  int __retres;
  
#line 1154 
  if (efx->ptp_data != (struct efx_ptp_data *)0 && (int)(efx->ptp_data)->enabled != 0) {
    int tmp;
    
#line 1155 
    tmp = efx_ptp_start(efx);
    
#line 1155 
    __retres = tmp;
    
#line 1155 
    goto return_label;
  }
  else ;
  
#line 1156 
  __retres = 0;
  return_label: 
#line 1156 
                return __retres;
}


#line 1159  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static void efx_ptp_pps_worker(struct work_struct *work)
{
  struct efx_ptp_data *tmp;
  struct ptp_clock_event ptp_evt;
  int tmp_0;
  {
    
#line 1162 
    struct work_struct const *__mptr = (struct work_struct const *)work;
    
#line 1162 
    tmp = (struct efx_ptp_data *)__mptr + 18446744073709550616U;
  }
  
#line 1161 
  struct efx_ptp_data *ptp = tmp;
  
#line 1163 
  struct efx_nic *efx = ptp->efx;
  
#line 1166 
  tmp_0 = efx_ptp_synchronize(efx,4U);
  
#line 1166 
  if (tmp_0 != 0) 
#line 1167 
                  goto return_label; else ;
  
#line 1169 
  ptp_evt.type = 3;
  
#line 1170 
  ptp_evt.__anonCompField_ptp_clock_event_110.pps_times = ptp->host_time_pps;
  
#line 1171 
  ptp_clock_event(ptp->phc_clock,& ptp_evt);
  return_label: 
#line 1172 
                return;
}


#line 1174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static void efx_ptp_worker(struct work_struct *work)
{
  struct efx_ptp_data *tmp;
  struct sk_buff *skb;
  struct sk_buff_head tempq;
  {
    
#line 1177 
    struct work_struct const *__mptr = (struct work_struct const *)work;
    
#line 1177 
    tmp = (struct efx_ptp_data *)__mptr + 18446744073709550968U;
  }
  
#line 1176 
  struct efx_ptp_data *ptp_data = tmp;
  
#line 1178 
  struct efx_nic *efx = ptp_data->efx;
  
#line 1182 
  if ((int)ptp_data->reset_required != 0) {
    
#line 1183 
    efx_ptp_stop(efx);
    
#line 1184 
    efx_ptp_start(efx);
    
#line 1185 
    goto return_label;
  }
  else ;
  
#line 1188 
  efx_ptp_drop_time_expired_events(efx);
  
#line 1190 
  __skb_queue_head_init(& tempq);
  
#line 1191 
  efx_ptp_process_events(efx,& tempq);
  
#line 1193 
  goto ldv_57358;
  ldv_57357: 
#line 1194 
  ;
  
#line 1194 
  efx_ptp_xmit_skb(efx,skb);
  ldv_57358: 
#line 1195 
  ;
  
#line 1193 
  skb = skb_dequeue(& ptp_data->txq);
  
#line 1193 
  if (skb != (struct sk_buff *)0) 
#line 1195 
                                  goto ldv_57357; else 
#line 1198 
                                                       goto ldv_57359;
  ldv_57359: 
#line 1199 
  ;
  
#line 1196 
  goto ldv_57361;
  ldv_57360: 
#line 1197 
  ;
  
#line 1197 
  efx_ptp_process_rx(efx,skb);
  ldv_57361: 
#line 1198 
  ;
  
#line 1196 
  skb = __skb_dequeue(& tempq);
  
#line 1196 
  if (skb != (struct sk_buff *)0) 
#line 1198 
                                  goto ldv_57360; else 
#line 1201 
                                                       goto ldv_57362;
  ldv_57362: 
#line 1202 
  ;
  return_label: 
#line 1203 
                return;
}


#line 1200  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static struct ptp_clock_info const efx_phc_clock_info = {.owner = & __this_module, .name = {(char)'s', (char)'f', (char)'c', (char)'\000'}, .max_adj = 1000000, .n_alarm = 0, .n_ext_ts = 0, .n_per_out = 0, .n_pins = 0, .pps = 1, .pin_config = (struct ptp_pin_desc *)0, .adjfreq = & efx_phc_adjfreq, .adjtime = & efx_phc_adjtime, .gettime64 = & efx_phc_gettime, .settime64 = & efx_phc_settime, .enable = & efx_phc_enable, .verify = (int (*)(struct ptp_clock_info *, unsigned int , enum ptp_pin_function , unsigned int ))0};

#line 1217  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
int efx_ptp_probe(struct efx_nic *efx, struct efx_channel *channel)
{
  int __retres;
  struct efx_ptp_data *ptp;
  unsigned int pos;
  int tmp_0;
  struct workqueue_struct *tmp_2;
  
#line 1220 
  int rc = 0;
  
#line 1223 
  ptp = (struct efx_ptp_data *)kzalloc_8(1672UL,208U);
  
#line 1224 
  efx->ptp_data = ptp;
  
#line 1225 
  if (efx->ptp_data == (struct efx_ptp_data *)0) {
    
#line 1226 
    __retres = -12;
    
#line 1226 
    goto return_label;
  }
  else ;
  
#line 1228 
  ptp->efx = efx;
  
#line 1229 
  ptp->channel = channel;
  
#line 1230 
  tmp_0 = efx_nic_rev(efx);
  
#line 1230 
  ptp->rx_ts_inline = (_Bool)(tmp_0 > 3);
  
#line 1232 
  rc = efx_nic_alloc_buffer(efx,& ptp->start,4U,208U);
  
#line 1233 
  if (rc != 0) 
#line 1234 
               goto fail1; else ;
  
#line 1236 
  skb_queue_head_init(& ptp->rxq);
  
#line 1237 
  skb_queue_head_init(& ptp->txq);
  {
    struct lock_class_key __key;
    char const *__lock_name;
    
#line 1238 
    __lock_name = "\"%s\"";
    
#line 1238 
    tmp_2 = __alloc_workqueue_key("%s",131082U,1,& __key,__lock_name,(char *)"sfc_ptp");
  }
  
#line 1238 
  ptp->workwq = tmp_2;
  
#line 1239 
  if (ptp->workwq == (struct workqueue_struct *)0) {
    
#line 1240 
    rc = -12;
    
#line 1241 
    goto fail2;
  }
  else ;
  {
    struct lock_class_key __key_0;
    
#line 1244 
    __init_work(& ptp->work,0);
    
#line 1244 
    atomic_long_t __constr_expr_39 = {.counter = WORK_STRUCT_NO_POOL_0};
    
#line 1244 
    ptp->work.data = __constr_expr_39;
    
#line 1244 
    lockdep_init_map(& ptp->work.lockdep_map,"(&ptp->work)",& __key_0,0);
    
#line 1244 
    INIT_LIST_HEAD(& ptp->work.entry);
    
#line 1244 
    ptp->work.func = & efx_ptp_worker;
  }
  
#line 1245 
  ptp->config.flags = 0;
  
#line 1246 
  ptp->config.tx_type = 0;
  
#line 1247 
  ptp->config.rx_filter = 0;
  
#line 1248 
  INIT_LIST_HEAD(& ptp->evt_list);
  
#line 1249 
  INIT_LIST_HEAD(& ptp->evt_free_list);
  
#line 1250 
  spinlock_check(& ptp->evt_lock);
  {
    struct lock_class_key __key_1;
    
#line 1250 
    __raw_spin_lock_init(& ptp->evt_lock.__anonCompField_spinlock_18.rlock,"&(&ptp->evt_lock)->rlock",& __key_1);
  }
  
#line 1251 
  pos = 0U;
  
#line 1251 
  goto ldv_57380;
  ldv_57379: 
#line 1252 
  ;
  
#line 1252 
  list_add(& ptp->rx_evts[pos].link,& ptp->evt_free_list);
  
#line 1251 
  pos += 1U;
  ldv_57380: 
#line 1252 
  ;
  
#line 1251 
  if (pos <= 7U) 
#line 1253 
                 goto ldv_57379; else 
#line 1256 
                                      goto ldv_57381;
  ldv_57381: 
#line 1257 
  ;
  
#line 1255 
  rc = efx_ptp_get_attributes(efx);
  
#line 1256 
  if (rc < 0) 
#line 1257 
              goto fail3; else ;
  
#line 1260 
  rc = efx_ptp_get_timestamp_corrections(efx);
  
#line 1261 
  if (rc < 0) 
#line 1262 
              goto fail3; else ;
  
#line 1264 
  if (((efx->mcdi)->fn_flags & 1U) != 0U) {
    bool tmp_4;
    struct workqueue_struct *tmp_6;
    
#line 1266 
    ptp->phc_clock_info = efx_phc_clock_info;
    
#line 1267 
    ptp->phc_clock = ptp_clock_register(& ptp->phc_clock_info,& (efx->pci_dev)->dev);
    
#line 1269 
    tmp_4 = IS_ERR_0((void const *)ptp->phc_clock);
    
#line 1269 
    if ((int)tmp_4 != 0) {
      long tmp_3;
      
#line 1270 
      tmp_3 = PTR_ERR_0((void const *)ptp->phc_clock);
      
#line 1270 
      rc = (int)tmp_3;
      
#line 1271 
      goto fail3;
    }
    else ;
    {
      struct lock_class_key __key_2;
      
#line 1274 
      __init_work(& ptp->pps_work,0);
      
#line 1274 
      atomic_long_t __constr_expr_40 = {.counter = WORK_STRUCT_NO_POOL_0};
      
#line 1274 
      ptp->pps_work.data = __constr_expr_40;
      
#line 1274 
      lockdep_init_map(& ptp->pps_work.lockdep_map,"(&ptp->pps_work)",& __key_2,0);
      
#line 1274 
      INIT_LIST_HEAD(& ptp->pps_work.entry);
      
#line 1274 
      ptp->pps_work.func = & efx_ptp_pps_worker;
    }
    {
      struct lock_class_key __key_3;
      char const *__lock_name_0;
      
#line 1275 
      __lock_name_0 = "\"%s\"";
      
#line 1275 
      tmp_6 = __alloc_workqueue_key("%s",131082U,1,& __key_3,__lock_name_0,(char *)"sfc_pps");
    }
    
#line 1275 
    ptp->pps_workwq = tmp_6;
    
#line 1276 
    if (ptp->pps_workwq == (struct workqueue_struct *)0) {
      
#line 1277 
      rc = -12;
      
#line 1278 
      goto fail4;
    }
    else ;
  }
  else ;
  
#line 1281 
  ptp->nic_ts_enabled = (_Bool)0;
  
#line 1283 
  __retres = 0;
  
#line 1283 
  goto return_label;
  fail4: 
#line 1284 
  ;
  
#line 1285 
  ptp_clock_unregister((efx->ptp_data)->phc_clock);
  fail3: 
#line 1287 
  ;
  
#line 1288 
  destroy_workqueue((efx->ptp_data)->workwq);
  fail2: 
#line 1290 
  ;
  
#line 1291 
  efx_nic_free_buffer(efx,& ptp->start);
  fail1: 
#line 1293 
  ;
  
#line 1294 
  kfree((void const *)efx->ptp_data);
  
#line 1295 
  efx->ptp_data = (struct efx_ptp_data *)0;
  
#line 1297 
  __retres = rc;
  return_label: 
#line 1297 
                return __retres;
}


#line 1305  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static int efx_ptp_probe_channel(struct efx_channel *channel)
{
  int tmp;
  
#line 1307 
  struct efx_nic *efx = channel->efx;
  
#line 1309 
  channel->irq_moderation = 0U;
  
#line 1310 
  channel->rx_queue.core_index = 0;
  
#line 1312 
  tmp = efx_ptp_probe(efx,channel);
  
#line 1312 
  return tmp;
}


#line 1315  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
void efx_ptp_remove(struct efx_nic *efx)
{
  
#line 1317 
  if (efx->ptp_data == (struct efx_ptp_data *)0) 
#line 1318 
                                                 goto return_label; else ;
  
#line 1320 
  efx_ptp_disable(efx);
  
#line 1322 
  cancel_work_sync(& (efx->ptp_data)->work);
  
#line 1323 
  cancel_work_sync(& (efx->ptp_data)->pps_work);
  
#line 1325 
  skb_queue_purge(& (efx->ptp_data)->rxq);
  
#line 1326 
  skb_queue_purge(& (efx->ptp_data)->txq);
  
#line 1328 
  if ((efx->ptp_data)->phc_clock != (struct ptp_clock *)0) {
    
#line 1329 
    destroy_workqueue((efx->ptp_data)->pps_workwq);
    
#line 1330 
    ptp_clock_unregister((efx->ptp_data)->phc_clock);
  }
  else ;
  
#line 1333 
  destroy_workqueue((efx->ptp_data)->workwq);
  
#line 1335 
  efx_nic_free_buffer(efx,& (efx->ptp_data)->start);
  
#line 1336 
  kfree((void const *)efx->ptp_data);
  return_label: 
#line 1337 
                return;
}


#line 1339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static void efx_ptp_remove_channel(struct efx_channel *channel)
{
  
#line 1341 
  efx_ptp_remove(channel->efx);
  
#line 1342 
  return;
}


#line 1344  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static void efx_ptp_get_channel_name(struct efx_channel *channel, char *buf, size_t len)
{
  
#line 1347 
  snprintf(buf,len,"%s-ptp",(char *)(& (channel->efx)->name));
  
#line 1348 
  return;
}


#line 1353  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
bool efx_ptp_is_ptp_tx(struct efx_nic *efx, struct sk_buff *skb)
{
  bool __retres;
  int tmp_5;
  
#line 1364 
  if ((((efx->ptp_data != (struct efx_ptp_data *)0 && (int)(efx->ptp_data)->enabled != 0) && skb->len > 62U) && skb->len <= 240U) && (long)((unsigned int)skb->protocol == 8U) != 0L) {
    bool tmp;
    
#line 1359 
    tmp = skb_transport_header_was_set((struct sk_buff const *)skb);
    
#line 1359 
    if ((int)tmp != 0) {
      u32 tmp_0;
      
#line 1360 
      tmp_0 = skb_network_header_len((struct sk_buff const *)skb);
      
#line 1360 
      if (tmp_0 > 19U) {
        struct iphdr *tmp_1;
        
#line 1362 
        tmp_1 = ip_hdr((struct sk_buff const *)skb);
        
#line 1361 
        ;
        
#line 1361 
        if ((unsigned int)tmp_1->protocol == 17U) {
          unsigned int tmp_2;
          int tmp_3;
          
#line 1363 
          tmp_2 = skb_headlen((struct sk_buff const *)skb);
          
#line 1364 
          tmp_3 = skb_transport_offset((struct sk_buff const *)skb);
          
#line 1363 
          if ((unsigned long)tmp_2 >= (unsigned long)tmp_3 + 8UL) {
            struct udphdr *tmp_4;
            
#line 1365 
            tmp_4 = udp_hdr((struct sk_buff const *)skb);
            
#line 1364 
            ;
            
#line 1364 
            if ((unsigned int)tmp_4->dest == 16129U) 
#line 1364 
                                                     tmp_5 = 1; else 
                                                                  
#line 1364 
                                                                  tmp_5 = 0;
          }
          else 
#line 1364 
               tmp_5 = 0;
        }
        else 
#line 1364 
             tmp_5 = 0;
      }
      else 
#line 1364 
           tmp_5 = 0;
    }
    else 
#line 1364 
         tmp_5 = 0;
  }
  else 
#line 1364 
       tmp_5 = 0;
  
#line 1364 
  __retres = (_Bool)(tmp_5 != 0);
  
#line 1364 
  return __retres;
}


#line 1432 
void __compiletime_assert_1432(void);


#line 1433 
void __compiletime_assert_1433(void);


#line 1372  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static bool efx_ptp_rx(struct efx_channel *channel, struct sk_buff *skb)
{
  bool __retres;
  u8 *match_data_012;
  u8 *match_data_345;
  unsigned int version;
  u8 *data;
  unsigned long tmp;
  int tmp_5;
  
#line 1374 
  struct efx_nic *efx = channel->efx;
  
#line 1375 
  struct efx_ptp_data *ptp = efx->ptp_data;
  
#line 1376 
  struct efx_ptp_match *match = (struct efx_ptp_match *)(& skb->cb);
  
#line 1381 
  tmp = msecs_to_jiffies(10U);
  
#line 1381 
  match->expiry = tmp + jiffies;
  
#line 1384 
  if (ptp->mode == 0U) {
    int tmp_0;
    int tmp_2;
    
#line 1385 
    tmp_0 = pskb_may_pull(skb,64U);
    
#line 1385 
    if (tmp_0 == 0) {
      
#line 1386 
      __retres = (_Bool)0;
      
#line 1386 
      goto return_label;
    }
    else ;
    
#line 1388 
    data = skb->data;
    
#line 1389 
    if (0 != 0) 
#line 1389 
                tmp_2 = (int)((unsigned short)(((int)*((__be16 *)(data + 28U)) << 8) | ((int)*((__be16 *)(data + 28U)) >> 8)));
    else {
      __u16 tmp_1;
      
#line 1389 
      tmp_1 = __fswab16((unsigned short)((int)*((__be16 *)(data + 28U))));
      
#line 1389 
      tmp_2 = (int)tmp_1;
    }
    
#line 1389 
    version = (unsigned int)tmp_2;
    
#line 1390 
    if (version != 1U) {
      
#line 1391 
      __retres = (_Bool)0;
      
#line 1391 
      goto return_label;
    }
    else ;
    
#line 1397 
    match_data_012 = data + 50U;
    
#line 1398 
    match_data_345 = data + 53U;
  }
  else {
    int tmp_3;
    
#line 1400 
    tmp_3 = pskb_may_pull(skb,63U);
    
#line 1400 
    if (tmp_3 == 0) {
      
#line 1401 
      __retres = (_Bool)0;
      
#line 1401 
      goto return_label;
    }
    else ;
    
#line 1403 
    data = skb->data;
    
#line 1404 
    version = (unsigned int)*(data + 29U);
    
#line 1405 
    if ((version & 15U) != 2U) {
      
#line 1406 
      __retres = (_Bool)0;
      
#line 1406 
      goto return_label;
    }
    else ;
    
#line 1416 
    match_data_345 = data + 53U;
    
#line 1417 
    if (ptp->mode == 2U) 
#line 1418 
                         match_data_012 = data + 50U;
    else {
      
#line 1420 
      match_data_012 = data + 48U;
      
#line 1421 
      if ((long)(ptp->mode != 4U) != 0L) {
        
#line 1423 
        ldv_inline_asm();
        
#line 1421 
        ;
      }
      else ;
    }
  }
  
#line 1426 
  if (0 != 0) 
#line 1426 
              tmp_5 = (((int)*((__be16 *)(data + 22U)) << 8) | ((int)*((__be16 *)(data + 22U)) >> 8)) == 319;
  else {
    __u16 tmp_4;
    
#line 1426 
    tmp_4 = __fswab16((unsigned short)((int)*((__be16 *)(data + 22U))));
    
#line 1426 
    tmp_5 = (unsigned int)tmp_4 == 319U;
  }
  
#line 1426 
  if (tmp_5) {
    
#line 1427 
    match->state = PTP_PACKET_STATE_UNMATCHED;
    {
      
#line 1432 
      bool __cond = (_Bool)0;
      
#line 1432 
      if ((int)__cond != 0) 
#line 1432 
                            __compiletime_assert_1432(); else ;
    }
    {
      
#line 1433 
      bool __cond_0 = (_Bool)0;
      
#line 1433 
      if ((int)__cond_0 != 0) 
#line 1433 
                              __compiletime_assert_1433(); else ;
    }
    
#line 1436 
    match->words[0] = (unsigned int)((((int)*match_data_012 | ((int)*(match_data_012 + 1U) << 8)) | ((int)*(match_data_012 + 2U) << 16)) | ((int)*match_data_345 << 24));
    
#line 1440 
    match->words[1] = (unsigned int)(((int)*(match_data_345 + 1U) | ((int)*(match_data_345 + 2U) << 8)) | ((int)*(data + 59U) << 16));
  }
  else 
#line 1446 
       match->state = PTP_PACKET_STATE_MATCH_UNWANTED;
  
#line 1449 
  skb_queue_tail(& ptp->rxq,skb);
  
#line 1450 
  ldv_queue_work_105(ptp->workwq,& ptp->work);
  
#line 1452 
  __retres = (_Bool)1;
  return_label: 
#line 1452 
                return __retres;
}


#line 1459  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
int efx_ptp_tx(struct efx_nic *efx, struct sk_buff *skb)
{
  int __retres;
  struct udphdr *tmp;
  
#line 1461 
  struct efx_ptp_data *ptp = efx->ptp_data;
  
#line 1463 
  skb_queue_tail(& ptp->txq,skb);
  
#line 1465 
  tmp = udp_hdr((struct sk_buff const *)skb);
  
#line 1465 
  ;
  
#line 1465 
  if ((unsigned int)tmp->dest == 16129U) {
    
#line 1465 
    if (skb->len <= 240U) 
#line 1467 
                          efx_xmit_hwtstamp_pending(skb); else ;
  }
  else ;
  
#line 1468 
  ldv_queue_work_106(ptp->workwq,& ptp->work);
  
#line 1470 
  __retres = 0;
  
#line 1470 
  return __retres;
}


#line 1473  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
int efx_ptp_get_mode(struct efx_nic *efx)
{
  int __retres;
  
#line 1475 
  __retres = (int)(efx->ptp_data)->mode;
  
#line 1475 
  return __retres;
}


#line 1478  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
int efx_ptp_change_mode(struct efx_nic *efx, bool enable_wanted, unsigned int new_mode)
{
  int __retres;
  
#line 1481 
  if ((int)(efx->ptp_data)->enabled != (int)enable_wanted || ((int)enable_wanted != 0 && (efx->ptp_data)->mode != new_mode)) {
    
#line 1483 
    int rc = 0;
    
#line 1485 
    if ((int)enable_wanted != 0) {
      bool tmp;
      
#line 1487 
      if ((int)(efx->ptp_data)->enabled != 0 && (efx->ptp_data)->mode != new_mode) {
        
#line 1489 
        (efx->ptp_data)->enabled = (_Bool)0;
        
#line 1490 
        rc = efx_ptp_stop(efx);
        
#line 1491 
        if (rc != 0) {
          
#line 1492 
          __retres = rc;
          
#line 1492 
          goto return_label;
        }
        else ;
      }
      else ;
      
#line 1499 
      (efx->ptp_data)->mode = new_mode;
      
#line 1500 
      tmp = netif_running((struct net_device const *)efx->net_dev);
      
#line 1500 
      if ((int)tmp != 0) 
#line 1501 
                         rc = efx_ptp_start(efx); else ;
      
#line 1502 
      if (rc == 0) {
        
#line 1503 
        rc = efx_ptp_synchronize(efx,8U);
        
#line 1505 
        if (rc != 0) 
#line 1506 
                     efx_ptp_stop(efx); else ;
      }
      else ;
    }
    else 
#line 1509 
         rc = efx_ptp_stop(efx);
    
#line 1512 
    if (rc != 0) {
      
#line 1513 
      __retres = rc;
      
#line 1513 
      goto return_label;
    }
    else ;
    
#line 1515 
    (efx->ptp_data)->enabled = enable_wanted;
  }
  else ;
  
#line 1518 
  __retres = 0;
  return_label: 
#line 1518 
                return __retres;
}


#line 1521  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static int efx_ptp_ts_init(struct efx_nic *efx, struct hwtstamp_config *init)
{
  int __retres;
  int rc;
  
#line 1525 
  if (init->flags != 0) {
    
#line 1526 
    __retres = -22;
    
#line 1526 
    goto return_label;
  }
  else ;
  
#line 1528 
  if ((unsigned int)init->tx_type > 1U) {
    
#line 1530 
    __retres = -34;
    
#line 1530 
    goto return_label;
  }
  else ;
  
#line 1532 
  rc = (*((efx->type)->ptp_set_ts_config))(efx,init);
  
#line 1533 
  if (rc != 0) {
    
#line 1534 
    __retres = rc;
    
#line 1534 
    goto return_label;
  }
  else ;
  
#line 1536 
  (efx->ptp_data)->config = *init;
  
#line 1537 
  __retres = 0;
  return_label: 
#line 1537 
                return __retres;
}


#line 1540  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
void efx_ptp_get_ts_info(struct efx_nic *efx, struct ethtool_ts_info *ts_info)
{
  int tmp;
  
#line 1542 
  struct efx_ptp_data *ptp = efx->ptp_data;
  
#line 1543 
  struct efx_nic *primary = efx->primary;
  
#line 1545 
  tmp = rtnl_is_locked();
  
#line 1545 
  if ((long)(tmp == 0) != 0L) {
    
#line 1545 
    printk("\001",(char *)"/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c",1545);
    
#line 1545 
    dump_stack();
  }
  else ;
  
#line 1547 
  if (ptp == (struct efx_ptp_data *)0) 
#line 1548 
                                       goto return_label; else ;
  
#line 1550 
  ts_info->so_timestamping |= 69U;
  
#line 1553 
  if ((primary != (struct efx_nic *)0 && primary->ptp_data != (struct efx_ptp_data *)0) && (primary->ptp_data)->phc_clock != (struct ptp_clock *)0) 
    
#line 1554 
    ts_info->phc_index = ptp_clock_index((primary->ptp_data)->phc_clock); else ;
  
#line 1556 
  ts_info->tx_types = 3U;
  
#line 1557 
  ts_info->rx_filters = ((ptp->efx)->type)->hwtstamp_filters;
  return_label: 
#line 1558 
                return;
}


#line 1560  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
int efx_ptp_set_ts_config(struct efx_nic *efx, struct ifreq *ifr)
{
  int __retres;
  struct hwtstamp_config config;
  int rc;
  unsigned long tmp;
  int tmp_1;
  unsigned long tmp_0;
  
#line 1566 
  if (efx->ptp_data == (struct efx_ptp_data *)0) {
    
#line 1567 
    __retres = -95;
    
#line 1567 
    goto return_label;
  }
  else ;
  
#line 1569 
  tmp = copy_from_user((void *)(& config),(void const *)ifr->ifr_ifru.ifru_data,12UL);
  
#line 1569 
  if (tmp != 0UL) {
    
#line 1570 
    __retres = -14;
    
#line 1570 
    goto return_label;
  }
  else ;
  
#line 1572 
  rc = efx_ptp_ts_init(efx,& config);
  
#line 1573 
  if (rc != 0) {
    
#line 1574 
    __retres = rc;
    
#line 1574 
    goto return_label;
  }
  else ;
  
#line 1577 
  tmp_0 = copy_to_user(ifr->ifr_ifru.ifru_data,(void const *)(& config),12UL);
  
#line 1577 
  if (tmp_0 != 0UL) 
#line 1577 
                    tmp_1 = -14; else 
#line 1577 
                                      tmp_1 = 0;
  
#line 1577 
  __retres = tmp_1;
  return_label: 
#line 1577 
                return __retres;
}


#line 1580  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
int efx_ptp_get_ts_config(struct efx_nic *efx, struct ifreq *ifr)
{
  int __retres;
  int tmp_0;
  unsigned long tmp;
  
#line 1582 
  if (efx->ptp_data == (struct efx_ptp_data *)0) {
    
#line 1583 
    __retres = -95;
    
#line 1583 
    goto return_label;
  }
  else ;
  
#line 1586 
  tmp = copy_to_user(ifr->ifr_ifru.ifru_data,(void const *)(& (efx->ptp_data)->config),12UL);
  
#line 1586 
  if (tmp != 0UL) 
#line 1586 
                  tmp_0 = -14; else 
#line 1586 
                                    tmp_0 = 0;
  
#line 1586 
  __retres = tmp_0;
  return_label: 
#line 1586 
                return __retres;
}


#line 1589  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static void ptp_event_failure(struct efx_nic *efx, int expected_frag_len)
{
  
#line 1591 
  struct efx_ptp_data *ptp = efx->ptp_data;
  
#line 1593 
  if ((efx->msg_enable & 8192U) != 0U) 
#line 1593 
                                       netdev_err((struct net_device const *)efx->net_dev,"PTP unexpected event length: got %d expected %d\n",ptp->evt_frag_idx,expected_frag_len); else ;
  
#line 1596 
  ptp->reset_required = (_Bool)1;
  
#line 1597 
  ldv_queue_work_107(ptp->workwq,& ptp->work);
  
#line 1598 
  return;
}


#line 1604  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static void ptp_event_rx(struct efx_nic *efx, struct efx_ptp_data *ptp)
{
  int tmp_0;
  int tmp_4;
  
#line 1606 
  struct efx_ptp_event_rx *evt = (struct efx_ptp_event_rx *)0;
  {
    bool __warned;
    
#line 1608 
    int __ret_warn_once = (int)ptp->rx_ts_inline != 0;
    
#line 1608 
    if ((long)(__ret_warn_once != 0) != 0L) {
      int tmp;
      {
        
#line 1608 
        int __ret_warn_on = ! __warned;
        
#line 1608 
        if ((long)(__ret_warn_on != 0) != 0L) 
#line 1608 
                                              warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c",1608); else ;
        
#line 1608 
        tmp = (long)(__ret_warn_on != 0);
      }
      
#line 1608 
      if ((long)tmp != 0L) 
#line 1608 
                           __warned = (_Bool)1; else ;
    }
    else ;
    
#line 1608 
    tmp_0 = (long)(__ret_warn_once != 0);
  }
  
#line 1608 
  if ((long)tmp_0 != 0L) 
#line 1609 
                         goto return_label; else ;
  
#line 1611 
  if (ptp->evt_frag_idx != 3) {
    
#line 1612 
    ptp_event_failure(efx,3);
    
#line 1613 
    goto return_label;
  }
  else ;
  
#line 1616 
  ldv_spin_lock_bh_108_0(& ptp->evt_lock);
  
#line 1617 
  tmp_4 = list_empty((struct list_head const *)(& ptp->evt_free_list));
  
#line 1617 
  if (tmp_4 == 0) {
    struct efx_ptp_event_rx *tmp_1;
    unsigned long tmp_2;
    {
      
#line 1618 
      struct list_head const *__mptr = (struct list_head const *)ptp->evt_free_list.next;
      
#line 1618 
      tmp_1 = (struct efx_ptp_event_rx *)__mptr;
    }
    
#line 1618 
    evt = tmp_1;
    
#line 1620 
    list_del(& evt->link);
    
#line 1622 
    evt->seq0 = (unsigned int)ptp->evt_frags[2].u64[0];
    
#line 1623 
    evt->seq1 = (((unsigned int)(ptp->evt_frags[2].u64[0] >> 36) & 255U) | (((unsigned int)(ptp->evt_frags[1].u64[0] >> 36) << 8U) & 65535U)) | (((unsigned int)(ptp->evt_frags[0].u64[0] >> 36) << 16U) & 16711680U);
    
#line 1629 
    evt->hwtimestamp = (*((efx->ptp_data)->nic_to_kernel_time))((unsigned int)ptp->evt_frags[0].u64[0],(unsigned int)ptp->evt_frags[1].u64[0],ptp->ts_corrections.rx);
    
#line 1633 
    tmp_2 = msecs_to_jiffies(10U);
    
#line 1633 
    evt->expiry = tmp_2 + jiffies;
    
#line 1634 
    list_add_tail(& evt->link,& ptp->evt_list);
    
#line 1636 
    ldv_queue_work_109(ptp->workwq,& ptp->work);
  }
  else {
    int tmp_3;
    
#line 1637 
    tmp_3 = net_ratelimit();
    
#line 1637 
    if (tmp_3 != 0) {
      
#line 1639 
      if ((efx->msg_enable & 64U) != 0U) 
#line 1639 
                                         netdev_err((struct net_device const *)efx->net_dev,"PTP event queue overflow\n"); else ;
    }
    else ;
  }
  
#line 1641 
  ldv_spin_unlock_bh_110(& ptp->evt_lock);
  return_label: 
#line 1642 
                return;
}


#line 1644  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static void ptp_event_fault(struct efx_nic *efx, struct efx_ptp_data *ptp)
{
  
#line 1646 
  int code = (int)ptp->evt_frags[0].u64[0];
  
#line 1647 
  if (ptp->evt_frag_idx != 1) {
    
#line 1648 
    ptp_event_failure(efx,1);
    
#line 1649 
    goto return_label;
  }
  else ;
  
#line 1652 
  if ((efx->msg_enable & 8192U) != 0U) 
#line 1652 
                                       netdev_err((struct net_device const *)efx->net_dev,"PTP error %d\n",code); else ;
  return_label: 
#line 1653 
                return;
}


#line 1655  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static void ptp_event_pps(struct efx_nic *efx, struct efx_ptp_data *ptp)
{
  
#line 1657 
  if ((int)ptp->nic_ts_enabled != 0) 
#line 1658 
                                     ldv_queue_work_111(ptp->pps_workwq,& ptp->pps_work); else ;
  
#line 1659 
  return;
}


#line 1661  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
void efx_ptp_event(struct efx_nic *efx, efx_qword_t *ev)
{
  int tmp_0;
  
#line 1663 
  struct efx_ptp_data *ptp = efx->ptp_data;
  
#line 1664 
  int code = (int)(ev->u64[0] >> 44) & 255;
  
#line 1666 
  if (ptp == (struct efx_ptp_data *)0) {
    int tmp;
    
#line 1667 
    tmp = net_ratelimit();
    
#line 1667 
    if (tmp != 0) {
      
#line 1668 
      if ((efx->msg_enable & 1U) != 0U) 
#line 1668 
                                        netdev_warn((struct net_device const *)efx->net_dev,"Received PTP event but PTP not set up\n"); else ;
    }
    else ;
    
#line 1670 
    goto return_label;
  }
  else ;
  
#line 1673 
  if (! ptp->enabled) 
#line 1674 
                      goto return_label; else ;
  
#line 1676 
  if (ptp->evt_frag_idx == 0) 
#line 1677 
                              ptp->evt_code = code;
  else 
    
#line 1678 
    if (ptp->evt_code != code) {
      
#line 1679 
      if ((efx->msg_enable & 8192U) != 0U) 
#line 1679 
                                           netdev_err((struct net_device const *)efx->net_dev,"PTP out of sequence event %d\n",code); else ;
      
#line 1681 
      ptp->evt_frag_idx = 0;
    }
    else ;
  
#line 1684 
  tmp_0 = ptp->evt_frag_idx;
  
#line 1684 
  ptp->evt_frag_idx += 1;
  
#line 1684 
  ptp->evt_frags[tmp_0] = *ev;
  
#line 1685 
  if ((ev->u64[0] & 4294967296ULL) == 0ULL) {
    
#line 1687 
    switch (code) {
      case 13: 
#line 1688 
      ;
      
#line 1689 
      ptp_event_rx(efx,ptp);
      
#line 1690 
      goto ldv_57495;
      case 14: 
#line 1691 
      ;
      
#line 1692 
      ptp_event_fault(efx,ptp);
      
#line 1693 
      goto ldv_57495;
      case 15: 
#line 1694 
      ;
      
#line 1695 
      ptp_event_pps(efx,ptp);
      
#line 1696 
      goto ldv_57495;
      default: 
#line 1697 
      ;
      
#line 1698 
      if ((efx->msg_enable & 8192U) != 0U) 
#line 1698 
                                           netdev_err((struct net_device const *)efx->net_dev,"PTP unknown event %d\n",code); else ;
      
#line 1700 
      goto ldv_57495;
    }
    ldv_57495: 
#line 1702 
    ;
    
#line 1702 
    ptp->evt_frag_idx = 0;
  }
  else 
    
#line 1703 
    if (ptp->evt_frag_idx == 3) {
      
#line 1704 
      if ((efx->msg_enable & 8192U) != 0U) 
#line 1704 
                                           netdev_err((struct net_device const *)efx->net_dev,"PTP too many event fragments\n"); else ;
      
#line 1706 
      ptp->evt_frag_idx = 0;
    }
    else ;
  return_label: 
#line 1708 
                return;
}


#line 1710  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
void efx_time_sync_event(struct efx_channel *channel, efx_qword_t *ev)
{
  
#line 1712 
  channel->sync_timestamp_major = (unsigned int)ev->u64[0];
  
#line 1713 
  channel->sync_timestamp_minor = ((unsigned int)(ev->u64[0] >> 36) << 19U) & 133693440U;
  {
    enum efx_sync_events_state __ret;
    
#line 1718 
    enum efx_sync_events_state __old = SYNC_EVENTS_REQUESTED;
    
#line 1718 
    enum efx_sync_events_state __new = SYNC_EVENTS_VALID;
    
#line 1718 
    switch (4UL) {
      case (unsigned long)1: 
#line 1718 
      ;
      {
        
#line 1718 
        u8 volatile *__ptr = (u8 volatile *)(& channel->sync_events_state);
        
#line 1719 
        ldv_inline_asm();
        
#line 1718 
        goto ldv_57508;
      }
      case (unsigned long)2: 
#line 1718 
      ;
      {
        
#line 1718 
        u16 volatile *__ptr_0 = (u16 volatile *)(& channel->sync_events_state);
        
#line 1719 
        ldv_inline_asm();
        
#line 1718 
        goto ldv_57508;
      }
      case (unsigned long)4: 
#line 1718 
      ;
      {
        
#line 1718 
        u32 volatile *__ptr_1 = (u32 volatile *)(& channel->sync_events_state);
        
#line 1719 
        ldv_inline_asm();
        
#line 1718 
        goto ldv_57508;
      }
      case (unsigned long)8: 
#line 1718 
      ;
      {
        
#line 1718 
        u64 volatile *__ptr_2 = (u64 volatile *)(& channel->sync_events_state);
        
#line 1719 
        ldv_inline_asm();
        
#line 1718 
        goto ldv_57508;
      }
      default: 
#line 1718 
      ;
      
#line 1718 
      __cmpxchg_wrong_size();
    }
    ldv_57508: 
#line 1718 
    ;
    
#line 1718 
    enum efx_sync_events_state tmp = __ret;
  }
  
#line 1720 
  return;
}


#line 1731  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
__inline static u32 efx_rx_buf_timestamp_minor(struct efx_nic *efx, u8 const *eh)
{
  u32 tmp;
  
#line 1734 
  tmp = __le32_to_cpup((__le32 const *)(eh + efx->rx_packet_ts_offset));
  
#line 1734 
  return tmp;
}


#line 1744  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
void __efx_rx_skb_attach_timestamp(struct efx_channel *channel, struct sk_buff *skb)
{
  u32 pkt_timestamp_major;
  u32 pkt_timestamp_minor;
  u32 diff;
  u32 carry;
  struct skb_shared_hwtstamps *timestamps;
  u32 tmp_0;
  unsigned char *tmp;
  
#line 1747 
  struct efx_nic *efx = channel->efx;
  
#line 1753 
  tmp = skb_mac_header((struct sk_buff const *)skb);
  
#line 1752 
  ;
  
#line 1752 
  tmp_0 = efx_rx_buf_timestamp_minor(efx,(u8 const *)tmp);
  
#line 1752 
  pkt_timestamp_minor = (tmp_0 + (unsigned int)(efx->ptp_data)->ts_corrections.rx) & 134217727U;
  
#line 1760 
  diff = (pkt_timestamp_minor - channel->sync_timestamp_minor) & 134217727U;
  
#line 1763 
  carry = (unsigned int)(channel->sync_timestamp_minor + diff > 134217728U);
  
#line 1766 
  if (diff <= 46976204U) 
#line 1771 
                         pkt_timestamp_major = channel->sync_timestamp_major + carry;
  else 
    
#line 1772 
    if (diff > 120795955U) 
#line 1777 
                           pkt_timestamp_major = (channel->sync_timestamp_major + carry) + 4294967295U; else 
                                                                    
#line 1788 
                                                                    goto return_label;
  
#line 1792 
  timestamps = skb_hwtstamps(skb);
  
#line 1793 
  timestamps->hwtstamp = efx_ptp_s27_to_ktime(pkt_timestamp_major,pkt_timestamp_minor);
  return_label: 
#line 1795 
                return;
}


#line 1797  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static int efx_phc_adjfreq(struct ptp_clock_info *ptp, s32 delta)
{
  int __retres;
  struct efx_ptp_data *tmp;
  s64 adjustment_ns;
  int rc;
  {
    
#line 1799 
    struct ptp_clock_info const *__mptr = (struct ptp_clock_info const *)ptp;
    
#line 1799 
    tmp = (struct efx_ptp_data *)__mptr + 18446744073709550720U;
  }
  
#line 1799 
  struct efx_ptp_data *ptp_data = tmp;
  
#line 1802 
  struct efx_nic *efx = ptp_data->efx;
  
#line 1803 
  efx_dword_t inadj[6U] = {{.u32 = {0U}}};
  
#line 1807 
  if (delta > 1000000) 
#line 1808 
                       delta = 1000000;
  else 
    
#line 1809 
    if (delta < -1000000) 
#line 1810 
                          delta = -1000000; else ;
  
#line 1813 
  adjustment_ns = (long long)delta * 4611686018LL >> 22;
  
#line 1816 
  ((efx_dword_t *)(& inadj))->u32[0] = 6U;
  
#line 1817 
  ((efx_dword_t *)(& inadj) + 1U)->u32[0] = 0U;
  
#line 1818 
  ((efx_dword_t *)(& inadj) + 2U)->u32[0] = (unsigned int)adjustment_ns;
  
#line 1818 
  ((efx_dword_t *)(& inadj) + 3U)->u32[0] = (unsigned int)((unsigned long long)adjustment_ns >> 32);
  
#line 1819 
  ((efx_dword_t *)(& inadj) + 4U)->u32[0] = 0U;
  
#line 1820 
  ((efx_dword_t *)(& inadj) + 5U)->u32[0] = 0U;
  
#line 1821 
  rc = efx_mcdi_rpc(efx,11U,(efx_dword_t const *)(& inadj),24UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 1823 
  if (rc != 0) {
    
#line 1824 
    __retres = rc;
    
#line 1824 
    goto return_label;
  }
  else ;
  
#line 1826 
  ptp_data->current_adjfreq = adjustment_ns;
  
#line 1827 
  __retres = 0;
  return_label: 
#line 1827 
                return __retres;
}


#line 1830  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static int efx_phc_adjtime(struct ptp_clock_info *ptp, s64 delta)
{
  u32 nic_major;
  u32 nic_minor;
  struct efx_ptp_data *tmp;
  int tmp_0;
  {
    
#line 1833 
    struct ptp_clock_info const *__mptr = (struct ptp_clock_info const *)ptp;
    
#line 1833 
    tmp = (struct efx_ptp_data *)__mptr + 18446744073709550720U;
  }
  
#line 1833 
  struct efx_ptp_data *ptp_data = tmp;
  
#line 1836 
  struct efx_nic *efx = ptp_data->efx;
  
#line 1837 
  efx_dword_t inbuf[6U] = {{.u32 = {0U}}};
  
#line 1839 
  (*((efx->ptp_data)->ns_to_nic_time))(delta,& nic_major,& nic_minor);
  
#line 1841 
  ((efx_dword_t *)(& inbuf))->u32[0] = 6U;
  
#line 1842 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = 0U;
  
#line 1843 
  ((efx_dword_t *)(& inbuf) + 2U)->u32[0] = (unsigned int)ptp_data->current_adjfreq;
  
#line 1843 
  ((efx_dword_t *)(& inbuf) + 3U)->u32[0] = (unsigned int)((unsigned long long)ptp_data->current_adjfreq >> 32);
  
#line 1844 
  ((efx_dword_t *)(& inbuf) + 4U)->u32[0] = nic_major;
  
#line 1845 
  ((efx_dword_t *)(& inbuf) + 5U)->u32[0] = nic_minor;
  
#line 1846 
  tmp_0 = efx_mcdi_rpc(efx,11U,(efx_dword_t const *)(& inbuf),24UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 1846 
  return tmp_0;
}


#line 1850  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static int efx_phc_gettime(struct ptp_clock_info *ptp, struct timespec *ts)
{
  int __retres;
  struct efx_ptp_data *tmp;
  int rc;
  ktime_t kt;
  {
    
#line 1852 
    struct ptp_clock_info const *__mptr = (struct ptp_clock_info const *)ptp;
    
#line 1852 
    tmp = (struct efx_ptp_data *)__mptr + 18446744073709550720U;
  }
  
#line 1852 
  struct efx_ptp_data *ptp_data = tmp;
  
#line 1855 
  struct efx_nic *efx = ptp_data->efx;
  
#line 1856 
  efx_dword_t inbuf[2U] = {{.u32 = {0U}}};
  
#line 1857 
  efx_dword_t outbuf[2U] = {{.u32 = {0U}}};
  
#line 1861 
  ((efx_dword_t *)(& inbuf))->u32[0] = 4U;
  
#line 1862 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = 0U;
  
#line 1864 
  rc = efx_mcdi_rpc(efx,11U,(efx_dword_t const *)(& inbuf),8UL,(efx_dword_t *)(& outbuf),8UL,(size_t *)0UL);
  
#line 1866 
  if (rc != 0) {
    
#line 1867 
    __retres = rc;
    
#line 1867 
    goto return_label;
  }
  else ;
  
#line 1869 
  kt = (*(ptp_data->nic_to_kernel_time))(((efx_dword_t *)(& outbuf))->u32[0],((efx_dword_t *)(& outbuf) + 1U)->u32[0],0);
  
#line 1872 
  *ts = ns_to_timespec(kt.tv64);
  
#line 1873 
  __retres = 0;
  return_label: 
#line 1873 
                return __retres;
}


#line 1876  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static int efx_phc_settime(struct ptp_clock_info *ptp, struct timespec const *e_ts)
{
  int __retres;
  int rc;
  struct timespec time_now;
  struct timespec delta;
  s64 tmp;
  
#line 1887 
  rc = efx_phc_gettime(ptp,& time_now);
  
#line 1888 
  if (rc != 0) {
    
#line 1889 
    __retres = rc;
    
#line 1889 
    goto return_label;
  }
  else ;
  
#line 1891 
  delta = timespec_sub(*e_ts,time_now);
  
#line 1893 
  tmp = timespec_to_ns((struct timespec const *)(& delta));
  
#line 1893 
  ;
  
#line 1893 
  rc = efx_phc_adjtime(ptp,tmp);
  
#line 1894 
  if (rc != 0) {
    
#line 1895 
    __retres = rc;
    
#line 1895 
    goto return_label;
  }
  else ;
  
#line 1897 
  __retres = 0;
  return_label: 
#line 1897 
                return __retres;
}


#line 1900  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static int efx_phc_enable(struct ptp_clock_info *ptp, struct ptp_clock_request *request, int enable)
{
  int __retres;
  struct efx_ptp_data *tmp;
  {
    
#line 1904 
    struct ptp_clock_info const *__mptr = (struct ptp_clock_info const *)ptp;
    
#line 1904 
    tmp = (struct efx_ptp_data *)__mptr + 18446744073709550720U;
  }
  
#line 1904 
  struct efx_ptp_data *ptp_data = tmp;
  
#line 1907 
  if (request->type != (unsigned int)PTP_CLK_REQ_PPS) {
    
#line 1908 
    __retres = -95;
    
#line 1908 
    goto return_label;
  }
  else ;
  
#line 1910 
  ptp_data->nic_ts_enabled = (_Bool)(enable != 0);
  
#line 1911 
  __retres = 0;
  return_label: 
#line 1911 
                return __retres;
}


#line 1914  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
static struct efx_channel_type const efx_ptp_channel_type = {.handle_no_channel = & efx_ptp_handle_no_channel, .pre_probe = & efx_ptp_probe_channel, .post_remove = & efx_ptp_remove_channel, .get_name = & efx_ptp_get_channel_name, .copy = (struct efx_channel *(*)(struct efx_channel const *))0, .receive_skb = & efx_ptp_rx, .keep_eventq = (_Bool)0};

#line 1924  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
void efx_ptp_defer_probe_with_channel(struct efx_nic *efx)
{
  int tmp;
  
#line 1929 
  tmp = efx_ptp_disable(efx);
  
#line 1929 
  if (tmp == 0) 
#line 1930 
                efx->extra_channel_type[1] = & efx_ptp_channel_type; else ;
  
#line 1932 
  return;
}


#line 1934  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
void efx_ptp_start_datapath(struct efx_nic *efx)
{
  int tmp;
  
#line 1936 
  tmp = efx_ptp_restart(efx);
  
#line 1936 
  if (tmp != 0) {
    
#line 1937 
    if ((efx->msg_enable & 1U) != 0U) 
#line 1937 
                                      netdev_err((struct net_device const *)efx->net_dev,"Failed to restart PTP.\n"); else ;
  }
  else ;
  
#line 1939 
  if ((efx->type)->ptp_set_ts_sync_events != (int (*)(struct efx_nic *, bool , bool ))0) 
    
#line 1940 
    (*((efx->type)->ptp_set_ts_sync_events))(efx,(_Bool)1,(_Bool)1); else ;
  
#line 1941 
  return;
}


#line 1943  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/ptp.c"
void efx_ptp_stop_datapath(struct efx_nic *efx)
{
  
#line 1946 
  if ((efx->type)->ptp_set_ts_sync_events != (int (*)(struct efx_nic *, bool , bool ))0) 
    
#line 1947 
    (*((efx->type)->ptp_set_ts_sync_events))(efx,(_Bool)0,(_Bool)1); else ;
  
#line 1948 
  efx_ptp_stop(efx);
  
#line 1949 
  return;
}


#line 79  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ptp.c.aux"
static long PTR_ERR_0(void const *ptr)
{
  long tmp;
  
#line 82 
  tmp = ldv_ptr_err(ptr);
  
#line 82 
  return tmp;
}


#line 86  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ptp.c.aux"
static bool IS_ERR_0(void const *ptr)
{
  bool __retres;
  long ret;
  
#line 90 
  ret = ldv_is_err(ptr);
  
#line 91 
  __retres = (_Bool)(ret != 0L);
  
#line 91 
  return __retres;
}


#line 441  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ptp.c.aux"
static void *kzalloc_8(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 444 
  tmp = ldv_kzalloc(size,flags);
  
#line 444 
  return tmp;
}


#line 988  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ptp.c.aux"
static void ldv_spin_lock_bh_97_1(spinlock_t *lock)
{
  
#line 992 
  ldv_spin_model_lock((char *)"evt_lock_of_efx_ptp_data");
  
#line 994 
  spin_lock_bh_4(lock);
  
#line 995 
  return;
}


#line 998  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ptp.c.aux"
static void ldv_spin_unlock_bh_98_0(spinlock_t *lock)
{
  
#line 1002 
  ldv_spin_model_unlock((char *)"evt_lock_of_efx_ptp_data");
  
#line 1004 
  spin_unlock_bh_5(lock);
  
#line 1005 
  return;
}


#line 1008  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ptp.c.aux"
static void ldv_spin_lock_bh_99_0(spinlock_t *lock)
{
  
#line 1012 
  ldv_spin_model_lock((char *)"evt_lock_of_efx_ptp_data");
  
#line 1014 
  spin_lock_bh_4(lock);
  
#line 1015 
  return;
}


#line 1018  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ptp.c.aux"
static void ldv_spin_unlock_bh_100_0(spinlock_t *lock)
{
  
#line 1022 
  ldv_spin_model_unlock((char *)"evt_lock_of_efx_ptp_data");
  
#line 1024 
  spin_unlock_bh_5(lock);
  
#line 1025 
  return;
}


#line 1028  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ptp.c.aux"
static void ldv_spin_lock_bh_101_0(spinlock_t *lock)
{
  
#line 1032 
  ldv_spin_model_lock((char *)"evt_lock_of_efx_ptp_data");
  
#line 1034 
  spin_lock_bh_4(lock);
  
#line 1035 
  return;
}


#line 1038  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ptp.c.aux"
static void ldv_spin_unlock_bh_102_0(spinlock_t *lock)
{
  
#line 1042 
  ldv_spin_model_unlock((char *)"evt_lock_of_efx_ptp_data");
  
#line 1044 
  spin_unlock_bh_5(lock);
  
#line 1045 
  return;
}


#line 1048  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ptp.c.aux"
static void ldv_spin_lock_bh_103_0(spinlock_t *lock)
{
  
#line 1052 
  ldv_spin_model_lock((char *)"evt_lock_of_efx_ptp_data");
  
#line 1054 
  spin_lock_bh_4(lock);
  
#line 1055 
  return;
}


#line 1058  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ptp.c.aux"
static void ldv_spin_unlock_bh_104(spinlock_t *lock)
{
  
#line 1062 
  ldv_spin_model_unlock((char *)"evt_lock_of_efx_ptp_data");
  
#line 1064 
  spin_unlock_bh_5(lock);
  
#line 1065 
  return;
}


#line 1068  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ptp.c.aux"
static bool ldv_queue_work_105(struct workqueue_struct *wq, struct work_struct *work)
{
  bool __retres;
  bool tmp;
  
#line 1072 
  tmp = ldv_emg_queue_work(wq,work);
  
#line 1072 
  __retres = tmp != 0;
  
#line 1072 
  return __retres;
}


#line 1076  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ptp.c.aux"
static bool ldv_queue_work_106(struct workqueue_struct *wq, struct work_struct *work)
{
  bool __retres;
  bool tmp;
  
#line 1080 
  tmp = ldv_emg_queue_work(wq,work);
  
#line 1080 
  __retres = tmp != 0;
  
#line 1080 
  return __retres;
}


#line 1084  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ptp.c.aux"
static bool ldv_queue_work_107(struct workqueue_struct *wq, struct work_struct *work)
{
  bool __retres;
  bool tmp;
  
#line 1088 
  tmp = ldv_emg_queue_work(wq,work);
  
#line 1088 
  __retres = tmp != 0;
  
#line 1088 
  return __retres;
}


#line 1092  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ptp.c.aux"
static void ldv_spin_lock_bh_108_0(spinlock_t *lock)
{
  
#line 1096 
  ldv_spin_model_lock((char *)"evt_lock_of_efx_ptp_data");
  
#line 1098 
  spin_lock_bh_4(lock);
  
#line 1099 
  return;
}


#line 1102  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ptp.c.aux"
static bool ldv_queue_work_109(struct workqueue_struct *wq, struct work_struct *work)
{
  bool __retres;
  bool tmp;
  
#line 1106 
  tmp = ldv_emg_queue_work(wq,work);
  
#line 1106 
  __retres = tmp != 0;
  
#line 1106 
  return __retres;
}


#line 1110  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ptp.c.aux"
static void ldv_spin_unlock_bh_110(spinlock_t *lock)
{
  
#line 1114 
  ldv_spin_model_unlock((char *)"evt_lock_of_efx_ptp_data");
  
#line 1116 
  spin_unlock_bh_5(lock);
  
#line 1117 
  return;
}


#line 1120  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_ptp.c.aux"
static bool ldv_queue_work_111(struct workqueue_struct *wq, struct work_struct *work)
{
  bool __retres;
  bool tmp;
  
#line 1124 
  tmp = ldv_emg_queue_work(wq,work);
  
#line 1124 
  __retres = tmp != 0;
  
#line 1124 
  return __retres;
}


#line 581  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kzalloc_9(size_t size, gfp_t flags);


#line 151  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tenxpress.c"
static int tenxpress_init(struct efx_nic *efx)
{
  int __retres;
  
#line 154 
  efx_mdio_write(efx,3,55303,8);
  
#line 158 
  efx_mdio_set_flag(efx,1,49159,8,(_Bool)1);
  
#line 160 
  efx_mdio_write(efx,1,49161,128);
  
#line 163 
  __retres = 0;
  
#line 163 
  return __retres;
}


#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tenxpress.c"
static int tenxpress_phy_probe(struct efx_nic *efx)
{
  int __retres;
  struct tenxpress_phy_data *phy_data;
  
#line 171 
  phy_data = (struct tenxpress_phy_data *)kzalloc_9(12UL,208U);
  
#line 172 
  if (phy_data == (struct tenxpress_phy_data *)0) {
    
#line 173 
    __retres = -12;
    
#line 173 
    goto return_label;
  }
  else ;
  
#line 174 
  efx->phy_data = (void *)phy_data;
  
#line 175 
  phy_data->phy_mode = efx->phy_mode;
  
#line 177 
  efx->mdio.mmds = 154U;
  
#line 178 
  efx->mdio.mode_support = 2U;
  
#line 180 
  efx->loopback_modes = 67338296ULL;
  
#line 182 
  efx->link_advertising = 4288U;
  
#line 185 
  __retres = 0;
  return_label: 
#line 185 
                return __retres;
}


#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tenxpress.c"
static int tenxpress_phy_init(struct efx_nic *efx)
{
  int __retres;
  int rc;
  struct falcon_board *tmp;
  
#line 192 
  tmp = falcon_board(efx);
  
#line 192 
  (*((tmp->type)->init_phy))(efx);
  
#line 194 
  if (((unsigned int)efx->phy_mode & 8U) == 0U) {
    
#line 195 
    rc = efx_mdio_wait_reset_mmds(efx,154U);
    
#line 196 
    if (rc < 0) {
      
#line 197 
      __retres = rc;
      
#line 197 
      goto return_label;
    }
    else ;
    
#line 199 
    rc = efx_mdio_check_mmds(efx,154U);
    
#line 200 
    if (rc < 0) {
      
#line 201 
      __retres = rc;
      
#line 201 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 204 
  rc = tenxpress_init(efx);
  
#line 205 
  if (rc < 0) {
    
#line 206 
    __retres = rc;
    
#line 206 
    goto return_label;
  }
  else ;
  
#line 209 
  efx_link_set_wanted_fc(efx,(unsigned char)((int)efx->wanted_fc));
  
#line 210 
  efx_mdio_an_reconfigure(efx);
  
#line 212 
  schedule_timeout_uninterruptible(50L);
  
#line 215 
  falcon_reset_xaui(efx);
  
#line 217 
  __retres = 0;
  return_label: 
#line 217 
                return __retres;
}


#line 223  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tenxpress.c"
static int tenxpress_special_reset(struct efx_nic *efx)
{
  int rc;
  int reg;
  
#line 230 
  falcon_stop_nic_stats(efx);
  
#line 233 
  reg = efx_mdio_read(efx,1,49152);
  
#line 234 
  reg |= 32768;
  
#line 235 
  efx_mdio_write(efx,1,49152,reg);
  {
    
#line 237 
    unsigned long __ms = 200UL;
    {
      unsigned long tmp;
      
#line 237 
      goto ldv_55581;
      ldv_55580: 
#line 238 
      ;
      
#line 237 
      __const_udelay(4295000UL);
      ldv_55581: 
#line 239 
      ;
      
#line 237 
      tmp = __ms;
      
#line 237 
      __ms -= 1UL;
      
#line 237 
      ;
      
#line 237 
      if (tmp != 0UL) 
#line 239 
                      goto ldv_55580; else 
#line 242 
                                           goto ldv_55582;
      ldv_55582: 
#line 243 
      ;
    }
  }
  
#line 240 
  rc = efx_mdio_wait_reset_mmds(efx,154U);
  
#line 241 
  if (rc < 0) 
#line 242 
              goto out; else ;
  
#line 245 
  rc = tenxpress_init(efx);
  
#line 246 
  if (rc < 0) 
#line 247 
              goto out; else ;
  {
    
#line 250 
    unsigned long __ms_0 = 10UL;
    {
      unsigned long tmp_0;
      
#line 250 
      goto ldv_55586;
      ldv_55585: 
#line 251 
      ;
      
#line 250 
      __const_udelay(4295000UL);
      ldv_55586: 
#line 252 
      ;
      
#line 250 
      tmp_0 = __ms_0;
      
#line 250 
      __ms_0 -= 1UL;
      
#line 250 
      ;
      
#line 250 
      if (tmp_0 != 0UL) 
#line 252 
                        goto ldv_55585; else 
#line 255 
                                             goto ldv_55587;
      ldv_55587: 
#line 256 
      ;
    }
  }
  out: 
#line 251 
  ;
  
#line 252 
  falcon_start_nic_stats(efx);
  
#line 253 
  return rc;
}


#line 256  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tenxpress.c"
static void sfx7101_check_bad_lp(struct efx_nic *efx, bool link_ok)
{
  bool bad_lp;
  int reg;
  
#line 258 
  struct tenxpress_phy_data *pd = (struct tenxpress_phy_data *)efx->phy_data;
  
#line 262 
  if ((int)link_ok != 0) 
#line 263 
                         bad_lp = (_Bool)0;
  else {
    
#line 266 
    reg = efx_mdio_read(efx,7,1);
    
#line 267 
    if ((reg & 1) == 0) 
#line 268 
                        goto return_label; else ;
    
#line 269 
    bad_lp = (_Bool)((reg & 32) == 0);
    
#line 270 
    if ((int)bad_lp != 0) 
#line 271 
                          pd->bad_lp_tries += 1; else ;
  }
  
#line 275 
  if (pd->bad_lp_tries == 0) 
#line 276 
                             goto return_label; else ;
  
#line 280 
  if (! bad_lp || pd->bad_lp_tries == 5) {
    
#line 281 
    reg = efx_mdio_read(efx,1,49161);
    
#line 283 
    reg &= -193;
    
#line 284 
    if (! bad_lp) 
#line 285 
                  reg |= 128;
    else {
      
#line 287 
      reg |= 192;
      
#line 288 
      if ((efx->msg_enable & 4U) != 0U) 
#line 288 
                                        netdev_err((struct net_device const *)efx->net_dev,"appears to be plugged into a port"); else ;
    }
    
#line 294 
    efx_mdio_write(efx,1,49161,reg);
    
#line 296 
    pd->bad_lp_tries = (int)bad_lp;
  }
  else ;
  return_label: 
#line 298 
                return;
}


#line 300  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tenxpress.c"
static bool sfx7101_link_ok(struct efx_nic *efx)
{
  bool tmp;
  
#line 302 
  tmp = efx_mdio_links_ok(efx,26U);
  
#line 302 
  return tmp;
}


#line 308  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tenxpress.c"
static void tenxpress_ext_loopback(struct efx_nic *efx)
{
  
#line 310 
  efx_mdio_set_flag(efx,4,49162,256,(_Bool)(efx->loopback_mode == (unsigned int)LOOPBACK_PHYXS));
  
#line 313 
  return;
}


#line 315  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tenxpress.c"
static void tenxpress_low_power(struct efx_nic *efx)
{
  
#line 317 
  efx_mdio_set_mmds_lpower(efx,((unsigned int)efx->phy_mode & 2U) != 0U,154U);
  
#line 319 
  return;
}


#line 322  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tenxpress.c"
static int tenxpress_phy_reconfigure(struct efx_nic *efx)
{
  int __retres;
  bool phy_mode_change;
  bool loop_reset;
  
#line 324 
  struct tenxpress_phy_data *phy_data = (struct tenxpress_phy_data *)efx->phy_data;
  
#line 327 
  if (((unsigned int)efx->phy_mode & 12U) != 0U) {
    
#line 328 
    phy_data->phy_mode = efx->phy_mode;
    
#line 329 
    __retres = 0;
    
#line 329 
    goto return_label;
  }
  else ;
  
#line 332 
  phy_mode_change = (_Bool)((efx->phy_mode == (unsigned int)PHY_MODE_NORMAL && phy_data->phy_mode != (unsigned int)PHY_MODE_NORMAL) != 0);
  
#line 334 
  loop_reset = (_Bool)((((((unsigned long long)(1 << (unsigned int)phy_data->loopback_mode) & efx->loopback_modes) & 18446744073642950656ULL) != 0ULL && (((unsigned long long)(1 << (unsigned int)efx->loopback_mode) & efx->loopback_modes) & 18446744073642950656ULL) == 0ULL) || (((1 << (unsigned int)phy_data->loopback_mode) ^ (1 << (unsigned int)efx->loopback_mode)) & 16384) != 0) != 0);
  
#line 337 
  if ((int)loop_reset != 0 || (int)phy_mode_change != 0) {
    
#line 338 
    tenxpress_special_reset(efx);
    
#line 339 
    falcon_reset_xaui(efx);
  }
  else ;
  
#line 342 
  tenxpress_low_power(efx);
  
#line 343 
  efx_mdio_transmit_disable(efx);
  
#line 344 
  efx_mdio_phy_reconfigure(efx);
  
#line 345 
  tenxpress_ext_loopback(efx);
  
#line 346 
  efx_mdio_an_reconfigure(efx);
  
#line 348 
  phy_data->loopback_mode = efx->loopback_mode;
  
#line 349 
  phy_data->phy_mode = efx->phy_mode;
  
#line 351 
  __retres = 0;
  return_label: 
#line 351 
                return __retres;
}


#line 355 
static void tenxpress_get_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd);


#line 358  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tenxpress.c"
static bool tenxpress_phy_poll(struct efx_nic *efx)
{
  bool __retres;
  int tmp_0;
  bool tmp;
  
#line 360 
  struct efx_link_state old_state = efx->link_state;
  
#line 362 
  efx->link_state.up = sfx7101_link_ok(efx);
  
#line 363 
  efx->link_state.speed = 10000U;
  
#line 364 
  efx->link_state.fd = (_Bool)1;
  
#line 365 
  efx->link_state.fc = efx_mdio_get_pause(efx);
  
#line 367 
  sfx7101_check_bad_lp(efx,(_Bool)((bool)((int)efx->link_state.up) != 0));
  
#line 369 
  tmp = efx_link_state_equal((struct efx_link_state const *)(& efx->link_state),(struct efx_link_state const *)(& old_state));
  
#line 369 
  if ((int)tmp != 0) 
#line 369 
                     tmp_0 = 0; else 
#line 369 
                                     tmp_0 = 1;
  
#line 369 
  __retres = (_Bool)(tmp_0 != 0);
  
#line 369 
  return __retres;
}


#line 372  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tenxpress.c"
static void sfx7101_phy_fini(struct efx_nic *efx)
{
  int reg;
  
#line 377 
  reg = 256;
  
#line 378 
  efx_mdio_write(efx,1,49152,reg);
  
#line 383 
  schedule_timeout_uninterruptible(50L);
  
#line 384 
  return;
}


#line 386  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tenxpress.c"
static void tenxpress_phy_remove(struct efx_nic *efx)
{
  
#line 388 
  kfree((void const *)efx->phy_data);
  
#line 389 
  efx->phy_data = (void *)0;
  
#line 390 
  return;
}


#line 394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tenxpress.c"
void tenxpress_set_id_led(struct efx_nic *efx, enum efx_led_mode mode)
{
  int reg;
  
#line 398 
  switch ((unsigned int)mode) {
    case (unsigned int)0: 
#line 399 
    ;
    
#line 400 
    reg = 162;
    
#line 403 
    goto ldv_55630;
    case (unsigned int)1: 
#line 404 
    ;
    
#line 405 
    reg = 81;
    
#line 408 
    goto ldv_55630;
    default: 
#line 409 
    ;
    
#line 410 
    reg = 128;
    
#line 411 
    goto ldv_55630;
  }
  ldv_55630: 
#line 414 
  ;
  
#line 414 
  efx_mdio_write(efx,1,49161,reg);
  
#line 415 
  return;
}


#line 417  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tenxpress.c"
static char const * const sfx7101_test_names[1U] = {"bist"};

#line 421  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tenxpress.c"
static char const *sfx7101_test_name(struct efx_nic *efx, unsigned int index)
{
  char const *__retres;
  
#line 423 
  if (index == 0U) {
    
#line 424 
    __retres = sfx7101_test_names[index];
    
#line 424 
    goto return_label;
  }
  else ;
  
#line 425 
  __retres = (char const *)0;
  return_label: 
#line 425 
                return __retres;
}


#line 429  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tenxpress.c"
static int sfx7101_run_tests(struct efx_nic *efx, int *results, unsigned int flags)
{
  int __retres;
  int rc;
  
#line 433 
  if ((flags & 1U) == 0U) {
    
#line 434 
    __retres = 0;
    
#line 434 
    goto return_label;
  }
  else ;
  
#line 437 
  rc = tenxpress_special_reset(efx);
  
#line 438 
  if (rc != 0) 
#line 438 
               *results = -1; else 
#line 438 
                                   *results = 1;
  
#line 440 
  efx_mdio_an_reconfigure(efx);
  
#line 442 
  __retres = rc;
  return_label: 
#line 442 
                return __retres;
}


#line 446  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tenxpress.c"
static void tenxpress_get_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd)
{
  int reg;
  
#line 448 
  u32 adv = 0U;
  
#line 448 
  u32 lpa = 0U;
  
#line 451 
  reg = efx_mdio_read(efx,7,32);
  
#line 452 
  if ((reg & 4096) != 0) 
#line 453 
                         adv |= 4096U; else ;
  
#line 454 
  reg = efx_mdio_read(efx,7,33);
  
#line 455 
  if ((reg & 2048) != 0) 
#line 456 
                         lpa |= 4096U; else ;
  
#line 458 
  mdio45_ethtool_gset_npage((struct mdio_if_info const *)(& efx->mdio),ecmd,adv,lpa);
  
#line 462 
  if ((((unsigned long long)(1 << (unsigned int)efx->loopback_mode) & efx->loopback_modes) & 18446744073642950656ULL) != 0ULL) 
    
#line 463 
    ethtool_cmd_speed_set(ecmd,10000U); else ;
  
#line 464 
  return;
}


#line 466  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tenxpress.c"
static int tenxpress_set_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd)
{
  int __retres;
  int tmp;
  
#line 468 
  if ((unsigned int)ecmd->autoneg == 0U) {
    
#line 469 
    __retres = -22;
    
#line 469 
    goto return_label;
  }
  else ;
  
#line 471 
  tmp = efx_mdio_set_settings(efx,ecmd);
  
#line 471 
  __retres = tmp;
  return_label: 
#line 471 
                return __retres;
}


#line 474  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tenxpress.c"
static void sfx7101_set_npage_adv(struct efx_nic *efx, u32 advertising)
{
  
#line 476 
  efx_mdio_set_flag(efx,7,32,4096,(_Bool)((advertising & 4096U) != 0U));
  
#line 479 
  return;
}


#line 481  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/tenxpress.c"
struct efx_phy_operations const falcon_sfx7101_phy_ops = {.probe = & tenxpress_phy_probe, .init = & tenxpress_phy_init, .fini = & sfx7101_phy_fini, .remove = & tenxpress_phy_remove, .reconfigure = & tenxpress_phy_reconfigure, .poll = & tenxpress_phy_poll, .get_settings = & tenxpress_get_settings, .set_settings = & tenxpress_set_settings, .set_npage_adv = & sfx7101_set_npage_adv, .test_alive = & efx_mdio_test_alive, .test_name = & sfx7101_test_name, .run_tests = & sfx7101_run_tests, .get_module_eeprom = (int (*)(struct efx_nic *, struct ethtool_eeprom *, u8 *))0, .get_module_info = (int (*)(struct efx_nic *, struct ethtool_modinfo *))0};

#line 618  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_tenxpress.c.aux"
static void *kzalloc_9(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 621 
  tmp = ldv_kzalloc(size,flags);
  
#line 621 
  return tmp;
}


#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/log2.h"
__inline static int __ilog2_u64(u64 n)
{
  int __retres;
  int tmp;
  
#line 42 
  tmp = fls64(n);
  
#line 42 
  __retres = tmp + -1;
  
#line 42 
  return __retres;
}


#line 409  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
int scnprintf(char *, size_t, char const * , ...);


#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/percpu.h"
extern unsigned long __per_cpu_offset[8192U];


#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/getorder.h"
__inline static int __get_order(unsigned long size)
{
  int order;
  
#line 17 
  size -= 1UL;
  
#line 18 
  size >>= 12;
  
#line 22 
  order = fls64((unsigned long long)size);
  
#line 24 
  return order;
}


#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
int strcmp(char const *, char const *);


#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitmap.h"
void __bitmap_or(unsigned long *, unsigned long const *, unsigned long const *, unsigned int);


#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitmap.h"
__inline static void bitmap_or(unsigned long *dst, unsigned long const *src1, unsigned long const *src2, unsigned int nbits)
{
  
#line 223 
  if (0 != 0 && nbits <= 64U) 
#line 224 
                              *dst = *src1 | *src2; else 
#line 226 
                                                         __bitmap_or(dst,src1,src2,nbits);
  
#line 227 
  return;
}


#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
extern int nr_cpu_ids;


#line 89 
extern struct cpumask const * const cpu_online_mask;


#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
__inline static unsigned int cpumask_check(unsigned int cpu)
{
  {
    bool __warned;
    
#line 117 
    int __ret_warn_once = cpu >= (unsigned int)nr_cpu_ids;
    
#line 117 
    if ((long)(__ret_warn_once != 0) != 0L) {
      int tmp;
      {
        
#line 117 
        int __ret_warn_on = ! __warned;
        
#line 117 
        if ((long)(__ret_warn_on != 0) != 0L) 
#line 117 
                                              warn_slowpath_null("include/linux/cpumask.h",117); else ;
        
#line 117 
        tmp = (long)(__ret_warn_on != 0);
      }
      
#line 117 
      if ((long)tmp != 0L) 
#line 117 
                           __warned = (_Bool)1; else ;
    }
    else ;
    
#line 117 
    long tmp_2 = (long)(__ret_warn_once != 0);
  }
  
#line 119 
  return cpu;
}


#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
__inline static unsigned int cpumask_next(int n, struct cpumask const *srcp)
{
  unsigned int __retres;
  unsigned long tmp;
  
#line 187 
  if (n != -1) 
#line 188 
               cpumask_check((unsigned int)n); else ;
  
#line 189 
  tmp = find_next_bit((unsigned long const *)(& srcp->bits),(unsigned long)nr_cpu_ids,(unsigned long)(n + 1));
  
#line 189 
  __retres = (unsigned int)tmp;
  
#line 189 
  return __retres;
}


#line 292  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
__inline static int cpumask_test_cpu(int cpu, struct cpumask const *cpumask)
{
  int tmp_0;
  unsigned int tmp;
  
#line 294 
  ;
  
#line 294 
  tmp = cpumask_check((unsigned int)cpu);
  
#line 294 
  tmp_0 = variable_test_bit((long)tmp,(unsigned long const volatile *)(& cpumask->bits));
  
#line 294 
  return tmp_0;
}


#line 365  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
__inline static void cpumask_or(struct cpumask *dstp, struct cpumask const *src1p, struct cpumask const *src2p)
{
  
#line 368 
  bitmap_or((unsigned long *)(& dstp->bits),(unsigned long const *)(& src1p->bits),(unsigned long const *)(& src2p->bits),(unsigned int)nr_cpu_ids);
  
#line 370 
  return;
}


#line 659 
bool zalloc_cpumask_var(cpumask_var_t **, gfp_t);


#line 661 
void free_cpumask_var(cpumask_var_t);


#line 98  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/atomic.h"
static void atomic_inc_4(atomic_t *v);


#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_5(spinlock_t *lock)
{
  
#line 312 
  _raw_spin_lock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 313 
  return;
}


#line 346 
static void ldv_spin_lock_62_3(spinlock_t *lock);


#line 350 
static void ldv_spin_lock_67_3(spinlock_t *lock);


#line 355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_bh_5(spinlock_t *lock)
{
  
#line 357 
  _raw_spin_lock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 358 
  return;
}


#line 379 
static void ldv_spin_lock_bh_71_1(spinlock_t *lock);


#line 383 
static void ldv_spin_lock_bh_75(spinlock_t *lock);


#line 387 
static void ldv_spin_lock_bh_77(spinlock_t *lock);


#line 391 
static void ldv_spin_lock_bh_79(spinlock_t *lock);


#line 395 
static void ldv_spin_lock_bh_81(spinlock_t *lock);


#line 399 
static void ldv_spin_lock_bh_83(spinlock_t *lock);


#line 403 
static void ldv_spin_lock_bh_85(spinlock_t *lock);


#line 407 
static void ldv_spin_lock_bh_103_1(spinlock_t *lock);


#line 411 
static void ldv_spin_lock_bh_105_0(spinlock_t *lock);


#line 415 
static void ldv_spin_lock_bh_110_1(spinlock_t *lock);


#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_5(spinlock_t *lock)
{
  
#line 365 
  _raw_spin_unlock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 366 
  return;
}


#line 395 
static void ldv_spin_unlock_65_3(spinlock_t *lock);


#line 399 
static void ldv_spin_unlock_68_3(spinlock_t *lock);


#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_bh_6(spinlock_t *lock)
{
  
#line 406 
  _raw_spin_unlock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 407 
  return;
}


#line 428 
static void ldv_spin_unlock_bh_73_1(spinlock_t *lock);


#line 436 
static void ldv_spin_unlock_bh_76(spinlock_t *lock);


#line 440 
static void ldv_spin_unlock_bh_78(spinlock_t *lock);


#line 444 
static void ldv_spin_unlock_bh_80(spinlock_t *lock);


#line 448 
static void ldv_spin_unlock_bh_82(spinlock_t *lock);


#line 452 
static void ldv_spin_unlock_bh_84(spinlock_t *lock);


#line 456 
static void ldv_spin_unlock_bh_86(spinlock_t *lock);


#line 460 
static void ldv_spin_unlock_bh_104_0(spinlock_t *lock);


#line 464 
static void ldv_spin_unlock_bh_106(spinlock_t *lock);


#line 468 
static void ldv_spin_unlock_bh_111_1(spinlock_t *lock);


#line 37  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_mutex_lock_89_1(struct mutex *ldv_func_arg1);


#line 41 
static void ldv_mutex_lock_91_0(struct mutex *ldv_func_arg1);


#line 45 
static void ldv_mutex_lock_93_1(struct mutex *ldv_func_arg1);


#line 49 
static void ldv_mutex_lock_96(struct mutex *ldv_func_arg1);


#line 53 
static void ldv_mutex_lock_98(struct mutex *ldv_func_arg1);


#line 57 
static void ldv_mutex_lock_101(struct mutex *ldv_func_arg1);


#line 61 
static void ldv_mutex_lock_112_1(struct mutex *ldv_func_arg1);


#line 65 
static void ldv_mutex_lock_114_0(struct mutex *ldv_func_arg1);


#line 69 
static void ldv_mutex_lock_123(struct mutex *ldv_func_arg1);


#line 73 
static void ldv_mutex_lock_130(struct mutex *ldv_func_arg1);


#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
static int ldv_mutex_is_locked_88(struct mutex *lock);


#line 180 
static int ldv_mutex_trylock_107(struct mutex *ldv_func_arg1);


#line 197 
static void ldv_mutex_unlock_90_1(struct mutex *ldv_func_arg1);


#line 201 
static void ldv_mutex_unlock_92_0(struct mutex *ldv_func_arg1);


#line 205 
static void ldv_mutex_unlock_94_1(struct mutex *ldv_func_arg1);


#line 209 
static void ldv_mutex_unlock_95(struct mutex *ldv_func_arg1);


#line 213 
static void ldv_mutex_unlock_97(struct mutex *ldv_func_arg1);


#line 217 
static void ldv_mutex_unlock_99(struct mutex *ldv_func_arg1);


#line 221 
static void ldv_mutex_unlock_102_0(struct mutex *ldv_func_arg1);


#line 225 
static void ldv_mutex_unlock_108_0(struct mutex *ldv_func_arg1);


#line 229 
static void ldv_mutex_unlock_113_1(struct mutex *ldv_func_arg1);


#line 233 
static void ldv_mutex_unlock_115_0(struct mutex *ldv_func_arg1);


#line 237 
static void ldv_mutex_unlock_124(struct mutex *ldv_func_arg1);


#line 241 
static void ldv_mutex_unlock_125_0(struct mutex *ldv_func_arg1);


#line 245 
static void ldv_mutex_unlock_131(struct mutex *ldv_func_arg1);


#line 84  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwsem.h"
void __init_rwsem(struct rw_semaphore *, char const *, struct lock_class_key *);


#line 108 
void down_read(struct rw_semaphore *);


#line 128 
void up_read(struct rw_semaphore *);


#line 173  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
static int ldv_mod_timer_87(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2);


#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
void delayed_work_timer_fn(unsigned long);


#line 490 
static bool ldv_queue_work_116(struct workqueue_struct *wq, struct work_struct *work);


#line 494 
static bool ldv_queue_work_126(struct workqueue_struct *wq, struct work_struct *work);


#line 498 
static bool ldv_queue_work_132(struct workqueue_struct *wq, struct work_struct *work);


#line 505 
static bool ldv_queue_delayed_work_100(struct workqueue_struct *wq, struct delayed_work *dwork, unsigned long delay);


#line 509 
static bool ldv_queue_delayed_work_109(struct workqueue_struct *wq, struct delayed_work *dwork, unsigned long delay);


#line 595  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
static int ldv_device_create_file_117(struct device *ldv_func_arg1, struct device_attribute const *ldv_func_arg2);


#line 599 
static int ldv_device_create_file_118(struct device *ldv_func_arg1, struct device_attribute const *ldv_func_arg2);


#line 605 
static void ldv_device_remove_file_119(struct device *ldv_func_arg1, struct device_attribute const *ldv_func_arg2);


#line 609 
static void ldv_device_remove_file_120(struct device *ldv_func_arg1, struct device_attribute const *ldv_func_arg2);


#line 613 
static void ldv_device_remove_file_121(struct device *ldv_func_arg1, struct device_attribute const *ldv_func_arg2);


#line 869  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev, void *data)
{
  
#line 871 
  dev->driver_data = data;
  
#line 872 
  return;
}


#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kmalloc_4(size_t size, gfp_t flags);


#line 542 
static void *kcalloc_9(size_t n, size_t size, gfp_t flags);


#line 581 
static void *kzalloc_10(size_t size, gfp_t flags);


#line 951  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
int pci_enable_device(struct pci_dev *);


#line 968 
void pci_disable_device(struct pci_dev *);


#line 971 
void pci_set_master(struct pci_dev *);


#line 1040 
int pci_set_power_state(struct pci_dev *, pci_power_t);


#line 1076 
ssize_t pci_read_vpd(struct pci_dev *, loff_t, size_t, void *);


#line 1097 
int pci_request_region(struct pci_dev *, int, char const *);


#line 1099 
void pci_release_region(struct pci_dev *, int);


#line 1146 
static int ldv___pci_register_driver_133(struct pci_driver *ldv_func_arg1, struct module *ldv_func_arg2, char const *ldv_func_arg3);


#line 1158 
static void ldv_pci_unregister_driver_134(struct pci_driver *ldv_func_arg1);


#line 1212 
void pci_disable_msi(struct pci_dev *);


#line 1216 
void pci_disable_msix(struct pci_dev *);


#line 1219 
int pci_enable_msi_range(struct pci_dev *, int, int);


#line 1220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_enable_msi_exact(struct pci_dev *dev, int nvec)
{
  int __retres;
  
#line 1222 
  int rc = pci_enable_msi_range(dev,nvec,nvec);
  
#line 1223 
  if (rc < 0) {
    
#line 1224 
    __retres = rc;
    
#line 1224 
    goto return_label;
  }
  else ;
  
#line 1225 
  __retres = 0;
  return_label: 
#line 1225 
                return __retres;
}


#line 1227 
int pci_enable_msix_range(struct pci_dev *, struct msix_entry *, int, int);


#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
int dma_supported(struct device *, u64);


#line 61 
int dma_set_mask(struct device *, u64);


#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
__inline static int dma_set_coherent_mask(struct device *dev, u64 mask)
{
  int __retres;
  int tmp;
  
#line 103 
  tmp = dma_supported(dev,mask);
  
#line 103 
  if (tmp == 0) {
    
#line 104 
    __retres = -5;
    
#line 104 
    goto return_label;
  }
  else ;
  
#line 105 
  dev->coherent_dma_mask = mask;
  
#line 106 
  __retres = 0;
  return_label: 
#line 106 
                return __retres;
}


#line 116  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
__inline static int dma_set_mask_and_coherent(struct device *dev, u64 mask)
{
  
#line 118 
  int rc = dma_set_mask(dev,mask);
  
#line 119 
  if (rc == 0) 
#line 120 
               dma_set_coherent_mask(dev,mask); else ;
  
#line 121 
  return rc;
}


#line 1476  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev, void *data)
{
  
#line 1478 
  dev_set_drvdata(& pdev->dev,data);
  
#line 1479 
  return;
}


#line 1793  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static u16 pci_vpd_lrdt_size(u8 const *lrdt)
{
  u16 __retres;
  
#line 1795 
  __retres = (unsigned short)((int)((unsigned short)*(lrdt + 1U)) + ((int)((unsigned short)*(lrdt + 2U)) << 8U));
  
#line 1795 
  return __retres;
}


#line 1815  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static u8 pci_vpd_info_field_size(u8 const *info_field)
{
  u8 __retres;
  
#line 1817 
  __retres = *(info_field + 2U);
  
#line 1817 
  return __retres;
}


#line 1830 
int pci_vpd_find_tag(u8 const *, unsigned int, unsigned int, u8);


#line 1842 
int pci_vpd_find_info_keyword(u8 const *, unsigned int, unsigned int, char const *);


#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/delay.h"
void usleep_range(unsigned long, unsigned long);


#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_queue_limits.h"
void dql_completed(struct dql *, unsigned int);


#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hardirq.h"
void synchronize_irq(unsigned int);


#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
void enable_irq(unsigned int);


#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mii.h"
__inline static struct mii_ioctl_data *if_mii(struct ifreq *rq)
{
  struct mii_ioctl_data *__retres;
  
#line 47 
  __retres = (struct mii_ioctl_data *)(& rq->ifr_ifru);
  
#line 47 
  return __retres;
}


#line 450  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
void napi_complete_done(struct napi_struct *, int);


#line 458  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void napi_complete(struct napi_struct *n)
{
  
#line 460 
  napi_complete_done(n,0);
  
#line 461 
  return;
}


#line 478 
void napi_hash_add(struct napi_struct *);


#line 487 
void napi_hash_del(struct napi_struct *);


#line 496 
void napi_disable(struct napi_struct *);


#line 505  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void napi_enable(struct napi_struct *n)
{
  int tmp;
  
#line 507 
  tmp = constant_test_bit(0L,(unsigned long const volatile *)(& n->state));
  
#line 507 
  if ((long)(tmp == 0) != 0L) {
    
#line 509 
    ldv_inline_asm();
    
#line 507 
    ;
  }
  else ;
  
#line 509 
  ldv_inline_asm();
  
#line 509 
  set_bit(0L,(unsigned long volatile *)(& n->state));
  
#line 510 
  return;
}


#line 1911 
void netif_napi_add(struct net_device *, struct napi_struct *, int (*)(struct napi_struct *, int ), int);


#line 1920 
void netif_napi_del(struct napi_struct *);


#line 2084 
int register_netdevice_notifier(struct notifier_block *);


#line 2085 
int unregister_netdevice_notifier(struct notifier_block *);


#line 2103  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static struct net_device *netdev_notifier_info_to_dev(struct netdev_notifier_info const *info)
{
  struct net_device *__retres;
  
#line 2105 
  __retres = info->dev;
  
#line 2105 
  return __retres;
}


#line 2181 
int dev_alloc_name(struct net_device *, char const *);


#line 2193 
int register_netdevice(struct net_device *);


#line 2194 
void unregister_netdevice_queue(struct net_device *, struct list_head *);


#line 2196  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void unregister_netdevice(struct net_device *dev)
{
  
#line 2198 
  unregister_netdevice_queue(dev,(struct list_head *)0);
  
#line 2199 
  return;
}


#line 2205 
static void ldv_free_netdev_127(struct net_device *ldv_func_arg1);


#line 2209 
static void ldv_free_netdev_129(struct net_device *ldv_func_arg1);


#line 2555  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_wake_all_queues(struct net_device *dev)
{
  unsigned int i;
  
#line 2559 
  i = 0U;
  
#line 2559 
  goto ldv_45025;
  ldv_45024: 
#line 2560 
  ;
  {
    
#line 2560 
    struct netdev_queue *txq = netdev_get_tx_queue((struct net_device const *)dev,i);
    
#line 2561 
    netif_tx_wake_queue(txq);
  }
  
#line 2559 
  i += 1U;
  ldv_45025: 
#line 2560 
  ;
  
#line 2559 
  if (dev->num_tx_queues > i) 
#line 2561 
                              goto ldv_45024; else 
#line 2564 
                                                   goto ldv_45026;
  ldv_45026: 
#line 2565 
  ;
  
#line 2566 
  return;
}


#line 2683  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netdev_tx_completed_queue(struct netdev_queue *dev_queue, unsigned int pkts, unsigned int bytes)
{
  int tmp;
  int tmp_0;
  
#line 2687 
  if ((long)(bytes == 0U) != 0L) 
#line 2688 
                                 goto return_label; else ;
  
#line 2690 
  dql_completed(& dev_queue->dql,bytes);
  
#line 2691 
  ldv_inline_asm();
  
#line 2699 
  tmp = dql_avail((struct dql const *)(& dev_queue->dql));
  
#line 2699 
  if (tmp < 0) 
#line 2700 
               goto return_label; else ;
  
#line 2702 
  tmp_0 = test_and_set_bit(1L,(unsigned long volatile *)(& dev_queue->state));
  
#line 2702 
  if (tmp_0 != 0) 
#line 2703 
                  netif_schedule_queue(dev_queue); else ;
  return_label: 
#line 2704 
                return;
}


#line 2870 
int netif_set_real_num_rx_queues(struct net_device *, unsigned int);


#line 3038  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool netif_carrier_ok(struct net_device const *dev)
{
  bool __retres;
  int tmp;
  
#line 3040 
  tmp = constant_test_bit(2L,(unsigned long const volatile *)(& dev->state));
  
#line 3040 
  __retres = (_Bool)(tmp == 0);
  
#line 3040 
  return __retres;
}


#line 3047 
void netif_carrier_on(struct net_device *);


#line 3049 
void netif_carrier_off(struct net_device *);


#line 3170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void __netif_tx_lock_3(struct netdev_queue *txq, int cpu)
{
  
#line 3172 
  ldv_spin_lock_62_3(& txq->_xmit_lock);
  
#line 3173 
  txq->xmit_lock_owner = cpu;
  
#line 3174 
  return;
}


#line 3190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void __netif_tx_unlock_3(struct netdev_queue *txq)
{
  
#line 3192 
  txq->xmit_lock_owner = -1;
  
#line 3193 
  ldv_spin_unlock_65_3(& txq->_xmit_lock);
  
#line 3194 
  return;
}


#line 3214  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_lock_3(struct net_device *dev)
{
  unsigned int i;
  int cpu;
  int tmp_3;
  
#line 3219 
  ldv_spin_lock_67_3(& dev->tx_global_lock);
  {
    int pscr_ret__;
    {
      
#line 3220 
      void const *__vpp_verify = (void const *)0;
      
#line 3220 
      void const *tmp = __vpp_verify;
    }
    
#line 3220 
    switch (4UL) {
      int tmp_0;
      int tmp_0_0;
      int tmp_1;
      int tmp_2;
      case (unsigned long)1: 
#line 3220 
      ;
      {
        int pfo_ret__;
        
#line 3220 
        switch (4UL) {
          case (unsigned long)1: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45522;
          case (unsigned long)2: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45522;
          case (unsigned long)4: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45522;
          case (unsigned long)8: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45522;
          default: 
#line 3220 
          ;
          
#line 3220 
          __bad_percpu_size();
        }
        ldv_45522: 
#line 3220 
        ;
        
#line 3220 
        tmp_0 = pfo_ret__;
      }
      
#line 3220 
      pscr_ret__ = tmp_0;
      
#line 3220 
      goto ldv_45528;
      case (unsigned long)2: 
#line 3220 
      ;
      {
        int pfo_ret___0;
        
#line 3220 
        switch (4UL) {
          case (unsigned long)1: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45532;
          case (unsigned long)2: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45532;
          case (unsigned long)4: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45532;
          case (unsigned long)8: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45532;
          default: 
#line 3220 
          ;
          
#line 3220 
          __bad_percpu_size();
        }
        ldv_45532: 
#line 3220 
        ;
        
#line 3220 
        tmp_0_0 = pfo_ret___0;
      }
      
#line 3220 
      pscr_ret__ = tmp_0_0;
      
#line 3220 
      goto ldv_45528;
      case (unsigned long)4: 
#line 3220 
      ;
      {
        int pfo_ret___1;
        
#line 3220 
        switch (4UL) {
          case (unsigned long)1: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45541;
          case (unsigned long)2: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45541;
          case (unsigned long)4: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45541;
          case (unsigned long)8: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45541;
          default: 
#line 3220 
          ;
          
#line 3220 
          __bad_percpu_size();
        }
        ldv_45541: 
#line 3220 
        ;
        
#line 3220 
        tmp_1 = pfo_ret___1;
      }
      
#line 3220 
      pscr_ret__ = tmp_1;
      
#line 3220 
      goto ldv_45528;
      case (unsigned long)8: 
#line 3220 
      ;
      {
        int pfo_ret___2;
        
#line 3220 
        switch (4UL) {
          case (unsigned long)1: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45550;
          case (unsigned long)2: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45550;
          case (unsigned long)4: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45550;
          case (unsigned long)8: 
#line 3220 
          ;
          
#line 3221 
          ldv_inline_asm();
          
#line 3220 
          goto ldv_45550;
          default: 
#line 3220 
          ;
          
#line 3220 
          __bad_percpu_size();
        }
        ldv_45550: 
#line 3220 
        ;
        
#line 3220 
        tmp_2 = pfo_ret___2;
      }
      
#line 3220 
      pscr_ret__ = tmp_2;
      
#line 3220 
      goto ldv_45528;
      default: 
#line 3220 
      ;
      
#line 3220 
      __bad_size_call_parameter();
      
#line 3220 
      goto ldv_45528;
    }
    ldv_45528: 
#line 3220 
    ;
    
#line 3220 
    tmp_3 = pscr_ret__;
  }
  
#line 3220 
  cpu = tmp_3;
  
#line 3221 
  i = 0U;
  
#line 3221 
  goto ldv_45560;
  ldv_45559: 
#line 3222 
  ;
  {
    
#line 3222 
    struct netdev_queue *txq = netdev_get_tx_queue((struct net_device const *)dev,i);
    
#line 3230 
    __netif_tx_lock_3(txq,cpu);
    
#line 3231 
    set_bit(2L,(unsigned long volatile *)(& txq->state));
    
#line 3232 
    __netif_tx_unlock_3(txq);
  }
  
#line 3221 
  i += 1U;
  ldv_45560: 
#line 3222 
  ;
  
#line 3221 
  if (dev->num_tx_queues > i) 
#line 3223 
                              goto ldv_45559; else 
#line 3226 
                                                   goto ldv_45561;
  ldv_45561: 
#line 3227 
  ;
  
#line 3228 
  return;
}


#line 3236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_lock_bh_2(struct net_device *dev)
{
  
#line 3238 
  local_bh_disable();
  
#line 3239 
  netif_tx_lock_3(dev);
  
#line 3240 
  return;
}


#line 3242  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_unlock_3(struct net_device *dev)
{
  unsigned int i;
  
#line 3246 
  i = 0U;
  
#line 3246 
  goto ldv_45571;
  ldv_45570: 
#line 3247 
  ;
  {
    
#line 3247 
    struct netdev_queue *txq = netdev_get_tx_queue((struct net_device const *)dev,i);
    
#line 3253 
    set_bit(2L,(unsigned long volatile *)(& txq->state));
    
#line 3254 
    netif_schedule_queue(txq);
  }
  
#line 3246 
  i += 1U;
  ldv_45571: 
#line 3247 
  ;
  
#line 3246 
  if (dev->num_tx_queues > i) 
#line 3248 
                              goto ldv_45570; else 
#line 3251 
                                                   goto ldv_45572;
  ldv_45572: 
#line 3252 
  ;
  
#line 3256 
  ldv_spin_unlock_68_3(& dev->tx_global_lock);
  
#line 3257 
  return;
}


#line 3259  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_unlock_bh_2(struct net_device *dev)
{
  
#line 3261 
  netif_tx_unlock_3(dev);
  
#line 3262 
  local_bh_enable();
  
#line 3263 
  return;
}


#line 3282  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_disable(struct net_device *dev)
{
  unsigned int i;
  int cpu;
  int tmp_3;
  
#line 3287 
  local_bh_disable();
  {
    int pscr_ret__;
    {
      
#line 3288 
      void const *__vpp_verify = (void const *)0;
      
#line 3288 
      void const *tmp = __vpp_verify;
    }
    
#line 3288 
    switch (4UL) {
      int tmp_0;
      int tmp_0_0;
      int tmp_1;
      int tmp_2;
      case (unsigned long)1: 
#line 3288 
      ;
      {
        int pfo_ret__;
        
#line 3288 
        switch (4UL) {
          case (unsigned long)1: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45586;
          case (unsigned long)2: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45586;
          case (unsigned long)4: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45586;
          case (unsigned long)8: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45586;
          default: 
#line 3288 
          ;
          
#line 3288 
          __bad_percpu_size();
        }
        ldv_45586: 
#line 3288 
        ;
        
#line 3288 
        tmp_0 = pfo_ret__;
      }
      
#line 3288 
      pscr_ret__ = tmp_0;
      
#line 3288 
      goto ldv_45592;
      case (unsigned long)2: 
#line 3288 
      ;
      {
        int pfo_ret___0;
        
#line 3288 
        switch (4UL) {
          case (unsigned long)1: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45596;
          case (unsigned long)2: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45596;
          case (unsigned long)4: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45596;
          case (unsigned long)8: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45596;
          default: 
#line 3288 
          ;
          
#line 3288 
          __bad_percpu_size();
        }
        ldv_45596: 
#line 3288 
        ;
        
#line 3288 
        tmp_0_0 = pfo_ret___0;
      }
      
#line 3288 
      pscr_ret__ = tmp_0_0;
      
#line 3288 
      goto ldv_45592;
      case (unsigned long)4: 
#line 3288 
      ;
      {
        int pfo_ret___1;
        
#line 3288 
        switch (4UL) {
          case (unsigned long)1: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45605;
          case (unsigned long)2: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45605;
          case (unsigned long)4: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45605;
          case (unsigned long)8: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45605;
          default: 
#line 3288 
          ;
          
#line 3288 
          __bad_percpu_size();
        }
        ldv_45605: 
#line 3288 
        ;
        
#line 3288 
        tmp_1 = pfo_ret___1;
      }
      
#line 3288 
      pscr_ret__ = tmp_1;
      
#line 3288 
      goto ldv_45592;
      case (unsigned long)8: 
#line 3288 
      ;
      {
        int pfo_ret___2;
        
#line 3288 
        switch (4UL) {
          case (unsigned long)1: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45614;
          case (unsigned long)2: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45614;
          case (unsigned long)4: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45614;
          case (unsigned long)8: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45614;
          default: 
#line 3288 
          ;
          
#line 3288 
          __bad_percpu_size();
        }
        ldv_45614: 
#line 3288 
        ;
        
#line 3288 
        tmp_2 = pfo_ret___2;
      }
      
#line 3288 
      pscr_ret__ = tmp_2;
      
#line 3288 
      goto ldv_45592;
      default: 
#line 3288 
      ;
      
#line 3288 
      __bad_size_call_parameter();
      
#line 3288 
      goto ldv_45592;
    }
    ldv_45592: 
#line 3288 
    ;
    
#line 3288 
    tmp_3 = pscr_ret__;
  }
  
#line 3288 
  cpu = tmp_3;
  
#line 3289 
  i = 0U;
  
#line 3289 
  goto ldv_45624;
  ldv_45623: 
#line 3290 
  ;
  {
    
#line 3290 
    struct netdev_queue *txq = netdev_get_tx_queue((struct net_device const *)dev,i);
    
#line 3292 
    __netif_tx_lock_3(txq,cpu);
    
#line 3293 
    netif_tx_start_queue(txq);
    
#line 3294 
    __netif_tx_unlock_3(txq);
  }
  
#line 3289 
  i += 1U;
  ldv_45624: 
#line 3290 
  ;
  
#line 3289 
  if (dev->num_tx_queues > i) 
#line 3291 
                              goto ldv_45623; else 
#line 3294 
                                                   goto ldv_45625;
  ldv_45625: 
#line 3295 
  ;
  
#line 3296 
  local_bh_enable();
  
#line 3297 
  return;
}


#line 3314  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_addr_lock_bh_1(struct net_device *dev)
{
  
#line 3316 
  ldv_spin_lock_bh_71_1(& dev->addr_list_lock);
  
#line 3317 
  return;
}


#line 3324  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_addr_unlock_bh_1(struct net_device *dev)
{
  
#line 3326 
  ldv_spin_unlock_bh_73_1(& dev->addr_list_lock);
  
#line 3327 
  return;
}


#line 3356 
static void ldv_unregister_netdev_122(struct net_device *ldv_func_arg1);


#line 3549 
void netdev_rss_key_fill(void *, size_t);


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
int eth_validate_addr(struct net_device *);


#line 53 
static struct net_device *ldv_alloc_etherdev_mqs_128(int ldv_func_arg1, unsigned int ldv_func_arg2, unsigned int ldv_func_arg3);


#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/aer.h"
int pci_enable_pcie_error_reporting(struct pci_dev *);


#line 43 
int pci_disable_pcie_error_reporting(struct pci_dev *);


#line 44 
int pci_cleanup_aer_uncorrect_error_status(struct pci_dev *);


#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mdio.h"
int mdio_mii_ioctl(struct mdio_if_info const *, struct mii_ioctl_data *, int);


#line 483  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
__inline static void efx_channel_init_lock(struct efx_channel *channel)
{
  
#line 485 
  spinlock_check(& channel->state_lock);
  {
    struct lock_class_key __key;
    
#line 485 
    __raw_spin_lock_init(& channel->state_lock.__anonCompField_spinlock_18.rlock,"&(&channel->state_lock)->rlock",& __key);
  }
  
#line 487 
  return;
}


#line 489  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
__inline static bool efx_channel_lock_napi(struct efx_channel *channel)
{
  
#line 491 
  bool rc = (_Bool)1;
  
#line 493 
  ldv_spin_lock_bh_75(& channel->state_lock);
  
#line 494 
  if ((channel->state & 7U) != 0U) {
    {
      
#line 495 
      int __ret_warn_on = (channel->state & 1U) != 0U;
      
#line 495 
      if ((long)(__ret_warn_on != 0) != 0L) 
#line 495 
                                            warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h",495); else ;
      
#line 495 
      long tmp = (long)(__ret_warn_on != 0);
    }
    
#line 496 
    channel->state |= 8U;
    
#line 497 
    rc = (_Bool)0;
  }
  else 
#line 500 
       channel->state = 1U;
  
#line 502 
  ldv_spin_unlock_bh_76(& channel->state_lock);
  
#line 503 
  return rc;
}


#line 506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
__inline static void efx_channel_unlock_napi(struct efx_channel *channel)
{
  
#line 508 
  ldv_spin_lock_bh_77(& channel->state_lock);
  {
    
#line 509 
    int __ret_warn_on = (channel->state & 10U) != 0U;
    
#line 509 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 509 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h",510); else ;
    
#line 509 
    long tmp = (long)(__ret_warn_on != 0);
  }
  
#line 512 
  channel->state &= 4U;
  
#line 513 
  ldv_spin_unlock_bh_78(& channel->state_lock);
  
#line 514 
  return;
}


#line 517  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
__inline static bool efx_channel_lock_poll(struct efx_channel *channel)
{
  
#line 519 
  bool rc = (_Bool)1;
  
#line 521 
  ldv_spin_lock_bh_79(& channel->state_lock);
  
#line 522 
  if ((channel->state & 7U) != 0U) {
    
#line 523 
    channel->state |= 16U;
    
#line 524 
    rc = (_Bool)0;
  }
  else 
#line 527 
       channel->state |= 2U;
  
#line 529 
  ldv_spin_unlock_bh_80(& channel->state_lock);
  
#line 530 
  return rc;
}


#line 534  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
__inline static void efx_channel_unlock_poll(struct efx_channel *channel)
{
  
#line 536 
  ldv_spin_lock_bh_81(& channel->state_lock);
  {
    
#line 537 
    int __ret_warn_on = (channel->state & 1U) != 0U;
    
#line 537 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 537 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h",537); else ;
    
#line 537 
    long tmp = (long)(__ret_warn_on != 0);
  }
  
#line 540 
  channel->state &= 4U;
  
#line 541 
  ldv_spin_unlock_bh_82(& channel->state_lock);
  
#line 542 
  return;
}


#line 551  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
__inline static void efx_channel_enable(struct efx_channel *channel)
{
  
#line 553 
  ldv_spin_lock_bh_83(& channel->state_lock);
  
#line 554 
  channel->state = 0U;
  
#line 555 
  ldv_spin_unlock_bh_84(& channel->state_lock);
  
#line 556 
  return;
}


#line 559  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/net_driver.h"
__inline static bool efx_channel_disable(struct efx_channel *channel)
{
  
#line 561 
  bool rc = (_Bool)1;
  
#line 563 
  ldv_spin_lock_bh_85(& channel->state_lock);
  
#line 564 
  if ((channel->state & 3U) != 0U) 
#line 565 
                                   rc = (_Bool)0; else ;
  
#line 566 
  channel->state |= 4U;
  
#line 567 
  ldv_spin_unlock_bh_86(& channel->state_lock);
  
#line 569 
  return rc;
}


#line 167  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
__inline static void efx_filter_rfs_expire(struct efx_channel *channel)
{
  
#line 169 
  if (channel->rfs_filters_added > 59U) {
    bool tmp;
    
#line 169 
    tmp = __efx_filter_rfs_expire(channel->efx,100U);
    
#line 169 
    if ((int)tmp != 0) 
#line 171 
                       channel->rfs_filters_added += 4294967236U; else ;
  }
  else ;
  
#line 172 
  return;
}


#line 181 
int efx_channel_dummy_op_int(struct efx_channel *channel);


#line 219  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
__inline static int efx_mtd_probe(struct efx_nic *efx)
{
  int tmp;
  
#line 221 
  tmp = (*((efx->type)->mtd_probe))(efx);
  
#line 221 
  return tmp;
}


#line 238  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
__inline static void efx_schedule_channel_2(struct efx_channel *channel)
{
  
#line 240 
  if (0) {
    
#line 240 
    if (((channel->efx)->msg_enable & 512U) != 0U) {
      int tmp_3;
      {
        int pscr_ret__;
        {
          
#line 240 
          void const *__vpp_verify = (void const *)0;
          
#line 240 
          void const *tmp = __vpp_verify;
        }
        
#line 240 
        switch (4UL) {
          int tmp_0;
          int tmp_0_0;
          int tmp_1;
          int tmp_2;
          case (unsigned long)1: 
#line 240 
          ;
          {
            int pfo_ret__;
            
#line 240 
            switch (4UL) {
              case (unsigned long)1: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55668;
              case (unsigned long)2: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55668;
              case (unsigned long)4: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55668;
              case (unsigned long)8: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55668;
              default: 
#line 240 
              ;
              
#line 240 
              __bad_percpu_size();
            }
            ldv_55668: 
#line 240 
            ;
            
#line 240 
            tmp_0 = pfo_ret__;
          }
          
#line 240 
          pscr_ret__ = tmp_0;
          
#line 240 
          goto ldv_55674;
          case (unsigned long)2: 
#line 240 
          ;
          {
            int pfo_ret___0;
            
#line 240 
            switch (4UL) {
              case (unsigned long)1: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55678;
              case (unsigned long)2: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55678;
              case (unsigned long)4: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55678;
              case (unsigned long)8: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55678;
              default: 
#line 240 
              ;
              
#line 240 
              __bad_percpu_size();
            }
            ldv_55678: 
#line 240 
            ;
            
#line 240 
            tmp_0_0 = pfo_ret___0;
          }
          
#line 240 
          pscr_ret__ = tmp_0_0;
          
#line 240 
          goto ldv_55674;
          case (unsigned long)4: 
#line 240 
          ;
          {
            int pfo_ret___1;
            
#line 240 
            switch (4UL) {
              case (unsigned long)1: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55687;
              case (unsigned long)2: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55687;
              case (unsigned long)4: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55687;
              case (unsigned long)8: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55687;
              default: 
#line 240 
              ;
              
#line 240 
              __bad_percpu_size();
            }
            ldv_55687: 
#line 240 
            ;
            
#line 240 
            tmp_1 = pfo_ret___1;
          }
          
#line 240 
          pscr_ret__ = tmp_1;
          
#line 240 
          goto ldv_55674;
          case (unsigned long)8: 
#line 240 
          ;
          {
            int pfo_ret___2;
            
#line 240 
            switch (4UL) {
              case (unsigned long)1: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55696;
              case (unsigned long)2: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55696;
              case (unsigned long)4: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55696;
              case (unsigned long)8: 
#line 240 
              ;
              
#line 241 
              ldv_inline_asm();
              
#line 240 
              goto ldv_55696;
              default: 
#line 240 
              ;
              
#line 240 
              __bad_percpu_size();
            }
            ldv_55696: 
#line 240 
            ;
            
#line 240 
            tmp_2 = pfo_ret___2;
          }
          
#line 240 
          pscr_ret__ = tmp_2;
          
#line 240 
          goto ldv_55674;
          default: 
#line 240 
          ;
          
#line 240 
          __bad_size_call_parameter();
          
#line 240 
          goto ldv_55674;
        }
        ldv_55674: 
#line 240 
        ;
        
#line 240 
        tmp_3 = pscr_ret__;
      }
      
#line 240 
      ;
      
#line 240 
      ;
      
#line 240 
      netdev_printk("\001",(struct net_device const *)(channel->efx)->net_dev,"channel %d scheduling NAPI poll on CPU%d\n",channel->channel,tmp_3);
    }
    else ;
  }
  else ;
  
#line 244 
  napi_schedule(& channel->napi_str);
  
#line 245 
  return;
}


#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.h"
__inline static void efx_device_detach_sync_2(struct efx_nic *efx)
{
  
#line 259 
  struct net_device *dev = efx->net_dev;
  
#line 265 
  netif_tx_lock_bh_2(dev);
  
#line 266 
  netif_device_detach(dev);
  
#line 267 
  netif_tx_unlock_bh_2(dev);
  
#line 268 
  return;
}


#line 639  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
__inline static int efx_nic_probe_eventq(struct efx_channel *channel)
{
  int tmp;
  
#line 641 
  tmp = (*(((channel->efx)->type)->ev_probe))(channel);
  
#line 641 
  return tmp;
}


#line 643  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
__inline static int efx_nic_init_eventq(struct efx_channel *channel)
{
  int tmp;
  
#line 645 
  tmp = (*(((channel->efx)->type)->ev_init))(channel);
  
#line 645 
  return tmp;
}


#line 647  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
__inline static void efx_nic_fini_eventq(struct efx_channel *channel)
{
  
#line 649 
  (*(((channel->efx)->type)->ev_fini))(channel);
  
#line 650 
  return;
}


#line 651  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
__inline static void efx_nic_remove_eventq(struct efx_channel *channel)
{
  
#line 653 
  (*(((channel->efx)->type)->ev_remove))(channel);
  
#line 654 
  return;
}


#line 656  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
__inline static int efx_nic_process_eventq(struct efx_channel *channel, int quota)
{
  int tmp;
  
#line 658 
  tmp = (*(((channel->efx)->type)->ev_process))(channel,quota);
  
#line 658 
  return tmp;
}


#line 660  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/nic.h"
__inline static void efx_nic_eventq_read_ack(struct efx_channel *channel)
{
  
#line 662 
  (*(((channel->efx)->type)->ev_read_ack))(channel);
  
#line 663 
  return;
}


#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
unsigned int const efx_loopback_mode_max = 27U;

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
char const * const efx_loopback_mode_names[27U] = {"NONE", "DATAPATH", "GMAC", "XGMII", "XGXS", "XAUI", "GMII", "SGMII", "XGBR", "XFI", "XAUI_FAR", "GMII_FAR", "SGMII_FAR", "XFI_FAR", "GPHY", "PHYXS", "PCS", "PMA/PMD", "XPORT", "XGMII_WS", "XAUI_WS", "XAUI_WS_FAR", "XAUI_WS_NEAR", "GMII_WS", "XFI_WS", "XFI_WS_FAR", "PHYXS_WS"};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
unsigned int const efx_reset_type_max = 16U;

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
char const * const efx_reset_type_names[16U] = {"INVISIBLE", "RECOVER_OR_ALL", "ALL", "WORLD", "RECOVER_OR_DISABLE", "DATAPATH", "MC_BIST", "DISABLE", [9] = "TX_WATCHDOG", "INT_ERROR", "RX_RECOVERY", "DMA_ERROR", "TX_SKIP", "MC_FAILURE", "MCDI_TIMEOUT (FLR)"};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static struct workqueue_struct *reset_workqueue;

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static bool separate_tx_channels;

#line 126  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int napi_weight = 64;

#line 136  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static unsigned int efx_monitor_interval = 250U;

#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static unsigned int rx_irq_mod_usec = 60U;

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static unsigned int tx_irq_mod_usec = 150U;

#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static unsigned int interrupt_mode;

#line 171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static unsigned int rss_cpus;

#line 175  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static bool phy_flash_cfg;

#line 179  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static unsigned int irq_adapt_low_thresh = 8000U;

#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static unsigned int irq_adapt_high_thresh = 16000U;

#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static unsigned int debug = 8439U;

#line 202 
static int efx_soft_enable_interrupts(struct efx_nic *efx);


#line 203 
static void efx_soft_disable_interrupts(struct efx_nic *efx);


#line 204 
static void efx_remove_channel(struct efx_channel *channel);


#line 205 
static void efx_remove_channels(struct efx_nic *efx);


#line 206 
static struct efx_channel_type const efx_default_channel_type;


#line 207 
static void efx_remove_port(struct efx_nic *efx);


#line 208 
static void efx_init_napi_channel(struct efx_channel *channel);


#line 209 
static void efx_fini_napi(struct efx_nic *efx);


#line 210 
static void efx_fini_napi_channel(struct efx_channel *channel);


#line 211 
static void efx_fini_struct(struct efx_nic *efx);


#line 212 
static void efx_start_all(struct efx_nic *efx);


#line 213 
static void efx_stop_all(struct efx_nic *efx);


#line 223  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_check_disabled(struct efx_nic *efx)
{
  int __retres;
  
#line 225 
  if ((unsigned int)efx->state + 4294967294U <= 1U) {
    
#line 226 
    if ((efx->msg_enable & 1U) != 0U) 
#line 226 
                                      netdev_err((struct net_device const *)efx->net_dev,"device is disabled due to earlier errors\n"); else ;
    
#line 228 
    __retres = -5;
    
#line 228 
    goto return_label;
  }
  else ;
  
#line 230 
  __retres = 0;
  return_label: 
#line 230 
                return __retres;
}


#line 246  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_process_channel(struct efx_channel *channel, int budget)
{
  int __retres;
  struct efx_tx_queue *tx_queue;
  int spent;
  int tmp_1;
  bool tmp_0;
  int tmp_6;
  bool tmp_5;
  
#line 251 
  if ((long)(! channel->enabled) != 0L) {
    
#line 252 
    __retres = 0;
    
#line 252 
    goto return_label;
  }
  else ;
  
#line 254 
  tmp_0 = efx_channel_has_tx_queues(channel);
  
#line 254 
  if (tmp_0) 
#line 254 
             tmp_1 = 0; else 
#line 254 
                             tmp_1 = 1;
  
#line 254 
  if (tmp_1) ;
  else {
    
#line 254 
    tx_queue = (struct efx_tx_queue *)(& channel->tx_queue);
    
#line 254 
    goto ldv_56896;
    ldv_56895: 
#line 255 
    ;
    
#line 255 
    tx_queue->pkts_compl = 0U;
    
#line 256 
    tx_queue->bytes_compl = 0U;
    
#line 254 
    tx_queue += 1;
    ldv_56896: 
#line 255 
    ;
    
#line 254 
    if ((struct efx_tx_queue *)(& channel->tx_queue) + 4U > tx_queue) {
      bool tmp;
      
#line 254 
      tmp = efx_tx_queue_used(tx_queue);
      
#line 254 
      if ((int)tmp != 0) 
#line 256 
                         goto ldv_56895; else 
#line 259 
                                              goto ldv_56897;
    }
    else 
#line 259 
         goto ldv_56897;
    ldv_56897: 
#line 260 
    ;
  }
  
#line 259 
  spent = efx_nic_process_eventq(channel,budget);
  
#line 260 
  if (spent != 0) {
    bool tmp_3;
    
#line 260 
    tmp_3 = efx_channel_has_rx_queue(channel);
    
#line 260 
    if ((int)tmp_3 != 0) {
      
#line 261 
      struct efx_rx_queue *rx_queue = efx_channel_get_rx_queue(channel);
      
#line 264 
      efx_rx_flush_packet(channel);
      
#line 265 
      efx_fast_push_rx_descriptors(rx_queue,(_Bool)1);
    }
    else ;
  }
  else ;
  
#line 269 
  tmp_5 = efx_channel_has_tx_queues(channel);
  
#line 269 
  if (tmp_5) 
#line 269 
             tmp_6 = 0; else 
#line 269 
                             tmp_6 = 1;
  
#line 269 
  if (tmp_6) ;
  else {
    
#line 269 
    tx_queue = (struct efx_tx_queue *)(& channel->tx_queue);
    
#line 269 
    goto ldv_56900;
    ldv_56899: 
#line 270 
    ;
    
#line 270 
    if (tx_queue->bytes_compl != 0U) 
#line 271 
                                     netdev_tx_completed_queue(tx_queue->core_txq,tx_queue->pkts_compl,tx_queue->bytes_compl); else ;
    
#line 269 
    tx_queue += 1;
    ldv_56900: 
#line 270 
    ;
    
#line 269 
    if ((struct efx_tx_queue *)(& channel->tx_queue) + 4U > tx_queue) {
      bool tmp_4;
      
#line 269 
      tmp_4 = efx_tx_queue_used(tx_queue);
      
#line 269 
      if ((int)tmp_4 != 0) 
#line 271 
                           goto ldv_56899; else 
#line 274 
                                                goto ldv_56901;
    }
    else 
#line 274 
         goto ldv_56901;
    ldv_56901: 
#line 275 
    ;
  }
  
#line 276 
  __retres = spent;
  return_label: 
#line 276 
                return __retres;
}


#line 284  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_poll(struct napi_struct *napi, int budget)
{
  int __retres;
  struct efx_channel *tmp;
  int spent;
  int tmp_1;
  bool tmp_0;
  {
    
#line 287 
    struct napi_struct const *__mptr = (struct napi_struct const *)napi;
    
#line 287 
    tmp = (struct efx_channel *)__mptr + 18446744073709551568U;
  }
  
#line 286 
  struct efx_channel *channel = tmp;
  
#line 288 
  struct efx_nic *efx = channel->efx;
  
#line 291 
  tmp_0 = efx_channel_lock_napi(channel);
  
#line 291 
  if (tmp_0) 
#line 291 
             tmp_1 = 0; else 
#line 291 
                             tmp_1 = 1;
  
#line 291 
  if (tmp_1) {
    
#line 292 
    __retres = budget;
    
#line 292 
    goto return_label;
  }
  else ;
  
#line 294 
  if (0) {
    
#line 294 
    if ((efx->msg_enable & 512U) != 0U) {
      int tmp_6;
      {
        int pscr_ret__;
        {
          
#line 294 
          void const *__vpp_verify = (void const *)0;
          
#line 294 
          void const *tmp_2 = __vpp_verify;
        }
        
#line 294 
        switch (4UL) {
          int tmp_2_0;
          int tmp_3;
          int tmp_4;
          int tmp_5;
          case (unsigned long)1: 
#line 294 
          ;
          {
            int pfo_ret__;
            
#line 294 
            switch (4UL) {
              case (unsigned long)1: 
#line 294 
              ;
              
#line 295 
              ldv_inline_asm();
              
#line 294 
              goto ldv_56916;
              case (unsigned long)2: 
#line 294 
              ;
              
#line 295 
              ldv_inline_asm();
              
#line 294 
              goto ldv_56916;
              case (unsigned long)4: 
#line 294 
              ;
              
#line 295 
              ldv_inline_asm();
              
#line 294 
              goto ldv_56916;
              case (unsigned long)8: 
#line 294 
              ;
              
#line 295 
              ldv_inline_asm();
              
#line 294 
              goto ldv_56916;
              default: 
#line 294 
              ;
              
#line 294 
              __bad_percpu_size();
            }
            ldv_56916: 
#line 294 
            ;
            
#line 294 
            tmp_2_0 = pfo_ret__;
          }
          
#line 294 
          pscr_ret__ = tmp_2_0;
          
#line 294 
          goto ldv_56922;
          case (unsigned long)2: 
#line 294 
          ;
          {
            int pfo_ret___0;
            
#line 294 
            switch (4UL) {
              case (unsigned long)1: 
#line 294 
              ;
              
#line 295 
              ldv_inline_asm();
              
#line 294 
              goto ldv_56926;
              case (unsigned long)2: 
#line 294 
              ;
              
#line 295 
              ldv_inline_asm();
              
#line 294 
              goto ldv_56926;
              case (unsigned long)4: 
#line 294 
              ;
              
#line 295 
              ldv_inline_asm();
              
#line 294 
              goto ldv_56926;
              case (unsigned long)8: 
#line 294 
              ;
              
#line 295 
              ldv_inline_asm();
              
#line 294 
              goto ldv_56926;
              default: 
#line 294 
              ;
              
#line 294 
              __bad_percpu_size();
            }
            ldv_56926: 
#line 294 
            ;
            
#line 294 
            tmp_3 = pfo_ret___0;
          }
          
#line 294 
          pscr_ret__ = tmp_3;
          
#line 294 
          goto ldv_56922;
          case (unsigned long)4: 
#line 294 
          ;
          {
            int pfo_ret___1;
            
#line 294 
            switch (4UL) {
              case (unsigned long)1: 
#line 294 
              ;
              
#line 295 
              ldv_inline_asm();
              
#line 294 
              goto ldv_56935;
              case (unsigned long)2: 
#line 294 
              ;
              
#line 295 
              ldv_inline_asm();
              
#line 294 
              goto ldv_56935;
              case (unsigned long)4: 
#line 294 
              ;
              
#line 295 
              ldv_inline_asm();
              
#line 294 
              goto ldv_56935;
              case (unsigned long)8: 
#line 294 
              ;
              
#line 295 
              ldv_inline_asm();
              
#line 294 
              goto ldv_56935;
              default: 
#line 294 
              ;
              
#line 294 
              __bad_percpu_size();
            }
            ldv_56935: 
#line 294 
            ;
            
#line 294 
            tmp_4 = pfo_ret___1;
          }
          
#line 294 
          pscr_ret__ = tmp_4;
          
#line 294 
          goto ldv_56922;
          case (unsigned long)8: 
#line 294 
          ;
          {
            int pfo_ret___2;
            
#line 294 
            switch (4UL) {
              case (unsigned long)1: 
#line 294 
              ;
              
#line 295 
              ldv_inline_asm();
              
#line 294 
              goto ldv_56944;
              case (unsigned long)2: 
#line 294 
              ;
              
#line 295 
              ldv_inline_asm();
              
#line 294 
              goto ldv_56944;
              case (unsigned long)4: 
#line 294 
              ;
              
#line 295 
              ldv_inline_asm();
              
#line 294 
              goto ldv_56944;
              case (unsigned long)8: 
#line 294 
              ;
              
#line 295 
              ldv_inline_asm();
              
#line 294 
              goto ldv_56944;
              default: 
#line 294 
              ;
              
#line 294 
              __bad_percpu_size();
            }
            ldv_56944: 
#line 294 
            ;
            
#line 294 
            tmp_5 = pfo_ret___2;
          }
          
#line 294 
          pscr_ret__ = tmp_5;
          
#line 294 
          goto ldv_56922;
          default: 
#line 294 
          ;
          
#line 294 
          __bad_size_call_parameter();
          
#line 294 
          goto ldv_56922;
        }
        ldv_56922: 
#line 294 
        ;
        
#line 294 
        tmp_6 = pscr_ret__;
      }
      
#line 294 
      ;
      
#line 294 
      ;
      
#line 294 
      netdev_printk("\001",(struct net_device const *)efx->net_dev,"channel %d NAPI poll executing on CPU %d\n",channel->channel,tmp_6);
    }
    else ;
  }
  else ;
  
#line 298 
  spent = efx_process_channel(channel,budget);
  
#line 300 
  if (spent < budget) {
    bool tmp_7;
    
#line 301 
    tmp_7 = efx_channel_has_rx_queue(channel);
    
#line 301 
    if ((int)tmp_7 != 0) {
      
#line 301 
      if ((int)efx->irq_rx_adaptive != 0) {
        
#line 303 
        channel->irq_count += 1U;
        
#line 302 
        if ((long)(channel->irq_count == 1000U) != 0L) {
          
#line 304 
          if ((long)(channel->irq_mod_score < irq_adapt_low_thresh) != 0L) {
            
#line 306 
            if (channel->irq_moderation > 1U) {
              
#line 307 
              channel->irq_moderation += 4294967295U;
              
#line 308 
              (*((efx->type)->push_irq_moderation))(channel);
            }
            else ;
          }
          else 
            
#line 310 
            if ((long)(channel->irq_mod_score > irq_adapt_high_thresh) != 0L) {
              
#line 312 
              if (channel->irq_moderation < efx->irq_rx_moderation) {
                
#line 314 
                channel->irq_moderation += 1U;
                
#line 315 
                (*((efx->type)->push_irq_moderation))(channel);
              }
              else ;
            }
            else ;
          
#line 318 
          channel->irq_count = 0U;
          
#line 319 
          channel->irq_mod_score = 0U;
        }
        else ;
      }
      else ;
    }
    else ;
    
#line 322 
    efx_filter_rfs_expire(channel);
    
#line 329 
    napi_complete(napi);
    
#line 330 
    efx_nic_eventq_read_ack(channel);
  }
  else ;
  
#line 333 
  efx_channel_unlock_napi(channel);
  
#line 334 
  __retres = spent;
  return_label: 
#line 334 
                return __retres;
}


#line 342  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_probe_eventq(struct efx_channel *channel)
{
  unsigned long entries;
  unsigned long tmp_70;
  int tmp_71;
  
#line 344 
  struct efx_nic *efx = channel->efx;
  
#line 347 
  if ((efx->msg_enable & 2U) != 0U) {
    
#line 347 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_probe_eventq", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "chan %d create event queue\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))348U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 347 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 347 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"chan %d create event queue\n",channel->channel); else ;
  }
  else ;
  
#line 352 
  if (0 != 0) {
    unsigned long tmp_67;
    
#line 352 
    if (efx->rxq_entries + efx->txq_entries != 4294967169U) {
      unsigned long tmp_66;
      
#line 352 
      if (0 != 0) {
        unsigned long tmp_64;
        
#line 352 
        if (efx->rxq_entries + efx->txq_entries == 4294967169U) {
          int tmp;
          
#line 352 
          tmp = ____ilog2_NaN();
          
#line 352 
          tmp_64 = 1UL << (tmp + 1);
        }
        else {
          unsigned long tmp_63;
          
#line 352 
          if (((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 4611686018427387904ULL) == 0ULL) {
            unsigned long tmp_62;
            
#line 352 
            if (((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 2305843009213693952ULL) == 0ULL) {
              unsigned long tmp_61;
              
#line 352 
              if (((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 1152921504606846976ULL) == 0ULL) {
                unsigned long tmp_60;
                
#line 352 
                if (((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 576460752303423488ULL) == 0ULL) {
                  unsigned long tmp_59;
                  
#line 352 
                  if (((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 288230376151711744ULL) == 0ULL) {
                    unsigned long tmp_58;
                    
#line 352 
                    if (((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 144115188075855872ULL) == 0ULL) {
                      unsigned long tmp_57;
                      
#line 352 
                      if (((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 72057594037927936ULL) == 0ULL) {
                        unsigned long tmp_56;
                        
#line 352 
                        if (((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 36028797018963968ULL) == 0ULL) {
                          unsigned long tmp_55;
                          
#line 352 
                          if (((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 18014398509481984ULL) == 0ULL) {
                            unsigned long tmp_54;
                            
#line 352 
                            if (((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 9007199254740992ULL) == 0ULL) {
                              unsigned long tmp_53;
                              
#line 352 
                              if (((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 4503599627370496ULL) == 0ULL) {
                                unsigned long tmp_52;
                                
#line 352 
                                if (((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 2251799813685248ULL) == 0ULL) {
                                  unsigned long tmp_51;
                                  
#line 352 
                                  if (((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 1125899906842624ULL) == 0ULL) {
                                    unsigned long tmp_50;
                                    
#line 352 
                                    if (((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 562949953421312ULL) == 0ULL) {
                                      unsigned long tmp_49;
                                      
#line 352 
                                      if (((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 281474976710656ULL) == 0ULL) {
                                        unsigned long tmp_48;
                                        
#line 352 
                                        if (((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 140737488355328ULL) == 0ULL) {
                                          unsigned long tmp_47;
                                          
#line 352 
                                          if (((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 70368744177664ULL) == 0ULL) {
                                            unsigned long tmp_46;
                                            
#line 352 
                                            if (((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 35184372088832ULL) == 0ULL) {
                                              unsigned long tmp_45;
                                              
#line 352 
                                              if (((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 17592186044416ULL) == 0ULL) {
                                                unsigned long tmp_44;
                                                
#line 352 
                                                if (((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 8796093022208ULL) == 0ULL) {
                                                  unsigned long tmp_43;
                                                  
#line 352 
                                                  if (((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 4398046511104ULL) == 0ULL) {
                                                    unsigned long tmp_42;
                                                    
#line 352 
                                                    if (((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 2199023255552ULL) == 0ULL) {
                                                      unsigned long tmp_41;
                                                      
#line 352 
                                                      if (((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 1099511627776ULL) == 0ULL) {
                                                        unsigned long tmp_40;
                                                        
#line 352 
                                                        if (((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 549755813888ULL) == 0ULL) {
                                                          unsigned long tmp_39;
                                                          
#line 352 
                                                          if (((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 274877906944ULL) == 0ULL) {
                                                            unsigned long tmp_38;
                                                            
#line 352 
                                                            if (((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 137438953472ULL) == 0ULL) {
                                                              unsigned long tmp_37;
                                                              
#line 352 
                                                              if (((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 68719476736ULL) == 0ULL) {
                                                                unsigned long tmp_36;
                                                                
#line 352 
                                                                if (((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 34359738368ULL) == 0ULL) {
                                                                  unsigned long tmp_35;
                                                                  
#line 352 
                                                                  if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 17179869184ULL) == 0ULL) {
                                                                    unsigned long tmp_34;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 8589934592ULL) == 0ULL) {
                                                                    unsigned long tmp_33;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 4294967296ULL) == 0ULL) {
                                                                    unsigned long tmp_32;
                                                                    
#line 352 
                                                                    if (
                                                                    (efx->rxq_entries + efx->txq_entries) + 127U >= (unsigned int)0) {
                                                                    unsigned long tmp_31;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 1073741824ULL) == 0ULL) {
                                                                    unsigned long tmp_30;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 536870912ULL) == 0ULL) {
                                                                    unsigned long tmp_29;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 268435456ULL) == 0ULL) {
                                                                    unsigned long tmp_28;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 134217728ULL) == 0ULL) {
                                                                    unsigned long tmp_27;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 67108864ULL) == 0ULL) {
                                                                    unsigned long tmp_26;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 33554432ULL) == 0ULL) {
                                                                    unsigned long tmp_25;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 16777216ULL) == 0ULL) {
                                                                    unsigned long tmp_24;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 8388608ULL) == 0ULL) {
                                                                    unsigned long tmp_23;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 4194304ULL) == 0ULL) {
                                                                    unsigned long tmp_22;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 2097152ULL) == 0ULL) {
                                                                    unsigned long tmp_21;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 1048576ULL) == 0ULL) {
                                                                    unsigned long tmp_20;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 524288ULL) == 0ULL) {
                                                                    unsigned long tmp_19;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 262144ULL) == 0ULL) {
                                                                    unsigned long tmp_18;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 131072ULL) == 0ULL) {
                                                                    unsigned long tmp_17;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 65536ULL) == 0ULL) {
                                                                    unsigned long tmp_16;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 32768ULL) == 0ULL) {
                                                                    unsigned long tmp_15;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 16384ULL) == 0ULL) {
                                                                    unsigned long tmp_14;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 8192ULL) == 0ULL) {
                                                                    unsigned long tmp_13;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 4096ULL) == 0ULL) {
                                                                    unsigned long tmp_12;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 2048ULL) == 0ULL) {
                                                                    unsigned long tmp_11;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 1024ULL) == 0ULL) {
                                                                    unsigned long tmp_10;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 512ULL) == 0ULL) {
                                                                    unsigned long tmp_9;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 256ULL) == 0ULL) {
                                                                    unsigned long tmp_8;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 128ULL) == 0ULL) {
                                                                    unsigned long tmp_7;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 64ULL) == 0ULL) {
                                                                    unsigned long tmp_6;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 32ULL) == 0ULL) {
                                                                    unsigned long tmp_5;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 16ULL) == 0ULL) {
                                                                    unsigned long tmp_4;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 8ULL) == 0ULL) {
                                                                    unsigned long tmp_3;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 4ULL) == 0ULL) {
                                                                    unsigned long tmp_2;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 2ULL) == 0ULL) {
                                                                    unsigned long tmp_1;
                                                                    
#line 352 
                                                                    if (
                                                                    ((unsigned long long)((efx->rxq_entries + efx->txq_entries) + 127U) & 1ULL) == 0ULL) {
                                                                    int tmp_0;
                                                                    
#line 352 
                                                                    tmp_0 = ____ilog2_NaN();
                                                                    
#line 352 
                                                                    tmp_1 = 1UL << (tmp_0 + 1);
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_1 = 2UL;
                                                                    
#line 352 
                                                                    tmp_2 = tmp_1;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_2 = 4UL;
                                                                    
#line 352 
                                                                    tmp_3 = tmp_2;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_3 = 8UL;
                                                                    
#line 352 
                                                                    tmp_4 = tmp_3;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_4 = 16UL;
                                                                    
#line 352 
                                                                    tmp_5 = tmp_4;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_5 = 32UL;
                                                                    
#line 352 
                                                                    tmp_6 = tmp_5;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_6 = 64UL;
                                                                    
#line 352 
                                                                    tmp_7 = tmp_6;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_7 = 128UL;
                                                                    
#line 352 
                                                                    tmp_8 = tmp_7;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_8 = 256UL;
                                                                    
#line 352 
                                                                    tmp_9 = tmp_8;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_9 = 512UL;
                                                                    
#line 352 
                                                                    tmp_10 = tmp_9;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_10 = 1024UL;
                                                                    
#line 352 
                                                                    tmp_11 = tmp_10;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_11 = 2048UL;
                                                                    
#line 352 
                                                                    tmp_12 = tmp_11;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_12 = 4096UL;
                                                                    
#line 352 
                                                                    tmp_13 = tmp_12;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_13 = 8192UL;
                                                                    
#line 352 
                                                                    tmp_14 = tmp_13;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_14 = 16384UL;
                                                                    
#line 352 
                                                                    tmp_15 = tmp_14;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_15 = 32768UL;
                                                                    
#line 352 
                                                                    tmp_16 = tmp_15;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_16 = 65536UL;
                                                                    
#line 352 
                                                                    tmp_17 = tmp_16;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_17 = 131072UL;
                                                                    
#line 352 
                                                                    tmp_18 = tmp_17;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_18 = 262144UL;
                                                                    
#line 352 
                                                                    tmp_19 = tmp_18;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_19 = 524288UL;
                                                                    
#line 352 
                                                                    tmp_20 = tmp_19;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_20 = 1048576UL;
                                                                    
#line 352 
                                                                    tmp_21 = tmp_20;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_21 = 2097152UL;
                                                                    
#line 352 
                                                                    tmp_22 = tmp_21;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_22 = 4194304UL;
                                                                    
#line 352 
                                                                    tmp_23 = tmp_22;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_23 = 8388608UL;
                                                                    
#line 352 
                                                                    tmp_24 = tmp_23;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_24 = 16777216UL;
                                                                    
#line 352 
                                                                    tmp_25 = tmp_24;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_25 = 33554432UL;
                                                                    
#line 352 
                                                                    tmp_26 = tmp_25;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_26 = 67108864UL;
                                                                    
#line 352 
                                                                    tmp_27 = tmp_26;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_27 = 134217728UL;
                                                                    
#line 352 
                                                                    tmp_28 = tmp_27;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_28 = 268435456UL;
                                                                    
#line 352 
                                                                    tmp_29 = tmp_28;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_29 = 536870912UL;
                                                                    
#line 352 
                                                                    tmp_30 = tmp_29;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_30 = 1073741824UL;
                                                                    
#line 352 
                                                                    tmp_31 = tmp_30;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_31 = 2147483648UL;
                                                                    
#line 352 
                                                                    tmp_32 = tmp_31;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_32 = 4294967296UL;
                                                                    
#line 352 
                                                                    tmp_33 = tmp_32;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_33 = 8589934592UL;
                                                                    
#line 352 
                                                                    tmp_34 = tmp_33;
                                                                    }
                                                                    else 
                                                                    
#line 352 
                                                                    tmp_34 = 17179869184UL;
                                                                    
#line 352 
                                                                    tmp_35 = tmp_34;
                                                                  }
                                                                  else 
                                                                    
#line 352 
                                                                    tmp_35 = 34359738368UL;
                                                                  
#line 352 
                                                                  tmp_36 = tmp_35;
                                                                }
                                                                else 
                                                                  
#line 352 
                                                                  tmp_36 = 68719476736UL;
                                                                
#line 352 
                                                                tmp_37 = tmp_36;
                                                              }
                                                              else 
#line 352 
                                                                   tmp_37 = 137438953472UL;
                                                              
#line 352 
                                                              tmp_38 = tmp_37;
                                                            }
                                                            else 
#line 352 
                                                                 tmp_38 = 274877906944UL;
                                                            
#line 352 
                                                            tmp_39 = tmp_38;
                                                          }
                                                          else 
#line 352 
                                                               tmp_39 = 549755813888UL;
                                                          
#line 352 
                                                          tmp_40 = tmp_39;
                                                        }
                                                        else 
#line 352 
                                                             tmp_40 = 1099511627776UL;
                                                        
#line 352 
                                                        tmp_41 = tmp_40;
                                                      }
                                                      else 
#line 352 
                                                           tmp_41 = 2199023255552UL;
                                                      
#line 352 
                                                      tmp_42 = tmp_41;
                                                    }
                                                    else 
#line 352 
                                                         tmp_42 = 4398046511104UL;
                                                    
#line 352 
                                                    tmp_43 = tmp_42;
                                                  }
                                                  else 
#line 352 
                                                       tmp_43 = 8796093022208UL;
                                                  
#line 352 
                                                  tmp_44 = tmp_43;
                                                }
                                                else 
#line 352 
                                                     tmp_44 = 17592186044416UL;
                                                
#line 352 
                                                tmp_45 = tmp_44;
                                              }
                                              else 
#line 352 
                                                   tmp_45 = 35184372088832UL;
                                              
#line 352 
                                              tmp_46 = tmp_45;
                                            }
                                            else 
#line 352 
                                                 tmp_46 = 70368744177664UL;
                                            
#line 352 
                                            tmp_47 = tmp_46;
                                          }
                                          else 
#line 352 
                                               tmp_47 = 140737488355328UL;
                                          
#line 352 
                                          tmp_48 = tmp_47;
                                        }
                                        else 
#line 352 
                                             tmp_48 = 281474976710656UL;
                                        
#line 352 
                                        tmp_49 = tmp_48;
                                      }
                                      else 
#line 352 
                                           tmp_49 = 562949953421312UL;
                                      
#line 352 
                                      tmp_50 = tmp_49;
                                    }
                                    else 
#line 352 
                                         tmp_50 = 1125899906842624UL;
                                    
#line 352 
                                    tmp_51 = tmp_50;
                                  }
                                  else 
#line 352 
                                       tmp_51 = 2251799813685248UL;
                                  
#line 352 
                                  tmp_52 = tmp_51;
                                }
                                else 
#line 352 
                                     tmp_52 = 4503599627370496UL;
                                
#line 352 
                                tmp_53 = tmp_52;
                              }
                              else 
#line 352 
                                   tmp_53 = 9007199254740992UL;
                              
#line 352 
                              tmp_54 = tmp_53;
                            }
                            else 
#line 352 
                                 tmp_54 = 18014398509481984UL;
                            
#line 352 
                            tmp_55 = tmp_54;
                          }
                          else 
#line 352 
                               tmp_55 = 36028797018963968UL;
                          
#line 352 
                          tmp_56 = tmp_55;
                        }
                        else 
#line 352 
                             tmp_56 = 72057594037927936UL;
                        
#line 352 
                        tmp_57 = tmp_56;
                      }
                      else 
#line 352 
                           tmp_57 = 144115188075855872UL;
                      
#line 352 
                      tmp_58 = tmp_57;
                    }
                    else 
#line 352 
                         tmp_58 = 288230376151711744UL;
                    
#line 352 
                    tmp_59 = tmp_58;
                  }
                  else 
#line 352 
                       tmp_59 = 576460752303423488UL;
                  
#line 352 
                  tmp_60 = tmp_59;
                }
                else 
#line 352 
                     tmp_60 = 1152921504606846976UL;
                
#line 352 
                tmp_61 = tmp_60;
              }
              else 
#line 352 
                   tmp_61 = 2305843009213693952UL;
              
#line 352 
              tmp_62 = tmp_61;
            }
            else 
#line 352 
                 tmp_62 = 4611686018427387904UL;
            
#line 352 
            tmp_63 = tmp_62;
          }
          else 
#line 352 
               tmp_63 = 9223372036854775808UL;
          
#line 352 
          tmp_64 = tmp_63;
        }
        
#line 352 
        tmp_66 = tmp_64;
      }
      else {
        int tmp_65;
        
#line 352 
        tmp_65 = __ilog2_u32((efx->rxq_entries + efx->txq_entries) + 127U);
        
#line 352 
        tmp_66 = 1UL << (tmp_65 + 1);
      }
      
#line 352 
      tmp_67 = tmp_66;
    }
    else 
#line 352 
         tmp_67 = 1UL;
    
#line 352 
    entries = tmp_67;
  }
  else 
#line 352 
       entries = __roundup_pow_of_two((unsigned long)((efx->rxq_entries + efx->txq_entries) + 128U));
  {
    unsigned long tmp_69;
    
#line 354 
    unsigned long _max1 = entries;
    
#line 354 
    unsigned long _max2 = 512UL;
    
#line 354 
    if (_max1 > _max2) 
#line 354 
                       tmp_69 = _max1; else 
#line 354 
                                            tmp_69 = _max2;
    
#line 354 
    tmp_70 = tmp_69;
  }
  
#line 354 
  channel->eventq_mask = (unsigned int)tmp_70 + 4294967295U;
  
#line 356 
  tmp_71 = efx_nic_probe_eventq(channel);
  
#line 356 
  return tmp_71;
}


#line 360  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_init_eventq(struct efx_channel *channel)
{
  int rc;
  
#line 362 
  struct efx_nic *efx = channel->efx;
  
#line 367 
  if ((efx->msg_enable & 1U) != 0U) {
    
#line 367 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_init_eventq", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "chan %d init event queue\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))368U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 367 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 367 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"chan %d init event queue\n",channel->channel); else ;
  }
  else ;
  
#line 370 
  rc = efx_nic_init_eventq(channel);
  
#line 371 
  if (rc == 0) {
    
#line 372 
    (*((efx->type)->push_irq_moderation))(channel);
    
#line 373 
    channel->eventq_read_ptr = 0U;
    
#line 374 
    channel->eventq_init = (_Bool)1;
  }
  else ;
  
#line 376 
  return rc;
}


#line 380  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
void efx_start_eventq(struct efx_channel *channel)
{
  
#line 382 
  if (((channel->efx)->msg_enable & 32U) != 0U) {
    
#line 382 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_start_eventq", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "chan %d start event queue\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))383U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 382 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 382 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)(channel->efx)->net_dev,"chan %d start event queue\n",channel->channel); else ;
  }
  else ;
  
#line 386 
  channel->enabled = (_Bool)1;
  
#line 387 
  ldv_inline_asm();
  
#line 389 
  efx_channel_enable(channel);
  
#line 390 
  napi_enable(& channel->napi_str);
  
#line 391 
  efx_nic_eventq_read_ack(channel);
  
#line 392 
  return;
}


#line 395  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
void efx_stop_eventq(struct efx_channel *channel)
{
  int tmp_0;
  bool tmp;
  
#line 397 
  if (! channel->enabled) 
#line 398 
                          goto return_label; else ;
  
#line 400 
  napi_disable(& channel->napi_str);
  
#line 401 
  goto ldv_56979;
  ldv_56978: 
#line 402 
  ;
  
#line 402 
  usleep_range(1000UL,20000UL);
  ldv_56979: 
#line 403 
  ;
  
#line 401 
  tmp = efx_channel_disable(channel);
  
#line 401 
  if (tmp) 
#line 401 
           tmp_0 = 0; else 
#line 401 
                           tmp_0 = 1;
  
#line 401 
  if (tmp_0) 
#line 403 
             goto ldv_56978; else 
#line 406 
                                  goto ldv_56980;
  ldv_56980: 
#line 407 
  ;
  
#line 403 
  channel->enabled = (_Bool)0;
  return_label: 
#line 404 
                return;
}


#line 406  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_fini_eventq(struct efx_channel *channel)
{
  
#line 408 
  if (! channel->eventq_init) 
#line 409 
                              goto return_label; else ;
  
#line 411 
  if (((channel->efx)->msg_enable & 1U) != 0U) {
    
#line 411 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_fini_eventq", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "chan %d fini event queue\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))412U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 411 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 411 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)(channel->efx)->net_dev,"chan %d fini event queue\n",channel->channel); else ;
  }
  else ;
  
#line 414 
  efx_nic_fini_eventq(channel);
  
#line 415 
  channel->eventq_init = (_Bool)0;
  return_label: 
#line 416 
                return;
}


#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_remove_eventq(struct efx_channel *channel)
{
  
#line 420 
  if (((channel->efx)->msg_enable & 1U) != 0U) {
    
#line 420 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_remove_eventq", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "chan %d remove event queue\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))421U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 420 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 420 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)(channel->efx)->net_dev,"chan %d remove event queue\n",channel->channel); else ;
  }
  else ;
  
#line 423 
  efx_nic_remove_eventq(channel);
  
#line 424 
  return;
}


#line 434  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static struct efx_channel *efx_alloc_channel(struct efx_nic *efx, int i, struct efx_channel *old_channel)
{
  struct efx_channel *__retres;
  struct efx_channel *channel;
  struct efx_rx_queue *rx_queue;
  struct efx_tx_queue *tx_queue;
  int j;
  
#line 441 
  channel = (struct efx_channel *)kzalloc_10(2176UL,208U);
  
#line 442 
  if (channel == (struct efx_channel *)0) {
    
#line 443 
    __retres = (struct efx_channel *)0;
    
#line 443 
    goto return_label;
  }
  else ;
  
#line 445 
  channel->efx = efx;
  
#line 446 
  channel->channel = i;
  
#line 447 
  channel->type = & efx_default_channel_type;
  
#line 449 
  j = 0;
  
#line 449 
  goto ldv_57001;
  ldv_57000: 
#line 450 
  ;
  
#line 450 
  tx_queue = & channel->tx_queue[j];
  
#line 451 
  tx_queue->efx = efx;
  
#line 452 
  tx_queue->queue = (unsigned int)(i * 4 + j);
  
#line 453 
  tx_queue->channel = channel;
  
#line 449 
  j += 1;
  ldv_57001: 
#line 450 
  ;
  
#line 449 
  if (j <= 3) 
#line 451 
              goto ldv_57000; else 
#line 454 
                                   goto ldv_57002;
  ldv_57002: 
#line 455 
  ;
  
#line 456 
  rx_queue = & channel->rx_queue;
  
#line 457 
  rx_queue->efx = efx;
  {
    struct lock_class_key __key;
    
#line 458 
    init_timer_key(& rx_queue->slow_fill,0U,"((&rx_queue->slow_fill))",& __key);
  }
  
#line 458 
  rx_queue->slow_fill.function = & efx_rx_slow_fill;
  
#line 458 
  rx_queue->slow_fill.data = (unsigned long)rx_queue;
  
#line 461 
  __retres = channel;
  return_label: 
#line 461 
                return __retres;
}


#line 468  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static struct efx_channel *efx_copy_channel(struct efx_channel const *old_channel)
{
  struct efx_channel *__retres;
  struct efx_channel *channel;
  struct efx_rx_queue *rx_queue;
  struct efx_tx_queue *tx_queue;
  int j;
  
#line 475 
  channel = (struct efx_channel *)kmalloc_4(2176UL,208U);
  
#line 476 
  if (channel == (struct efx_channel *)0) {
    
#line 477 
    __retres = (struct efx_channel *)0;
    
#line 477 
    goto return_label;
  }
  else ;
  
#line 479 
  *channel = *old_channel;
  
#line 481 
  channel->napi_dev = (struct net_device *)0;
  
#line 482 
  memset((void *)(& channel->eventq),0,32UL);
  
#line 484 
  j = 0;
  
#line 484 
  goto ldv_57012;
  ldv_57011: 
#line 485 
  ;
  
#line 485 
  tx_queue = & channel->tx_queue[j];
  
#line 486 
  if (tx_queue->channel != (struct efx_channel *)0) 
#line 487 
                                                    tx_queue->channel = channel; else ;
  
#line 488 
  tx_queue->buffer = (struct efx_tx_buffer *)0;
  
#line 489 
  memset((void *)(& tx_queue->txd),0,32UL);
  
#line 484 
  j += 1;
  ldv_57012: 
#line 485 
  ;
  
#line 484 
  if (j <= 3) 
#line 486 
              goto ldv_57011; else 
#line 489 
                                   goto ldv_57013;
  ldv_57013: 
#line 490 
  ;
  
#line 492 
  rx_queue = & channel->rx_queue;
  
#line 493 
  rx_queue->buffer = (struct efx_rx_buffer *)0;
  
#line 494 
  memset((void *)(& rx_queue->rxd),0,32UL);
  {
    struct lock_class_key __key;
    
#line 495 
    init_timer_key(& rx_queue->slow_fill,0U,"((&rx_queue->slow_fill))",& __key);
  }
  
#line 495 
  rx_queue->slow_fill.function = & efx_rx_slow_fill;
  
#line 495 
  rx_queue->slow_fill.data = (unsigned long)rx_queue;
  
#line 498 
  __retres = channel;
  return_label: 
#line 498 
                return __retres;
}


#line 501  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_probe_channel(struct efx_channel *channel)
{
  int __retres;
  struct efx_tx_queue *tx_queue;
  struct efx_rx_queue *rx_queue;
  int rc;
  int tmp_1;
  bool tmp_0;
  int tmp_3;
  bool tmp_2;
  
#line 507 
  if (((channel->efx)->msg_enable & 2U) != 0U) {
    
#line 507 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_probe_channel", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "creating channel %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))508U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 507 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 507 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)(channel->efx)->net_dev,"creating channel %d\n",channel->channel); else ;
  }
  else ;
  
#line 510 
  rc = (*((channel->type)->pre_probe))(channel);
  
#line 511 
  if (rc != 0) 
#line 512 
               goto fail; else ;
  
#line 514 
  rc = efx_probe_eventq(channel);
  
#line 515 
  if (rc != 0) 
#line 516 
               goto fail; else ;
  
#line 518 
  tmp_0 = efx_channel_has_tx_queues(channel);
  
#line 518 
  if (tmp_0) 
#line 518 
             tmp_1 = 0; else 
#line 518 
                             tmp_1 = 1;
  
#line 518 
  if (tmp_1) ;
  else {
    
#line 518 
    tx_queue = (struct efx_tx_queue *)(& channel->tx_queue);
    
#line 518 
    goto ldv_57025;
    ldv_57024: 
#line 519 
    ;
    
#line 519 
    rc = efx_probe_tx_queue(tx_queue);
    
#line 520 
    if (rc != 0) 
#line 521 
                 goto fail; else ;
    
#line 518 
    tx_queue += 1;
    ldv_57025: 
#line 519 
    ;
    
#line 518 
    if ((struct efx_tx_queue *)(& channel->tx_queue) + 4U > tx_queue) {
      bool tmp;
      
#line 518 
      tmp = efx_tx_queue_used(tx_queue);
      
#line 518 
      if ((int)tmp != 0) 
#line 520 
                         goto ldv_57024; else 
#line 523 
                                              goto ldv_57026;
    }
    else 
#line 523 
         goto ldv_57026;
    ldv_57026: 
#line 524 
    ;
  }
  
#line 524 
  tmp_2 = efx_channel_has_rx_queue(channel);
  
#line 524 
  if (tmp_2) 
#line 524 
             tmp_3 = 0; else 
#line 524 
                             tmp_3 = 1;
  
#line 524 
  if (tmp_3) ;
  else {
    
#line 524 
    rx_queue = & channel->rx_queue;
    
#line 524 
    goto ldv_57028;
    ldv_57027: 
#line 525 
    ;
    
#line 525 
    rc = efx_probe_rx_queue(rx_queue);
    
#line 526 
    if (rc != 0) 
#line 527 
                 goto fail; else ;
    
#line 524 
    rx_queue = (struct efx_rx_queue *)0;
    ldv_57028: 
#line 525 
    ;
    
#line 524 
    if (rx_queue != (struct efx_rx_queue *)0) 
#line 526 
                                              goto ldv_57027; else 
#line 529 
                                                                   goto ldv_57029;
    ldv_57029: 
#line 530 
    ;
  }
  
#line 530 
  __retres = 0;
  
#line 530 
  goto return_label;
  fail: 
#line 532 
  ;
  
#line 533 
  efx_remove_channel(channel);
  
#line 534 
  __retres = rc;
  return_label: 
#line 534 
                return __retres;
}


#line 538  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_get_channel_name(struct efx_channel *channel, char *buf, size_t len)
{
  char const *type;
  int number;
  
#line 540 
  struct efx_nic *efx = channel->efx;
  
#line 544 
  number = channel->channel;
  
#line 545 
  if (efx->tx_channel_offset == 0U) 
#line 546 
                                    type = "";
  else 
    
#line 547 
    if ((unsigned int)channel->channel < efx->tx_channel_offset) 
#line 548 
                                                                 type = "-rx";
    else {
      
#line 550 
      type = "-tx";
      
#line 551 
      number = (int)((unsigned int)number - efx->tx_channel_offset);
    }
  
#line 553 
  snprintf(buf,len,"%s%s-%d",(char *)(& efx->name),type,number);
  
#line 554 
  return;
}


#line 556  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_set_channel_names(struct efx_nic *efx)
{
  struct efx_channel *channel;
  
#line 560 
  channel = efx->channel[0];
  
#line 560 
  goto ldv_57043;
  ldv_57042: 
#line 561 
  ;
  
#line 561 
  (*((channel->type)->get_name))(channel,(char *)(& efx->msi_context[channel->channel].name),22UL);
  
#line 560 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 560 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 560 
                                                                    channel = (struct efx_channel *)0;
  ldv_57043: 
#line 561 
  ;
  
#line 560 
  if (channel != (struct efx_channel *)0) 
#line 562 
                                          goto ldv_57042; else 
#line 565 
                                                               goto ldv_57044;
  ldv_57044: 
#line 566 
  ;
  
#line 567 
  return;
}


#line 566  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_probe_channels(struct efx_nic *efx)
{
  int __retres;
  struct efx_channel *channel;
  int rc;
  
#line 572 
  efx->next_buffer_table = 0U;
  
#line 579 
  channel = efx->channel[efx->n_channels + 4294967295U];
  
#line 579 
  goto ldv_57052;
  ldv_57051: 
#line 580 
  ;
  
#line 580 
  rc = efx_probe_channel(channel);
  
#line 581 
  if (rc != 0) {
    
#line 582 
    if ((efx->msg_enable & 2U) != 0U) 
#line 582 
                                      netdev_err((struct net_device const *)efx->net_dev,"failed to create channel %d\n",channel->channel); else ;
    
#line 585 
    goto fail;
  }
  else ;
  
#line 579 
  if (channel->channel != 0) 
#line 579 
                             channel = efx->channel[channel->channel + -1]; else 
                                                                    
#line 579 
                                                                    channel = (struct efx_channel *)0;
  ldv_57052: 
#line 580 
  ;
  
#line 579 
  if (channel != (struct efx_channel *)0) 
#line 581 
                                          goto ldv_57051; else 
#line 584 
                                                               goto ldv_57053;
  ldv_57053: 
#line 585 
  ;
  
#line 588 
  efx_set_channel_names(efx);
  
#line 590 
  __retres = 0;
  
#line 590 
  goto return_label;
  fail: 
#line 592 
  ;
  
#line 593 
  efx_remove_channels(efx);
  
#line 594 
  __retres = rc;
  return_label: 
#line 594 
                return __retres;
}


#line 622 
void __compiletime_assert_622(void);


#line 623 
void __compiletime_assert_626(void);


#line 601  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_start_datapath(struct efx_nic *efx)
{
  struct efx_tx_queue *tx_queue;
  struct efx_rx_queue *rx_queue;
  struct efx_channel *channel;
  size_t rx_buf_len;
  unsigned int tmp_72;
  int tmp_75;
  bool tmp_74;
  int tmp_77;
  bool tmp_76;
  bool tmp_78_0;
  
#line 603 
  bool old_rx_scatter = efx->rx_scatter;
  
#line 613 
  efx->rx_dma_len = ((efx->rx_prefix_size + (((efx->net_dev)->mtu + 29U) & 4294967288U)) + (efx->type)->rx_buffer_padding) + 16U;
  
#line 616 
  rx_buf_len = ((unsigned long)efx->rx_ip_align + (unsigned long)efx->rx_dma_len) + 64UL;
  
#line 618 
  if (rx_buf_len <= 4096UL) {
    
#line 619 
    efx->rx_scatter = (efx->type)->always_rx_scatter;
    
#line 620 
    efx->rx_buffer_order = 0U;
  }
  else 
    
#line 621 
    if ((int)(efx->type)->can_rx_scatter != 0) {
      {
        
#line 622 
        bool __cond = (_Bool)0;
        
#line 622 
        if ((int)__cond != 0) 
#line 622 
                              __compiletime_assert_622(); else ;
      }
      {
        
#line 623 
        bool __cond_0 = (_Bool)0;
        
#line 623 
        if ((int)__cond_0 != 0) 
#line 623 
                                __compiletime_assert_626(); else ;
      }
      
#line 627 
      efx->rx_scatter = (_Bool)1;
      
#line 628 
      efx->rx_dma_len = 1792U;
      
#line 629 
      efx->rx_buffer_order = 0U;
    }
    else {
      int tmp_71;
      
#line 631 
      efx->rx_scatter = (_Bool)0;
      
#line 632 
      if (0 != 0) {
        int tmp_69;
        
#line 632 
        if (rx_buf_len != 0UL) {
          int tmp_68;
          
#line 632 
          if (rx_buf_len > 4095UL) {
            int tmp_67;
            
#line 632 
            if (0 != 0) {
              int tmp_65;
              
#line 632 
              if (rx_buf_len == 1UL) {
                int tmp;
                
#line 632 
                tmp = ____ilog2_NaN();
                
#line 632 
                tmp_65 = tmp + -11;
              }
              else {
                int tmp_64;
                
#line 632 
                if (rx_buf_len + 18446744073709551615UL >= (size_t)0) {
                  int tmp_63;
                  
#line 632 
                  if (((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 4611686018427387904ULL) == 0ULL) {
                    int tmp_62;
                    
#line 632 
                    if (((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 2305843009213693952ULL) == 0ULL) {
                      int tmp_61;
                      
#line 632 
                      if (((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 1152921504606846976ULL) == 0ULL) {
                        int tmp_60;
                        
#line 632 
                        if (((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 576460752303423488ULL) == 0ULL) {
                          int tmp_59;
                          
#line 632 
                          if (((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 288230376151711744ULL) == 0ULL) {
                            int tmp_58;
                            
#line 632 
                            if (((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 144115188075855872ULL) == 0ULL) {
                              int tmp_57;
                              
#line 632 
                              if (((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 72057594037927936ULL) == 0ULL) {
                                int tmp_56;
                                
#line 632 
                                if (((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 36028797018963968ULL) == 0ULL) {
                                  int tmp_55;
                                  
#line 632 
                                  if (((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 18014398509481984ULL) == 0ULL) {
                                    int tmp_54;
                                    
#line 632 
                                    if (((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 9007199254740992ULL) == 0ULL) {
                                      int tmp_53;
                                      
#line 632 
                                      if (((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 4503599627370496ULL) == 0ULL) {
                                        int tmp_52;
                                        
#line 632 
                                        if (((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 2251799813685248ULL) == 0ULL) {
                                          int tmp_51;
                                          
#line 632 
                                          if (((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 1125899906842624ULL) == 0ULL) {
                                            int tmp_50;
                                            
#line 632 
                                            if (((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 562949953421312ULL) == 0ULL) {
                                              int tmp_49;
                                              
#line 632 
                                              if (((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 281474976710656ULL) == 0ULL) {
                                                int tmp_48;
                                                
#line 632 
                                                if (((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 140737488355328ULL) == 0ULL) {
                                                  int tmp_47;
                                                  
#line 632 
                                                  if (((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 70368744177664ULL) == 0ULL) {
                                                    int tmp_46;
                                                    
#line 632 
                                                    if (((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 35184372088832ULL) == 0ULL) {
                                                      int tmp_45;
                                                      
#line 632 
                                                      if (((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 17592186044416ULL) == 0ULL) {
                                                        int tmp_44;
                                                        
#line 632 
                                                        if (((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 8796093022208ULL) == 0ULL) {
                                                          int tmp_43;
                                                          
#line 632 
                                                          if (((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 4398046511104ULL) == 0ULL) {
                                                            int tmp_42;
                                                            
#line 632 
                                                            if (((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 2199023255552ULL) == 0ULL) {
                                                              int tmp_41;
                                                              
#line 632 
                                                              if (((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 1099511627776ULL) == 0ULL) {
                                                                int tmp_40;
                                                                
#line 632 
                                                                if (((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 549755813888ULL) == 0ULL) {
                                                                  int tmp_39;
                                                                  
#line 632 
                                                                  if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 274877906944ULL) == 0ULL) {
                                                                    int tmp_38;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 137438953472ULL) == 0ULL) {
                                                                    int tmp_37;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 68719476736ULL) == 0ULL) {
                                                                    int tmp_36;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 34359738368ULL) == 0ULL) {
                                                                    int tmp_35;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 17179869184ULL) == 0ULL) {
                                                                    int tmp_34;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 8589934592ULL) == 0ULL) {
                                                                    int tmp_33;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 4294967296ULL) == 0ULL) {
                                                                    int tmp_32;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 2147483648ULL) == 0ULL) {
                                                                    int tmp_31;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 1073741824ULL) == 0ULL) {
                                                                    int tmp_30;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 536870912ULL) == 0ULL) {
                                                                    int tmp_29;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 268435456ULL) == 0ULL) {
                                                                    int tmp_28;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 134217728ULL) == 0ULL) {
                                                                    int tmp_27;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 67108864ULL) == 0ULL) {
                                                                    int tmp_26;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 33554432ULL) == 0ULL) {
                                                                    int tmp_25;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 16777216ULL) == 0ULL) {
                                                                    int tmp_24;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 8388608ULL) == 0ULL) {
                                                                    int tmp_23;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 4194304ULL) == 0ULL) {
                                                                    int tmp_22;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 2097152ULL) == 0ULL) {
                                                                    int tmp_21;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 1048576ULL) == 0ULL) {
                                                                    int tmp_20;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 524288ULL) == 0ULL) {
                                                                    int tmp_19;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 262144ULL) == 0ULL) {
                                                                    int tmp_18;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 131072ULL) == 0ULL) {
                                                                    int tmp_17;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 65536ULL) == 0ULL) {
                                                                    int tmp_16;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 32768ULL) == 0ULL) {
                                                                    int tmp_15;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 16384ULL) == 0ULL) {
                                                                    int tmp_14;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 8192ULL) == 0ULL) {
                                                                    int tmp_13;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 4096ULL) == 0ULL) {
                                                                    int tmp_12;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 2048ULL) == 0ULL) {
                                                                    int tmp_11;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 1024ULL) == 0ULL) {
                                                                    int tmp_10;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 512ULL) == 0ULL) {
                                                                    int tmp_9;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 256ULL) == 0ULL) {
                                                                    int tmp_8;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 128ULL) == 0ULL) {
                                                                    int tmp_7;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 64ULL) == 0ULL) {
                                                                    int tmp_6;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 32ULL) == 0ULL) {
                                                                    int tmp_5;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 16ULL) == 0ULL) {
                                                                    int tmp_4;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 8ULL) == 0ULL) {
                                                                    int tmp_3;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 4ULL) == 0ULL) {
                                                                    int tmp_2;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 2ULL) == 0ULL) {
                                                                    int tmp_1;
                                                                    
#line 632 
                                                                    if (
                                                                    ((unsigned long long)(rx_buf_len + 18446744073709551615UL) & 1ULL) == 0ULL) {
                                                                    int tmp_0;
                                                                    
#line 632 
                                                                    tmp_0 = ____ilog2_NaN();
                                                                    
#line 632 
                                                                    tmp_1 = tmp_0 + -11;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_1 = -11;
                                                                    
#line 632 
                                                                    tmp_2 = tmp_1;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_2 = -10;
                                                                    
#line 632 
                                                                    tmp_3 = tmp_2;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_3 = -9;
                                                                    
#line 632 
                                                                    tmp_4 = tmp_3;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_4 = -8;
                                                                    
#line 632 
                                                                    tmp_5 = tmp_4;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_5 = -7;
                                                                    
#line 632 
                                                                    tmp_6 = tmp_5;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_6 = -6;
                                                                    
#line 632 
                                                                    tmp_7 = tmp_6;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_7 = -5;
                                                                    
#line 632 
                                                                    tmp_8 = tmp_7;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_8 = -4;
                                                                    
#line 632 
                                                                    tmp_9 = tmp_8;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_9 = -3;
                                                                    
#line 632 
                                                                    tmp_10 = tmp_9;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_10 = -2;
                                                                    
#line 632 
                                                                    tmp_11 = tmp_10;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_11 = -1;
                                                                    
#line 632 
                                                                    tmp_12 = tmp_11;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_12 = 0;
                                                                    
#line 632 
                                                                    tmp_13 = tmp_12;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_13 = 1;
                                                                    
#line 632 
                                                                    tmp_14 = tmp_13;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_14 = 2;
                                                                    
#line 632 
                                                                    tmp_15 = tmp_14;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_15 = 3;
                                                                    
#line 632 
                                                                    tmp_16 = tmp_15;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_16 = 4;
                                                                    
#line 632 
                                                                    tmp_17 = tmp_16;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_17 = 5;
                                                                    
#line 632 
                                                                    tmp_18 = tmp_17;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_18 = 6;
                                                                    
#line 632 
                                                                    tmp_19 = tmp_18;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_19 = 7;
                                                                    
#line 632 
                                                                    tmp_20 = tmp_19;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_20 = 8;
                                                                    
#line 632 
                                                                    tmp_21 = tmp_20;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_21 = 9;
                                                                    
#line 632 
                                                                    tmp_22 = tmp_21;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_22 = 10;
                                                                    
#line 632 
                                                                    tmp_23 = tmp_22;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_23 = 11;
                                                                    
#line 632 
                                                                    tmp_24 = tmp_23;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_24 = 12;
                                                                    
#line 632 
                                                                    tmp_25 = tmp_24;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_25 = 13;
                                                                    
#line 632 
                                                                    tmp_26 = tmp_25;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_26 = 14;
                                                                    
#line 632 
                                                                    tmp_27 = tmp_26;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_27 = 15;
                                                                    
#line 632 
                                                                    tmp_28 = tmp_27;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_28 = 16;
                                                                    
#line 632 
                                                                    tmp_29 = tmp_28;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_29 = 17;
                                                                    
#line 632 
                                                                    tmp_30 = tmp_29;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_30 = 18;
                                                                    
#line 632 
                                                                    tmp_31 = tmp_30;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_31 = 19;
                                                                    
#line 632 
                                                                    tmp_32 = tmp_31;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_32 = 20;
                                                                    
#line 632 
                                                                    tmp_33 = tmp_32;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_33 = 21;
                                                                    
#line 632 
                                                                    tmp_34 = tmp_33;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_34 = 22;
                                                                    
#line 632 
                                                                    tmp_35 = tmp_34;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_35 = 23;
                                                                    
#line 632 
                                                                    tmp_36 = tmp_35;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_36 = 24;
                                                                    
#line 632 
                                                                    tmp_37 = tmp_36;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_37 = 25;
                                                                    
#line 632 
                                                                    tmp_38 = tmp_37;
                                                                    }
                                                                    else 
                                                                    
#line 632 
                                                                    tmp_38 = 26;
                                                                    
#line 632 
                                                                    tmp_39 = tmp_38;
                                                                  }
                                                                  else 
                                                                    
#line 632 
                                                                    tmp_39 = 27;
                                                                  
#line 632 
                                                                  tmp_40 = tmp_39;
                                                                }
                                                                else 
                                                                  
#line 632 
                                                                  tmp_40 = 28;
                                                                
#line 632 
                                                                tmp_41 = tmp_40;
                                                              }
                                                              else 
#line 632 
                                                                   tmp_41 = 29;
                                                              
#line 632 
                                                              tmp_42 = tmp_41;
                                                            }
                                                            else 
#line 632 
                                                                 tmp_42 = 30;
                                                            
#line 632 
                                                            tmp_43 = tmp_42;
                                                          }
                                                          else 
#line 632 
                                                               tmp_43 = 31;
                                                          
#line 632 
                                                          tmp_44 = tmp_43;
                                                        }
                                                        else 
#line 632 
                                                             tmp_44 = 32;
                                                        
#line 632 
                                                        tmp_45 = tmp_44;
                                                      }
                                                      else 
#line 632 
                                                           tmp_45 = 33;
                                                      
#line 632 
                                                      tmp_46 = tmp_45;
                                                    }
                                                    else 
#line 632 
                                                         tmp_46 = 34;
                                                    
#line 632 
                                                    tmp_47 = tmp_46;
                                                  }
                                                  else 
#line 632 
                                                       tmp_47 = 35;
                                                  
#line 632 
                                                  tmp_48 = tmp_47;
                                                }
                                                else 
#line 632 
                                                     tmp_48 = 36;
                                                
#line 632 
                                                tmp_49 = tmp_48;
                                              }
                                              else 
#line 632 
                                                   tmp_49 = 37;
                                              
#line 632 
                                              tmp_50 = tmp_49;
                                            }
                                            else 
#line 632 
                                                 tmp_50 = 38;
                                            
#line 632 
                                            tmp_51 = tmp_50;
                                          }
                                          else 
#line 632 
                                               tmp_51 = 39;
                                          
#line 632 
                                          tmp_52 = tmp_51;
                                        }
                                        else 
#line 632 
                                             tmp_52 = 40;
                                        
#line 632 
                                        tmp_53 = tmp_52;
                                      }
                                      else 
#line 632 
                                           tmp_53 = 41;
                                      
#line 632 
                                      tmp_54 = tmp_53;
                                    }
                                    else 
#line 632 
                                         tmp_54 = 42;
                                    
#line 632 
                                    tmp_55 = tmp_54;
                                  }
                                  else 
#line 632 
                                       tmp_55 = 43;
                                  
#line 632 
                                  tmp_56 = tmp_55;
                                }
                                else 
#line 632 
                                     tmp_56 = 44;
                                
#line 632 
                                tmp_57 = tmp_56;
                              }
                              else 
#line 632 
                                   tmp_57 = 45;
                              
#line 632 
                              tmp_58 = tmp_57;
                            }
                            else 
#line 632 
                                 tmp_58 = 46;
                            
#line 632 
                            tmp_59 = tmp_58;
                          }
                          else 
#line 632 
                               tmp_59 = 47;
                          
#line 632 
                          tmp_60 = tmp_59;
                        }
                        else 
#line 632 
                             tmp_60 = 48;
                        
#line 632 
                        tmp_61 = tmp_60;
                      }
                      else 
#line 632 
                           tmp_61 = 49;
                      
#line 632 
                      tmp_62 = tmp_61;
                    }
                    else 
#line 632 
                         tmp_62 = 50;
                    
#line 632 
                    tmp_63 = tmp_62;
                  }
                  else 
#line 632 
                       tmp_63 = 51;
                  
#line 632 
                  tmp_64 = tmp_63;
                }
                else 
#line 632 
                     tmp_64 = 52;
                
#line 632 
                tmp_65 = tmp_64;
              }
              
#line 632 
              tmp_67 = tmp_65;
            }
            else {
              int tmp_66;
              
#line 632 
              tmp_66 = __ilog2_u64((unsigned long long)(rx_buf_len + 18446744073709551615UL));
              
#line 632 
              tmp_67 = tmp_66 + -11;
            }
            
#line 632 
            tmp_68 = tmp_67;
          }
          else 
#line 632 
               tmp_68 = 0;
          
#line 632 
          tmp_69 = tmp_68;
        }
        else 
#line 632 
             tmp_69 = 52;
        
#line 632 
        tmp_71 = tmp_69;
      }
      else 
#line 632 
           tmp_71 = __get_order(rx_buf_len);
      
#line 632 
      efx->rx_buffer_order = (unsigned int)tmp_71;
    }
  
#line 635 
  efx_rx_config_page_split(efx);
  
#line 636 
  if (efx->rx_buffer_order != 0U) {
    
#line 637 
    if ((efx->msg_enable & 1U) != 0U) {
      
#line 637 
      struct _ddebug descriptor = {.modname = "sfc", .function = "efx_start_datapath", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "RX buf len=%u; page order=%u batch=%u\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))640U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 637 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 637 
                                                          __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"RX buf len=%u; page order=%u batch=%u\n",efx->rx_dma_len,efx->rx_buffer_order,efx->rx_pages_per_batch); else ;
    }
    else ;
  }
  else 
    
#line 642 
    if ((efx->msg_enable & 1U) != 0U) {
      
#line 642 
      struct _ddebug descriptor_0 = {.modname = "sfc", .function = "efx_start_datapath", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "RX buf len=%u step=%u bpp=%u; page batch=%u\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))645U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 642 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 642 
                                                            __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)efx->net_dev,"RX buf len=%u step=%u bpp=%u; page batch=%u\n",efx->rx_dma_len,efx->rx_page_buf_step,efx->rx_bufs_per_page,efx->rx_pages_per_batch); else ;
    }
    else ;
  
#line 648 
  if ((int)efx->rx_scatter != (int)old_rx_scatter) 
#line 649 
                                                   (*((efx->type)->filter_update_rx_scatter))(efx); else ;
  
#line 658 
  tmp_72 = efx_tx_max_skb_descs(efx);
  
#line 658 
  efx->txq_stop_thresh = efx->txq_entries - tmp_72;
  
#line 659 
  efx->txq_wake_thresh = efx->txq_stop_thresh / 2U;
  
#line 662 
  channel = efx->channel[0];
  
#line 662 
  goto ldv_57082;
  ldv_57081: 
#line 663 
  ;
  
#line 663 
  tmp_74 = efx_channel_has_tx_queues(channel);
  
#line 663 
  if (tmp_74) 
#line 663 
              tmp_75 = 0; else 
#line 663 
                               tmp_75 = 1;
  
#line 663 
  if (tmp_75) ;
  else {
    
#line 663 
    tx_queue = (struct efx_tx_queue *)(& channel->tx_queue);
    
#line 663 
    goto ldv_57074;
    ldv_57073: 
#line 664 
    ;
    
#line 664 
    efx_init_tx_queue(tx_queue);
    
#line 665 
    atomic_inc_4(& efx->active_queues);
    
#line 663 
    tx_queue += 1;
    ldv_57074: 
#line 664 
    ;
    
#line 663 
    if ((struct efx_tx_queue *)(& channel->tx_queue) + 4U > tx_queue) {
      bool tmp_73;
      
#line 663 
      tmp_73 = efx_tx_queue_used(tx_queue);
      
#line 663 
      if ((int)tmp_73 != 0) 
#line 665 
                            goto ldv_57073; else 
#line 668 
                                                 goto ldv_57075;
    }
    else 
#line 668 
         goto ldv_57075;
    ldv_57075: 
#line 669 
    ;
  }
  
#line 668 
  tmp_76 = efx_channel_has_rx_queue(channel);
  
#line 668 
  if (tmp_76) 
#line 668 
              tmp_77 = 0; else 
#line 668 
                               tmp_77 = 1;
  
#line 668 
  if (tmp_77) ;
  else {
    
#line 668 
    rx_queue = & channel->rx_queue;
    
#line 668 
    goto ldv_57077;
    ldv_57076: 
#line 669 
    ;
    
#line 669 
    efx_init_rx_queue(rx_queue);
    
#line 670 
    atomic_inc_4(& efx->active_queues);
    
#line 671 
    efx_stop_eventq(channel);
    
#line 672 
    efx_fast_push_rx_descriptors(rx_queue,(_Bool)0);
    
#line 673 
    efx_start_eventq(channel);
    
#line 668 
    rx_queue = (struct efx_rx_queue *)0;
    ldv_57077: 
#line 669 
    ;
    
#line 668 
    if (rx_queue != (struct efx_rx_queue *)0) 
#line 670 
                                              goto ldv_57076; else 
#line 673 
                                                                   goto ldv_57078;
    ldv_57078: 
#line 674 
    ;
  }
  {
    
#line 676 
    int __ret_warn_on = channel->rx_pkt_n_frags != 0U;
    
#line 676 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 676 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c",676); else ;
    
#line 676 
    long tmp_78 = (long)(__ret_warn_on != 0);
  }
  
#line 662 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 662 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 662 
                                                                    channel = (struct efx_channel *)0;
  ldv_57082: 
#line 663 
  ;
  
#line 662 
  if (channel != (struct efx_channel *)0) 
#line 664 
                                          goto ldv_57081; else 
#line 667 
                                                               goto ldv_57083;
  ldv_57083: 
#line 668 
  ;
  
#line 679 
  efx_ptp_start_datapath(efx);
  
#line 681 
  tmp_78_0 = netif_device_present(efx->net_dev);
  
#line 681 
  if ((int)tmp_78_0 != 0) 
#line 682 
                          netif_tx_wake_all_queues(efx->net_dev); else ;
  
#line 683 
  return;
}


#line 685  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_stop_datapath(struct efx_nic *efx)
{
  struct efx_channel *channel;
  struct efx_tx_queue *tx_queue;
  struct efx_rx_queue *rx_queue;
  int rc;
  int tmp_1;
  bool tmp_0;
  bool tmp_2;
  int tmp_5;
  bool tmp_4;
  int tmp_7;
  bool tmp_6;
  
#line 692 
  if ((efx->state == (unsigned int)STATE_READY || efx->state == (unsigned int)STATE_RECOVERY) || efx->state == (unsigned int)STATE_DISABLED) {
    int tmp;
    
#line 692 
    tmp = rtnl_is_locked();
    
#line 692 
    if ((long)(tmp == 0) != 0L) {
      
#line 692 
      printk("\001",(char *)"/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c",692);
      
#line 692 
      dump_stack();
    }
    else ;
  }
  else ;
  
#line 693 
  if ((long)((int)efx->port_enabled != 0) != 0L) {
    
#line 695 
    ldv_inline_asm();
    
#line 693 
    ;
  }
  else ;
  
#line 695 
  efx_ptp_stop_datapath(efx);
  
#line 698 
  channel = efx->channel[0];
  
#line 698 
  goto ldv_57095;
  ldv_57094: 
#line 699 
  ;
  
#line 699 
  tmp_0 = efx_channel_has_rx_queue(channel);
  
#line 699 
  if (tmp_0) 
#line 699 
             tmp_1 = 0; else 
#line 699 
                             tmp_1 = 1;
  
#line 699 
  if (tmp_1) ;
  else {
    
#line 699 
    rx_queue = & channel->rx_queue;
    
#line 699 
    goto ldv_57092;
    ldv_57091: 
#line 700 
    ;
    
#line 700 
    rx_queue->refill_enabled = (_Bool)0;
    
#line 699 
    rx_queue = (struct efx_rx_queue *)0;
    ldv_57092: 
#line 700 
    ;
    
#line 699 
    if (rx_queue != (struct efx_rx_queue *)0) 
#line 701 
                                              goto ldv_57091; else 
#line 704 
                                                                   goto ldv_57093;
    ldv_57093: 
#line 705 
    ;
  }
  
#line 698 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 698 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 698 
                                                                    channel = (struct efx_channel *)0;
  ldv_57095: 
#line 699 
  ;
  
#line 698 
  if (channel != (struct efx_channel *)0) 
#line 700 
                                          goto ldv_57094; else 
#line 703 
                                                               goto ldv_57096;
  ldv_57096: 
#line 704 
  ;
  
#line 703 
  channel = efx->channel[0];
  
#line 703 
  goto ldv_57098;
  ldv_57097: 
#line 704 
  ;
  
#line 710 
  tmp_2 = efx_channel_has_rx_queue(channel);
  
#line 710 
  if ((int)tmp_2 != 0) {
    
#line 711 
    efx_stop_eventq(channel);
    
#line 712 
    efx_start_eventq(channel);
  }
  else ;
  
#line 703 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 703 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 703 
                                                                    channel = (struct efx_channel *)0;
  ldv_57098: 
#line 704 
  ;
  
#line 703 
  if (channel != (struct efx_channel *)0) 
#line 705 
                                          goto ldv_57097; else 
#line 708 
                                                               goto ldv_57099;
  ldv_57099: 
#line 709 
  ;
  
#line 716 
  rc = (*((efx->type)->fini_dmaq))(efx);
  
#line 717 
  if (rc != 0) {
    int tmp_3;
    
#line 717 
    tmp_3 = efx_nic_rev(efx);
    
#line 717 
    if (tmp_3 <= 2) {
      
#line 723 
      if ((efx->msg_enable & 1U) != 0U) 
#line 723 
                                        netdev_err((struct net_device const *)efx->net_dev,"Resetting to recover from flush failure\n"); else ;
      
#line 725 
      efx_schedule_reset(efx,(enum reset_type)RESET_TYPE_ALL);
    }
    else 
#line 717 
         goto _LAND;
  }
  else {
    _LAND: 
#line 726 
    ;
    
#line 726 
    if (rc != 0) {
      
#line 727 
      if ((efx->msg_enable & 1U) != 0U) 
#line 727 
                                        netdev_err((struct net_device const *)efx->net_dev,"failed to flush queues\n"); else ;
    }
    else 
      
#line 729 
      if ((efx->msg_enable & 1U) != 0U) {
        
#line 729 
        struct _ddebug descriptor = {.modname = "sfc", .function = "efx_stop_datapath", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "successfully flushed all queues\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))730U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 729 
        if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 729 
                                                            __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"successfully flushed all queues\n"); else ;
      }
      else ;
  }
  
#line 733 
  channel = efx->channel[0];
  
#line 733 
  goto ldv_57109;
  ldv_57108: 
#line 734 
  ;
  
#line 734 
  tmp_4 = efx_channel_has_rx_queue(channel);
  
#line 734 
  if (tmp_4) 
#line 734 
             tmp_5 = 0; else 
#line 734 
                             tmp_5 = 1;
  
#line 734 
  if (tmp_5) ;
  else {
    
#line 734 
    rx_queue = & channel->rx_queue;
    
#line 734 
    goto ldv_57103;
    ldv_57102: 
#line 735 
    ;
    
#line 735 
    efx_fini_rx_queue(rx_queue);
    
#line 734 
    rx_queue = (struct efx_rx_queue *)0;
    ldv_57103: 
#line 735 
    ;
    
#line 734 
    if (rx_queue != (struct efx_rx_queue *)0) 
#line 736 
                                              goto ldv_57102; else 
#line 739 
                                                                   goto ldv_57104;
    ldv_57104: 
#line 740 
    ;
  }
  
#line 736 
  tmp_6 = efx_channel_has_tx_queues(channel);
  
#line 736 
  if (tmp_6) 
#line 736 
             tmp_7 = 0; else 
#line 736 
                             tmp_7 = 1;
  
#line 736 
  if (tmp_7) ;
  else {
    
#line 736 
    tx_queue = (struct efx_tx_queue *)(& channel->tx_queue);
    
#line 736 
    goto ldv_57106;
    ldv_57105: 
#line 737 
    ;
    
#line 737 
    efx_fini_tx_queue(tx_queue);
    
#line 736 
    tx_queue += 1;
    ldv_57106: 
#line 737 
    ;
    
#line 736 
    if ((struct efx_tx_queue *)(& channel->tx_queue) + 4U > tx_queue) 
      
#line 738 
      goto ldv_57105; else 
#line 741 
                           goto ldv_57107;
    ldv_57107: 
#line 742 
    ;
  }
  
#line 733 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 733 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 733 
                                                                    channel = (struct efx_channel *)0;
  ldv_57109: 
#line 734 
  ;
  
#line 733 
  if (channel != (struct efx_channel *)0) 
#line 735 
                                          goto ldv_57108; else 
#line 738 
                                                               goto ldv_57110;
  ldv_57110: 
#line 739 
  ;
  
#line 740 
  return;
}


#line 741  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_remove_channel(struct efx_channel *channel)
{
  struct efx_tx_queue *tx_queue;
  struct efx_rx_queue *rx_queue;
  int tmp_0;
  bool tmp;
  int tmp_2;
  bool tmp_1;
  
#line 746 
  if (((channel->efx)->msg_enable & 1U) != 0U) {
    
#line 746 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_remove_channel", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "destroy chan %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))747U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 746 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 746 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)(channel->efx)->net_dev,"destroy chan %d\n",channel->channel); else ;
  }
  else ;
  
#line 749 
  tmp = efx_channel_has_rx_queue(channel);
  
#line 749 
  if (tmp) 
#line 749 
           tmp_0 = 0; else 
#line 749 
                           tmp_0 = 1;
  
#line 749 
  if (tmp_0) ;
  else {
    
#line 749 
    rx_queue = & channel->rx_queue;
    
#line 749 
    goto ldv_57119;
    ldv_57118: 
#line 750 
    ;
    
#line 750 
    efx_remove_rx_queue(rx_queue);
    
#line 749 
    rx_queue = (struct efx_rx_queue *)0;
    ldv_57119: 
#line 750 
    ;
    
#line 749 
    if (rx_queue != (struct efx_rx_queue *)0) 
#line 751 
                                              goto ldv_57118; else 
#line 754 
                                                                   goto ldv_57120;
    ldv_57120: 
#line 755 
    ;
  }
  
#line 751 
  tmp_1 = efx_channel_has_tx_queues(channel);
  
#line 751 
  if (tmp_1) 
#line 751 
             tmp_2 = 0; else 
#line 751 
                             tmp_2 = 1;
  
#line 751 
  if (tmp_2) ;
  else {
    
#line 751 
    tx_queue = (struct efx_tx_queue *)(& channel->tx_queue);
    
#line 751 
    goto ldv_57122;
    ldv_57121: 
#line 752 
    ;
    
#line 752 
    efx_remove_tx_queue(tx_queue);
    
#line 751 
    tx_queue += 1;
    ldv_57122: 
#line 752 
    ;
    
#line 751 
    if ((struct efx_tx_queue *)(& channel->tx_queue) + 4U > tx_queue) 
      
#line 753 
      goto ldv_57121; else 
#line 756 
                           goto ldv_57123;
    ldv_57123: 
#line 757 
    ;
  }
  
#line 753 
  efx_remove_eventq(channel);
  
#line 754 
  (*((channel->type)->post_remove))(channel);
  
#line 755 
  return;
}


#line 757  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_remove_channels(struct efx_nic *efx)
{
  struct efx_channel *channel;
  
#line 761 
  channel = efx->channel[0];
  
#line 761 
  goto ldv_57129;
  ldv_57128: 
#line 762 
  ;
  
#line 762 
  efx_remove_channel(channel);
  
#line 761 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 761 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 761 
                                                                    channel = (struct efx_channel *)0;
  ldv_57129: 
#line 762 
  ;
  
#line 761 
  if (channel != (struct efx_channel *)0) 
#line 763 
                                          goto ldv_57128; else 
#line 766 
                                                               goto ldv_57130;
  ldv_57130: 
#line 767 
  ;
  
#line 768 
  return;
}


#line 766  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
int efx_realloc_channels(struct efx_nic *efx, u32 rxq_entries, u32 txq_entries)
{
  int __retres;
  struct efx_channel *other_channel[32U];
  struct efx_channel *channel;
  u32 old_rxq_entries;
  u32 old_txq_entries;
  unsigned int i;
  int rc;
  int rc2;
  
#line 770 
  unsigned int next_buffer_table = 0U;
  
#line 773 
  rc = efx_check_disabled(efx);
  
#line 774 
  if (rc != 0) {
    
#line 775 
    __retres = rc;
    
#line 775 
    goto return_label;
  }
  else ;
  
#line 780 
  channel = efx->channel[0];
  
#line 780 
  goto ldv_57163;
  ldv_57162: 
#line 781 
  ;
  {
    struct efx_rx_queue *rx_queue;
    struct efx_tx_queue *tx_queue;
    unsigned int tmp_0;
    int tmp_4;
    bool tmp_3;
    int tmp_9;
    bool tmp_8;
    
#line 784 
    if ((channel->type)->copy != (struct efx_channel *(*)(struct efx_channel const *))0) 
      
#line 785 
      goto ldv_57146; else ;
    {
      unsigned int tmp;
      
#line 786 
      unsigned int _max1 = next_buffer_table;
      
#line 786 
      unsigned int _max2 = channel->eventq.index + channel->eventq.entries;
      
#line 786 
      if (_max1 > _max2) 
#line 786 
                         tmp = _max1; else 
#line 786 
                                           tmp = _max2;
      
#line 786 
      tmp_0 = tmp;
    }
    
#line 786 
    next_buffer_table = tmp_0;
    
#line 789 
    tmp_3 = efx_channel_has_rx_queue(channel);
    
#line 789 
    if (tmp_3) 
#line 789 
               tmp_4 = 0; else 
#line 789 
                               tmp_4 = 1;
    
#line 789 
    if (tmp_4) ;
    else {
      unsigned int tmp_2;
      
#line 789 
      rx_queue = & channel->rx_queue;
      
#line 789 
      goto ldv_57154;
      ldv_57153: 
#line 790 
      ;
      {
        unsigned int tmp_1;
        
#line 790 
        unsigned int _max1_0 = next_buffer_table;
        
#line 790 
        unsigned int _max2_0 = rx_queue->rxd.index + rx_queue->rxd.entries;
        
#line 790 
        if (_max1_0 > _max2_0) 
#line 790 
                               tmp_1 = _max1_0; else 
#line 790 
                                                     tmp_1 = _max2_0;
        
#line 790 
        tmp_2 = tmp_1;
      }
      
#line 790 
      next_buffer_table = tmp_2;
      
#line 789 
      rx_queue = (struct efx_rx_queue *)0;
      ldv_57154: 
#line 790 
      ;
      
#line 789 
      if (rx_queue != (struct efx_rx_queue *)0) 
#line 791 
                                                goto ldv_57153; else 
                                                                  
#line 794 
                                                                  goto ldv_57155;
      ldv_57155: 
#line 795 
      ;
    }
    
#line 793 
    tmp_8 = efx_channel_has_tx_queues(channel);
    
#line 793 
    if (tmp_8) 
#line 793 
               tmp_9 = 0; else 
#line 793 
                               tmp_9 = 1;
    
#line 793 
    if (tmp_9) ;
    else {
      unsigned int tmp_6;
      
#line 793 
      tx_queue = (struct efx_tx_queue *)(& channel->tx_queue);
      
#line 793 
      goto ldv_57160;
      ldv_57159: 
#line 794 
      ;
      {
        unsigned int tmp_5;
        
#line 794 
        unsigned int _max1_1 = next_buffer_table;
        
#line 794 
        unsigned int _max2_1 = tx_queue->txd.index + tx_queue->txd.entries;
        
#line 794 
        if (_max1_1 > _max2_1) 
#line 794 
                               tmp_5 = _max1_1; else 
#line 794 
                                                     tmp_5 = _max2_1;
        
#line 794 
        tmp_6 = tmp_5;
      }
      
#line 794 
      next_buffer_table = tmp_6;
      
#line 793 
      tx_queue += 1;
      ldv_57160: 
#line 794 
      ;
      
#line 793 
      if ((struct efx_tx_queue *)(& channel->tx_queue) + 4U > tx_queue) {
        bool tmp_7;
        
#line 793 
        tmp_7 = efx_tx_queue_used(tx_queue);
        
#line 793 
        if ((int)tmp_7 != 0) 
#line 795 
                             goto ldv_57159; else 
#line 798 
                                                  goto ldv_57161;
      }
      else 
#line 798 
           goto ldv_57161;
      ldv_57161: 
#line 799 
      ;
    }
  }
  ldv_57146: 
#line 802 
  ;
  
#line 780 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 780 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 780 
                                                                    channel = (struct efx_channel *)0;
  ldv_57163: 
#line 781 
  ;
  
#line 780 
  if (channel != (struct efx_channel *)0) 
#line 782 
                                          goto ldv_57162; else 
#line 785 
                                                               goto ldv_57164;
  ldv_57164: 
#line 786 
  ;
  
#line 799 
  efx_device_detach_sync_2(efx);
  
#line 800 
  efx_stop_all(efx);
  
#line 801 
  efx_soft_disable_interrupts(efx);
  
#line 804 
  memset((void *)(& other_channel),0,256UL);
  
#line 805 
  i = 0U;
  
#line 805 
  goto ldv_57167;
  ldv_57166: 
#line 806 
  ;
  
#line 806 
  channel = efx->channel[i];
  
#line 807 
  if ((channel->type)->copy != (struct efx_channel *(*)(struct efx_channel const *))0) 
    
#line 808 
    channel = (*((channel->type)->copy))((struct efx_channel const *)channel); else ;
  
#line 809 
  if (channel == (struct efx_channel *)0) {
    
#line 810 
    rc = -12;
    
#line 811 
    goto out;
  }
  else ;
  
#line 813 
  other_channel[i] = channel;
  
#line 805 
  i += 1U;
  ldv_57167: 
#line 806 
  ;
  
#line 805 
  if (efx->n_channels > i) 
#line 807 
                           goto ldv_57166; else 
#line 810 
                                                goto ldv_57168;
  ldv_57168: 
#line 811 
  ;
  
#line 817 
  old_rxq_entries = efx->rxq_entries;
  
#line 818 
  old_txq_entries = efx->txq_entries;
  
#line 819 
  efx->rxq_entries = rxq_entries;
  
#line 820 
  efx->txq_entries = txq_entries;
  
#line 821 
  i = 0U;
  
#line 821 
  goto ldv_57170;
  ldv_57169: 
#line 822 
  ;
  
#line 822 
  channel = efx->channel[i];
  
#line 823 
  efx->channel[i] = other_channel[i];
  
#line 824 
  other_channel[i] = channel;
  
#line 821 
  i += 1U;
  ldv_57170: 
#line 822 
  ;
  
#line 821 
  if (efx->n_channels > i) 
#line 823 
                           goto ldv_57169; else 
#line 826 
                                                goto ldv_57171;
  ldv_57171: 
#line 827 
  ;
  
#line 828 
  efx->next_buffer_table = next_buffer_table;
  
#line 830 
  i = 0U;
  
#line 830 
  goto ldv_57175;
  ldv_57174: 
#line 831 
  ;
  
#line 831 
  channel = efx->channel[i];
  
#line 832 
  if ((channel->type)->copy == (struct efx_channel *(*)(struct efx_channel const *))0) 
    
#line 833 
    goto ldv_57172; else ;
  
#line 834 
  rc = efx_probe_channel(channel);
  
#line 835 
  if (rc != 0) 
#line 836 
               goto rollback; else ;
  
#line 837 
  efx_init_napi_channel(efx->channel[i]);
  ldv_57172: 
#line 838 
  ;
  
#line 830 
  i += 1U;
  ldv_57175: 
#line 831 
  ;
  
#line 830 
  if (efx->n_channels > i) 
#line 832 
                           goto ldv_57174; else 
#line 835 
                                                goto ldv_57176;
  ldv_57176: 
#line 836 
  ;
  out: 
#line 840 
  ;
  
#line 842 
  i = 0U;
  
#line 842 
  goto ldv_57178;
  ldv_57177: 
#line 843 
  ;
  
#line 843 
  channel = other_channel[i];
  
#line 844 
  if (channel != (struct efx_channel *)0 && (channel->type)->copy != (struct efx_channel *(*)(struct efx_channel const *))0) {
    
#line 845 
    efx_fini_napi_channel(channel);
    
#line 846 
    efx_remove_channel(channel);
    
#line 847 
    kfree((void const *)channel);
  }
  else ;
  
#line 842 
  i += 1U;
  ldv_57178: 
#line 843 
  ;
  
#line 842 
  if (efx->n_channels > i) 
#line 844 
                           goto ldv_57177; else 
#line 847 
                                                goto ldv_57179;
  ldv_57179: 
#line 848 
  ;
  
#line 851 
  rc2 = efx_soft_enable_interrupts(efx);
  
#line 852 
  if (rc2 != 0) {
    
#line 853 
    if (rc != 0) 
#line 853 
                 rc = rc; else 
#line 853 
                               rc = rc2;
    
#line 854 
    if ((efx->msg_enable & 1U) != 0U) 
#line 854 
                                      netdev_err((struct net_device const *)efx->net_dev,"unable to restart interrupts on channel reallocation\n"); else ;
    
#line 856 
    efx_schedule_reset(efx,(enum reset_type)RESET_TYPE_DISABLE);
  }
  else {
    
#line 858 
    efx_start_all(efx);
    
#line 859 
    netif_device_attach(efx->net_dev);
  }
  
#line 861 
  __retres = rc;
  
#line 861 
  goto return_label;
  rollback: 
#line 863 
  ;
  
#line 865 
  efx->rxq_entries = old_rxq_entries;
  
#line 866 
  efx->txq_entries = old_txq_entries;
  
#line 867 
  i = 0U;
  
#line 867 
  goto ldv_57181;
  ldv_57180: 
#line 868 
  ;
  
#line 868 
  channel = efx->channel[i];
  
#line 869 
  efx->channel[i] = other_channel[i];
  
#line 870 
  other_channel[i] = channel;
  
#line 867 
  i += 1U;
  ldv_57181: 
#line 868 
  ;
  
#line 867 
  if (efx->n_channels > i) 
#line 869 
                           goto ldv_57180; else 
#line 872 
                                                goto ldv_57182;
  ldv_57182: 
#line 873 
  ;
  
#line 872 
  goto out;
  return_label: 
#line 872 
                return __retres;
}


#line 875  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
void efx_schedule_slow_fill(struct efx_rx_queue *rx_queue)
{
  unsigned long tmp;
  
#line 877 
  tmp = msecs_to_jiffies(100U);
  
#line 877 
  ;
  
#line 877 
  ;
  
#line 877 
  ldv_mod_timer_87(& rx_queue->slow_fill,tmp + jiffies);
  
#line 878 
  return;
}


#line 880  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static struct efx_channel_type const efx_default_channel_type = {.handle_no_channel = (void (*)(struct efx_nic *))0, .pre_probe = & efx_channel_dummy_op_int, .post_remove = & efx_channel_dummy_op_void, .get_name = & efx_get_channel_name, .copy = & efx_copy_channel, .receive_skb = (bool (*)(struct efx_channel *, struct sk_buff *))0, .keep_eventq = (_Bool)0};

#line 888  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
int efx_channel_dummy_op_int(struct efx_channel *channel)
{
  int __retres;
  
#line 890 
  __retres = 0;
  
#line 890 
  return __retres;
}


#line 893  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
void efx_channel_dummy_op_void(struct efx_channel *channel)
{
  
#line 895 
  return;
}


#line 907  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
void efx_link_status_changed(struct efx_nic *efx)
{
  int tmp_0;
  bool tmp;
  bool tmp_1;
  
#line 909 
  struct efx_link_state *link_state = & efx->link_state;
  
#line 915 
  tmp = netif_running((struct net_device const *)efx->net_dev);
  
#line 915 
  if (tmp) 
#line 915 
           tmp_0 = 0; else 
#line 915 
                           tmp_0 = 1;
  
#line 915 
  if (tmp_0) 
#line 916 
             goto return_label; else ;
  
#line 918 
  tmp_1 = netif_carrier_ok((struct net_device const *)efx->net_dev);
  
#line 918 
  ;
  
#line 918 
  if ((int)link_state->up != (int)tmp_1) {
    
#line 919 
    efx->n_link_state_changes += 1U;
    
#line 921 
    if ((int)link_state->up != 0) 
#line 922 
                                  netif_carrier_on(efx->net_dev); else 
                                                                    
#line 924 
                                                                    netif_carrier_off(efx->net_dev);
  }
  else ;
  
#line 928 
  if ((int)link_state->up != 0) {
    
#line 929 
    if ((efx->msg_enable & 4U) != 0U) {
      char *tmp_2;
      
#line 929 
      ;
      
#line 929 
      if ((int)link_state->fd != 0) 
#line 929 
                                    tmp_2 = (char *)"full"; else 
#line 929 
                                                                 tmp_2 = (char *)"half";
      
#line 929 
      ;
      
#line 929 
      ;
      
#line 929 
      netdev_info((struct net_device const *)efx->net_dev,"link up at %uMbps %s-duplex (MTU %d)\n",link_state->speed,tmp_2,(efx->net_dev)->mtu);
    }
    else ;
  }
  else 
    
#line 934 
    if ((efx->msg_enable & 4U) != 0U) 
#line 934 
                                      netdev_info((struct net_device const *)efx->net_dev,"link down\n"); else ;
  return_label: 
#line 935 
                return;
}


#line 937  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
void efx_link_set_advertising(struct efx_nic *efx, u32 advertising)
{
  
#line 939 
  efx->link_advertising = advertising;
  
#line 940 
  if (advertising != 0U) {
    
#line 941 
    if ((advertising & 8192U) != 0U) 
#line 942 
                                     efx->wanted_fc = (unsigned char)((unsigned int)efx->wanted_fc | 3U); else 
                                                                    
#line 944 
                                                                    efx->wanted_fc = (unsigned char)((unsigned int)efx->wanted_fc & 252U);
    
#line 945 
    if ((advertising & 16384U) != 0U) 
#line 946 
                                      efx->wanted_fc = (unsigned char)((unsigned int)efx->wanted_fc ^ 1U); else ;
  }
  else ;
  
#line 948 
  return;
}


#line 950  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
void efx_link_set_wanted_fc(struct efx_nic *efx, u8 wanted_fc)
{
  
#line 952 
  efx->wanted_fc = wanted_fc;
  
#line 953 
  if (efx->link_advertising != 0U) {
    
#line 954 
    if (((int)wanted_fc & 2) != 0) 
#line 955 
                                   efx->link_advertising |= 24576U; else 
                                                                    
#line 958 
                                                                    efx->link_advertising &= 4294942719U;
    
#line 960 
    if (((int)wanted_fc & 1) != 0) 
#line 961 
                                   efx->link_advertising ^= 16384U; else ;
  }
  else ;
  
#line 963 
  return;
}


#line 965 
static void efx_fini_port(struct efx_nic *efx);


#line 970  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
void efx_mac_reconfigure(struct efx_nic *efx)
{
  
#line 972 
  down_read(& efx->filter_sem);
  
#line 973 
  (*((efx->type)->reconfigure_mac))(efx);
  
#line 974 
  up_read(& efx->filter_sem);
  
#line 975 
  return;
}


#line 984  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
int __efx_reconfigure_port(struct efx_nic *efx)
{
  enum efx_phy_mode phy_mode;
  int rc;
  {
    int tmp;
    
#line 989 
    tmp = ldv_mutex_is_locked_88(& efx->mac_lock);
    
#line 989 
    int __ret_warn_on = tmp == 0;
    
#line 989 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 989 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c",989); else ;
    
#line 989 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 992 
  phy_mode = efx->phy_mode;
  
#line 993 
  if (((66600958 >> (unsigned int)efx->loopback_mode) & 1) != 0) 
#line 994 
                                                                 efx->phy_mode = (enum efx_phy_mode)((unsigned int)efx->phy_mode | 1U); else 
                                                                    
#line 996 
                                                                    efx->phy_mode = (enum efx_phy_mode)((unsigned int)efx->phy_mode & 4294967294U);
  
#line 998 
  rc = (*((efx->type)->reconfigure_port))(efx);
  
#line 1000 
  if (rc != 0) 
#line 1001 
               efx->phy_mode = phy_mode; else ;
  
#line 1003 
  return rc;
}


#line 1008  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
int efx_reconfigure_port(struct efx_nic *efx)
{
  int rc;
  
#line 1012 
  if ((efx->state == (unsigned int)STATE_READY || efx->state == (unsigned int)STATE_RECOVERY) || efx->state == (unsigned int)STATE_DISABLED) {
    int tmp;
    
#line 1012 
    tmp = rtnl_is_locked();
    
#line 1012 
    if ((long)(tmp == 0) != 0L) {
      
#line 1012 
      printk("\001",(char *)"/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c",1012);
      
#line 1012 
      dump_stack();
    }
    else ;
  }
  else ;
  
#line 1014 
  ldv_mutex_lock_89_1(& efx->mac_lock);
  
#line 1015 
  rc = __efx_reconfigure_port(efx);
  
#line 1016 
  ldv_mutex_unlock_90_1(& efx->mac_lock);
  
#line 1018 
  return rc;
}


#line 1024  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_mac_work(struct work_struct *data)
{
  struct efx_nic *tmp;
  {
    
#line 1026 
    struct work_struct const *__mptr = (struct work_struct const *)data;
    
#line 1026 
    tmp = (struct efx_nic *)__mptr + 18446744073709548696U;
  }
  
#line 1026 
  struct efx_nic *efx = tmp;
  
#line 1028 
  ldv_mutex_lock_91_0(& efx->mac_lock);
  
#line 1029 
  if ((int)efx->port_enabled != 0) 
#line 1030 
                                   efx_mac_reconfigure(efx); else ;
  
#line 1031 
  ldv_mutex_unlock_92_0(& efx->mac_lock);
  
#line 1032 
  return;
}


#line 1034  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_probe_port(struct efx_nic *efx)
{
  int __retres;
  int rc;
  
#line 1038 
  if ((efx->msg_enable & 2U) != 0U) {
    
#line 1038 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_probe_port", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "create port\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1038U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1038 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1038 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"create port\n"); else ;
  }
  else ;
  
#line 1040 
  if ((int)phy_flash_cfg != 0) 
#line 1041 
                               efx->phy_mode = PHY_MODE_SPECIAL; else ;
  
#line 1044 
  rc = (*((efx->type)->probe_port))(efx);
  
#line 1045 
  if (rc != 0) {
    
#line 1046 
    __retres = rc;
    
#line 1046 
    goto return_label;
  }
  else ;
  
#line 1049 
  ether_addr_copy((efx->net_dev)->dev_addr,(u8 const *)(& (efx->net_dev)->perm_addr));
  
#line 1051 
  __retres = 0;
  return_label: 
#line 1051 
                return __retres;
}


#line 1054  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_init_port(struct efx_nic *efx)
{
  int __retres;
  int rc;
  
#line 1058 
  if ((efx->msg_enable & 1U) != 0U) {
    
#line 1058 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_init_port", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "init port\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1058U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1058 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1058 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"init port\n"); else ;
  }
  else ;
  
#line 1060 
  ldv_mutex_lock_93_1(& efx->mac_lock);
  
#line 1062 
  rc = (*((efx->phy_op)->init))(efx);
  
#line 1063 
  if (rc != 0) 
#line 1064 
               goto fail1; else ;
  
#line 1066 
  efx->port_initialized = (_Bool)1;
  
#line 1070 
  efx_mac_reconfigure(efx);
  
#line 1073 
  rc = (*((efx->phy_op)->reconfigure))(efx);
  
#line 1074 
  if ((unsigned int)rc + 1U > 1U) 
#line 1075 
                                  goto fail2; else ;
  
#line 1077 
  ldv_mutex_unlock_94_1(& efx->mac_lock);
  
#line 1078 
  __retres = 0;
  
#line 1078 
  goto return_label;
  fail2: 
#line 1080 
  ;
  
#line 1081 
  (*((efx->phy_op)->fini))(efx);
  fail1: 
#line 1082 
  ;
  
#line 1083 
  ldv_mutex_unlock_95(& efx->mac_lock);
  
#line 1084 
  __retres = rc;
  return_label: 
#line 1084 
                return __retres;
}


#line 1087  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_start_port(struct efx_nic *efx)
{
  
#line 1089 
  if ((efx->msg_enable & 32U) != 0U) {
    
#line 1089 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_start_port", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "start port\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1089U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1089 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1089 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"start port\n"); else ;
  }
  else ;
  
#line 1090 
  if ((long)((int)efx->port_enabled != 0) != 0L) {
    
#line 1092 
    ldv_inline_asm();
    
#line 1090 
    ;
  }
  else ;
  
#line 1092 
  ldv_mutex_lock_96(& efx->mac_lock);
  
#line 1093 
  efx->port_enabled = (_Bool)1;
  
#line 1096 
  efx_mac_reconfigure(efx);
  
#line 1098 
  ldv_mutex_unlock_97(& efx->mac_lock);
  
#line 1099 
  return;
}


#line 1106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_stop_port(struct efx_nic *efx)
{
  
#line 1108 
  if ((efx->msg_enable & 16U) != 0U) {
    
#line 1108 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_stop_port", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "stop port\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1108U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1108 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1108 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"stop port\n"); else ;
  }
  else ;
  
#line 1110 
  if ((efx->state == (unsigned int)STATE_READY || efx->state == (unsigned int)STATE_RECOVERY) || efx->state == (unsigned int)STATE_DISABLED) {
    int tmp;
    
#line 1110 
    tmp = rtnl_is_locked();
    
#line 1110 
    if ((long)(tmp == 0) != 0L) {
      
#line 1110 
      printk("\001",(char *)"/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c",1110);
      
#line 1110 
      dump_stack();
    }
    else ;
  }
  else ;
  
#line 1112 
  ldv_mutex_lock_98(& efx->mac_lock);
  
#line 1113 
  efx->port_enabled = (_Bool)0;
  
#line 1114 
  ldv_mutex_unlock_99(& efx->mac_lock);
  
#line 1117 
  netif_addr_lock_bh_1(efx->net_dev);
  
#line 1118 
  netif_addr_unlock_bh_1(efx->net_dev);
  
#line 1120 
  cancel_delayed_work_sync(& efx->monitor_work);
  
#line 1121 
  efx_selftest_async_cancel(efx);
  
#line 1122 
  cancel_work_sync(& efx->mac_work);
  
#line 1123 
  return;
}


#line 1125  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_fini_port(struct efx_nic *efx)
{
  
#line 1127 
  if ((efx->msg_enable & 1U) != 0U) {
    
#line 1127 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_fini_port", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "shut down port\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1127U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1127 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1127 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"shut down port\n"); else ;
  }
  else ;
  
#line 1129 
  if (! efx->port_initialized) 
#line 1130 
                               goto return_label; else ;
  
#line 1132 
  (*((efx->phy_op)->fini))(efx);
  
#line 1133 
  efx->port_initialized = (_Bool)0;
  
#line 1135 
  efx->link_state.up = (_Bool)0;
  
#line 1136 
  efx_link_status_changed(efx);
  return_label: 
#line 1137 
                return;
}


#line 1139  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_remove_port(struct efx_nic *efx)
{
  
#line 1141 
  if ((efx->msg_enable & 1U) != 0U) {
    
#line 1141 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_remove_port", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "destroying port\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1141U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1141 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1141 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"destroying port\n"); else ;
  }
  else ;
  
#line 1143 
  (*((efx->type)->remove_port))(efx);
  
#line 1144 
  return;
}


#line 1152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static struct list_head efx_primary_list = {.next = & efx_primary_list, .prev = & efx_primary_list};

#line 1153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static struct list_head efx_unassociated_list = {.next = & efx_unassociated_list, .prev = & efx_unassociated_list};

#line 1155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static bool efx_same_controller(struct efx_nic *left, struct efx_nic *right)
{
  bool __retres;
  int tmp_0;
  
#line 1158 
  if ((left->type == right->type && left->vpd_sn != (char *)0) && right->vpd_sn != (char *)0) {
    int tmp;
    
#line 1158 
    tmp = strcmp((char const *)left->vpd_sn,(char const *)right->vpd_sn);
    
#line 1158 
    if (tmp == 0) 
#line 1158 
                  tmp_0 = 1; else 
#line 1158 
                                  tmp_0 = 0;
  }
  else 
#line 1158 
       tmp_0 = 0;
  
#line 1158 
  __retres = (_Bool)(tmp_0 != 0);
  
#line 1158 
  return __retres;
}


#line 1162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_associate(struct efx_nic *efx)
{
  struct efx_nic *other;
  struct efx_nic *next;
  
#line 1166 
  if (efx->primary == efx) {
    struct efx_nic *tmp;
    struct efx_nic *tmp_0;
    bool tmp_2;
    struct efx_nic *tmp_3;
    
#line 1169 
    if ((efx->msg_enable & 2U) != 0U) {
      
#line 1169 
      struct _ddebug descriptor = {.modname = "sfc", .function = "efx_associate", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "adding to primary list\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1169U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1169 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1169 
                                                          __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"adding to primary list\n"); else ;
    }
    else ;
    
#line 1170 
    list_add_tail(& efx->node,& efx_primary_list);
    {
      
#line 1172 
      struct list_head const *__mptr = (struct list_head const *)efx_unassociated_list.next;
      
#line 1172 
      tmp = (struct efx_nic *)__mptr + 18446744073709551600U;
    }
    
#line 1172 
    other = tmp;
    {
      
#line 1172 
      struct list_head const *__mptr_0 = (struct list_head const *)other->node.next;
      
#line 1172 
      tmp_0 = (struct efx_nic *)__mptr_0 + 18446744073709551600U;
    }
    
#line 1173 
    next = tmp_0;
    
#line 1172 
    goto ldv_57282;
    ldv_57281: 
#line 1173 
    ;
    
#line 1174 
    tmp_2 = efx_same_controller(efx,other);
    
#line 1174 
    if ((int)tmp_2 != 0) {
      
#line 1175 
      list_del(& other->node);
      
#line 1176 
      if ((other->msg_enable & 2U) != 0U) {
        
#line 1176 
        struct _ddebug descriptor_0 = {.modname = "sfc", .function = "efx_associate", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "moving to secondary list of %s %s\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1179U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 1176 
        if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) {
          char const *tmp_1;
          
#line 1176 
          ;
          
#line 1176 
          tmp_1 = pci_name((struct pci_dev const *)efx->pci_dev);
          
#line 1176 
          ;
          
#line 1176 
          __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)other->net_dev,"moving to secondary list of %s %s\n",tmp_1,(char *)(& (efx->net_dev)->name));
        }
        else ;
      }
      else ;
      
#line 1180 
      list_add_tail(& other->node,& efx->secondary_list);
      
#line 1182 
      other->primary = efx;
    }
    else ;
    
#line 1172 
    other = next;
    {
      
#line 1172 
      struct list_head const *__mptr_1 = (struct list_head const *)next->node.next;
      
#line 1172 
      tmp_3 = (struct efx_nic *)__mptr_1 + 18446744073709551600U;
    }
    
#line 1172 
    next = tmp_3;
    ldv_57282: 
#line 1174 
    ;
    
#line 1172 
    if (& other->node != & efx_unassociated_list) 
#line 1174 
                                                  goto ldv_57281; else 
                                                                    
#line 1177 
                                                                    goto ldv_57283;
    ldv_57283: 
#line 1178 
    ;
  }
  else {
    struct efx_nic *tmp_4;
    bool tmp_6;
    struct efx_nic *tmp_7;
    {
      
#line 1188 
      struct list_head const *__mptr_2 = (struct list_head const *)efx_primary_list.next;
      
#line 1188 
      tmp_4 = (struct efx_nic *)__mptr_2 + 18446744073709551600U;
    }
    
#line 1188 
    other = tmp_4;
    
#line 1188 
    goto ldv_57290;
    ldv_57289: 
#line 1189 
    ;
    
#line 1189 
    tmp_6 = efx_same_controller(efx,other);
    
#line 1189 
    if ((int)tmp_6 != 0) {
      
#line 1190 
      if ((efx->msg_enable & 2U) != 0U) {
        
#line 1190 
        struct _ddebug descriptor_1 = {.modname = "sfc", .function = "efx_associate", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "adding to secondary list of %s %s\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1193U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 1190 
        if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) {
          char const *tmp_5;
          
#line 1190 
          ;
          
#line 1190 
          tmp_5 = pci_name((struct pci_dev const *)other->pci_dev);
          
#line 1190 
          ;
          
#line 1190 
          __dynamic_netdev_dbg(& descriptor_1,(struct net_device const *)efx->net_dev,"adding to secondary list of %s %s\n",tmp_5,(char *)(& (other->net_dev)->name));
        }
        else ;
      }
      else ;
      
#line 1194 
      list_add_tail(& efx->node,& other->secondary_list);
      
#line 1196 
      efx->primary = other;
      
#line 1197 
      goto return_label;
    }
    else ;
    {
      
#line 1188 
      struct list_head const *__mptr_3 = (struct list_head const *)other->node.next;
      
#line 1188 
      tmp_7 = (struct efx_nic *)__mptr_3 + 18446744073709551600U;
    }
    
#line 1188 
    other = tmp_7;
    ldv_57290: 
#line 1190 
    ;
    
#line 1188 
    if (& other->node != & efx_primary_list) 
#line 1190 
                                             goto ldv_57289; else 
#line 1193 
                                                                  goto ldv_57291;
    ldv_57291: 
#line 1194 
    ;
    
#line 1201 
    if ((efx->msg_enable & 2U) != 0U) {
      
#line 1201 
      struct _ddebug descriptor_2 = {.modname = "sfc", .function = "efx_associate", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "adding to unassociated list\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1202U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1201 
      if ((long)(((int)descriptor_2.flags & 1) != 0) != 0L) 
#line 1201 
                                                            __dynamic_netdev_dbg(& descriptor_2,(struct net_device const *)efx->net_dev,"adding to unassociated list\n"); else ;
    }
    else ;
    
#line 1203 
    list_add_tail(& efx->node,& efx_unassociated_list);
  }
  return_label: 
#line 1205 
                return;
}


#line 1207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_dissociate(struct efx_nic *efx)
{
  struct efx_nic *other;
  struct efx_nic *next;
  struct efx_nic *tmp;
  struct efx_nic *tmp_0;
  struct efx_nic *tmp_1;
  
#line 1211 
  list_del(& efx->node);
  
#line 1212 
  efx->primary = (struct efx_nic *)0;
  {
    
#line 1214 
    struct list_head const *__mptr = (struct list_head const *)efx->secondary_list.next;
    
#line 1214 
    tmp = (struct efx_nic *)__mptr + 18446744073709551600U;
  }
  
#line 1214 
  other = tmp;
  {
    
#line 1214 
    struct list_head const *__mptr_0 = (struct list_head const *)other->node.next;
    
#line 1214 
    tmp_0 = (struct efx_nic *)__mptr_0 + 18446744073709551600U;
  }
  
#line 1215 
  next = tmp_0;
  
#line 1214 
  goto ldv_57307;
  ldv_57306: 
#line 1215 
  ;
  
#line 1215 
  list_del(& other->node);
  
#line 1216 
  if ((other->msg_enable & 2U) != 0U) {
    
#line 1216 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_dissociate", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "moving to unassociated list\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1217U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1216 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1216 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)other->net_dev,"moving to unassociated list\n"); else ;
  }
  else ;
  
#line 1218 
  list_add_tail(& other->node,& efx_unassociated_list);
  
#line 1219 
  other->primary = (struct efx_nic *)0;
  
#line 1214 
  other = next;
  {
    
#line 1214 
    struct list_head const *__mptr_1 = (struct list_head const *)next->node.next;
    
#line 1214 
    tmp_1 = (struct efx_nic *)__mptr_1 + 18446744073709551600U;
  }
  
#line 1214 
  next = tmp_1;
  ldv_57307: 
#line 1216 
  ;
  
#line 1214 
  if (& other->node != & efx->secondary_list) 
#line 1216 
                                              goto ldv_57306; else 
#line 1219 
                                                                   goto ldv_57308;
  ldv_57308: 
#line 1220 
  ;
  
#line 1221 
  return;
}


#line 1224  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_init_io(struct efx_nic *efx)
{
  int __retres;
  unsigned int tmp;
  int rc;
  int bar;
  int tmp_0;
  
#line 1226 
  struct pci_dev *pci_dev = efx->pci_dev;
  
#line 1227 
  dma_addr_t dma_mask = (efx->type)->max_dma_mask;
  
#line 1228 
  tmp = (*((efx->type)->mem_map_size))(efx);
  
#line 1228 
  unsigned int mem_map_size = tmp;
  
#line 1231 
  if ((efx->msg_enable & 2U) != 0U) {
    
#line 1231 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_init_io", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "initialising I/O\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1231U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1231 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1231 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"initialising I/O\n"); else ;
  }
  else ;
  
#line 1233 
  bar = (int)(efx->type)->mem_bar;
  
#line 1235 
  rc = pci_enable_device(pci_dev);
  
#line 1236 
  if (rc != 0) {
    
#line 1237 
    if ((efx->msg_enable & 2U) != 0U) 
#line 1237 
                                      netdev_err((struct net_device const *)efx->net_dev,"failed to enable PCI device\n"); else ;
    
#line 1239 
    goto fail1;
  }
  else ;
  
#line 1242 
  pci_set_master(pci_dev);
  
#line 1249 
  goto ldv_57322;
  ldv_57321: 
#line 1250 
  ;
  
#line 1250 
  tmp_0 = dma_supported(& pci_dev->dev,dma_mask);
  
#line 1250 
  if (tmp_0 != 0) {
    
#line 1251 
    rc = dma_set_mask_and_coherent(& pci_dev->dev,dma_mask);
    
#line 1252 
    if (rc == 0) 
#line 1253 
                 goto ldv_57320; else ;
  }
  else ;
  
#line 1255 
  dma_mask >>= 1;
  ldv_57322: 
#line 1256 
  ;
  
#line 1249 
  if (dma_mask > 2147483647ULL) 
#line 1251 
                                goto ldv_57321; else 
#line 1254 
                                                     goto ldv_57320;
  ldv_57320: 
#line 1255 
  ;
  
#line 1257 
  if (rc != 0) {
    
#line 1258 
    if ((efx->msg_enable & 2U) != 0U) 
#line 1258 
                                      netdev_err((struct net_device const *)efx->net_dev,"could not find a suitable DMA mask\n"); else ;
    
#line 1260 
    goto fail2;
  }
  else ;
  
#line 1262 
  if ((efx->msg_enable & 2U) != 0U) {
    
#line 1262 
    struct _ddebug descriptor_0 = {.modname = "sfc", .function = "efx_init_io", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "using DMA mask %llx\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1263U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1262 
    if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 1262 
                                                          __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)efx->net_dev,"using DMA mask %llx\n",dma_mask); else ;
  }
  else ;
  
#line 1265 
  efx->membase_phys = (efx->pci_dev)->resource[bar].start;
  
#line 1266 
  rc = pci_request_region(pci_dev,bar,"sfc");
  
#line 1267 
  if (rc != 0) {
    
#line 1268 
    if ((efx->msg_enable & 2U) != 0U) 
#line 1268 
                                      netdev_err((struct net_device const *)efx->net_dev,"request for memory BAR failed\n"); else ;
    
#line 1270 
    rc = -5;
    
#line 1271 
    goto fail3;
  }
  else ;
  
#line 1273 
  efx->membase = ioremap_nocache(efx->membase_phys,(unsigned long)mem_map_size);
  
#line 1274 
  if (efx->membase == (void *)0) {
    
#line 1275 
    if ((efx->msg_enable & 2U) != 0U) 
#line 1275 
                                      netdev_err((struct net_device const *)efx->net_dev,"could not map memory BAR at %llx+%x\n",efx->membase_phys,mem_map_size); else ;
    
#line 1278 
    rc = -12;
    
#line 1279 
    goto fail4;
  }
  else ;
  
#line 1281 
  if ((efx->msg_enable & 2U) != 0U) {
    
#line 1281 
    struct _ddebug descriptor_1 = {.modname = "sfc", .function = "efx_init_io", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "memory BAR at %llx+%x (virtual %p)\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1284U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1281 
    if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) 
#line 1281 
                                                          __dynamic_netdev_dbg(& descriptor_1,(struct net_device const *)efx->net_dev,"memory BAR at %llx+%x (virtual %p)\n",efx->membase_phys,mem_map_size,efx->membase); else ;
  }
  else ;
  
#line 1286 
  __retres = 0;
  
#line 1286 
  goto return_label;
  fail4: 
#line 1288 
  ;
  
#line 1289 
  pci_release_region(efx->pci_dev,bar);
  fail3: 
#line 1290 
  ;
  
#line 1291 
  efx->membase_phys = 0ULL;
  fail2: 
#line 1292 
  ;
  
#line 1293 
  pci_disable_device(efx->pci_dev);
  fail1: 
#line 1294 
  ;
  
#line 1295 
  __retres = rc;
  return_label: 
#line 1295 
                return __retres;
}


#line 1298  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_fini_io(struct efx_nic *efx)
{
  int bar;
  int tmp;
  
#line 1302 
  if ((efx->msg_enable & 1U) != 0U) {
    
#line 1302 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_fini_io", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "shutting down I/O\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1302U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1302 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1302 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"shutting down I/O\n"); else ;
  }
  else ;
  
#line 1304 
  if (efx->membase != (void *)0) {
    
#line 1305 
    iounmap((void volatile *)efx->membase);
    
#line 1306 
    efx->membase = (void *)0;
  }
  else ;
  
#line 1309 
  if (efx->membase_phys != 0ULL) {
    
#line 1310 
    bar = (int)(efx->type)->mem_bar;
    
#line 1311 
    pci_release_region(efx->pci_dev,bar);
    
#line 1312 
    efx->membase_phys = 0ULL;
  }
  else ;
  
#line 1316 
  tmp = pci_vfs_assigned(efx->pci_dev);
  
#line 1316 
  if (tmp == 0) 
#line 1317 
                pci_disable_device(efx->pci_dev); else ;
  
#line 1318 
  return;
}


#line 1320  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
void efx_set_default_rx_indir_table(struct efx_nic *efx)
{
  size_t i;
  
#line 1324 
  i = 0UL;
  
#line 1324 
  goto ldv_57342;
  ldv_57341: 
#line 1325 
  ;
  
#line 1325 
  efx->rx_indir_table[i] = ethtool_rxfh_indir_default((unsigned int)i,efx->rss_spread);
  
#line 1324 
  i += 1UL;
  ldv_57342: 
#line 1325 
  ;
  
#line 1324 
  if (i <= 127UL) 
#line 1326 
                  goto ldv_57341; else 
#line 1329 
                                       goto ldv_57343;
  ldv_57343: 
#line 1330 
  ;
  
#line 1331 
  return;
}


#line 1329  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static unsigned int efx_wanted_parallelism(struct efx_nic *efx)
{
  unsigned int __retres;
  cpumask_var_t thread_mask;
  unsigned int count;
  int cpu;
  
#line 1335 
  if (rss_cpus != 0U) 
#line 1336 
                      count = rss_cpus;
  else {
    int tmp_0;
    bool tmp;
    int tmp_3;
    unsigned int tmp_4;
    
#line 1338 
    tmp = zalloc_cpumask_var((cpumask_var_t **)(& thread_mask),208U);
    
#line 1338 
    if (tmp) 
#line 1338 
             tmp_0 = 0; else 
#line 1338 
                             tmp_0 = 1;
    
#line 1338 
    if ((long)tmp_0 != 0L) {
      
#line 1339 
      if ((efx->msg_enable & 2U) != 0U) 
#line 1339 
                                        netdev_warn((struct net_device const *)efx->net_dev,"RSS disabled due to allocation failure\n"); else ;
      
#line 1341 
      __retres = 1U;
      
#line 1341 
      goto return_label;
    }
    else ;
    
#line 1344 
    count = 0U;
    
#line 1345 
    cpu = -1;
    
#line 1345 
    goto ldv_57355;
    ldv_57354: 
#line 1346 
    ;
    
#line 1346 
    tmp_3 = cpumask_test_cpu(cpu,(struct cpumask const *)thread_mask);
    
#line 1346 
    if (tmp_3 == 0) {
      cpumask_var_t **tmp_2_0;
      
#line 1347 
      count += 1U;
      {
        cpumask_var_t **tmp_1;
        {
          
#line 1349 
          void const *__vpp_verify = (void const *)0;
          
#line 1349 
          void const *tmp_2 = __vpp_verify;
        }
        {
          unsigned long __ptr;
          
#line 1350 
          ldv_inline_asm();
          
#line 1349 
          tmp_1 = (cpumask_var_t **)(__per_cpu_offset[cpu] + __ptr);
        }
        
#line 1349 
        tmp_2_0 = tmp_1;
      }
      
#line 1348 
      ;
      
#line 1348 
      ;
      
#line 1348 
      cpumask_or(thread_mask,(struct cpumask const *)thread_mask,(struct cpumask const *)*tmp_2_0);
    }
    else ;
    ldv_57355: 
#line 1353 
    ;
    
#line 1345 
    tmp_4 = cpumask_next(cpu,cpu_online_mask);
    
#line 1345 
    cpu = (int)tmp_4;
    
#line 1345 
    if (cpu < nr_cpu_ids) 
#line 1347 
                          goto ldv_57354; else 
#line 1350 
                                               goto ldv_57356;
    ldv_57356: 
#line 1351 
    ;
    
#line 1353 
    free_cpumask_var(thread_mask);
  }
  
#line 1360 
  if ((efx->type)->sriov_wanted != (bool (*)(struct efx_nic *))0) {
    bool tmp_6;
    
#line 1361 
    tmp_6 = (*((efx->type)->sriov_wanted))(efx);
    
#line 1361 
    if ((int)tmp_6 != 0) {
      unsigned int tmp_7;
      
#line 1361 
      tmp_7 = efx_vf_size(efx);
      
#line 1361 
      if (tmp_7 > 1U) {
        unsigned int tmp_8;
        
#line 1361 
        tmp_8 = efx_vf_size(efx);
        
#line 1361 
        ;
        
#line 1361 
        if (tmp_8 < count) {
          
#line 1363 
          if ((efx->msg_enable & 2U) != 0U) {
            unsigned int tmp_5;
            
#line 1363 
            tmp_5 = efx_vf_size(efx);
            
#line 1363 
            ;
            
#line 1363 
            ;
            
#line 1363 
            netdev_warn((struct net_device const *)efx->net_dev,"Reducing number of RSS channels from %u to %u for ",count,tmp_5);
          }
          else ;
          
#line 1368 
          count = efx_vf_size(efx);
        }
        else ;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 1373 
  __retres = count;
  return_label: 
#line 1373 
                return __retres;
}


#line 1379  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_probe_interrupts(struct efx_nic *efx)
{
  int __retres;
  unsigned int i;
  unsigned int j;
  int rc;
  
#line 1381 
  unsigned int extra_channels = 0U;
  
#line 1385 
  i = 0U;
  
#line 1385 
  goto ldv_57365;
  ldv_57364: 
#line 1386 
  ;
  
#line 1386 
  if (efx->extra_channel_type[i] != (struct efx_channel_type const *)0) 
    
#line 1387 
    extra_channels += 1U; else ;
  
#line 1385 
  i += 1U;
  ldv_57365: 
#line 1386 
  ;
  
#line 1385 
  if (i <= 1U) 
#line 1387 
               goto ldv_57364; else 
#line 1390 
                                    goto ldv_57366;
  ldv_57366: 
#line 1391 
  ;
  
#line 1389 
  if (efx->interrupt_mode == (unsigned int)EFX_INT_MODE_MSIX) {
    struct msix_entry xentries[32U];
    unsigned int n_channels;
    unsigned int tmp_0;
    
#line 1393 
    n_channels = efx_wanted_parallelism(efx);
    
#line 1394 
    if ((int)separate_tx_channels != 0) 
#line 1395 
                                        n_channels *= 2U; else ;
    
#line 1396 
    n_channels += extra_channels;
    {
      unsigned int tmp;
      
#line 1397 
      unsigned int _min1 = n_channels;
      
#line 1397 
      unsigned int _min2 = efx->max_channels;
      
#line 1397 
      if (_min1 < _min2) 
#line 1397 
                         tmp = _min1; else 
#line 1397 
                                           tmp = _min2;
      
#line 1397 
      tmp_0 = tmp;
    }
    
#line 1397 
    n_channels = tmp_0;
    
#line 1399 
    i = 0U;
    
#line 1399 
    goto ldv_57373;
    ldv_57372: 
#line 1400 
    ;
    
#line 1400 
    xentries[i].entry = (unsigned short)i;
    
#line 1399 
    i += 1U;
    ldv_57373: 
#line 1400 
    ;
    
#line 1399 
    if (i < n_channels) 
#line 1401 
                        goto ldv_57372; else 
#line 1404 
                                             goto ldv_57374;
    ldv_57374: 
#line 1405 
    ;
    
#line 1401 
    rc = pci_enable_msix_range(efx->pci_dev,(struct msix_entry *)(& xentries),1,(int)n_channels);
    
#line 1403 
    if (rc < 0) {
      
#line 1405 
      efx->interrupt_mode = EFX_INT_MODE_MSI;
      
#line 1406 
      if ((efx->msg_enable & 1U) != 0U) 
#line 1406 
                                        netdev_err((struct net_device const *)efx->net_dev,"could not enable MSI-X\n"); else ;
    }
    else 
      
#line 1408 
      if ((unsigned int)rc < n_channels) {
        
#line 1409 
        if ((efx->msg_enable & 1U) != 0U) 
#line 1409 
                                          netdev_err((struct net_device const *)efx->net_dev,"WARNING: Insufficient MSI-X vectors",rc,n_channels); else ;
        
#line 1412 
        if ((efx->msg_enable & 1U) != 0U) 
#line 1412 
                                          netdev_err((struct net_device const *)efx->net_dev,"WARNING: Performance may be reduced.\n"); else ;
        
#line 1414 
        n_channels = (unsigned int)rc;
      }
      else ;
    
#line 1417 
    if (rc > 0) {
      struct efx_channel *tmp_5;
      
#line 1418 
      efx->n_channels = n_channels;
      
#line 1419 
      if (n_channels > extra_channels) 
#line 1420 
                                       n_channels -= extra_channels; else ;
      
#line 1421 
      if ((int)separate_tx_channels != 0) {
        unsigned int tmp_2;
        unsigned int tmp_4;
        {
          unsigned int tmp_1;
          
#line 1422 
          unsigned int _max1 = n_channels / 2U;
          
#line 1422 
          unsigned int _max2 = 1U;
          
#line 1422 
          if (_max1 > _max2) 
#line 1422 
                             tmp_1 = _max1; else 
#line 1422 
                                                 tmp_1 = _max2;
          
#line 1422 
          tmp_2 = tmp_1;
        }
        
#line 1422 
        efx->n_tx_channels = tmp_2;
        {
          unsigned int tmp_3;
          
#line 1423 
          unsigned int _max1_0 = n_channels - efx->n_tx_channels;
          
#line 1423 
          unsigned int _max2_0 = 1U;
          
#line 1423 
          if (_max1_0 > _max2_0) 
#line 1423 
                                 tmp_3 = _max1_0; else 
#line 1423 
                                                       tmp_3 = _max2_0;
          
#line 1423 
          tmp_4 = tmp_3;
        }
        
#line 1423 
        efx->n_rx_channels = tmp_4;
      }
      else {
        
#line 1427 
        efx->n_tx_channels = n_channels;
        
#line 1428 
        efx->n_rx_channels = n_channels;
      }
      
#line 1430 
      i = 0U;
      
#line 1430 
      goto ldv_57382;
      ldv_57381: 
#line 1431 
      ;
      
#line 1431 
      tmp_5 = efx_get_channel(efx,i);
      
#line 1431 
      tmp_5->irq = (int)xentries[i].vector;
      
#line 1430 
      i += 1U;
      ldv_57382: 
#line 1431 
      ;
      
#line 1430 
      if (efx->n_channels > i) 
#line 1432 
                               goto ldv_57381; else 
#line 1435 
                                                    goto ldv_57383;
      ldv_57383: 
#line 1436 
      ;
    }
    else ;
  }
  else ;
  
#line 1437 
  if (efx->interrupt_mode == (unsigned int)EFX_INT_MODE_MSI) {
    
#line 1438 
    efx->n_channels = 1U;
    
#line 1439 
    efx->n_rx_channels = 1U;
    
#line 1440 
    efx->n_tx_channels = 1U;
    
#line 1441 
    rc = pci_enable_msi_exact(efx->pci_dev,1);
    
#line 1442 
    if (rc == 0) {
      struct efx_channel *tmp_6;
      
#line 1443 
      tmp_6 = efx_get_channel(efx,0U);
      
#line 1443 
      tmp_6->irq = (int)(efx->pci_dev)->irq;
    }
    else {
      
#line 1445 
      if ((efx->msg_enable & 1U) != 0U) 
#line 1445 
                                        netdev_err((struct net_device const *)efx->net_dev,"could not enable MSI\n"); else ;
      
#line 1447 
      efx->interrupt_mode = EFX_INT_MODE_LEGACY;
    }
  }
  else ;
  
#line 1452 
  if (efx->interrupt_mode == (unsigned int)EFX_INT_MODE_LEGACY) {
    int tmp_7;
    
#line 1453 
    if ((int)separate_tx_channels != 0) 
#line 1453 
                                        tmp_7 = 2; else 
#line 1453 
                                                        tmp_7 = 1;
    
#line 1453 
    efx->n_channels = (unsigned int)tmp_7;
    
#line 1454 
    efx->n_rx_channels = 1U;
    
#line 1455 
    efx->n_tx_channels = 1U;
    
#line 1456 
    efx->legacy_irq = (int)(efx->pci_dev)->irq;
  }
  else ;
  
#line 1460 
  j = efx->n_channels;
  
#line 1461 
  i = 0U;
  
#line 1461 
  goto ldv_57386;
  ldv_57385: 
#line 1462 
  ;
  
#line 1462 
  if (efx->extra_channel_type[i] == (struct efx_channel_type const *)0) 
    
#line 1463 
    goto ldv_57384; else ;
  
#line 1464 
  if (efx->interrupt_mode != (unsigned int)EFX_INT_MODE_MSIX || efx->n_channels <= extra_channels) 
    
#line 1466 
    (*((efx->extra_channel_type[i])->handle_no_channel))(efx);
  else {
    struct efx_channel *tmp_8;
    
#line 1468 
    j -= 1U;
    
#line 1469 
    tmp_8 = efx_get_channel(efx,j);
    
#line 1469 
    tmp_8->type = efx->extra_channel_type[i];
  }
  ldv_57384: 
#line 1472 
  ;
  
#line 1461 
  i += 1U;
  ldv_57386: 
#line 1462 
  ;
  
#line 1461 
  if (i <= 1U) 
#line 1463 
               goto ldv_57385; else 
#line 1466 
                                    goto ldv_57387;
  ldv_57387: 
#line 1467 
  ;
  
#line 1476 
  if ((efx->type)->sriov_wanted != (bool (*)(struct efx_nic *))0) {
    
#line 1477 
    if (efx->n_rx_channels > 1U) 
#line 1477 
                                 efx->rss_spread = efx->n_rx_channels;
    else {
      int tmp_10;
      bool tmp_9;
      
#line 1478 
      tmp_9 = (*((efx->type)->sriov_wanted))(efx);
      
#line 1478 
      if (tmp_9) 
#line 1478 
                 tmp_10 = 0; else 
#line 1478 
                                  tmp_10 = 1;
      
#line 1478 
      if (tmp_10) 
#line 1477 
                  efx->rss_spread = efx->n_rx_channels; else 
#line 1479 
                                                             efx->rss_spread = efx_vf_size(efx);
    }
    
#line 1480 
    __retres = 0;
    
#line 1480 
    goto return_label;
  }
  else ;
  
#line 1483 
  efx->rss_spread = efx->n_rx_channels;
  
#line 1485 
  __retres = 0;
  return_label: 
#line 1485 
                return __retres;
}


#line 1488  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_soft_enable_interrupts(struct efx_nic *efx)
{
  int __retres;
  struct efx_channel *channel;
  struct efx_channel *end_channel;
  int rc;
  
#line 1493 
  if ((long)(efx->state == (unsigned int)STATE_DISABLED) != 0L) {
    
#line 1495 
    ldv_inline_asm();
    
#line 1493 
    ;
  }
  else ;
  
#line 1495 
  efx->irq_soft_enabled = (_Bool)1;
  
#line 1496 
  ldv_inline_asm();
  
#line 1498 
  channel = efx->channel[0];
  
#line 1498 
  goto ldv_57396;
  ldv_57395: 
#line 1499 
  ;
  
#line 1499 
  if (! (channel->type)->keep_eventq) {
    
#line 1500 
    rc = efx_init_eventq(channel);
    
#line 1501 
    if (rc != 0) 
#line 1502 
                 goto fail; else ;
  }
  else ;
  
#line 1504 
  efx_start_eventq(channel);
  
#line 1498 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 1498 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 1498 
                                                                    channel = (struct efx_channel *)0;
  ldv_57396: 
#line 1499 
  ;
  
#line 1498 
  if (channel != (struct efx_channel *)0) 
#line 1500 
                                          goto ldv_57395; else 
#line 1503 
                                                               goto ldv_57397;
  ldv_57397: 
#line 1504 
  ;
  
#line 1507 
  efx_mcdi_mode_event(efx);
  
#line 1509 
  __retres = 0;
  
#line 1509 
  goto return_label;
  fail: 
#line 1510 
  ;
  
#line 1511 
  end_channel = channel;
  
#line 1512 
  channel = efx->channel[0];
  
#line 1512 
  goto ldv_57400;
  ldv_57399: 
#line 1513 
  ;
  
#line 1513 
  if (channel == end_channel) 
#line 1514 
                              goto ldv_57398; else ;
  
#line 1515 
  efx_stop_eventq(channel);
  
#line 1516 
  if (! (channel->type)->keep_eventq) 
#line 1517 
                                      efx_fini_eventq(channel); else ;
  
#line 1512 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 1512 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 1512 
                                                                    channel = (struct efx_channel *)0;
  ldv_57400: 
#line 1513 
  ;
  
#line 1512 
  if (channel != (struct efx_channel *)0) 
#line 1514 
                                          goto ldv_57399; else 
#line 1517 
                                                               goto ldv_57398;
  ldv_57398: 
#line 1518 
  ;
  
#line 1520 
  __retres = rc;
  return_label: 
#line 1520 
                return __retres;
}


#line 1523  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_soft_disable_interrupts(struct efx_nic *efx)
{
  struct efx_channel *channel;
  
#line 1527 
  if (efx->state == (unsigned int)STATE_DISABLED) 
#line 1528 
                                                  goto return_label; else ;
  
#line 1530 
  efx_mcdi_mode_poll(efx);
  
#line 1532 
  efx->irq_soft_enabled = (_Bool)0;
  
#line 1533 
  ldv_inline_asm();
  
#line 1535 
  if (efx->legacy_irq != 0) 
#line 1536 
                            synchronize_irq((unsigned int)efx->legacy_irq); else ;
  
#line 1538 
  channel = efx->channel[0];
  
#line 1538 
  goto ldv_57406;
  ldv_57405: 
#line 1539 
  ;
  
#line 1539 
  if (channel->irq != 0) 
#line 1540 
                         synchronize_irq((unsigned int)channel->irq); else ;
  
#line 1542 
  efx_stop_eventq(channel);
  
#line 1543 
  if (! (channel->type)->keep_eventq) 
#line 1544 
                                      efx_fini_eventq(channel); else ;
  
#line 1538 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 1538 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 1538 
                                                                    channel = (struct efx_channel *)0;
  ldv_57406: 
#line 1539 
  ;
  
#line 1538 
  if (channel != (struct efx_channel *)0) 
#line 1540 
                                          goto ldv_57405; else 
#line 1543 
                                                               goto ldv_57407;
  ldv_57407: 
#line 1544 
  ;
  
#line 1548 
  efx_mcdi_flush_async(efx);
  return_label: 
#line 1549 
                return;
}


#line 1551  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_enable_interrupts(struct efx_nic *efx)
{
  int __retres;
  struct efx_channel *channel;
  struct efx_channel *end_channel;
  int rc;
  
#line 1556 
  if ((long)(efx->state == (unsigned int)STATE_DISABLED) != 0L) {
    
#line 1558 
    ldv_inline_asm();
    
#line 1556 
    ;
  }
  else ;
  
#line 1558 
  if ((int)efx->eeh_disabled_legacy_irq != 0) {
    
#line 1559 
    enable_irq((unsigned int)efx->legacy_irq);
    
#line 1560 
    efx->eeh_disabled_legacy_irq = (_Bool)0;
  }
  else ;
  
#line 1563 
  (*((efx->type)->irq_enable_master))(efx);
  
#line 1565 
  channel = efx->channel[0];
  
#line 1565 
  goto ldv_57416;
  ldv_57415: 
#line 1566 
  ;
  
#line 1566 
  if ((int)(channel->type)->keep_eventq != 0) {
    
#line 1567 
    rc = efx_init_eventq(channel);
    
#line 1568 
    if (rc != 0) 
#line 1569 
                 goto fail; else ;
  }
  else ;
  
#line 1565 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 1565 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 1565 
                                                                    channel = (struct efx_channel *)0;
  ldv_57416: 
#line 1566 
  ;
  
#line 1565 
  if (channel != (struct efx_channel *)0) 
#line 1567 
                                          goto ldv_57415; else 
#line 1570 
                                                               goto ldv_57417;
  ldv_57417: 
#line 1571 
  ;
  
#line 1573 
  rc = efx_soft_enable_interrupts(efx);
  
#line 1574 
  if (rc != 0) 
#line 1575 
               goto fail; else ;
  
#line 1577 
  __retres = 0;
  
#line 1577 
  goto return_label;
  fail: 
#line 1579 
  ;
  
#line 1580 
  end_channel = channel;
  
#line 1581 
  channel = efx->channel[0];
  
#line 1581 
  goto ldv_57420;
  ldv_57419: 
#line 1582 
  ;
  
#line 1582 
  if (channel == end_channel) 
#line 1583 
                              goto ldv_57418; else ;
  
#line 1584 
  if ((int)(channel->type)->keep_eventq != 0) 
#line 1585 
                                              efx_fini_eventq(channel); else ;
  
#line 1581 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 1581 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 1581 
                                                                    channel = (struct efx_channel *)0;
  ldv_57420: 
#line 1582 
  ;
  
#line 1581 
  if (channel != (struct efx_channel *)0) 
#line 1583 
                                          goto ldv_57419; else 
#line 1586 
                                                               goto ldv_57418;
  ldv_57418: 
#line 1587 
  ;
  
#line 1588 
  (*((efx->type)->irq_disable_non_ev))(efx);
  
#line 1590 
  __retres = rc;
  return_label: 
#line 1590 
                return __retres;
}


#line 1593  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_disable_interrupts(struct efx_nic *efx)
{
  struct efx_channel *channel;
  
#line 1597 
  efx_soft_disable_interrupts(efx);
  
#line 1599 
  channel = efx->channel[0];
  
#line 1599 
  goto ldv_57426;
  ldv_57425: 
#line 1600 
  ;
  
#line 1600 
  if ((int)(channel->type)->keep_eventq != 0) 
#line 1601 
                                              efx_fini_eventq(channel); else ;
  
#line 1599 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 1599 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 1599 
                                                                    channel = (struct efx_channel *)0;
  ldv_57426: 
#line 1600 
  ;
  
#line 1599 
  if (channel != (struct efx_channel *)0) 
#line 1601 
                                          goto ldv_57425; else 
#line 1604 
                                                               goto ldv_57427;
  ldv_57427: 
#line 1605 
  ;
  
#line 1604 
  (*((efx->type)->irq_disable_non_ev))(efx);
  
#line 1605 
  return;
}


#line 1607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_remove_interrupts(struct efx_nic *efx)
{
  struct efx_channel *channel;
  
#line 1612 
  channel = efx->channel[0];
  
#line 1612 
  goto ldv_57433;
  ldv_57432: 
#line 1613 
  ;
  
#line 1613 
  channel->irq = 0;
  
#line 1612 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 1612 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 1612 
                                                                    channel = (struct efx_channel *)0;
  ldv_57433: 
#line 1613 
  ;
  
#line 1612 
  if (channel != (struct efx_channel *)0) 
#line 1614 
                                          goto ldv_57432; else 
#line 1617 
                                                               goto ldv_57434;
  ldv_57434: 
#line 1618 
  ;
  
#line 1614 
  pci_disable_msi(efx->pci_dev);
  
#line 1615 
  pci_disable_msix(efx->pci_dev);
  
#line 1618 
  efx->legacy_irq = 0;
  
#line 1619 
  return;
}


#line 1621  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_set_channels(struct efx_nic *efx)
{
  struct efx_channel *channel;
  struct efx_tx_queue *tx_queue;
  int tmp_1;
  bool tmp_0;
  
#line 1626 
  if ((int)separate_tx_channels != 0) 
#line 1626 
                                      efx->tx_channel_offset = efx->n_channels - efx->n_tx_channels; else 
                                                                    
#line 1626 
                                                                    efx->tx_channel_offset = 0U;
  
#line 1633 
  channel = efx->channel[0];
  
#line 1633 
  goto ldv_57444;
  ldv_57443: 
#line 1634 
  ;
  
#line 1634 
  if ((unsigned int)channel->channel < efx->n_rx_channels) 
#line 1635 
                                                           channel->rx_queue.core_index = channel->channel; else 
                                                                    
#line 1637 
                                                                    channel->rx_queue.core_index = -1;
  
#line 1639 
  tmp_0 = efx_channel_has_tx_queues(channel);
  
#line 1639 
  if (tmp_0) 
#line 1639 
             tmp_1 = 0; else 
#line 1639 
                             tmp_1 = 1;
  
#line 1639 
  if (tmp_1) ;
  else {
    
#line 1639 
    tx_queue = (struct efx_tx_queue *)(& channel->tx_queue);
    
#line 1639 
    goto ldv_57441;
    ldv_57440: 
#line 1640 
    ;
    
#line 1640 
    tx_queue->queue -= efx->tx_channel_offset * 4U;
    
#line 1639 
    tx_queue += 1;
    ldv_57441: 
#line 1640 
    ;
    
#line 1639 
    if ((struct efx_tx_queue *)(& channel->tx_queue) + 4U > tx_queue) {
      bool tmp;
      
#line 1639 
      tmp = efx_tx_queue_used(tx_queue);
      
#line 1639 
      if ((int)tmp != 0) 
#line 1641 
                         goto ldv_57440; else 
#line 1644 
                                              goto ldv_57442;
    }
    else 
#line 1644 
         goto ldv_57442;
    ldv_57442: 
#line 1645 
    ;
  }
  
#line 1633 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 1633 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 1633 
                                                                    channel = (struct efx_channel *)0;
  ldv_57444: 
#line 1634 
  ;
  
#line 1633 
  if (channel != (struct efx_channel *)0) 
#line 1635 
                                          goto ldv_57443; else 
#line 1638 
                                                               goto ldv_57445;
  ldv_57445: 
#line 1639 
  ;
  
#line 1640 
  return;
}


#line 1645  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_probe_nic(struct efx_nic *efx)
{
  int __retres;
  int rc;
  
#line 1649 
  if ((efx->msg_enable & 2U) != 0U) {
    
#line 1649 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_probe_nic", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "creating NIC\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1649U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1649 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1649 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"creating NIC\n"); else ;
  }
  else ;
  
#line 1652 
  rc = (*((efx->type)->probe))(efx);
  
#line 1653 
  if (rc != 0) {
    
#line 1654 
    __retres = rc;
    
#line 1654 
    goto return_label;
  }
  else ;
  
#line 1658 
  rc = efx_probe_interrupts(efx);
  
#line 1659 
  if (rc != 0) 
#line 1660 
               goto fail1; else ;
  
#line 1662 
  efx_set_channels(efx);
  
#line 1664 
  rc = (*((efx->type)->dimension_resources))(efx);
  
#line 1665 
  if (rc != 0) 
#line 1666 
               goto fail2; else ;
  
#line 1668 
  if (efx->n_channels > 1U) 
#line 1669 
                            netdev_rss_key_fill((void *)(& efx->rx_hash_key),40UL); else ;
  
#line 1671 
  efx_set_default_rx_indir_table(efx);
  
#line 1673 
  netif_set_real_num_tx_queues(efx->net_dev,efx->n_tx_channels);
  
#line 1674 
  netif_set_real_num_rx_queues(efx->net_dev,efx->n_rx_channels);
  
#line 1677 
  efx_init_irq_moderation(efx,tx_irq_mod_usec,rx_irq_mod_usec,(_Bool)1,(_Bool)1);
  
#line 1680 
  __retres = 0;
  
#line 1680 
  goto return_label;
  fail2: 
#line 1682 
  ;
  
#line 1683 
  efx_remove_interrupts(efx);
  fail1: 
#line 1684 
  ;
  
#line 1685 
  (*((efx->type)->remove))(efx);
  
#line 1686 
  __retres = rc;
  return_label: 
#line 1686 
                return __retres;
}


#line 1689  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_remove_nic(struct efx_nic *efx)
{
  
#line 1691 
  if ((efx->msg_enable & 1U) != 0U) {
    
#line 1691 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_remove_nic", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "destroying NIC\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1691U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1691 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1691 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"destroying NIC\n"); else ;
  }
  else ;
  
#line 1693 
  efx_remove_interrupts(efx);
  
#line 1694 
  (*((efx->type)->remove))(efx);
  
#line 1695 
  return;
}


#line 1697  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_probe_filters(struct efx_nic *efx)
{
  int rc;
  
#line 1701 
  spinlock_check(& efx->filter_lock);
  {
    struct lock_class_key __key;
    
#line 1701 
    __raw_spin_lock_init(& efx->filter_lock.__anonCompField_spinlock_18.rlock,"&(&efx->filter_lock)->rlock",& __key);
  }
  {
    struct lock_class_key __key_0;
    
#line 1702 
    __init_rwsem(& efx->filter_sem,"&efx->filter_sem",& __key_0);
  }
  
#line 1703 
  down_write(& efx->filter_sem);
  
#line 1704 
  rc = (*((efx->type)->filter_table_probe))(efx);
  
#line 1705 
  if (rc != 0) 
#line 1706 
               goto out_unlock; else ;
  
#line 1709 
  if (((efx->type)->offload_features & 4294967296ULL) != 0ULL) {
    
#line 1710 
    efx->rps_flow_id = (u32 *)kcalloc_9((unsigned long)(efx->type)->max_rx_ip_filters,4UL,208U);
    
#line 1713 
    if (efx->rps_flow_id == (u32 *)0U) {
      
#line 1714 
      (*((efx->type)->filter_table_remove))(efx);
      
#line 1715 
      rc = -12;
      
#line 1716 
      goto out_unlock;
    }
    else ;
  }
  else ;
  out_unlock: 
#line 1720 
  ;
  
#line 1721 
  up_write(& efx->filter_sem);
  
#line 1722 
  return rc;
}


#line 1725  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_remove_filters(struct efx_nic *efx)
{
  
#line 1728 
  kfree((void const *)efx->rps_flow_id);
  
#line 1730 
  down_write(& efx->filter_sem);
  
#line 1731 
  (*((efx->type)->filter_table_remove))(efx);
  
#line 1732 
  up_write(& efx->filter_sem);
  
#line 1733 
  return;
}


#line 1735  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_restore_filters(struct efx_nic *efx)
{
  
#line 1737 
  down_read(& efx->filter_sem);
  
#line 1738 
  (*((efx->type)->filter_table_restore))(efx);
  
#line 1739 
  up_read(& efx->filter_sem);
  
#line 1740 
  return;
}


#line 1764 
void __compiletime_assert_1764(void);


#line 1748  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_probe_all(struct efx_nic *efx)
{
  int __retres;
  int rc;
  int tmp_0;
  unsigned int tmp_1;
  
#line 1752 
  rc = efx_probe_nic(efx);
  
#line 1753 
  if (rc != 0) {
    
#line 1754 
    if ((efx->msg_enable & 2U) != 0U) 
#line 1754 
                                      netdev_err((struct net_device const *)efx->net_dev,"failed to create NIC\n"); else ;
    
#line 1755 
    goto fail1;
  }
  else ;
  
#line 1758 
  rc = efx_probe_port(efx);
  
#line 1759 
  if (rc != 0) {
    
#line 1760 
    if ((efx->msg_enable & 2U) != 0U) 
#line 1760 
                                      netdev_err((struct net_device const *)efx->net_dev,"failed to create port\n"); else ;
    
#line 1761 
    goto fail2;
  }
  else ;
  {
    
#line 1764 
    bool __cond = (_Bool)0;
    
#line 1764 
    if ((int)__cond != 0) 
#line 1764 
                          __compiletime_assert_1764(); else ;
  }
  {
    unsigned int tmp;
    
#line 1765 
    tmp = efx_tx_max_skb_descs(efx);
    
#line 1765 
    int __ret_warn_on = tmp * 2U > 1024U;
    
#line 1765 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 1765 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c",1765); else ;
    
#line 1765 
    tmp_0 = (long)(__ret_warn_on != 0);
  }
  
#line 1765 
  if ((long)tmp_0 != 0L) {
    
#line 1766 
    rc = -22;
    
#line 1767 
    goto fail3;
  }
  else ;
  
#line 1769 
  tmp_1 = 1024U;
  
#line 1769 
  efx->txq_entries = tmp_1;
  
#line 1769 
  efx->rxq_entries = tmp_1;
  
#line 1772 
  rc = (*((efx->type)->vswitching_probe))(efx);
  
#line 1773 
  if (rc != 0) {
    
#line 1774 
    if ((efx->msg_enable & 2U) != 0U) 
#line 1774 
                                      netdev_warn((struct net_device const *)efx->net_dev,"failed to setup vswitching rc=%d;",rc); else ;
  }
  else ;
  
#line 1779 
  rc = efx_probe_filters(efx);
  
#line 1780 
  if (rc != 0) {
    
#line 1781 
    if ((efx->msg_enable & 2U) != 0U) 
#line 1781 
                                      netdev_err((struct net_device const *)efx->net_dev,"failed to create filter tables\n"); else ;
    
#line 1783 
    goto fail4;
  }
  else ;
  
#line 1786 
  rc = efx_probe_channels(efx);
  
#line 1787 
  if (rc != 0) 
#line 1788 
               goto fail5; else ;
  
#line 1790 
  __retres = 0;
  
#line 1790 
  goto return_label;
  fail5: 
#line 1792 
  ;
  
#line 1793 
  efx_remove_filters(efx);
  fail4: 
#line 1794 
  ;
  
#line 1796 
  (*((efx->type)->vswitching_remove))(efx);
  fail3: 
#line 1798 
  ;
  
#line 1799 
  efx_remove_port(efx);
  fail2: 
#line 1800 
  ;
  
#line 1801 
  efx_remove_nic(efx);
  fail1: 
#line 1802 
  ;
  
#line 1803 
  __retres = rc;
  return_label: 
#line 1803 
                return __retres;
}


#line 1813  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_start_all(struct efx_nic *efx)
{
  int tmp_3;
  
#line 1815 
  if ((efx->state == (unsigned int)STATE_READY || efx->state == (unsigned int)STATE_RECOVERY) || efx->state == (unsigned int)STATE_DISABLED) {
    int tmp;
    
#line 1815 
    tmp = rtnl_is_locked();
    
#line 1815 
    if ((long)(tmp == 0) != 0L) {
      
#line 1815 
      printk("\001",(char *)"/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c",1815);
      
#line 1815 
      dump_stack();
    }
    else ;
  }
  else ;
  
#line 1816 
  if ((long)(efx->state == (unsigned int)STATE_DISABLED) != 0L) {
    
#line 1818 
    ldv_inline_asm();
    
#line 1816 
    ;
  }
  else ;
  
#line 1820 
  if ((int)efx->port_enabled != 0) 
#line 1822 
                                   goto return_label;
  else {
    int tmp_1;
    bool tmp_0;
    
#line 1820 
    tmp_0 = netif_running((struct net_device const *)efx->net_dev);
    
#line 1820 
    if (tmp_0) 
#line 1820 
               tmp_1 = 0; else 
#line 1820 
                               tmp_1 = 1;
    
#line 1820 
    if (tmp_1) 
#line 1822 
               goto return_label;
    else 
      
#line 1820 
      if (efx->reset_pending != 0UL) 
#line 1822 
                                     goto return_label; else ;
  }
  
#line 1824 
  efx_start_port(efx);
  
#line 1825 
  efx_start_datapath(efx);
  
#line 1828 
  if ((efx->type)->monitor != (void (*)(struct efx_nic *))0) 
#line 1829 
                                                             ldv_queue_delayed_work_100(efx->workqueue,& efx->monitor_work,(unsigned long)efx_monitor_interval); else ;
  
#line 1835 
  tmp_3 = efx_nic_rev(efx);
  
#line 1835 
  if (tmp_3 > 2) {
    bool tmp_2;
    
#line 1836 
    ldv_mutex_lock_101(& efx->mac_lock);
    
#line 1837 
    tmp_2 = (*((efx->phy_op)->poll))(efx);
    
#line 1837 
    if ((int)tmp_2 != 0) 
#line 1838 
                         efx_link_status_changed(efx); else ;
    
#line 1839 
    ldv_mutex_unlock_102_0(& efx->mac_lock);
  }
  else ;
  
#line 1842 
  (*((efx->type)->start_stats))(efx);
  
#line 1843 
  (*((efx->type)->pull_stats))(efx);
  
#line 1844 
  ldv_spin_lock_bh_103_1(& efx->stats_lock);
  
#line 1845 
  (*((efx->type)->update_stats))(efx,(u64 *)0ULL,(struct rtnl_link_stats64 *)0);
  
#line 1846 
  ldv_spin_unlock_bh_104_0(& efx->stats_lock);
  return_label: 
#line 1847 
                return;
}


#line 1854  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_stop_all(struct efx_nic *efx)
{
  
#line 1856 
  if ((efx->state == (unsigned int)STATE_READY || efx->state == (unsigned int)STATE_RECOVERY) || efx->state == (unsigned int)STATE_DISABLED) {
    int tmp;
    
#line 1856 
    tmp = rtnl_is_locked();
    
#line 1856 
    if ((long)(tmp == 0) != 0L) {
      
#line 1856 
      printk("\001",(char *)"/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c",1856);
      
#line 1856 
      dump_stack();
    }
    else ;
  }
  else ;
  
#line 1859 
  if (! efx->port_enabled) 
#line 1860 
                           goto return_label; else ;
  
#line 1865 
  (*((efx->type)->pull_stats))(efx);
  
#line 1866 
  ldv_spin_lock_bh_105_0(& efx->stats_lock);
  
#line 1867 
  (*((efx->type)->update_stats))(efx,(u64 *)0ULL,(struct rtnl_link_stats64 *)0);
  
#line 1868 
  ldv_spin_unlock_bh_106(& efx->stats_lock);
  
#line 1869 
  (*((efx->type)->stop_stats))(efx);
  
#line 1870 
  efx_stop_port(efx);
  {
    int tmp_2;
    bool tmp_0;
    
#line 1876 
    tmp_0 = netif_running((struct net_device const *)efx->net_dev);
    
#line 1876 
    if ((int)tmp_0 != 0) {
      bool tmp_1;
      
#line 1876 
      tmp_1 = netif_device_present(efx->net_dev);
      
#line 1876 
      if ((int)tmp_1 != 0) 
#line 1876 
                           tmp_2 = 1; else 
#line 1876 
                                           tmp_2 = 0;
    }
    else 
#line 1876 
         tmp_2 = 0;
    
#line 1876 
    int __ret_warn_on = tmp_2;
    
#line 1876 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 1876 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c",1877); else ;
    
#line 1876 
    long tmp_3 = (long)(__ret_warn_on != 0);
  }
  
#line 1878 
  netif_tx_disable(efx->net_dev);
  
#line 1880 
  efx_stop_datapath(efx);
  return_label: 
#line 1881 
                return;
}


#line 1883  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_remove_all(struct efx_nic *efx)
{
  
#line 1885 
  efx_remove_channels(efx);
  
#line 1886 
  efx_remove_filters(efx);
  
#line 1888 
  (*((efx->type)->vswitching_remove))(efx);
  
#line 1890 
  efx_remove_port(efx);
  
#line 1891 
  efx_remove_nic(efx);
  
#line 1892 
  return;
}


#line 1900  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static unsigned int irq_mod_ticks(unsigned int usecs, unsigned int quantum_ns)
{
  unsigned int __retres;
  
#line 1902 
  if (usecs == 0U) {
    
#line 1903 
    __retres = 0U;
    
#line 1903 
    goto return_label;
  }
  else ;
  
#line 1904 
  if (usecs * 1000U < quantum_ns) {
    
#line 1905 
    __retres = 1U;
    
#line 1905 
    goto return_label;
  }
  else ;
  
#line 1906 
  __retres = (usecs * 1000U) / quantum_ns;
  return_label: 
#line 1906 
                return __retres;
}


#line 1910  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
int efx_init_irq_moderation(struct efx_nic *efx, unsigned int tx_usecs, unsigned int rx_usecs, bool rx_adaptive, bool rx_may_override_tx)
{
  int __retres;
  struct efx_channel *channel;
  unsigned int tx_ticks;
  unsigned int rx_ticks;
  bool tmp_1;
  
#line 1915 
  unsigned int irq_mod_max = ((efx->type)->timer_period_max * efx->timer_quantum_ns + 999U) / 1000U;
  
#line 1921 
  if ((efx->state == (unsigned int)STATE_READY || efx->state == (unsigned int)STATE_RECOVERY) || efx->state == (unsigned int)STATE_DISABLED) {
    int tmp;
    
#line 1921 
    tmp = rtnl_is_locked();
    
#line 1921 
    if ((long)(tmp == 0) != 0L) {
      
#line 1921 
      printk("\001",(char *)"/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c",1921);
      
#line 1921 
      dump_stack();
    }
    else ;
  }
  else ;
  
#line 1923 
  if (tx_usecs > irq_mod_max || rx_usecs > irq_mod_max) {
    
#line 1924 
    __retres = -22;
    
#line 1924 
    goto return_label;
  }
  else ;
  
#line 1926 
  tx_ticks = irq_mod_ticks(tx_usecs,efx->timer_quantum_ns);
  
#line 1927 
  rx_ticks = irq_mod_ticks(rx_usecs,efx->timer_quantum_ns);
  
#line 1929 
  if ((tx_ticks != rx_ticks && efx->tx_channel_offset == 0U) && ! rx_may_override_tx) {
    
#line 1931 
    if ((efx->msg_enable & 1U) != 0U) 
#line 1931 
                                      netdev_err((struct net_device const *)efx->net_dev,"Channels are shared. "); else ;
    
#line 1933 
    __retres = -22;
    
#line 1933 
    goto return_label;
  }
  else ;
  
#line 1936 
  efx->irq_rx_adaptive = rx_adaptive;
  
#line 1937 
  efx->irq_rx_moderation = rx_ticks;
  
#line 1938 
  channel = efx->channel[0];
  
#line 1938 
  goto ldv_57514;
  ldv_57513: 
#line 1939 
  ;
  
#line 1939 
  tmp_1 = efx_channel_has_rx_queue(channel);
  
#line 1939 
  if ((int)tmp_1 != 0) 
#line 1940 
                       channel->irq_moderation = rx_ticks;
  else {
    bool tmp_0;
    
#line 1941 
    tmp_0 = efx_channel_has_tx_queues(channel);
    
#line 1941 
    if ((int)tmp_0 != 0) 
#line 1942 
                         channel->irq_moderation = tx_ticks; else ;
  }
  
#line 1938 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 1938 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 1938 
                                                                    channel = (struct efx_channel *)0;
  ldv_57514: 
#line 1939 
  ;
  
#line 1938 
  if (channel != (struct efx_channel *)0) 
#line 1940 
                                          goto ldv_57513; else 
#line 1943 
                                                               goto ldv_57515;
  ldv_57515: 
#line 1944 
  ;
  
#line 1945 
  __retres = 0;
  return_label: 
#line 1945 
                return __retres;
}


#line 1948  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
void efx_get_irq_moderation(struct efx_nic *efx, unsigned int *tx_usecs, unsigned int *rx_usecs, bool *rx_adaptive)
{
  
#line 1955 
  *rx_adaptive = efx->irq_rx_adaptive;
  
#line 1956 
  *rx_usecs = (efx->irq_rx_moderation * efx->timer_quantum_ns + 999U) / 1000U;
  
#line 1964 
  if (efx->tx_channel_offset == 0U) 
#line 1965 
                                    *tx_usecs = *rx_usecs; else 
#line 1967 
                                                                *tx_usecs = ((efx->channel[efx->tx_channel_offset])->irq_moderation * efx->timer_quantum_ns + 999U) / 1000U;
  
#line 1968 
  return;
}


#line 1980  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_monitor(struct work_struct *data)
{
  struct efx_nic *tmp;
  int tmp_5;
  {
    
#line 1982 
    struct work_struct const *__mptr = (struct work_struct const *)data;
    
#line 1982 
    tmp = (struct efx_nic *)__mptr + 18446744073709547968U;
  }
  
#line 1982 
  struct efx_nic *efx = tmp;
  
#line 1985 
  if (0) {
    
#line 1985 
    if ((efx->msg_enable & 8U) != 0U) {
      int tmp_4;
      {
        int pscr_ret__;
        {
          
#line 1985 
          void const *__vpp_verify = (void const *)0;
          
#line 1985 
          void const *tmp_2 = __vpp_verify;
        }
        
#line 1985 
        switch (4UL) {
          int tmp_0;
          int tmp_1;
          int tmp_2_0;
          int tmp_3;
          case (unsigned long)1: 
#line 1985 
          ;
          {
            int pfo_ret__;
            
#line 1985 
            switch (4UL) {
              case (unsigned long)1: 
#line 1985 
              ;
              
#line 1986 
              ldv_inline_asm();
              
#line 1985 
              goto ldv_57533;
              case (unsigned long)2: 
#line 1985 
              ;
              
#line 1986 
              ldv_inline_asm();
              
#line 1985 
              goto ldv_57533;
              case (unsigned long)4: 
#line 1985 
              ;
              
#line 1986 
              ldv_inline_asm();
              
#line 1985 
              goto ldv_57533;
              case (unsigned long)8: 
#line 1985 
              ;
              
#line 1986 
              ldv_inline_asm();
              
#line 1985 
              goto ldv_57533;
              default: 
#line 1985 
              ;
              
#line 1985 
              __bad_percpu_size();
            }
            ldv_57533: 
#line 1985 
            ;
            
#line 1985 
            tmp_0 = pfo_ret__;
          }
          
#line 1985 
          pscr_ret__ = tmp_0;
          
#line 1985 
          goto ldv_57539;
          case (unsigned long)2: 
#line 1985 
          ;
          {
            int pfo_ret___0;
            
#line 1985 
            switch (4UL) {
              case (unsigned long)1: 
#line 1985 
              ;
              
#line 1986 
              ldv_inline_asm();
              
#line 1985 
              goto ldv_57543;
              case (unsigned long)2: 
#line 1985 
              ;
              
#line 1986 
              ldv_inline_asm();
              
#line 1985 
              goto ldv_57543;
              case (unsigned long)4: 
#line 1985 
              ;
              
#line 1986 
              ldv_inline_asm();
              
#line 1985 
              goto ldv_57543;
              case (unsigned long)8: 
#line 1985 
              ;
              
#line 1986 
              ldv_inline_asm();
              
#line 1985 
              goto ldv_57543;
              default: 
#line 1985 
              ;
              
#line 1985 
              __bad_percpu_size();
            }
            ldv_57543: 
#line 1985 
            ;
            
#line 1985 
            tmp_1 = pfo_ret___0;
          }
          
#line 1985 
          pscr_ret__ = tmp_1;
          
#line 1985 
          goto ldv_57539;
          case (unsigned long)4: 
#line 1985 
          ;
          {
            int pfo_ret___1;
            
#line 1985 
            switch (4UL) {
              case (unsigned long)1: 
#line 1985 
              ;
              
#line 1986 
              ldv_inline_asm();
              
#line 1985 
              goto ldv_57552;
              case (unsigned long)2: 
#line 1985 
              ;
              
#line 1986 
              ldv_inline_asm();
              
#line 1985 
              goto ldv_57552;
              case (unsigned long)4: 
#line 1985 
              ;
              
#line 1986 
              ldv_inline_asm();
              
#line 1985 
              goto ldv_57552;
              case (unsigned long)8: 
#line 1985 
              ;
              
#line 1986 
              ldv_inline_asm();
              
#line 1985 
              goto ldv_57552;
              default: 
#line 1985 
              ;
              
#line 1985 
              __bad_percpu_size();
            }
            ldv_57552: 
#line 1985 
            ;
            
#line 1985 
            tmp_2_0 = pfo_ret___1;
          }
          
#line 1985 
          pscr_ret__ = tmp_2_0;
          
#line 1985 
          goto ldv_57539;
          case (unsigned long)8: 
#line 1985 
          ;
          {
            int pfo_ret___2;
            
#line 1985 
            switch (4UL) {
              case (unsigned long)1: 
#line 1985 
              ;
              
#line 1986 
              ldv_inline_asm();
              
#line 1985 
              goto ldv_57561;
              case (unsigned long)2: 
#line 1985 
              ;
              
#line 1986 
              ldv_inline_asm();
              
#line 1985 
              goto ldv_57561;
              case (unsigned long)4: 
#line 1985 
              ;
              
#line 1986 
              ldv_inline_asm();
              
#line 1985 
              goto ldv_57561;
              case (unsigned long)8: 
#line 1985 
              ;
              
#line 1986 
              ldv_inline_asm();
              
#line 1985 
              goto ldv_57561;
              default: 
#line 1985 
              ;
              
#line 1985 
              __bad_percpu_size();
            }
            ldv_57561: 
#line 1985 
            ;
            
#line 1985 
            tmp_3 = pfo_ret___2;
          }
          
#line 1985 
          pscr_ret__ = tmp_3;
          
#line 1985 
          goto ldv_57539;
          default: 
#line 1985 
          ;
          
#line 1985 
          __bad_size_call_parameter();
          
#line 1985 
          goto ldv_57539;
        }
        ldv_57539: 
#line 1985 
        ;
        
#line 1985 
        tmp_4 = pscr_ret__;
      }
      
#line 1985 
      ;
      
#line 1985 
      netdev_printk("\001",(struct net_device const *)efx->net_dev,"hardware monitor executing on CPU %d\n",tmp_4);
    }
    else ;
  }
  else ;
  
#line 1988 
  if ((long)((efx->type)->monitor == (void (*)(struct efx_nic *))0) != 0L) {
    
#line 1990 
    ldv_inline_asm();
    
#line 1988 
    ;
  }
  else ;
  
#line 1993 
  tmp_5 = ldv_mutex_trylock_107(& efx->mac_lock);
  
#line 1993 
  if (tmp_5 != 0) {
    
#line 1994 
    if ((int)efx->port_enabled != 0) 
#line 1995 
                                     (*((efx->type)->monitor))(efx); else ;
    
#line 1996 
    ldv_mutex_unlock_108_0(& efx->mac_lock);
  }
  else ;
  
#line 1999 
  ldv_queue_delayed_work_109(efx->workqueue,& efx->monitor_work,(unsigned long)efx_monitor_interval);
  
#line 2000 
  return;
}


#line 2012  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_ioctl(struct net_device *net_dev, struct ifreq *ifr, int cmd)
{
  int __retres;
  int tmp_3;
  
#line 2014 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 2015 
  struct mii_ioctl_data *data = if_mii(ifr);
  
#line 2017 
  if (cmd == 35248) {
    int tmp_1;
    
#line 2018 
    tmp_1 = efx_ptp_set_ts_config(efx,ifr);
    
#line 2018 
    __retres = tmp_1;
    
#line 2018 
    goto return_label;
  }
  else ;
  
#line 2019 
  if (cmd == 35249) {
    int tmp_2;
    
#line 2020 
    tmp_2 = efx_ptp_get_ts_config(efx,ifr);
    
#line 2020 
    __retres = tmp_2;
    
#line 2020 
    goto return_label;
  }
  else ;
  
#line 2023 
  if ((unsigned int)cmd + 4294932152U <= 1U && ((int)data->phy_id & 64512) == 1024) 
    
#line 2025 
    data->phy_id = (unsigned short)((unsigned int)data->phy_id ^ 33792U); else ;
  
#line 2027 
  tmp_3 = mdio_mii_ioctl((struct mdio_if_info const *)(& efx->mdio),data,cmd);
  
#line 2027 
  __retres = tmp_3;
  return_label: 
#line 2027 
                return __retres;
}


#line 2036  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_init_napi_channel(struct efx_channel *channel)
{
  
#line 2038 
  struct efx_nic *efx = channel->efx;
  
#line 2040 
  channel->napi_dev = efx->net_dev;
  
#line 2041 
  netif_napi_add(channel->napi_dev,& channel->napi_str,& efx_poll,napi_weight);
  
#line 2043 
  napi_hash_add(& channel->napi_str);
  
#line 2044 
  efx_channel_init_lock(channel);
  
#line 2045 
  return;
}


#line 2047  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_init_napi(struct efx_nic *efx)
{
  struct efx_channel *channel;
  
#line 2051 
  channel = efx->channel[0];
  
#line 2051 
  goto ldv_57586;
  ldv_57585: 
#line 2052 
  ;
  
#line 2052 
  efx_init_napi_channel(channel);
  
#line 2051 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 2051 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 2051 
                                                                    channel = (struct efx_channel *)0;
  ldv_57586: 
#line 2052 
  ;
  
#line 2051 
  if (channel != (struct efx_channel *)0) 
#line 2053 
                                          goto ldv_57585; else 
#line 2056 
                                                               goto ldv_57587;
  ldv_57587: 
#line 2057 
  ;
  
#line 2058 
  return;
}


#line 2055  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_fini_napi_channel(struct efx_channel *channel)
{
  
#line 2057 
  if (channel->napi_dev != (struct net_device *)0) {
    
#line 2058 
    netif_napi_del(& channel->napi_str);
    
#line 2059 
    napi_hash_del(& channel->napi_str);
  }
  else ;
  
#line 2061 
  channel->napi_dev = (struct net_device *)0;
  
#line 2062 
  return;
}


#line 2064  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_fini_napi(struct efx_nic *efx)
{
  struct efx_channel *channel;
  
#line 2068 
  channel = efx->channel[0];
  
#line 2068 
  goto ldv_57596;
  ldv_57595: 
#line 2069 
  ;
  
#line 2069 
  efx_fini_napi_channel(channel);
  
#line 2068 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 2068 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 2068 
                                                                    channel = (struct efx_channel *)0;
  ldv_57596: 
#line 2069 
  ;
  
#line 2068 
  if (channel != (struct efx_channel *)0) 
#line 2070 
                                          goto ldv_57595; else 
#line 2073 
                                                               goto ldv_57597;
  ldv_57597: 
#line 2074 
  ;
  
#line 2075 
  return;
}


#line 2084  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_netpoll(struct net_device *net_dev)
{
  struct efx_channel *channel;
  
#line 2086 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 2089 
  channel = efx->channel[0];
  
#line 2089 
  goto ldv_57604;
  ldv_57603: 
#line 2090 
  ;
  
#line 2090 
  efx_schedule_channel_2(channel);
  
#line 2089 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 2089 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 2089 
                                                                    channel = (struct efx_channel *)0;
  ldv_57604: 
#line 2090 
  ;
  
#line 2089 
  if (channel != (struct efx_channel *)0) 
#line 2091 
                                          goto ldv_57603; else 
#line 2094 
                                                               goto ldv_57605;
  ldv_57605: 
#line 2095 
  ;
  
#line 2096 
  return;
}


#line 2096  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_busy_poll(struct napi_struct *napi)
{
  int __retres;
  struct efx_channel *tmp;
  int old_rx_packets;
  int rx_packets;
  int tmp_1;
  bool tmp_0;
  int tmp_3;
  bool tmp_2;
  {
    
#line 2099 
    struct napi_struct const *__mptr = (struct napi_struct const *)napi;
    
#line 2099 
    tmp = (struct efx_channel *)__mptr + 18446744073709551568U;
  }
  
#line 2098 
  struct efx_channel *channel = tmp;
  
#line 2100 
  struct efx_nic *efx = channel->efx;
  
#line 2101 
  int budget = 4;
  
#line 2104 
  tmp_0 = netif_running((struct net_device const *)efx->net_dev);
  
#line 2104 
  if (tmp_0) 
#line 2104 
             tmp_1 = 0; else 
#line 2104 
                             tmp_1 = 1;
  
#line 2104 
  if (tmp_1) {
    
#line 2105 
    __retres = -1;
    
#line 2105 
    goto return_label;
  }
  else ;
  
#line 2107 
  tmp_2 = efx_channel_lock_poll(channel);
  
#line 2107 
  if (tmp_2) 
#line 2107 
             tmp_3 = 0; else 
#line 2107 
                             tmp_3 = 1;
  
#line 2107 
  if (tmp_3) {
    
#line 2108 
    __retres = -2;
    
#line 2108 
    goto return_label;
  }
  else ;
  
#line 2110 
  old_rx_packets = (int)channel->rx_queue.rx_packets;
  
#line 2111 
  efx_process_channel(channel,budget);
  
#line 2113 
  rx_packets = (int)(channel->rx_queue.rx_packets - (unsigned long)old_rx_packets);
  
#line 2120 
  efx_channel_unlock_poll(channel);
  
#line 2122 
  __retres = rx_packets;
  return_label: 
#line 2122 
                return __retres;
}


#line 2133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
int efx_net_open(struct net_device *net_dev)
{
  int __retres;
  int rc;
  int tmp_5;
  
#line 2135 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 2138 
  if ((efx->msg_enable & 32U) != 0U) {
    
#line 2138 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_net_open", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "opening device on CPU %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2139U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 2138 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      int tmp_4;
      {
        int pscr_ret__;
        {
          
#line 2138 
          void const *__vpp_verify = (void const *)0;
          
#line 2138 
          void const *tmp_2 = __vpp_verify;
        }
        
#line 2138 
        switch (4UL) {
          int tmp_0;
          int tmp_1;
          int tmp_2_0;
          int tmp_3;
          case (unsigned long)1: 
#line 2138 
          ;
          {
            int pfo_ret__;
            
#line 2138 
            switch (4UL) {
              case (unsigned long)1: 
#line 2138 
              ;
              
#line 2139 
              ldv_inline_asm();
              
#line 2138 
              goto ldv_57628;
              case (unsigned long)2: 
#line 2138 
              ;
              
#line 2139 
              ldv_inline_asm();
              
#line 2138 
              goto ldv_57628;
              case (unsigned long)4: 
#line 2138 
              ;
              
#line 2139 
              ldv_inline_asm();
              
#line 2138 
              goto ldv_57628;
              case (unsigned long)8: 
#line 2138 
              ;
              
#line 2139 
              ldv_inline_asm();
              
#line 2138 
              goto ldv_57628;
              default: 
#line 2138 
              ;
              
#line 2138 
              __bad_percpu_size();
            }
            ldv_57628: 
#line 2138 
            ;
            
#line 2138 
            tmp_0 = pfo_ret__;
          }
          
#line 2138 
          pscr_ret__ = tmp_0;
          
#line 2138 
          goto ldv_57634;
          case (unsigned long)2: 
#line 2138 
          ;
          {
            int pfo_ret___0;
            
#line 2138 
            switch (4UL) {
              case (unsigned long)1: 
#line 2138 
              ;
              
#line 2139 
              ldv_inline_asm();
              
#line 2138 
              goto ldv_57638;
              case (unsigned long)2: 
#line 2138 
              ;
              
#line 2139 
              ldv_inline_asm();
              
#line 2138 
              goto ldv_57638;
              case (unsigned long)4: 
#line 2138 
              ;
              
#line 2139 
              ldv_inline_asm();
              
#line 2138 
              goto ldv_57638;
              case (unsigned long)8: 
#line 2138 
              ;
              
#line 2139 
              ldv_inline_asm();
              
#line 2138 
              goto ldv_57638;
              default: 
#line 2138 
              ;
              
#line 2138 
              __bad_percpu_size();
            }
            ldv_57638: 
#line 2138 
            ;
            
#line 2138 
            tmp_1 = pfo_ret___0;
          }
          
#line 2138 
          pscr_ret__ = tmp_1;
          
#line 2138 
          goto ldv_57634;
          case (unsigned long)4: 
#line 2138 
          ;
          {
            int pfo_ret___1;
            
#line 2138 
            switch (4UL) {
              case (unsigned long)1: 
#line 2138 
              ;
              
#line 2139 
              ldv_inline_asm();
              
#line 2138 
              goto ldv_57647;
              case (unsigned long)2: 
#line 2138 
              ;
              
#line 2139 
              ldv_inline_asm();
              
#line 2138 
              goto ldv_57647;
              case (unsigned long)4: 
#line 2138 
              ;
              
#line 2139 
              ldv_inline_asm();
              
#line 2138 
              goto ldv_57647;
              case (unsigned long)8: 
#line 2138 
              ;
              
#line 2139 
              ldv_inline_asm();
              
#line 2138 
              goto ldv_57647;
              default: 
#line 2138 
              ;
              
#line 2138 
              __bad_percpu_size();
            }
            ldv_57647: 
#line 2138 
            ;
            
#line 2138 
            tmp_2_0 = pfo_ret___1;
          }
          
#line 2138 
          pscr_ret__ = tmp_2_0;
          
#line 2138 
          goto ldv_57634;
          case (unsigned long)8: 
#line 2138 
          ;
          {
            int pfo_ret___2;
            
#line 2138 
            switch (4UL) {
              case (unsigned long)1: 
#line 2138 
              ;
              
#line 2139 
              ldv_inline_asm();
              
#line 2138 
              goto ldv_57656;
              case (unsigned long)2: 
#line 2138 
              ;
              
#line 2139 
              ldv_inline_asm();
              
#line 2138 
              goto ldv_57656;
              case (unsigned long)4: 
#line 2138 
              ;
              
#line 2139 
              ldv_inline_asm();
              
#line 2138 
              goto ldv_57656;
              case (unsigned long)8: 
#line 2138 
              ;
              
#line 2139 
              ldv_inline_asm();
              
#line 2138 
              goto ldv_57656;
              default: 
#line 2138 
              ;
              
#line 2138 
              __bad_percpu_size();
            }
            ldv_57656: 
#line 2138 
            ;
            
#line 2138 
            tmp_3 = pfo_ret___2;
          }
          
#line 2138 
          pscr_ret__ = tmp_3;
          
#line 2138 
          goto ldv_57634;
          default: 
#line 2138 
          ;
          
#line 2138 
          __bad_size_call_parameter();
          
#line 2138 
          goto ldv_57634;
        }
        ldv_57634: 
#line 2138 
        ;
        
#line 2138 
        tmp_4 = pscr_ret__;
      }
      
#line 2138 
      ;
      
#line 2138 
      __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"opening device on CPU %d\n",tmp_4);
    }
    else ;
  }
  else ;
  
#line 2141 
  rc = efx_check_disabled(efx);
  
#line 2142 
  if (rc != 0) {
    
#line 2143 
    __retres = rc;
    
#line 2143 
    goto return_label;
  }
  else ;
  
#line 2144 
  if (((unsigned int)efx->phy_mode & 8U) != 0U) {
    
#line 2145 
    __retres = -16;
    
#line 2145 
    goto return_label;
  }
  else ;
  
#line 2146 
  tmp_5 = efx_mcdi_poll_reboot(efx);
  
#line 2146 
  if (tmp_5 != 0) {
    int tmp_6;
    
#line 2146 
    tmp_6 = efx_reset(efx,(enum reset_type)RESET_TYPE_ALL);
    
#line 2146 
    if (tmp_6 != 0) {
      
#line 2147 
      __retres = -5;
      
#line 2147 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 2151 
  efx_link_status_changed(efx);
  
#line 2153 
  efx_start_all(efx);
  
#line 2154 
  efx_selftest_async_start(efx);
  
#line 2155 
  __retres = 0;
  return_label: 
#line 2155 
                return __retres;
}


#line 2162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
int efx_net_stop(struct net_device *net_dev)
{
  int __retres;
  
#line 2164 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 2166 
  if ((efx->msg_enable & 16U) != 0U) {
    
#line 2166 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_net_stop", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "closing on CPU %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2167U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 2166 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      int tmp_4;
      {
        int pscr_ret__;
        {
          
#line 2166 
          void const *__vpp_verify = (void const *)0;
          
#line 2166 
          void const *tmp_2 = __vpp_verify;
        }
        
#line 2166 
        switch (4UL) {
          int tmp_0;
          int tmp_1;
          int tmp_2_0;
          int tmp_3;
          case (unsigned long)1: 
#line 2166 
          ;
          {
            int pfo_ret__;
            
#line 2166 
            switch (4UL) {
              case (unsigned long)1: 
#line 2166 
              ;
              
#line 2167 
              ldv_inline_asm();
              
#line 2166 
              goto ldv_57675;
              case (unsigned long)2: 
#line 2166 
              ;
              
#line 2167 
              ldv_inline_asm();
              
#line 2166 
              goto ldv_57675;
              case (unsigned long)4: 
#line 2166 
              ;
              
#line 2167 
              ldv_inline_asm();
              
#line 2166 
              goto ldv_57675;
              case (unsigned long)8: 
#line 2166 
              ;
              
#line 2167 
              ldv_inline_asm();
              
#line 2166 
              goto ldv_57675;
              default: 
#line 2166 
              ;
              
#line 2166 
              __bad_percpu_size();
            }
            ldv_57675: 
#line 2166 
            ;
            
#line 2166 
            tmp_0 = pfo_ret__;
          }
          
#line 2166 
          pscr_ret__ = tmp_0;
          
#line 2166 
          goto ldv_57681;
          case (unsigned long)2: 
#line 2166 
          ;
          {
            int pfo_ret___0;
            
#line 2166 
            switch (4UL) {
              case (unsigned long)1: 
#line 2166 
              ;
              
#line 2167 
              ldv_inline_asm();
              
#line 2166 
              goto ldv_57685;
              case (unsigned long)2: 
#line 2166 
              ;
              
#line 2167 
              ldv_inline_asm();
              
#line 2166 
              goto ldv_57685;
              case (unsigned long)4: 
#line 2166 
              ;
              
#line 2167 
              ldv_inline_asm();
              
#line 2166 
              goto ldv_57685;
              case (unsigned long)8: 
#line 2166 
              ;
              
#line 2167 
              ldv_inline_asm();
              
#line 2166 
              goto ldv_57685;
              default: 
#line 2166 
              ;
              
#line 2166 
              __bad_percpu_size();
            }
            ldv_57685: 
#line 2166 
            ;
            
#line 2166 
            tmp_1 = pfo_ret___0;
          }
          
#line 2166 
          pscr_ret__ = tmp_1;
          
#line 2166 
          goto ldv_57681;
          case (unsigned long)4: 
#line 2166 
          ;
          {
            int pfo_ret___1;
            
#line 2166 
            switch (4UL) {
              case (unsigned long)1: 
#line 2166 
              ;
              
#line 2167 
              ldv_inline_asm();
              
#line 2166 
              goto ldv_57694;
              case (unsigned long)2: 
#line 2166 
              ;
              
#line 2167 
              ldv_inline_asm();
              
#line 2166 
              goto ldv_57694;
              case (unsigned long)4: 
#line 2166 
              ;
              
#line 2167 
              ldv_inline_asm();
              
#line 2166 
              goto ldv_57694;
              case (unsigned long)8: 
#line 2166 
              ;
              
#line 2167 
              ldv_inline_asm();
              
#line 2166 
              goto ldv_57694;
              default: 
#line 2166 
              ;
              
#line 2166 
              __bad_percpu_size();
            }
            ldv_57694: 
#line 2166 
            ;
            
#line 2166 
            tmp_2_0 = pfo_ret___1;
          }
          
#line 2166 
          pscr_ret__ = tmp_2_0;
          
#line 2166 
          goto ldv_57681;
          case (unsigned long)8: 
#line 2166 
          ;
          {
            int pfo_ret___2;
            
#line 2166 
            switch (4UL) {
              case (unsigned long)1: 
#line 2166 
              ;
              
#line 2167 
              ldv_inline_asm();
              
#line 2166 
              goto ldv_57703;
              case (unsigned long)2: 
#line 2166 
              ;
              
#line 2167 
              ldv_inline_asm();
              
#line 2166 
              goto ldv_57703;
              case (unsigned long)4: 
#line 2166 
              ;
              
#line 2167 
              ldv_inline_asm();
              
#line 2166 
              goto ldv_57703;
              case (unsigned long)8: 
#line 2166 
              ;
              
#line 2167 
              ldv_inline_asm();
              
#line 2166 
              goto ldv_57703;
              default: 
#line 2166 
              ;
              
#line 2166 
              __bad_percpu_size();
            }
            ldv_57703: 
#line 2166 
            ;
            
#line 2166 
            tmp_3 = pfo_ret___2;
          }
          
#line 2166 
          pscr_ret__ = tmp_3;
          
#line 2166 
          goto ldv_57681;
          default: 
#line 2166 
          ;
          
#line 2166 
          __bad_size_call_parameter();
          
#line 2166 
          goto ldv_57681;
        }
        ldv_57681: 
#line 2166 
        ;
        
#line 2166 
        tmp_4 = pscr_ret__;
      }
      
#line 2166 
      ;
      
#line 2166 
      __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"closing on CPU %d\n",tmp_4);
    }
    else ;
  }
  else ;
  
#line 2170 
  efx_stop_all(efx);
  
#line 2172 
  __retres = 0;
  
#line 2172 
  return __retres;
}


#line 2176  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static struct rtnl_link_stats64 *efx_net_stats(struct net_device *net_dev, struct rtnl_link_stats64 *stats)
{
  
#line 2179 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 2181 
  ldv_spin_lock_bh_110_1(& efx->stats_lock);
  
#line 2182 
  (*((efx->type)->update_stats))(efx,(u64 *)0ULL,stats);
  
#line 2183 
  ldv_spin_unlock_bh_111_1(& efx->stats_lock);
  
#line 2185 
  return stats;
}


#line 2189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_watchdog(struct net_device *net_dev)
{
  
#line 2191 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 2193 
  if ((efx->msg_enable & 128U) != 0U) 
#line 2193 
                                      netdev_err((struct net_device const *)efx->net_dev,"TX stuck with port_enabled=%d: resetting channels\n",(int)efx->port_enabled); else ;
  
#line 2197 
  efx_schedule_reset(efx,(enum reset_type)RESET_TYPE_TX_WATCHDOG);
  
#line 2198 
  return;
}


#line 2202  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_change_mtu(struct net_device *net_dev, int new_mtu)
{
  int __retres;
  int rc;
  
#line 2204 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 2207 
  rc = efx_check_disabled(efx);
  
#line 2208 
  if (rc != 0) {
    
#line 2209 
    __retres = rc;
    
#line 2209 
    goto return_label;
  }
  else ;
  
#line 2210 
  if (new_mtu > 9216) {
    
#line 2211 
    __retres = -22;
    
#line 2211 
    goto return_label;
  }
  else ;
  
#line 2213 
  if ((efx->msg_enable & 1U) != 0U) {
    
#line 2213 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_change_mtu", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "changing MTU to %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2213U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 2213 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 2213 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"changing MTU to %d\n",new_mtu); else ;
  }
  else ;
  
#line 2215 
  efx_device_detach_sync_2(efx);
  
#line 2216 
  efx_stop_all(efx);
  
#line 2218 
  ldv_mutex_lock_112_1(& efx->mac_lock);
  
#line 2219 
  net_dev->mtu = (unsigned int)new_mtu;
  
#line 2220 
  efx_mac_reconfigure(efx);
  
#line 2221 
  ldv_mutex_unlock_113_1(& efx->mac_lock);
  
#line 2223 
  efx_start_all(efx);
  
#line 2224 
  netif_device_attach(efx->net_dev);
  
#line 2225 
  __retres = 0;
  return_label: 
#line 2225 
                return __retres;
}


#line 2228  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_set_mac_address(struct net_device *net_dev, void *data)
{
  int __retres;
  u8 old_addr[6U];
  int rc;
  int tmp_1;
  bool tmp_0;
  
#line 2230 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 2231 
  struct sockaddr *addr = (struct sockaddr *)data;
  
#line 2232 
  u8 *new_addr = (u8 *)(& addr->sa_data);
  
#line 2236 
  tmp_0 = is_valid_ether_addr((u8 const *)new_addr);
  
#line 2236 
  if (tmp_0) 
#line 2236 
             tmp_1 = 0; else 
#line 2236 
                             tmp_1 = 1;
  
#line 2236 
  if (tmp_1) {
    
#line 2237 
    if ((efx->msg_enable & 1U) != 0U) 
#line 2237 
                                      netdev_err((struct net_device const *)efx->net_dev,"invalid ethernet MAC address requested: %pM\n",new_addr); else ;
    
#line 2240 
    __retres = -99;
    
#line 2240 
    goto return_label;
  }
  else ;
  
#line 2244 
  ether_addr_copy((u8 *)(& old_addr),(u8 const *)net_dev->dev_addr);
  
#line 2245 
  ether_addr_copy(net_dev->dev_addr,(u8 const *)new_addr);
  
#line 2246 
  if ((efx->type)->set_mac_address != (int (*)(struct efx_nic *))0) {
    
#line 2247 
    rc = (*((efx->type)->set_mac_address))(efx);
    
#line 2248 
    if (rc != 0) {
      
#line 2249 
      ether_addr_copy(net_dev->dev_addr,(u8 const *)(& old_addr));
      
#line 2250 
      __retres = rc;
      
#line 2250 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 2255 
  ldv_mutex_lock_114_0(& efx->mac_lock);
  
#line 2256 
  efx_mac_reconfigure(efx);
  
#line 2257 
  ldv_mutex_unlock_115_0(& efx->mac_lock);
  
#line 2259 
  __retres = 0;
  return_label: 
#line 2259 
                return __retres;
}


#line 2263  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_set_rx_mode(struct net_device *net_dev)
{
  
#line 2265 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 2267 
  if ((int)efx->port_enabled != 0) 
#line 2268 
                                   ldv_queue_work_116(efx->workqueue,& efx->mac_work); else ;
  
#line 2269 
  return;
}


#line 2272  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_set_features(struct net_device *net_dev, netdev_features_t data)
{
  int __retres;
  
#line 2274 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 2277 
  if (((net_dev->features & ~ data) & 4294967296ULL) != 0ULL) {
    int tmp_0;
    
#line 2278 
    tmp_0 = (*((efx->type)->filter_clear_rx))(efx,(enum efx_filter_priority)EFX_FILTER_PRI_MANUAL);
    
#line 2278 
    __retres = tmp_0;
    
#line 2278 
    goto return_label;
  }
  else ;
  
#line 2280 
  __retres = 0;
  return_label: 
#line 2280 
                return __retres;
}


#line 2283  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static struct net_device_ops const efx_netdev_ops = {.ndo_init = (int (*)(struct net_device *))0, .ndo_uninit = (void (*)(struct net_device *))0, .ndo_open = & efx_net_open, .ndo_stop = & efx_net_stop, .ndo_start_xmit = & efx_hard_start_xmit, .ndo_select_queue = (u16 (*)(struct net_device *, struct sk_buff *, void *, u16 (*)(struct net_device *, struct sk_buff *)))0, .ndo_change_rx_flags = (void (*)(struct net_device *, int ))0, .ndo_set_rx_mode = & efx_set_rx_mode, .ndo_set_mac_address = & efx_set_mac_address, .ndo_validate_addr = & eth_validate_addr, .ndo_do_ioctl = & efx_ioctl, .ndo_set_config = (int (*)(struct net_device *, struct ifmap *))0, .ndo_change_mtu = & efx_change_mtu, .ndo_neigh_setup = (int (*)(struct net_device *, struct neigh_parms *))0, .ndo_tx_timeout = & efx_watchdog, .ndo_get_stats64 = & efx_net_stats, .ndo_get_stats = (struct net_device_stats *(*)(struct net_device *))0, .ndo_vlan_rx_add_vid = (int (*)(struct net_device *, __be16 , u16 ))0, .ndo_vlan_rx_kill_vid = (int (*)(struct net_device *, __be16 , u16 ))0, .ndo_poll_controller = & efx_netpoll, .ndo_netpoll_setup = (int (*)(struct net_device *, struct netpoll_info *))0, .ndo_netpoll_cleanup = (void (*)(struct net_device *))0, .ndo_busy_poll = & efx_busy_poll, .ndo_set_vf_mac = & efx_sriov_set_vf_mac, .ndo_set_vf_vlan = & efx_sriov_set_vf_vlan, .ndo_set_vf_rate = (int (*)(struct net_device *, int , int , int ))0, .ndo_set_vf_spoofchk = & efx_sriov_set_vf_spoofchk, .ndo_get_vf_config = & efx_sriov_get_vf_config, .ndo_set_vf_link_state = & efx_sriov_set_vf_link_state, .ndo_get_vf_stats = (int (*)(struct net_device *, int , struct ifla_vf_stats *))0, .ndo_set_vf_port = (int (*)(struct net_device *, int , struct nlattr **))0, .ndo_get_vf_port = (int (*)(struct net_device *, int , struct sk_buff *))0, .ndo_set_vf_rss_query_en = (int (*)(struct net_device *, int , bool ))0, .ndo_setup_tc = & efx_setup_tc, .ndo_fcoe_enable = (int (*)(struct net_device *))0, .ndo_fcoe_disable = (int (*)(struct net_device *))0, .ndo_fcoe_ddp_setup = (int (*)(struct net_device *, u16 , struct scatterlist *, unsigned int ))0, .ndo_fcoe_ddp_done = (int (*)(struct net_device *, u16 ))0, .ndo_fcoe_ddp_target = (int (*)(struct net_device *, u16 , struct scatterlist *, unsigned int ))0, .ndo_fcoe_get_hbainfo = (int (*)(struct net_device *, struct netdev_fcoe_hbainfo *))0, .ndo_fcoe_get_wwn = (int (*)(struct net_device *, u64 *, int ))0, .ndo_rx_flow_steer = & efx_filter_rfs, .ndo_add_slave = (int (*)(struct net_device *, struct net_device *))0, .ndo_del_slave = (int (*)(struct net_device *, struct net_device *))0, .ndo_fix_features = (netdev_features_t (*)(struct net_device *, netdev_features_t ))0, .ndo_set_features = & efx_set_features, .ndo_neigh_construct = (int (*)(struct neighbour *))0, .ndo_neigh_destroy = (void (*)(struct neighbour *))0, .ndo_fdb_add = (int (*)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 , u16 ))0, .ndo_fdb_del = (int (*)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 ))0, .ndo_fdb_dump = (int (*)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int ))0, .ndo_bridge_setlink = (int (*)(struct net_device *, struct nlmsghdr *, u16 ))0, .ndo_bridge_getlink = (int (*)(struct sk_buff *, u32 , u32 , struct net_device *, u32 , int ))0, .ndo_bridge_dellink = (int (*)(struct net_device *, struct nlmsghdr *, u16 ))0, .ndo_change_carrier = (int (*)(struct net_device *, bool ))0, .ndo_get_phys_port_id = & efx_sriov_get_phys_port_id, .ndo_get_phys_port_name = (int (*)(struct net_device *, char *, size_t ))0, .ndo_add_vxlan_port = (void (*)(struct net_device *, sa_family_t , __be16 ))0, .ndo_del_vxlan_port = (void (*)(struct net_device *, sa_family_t , __be16 ))0, .ndo_dfwd_add_station = (void *(*)(struct net_device *, struct net_device *))0, .ndo_dfwd_del_station = (void (*)(struct net_device *, void *))0, .ndo_dfwd_start_xmit = (netdev_tx_t (*)(struct sk_buff *, struct net_device *, void *))0, .ndo_get_lock_subclass = (int (*)(struct net_device *))0, .ndo_features_check = (netdev_features_t (*)(struct sk_buff *, struct net_device *, netdev_features_t ))0, .ndo_set_tx_maxrate = (int (*)(struct net_device *, int , u32 ))0, .ndo_get_iflink = (int (*)(struct net_device const *))0};

#line 2315  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_update_name(struct efx_nic *efx)
{
  
#line 2317 
  strcpy((char *)(& efx->name),(char const *)(& (efx->net_dev)->name));
  
#line 2318 
  efx_mtd_rename(efx);
  
#line 2319 
  efx_set_channel_names(efx);
  
#line 2320 
  return;
}


#line 2322  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_netdev_event(struct notifier_block *this, unsigned long event, void *ptr)
{
  int __retres;
  
#line 2325 
  struct net_device *net_dev = netdev_notifier_info_to_dev((struct netdev_notifier_info const *)ptr);
  
#line 2327 
  if (net_dev->netdev_ops == & efx_netdev_ops && event == 10UL) {
    void *tmp_0;
    
#line 2329 
    tmp_0 = netdev_priv((struct net_device const *)net_dev);
    
#line 2329 
    efx_update_name((struct efx_nic *)tmp_0);
  }
  else ;
  
#line 2331 
  __retres = 0;
  
#line 2331 
  return __retres;
}


#line 2334  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static struct notifier_block efx_netdev_notifier = {.notifier_call = & efx_netdev_event, .next = (struct notifier_block *)0, .priority = 0};

#line 2339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static ssize_t show_phy_type(struct device *dev, struct device_attribute *attr, char *buf)
{
  ssize_t __retres;
  struct efx_nic *tmp_0;
  struct pci_dev *tmp;
  int tmp_1;
  {
    
#line 2341 
    struct device const *__mptr = (struct device const *)dev;
    
#line 2341 
    tmp = (struct pci_dev *)__mptr + 18446744073709551464U;
  }
  
#line 2341 
  tmp_0 = (struct efx_nic *)pci_get_drvdata(tmp);
  
#line 2341 
  struct efx_nic *efx = tmp_0;
  
#line 2342 
  tmp_1 = sprintf(buf,"%d\n",efx->phy_type);
  
#line 2342 
  __retres = (long)tmp_1;
  
#line 2342 
  return __retres;
}


#line 2344  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static struct device_attribute dev_attr_phy_type = {.attr = {.name = "phy_type", .mode = (unsigned short)292U, .ignore_lockdep = (_Bool)0, .key = (struct lock_class_key *)0, .skey = {.subkeys = {{.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}}}}, .show = & show_phy_type, .store = (ssize_t (*)(struct device *, struct device_attribute *, char const *, size_t ))0};

#line 2347  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static ssize_t show_mcdi_log(struct device *dev, struct device_attribute *attr, char *buf)
{
  ssize_t __retres;
  struct efx_nic *tmp_0;
  struct pci_dev *tmp;
  int tmp_2;
  {
    
#line 2350 
    struct device const *__mptr = (struct device const *)dev;
    
#line 2350 
    tmp = (struct pci_dev *)__mptr + 18446744073709551464U;
  }
  
#line 2350 
  tmp_0 = (struct efx_nic *)pci_get_drvdata(tmp);
  
#line 2350 
  struct efx_nic *efx = tmp_0;
  
#line 2351 
  struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
  
#line 2353 
  tmp_2 = scnprintf(buf,4096UL,"%d\n",(int)mcdi->logging_enabled);
  
#line 2353 
  __retres = (long)tmp_2;
  
#line 2353 
  return __retres;
}


#line 2355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static ssize_t set_mcdi_log(struct device *dev, struct device_attribute *attr, char const *buf, size_t count)
{
  ssize_t __retres;
  struct efx_nic *tmp_0;
  struct pci_dev *tmp;
  {
    
#line 2358 
    struct device const *__mptr = (struct device const *)dev;
    
#line 2358 
    tmp = (struct pci_dev *)__mptr + 18446744073709551464U;
  }
  
#line 2358 
  tmp_0 = (struct efx_nic *)pci_get_drvdata(tmp);
  
#line 2358 
  struct efx_nic *efx = tmp_0;
  
#line 2359 
  struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
  
#line 2360 
  bool enable = (_Bool)((count != 0UL && (int)*buf != 48) != 0);
  
#line 2362 
  mcdi->logging_enabled = enable;
  
#line 2363 
  __retres = (long)count;
  
#line 2363 
  return __retres;
}


#line 2365  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static struct device_attribute dev_attr_mcdi_logging = {.attr = {.name = "mcdi_logging", .mode = (unsigned short)420U, .ignore_lockdep = (_Bool)0, .key = (struct lock_class_key *)0, .skey = {.subkeys = {{.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}}}}, .show = & show_mcdi_log, .store = & set_mcdi_log};

#line 2368  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_register_netdev(struct efx_nic *efx)
{
  int __retres;
  struct efx_channel *channel;
  int rc;
  int tmp;
  
#line 2370 
  struct net_device *net_dev = efx->net_dev;
  
#line 2374 
  net_dev->watchdog_timeo = 1250;
  
#line 2375 
  net_dev->irq = (int)(efx->pci_dev)->irq;
  
#line 2376 
  net_dev->netdev_ops = & efx_netdev_ops;
  
#line 2377 
  tmp = efx_nic_rev(efx);
  
#line 2377 
  if (tmp > 3) 
#line 2378 
               net_dev->priv_flags |= 131072U; else ;
  
#line 2379 
  net_dev->ethtool_ops = & efx_ethtool_ops;
  
#line 2380 
  net_dev->gso_max_segs = (unsigned short)100U;
  
#line 2382 
  rtnl_lock();
  
#line 2388 
  efx->state = STATE_READY;
  
#line 2389 
  ldv_inline_asm();
  
#line 2390 
  if (efx->reset_pending != 0UL) {
    
#line 2391 
    if ((efx->msg_enable & 2U) != 0U) 
#line 2391 
                                      netdev_err((struct net_device const *)efx->net_dev,"aborting probe due to scheduled reset\n"); else ;
    
#line 2393 
    rc = -5;
    
#line 2394 
    goto fail_locked;
  }
  else ;
  
#line 2397 
  rc = dev_alloc_name(net_dev,(char const *)(& net_dev->name));
  
#line 2398 
  if (rc < 0) 
#line 2399 
              goto fail_locked; else ;
  
#line 2400 
  efx_update_name(efx);
  
#line 2403 
  netif_carrier_off(net_dev);
  
#line 2405 
  rc = register_netdevice(net_dev);
  
#line 2406 
  if (rc != 0) 
#line 2407 
               goto fail_locked; else ;
  
#line 2409 
  channel = efx->channel[0];
  
#line 2409 
  goto ldv_57835;
  ldv_57834: 
#line 2410 
  ;
  {
    struct efx_tx_queue *tx_queue;
    int tmp_2;
    bool tmp_1;
    
#line 2411 
    tmp_1 = efx_channel_has_tx_queues(channel);
    
#line 2411 
    if (tmp_1) 
#line 2411 
               tmp_2 = 0; else 
#line 2411 
                               tmp_2 = 1;
    
#line 2411 
    if (tmp_2) ;
    else {
      
#line 2411 
      tx_queue = (struct efx_tx_queue *)(& channel->tx_queue);
      
#line 2411 
      goto ldv_57832;
      ldv_57831: 
#line 2412 
      ;
      
#line 2412 
      efx_init_tx_queue_core_txq(tx_queue);
      
#line 2411 
      tx_queue += 1;
      ldv_57832: 
#line 2412 
      ;
      
#line 2411 
      if ((struct efx_tx_queue *)(& channel->tx_queue) + 4U > tx_queue) {
        bool tmp_0;
        
#line 2411 
        tmp_0 = efx_tx_queue_used(tx_queue);
        
#line 2411 
        if ((int)tmp_0 != 0) 
#line 2413 
                             goto ldv_57831; else 
#line 2416 
                                                  goto ldv_57833;
      }
      else 
#line 2416 
           goto ldv_57833;
      ldv_57833: 
#line 2417 
      ;
    }
  }
  
#line 2409 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 2409 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 2409 
                                                                    channel = (struct efx_channel *)0;
  ldv_57835: 
#line 2410 
  ;
  
#line 2409 
  if (channel != (struct efx_channel *)0) 
#line 2411 
                                          goto ldv_57834; else 
#line 2414 
                                                               goto ldv_57836;
  ldv_57836: 
#line 2415 
  ;
  
#line 2415 
  efx_associate(efx);
  
#line 2417 
  rtnl_unlock();
  
#line 2419 
  rc = ldv_device_create_file_117(& (efx->pci_dev)->dev,(struct device_attribute const *)(& dev_attr_phy_type));
  
#line 2420 
  if (rc != 0) {
    
#line 2421 
    if ((efx->msg_enable & 1U) != 0U) 
#line 2421 
                                      netdev_err((struct net_device const *)efx->net_dev,"failed to init net dev attributes\n"); else ;
    
#line 2423 
    goto fail_registered;
  }
  else ;
  
#line 2426 
  rc = ldv_device_create_file_118(& (efx->pci_dev)->dev,(struct device_attribute const *)(& dev_attr_mcdi_logging));
  
#line 2427 
  if (rc != 0) {
    
#line 2428 
    if ((efx->msg_enable & 1U) != 0U) 
#line 2428 
                                      netdev_err((struct net_device const *)efx->net_dev,"failed to init net dev attributes\n"); else ;
    
#line 2430 
    goto fail_attr_mcdi_logging;
  }
  else ;
  
#line 2434 
  __retres = 0;
  
#line 2434 
  goto return_label;
  fail_attr_mcdi_logging: 
#line 2437 
  ;
  
#line 2438 
  ldv_device_remove_file_119(& (efx->pci_dev)->dev,(struct device_attribute const *)(& dev_attr_phy_type));
  fail_registered: 
#line 2440 
  ;
  
#line 2441 
  rtnl_lock();
  
#line 2442 
  efx_dissociate(efx);
  
#line 2443 
  unregister_netdevice(net_dev);
  fail_locked: 
#line 2444 
  ;
  
#line 2445 
  efx->state = STATE_UNINIT;
  
#line 2446 
  rtnl_unlock();
  
#line 2447 
  if ((efx->msg_enable & 1U) != 0U) 
#line 2447 
                                    netdev_err((struct net_device const *)efx->net_dev,"could not register net dev\n"); else ;
  
#line 2448 
  __retres = rc;
  return_label: 
#line 2448 
                return __retres;
}


#line 2451  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_unregister_netdev(struct efx_nic *efx)
{
  void *tmp;
  int tmp_1;
  
#line 2453 
  if (efx->net_dev == (struct net_device *)0) 
#line 2454 
                                              goto return_label; else ;
  
#line 2456 
  tmp = netdev_priv((struct net_device const *)efx->net_dev);
  
#line 2456 
  ;
  
#line 2456 
  if ((long)(tmp != (void *)efx) != 0L) {
    
#line 2458 
    ldv_inline_asm();
    
#line 2456 
    ;
  }
  else ;
  
#line 2458 
  tmp_1 = efx_dev_registered(efx);
  
#line 2458 
  if (tmp_1 != 0) {
    char const *tmp_0;
    
#line 2459 
    tmp_0 = pci_name((struct pci_dev const *)efx->pci_dev);
    
#line 2459 
    ;
    
#line 2459 
    strlcpy((char *)(& efx->name),tmp_0,16UL);
    
#line 2461 
    ldv_device_remove_file_120(& (efx->pci_dev)->dev,(struct device_attribute const *)(& dev_attr_mcdi_logging));
    
#line 2463 
    ldv_device_remove_file_121(& (efx->pci_dev)->dev,(struct device_attribute const *)(& dev_attr_phy_type));
    
#line 2464 
    ldv_unregister_netdev_122(efx->net_dev);
  }
  else ;
  return_label: 
#line 2466 
                return;
}


#line 2476  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
void efx_reset_down(struct efx_nic *efx, enum reset_type method)
{
  
#line 2478 
  if ((efx->state == (unsigned int)STATE_READY || efx->state == (unsigned int)STATE_RECOVERY) || efx->state == (unsigned int)STATE_DISABLED) {
    int tmp;
    
#line 2478 
    tmp = rtnl_is_locked();
    
#line 2478 
    if ((long)(tmp == 0) != 0L) {
      
#line 2478 
      printk("\001",(char *)"/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c",2478);
      
#line 2478 
      dump_stack();
    }
    else ;
  }
  else ;
  
#line 2480 
  if (method == (unsigned int)RESET_TYPE_MCDI_TIMEOUT) 
#line 2481 
                                                       (*((efx->type)->prepare_flr))(efx); else ;
  
#line 2483 
  efx_stop_all(efx);
  
#line 2484 
  efx_disable_interrupts(efx);
  
#line 2486 
  ldv_mutex_lock_123(& efx->mac_lock);
  
#line 2487 
  if ((int)efx->port_initialized != 0 && (method != (unsigned int)RESET_TYPE_INVISIBLE && method != (unsigned int)RESET_TYPE_DATAPATH)) 
    
#line 2489 
    (*((efx->phy_op)->fini))(efx); else ;
  
#line 2490 
  (*((efx->type)->fini))(efx);
  
#line 2491 
  return;
}


#line 2498  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
int efx_reset_up(struct efx_nic *efx, enum reset_type method, bool ok)
{
  int __retres;
  int rc;
  
#line 2502 
  if ((efx->state == (unsigned int)STATE_READY || efx->state == (unsigned int)STATE_RECOVERY) || efx->state == (unsigned int)STATE_DISABLED) {
    int tmp;
    
#line 2502 
    tmp = rtnl_is_locked();
    
#line 2502 
    if ((long)(tmp == 0) != 0L) {
      
#line 2502 
      printk("\001",(char *)"/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c",2502);
      
#line 2502 
      dump_stack();
    }
    else ;
  }
  else ;
  
#line 2504 
  if (method == (unsigned int)RESET_TYPE_MCDI_TIMEOUT) 
#line 2505 
                                                       (*((efx->type)->finish_flr))(efx); else ;
  
#line 2508 
  rc = (*((efx->type)->init))(efx);
  
#line 2509 
  if (rc != 0) {
    
#line 2510 
    if ((efx->msg_enable & 1U) != 0U) 
#line 2510 
                                      netdev_err((struct net_device const *)efx->net_dev,"failed to initialise NIC\n"); else ;
    
#line 2511 
    goto fail;
  }
  else ;
  
#line 2514 
  if (! ok) 
#line 2515 
            goto fail; else ;
  
#line 2517 
  if ((int)efx->port_initialized != 0 && (method != (unsigned int)RESET_TYPE_INVISIBLE && method != (unsigned int)RESET_TYPE_DATAPATH)) {
    
#line 2519 
    rc = (*((efx->phy_op)->init))(efx);
    
#line 2520 
    if (rc != 0) 
#line 2521 
                 goto fail; else ;
    
#line 2522 
    rc = (*((efx->phy_op)->reconfigure))(efx);
    
#line 2523 
    if ((unsigned int)rc + 1U > 1U) {
      
#line 2524 
      if ((efx->msg_enable & 1U) != 0U) 
#line 2524 
                                        netdev_err((struct net_device const *)efx->net_dev,"could not restore PHY settings\n"); else ;
    }
    else ;
  }
  else ;
  
#line 2528 
  rc = efx_enable_interrupts(efx);
  
#line 2529 
  if (rc != 0) 
#line 2530 
               goto fail; else ;
  
#line 2533 
  rc = (*((efx->type)->vswitching_restore))(efx);
  
#line 2534 
  if (rc != 0) {
    
#line 2535 
    if ((efx->msg_enable & 2U) != 0U) 
#line 2535 
                                      netdev_warn((struct net_device const *)efx->net_dev,"failed to restore vswitching rc=%d;",rc); else ;
  }
  else ;
  
#line 2540 
  down_read(& efx->filter_sem);
  
#line 2541 
  efx_restore_filters(efx);
  
#line 2542 
  up_read(& efx->filter_sem);
  
#line 2543 
  if ((efx->type)->sriov_reset != (void (*)(struct efx_nic *))0) 
#line 2544 
                                                                 (*((efx->type)->sriov_reset))(efx); else ;
  
#line 2546 
  ldv_mutex_unlock_124(& efx->mac_lock);
  
#line 2548 
  efx_start_all(efx);
  
#line 2550 
  __retres = 0;
  
#line 2550 
  goto return_label;
  fail: 
#line 2552 
  ;
  
#line 2553 
  efx->port_initialized = (_Bool)0;
  
#line 2555 
  ldv_mutex_unlock_125_0(& efx->mac_lock);
  
#line 2557 
  __retres = rc;
  return_label: 
#line 2557 
                return __retres;
}


#line 2565  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
int efx_reset(struct efx_nic *efx, enum reset_type method)
{
  int rc;
  int rc2;
  bool disabled;
  
#line 2570 
  if ((efx->msg_enable & 1U) != 0U) {
    char const *tmp;
    
#line 2570 
    if (method <= (unsigned int)RESET_TYPE_MCDI_TIMEOUT) 
#line 2570 
                                                         tmp = efx_reset_type_names[(unsigned int)method]; else 
                                                                    
#line 2570 
                                                                    tmp = "(invalid)";
    
#line 2570 
    ;
    
#line 2570 
    netdev_info((struct net_device const *)efx->net_dev,"resetting (%s)\n",tmp);
  }
  else ;
  
#line 2573 
  efx_device_detach_sync_2(efx);
  
#line 2574 
  efx_reset_down(efx,method);
  
#line 2576 
  rc = (*((efx->type)->reset))(efx,method);
  
#line 2577 
  if (rc != 0) {
    
#line 2578 
    if ((efx->msg_enable & 1U) != 0U) 
#line 2578 
                                      netdev_err((struct net_device const *)efx->net_dev,"failed to reset hardware\n"); else ;
    
#line 2579 
    goto out;
  }
  else ;
  
#line 2585 
  if (method <= (unsigned int)RESET_TYPE_DISABLE) 
#line 2586 
                                                  efx->reset_pending &= (unsigned long)(- (1 << ((unsigned int)method + 1U))); else 
                                                                    
#line 2588 
                                                                    __set_bit((long)method,(unsigned long volatile *)(& efx->reset_pending));
  
#line 2594 
  pci_set_master(efx->pci_dev);
  out: 
#line 2596 
  ;
  
#line 2598 
  disabled = (_Bool)(((rc != 0 || method == (unsigned int)RESET_TYPE_DISABLE) || method == (unsigned int)RESET_TYPE_RECOVER_OR_DISABLE) != 0);
  
#line 2601 
  rc2 = efx_reset_up(efx,method,(_Bool)((int)((_Bool)(! ((int)disabled != 0)))));
  
#line 2602 
  if (rc2 != 0) {
    
#line 2603 
    disabled = (_Bool)1;
    
#line 2604 
    if (rc == 0) 
#line 2605 
                 rc = rc2; else ;
  }
  else ;
  
#line 2608 
  if ((int)disabled != 0) {
    
#line 2609 
    dev_close(efx->net_dev);
    
#line 2610 
    if ((efx->msg_enable & 1U) != 0U) 
#line 2610 
                                      netdev_err((struct net_device const *)efx->net_dev,"has been disabled\n"); else ;
    
#line 2611 
    efx->state = STATE_DISABLED;
  }
  else {
    
#line 2613 
    if ((efx->msg_enable & 1U) != 0U) {
      
#line 2613 
      struct _ddebug descriptor = {.modname = "sfc", .function = "efx_reset", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "reset complete\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2613U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 2613 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 2613 
                                                          __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"reset complete\n"); else ;
    }
    else ;
    
#line 2614 
    netif_device_attach(efx->net_dev);
  }
  
#line 2616 
  return rc;
}


#line 2624  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
int efx_try_recovery(struct efx_nic *efx)
{
  int __retres;
  
#line 2640 
  __retres = 0;
  
#line 2640 
  return __retres;
}


#line 2643  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_wait_for_bist_end(struct efx_nic *efx)
{
  int i;
  int tmp;
  
#line 2647 
  i = 0;
  
#line 2647 
  goto ldv_57872;
  ldv_57871: 
#line 2648 
  ;
  
#line 2648 
  tmp = efx_mcdi_poll_reboot(efx);
  
#line 2648 
  if (tmp != 0) 
#line 2649 
                goto out; else ;
  
#line 2650 
  msleep(100U);
  
#line 2647 
  i += 1;
  ldv_57872: 
#line 2648 
  ;
  
#line 2647 
  if (i <= 99) 
#line 2649 
               goto ldv_57871; else 
#line 2652 
                                    goto ldv_57873;
  ldv_57873: 
#line 2653 
  ;
  
#line 2653 
  if ((efx->msg_enable & 1U) != 0U) 
#line 2653 
                                    netdev_err((struct net_device const *)efx->net_dev,"Warning: No MC reboot after BIST mode\n"); else ;
  out: 
#line 2654 
  ;
  
#line 2658 
  efx->mc_bist_for_other_fn = (_Bool)0;
  
#line 2659 
  return;
}


#line 2664  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_reset_work(struct work_struct *data)
{
  struct efx_nic *tmp;
  unsigned long pending;
  enum reset_type method;
  unsigned long volatile *tmp_0;
  int tmp_1;
  {
    
#line 2666 
    struct work_struct const *__mptr = (struct work_struct const *)data;
    
#line 2666 
    tmp = (struct efx_nic *)__mptr + 18446744073709551504U;
  }
  
#line 2666 
  struct efx_nic *efx = tmp;
  {
    
#line 2670 
    unsigned long __var = 0UL;
    
#line 2670 
    tmp_0 = (unsigned long volatile *)(& efx->reset_pending);
  }
  
#line 2670 
  pending = *tmp_0;
  
#line 2671 
  tmp_1 = fls((int)pending);
  
#line 2671 
  method = (enum reset_type)(tmp_1 + -1);
  
#line 2673 
  if (method == (unsigned int)RESET_TYPE_MC_BIST) 
#line 2674 
                                                  efx_wait_for_bist_end(efx); else ;
  
#line 2676 
  if (method == (unsigned int)RESET_TYPE_RECOVER_OR_DISABLE || method == (unsigned int)RESET_TYPE_RECOVER_OR_ALL) {
    int tmp_2;
    
#line 2677 
    tmp_2 = efx_try_recovery(efx);
    
#line 2677 
    if (tmp_2 != 0) 
#line 2679 
                    goto return_label; else ;
  }
  else ;
  
#line 2681 
  if (pending == 0UL) 
#line 2682 
                      goto return_label; else ;
  
#line 2684 
  rtnl_lock();
  
#line 2690 
  if (efx->state == (unsigned int)STATE_READY) 
#line 2691 
                                               efx_reset(efx,method); else ;
  
#line 2693 
  rtnl_unlock();
  return_label: 
#line 2694 
                return;
}


#line 2696  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
void efx_schedule_reset(struct efx_nic *efx, enum reset_type type)
{
  enum reset_type method;
  enum nic_state volatile *tmp_3;
  
#line 2700 
  if (efx->state == (unsigned int)STATE_RECOVERY) {
    
#line 2701 
    if ((efx->msg_enable & 1U) != 0U) {
      
#line 2701 
      struct _ddebug descriptor = {.modname = "sfc", .function = "efx_schedule_reset", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "recovering: skip scheduling %s reset\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2703U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 2701 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
        char const *tmp;
        
#line 2701 
        if (type <= (unsigned int)RESET_TYPE_MCDI_TIMEOUT) 
#line 2701 
                                                           tmp = efx_reset_type_names[(unsigned int)type]; else 
                                                                    
#line 2701 
                                                                    tmp = "(invalid)";
        
#line 2701 
        ;
        
#line 2701 
        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"recovering: skip scheduling %s reset\n",tmp);
      }
      else ;
    }
    else ;
    
#line 2704 
    goto return_label;
  }
  else ;
  
#line 2707 
  switch ((unsigned int)type) {
    case (unsigned int)0: 
#line 2708 
    ;
    case (unsigned int)2: 
#line 2709 
    ;
    case (unsigned int)1: 
#line 2710 
    ;
    case (unsigned int)3: 
#line 2711 
    ;
    case (unsigned int)7: 
#line 2712 
    ;
    case (unsigned int)4: 
#line 2713 
    ;
    case (unsigned int)5: 
#line 2714 
    ;
    case (unsigned int)6: 
#line 2715 
    ;
    case (unsigned int)15: 
#line 2716 
    ;
    
#line 2717 
    method = type;
    
#line 2718 
    if ((efx->msg_enable & 1U) != 0U) {
      
#line 2718 
      struct _ddebug descriptor_0 = {.modname = "sfc", .function = "efx_schedule_reset", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "scheduling %s reset\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2719U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 2718 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) {
        char const *tmp_0;
        
#line 2718 
        if (method <= (unsigned int)RESET_TYPE_MCDI_TIMEOUT) 
#line 2718 
                                                             tmp_0 = efx_reset_type_names[(unsigned int)method]; else 
                                                                    
#line 2718 
                                                                    tmp_0 = "(invalid)";
        
#line 2718 
        ;
        
#line 2718 
        __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)efx->net_dev,"scheduling %s reset\n",tmp_0);
      }
      else ;
    }
    else ;
    
#line 2720 
    goto ldv_57901;
    default: 
#line 2721 
    ;
    
#line 2722 
    method = (*((efx->type)->map_reset_reason))(type);
    
#line 2723 
    if ((efx->msg_enable & 1U) != 0U) {
      
#line 2723 
      struct _ddebug descriptor_1 = {.modname = "sfc", .function = "efx_schedule_reset", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "scheduling %s reset for %s\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2725U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 2723 
      if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) {
        char const *tmp_1;
        char const *tmp_2;
        
#line 2723 
        if (type <= (unsigned int)RESET_TYPE_MCDI_TIMEOUT) 
#line 2723 
                                                           tmp_1 = efx_reset_type_names[(unsigned int)type]; else 
                                                                    
#line 2723 
                                                                    tmp_1 = "(invalid)";
        
#line 2723 
        if (method <= (unsigned int)RESET_TYPE_MCDI_TIMEOUT) 
#line 2723 
                                                             tmp_2 = efx_reset_type_names[(unsigned int)method]; else 
                                                                    
#line 2723 
                                                                    tmp_2 = "(invalid)";
        
#line 2723 
        ;
        
#line 2723 
        __dynamic_netdev_dbg(& descriptor_1,(struct net_device const *)efx->net_dev,"scheduling %s reset for %s\n",tmp_2,tmp_1);
      }
      else ;
    }
    else ;
    
#line 2726 
    goto ldv_57901;
  }
  ldv_57901: 
#line 2729 
  ;
  
#line 2729 
  set_bit((long)method,(unsigned long volatile *)(& efx->reset_pending));
  
#line 2730 
  ldv_inline_asm();
  {
    
#line 2735 
    enum nic_state __var = STATE_UNINIT;
    
#line 2735 
    tmp_3 = (enum nic_state volatile *)(& efx->state);
  }
  
#line 2735 
  ;
  
#line 2735 
  if (*tmp_3 != (unsigned int)STATE_READY) 
#line 2736 
                                           goto return_label; else ;
  
#line 2740 
  efx_mcdi_mode_poll(efx);
  
#line 2742 
  ldv_queue_work_126(reset_workqueue,& efx->reset_work);
  return_label: 
#line 2743 
                return;
}


#line 2752  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static struct pci_device_id const efx_pci_table[8U] = {{.vendor = 6436U, .device = 1795U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& falcon_a1_nic_type)}, {.vendor = 6436U, .device = 1808U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& falcon_b0_nic_type)}, {.vendor = 6436U, .device = 2051U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& siena_a0_nic_type)}, {.vendor = 6436U, .device = 2067U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& siena_a0_nic_type)}, {.vendor = 6436U, .device = 2307U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& efx_hunt_a0_nic_type)}, {.vendor = 6436U, .device = 6403U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& efx_hunt_a0_vf_nic_type)}, {.vendor = 6436U, .device = 2339U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& efx_hunt_a0_nic_type)}, {.vendor = 0U, .device = 0U, .subvendor = 0U, .subdevice = 0U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}};

#line 2781  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
int efx_port_dummy_op_int(struct efx_nic *efx)
{
  int __retres;
  
#line 2783 
  __retres = 0;
  
#line 2783 
  return __retres;
}


#line 2785  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
void efx_port_dummy_op_void(struct efx_nic *efx)
{
  
#line 2787 
  return;
}


#line 2787  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static bool efx_port_dummy_op_poll(struct efx_nic *efx)
{
  bool __retres;
  
#line 2789 
  __retres = (_Bool)0;
  
#line 2789 
  return __retres;
}


#line 2792  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static struct efx_phy_operations const efx_dummy_phy_operations = {.probe = (int (*)(struct efx_nic *))0, .init = & efx_port_dummy_op_int, .fini = & efx_port_dummy_op_void, .remove = (void (*)(struct efx_nic *))0, .reconfigure = & efx_port_dummy_op_int, .poll = & efx_port_dummy_op_poll, .get_settings = (void (*)(struct efx_nic *, struct ethtool_cmd *))0, .set_settings = (int (*)(struct efx_nic *, struct ethtool_cmd *))0, .set_npage_adv = (void (*)(struct efx_nic *, u32 ))0, .test_alive = (int (*)(struct efx_nic *))0, .test_name = (char const *(*)(struct efx_nic *, unsigned int ))0, .run_tests = (int (*)(struct efx_nic *, int *, unsigned int ))0, .get_module_eeprom = (int (*)(struct efx_nic *, struct ethtool_eeprom *, u8 *))0, .get_module_info = (int (*)(struct efx_nic *, struct ethtool_modinfo *))0};

#line 2808  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_init_struct(struct efx_nic *efx, struct pci_dev *pci_dev, struct net_device *net_dev)
{
  int __retres;
  int i;
  char const *tmp;
  unsigned int const tmp_1;
  char const *tmp_2;
  struct workqueue_struct *tmp_4;
  
#line 2814 
  INIT_LIST_HEAD(& efx->node);
  
#line 2815 
  INIT_LIST_HEAD(& efx->secondary_list);
  
#line 2816 
  spinlock_check(& efx->biu_lock);
  {
    struct lock_class_key __key;
    
#line 2816 
    __raw_spin_lock_init(& efx->biu_lock.__anonCompField_spinlock_18.rlock,"&(&efx->biu_lock)->rlock",& __key);
  }
  
#line 2818 
  INIT_LIST_HEAD(& efx->mtd_list);
  {
    struct lock_class_key __key_0;
    
#line 2820 
    __init_work(& efx->reset_work,0);
    
#line 2820 
    atomic_long_t __constr_expr_37 = {.counter = WORK_STRUCT_NO_POOL_1};
    
#line 2820 
    efx->reset_work.data = __constr_expr_37;
    
#line 2820 
    lockdep_init_map(& efx->reset_work.lockdep_map,"(&efx->reset_work)",& __key_0,0);
    
#line 2820 
    INIT_LIST_HEAD(& efx->reset_work.entry);
    
#line 2820 
    efx->reset_work.func = & efx_reset_work;
  }
  {
    struct lock_class_key __key_1;
    
#line 2821 
    __init_work(& efx->monitor_work.work,0);
    
#line 2821 
    atomic_long_t __constr_expr_38 = {.counter = WORK_STRUCT_NO_POOL_1};
    
#line 2821 
    efx->monitor_work.work.data = __constr_expr_38;
    
#line 2821 
    lockdep_init_map(& efx->monitor_work.work.lockdep_map,"(&(&efx->monitor_work)->work)",& __key_1,0);
    
#line 2821 
    INIT_LIST_HEAD(& efx->monitor_work.work.entry);
    
#line 2821 
    efx->monitor_work.work.func = & efx_monitor;
  }
  {
    struct lock_class_key __key_2;
    
#line 2821 
    init_timer_key(& efx->monitor_work.timer,2097152U,"(&(&efx->monitor_work)->timer)",& __key_2);
  }
  
#line 2821 
  efx->monitor_work.timer.function = & delayed_work_timer_fn;
  
#line 2821 
  efx->monitor_work.timer.data = (unsigned long)(& efx->monitor_work);
  {
    struct lock_class_key __key_3;
    
#line 2822 
    __init_work(& efx->selftest_work.work,0);
    
#line 2822 
    atomic_long_t __constr_expr_39 = {.counter = WORK_STRUCT_NO_POOL_1};
    
#line 2822 
    efx->selftest_work.work.data = __constr_expr_39;
    
#line 2822 
    lockdep_init_map(& efx->selftest_work.work.lockdep_map,"(&(&efx->selftest_work)->work)",& __key_3,0);
    
#line 2822 
    INIT_LIST_HEAD(& efx->selftest_work.work.entry);
    
#line 2822 
    efx->selftest_work.work.func = & efx_selftest_async_work;
  }
  {
    struct lock_class_key __key_4;
    
#line 2822 
    init_timer_key(& efx->selftest_work.timer,2097152U,"(&(&efx->selftest_work)->timer)",& __key_4);
  }
  
#line 2822 
  efx->selftest_work.timer.function = & delayed_work_timer_fn;
  
#line 2822 
  efx->selftest_work.timer.data = (unsigned long)(& efx->selftest_work);
  
#line 2823 
  efx->pci_dev = pci_dev;
  
#line 2824 
  efx->msg_enable = debug;
  
#line 2825 
  efx->state = STATE_UNINIT;
  
#line 2826 
  tmp = pci_name((struct pci_dev const *)pci_dev);
  
#line 2826 
  ;
  
#line 2826 
  strlcpy((char *)(& efx->name),tmp,16UL);
  
#line 2828 
  efx->net_dev = net_dev;
  
#line 2829 
  efx->rx_prefix_size = (efx->type)->rx_prefix_size;
  
#line 2830 
  efx->rx_ip_align = 0U;
  
#line 2832 
  efx->rx_packet_hash_offset = (int)((efx->type)->rx_hash_offset - (efx->type)->rx_prefix_size);
  
#line 2834 
  efx->rx_packet_ts_offset = (int)((efx->type)->rx_ts_offset - (efx->type)->rx_prefix_size);
  
#line 2836 
  spinlock_check(& efx->stats_lock);
  {
    struct lock_class_key __key_5;
    
#line 2836 
    __raw_spin_lock_init(& efx->stats_lock.__anonCompField_spinlock_18.rlock,"&(&efx->stats_lock)->rlock",& __key_5);
  }
  {
    struct lock_class_key __key_6;
    
#line 2837 
    __mutex_init(& efx->mac_lock,"&efx->mac_lock",& __key_6);
  }
  
#line 2838 
  efx->phy_op = & efx_dummy_phy_operations;
  
#line 2839 
  efx->mdio.dev = net_dev;
  {
    struct lock_class_key __key_7;
    
#line 2840 
    __init_work(& efx->mac_work,0);
    
#line 2840 
    atomic_long_t __constr_expr_40 = {.counter = WORK_STRUCT_NO_POOL_1};
    
#line 2840 
    efx->mac_work.data = __constr_expr_40;
    
#line 2840 
    lockdep_init_map(& efx->mac_work.lockdep_map,"(&efx->mac_work)",& __key_7,0);
    
#line 2840 
    INIT_LIST_HEAD(& efx->mac_work.entry);
    
#line 2840 
    efx->mac_work.func = & efx_mac_work;
  }
  {
    struct lock_class_key __key_8;
    
#line 2841 
    __init_waitqueue_head(& efx->flush_wq,"&efx->flush_wq",& __key_8);
  }
  
#line 2843 
  i = 0;
  
#line 2843 
  goto ldv_57939;
  ldv_57938: 
#line 2844 
  ;
  
#line 2844 
  efx->channel[i] = efx_alloc_channel(efx,i,(struct efx_channel *)0);
  
#line 2845 
  if (efx->channel[i] == (struct efx_channel *)0) 
#line 2846 
                                                  goto fail; else ;
  
#line 2847 
  efx->msi_context[i].efx = efx;
  
#line 2848 
  efx->msi_context[i].index = (unsigned int)i;
  
#line 2843 
  i += 1;
  ldv_57939: 
#line 2844 
  ;
  
#line 2843 
  if ((unsigned int)i <= 31U) 
#line 2845 
                              goto ldv_57938; else 
#line 2848 
                                                   goto ldv_57940;
  ldv_57940: 
#line 2849 
  ;
  {
    unsigned int tmp_0;
    
#line 2852 
    unsigned int const _max1 = (efx->type)->max_interrupt_mode;
    
#line 2852 
    unsigned int _max2 = interrupt_mode;
    
#line 2852 
    if (_max1 > _max2) 
#line 2852 
                       tmp_0 = _max1; else 
#line 2852 
                                           tmp_0 = _max2;
    
#line 2852 
    tmp_1 = tmp_0;
  }
  
#line 2852 
  efx->interrupt_mode = (enum efx_int_mode)tmp_1;
  
#line 2856 
  tmp_2 = pci_name((struct pci_dev const *)pci_dev);
  
#line 2856 
  ;
  
#line 2856 
  snprintf((char *)(& efx->workqueue_name),16UL,"sfc%s",tmp_2);
  {
    struct lock_class_key __key_9;
    char const *__lock_name;
    
#line 2858 
    __lock_name = "\"%s\"";
    
#line 2858 
    tmp_4 = __alloc_workqueue_key("%s",131082U,1,& __key_9,__lock_name,(char *)(& efx->workqueue_name));
  }
  
#line 2858 
  efx->workqueue = tmp_4;
  
#line 2859 
  if (efx->workqueue == (struct workqueue_struct *)0) 
#line 2860 
                                                      goto fail; else ;
  
#line 2862 
  __retres = 0;
  
#line 2862 
  goto return_label;
  fail: 
#line 2864 
  ;
  
#line 2865 
  efx_fini_struct(efx);
  
#line 2866 
  __retres = -12;
  return_label: 
#line 2866 
                return __retres;
}


#line 2869  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_fini_struct(struct efx_nic *efx)
{
  int i;
  
#line 2873 
  i = 0;
  
#line 2873 
  goto ldv_57952;
  ldv_57951: 
#line 2874 
  ;
  
#line 2874 
  kfree((void const *)efx->channel[i]);
  
#line 2873 
  i += 1;
  ldv_57952: 
#line 2874 
  ;
  
#line 2873 
  if ((unsigned int)i <= 31U) 
#line 2875 
                              goto ldv_57951; else 
#line 2878 
                                                   goto ldv_57953;
  ldv_57953: 
#line 2879 
  ;
  
#line 2876 
  kfree((void const *)efx->vpd_sn);
  
#line 2878 
  if (efx->workqueue != (struct workqueue_struct *)0) {
    
#line 2879 
    destroy_workqueue(efx->workqueue);
    
#line 2880 
    efx->workqueue = (struct workqueue_struct *)0;
  }
  else ;
  
#line 2882 
  return;
}


#line 2884  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
void efx_update_sw_stats(struct efx_nic *efx, u64 *stats)
{
  struct efx_channel *channel;
  int tmp;
  
#line 2886 
  u64 n_rx_nodesc_trunc = 0ULL;
  
#line 2889 
  channel = efx->channel[0];
  
#line 2889 
  goto ldv_57961;
  ldv_57960: 
#line 2890 
  ;
  
#line 2890 
  n_rx_nodesc_trunc = (unsigned long long)channel->n_rx_nodesc_trunc + n_rx_nodesc_trunc;
  
#line 2889 
  if ((unsigned int)(channel->channel + 1) < efx->n_channels) 
#line 2889 
                                                              channel = efx->channel[channel->channel + 1]; else 
                                                                    
#line 2889 
                                                                    channel = (struct efx_channel *)0;
  ldv_57961: 
#line 2890 
  ;
  
#line 2889 
  if (channel != (struct efx_channel *)0) 
#line 2891 
                                          goto ldv_57960; else 
#line 2894 
                                                               goto ldv_57962;
  ldv_57962: 
#line 2895 
  ;
  
#line 2891 
  *(stats + 1U) = n_rx_nodesc_trunc;
  
#line 2892 
  tmp = atomic_read((atomic_t const *)(& efx->n_rx_noskb_drops));
  
#line 2892 
  *stats = (unsigned long long)tmp;
  
#line 2893 
  return;
}


#line 2904  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_pci_remove_main(struct efx_nic *efx)
{
  
#line 2909 
  if ((long)(efx->state == (unsigned int)STATE_READY) != 0L) {
    
#line 2911 
    ldv_inline_asm();
    
#line 2909 
    ;
  }
  else ;
  
#line 2910 
  cancel_work_sync(& efx->reset_work);
  
#line 2912 
  efx_disable_interrupts(efx);
  
#line 2913 
  efx_nic_fini_interrupt(efx);
  
#line 2914 
  efx_fini_port(efx);
  
#line 2915 
  (*((efx->type)->fini))(efx);
  
#line 2916 
  efx_fini_napi(efx);
  
#line 2917 
  efx_remove_all(efx);
  
#line 2918 
  return;
}


#line 2924  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_pci_remove(struct pci_dev *pci_dev)
{
  struct efx_nic *efx;
  
#line 2928 
  efx = (struct efx_nic *)pci_get_drvdata(pci_dev);
  
#line 2929 
  if (efx == (struct efx_nic *)0) 
#line 2930 
                                  goto return_label; else ;
  
#line 2933 
  rtnl_lock();
  
#line 2934 
  efx_dissociate(efx);
  
#line 2935 
  dev_close(efx->net_dev);
  
#line 2936 
  efx_disable_interrupts(efx);
  
#line 2937 
  efx->state = STATE_UNINIT;
  
#line 2938 
  rtnl_unlock();
  
#line 2940 
  if ((efx->type)->sriov_fini != (void (*)(struct efx_nic *))0) 
#line 2941 
                                                                (*((efx->type)->sriov_fini))(efx); else ;
  
#line 2943 
  efx_unregister_netdev(efx);
  
#line 2945 
  efx_mtd_remove(efx);
  
#line 2947 
  efx_pci_remove_main(efx);
  
#line 2949 
  efx_fini_io(efx);
  
#line 2950 
  if ((efx->msg_enable & 1U) != 0U) {
    
#line 2950 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_pci_remove", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "shutdown successful\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2950U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 2950 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 2950 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"shutdown successful\n"); else ;
  }
  else ;
  
#line 2952 
  efx_fini_struct(efx);
  
#line 2953 
  ldv_free_netdev_127(efx->net_dev);
  
#line 2955 
  pci_disable_pcie_error_reporting(pci_dev);
  return_label: 
#line 2956 
                return;
}


#line 2964  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_probe_vpd_strings(struct efx_nic *efx)
{
  char vpd_data[512U];
  ssize_t vpd_size;
  int ro_start;
  int ro_size;
  int i;
  int j;
  u16 tmp;
  u8 tmp_0;
  u8 tmp_1;
  
#line 2966 
  struct pci_dev *dev = efx->pci_dev;
  
#line 2972 
  vpd_size = pci_read_vpd(dev,0LL,512UL,(void *)(& vpd_data));
  
#line 2973 
  if (vpd_size <= 0L) {
    
#line 2974 
    if ((efx->msg_enable & 1U) != 0U) 
#line 2974 
                                      netdev_err((struct net_device const *)efx->net_dev,"Unable to read VPD\n"); else ;
    
#line 2975 
    goto return_label;
  }
  else ;
  
#line 2979 
  ro_start = pci_vpd_find_tag((u8 const *)(& vpd_data),0U,(unsigned int)vpd_size,(unsigned char)144);
  
#line 2980 
  if (ro_start < 0) {
    
#line 2981 
    if ((efx->msg_enable & 1U) != 0U) 
#line 2981 
                                      netdev_err((struct net_device const *)efx->net_dev,"VPD Read-only not found\n"); else ;
    
#line 2982 
    goto return_label;
  }
  else ;
  
#line 2985 
  tmp = pci_vpd_lrdt_size((u8 const *)(& vpd_data[ro_start]));
  
#line 2985 
  ro_size = (int)tmp;
  
#line 2986 
  j = ro_size;
  
#line 2987 
  i = ro_start + 3;
  
#line 2988 
  if ((long)(i + j) > vpd_size) 
#line 2989 
                                j = (int)(vpd_size - (ssize_t)i); else ;
  
#line 2992 
  i = pci_vpd_find_info_keyword((u8 const *)(& vpd_data),(unsigned int)i,(unsigned int)j,"PN");
  
#line 2993 
  if (i < 0) {
    
#line 2994 
    if ((efx->msg_enable & 1U) != 0U) 
#line 2994 
                                      netdev_err((struct net_device const *)efx->net_dev,"Part number not found\n"); else ;
    
#line 2995 
    goto return_label;
  }
  else ;
  
#line 2998 
  tmp_0 = pci_vpd_info_field_size((u8 const *)(& vpd_data[i]));
  
#line 2998 
  j = (int)tmp_0;
  
#line 2999 
  i += 3;
  
#line 3000 
  if ((long)(i + j) > vpd_size) {
    
#line 3001 
    if ((efx->msg_enable & 1U) != 0U) 
#line 3001 
                                      netdev_err((struct net_device const *)efx->net_dev,"Incomplete part number\n"); else ;
    
#line 3002 
    goto return_label;
  }
  else ;
  
#line 3005 
  if ((efx->msg_enable & 1U) != 0U) 
#line 3005 
                                    netdev_info((struct net_device const *)efx->net_dev,"Part Number : %.*s\n",j,& vpd_data[i]); else ;
  
#line 3008 
  i = ro_start + 3;
  
#line 3009 
  j = ro_size;
  
#line 3010 
  i = pci_vpd_find_info_keyword((u8 const *)(& vpd_data),(unsigned int)i,(unsigned int)j,"SN");
  
#line 3011 
  if (i < 0) {
    
#line 3012 
    if ((efx->msg_enable & 1U) != 0U) 
#line 3012 
                                      netdev_err((struct net_device const *)efx->net_dev,"Serial number not found\n"); else ;
    
#line 3013 
    goto return_label;
  }
  else ;
  
#line 3016 
  tmp_1 = pci_vpd_info_field_size((u8 const *)(& vpd_data[i]));
  
#line 3016 
  j = (int)tmp_1;
  
#line 3017 
  i += 3;
  
#line 3018 
  if ((long)(i + j) > vpd_size) {
    
#line 3019 
    if ((efx->msg_enable & 1U) != 0U) 
#line 3019 
                                      netdev_err((struct net_device const *)efx->net_dev,"Incomplete serial number\n"); else ;
    
#line 3020 
    goto return_label;
  }
  else ;
  
#line 3023 
  efx->vpd_sn = (char *)kmalloc_4((unsigned long)(j + 1),208U);
  
#line 3024 
  if (efx->vpd_sn == (char *)0) 
#line 3025 
                                goto return_label; else ;
  
#line 3027 
  snprintf(efx->vpd_sn,(unsigned long)(j + 1),"%s",& vpd_data[i]);
  return_label: 
#line 3028 
                return;
}


#line 3034  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_pci_probe_main(struct efx_nic *efx)
{
  int __retres;
  int rc;
  
#line 3039 
  rc = efx_probe_all(efx);
  
#line 3040 
  if (rc != 0) 
#line 3041 
               goto fail1; else ;
  
#line 3043 
  efx_init_napi(efx);
  
#line 3045 
  rc = (*((efx->type)->init))(efx);
  
#line 3046 
  if (rc != 0) {
    
#line 3047 
    if ((efx->msg_enable & 2U) != 0U) 
#line 3047 
                                      netdev_err((struct net_device const *)efx->net_dev,"failed to initialise NIC\n"); else ;
    
#line 3049 
    goto fail3;
  }
  else ;
  
#line 3052 
  rc = efx_init_port(efx);
  
#line 3053 
  if (rc != 0) {
    
#line 3054 
    if ((efx->msg_enable & 2U) != 0U) 
#line 3054 
                                      netdev_err((struct net_device const *)efx->net_dev,"failed to initialise port\n"); else ;
    
#line 3056 
    goto fail4;
  }
  else ;
  
#line 3059 
  rc = efx_nic_init_interrupt(efx);
  
#line 3060 
  if (rc != 0) 
#line 3061 
               goto fail5; else ;
  
#line 3062 
  rc = efx_enable_interrupts(efx);
  
#line 3063 
  if (rc != 0) 
#line 3064 
               goto fail6; else ;
  
#line 3066 
  __retres = 0;
  
#line 3066 
  goto return_label;
  fail6: 
#line 3068 
  ;
  
#line 3069 
  efx_nic_fini_interrupt(efx);
  fail5: 
#line 3070 
  ;
  
#line 3071 
  efx_fini_port(efx);
  fail4: 
#line 3072 
  ;
  
#line 3073 
  (*((efx->type)->fini))(efx);
  fail3: 
#line 3074 
  ;
  
#line 3075 
  efx_fini_napi(efx);
  
#line 3076 
  efx_remove_all(efx);
  fail1: 
#line 3077 
  ;
  
#line 3078 
  __retres = rc;
  return_label: 
#line 3078 
                return __retres;
}


#line 3090  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_pci_probe(struct pci_dev *pci_dev, struct pci_device_id const *entry)
{
  int __retres;
  struct net_device *net_dev;
  struct efx_nic *efx;
  int rc;
  
#line 3098 
  net_dev = ldv_alloc_etherdev_mqs_128(4032,64U,32U);
  
#line 3100 
  if (net_dev == (struct net_device *)0) {
    
#line 3101 
    __retres = -12;
    
#line 3101 
    goto return_label;
  }
  else ;
  
#line 3102 
  efx = (struct efx_nic *)netdev_priv((struct net_device const *)net_dev);
  
#line 3103 
  efx->type = (struct efx_nic_type const *)entry->driver_data;
  
#line 3104 
  net_dev->features = (net_dev->features | (efx->type)->offload_features) | 17179934753ULL;
  
#line 3107 
  if (((efx->type)->offload_features & 24ULL) != 0ULL) 
#line 3108 
                                                       net_dev->features |= 1048576ULL; else ;
  
#line 3110 
  net_dev->vlan_features |= 17181507643ULL;
  
#line 3114 
  net_dev->hw_features = net_dev->features & 18446744073709551583ULL;
  
#line 3115 
  pci_set_drvdata(pci_dev,(void *)efx);
  
#line 3116 
  net_dev->dev.parent = & pci_dev->dev;
  
#line 3117 
  rc = efx_init_struct(efx,pci_dev,net_dev);
  
#line 3118 
  if (rc != 0) 
#line 3119 
               goto fail1; else ;
  
#line 3121 
  if ((efx->msg_enable & 2U) != 0U) 
#line 3121 
                                    netdev_info((struct net_device const *)efx->net_dev,"Solarflare NIC detected\n"); else ;
  
#line 3124 
  if (! (efx->type)->is_vf) 
#line 3125 
                            efx_probe_vpd_strings(efx); else ;
  
#line 3128 
  rc = efx_init_io(efx);
  
#line 3129 
  if (rc != 0) 
#line 3130 
               goto fail2; else ;
  
#line 3132 
  rc = efx_pci_probe_main(efx);
  
#line 3133 
  if (rc != 0) 
#line 3134 
               goto fail3; else ;
  
#line 3136 
  rc = efx_register_netdev(efx);
  
#line 3137 
  if (rc != 0) 
#line 3138 
               goto fail4; else ;
  
#line 3140 
  if ((efx->type)->sriov_init != (int (*)(struct efx_nic *))0) {
    
#line 3141 
    rc = (*((efx->type)->sriov_init))(efx);
    
#line 3142 
    if (rc != 0) {
      
#line 3143 
      if ((efx->msg_enable & 2U) != 0U) 
#line 3143 
                                        netdev_err((struct net_device const *)efx->net_dev,"SR-IOV can\'t be enabled rc %d\n",rc); else ;
    }
    else ;
  }
  else ;
  
#line 3147 
  if ((efx->msg_enable & 2U) != 0U) {
    
#line 3147 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_pci_probe", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "initialisation successful\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3147U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 3147 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 3147 
                                                        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"initialisation successful\n"); else ;
  }
  else ;
  
#line 3150 
  rtnl_lock();
  
#line 3151 
  rc = efx_mtd_probe(efx);
  
#line 3152 
  rtnl_unlock();
  
#line 3153 
  if (rc != 0) {
    
#line 3154 
    if ((efx->msg_enable & 2U) != 0U) 
#line 3154 
                                      netdev_warn((struct net_device const *)efx->net_dev,"failed to create MTDs (%d)\n",rc); else ;
  }
  else ;
  
#line 3157 
  rc = pci_enable_pcie_error_reporting(pci_dev);
  
#line 3158 
  if (rc != 0 && rc != -22) {
    
#line 3159 
    if ((efx->msg_enable & 2U) != 0U) 
#line 3159 
                                      netdev_warn((struct net_device const *)efx->net_dev,"pci_enable_pcie_error_reporting failed (%d)\n",rc); else ;
  }
  else ;
  
#line 3162 
  __retres = 0;
  
#line 3162 
  goto return_label;
  fail4: 
#line 3164 
  ;
  
#line 3165 
  efx_pci_remove_main(efx);
  fail3: 
#line 3166 
  ;
  
#line 3167 
  efx_fini_io(efx);
  fail2: 
#line 3168 
  ;
  
#line 3169 
  efx_fini_struct(efx);
  fail1: 
#line 3170 
  ;
  {
    
#line 3171 
    int __ret_warn_on = rc > 0;
    
#line 3171 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 3171 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c",3171); else ;
    
#line 3171 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 3172 
  if ((efx->msg_enable & 1U) != 0U) {
    
#line 3172 
    struct _ddebug descriptor_0 = {.modname = "sfc", .function = "efx_pci_probe", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "initialisation failed. rc=%d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3172U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 3172 
    if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 3172 
                                                          __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)efx->net_dev,"initialisation failed. rc=%d\n",rc); else ;
  }
  else ;
  
#line 3173 
  ldv_free_netdev_129(net_dev);
  
#line 3174 
  __retres = rc;
  return_label: 
#line 3174 
                return __retres;
}


#line 3181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_pci_sriov_configure(struct pci_dev *dev, int num_vfs)
{
  int __retres;
  int rc;
  
#line 3184 
  struct efx_nic *efx = pci_get_drvdata(dev);
  
#line 3186 
  if ((efx->type)->sriov_configure != (int (*)(struct efx_nic *, int ))0) {
    
#line 3187 
    rc = (*((efx->type)->sriov_configure))(efx,num_vfs);
    
#line 3188 
    if (rc != 0) {
      
#line 3189 
      __retres = rc;
      
#line 3189 
      goto return_label;
    }
    else {
      
#line 3191 
      __retres = num_vfs;
      
#line 3191 
      goto return_label;
    }
  }
  else {
    
#line 3193 
    __retres = -95;
    
#line 3193 
    goto return_label;
  }
  return_label: 
#line 3186 
                return __retres;
}


#line 3197  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_pm_freeze(struct device *dev)
{
  int __retres;
  struct efx_nic *tmp_0;
  struct pci_dev *tmp;
  {
    
#line 3199 
    struct device const *__mptr = (struct device const *)dev;
    
#line 3199 
    tmp = (struct pci_dev *)__mptr + 18446744073709551464U;
  }
  
#line 3199 
  tmp_0 = (struct efx_nic *)pci_get_drvdata(tmp);
  
#line 3199 
  struct efx_nic *efx = tmp_0;
  
#line 3201 
  rtnl_lock();
  
#line 3203 
  if (efx->state != (unsigned int)STATE_DISABLED) {
    
#line 3204 
    efx->state = STATE_UNINIT;
    
#line 3206 
    efx_device_detach_sync_2(efx);
    
#line 3208 
    efx_stop_all(efx);
    
#line 3209 
    efx_disable_interrupts(efx);
  }
  else ;
  
#line 3212 
  rtnl_unlock();
  
#line 3214 
  __retres = 0;
  
#line 3214 
  return __retres;
}


#line 3217  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_pm_thaw(struct device *dev)
{
  int __retres;
  int rc;
  struct efx_nic *tmp_0;
  struct pci_dev *tmp;
  {
    
#line 3220 
    struct device const *__mptr = (struct device const *)dev;
    
#line 3220 
    tmp = (struct pci_dev *)__mptr + 18446744073709551464U;
  }
  
#line 3220 
  tmp_0 = (struct efx_nic *)pci_get_drvdata(tmp);
  
#line 3220 
  struct efx_nic *efx = tmp_0;
  
#line 3222 
  rtnl_lock();
  
#line 3224 
  if (efx->state != (unsigned int)STATE_DISABLED) {
    
#line 3225 
    rc = efx_enable_interrupts(efx);
    
#line 3226 
    if (rc != 0) 
#line 3227 
                 goto fail; else ;
    
#line 3229 
    ldv_mutex_lock_130(& efx->mac_lock);
    
#line 3230 
    (*((efx->phy_op)->reconfigure))(efx);
    
#line 3231 
    ldv_mutex_unlock_131(& efx->mac_lock);
    
#line 3233 
    efx_start_all(efx);
    
#line 3235 
    netif_device_attach(efx->net_dev);
    
#line 3237 
    efx->state = STATE_READY;
    
#line 3239 
    (*((efx->type)->resume_wol))(efx);
  }
  else ;
  
#line 3242 
  rtnl_unlock();
  
#line 3245 
  ldv_queue_work_132(reset_workqueue,& efx->reset_work);
  
#line 3247 
  __retres = 0;
  
#line 3247 
  goto return_label;
  fail: 
#line 3249 
  ;
  
#line 3250 
  rtnl_unlock();
  
#line 3252 
  __retres = rc;
  return_label: 
#line 3252 
                return __retres;
}


#line 3255  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_pm_poweroff(struct device *dev)
{
  struct pci_dev *tmp;
  int tmp_1;
  {
    
#line 3257 
    struct device const *__mptr = (struct device const *)dev;
    
#line 3257 
    tmp = (struct pci_dev *)__mptr + 18446744073709551464U;
  }
  
#line 3257 
  struct pci_dev *pci_dev = tmp;
  
#line 3258 
  struct efx_nic *efx = pci_get_drvdata(pci_dev);
  
#line 3260 
  (*((efx->type)->fini))(efx);
  
#line 3262 
  efx->reset_pending = 0UL;
  
#line 3264 
  pci_save_state(pci_dev);
  
#line 3265 
  tmp_1 = pci_set_power_state(pci_dev,3);
  
#line 3265 
  return tmp_1;
}


#line 3269  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_pm_resume(struct device *dev)
{
  int __retres;
  struct pci_dev *tmp;
  int rc;
  {
    
#line 3271 
    struct device const *__mptr = (struct device const *)dev;
    
#line 3271 
    tmp = (struct pci_dev *)__mptr + 18446744073709551464U;
  }
  
#line 3271 
  struct pci_dev *pci_dev = tmp;
  
#line 3272 
  struct efx_nic *efx = pci_get_drvdata(pci_dev);
  
#line 3275 
  rc = pci_set_power_state(pci_dev,0);
  
#line 3276 
  if (rc != 0) {
    
#line 3277 
    __retres = rc;
    
#line 3277 
    goto return_label;
  }
  else ;
  
#line 3278 
  pci_restore_state(pci_dev);
  
#line 3279 
  rc = pci_enable_device(pci_dev);
  
#line 3280 
  if (rc != 0) {
    
#line 3281 
    __retres = rc;
    
#line 3281 
    goto return_label;
  }
  else ;
  
#line 3282 
  pci_set_master(efx->pci_dev);
  
#line 3283 
  rc = (*((efx->type)->reset))(efx,(enum reset_type)RESET_TYPE_ALL);
  
#line 3284 
  if (rc != 0) {
    
#line 3285 
    __retres = rc;
    
#line 3285 
    goto return_label;
  }
  else ;
  
#line 3286 
  rc = (*((efx->type)->init))(efx);
  
#line 3287 
  if (rc != 0) {
    
#line 3288 
    __retres = rc;
    
#line 3288 
    goto return_label;
  }
  else ;
  
#line 3289 
  rc = efx_pm_thaw(dev);
  
#line 3290 
  __retres = rc;
  return_label: 
#line 3290 
                return __retres;
}


#line 3293  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_pm_suspend(struct device *dev)
{
  int rc;
  
#line 3297 
  efx_pm_freeze(dev);
  
#line 3298 
  rc = efx_pm_poweroff(dev);
  
#line 3299 
  if (rc != 0) 
#line 3300 
               efx_pm_resume(dev); else ;
  
#line 3301 
  return rc;
}


#line 3304  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static struct dev_pm_ops const efx_pm_ops = {.prepare = (int (*)(struct device *))0, .complete = (void (*)(struct device *))0, .suspend = & efx_pm_suspend, .resume = & efx_pm_resume, .freeze = & efx_pm_freeze, .thaw = & efx_pm_thaw, .poweroff = & efx_pm_poweroff, .restore = & efx_pm_resume, .suspend_late = (int (*)(struct device *))0, .resume_early = (int (*)(struct device *))0, .freeze_late = (int (*)(struct device *))0, .thaw_early = (int (*)(struct device *))0, .poweroff_late = (int (*)(struct device *))0, .restore_early = (int (*)(struct device *))0, .suspend_noirq = (int (*)(struct device *))0, .resume_noirq = (int (*)(struct device *))0, .freeze_noirq = (int (*)(struct device *))0, .thaw_noirq = (int (*)(struct device *))0, .poweroff_noirq = (int (*)(struct device *))0, .restore_noirq = (int (*)(struct device *))0, .runtime_suspend = (int (*)(struct device *))0, .runtime_resume = (int (*)(struct device *))0, .runtime_idle = (int (*)(struct device *))0};

#line 3317  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static pci_ers_result_t efx_io_error_detected(struct pci_dev *pdev, enum pci_channel_state state)
{
  pci_ers_result_t __retres;
  
#line 3320 
  pci_ers_result_t status = 5U;
  
#line 3321 
  struct efx_nic *efx = pci_get_drvdata(pdev);
  
#line 3323 
  if (state == (unsigned int)pci_channel_io_perm_failure) {
    
#line 3324 
    __retres = 4U;
    
#line 3324 
    goto return_label;
  }
  else ;
  
#line 3326 
  rtnl_lock();
  
#line 3328 
  if (efx->state != (unsigned int)STATE_DISABLED) {
    
#line 3329 
    efx->state = STATE_RECOVERY;
    
#line 3330 
    efx->reset_pending = 0UL;
    
#line 3332 
    efx_device_detach_sync_2(efx);
    
#line 3334 
    efx_stop_all(efx);
    
#line 3335 
    efx_disable_interrupts(efx);
    
#line 3337 
    status = 3U;
  }
  else 
#line 3342 
       status = 5U;
  
#line 3345 
  rtnl_unlock();
  
#line 3347 
  pci_disable_device(pdev);
  
#line 3349 
  __retres = status;
  return_label: 
#line 3349 
                return __retres;
}


#line 3353  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static pci_ers_result_t efx_io_slot_reset(struct pci_dev *pdev)
{
  int rc;
  int tmp_0;
  
#line 3355 
  struct efx_nic *efx = pci_get_drvdata(pdev);
  
#line 3356 
  pci_ers_result_t status = 5U;
  
#line 3359 
  tmp_0 = pci_enable_device(pdev);
  
#line 3359 
  if (tmp_0 != 0) {
    
#line 3360 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 3360 
                                         netdev_err((struct net_device const *)efx->net_dev,"Cannot re-enable PCI device after reset.\n"); else ;
    
#line 3362 
    status = 4U;
  }
  else ;
  
#line 3365 
  rc = pci_cleanup_aer_uncorrect_error_status(pdev);
  
#line 3366 
  if (rc != 0) {
    
#line 3367 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 3367 
                                         netdev_err((struct net_device const *)efx->net_dev,"pci_cleanup_aer_uncorrect_error_status failed (%d)\n",rc); else ;
  }
  else ;
  
#line 3372 
  return status;
}


#line 3376  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_io_resume(struct pci_dev *pdev)
{
  int rc;
  
#line 3378 
  struct efx_nic *efx = pci_get_drvdata(pdev);
  
#line 3381 
  rtnl_lock();
  
#line 3383 
  if (efx->state == (unsigned int)STATE_DISABLED) 
#line 3384 
                                                  goto out; else ;
  
#line 3386 
  rc = efx_reset(efx,(enum reset_type)RESET_TYPE_ALL);
  
#line 3387 
  if (rc != 0) {
    
#line 3388 
    if ((efx->msg_enable & 8192U) != 0U) 
#line 3388 
                                         netdev_err((struct net_device const *)efx->net_dev,"efx_reset failed after PCI error (%d)\n",rc); else ;
  }
  else {
    
#line 3391 
    efx->state = STATE_READY;
    
#line 3392 
    if ((efx->msg_enable & 8192U) != 0U) {
      
#line 3392 
      struct _ddebug descriptor = {.modname = "sfc", .function = "efx_io_resume", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c", .format = "Done resetting and resuming IO after PCI error.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3393U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 3392 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 3392 
                                                          __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"Done resetting and resuming IO after PCI error.\n"); else ;
    }
    else ;
  }
  out: 
#line 3396 
  ;
  
#line 3397 
  rtnl_unlock();
  
#line 3398 
  return;
}


#line 3406  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static struct pci_error_handlers efx_err_handlers = {.error_detected = & efx_io_error_detected, .mmio_enabled = (pci_ers_result_t (*)(struct pci_dev *))0, .link_reset = (pci_ers_result_t (*)(struct pci_dev *))0, .slot_reset = & efx_io_slot_reset, .reset_notify = (void (*)(struct pci_dev *, bool ))0, .resume = & efx_io_resume};

#line 3412  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static struct pci_driver efx_pci_driver = {.node = {.next = (struct list_head *)0, .prev = (struct list_head *)0}, .name = "sfc", .id_table = (struct pci_device_id const *)(& efx_pci_table), .probe = & efx_pci_probe, .remove = & efx_pci_remove, .suspend = (int (*)(struct pci_dev *, pm_message_t ))0, .suspend_late = (int (*)(struct pci_dev *, pm_message_t ))0, .resume_early = (int (*)(struct pci_dev *))0, .resume = (int (*)(struct pci_dev *))0, .shutdown = (void (*)(struct pci_dev *))0, .sriov_configure = & efx_pci_sriov_configure, .err_handler = (struct pci_error_handlers const *)(& efx_err_handlers), .driver = {.name = (char const *)0, .bus = (struct bus_type *)0, .owner = (struct module *)0, .mod_name = (char const *)0, .suppress_bind_attrs = (_Bool)0, .probe_type = 0, .of_match_table = (struct of_device_id const *)0, .acpi_match_table = (struct acpi_device_id const *)0, .probe = (int (*)(struct device *))0, .remove = (int (*)(struct device *))0, .shutdown = (void (*)(struct device *))0, .suspend = (int (*)(struct device *, pm_message_t ))0, .resume = (int (*)(struct device *))0, .groups = (struct attribute_group const **)0, .pm = & efx_pm_ops, .p = (struct driver_private *)0}, .dynids = {.lock = {.__anonCompField_spinlock_18 = {.rlock = {.raw_lock = {.val = {.counter = 0}}, .magic = 0U, .owner_cpu = 0U, .owner = (void *)0, .dep_map = {.key = (struct lock_class_key *)0, .class_cache = {(struct lock_class *)0, (struct lock_class *)0}, .name = (char const *)0, .cpu = 0, .ip = 0UL}}}}, .list = {.next = (struct list_head *)0, .prev = (struct list_head *)0}}};

#line 3434  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static int efx_init_module(void)
{
  int __retres;
  int rc;
  struct workqueue_struct *tmp_0;
  
#line 3438 
  printk("\001");
  
#line 3440 
  rc = register_netdevice_notifier(& efx_netdev_notifier);
  
#line 3441 
  if (rc != 0) 
#line 3442 
               goto err_notifier; else ;
  
#line 3445 
  rc = efx_init_sriov();
  
#line 3446 
  if (rc != 0) 
#line 3447 
               goto err_sriov; else ;
  {
    struct lock_class_key __key;
    char const *__lock_name;
    
#line 3450 
    __lock_name = "\"%s\"";
    
#line 3450 
    tmp_0 = __alloc_workqueue_key("%s",131082U,1,& __key,__lock_name,(char *)"sfc_reset");
  }
  
#line 3450 
  reset_workqueue = tmp_0;
  
#line 3451 
  if (reset_workqueue == (struct workqueue_struct *)0) {
    
#line 3452 
    rc = -12;
    
#line 3453 
    goto err_reset;
  }
  else ;
  
#line 3456 
  rc = ldv___pci_register_driver_133(& efx_pci_driver,& __this_module,"sfc");
  
#line 3457 
  if (rc < 0) 
#line 3458 
              goto err_pci; else ;
  
#line 3460 
  __retres = 0;
  
#line 3460 
  goto return_label;
  err_pci: 
#line 3462 
  ;
  
#line 3463 
  destroy_workqueue(reset_workqueue);
  err_reset: 
#line 3464 
  ;
  
#line 3466 
  efx_fini_sriov();
  err_sriov: 
#line 3467 
  ;
  
#line 3469 
  unregister_netdevice_notifier(& efx_netdev_notifier);
  err_notifier: 
#line 3470 
  ;
  
#line 3471 
  __retres = rc;
  return_label: 
#line 3471 
                return __retres;
}


#line 3474  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
static void efx_exit_module(void)
{
  
#line 3476 
  printk("\001");
  
#line 3478 
  ldv_pci_unregister_driver_134(& efx_pci_driver);
  
#line 3479 
  destroy_workqueue(reset_workqueue);
  
#line 3481 
  efx_fini_sriov();
  
#line 3483 
  unregister_netdevice_notifier(& efx_netdev_notifier);
  
#line 3484 
  return;
}


#line 3494  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/efx.c"
struct pci_device_id const __mod_pci__efx_pci_table_device_table[8U];

#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
struct pci_driver *ldv_emg_alias_efx_pci_driver_2 = & efx_pci_driver;

#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
struct dev_pm_ops *ldv_emg_alias_efx_pm_ops_4 = (struct dev_pm_ops *)(& efx_pm_ops);

#line 58  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
struct device_attribute *ldv_emg_alias_dev_attr_mcdi_logging_3 = & dev_attr_mcdi_logging;

#line 59  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
struct device_attribute *ldv_emg_alias_dev_attr_phy_type_3 = & dev_attr_phy_type;

#line 65 
int ldv_emg___pci_register_driver(struct pci_driver *arg0, struct module *arg1, char *arg2);


#line 67 
void ldv_emg_pci_unregister_driver(struct pci_driver *arg0);


#line 69 
struct net_device *ldv_emg_alloc_etherdev_mqs(int arg0, unsigned int arg1, unsigned int arg2);


#line 70 
void ldv_emg_unregister_netdev(struct net_device *arg0);


#line 72 
_Bool ldv_emg_queue_delayed_work(struct workqueue_struct *arg0, struct delayed_work *arg1, unsigned long arg2);


#line 74 
void ldv_emg_free_netdev(struct net_device *arg0);


#line 79  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
int ldv_emg_wrapper_efx_pm_poweroff_2(struct device *arg0)
{
  int tmp;
  
#line 80 
  tmp = efx_pm_poweroff(arg0);
  
#line 80 
  return tmp;
}


#line 84  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
int ldv_emg_wrapper_efx_pm_freeze_3(struct device *arg0)
{
  int tmp;
  
#line 85 
  tmp = efx_pm_freeze(arg0);
  
#line 85 
  return tmp;
}


#line 89  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
int ldv_emg_wrapper_efx_pm_resume_6(struct device *arg0)
{
  int tmp;
  
#line 90 
  tmp = efx_pm_resume(arg0);
  
#line 90 
  return tmp;
}


#line 94  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
long ldv_emg_wrapper_show_phy_type_2(struct device *arg0, struct device_attribute *arg1, char *arg2)
{
  long tmp;
  
#line 95 
  tmp = show_phy_type(arg0,arg1,arg2);
  
#line 95 
  return tmp;
}


#line 99  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
long ldv_emg_wrapper_set_mcdi_log_4(struct device *arg0, struct device_attribute *arg1, char *arg2, unsigned long arg3)
{
  long tmp;
  
#line 100 
  tmp = set_mcdi_log(arg0,arg1,(char const *)arg2,arg3);
  
#line 100 
  return tmp;
}


#line 104  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
int ldv_emg_wrapper_efx_pm_thaw_7(struct device *arg0)
{
  int tmp;
  
#line 105 
  tmp = efx_pm_thaw(arg0);
  
#line 105 
  return tmp;
}


#line 109  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
void ldv_emg_efx_exit_module(void)
{
  
#line 110 
  efx_exit_module();
  
#line 111 
  return;
}


#line 113  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
int ldv_emg_wrapper_efx_pci_probe_3(struct pci_dev *arg0, struct pci_device_id *arg1)
{
  int tmp;
  
#line 114 
  tmp = efx_pci_probe(arg0,(struct pci_device_id const *)arg1);
  
#line 114 
  return tmp;
}


#line 118  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
int ldv_emg_efx_init_module(void)
{
  int tmp;
  
#line 119 
  tmp = efx_init_module();
  
#line 119 
  return tmp;
}


#line 122  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
int ldv_emg_wrapper_efx_pm_suspend_5(struct device *arg0)
{
  int tmp;
  
#line 123 
  tmp = efx_pm_suspend(arg0);
  
#line 123 
  return tmp;
}


#line 127  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
int ldv_emg_wrapper_efx_pci_sriov_configure_2(struct pci_dev *arg0, int arg1)
{
  int tmp;
  
#line 128 
  tmp = efx_pci_sriov_configure(arg0,arg1);
  
#line 128 
  return tmp;
}


#line 132  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
long ldv_emg_wrapper_show_mcdi_log_2(struct device *arg0, struct device_attribute *arg1, char *arg2)
{
  long tmp;
  
#line 133 
  tmp = show_mcdi_log(arg0,arg1,arg2);
  
#line 133 
  return tmp;
}


#line 137  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
void ldv_emg_wrapper_efx_pci_remove_4(struct pci_dev *arg0)
{
  
#line 138 
  efx_pci_remove(arg0);
  
#line 139 
  return;
}


#line 196  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void atomic_inc_4(atomic_t *v)
{
  
#line 199 
  ldv_atomic_inc(v);
  
#line 200 
  return;
}


#line 562  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void *kmalloc_4(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 565 
  tmp = ldv_kmalloc(size,flags);
  
#line 565 
  return tmp;
}


#line 576  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void *kcalloc_9(size_t n, size_t size, gfp_t flags)
{
  void *tmp;
  
#line 579 
  tmp = ldv_kcalloc(n,size,flags);
  
#line 579 
  return tmp;
}


#line 583  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void *kzalloc_10(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 586 
  tmp = ldv_kzalloc(size,flags);
  
#line 586 
  return tmp;
}


#line 696  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_spin_lock_62_3(spinlock_t *lock)
{
  
#line 700 
  ldv_spin_model_lock((char *)"_xmit_lock_of_netdev_queue");
  
#line 702 
  spin_lock_5(lock);
  
#line 703 
  return;
}


#line 739  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_spin_unlock_65_3(spinlock_t *lock)
{
  
#line 743 
  ldv_spin_model_unlock((char *)"_xmit_lock_of_netdev_queue");
  
#line 745 
  spin_unlock_5(lock);
  
#line 746 
  return;
}


#line 759  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_spin_lock_67_3(spinlock_t *lock)
{
  
#line 763 
  ldv_spin_model_lock((char *)"tx_global_lock_of_net_device");
  
#line 765 
  spin_lock_5(lock);
  
#line 766 
  return;
}


#line 769  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_spin_unlock_68_3(spinlock_t *lock)
{
  
#line 773 
  ldv_spin_model_unlock((char *)"tx_global_lock_of_net_device");
  
#line 775 
  spin_unlock_5(lock);
  
#line 776 
  return;
}


#line 799  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_spin_lock_bh_71_1(spinlock_t *lock)
{
  
#line 803 
  ldv_spin_model_lock((char *)"addr_list_lock_of_net_device");
  
#line 805 
  spin_lock_bh_5(lock);
  
#line 806 
  return;
}


#line 819  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_spin_unlock_bh_73_1(spinlock_t *lock)
{
  
#line 823 
  ldv_spin_model_unlock((char *)"addr_list_lock_of_net_device");
  
#line 825 
  spin_unlock_bh_6(lock);
  
#line 826 
  return;
}


#line 839  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_spin_lock_bh_75(spinlock_t *lock)
{
  
#line 843 
  ldv_spin_model_lock((char *)"state_lock_of_efx_channel");
  
#line 845 
  spin_lock_bh_5(lock);
  
#line 846 
  return;
}


#line 849  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_spin_unlock_bh_76(spinlock_t *lock)
{
  
#line 853 
  ldv_spin_model_unlock((char *)"state_lock_of_efx_channel");
  
#line 855 
  spin_unlock_bh_6(lock);
  
#line 856 
  return;
}


#line 859  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_spin_lock_bh_77(spinlock_t *lock)
{
  
#line 863 
  ldv_spin_model_lock((char *)"state_lock_of_efx_channel");
  
#line 865 
  spin_lock_bh_5(lock);
  
#line 866 
  return;
}


#line 869  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_spin_unlock_bh_78(spinlock_t *lock)
{
  
#line 873 
  ldv_spin_model_unlock((char *)"state_lock_of_efx_channel");
  
#line 875 
  spin_unlock_bh_6(lock);
  
#line 876 
  return;
}


#line 879  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_spin_lock_bh_79(spinlock_t *lock)
{
  
#line 883 
  ldv_spin_model_lock((char *)"state_lock_of_efx_channel");
  
#line 885 
  spin_lock_bh_5(lock);
  
#line 886 
  return;
}


#line 889  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_spin_unlock_bh_80(spinlock_t *lock)
{
  
#line 893 
  ldv_spin_model_unlock((char *)"state_lock_of_efx_channel");
  
#line 895 
  spin_unlock_bh_6(lock);
  
#line 896 
  return;
}


#line 899  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_spin_lock_bh_81(spinlock_t *lock)
{
  
#line 903 
  ldv_spin_model_lock((char *)"state_lock_of_efx_channel");
  
#line 905 
  spin_lock_bh_5(lock);
  
#line 906 
  return;
}


#line 909  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_spin_unlock_bh_82(spinlock_t *lock)
{
  
#line 913 
  ldv_spin_model_unlock((char *)"state_lock_of_efx_channel");
  
#line 915 
  spin_unlock_bh_6(lock);
  
#line 916 
  return;
}


#line 919  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_spin_lock_bh_83(spinlock_t *lock)
{
  
#line 923 
  ldv_spin_model_lock((char *)"state_lock_of_efx_channel");
  
#line 925 
  spin_lock_bh_5(lock);
  
#line 926 
  return;
}


#line 929  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_spin_unlock_bh_84(spinlock_t *lock)
{
  
#line 933 
  ldv_spin_model_unlock((char *)"state_lock_of_efx_channel");
  
#line 935 
  spin_unlock_bh_6(lock);
  
#line 936 
  return;
}


#line 939  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_spin_lock_bh_85(spinlock_t *lock)
{
  
#line 943 
  ldv_spin_model_lock((char *)"state_lock_of_efx_channel");
  
#line 945 
  spin_lock_bh_5(lock);
  
#line 946 
  return;
}


#line 949  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_spin_unlock_bh_86(spinlock_t *lock)
{
  
#line 953 
  ldv_spin_model_unlock((char *)"state_lock_of_efx_channel");
  
#line 955 
  spin_unlock_bh_6(lock);
  
#line 956 
  return;
}


#line 959  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static int ldv_mod_timer_87(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2)
{
  int tmp;
  
#line 963 
  tmp = ldv_emg_mod_timer(ldv_func_arg1,ldv_func_arg2);
  
#line 963 
  return tmp;
}


#line 967  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static int ldv_mutex_is_locked_88(struct mutex *lock)
{
  int tmp;
  
#line 970 
  tmp = ldv_mutex_model_is_locked(lock,(char *)"mac_lock_of_efx_nic");
  
#line 970 
  return tmp;
}


#line 974  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_mutex_lock_89_1(struct mutex *ldv_func_arg1)
{
  
#line 978 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 979 
  return;
}


#line 982  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_mutex_unlock_90_1(struct mutex *ldv_func_arg1)
{
  
#line 986 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 987 
  return;
}


#line 990  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_mutex_lock_91_0(struct mutex *ldv_func_arg1)
{
  
#line 994 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 995 
  return;
}


#line 998  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_mutex_unlock_92_0(struct mutex *ldv_func_arg1)
{
  
#line 1002 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 1003 
  return;
}


#line 1006  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_mutex_lock_93_1(struct mutex *ldv_func_arg1)
{
  
#line 1010 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 1011 
  return;
}


#line 1014  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_mutex_unlock_94_1(struct mutex *ldv_func_arg1)
{
  
#line 1018 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 1019 
  return;
}


#line 1022  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_mutex_unlock_95(struct mutex *ldv_func_arg1)
{
  
#line 1026 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 1027 
  return;
}


#line 1030  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_mutex_lock_96(struct mutex *ldv_func_arg1)
{
  
#line 1034 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 1035 
  return;
}


#line 1038  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_mutex_unlock_97(struct mutex *ldv_func_arg1)
{
  
#line 1042 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 1043 
  return;
}


#line 1046  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_mutex_lock_98(struct mutex *ldv_func_arg1)
{
  
#line 1050 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 1051 
  return;
}


#line 1054  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_mutex_unlock_99(struct mutex *ldv_func_arg1)
{
  
#line 1058 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 1059 
  return;
}


#line 1062  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static bool ldv_queue_delayed_work_100(struct workqueue_struct *wq, struct delayed_work *dwork, unsigned long delay)
{
  bool __retres;
  bool tmp;
  
#line 1066 
  tmp = ldv_emg_queue_delayed_work(wq,dwork,delay);
  
#line 1066 
  __retres = tmp != 0;
  
#line 1066 
  return __retres;
}


#line 1070  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_mutex_lock_101(struct mutex *ldv_func_arg1)
{
  
#line 1074 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 1075 
  return;
}


#line 1078  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_mutex_unlock_102_0(struct mutex *ldv_func_arg1)
{
  
#line 1082 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 1083 
  return;
}


#line 1086  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_spin_lock_bh_103_1(spinlock_t *lock)
{
  
#line 1090 
  ldv_spin_model_lock((char *)"stats_lock_of_efx_nic");
  
#line 1092 
  spin_lock_bh_5(lock);
  
#line 1093 
  return;
}


#line 1096  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_spin_unlock_bh_104_0(spinlock_t *lock)
{
  
#line 1100 
  ldv_spin_model_unlock((char *)"stats_lock_of_efx_nic");
  
#line 1102 
  spin_unlock_bh_6(lock);
  
#line 1103 
  return;
}


#line 1106  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_spin_lock_bh_105_0(spinlock_t *lock)
{
  
#line 1110 
  ldv_spin_model_lock((char *)"stats_lock_of_efx_nic");
  
#line 1112 
  spin_lock_bh_5(lock);
  
#line 1113 
  return;
}


#line 1116  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_spin_unlock_bh_106(spinlock_t *lock)
{
  
#line 1120 
  ldv_spin_model_unlock((char *)"stats_lock_of_efx_nic");
  
#line 1122 
  spin_unlock_bh_6(lock);
  
#line 1123 
  return;
}


#line 1126  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static int ldv_mutex_trylock_107(struct mutex *ldv_func_arg1)
{
  int __retres;
  
#line 1129 
  int is_mutex_held_by_another_thread = ldv_undef_int();
  
#line 1131 
  if (is_mutex_held_by_another_thread != 0) {
    
#line 1134 
    __retres = 0;
    
#line 1134 
    goto return_label;
  }
  else {
    
#line 1139 
    ldv_mutex_model_lock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
    
#line 1140 
    __retres = 1;
    
#line 1140 
    goto return_label;
  }
  return_label: 
#line 1131 
                return __retres;
}


#line 1145  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_mutex_unlock_108_0(struct mutex *ldv_func_arg1)
{
  
#line 1149 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 1150 
  return;
}


#line 1153  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static bool ldv_queue_delayed_work_109(struct workqueue_struct *wq, struct delayed_work *dwork, unsigned long delay)
{
  bool __retres;
  bool tmp;
  
#line 1157 
  tmp = ldv_emg_queue_delayed_work(wq,dwork,delay);
  
#line 1157 
  __retres = tmp != 0;
  
#line 1157 
  return __retres;
}


#line 1161  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_spin_lock_bh_110_1(spinlock_t *lock)
{
  
#line 1165 
  ldv_spin_model_lock((char *)"stats_lock_of_efx_nic");
  
#line 1167 
  spin_lock_bh_5(lock);
  
#line 1168 
  return;
}


#line 1171  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_spin_unlock_bh_111_1(spinlock_t *lock)
{
  
#line 1175 
  ldv_spin_model_unlock((char *)"stats_lock_of_efx_nic");
  
#line 1177 
  spin_unlock_bh_6(lock);
  
#line 1178 
  return;
}


#line 1181  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_mutex_lock_112_1(struct mutex *ldv_func_arg1)
{
  
#line 1185 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 1186 
  return;
}


#line 1189  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_mutex_unlock_113_1(struct mutex *ldv_func_arg1)
{
  
#line 1193 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 1194 
  return;
}


#line 1197  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_mutex_lock_114_0(struct mutex *ldv_func_arg1)
{
  
#line 1201 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 1202 
  return;
}


#line 1205  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_mutex_unlock_115_0(struct mutex *ldv_func_arg1)
{
  
#line 1209 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 1210 
  return;
}


#line 1213  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static bool ldv_queue_work_116(struct workqueue_struct *wq, struct work_struct *work)
{
  bool __retres;
  bool tmp;
  
#line 1217 
  tmp = ldv_emg_queue_work(wq,work);
  
#line 1217 
  __retres = tmp != 0;
  
#line 1217 
  return __retres;
}


#line 1221  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static int ldv_device_create_file_117(struct device *ldv_func_arg1, struct device_attribute const *ldv_func_arg2)
{
  int tmp;
  
#line 1225 
  tmp = ldv_emg_device_create_file(ldv_func_arg1,(struct device_attribute *)ldv_func_arg2);
  
#line 1225 
  return tmp;
}


#line 1229  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static int ldv_device_create_file_118(struct device *ldv_func_arg1, struct device_attribute const *ldv_func_arg2)
{
  int tmp;
  
#line 1233 
  tmp = ldv_emg_device_create_file(ldv_func_arg1,(struct device_attribute *)ldv_func_arg2);
  
#line 1233 
  return tmp;
}


#line 1237  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_device_remove_file_119(struct device *ldv_func_arg1, struct device_attribute const *ldv_func_arg2)
{
  
#line 1241 
  ldv_emg_device_remove_file(ldv_func_arg1,(struct device_attribute *)ldv_func_arg2);
  
#line 1242 
  return;
}


#line 1245  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_device_remove_file_120(struct device *ldv_func_arg1, struct device_attribute const *ldv_func_arg2)
{
  
#line 1249 
  ldv_emg_device_remove_file(ldv_func_arg1,(struct device_attribute *)ldv_func_arg2);
  
#line 1250 
  return;
}


#line 1253  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_device_remove_file_121(struct device *ldv_func_arg1, struct device_attribute const *ldv_func_arg2)
{
  
#line 1257 
  ldv_emg_device_remove_file(ldv_func_arg1,(struct device_attribute *)ldv_func_arg2);
  
#line 1258 
  return;
}


#line 1261  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_unregister_netdev_122(struct net_device *ldv_func_arg1)
{
  
#line 1265 
  ldv_emg_unregister_netdev(ldv_func_arg1);
  
#line 1266 
  return;
}


#line 1269  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_mutex_lock_123(struct mutex *ldv_func_arg1)
{
  
#line 1273 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 1274 
  return;
}


#line 1277  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_mutex_unlock_124(struct mutex *ldv_func_arg1)
{
  
#line 1281 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 1282 
  return;
}


#line 1285  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_mutex_unlock_125_0(struct mutex *ldv_func_arg1)
{
  
#line 1289 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 1290 
  return;
}


#line 1293  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static bool ldv_queue_work_126(struct workqueue_struct *wq, struct work_struct *work)
{
  bool __retres;
  bool tmp;
  
#line 1297 
  tmp = ldv_emg_queue_work(wq,work);
  
#line 1297 
  __retres = tmp != 0;
  
#line 1297 
  return __retres;
}


#line 1301  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_free_netdev_127(struct net_device *ldv_func_arg1)
{
  
#line 1305 
  ldv_emg_free_netdev(ldv_func_arg1);
  
#line 1306 
  return;
}


#line 1309  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static struct net_device *ldv_alloc_etherdev_mqs_128(int ldv_func_arg1, unsigned int ldv_func_arg2, unsigned int ldv_func_arg3)
{
  struct net_device *tmp;
  
#line 1313 
  tmp = ldv_emg_alloc_etherdev_mqs(ldv_func_arg1,ldv_func_arg2,ldv_func_arg3);
  
#line 1313 
  return tmp;
}


#line 1317  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_free_netdev_129(struct net_device *ldv_func_arg1)
{
  
#line 1321 
  ldv_emg_free_netdev(ldv_func_arg1);
  
#line 1322 
  return;
}


#line 1325  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_mutex_lock_130(struct mutex *ldv_func_arg1)
{
  
#line 1329 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 1330 
  return;
}


#line 1333  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_mutex_unlock_131(struct mutex *ldv_func_arg1)
{
  
#line 1337 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mac_lock_of_efx_nic");
  
#line 1338 
  return;
}


#line 1341  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static bool ldv_queue_work_132(struct workqueue_struct *wq, struct work_struct *work)
{
  bool __retres;
  bool tmp;
  
#line 1345 
  tmp = ldv_emg_queue_work(wq,work);
  
#line 1345 
  __retres = tmp != 0;
  
#line 1345 
  return __retres;
}


#line 1349  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static int ldv___pci_register_driver_133(struct pci_driver *ldv_func_arg1, struct module *ldv_func_arg2, char const *ldv_func_arg3)
{
  int tmp;
  
#line 1353 
  tmp = ldv_emg___pci_register_driver(ldv_func_arg1,ldv_func_arg2,(char *)ldv_func_arg3);
  
#line 1353 
  return tmp;
}


#line 1357  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_efx.c.aux"
static void ldv_pci_unregister_driver_134(struct pci_driver *ldv_func_arg1)
{
  
#line 1361 
  ldv_emg_pci_unregister_driver(ldv_func_arg1);
  
#line 1362 
  return;
}


#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
static int ldv_mutex_is_locked_87(struct mutex *lock);


#line 581  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kzalloc_11(size_t size, gfp_t flags);


#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
void __compiletime_assert_43(void);


#line 44 
void __compiletime_assert_44(void);


#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
static int efx_mcdi_get_phy_cfg(struct efx_nic *efx, struct efx_mcdi_phy_data *cfg)
{
  int __retres;
  size_t outlen;
  int rc;
  
#line 39 
  efx_dword_t outbuf[18U] = {{.u32 = {0U}}};
  {
    
#line 43 
    bool __cond = (_Bool)0;
    
#line 43 
    if ((int)__cond != 0) 
#line 43 
                          __compiletime_assert_43(); else ;
  }
  {
    
#line 44 
    bool __cond_0 = (_Bool)0;
    
#line 44 
    if ((int)__cond_0 != 0) 
#line 44 
                            __compiletime_assert_44(); else ;
  }
  
#line 46 
  rc = efx_mcdi_rpc(efx,36U,(efx_dword_t const *)0,0UL,(efx_dword_t *)(& outbuf),72UL,& outlen);
  
#line 48 
  if (rc != 0) 
#line 49 
               goto fail; else ;
  
#line 51 
  if (outlen <= 71UL) {
    
#line 52 
    rc = -5;
    
#line 53 
    goto fail;
  }
  else ;
  
#line 56 
  cfg->flags = ((efx_dword_t *)(& outbuf))->u32[0];
  
#line 57 
  cfg->type = ((efx_dword_t *)(& outbuf) + 1U)->u32[0];
  
#line 58 
  cfg->supported_cap = ((efx_dword_t *)(& outbuf) + 2U)->u32[0];
  
#line 60 
  cfg->channel = ((efx_dword_t *)(& outbuf) + 3U)->u32[0];
  
#line 61 
  cfg->port = ((efx_dword_t *)(& outbuf) + 4U)->u32[0];
  
#line 62 
  cfg->stats_mask = ((efx_dword_t *)(& outbuf) + 5U)->u32[0];
  
#line 63 
  memcpy((void *)(& cfg->name),(void const *)(& outbuf) + 24U,20UL);
  
#line 65 
  cfg->media = ((efx_dword_t *)(& outbuf) + 11U)->u32[0];
  
#line 66 
  cfg->mmd_mask = ((efx_dword_t *)(& outbuf) + 12U)->u32[0];
  
#line 67 
  memcpy((void *)(& cfg->revision),(void const *)(& outbuf) + 52U,20UL);
  
#line 70 
  __retres = 0;
  
#line 70 
  goto return_label;
  fail: 
#line 72 
  ;
  
#line 73 
  if ((efx->msg_enable & 8192U) != 0U) 
#line 73 
                                       netdev_err((struct net_device const *)efx->net_dev,"%s: failed rc=%d\n","efx_mcdi_get_phy_cfg",rc); else ;
  
#line 74 
  __retres = rc;
  return_label: 
#line 74 
                return __retres;
}


#line 84 
void __compiletime_assert_84(void);


#line 77  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
static int efx_mcdi_set_link(struct efx_nic *efx, u32 capabilities, u32 flags, u32 loopback_mode, u32 loopback_speed)
{
  int rc;
  
#line 81 
  efx_dword_t inbuf[4U] = {{.u32 = {0U}}};
  {
    
#line 84 
    bool __cond = (_Bool)0;
    
#line 84 
    if ((int)__cond != 0) 
#line 84 
                          __compiletime_assert_84(); else ;
  }
  
#line 86 
  ((efx_dword_t *)(& inbuf))->u32[0] = capabilities;
  
#line 87 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = flags;
  
#line 88 
  ((efx_dword_t *)(& inbuf) + 2U)->u32[0] = loopback_mode;
  
#line 89 
  ((efx_dword_t *)(& inbuf) + 3U)->u32[0] = loopback_speed;
  
#line 91 
  rc = efx_mcdi_rpc(efx,42U,(efx_dword_t const *)(& inbuf),16UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 93 
  return rc;
}


#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
static int efx_mcdi_loopback_modes(struct efx_nic *efx, u64 *loopback_modes)
{
  int __retres;
  size_t outlen;
  int rc;
  
#line 98 
  efx_dword_t outbuf[10U] = {{.u32 = {0U}}};
  
#line 102 
  rc = efx_mcdi_rpc(efx,40U,(efx_dword_t const *)0,0UL,(efx_dword_t *)(& outbuf),40UL,& outlen);
  
#line 104 
  if (rc != 0) 
#line 105 
               goto fail; else ;
  
#line 107 
  if (outlen <= 31UL) {
    
#line 109 
    rc = -5;
    
#line 110 
    goto fail;
  }
  else ;
  
#line 113 
  *loopback_modes = (unsigned long long)((efx_dword_t *)(& outbuf) + 6U)->u32[0] | ((unsigned long long)((efx_dword_t *)(& outbuf) + 7U)->u32[0] << 32);
  
#line 115 
  __retres = 0;
  
#line 115 
  goto return_label;
  fail: 
#line 117 
  ;
  
#line 118 
  if ((efx->msg_enable & 8192U) != 0U) 
#line 118 
                                       netdev_err((struct net_device const *)efx->net_dev,"%s: failed rc=%d\n","efx_mcdi_loopback_modes",rc); else ;
  
#line 119 
  __retres = rc;
  return_label: 
#line 119 
                return __retres;
}


#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
static int efx_mcdi_mdio_read(struct net_device *net_dev, int prtad, int devad, u16 addr)
{
  int __retres;
  size_t outlen;
  int rc;
  
#line 125 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 126 
  efx_dword_t inbuf[4U] = {{.u32 = {0U}}};
  
#line 127 
  efx_dword_t outbuf[2U] = {{.u32 = {0U}}};
  
#line 131 
  ((efx_dword_t *)(& inbuf))->u32[0] = efx->mdio_bus;
  
#line 132 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = (unsigned int)prtad;
  
#line 133 
  ((efx_dword_t *)(& inbuf) + 2U)->u32[0] = (unsigned int)devad;
  
#line 134 
  ((efx_dword_t *)(& inbuf) + 3U)->u32[0] = (unsigned int)addr;
  
#line 136 
  rc = efx_mcdi_rpc(efx,16U,(efx_dword_t const *)(& inbuf),16UL,(efx_dword_t *)(& outbuf),8UL,& outlen);
  
#line 138 
  if (rc != 0) {
    
#line 139 
    __retres = rc;
    
#line 139 
    goto return_label;
  }
  else ;
  
#line 141 
  if (((efx_dword_t *)(& outbuf) + 1U)->u32[0] != 8U) {
    
#line 143 
    __retres = -5;
    
#line 143 
    goto return_label;
  }
  else ;
  
#line 145 
  __retres = (int)((unsigned short)((efx_dword_t *)(& outbuf))->u32[0]);
  return_label: 
#line 145 
                return __retres;
}


#line 148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
static int efx_mcdi_mdio_write(struct net_device *net_dev, int prtad, int devad, u16 addr, u16 value)
{
  int __retres;
  size_t outlen;
  int rc;
  
#line 151 
  struct efx_nic *efx = netdev_priv((struct net_device const *)net_dev);
  
#line 152 
  efx_dword_t inbuf[5U] = {{.u32 = {0U}}};
  
#line 153 
  efx_dword_t outbuf[1U] = {{.u32 = {0U}}};
  
#line 157 
  ((efx_dword_t *)(& inbuf))->u32[0] = efx->mdio_bus;
  
#line 158 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = (unsigned int)prtad;
  
#line 159 
  ((efx_dword_t *)(& inbuf) + 2U)->u32[0] = (unsigned int)devad;
  
#line 160 
  ((efx_dword_t *)(& inbuf) + 3U)->u32[0] = (unsigned int)addr;
  
#line 161 
  ((efx_dword_t *)(& inbuf) + 4U)->u32[0] = (unsigned int)value;
  
#line 163 
  rc = efx_mcdi_rpc(efx,17U,(efx_dword_t const *)(& inbuf),20UL,(efx_dword_t *)(& outbuf),4UL,& outlen);
  
#line 165 
  if (rc != 0) {
    
#line 166 
    __retres = rc;
    
#line 166 
    goto return_label;
  }
  else ;
  
#line 168 
  if (((efx_dword_t *)(& outbuf))->u32[0] != 8U) {
    
#line 170 
    __retres = -5;
    
#line 170 
    goto return_label;
  }
  else ;
  
#line 172 
  __retres = 0;
  return_label: 
#line 172 
                return __retres;
}


#line 175  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
static u32 mcdi_to_ethtool_cap(u32 media, u32 cap)
{
  
#line 177 
  u32 result = 0U;
  
#line 179 
  switch (media) {
    case (u32)3: 
#line 180 
    ;
    
#line 181 
    result |= 65536U;
    
#line 182 
    if ((cap & 64U) != 0U) 
#line 183 
                           result |= 131072U; else ;
    
#line 184 
    if ((cap & 128U) != 0U) 
#line 185 
                            result |= 262144U; else ;
    
#line 186 
    if ((cap & 2048U) != 0U) 
#line 187 
                             result |= 8388608U; else ;
    
#line 188 
    goto ldv_55713;
    case (u32)4: 
#line 190 
    ;
    case (u32)5: 
#line 191 
    ;
    
#line 192 
    result |= 1024U;
    
#line 193 
    goto ldv_55713;
    case (u32)7: 
#line 195 
    ;
    
#line 196 
    result |= 1024U;
    
#line 197 
    if ((cap & 2048U) != 0U) 
#line 198 
                             result |= 16777216U; else ;
    
#line 199 
    goto ldv_55713;
    case (u32)6: 
#line 201 
    ;
    
#line 202 
    result |= 128U;
    
#line 203 
    if ((cap & 2U) != 0U) 
#line 204 
                          result |= 1U; else ;
    
#line 205 
    if ((cap & 4U) != 0U) 
#line 206 
                          result |= 2U; else ;
    
#line 207 
    if ((cap & 8U) != 0U) 
#line 208 
                          result |= 4U; else ;
    
#line 209 
    if ((cap & 16U) != 0U) 
#line 210 
                           result |= 8U; else ;
    
#line 211 
    if ((cap & 32U) != 0U) 
#line 212 
                           result |= 16U; else ;
    
#line 213 
    if ((cap & 64U) != 0U) 
#line 214 
                           result |= 32U; else ;
    
#line 215 
    if ((cap & 128U) != 0U) 
#line 216 
                            result |= 4096U; else ;
    
#line 217 
    goto ldv_55713;
  }
  ldv_55713: 
#line 220 
  ;
  
#line 220 
  if ((cap & 256U) != 0U) 
#line 221 
                          result |= 8192U; else ;
  
#line 222 
  if ((cap & 512U) != 0U) 
#line 223 
                          result |= 16384U; else ;
  
#line 224 
  if ((cap & 1024U) != 0U) 
#line 225 
                           result |= 64U; else ;
  
#line 227 
  return result;
}


#line 230  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
static u32 ethtool_to_mcdi_cap(u32 cap)
{
  
#line 232 
  u32 result = 0U;
  
#line 234 
  if ((cap & 1U) != 0U) 
#line 235 
                        result |= 2U; else ;
  
#line 236 
  if ((cap & 2U) != 0U) 
#line 237 
                        result |= 4U; else ;
  
#line 238 
  if ((cap & 4U) != 0U) 
#line 239 
                        result |= 8U; else ;
  
#line 240 
  if ((cap & 8U) != 0U) 
#line 241 
                        result |= 16U; else ;
  
#line 242 
  if ((cap & 16U) != 0U) 
#line 243 
                         result |= 32U; else ;
  
#line 244 
  if ((cap & 131104U) != 0U) 
#line 245 
                             result |= 64U; else ;
  
#line 246 
  if ((cap & 266240U) != 0U) 
#line 247 
                             result |= 128U; else ;
  
#line 248 
  if ((cap & 25165824U) != 0U) 
#line 249 
                               result |= 2048U; else ;
  
#line 250 
  if ((cap & 8192U) != 0U) 
#line 251 
                           result |= 256U; else ;
  
#line 252 
  if ((cap & 16384U) != 0U) 
#line 253 
                            result |= 512U; else ;
  
#line 254 
  if ((cap & 64U) != 0U) 
#line 255 
                         result |= 1024U; else ;
  
#line 257 
  return result;
}


#line 260  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
static u32 efx_get_mcdi_phy_flags(struct efx_nic *efx)
{
  enum efx_phy_mode mode;
  enum efx_phy_mode supported;
  u32 flags;
  
#line 262 
  struct efx_mcdi_phy_data *phy_cfg = (struct efx_mcdi_phy_data *)efx->phy_data;
  
#line 267 
  supported = PHY_MODE_NORMAL;
  
#line 268 
  if ((phy_cfg->flags & 32U) != 0U) 
#line 269 
                                    supported = (enum efx_phy_mode)((unsigned int)supported | 1U); else ;
  
#line 270 
  if ((phy_cfg->flags & 8U) != 0U) 
#line 271 
                                   supported = (enum efx_phy_mode)((unsigned int)supported | 2U); else ;
  
#line 272 
  if ((phy_cfg->flags & 16U) != 0U) 
#line 273 
                                    supported = (enum efx_phy_mode)((unsigned int)supported | 4U); else ;
  
#line 275 
  mode = (enum efx_phy_mode)((unsigned int)efx->phy_mode & (unsigned int)supported);
  
#line 277 
  flags = 0U;
  
#line 278 
  if (((unsigned int)mode & 1U) != 0U) 
#line 279 
                                       flags |= 4U; else ;
  
#line 280 
  if (((unsigned int)mode & 2U) != 0U) 
#line 281 
                                       flags |= 1U; else ;
  
#line 282 
  if (((unsigned int)mode & 4U) != 0U) 
#line 283 
                                       flags |= 2U; else ;
  
#line 285 
  return flags;
}


#line 288  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
static u32 mcdi_to_ethtool_media(u32 media)
{
  u32 __retres;
  
#line 290 
  switch (media) {
    case (u32)1: 
#line 291 
    ;
    case (u32)2: 
#line 292 
    ;
    case (u32)3: 
#line 293 
    ;
    
#line 294 
    __retres = 255U;
    
#line 294 
    goto return_label;
    case (u32)4: 
#line 296 
    ;
    case (u32)5: 
#line 297 
    ;
    case (u32)7: 
#line 298 
    ;
    
#line 299 
    __retres = 3U;
    
#line 299 
    goto return_label;
    case (u32)6: 
#line 301 
    ;
    
#line 302 
    __retres = 0U;
    
#line 302 
    goto return_label;
    default: 
#line 304 
    ;
    
#line 305 
    __retres = 255U;
    
#line 305 
    goto return_label;
  }
  return_label: 
#line 290 
                return __retres;
}


#line 309  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
static void efx_mcdi_phy_decode_link(struct efx_nic *efx, struct efx_link_state *link_state, u32 speed, u32 flags, u32 fcntl)
{
  
#line 313 
  switch (fcntl) {
    case (u32)3: 
#line 314 
    ;
    {
      
#line 315 
      int __ret_warn_on = 1;
      
#line 315 
      if ((long)(__ret_warn_on != 0) != 0L) 
#line 315 
                                            warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c",315); else ;
      
#line 315 
      long tmp = (long)(__ret_warn_on != 0);
    }
    
#line 316 
    link_state->fc = (unsigned char)7U;
    
#line 317 
    goto ldv_55750;
    case (u32)2: 
#line 318 
    ;
    
#line 319 
    link_state->fc = (unsigned char)3U;
    
#line 320 
    goto ldv_55750;
    case (u32)1: 
#line 321 
    ;
    
#line 322 
    link_state->fc = (unsigned char)2U;
    
#line 323 
    goto ldv_55750;
    default: 
#line 324 
    ;
    {
      
#line 325 
      int __ret_warn_on_0 = 1;
      
#line 325 
      if ((long)(__ret_warn_on_0 != 0) != 0L) 
#line 325 
                                              warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c",325); else ;
      
#line 325 
      long tmp_3 = (long)(__ret_warn_on_0 != 0);
    }
    case (u32)0: 
#line 326 
    ;
    
#line 327 
    link_state->fc = (unsigned char)0U;
    
#line 328 
    goto ldv_55750;
  }
  ldv_55750: 
#line 331 
  ;
  
#line 331 
  link_state->up = (_Bool)((flags & 1U) != 0U);
  
#line 332 
  link_state->fd = (_Bool)((flags & 2U) != 0U);
  
#line 333 
  link_state->speed = speed;
  
#line 334 
  return;
}


#line 353 
void __compiletime_assert_353(void);


#line 380 
void __compiletime_assert_380(void);


#line 381 
void __compiletime_assert_381(void);


#line 382 
void __compiletime_assert_382(void);


#line 383 
void __compiletime_assert_383(void);


#line 384 
void __compiletime_assert_384(void);


#line 385 
void __compiletime_assert_385(void);


#line 386 
void __compiletime_assert_386(void);


#line 387 
void __compiletime_assert_387(void);


#line 388 
void __compiletime_assert_388(void);


#line 389 
void __compiletime_assert_389(void);


#line 390 
void __compiletime_assert_390(void);


#line 391 
void __compiletime_assert_391(void);


#line 392 
void __compiletime_assert_392(void);


#line 394 
void __compiletime_assert_394(void);


#line 395 
void __compiletime_assert_395(void);


#line 396 
void __compiletime_assert_396(void);


#line 397 
void __compiletime_assert_397(void);


#line 398 
void __compiletime_assert_398(void);


#line 399 
void __compiletime_assert_399(void);


#line 400 
void __compiletime_assert_400(void);


#line 401 
void __compiletime_assert_401(void);


#line 403 
void __compiletime_assert_403(void);


#line 404 
void __compiletime_assert_404(void);


#line 405 
void __compiletime_assert_405(void);


#line 406 
void __compiletime_assert_406(void);


#line 336  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
static int efx_mcdi_phy_probe(struct efx_nic *efx)
{
  int __retres;
  struct efx_mcdi_phy_data *phy_data;
  u32 caps;
  int rc;
  
#line 339 
  efx_dword_t outbuf[7U] = {{.u32 = {0U}}};
  
#line 344 
  phy_data = (struct efx_mcdi_phy_data *)kzalloc_11(76UL,208U);
  
#line 345 
  if (phy_data == (struct efx_mcdi_phy_data *)0) {
    
#line 346 
    __retres = -12;
    
#line 346 
    goto return_label;
  }
  else ;
  
#line 348 
  rc = efx_mcdi_get_phy_cfg(efx,phy_data);
  
#line 349 
  if (rc != 0) 
#line 350 
               goto fail; else ;
  {
    
#line 353 
    bool __cond = (_Bool)0;
    
#line 353 
    if ((int)__cond != 0) 
#line 353 
                          __compiletime_assert_353(); else ;
  }
  
#line 354 
  rc = efx_mcdi_rpc(efx,41U,(efx_dword_t const *)0,0UL,(efx_dword_t *)(& outbuf),28UL,(size_t *)0UL);
  
#line 356 
  if (rc != 0) 
#line 357 
               goto fail; else ;
  
#line 360 
  efx->phy_data = (void *)phy_data;
  
#line 361 
  efx->phy_type = phy_data->type;
  
#line 363 
  efx->mdio_bus = phy_data->channel;
  
#line 364 
  efx->mdio.prtad = (int)phy_data->port;
  
#line 365 
  efx->mdio.mmds = phy_data->mmd_mask & 4294967294U;
  
#line 366 
  efx->mdio.mode_support = 0U;
  
#line 367 
  if ((phy_data->mmd_mask & 1U) != 0U) 
#line 368 
                                       efx->mdio.mode_support |= 1U; else ;
  
#line 369 
  if ((phy_data->mmd_mask & 4294967294U) != 0U) 
#line 370 
                                                efx->mdio.mode_support |= 6U; else ;
  
#line 372 
  caps = ((efx_dword_t *)(& outbuf))->u32[0];
  
#line 373 
  if ((caps & 1024U) != 0U) 
#line 374 
                            efx->link_advertising = mcdi_to_ethtool_cap(phy_data->media,caps); else 
                                                                    
#line 377 
                                                                    phy_data->forced_cap = caps;
  {
    
#line 380 
    bool __cond_0 = (_Bool)0;
    
#line 380 
    if ((int)__cond_0 != 0) 
#line 380 
                            __compiletime_assert_380(); else ;
  }
  {
    
#line 381 
    bool __cond_1 = (_Bool)0;
    
#line 381 
    if ((int)__cond_1 != 0) 
#line 381 
                            __compiletime_assert_381(); else ;
  }
  {
    
#line 382 
    bool __cond_2 = (_Bool)0;
    
#line 382 
    if ((int)__cond_2 != 0) 
#line 382 
                            __compiletime_assert_382(); else ;
  }
  {
    
#line 383 
    bool __cond_3 = (_Bool)0;
    
#line 383 
    if ((int)__cond_3 != 0) 
#line 383 
                            __compiletime_assert_383(); else ;
  }
  {
    
#line 384 
    bool __cond_4 = (_Bool)0;
    
#line 384 
    if ((int)__cond_4 != 0) 
#line 384 
                            __compiletime_assert_384(); else ;
  }
  {
    
#line 385 
    bool __cond_5 = (_Bool)0;
    
#line 385 
    if ((int)__cond_5 != 0) 
#line 385 
                            __compiletime_assert_385(); else ;
  }
  {
    
#line 386 
    bool __cond_6 = (_Bool)0;
    
#line 386 
    if ((int)__cond_6 != 0) 
#line 386 
                            __compiletime_assert_386(); else ;
  }
  {
    
#line 387 
    bool __cond_7 = (_Bool)0;
    
#line 387 
    if ((int)__cond_7 != 0) 
#line 387 
                            __compiletime_assert_387(); else ;
  }
  {
    
#line 388 
    bool __cond_8 = (_Bool)0;
    
#line 388 
    if ((int)__cond_8 != 0) 
#line 388 
                            __compiletime_assert_388(); else ;
  }
  {
    
#line 389 
    bool __cond_9 = (_Bool)0;
    
#line 389 
    if ((int)__cond_9 != 0) 
#line 389 
                            __compiletime_assert_389(); else ;
  }
  {
    
#line 390 
    bool __cond_10 = (_Bool)0;
    
#line 390 
    if ((int)__cond_10 != 0) 
#line 390 
                             __compiletime_assert_390(); else ;
  }
  {
    
#line 391 
    bool __cond_11 = (_Bool)0;
    
#line 391 
    if ((int)__cond_11 != 0) 
#line 391 
                             __compiletime_assert_391(); else ;
  }
  {
    
#line 392 
    bool __cond_12 = (_Bool)0;
    
#line 392 
    if ((int)__cond_12 != 0) 
#line 392 
                             __compiletime_assert_392(); else ;
  }
  {
    
#line 393 
    bool __cond_13 = (_Bool)0;
    
#line 393 
    if ((int)__cond_13 != 0) 
#line 393 
                             __compiletime_assert_393(); else ;
  }
  {
    
#line 394 
    bool __cond_14 = (_Bool)0;
    
#line 394 
    if ((int)__cond_14 != 0) 
#line 394 
                             __compiletime_assert_394(); else ;
  }
  {
    
#line 395 
    bool __cond_15 = (_Bool)0;
    
#line 395 
    if ((int)__cond_15 != 0) 
#line 395 
                             __compiletime_assert_395(); else ;
  }
  {
    
#line 396 
    bool __cond_16 = (_Bool)0;
    
#line 396 
    if ((int)__cond_16 != 0) 
#line 396 
                             __compiletime_assert_396(); else ;
  }
  {
    
#line 397 
    bool __cond_17 = (_Bool)0;
    
#line 397 
    if ((int)__cond_17 != 0) 
#line 397 
                             __compiletime_assert_397(); else ;
  }
  {
    
#line 398 
    bool __cond_18 = (_Bool)0;
    
#line 398 
    if ((int)__cond_18 != 0) 
#line 398 
                             __compiletime_assert_398(); else ;
  }
  {
    
#line 399 
    bool __cond_19 = (_Bool)0;
    
#line 399 
    if ((int)__cond_19 != 0) 
#line 399 
                             __compiletime_assert_399(); else ;
  }
  {
    
#line 400 
    bool __cond_20 = (_Bool)0;
    
#line 400 
    if ((int)__cond_20 != 0) 
#line 400 
                             __compiletime_assert_400(); else ;
  }
  {
    
#line 401 
    bool __cond_21 = (_Bool)0;
    
#line 401 
    if ((int)__cond_21 != 0) 
#line 401 
                             __compiletime_assert_401(); else ;
  }
  {
    
#line 402 
    bool __cond_22 = (_Bool)0;
    
#line 402 
    if ((int)__cond_22 != 0) 
#line 402 
                             __compiletime_assert_402(); else ;
  }
  {
    
#line 403 
    bool __cond_23 = (_Bool)0;
    
#line 403 
    if ((int)__cond_23 != 0) 
#line 403 
                             __compiletime_assert_403(); else ;
  }
  {
    
#line 404 
    bool __cond_24 = (_Bool)0;
    
#line 404 
    if ((int)__cond_24 != 0) 
#line 404 
                             __compiletime_assert_404(); else ;
  }
  {
    
#line 405 
    bool __cond_25 = (_Bool)0;
    
#line 405 
    if ((int)__cond_25 != 0) 
#line 405 
                             __compiletime_assert_405(); else ;
  }
  {
    
#line 406 
    bool __cond_26 = (_Bool)0;
    
#line 406 
    if ((int)__cond_26 != 0) 
#line 406 
                             __compiletime_assert_406(); else ;
  }
  
#line 408 
  rc = efx_mcdi_loopback_modes(efx,& efx->loopback_modes);
  
#line 409 
  if (rc != 0) 
#line 410 
               goto fail; else ;
  
#line 413 
  efx->loopback_modes &= 18446744073709551614ULL;
  
#line 416 
  efx_mcdi_phy_decode_link(efx,& efx->link_state,((efx_dword_t *)(& outbuf) + 2U)->u32[0],((efx_dword_t *)(& outbuf) + 4U)->u32[0],((efx_dword_t *)(& outbuf) + 5U)->u32[0]);
  
#line 423 
  efx->wanted_fc = (unsigned char)3U;
  
#line 424 
  if ((phy_data->supported_cap & 1024U) != 0U) 
#line 425 
                                               efx->wanted_fc = (unsigned char)((unsigned int)efx->wanted_fc | 4U); else ;
  
#line 426 
  efx_link_set_wanted_fc(efx,(unsigned char)((int)efx->wanted_fc));
  
#line 428 
  __retres = 0;
  
#line 428 
  goto return_label;
  fail: 
#line 430 
  ;
  
#line 431 
  kfree((void const *)phy_data);
  
#line 432 
  __retres = rc;
  return_label: 
#line 432 
                return __retres;
}


#line 435  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
int efx_mcdi_port_reconfigure(struct efx_nic *efx)
{
  u32 tmp_0;
  int tmp_2;
  u32 tmp_1;
  
#line 437 
  struct efx_mcdi_phy_data *phy_cfg = (struct efx_mcdi_phy_data *)efx->phy_data;
  
#line 438 
  if (efx->link_advertising != 0U) 
#line 438 
                                   tmp_0 = ethtool_to_mcdi_cap(efx->link_advertising); else 
                                                                    
#line 438 
                                                                    tmp_0 = phy_cfg->forced_cap;
  
#line 438 
  u32 caps = tmp_0;
  
#line 442 
  ;
  
#line 442 
  tmp_1 = efx_get_mcdi_phy_flags(efx);
  
#line 442 
  ;
  
#line 442 
  ;
  
#line 442 
  tmp_2 = efx_mcdi_set_link(efx,caps,tmp_1,(unsigned int)efx->loopback_mode,0U);
  
#line 442 
  return tmp_2;
}


#line 449  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
static void efx_mcdi_phy_check_fcntl(struct efx_nic *efx, u32 lpa)
{
  u32 rmtadv;
  
#line 451 
  struct efx_mcdi_phy_data *phy_cfg = (struct efx_mcdi_phy_data *)efx->phy_data;
  
#line 456 
  if ((phy_cfg->supported_cap & 1024U) == 0U) 
#line 457 
                                              goto return_label; else ;
  
#line 460 
  if (((int)efx->wanted_fc & 4) != 0) 
#line 461 
                                      goto return_label; else ;
  
#line 463 
  rmtadv = 0U;
  
#line 464 
  if ((lpa & 256U) != 0U) 
#line 465 
                          rmtadv |= 8192U; else ;
  
#line 466 
  if ((lpa & 512U) != 0U) 
#line 467 
                          rmtadv |= 16384U; else ;
  
#line 469 
  if (((int)efx->wanted_fc & 1) != 0 && rmtadv == 16384U) {
    
#line 470 
    if ((efx->msg_enable & 4U) != 0U) 
#line 470 
                                      netdev_err((struct net_device const *)efx->net_dev,"warning: link partner doesn\'t support pause frames"); else ;
  }
  else ;
  return_label: 
#line 471 
                return;
}


#line 482 
void __compiletime_assert_482(void);


#line 474  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
static bool efx_mcdi_phy_poll(struct efx_nic *efx)
{
  bool __retres;
  int rc;
  int tmp_1;
  bool tmp_0;
  
#line 476 
  struct efx_link_state old_state = efx->link_state;
  
#line 477 
  efx_dword_t outbuf[7U] = {{.u32 = {0U}}};
  {
    int tmp;
    
#line 480 
    tmp = ldv_mutex_is_locked_87(& efx->mac_lock);
    
#line 480 
    int __ret_warn_on = tmp == 0;
    
#line 480 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 480 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c",480); else ;
    
#line 480 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  {
    
#line 482 
    bool __cond = (_Bool)0;
    
#line 482 
    if ((int)__cond != 0) 
#line 482 
                          __compiletime_assert_482(); else ;
  }
  
#line 484 
  rc = efx_mcdi_rpc(efx,41U,(efx_dword_t const *)0,0UL,(efx_dword_t *)(& outbuf),28UL,(size_t *)0UL);
  
#line 486 
  if (rc != 0) 
#line 487 
               efx->link_state.up = (_Bool)0; else 
#line 489 
                                                   efx_mcdi_phy_decode_link(efx,& efx->link_state,((efx_dword_t *)(& outbuf) + 2U)->u32[0],((efx_dword_t *)(& outbuf) + 4U)->u32[0],((efx_dword_t *)(& outbuf) + 5U)->u32[0]);
  
#line 495 
  tmp_0 = efx_link_state_equal((struct efx_link_state const *)(& efx->link_state),(struct efx_link_state const *)(& old_state));
  
#line 495 
  if ((int)tmp_0 != 0) 
#line 495 
                       tmp_1 = 0; else 
#line 495 
                                       tmp_1 = 1;
  
#line 495 
  __retres = (_Bool)(tmp_1 != 0);
  
#line 495 
  return __retres;
}


#line 498  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
static void efx_mcdi_phy_remove(struct efx_nic *efx)
{
  
#line 500 
  struct efx_mcdi_phy_data *phy_data = (struct efx_mcdi_phy_data *)efx->phy_data;
  
#line 502 
  efx->phy_data = (void *)0;
  
#line 503 
  kfree((void const *)phy_data);
  
#line 504 
  return;
}


#line 524 
void __compiletime_assert_524(void);


#line 506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
static void efx_mcdi_phy_get_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd)
{
  int rc;
  u32 tmp;
  
#line 508 
  struct efx_mcdi_phy_data *phy_cfg = (struct efx_mcdi_phy_data *)efx->phy_data;
  
#line 509 
  efx_dword_t outbuf[7U] = {{.u32 = {0U}}};
  
#line 512 
  ecmd->supported = mcdi_to_ethtool_cap(phy_cfg->media,phy_cfg->supported_cap);
  
#line 514 
  ecmd->advertising = efx->link_advertising;
  
#line 515 
  ethtool_cmd_speed_set(ecmd,efx->link_state.speed);
  
#line 516 
  ecmd->duplex = (unsigned char)efx->link_state.fd;
  
#line 517 
  tmp = mcdi_to_ethtool_media(phy_cfg->media);
  
#line 517 
  ecmd->port = (unsigned char)tmp;
  
#line 518 
  ecmd->phy_address = (unsigned char)phy_cfg->port;
  
#line 519 
  ecmd->transceiver = (unsigned char)0U;
  
#line 520 
  ecmd->autoneg = (unsigned char)((efx->link_advertising & 64U) != 0U);
  
#line 521 
  ecmd->mdio_support = (unsigned char)((unsigned int)((unsigned char)efx->mdio.mode_support) & 3U);
  {
    
#line 524 
    bool __cond = (_Bool)0;
    
#line 524 
    if ((int)__cond != 0) 
#line 524 
                          __compiletime_assert_524(); else ;
  }
  
#line 525 
  rc = efx_mcdi_rpc(efx,41U,(efx_dword_t const *)0,0UL,(efx_dword_t *)(& outbuf),28UL,(size_t *)0UL);
  
#line 527 
  if (rc != 0) 
#line 528 
               goto return_label; else ;
  
#line 529 
  ecmd->lp_advertising = mcdi_to_ethtool_cap(phy_cfg->media,((efx_dword_t *)(& outbuf) + 1U)->u32[0]);
  return_label: 
#line 532 
                return;
}


#line 534  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
static int efx_mcdi_phy_set_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd)
{
  int __retres;
  u32 caps;
  int rc;
  u32 tmp_2;
  
#line 536 
  struct efx_mcdi_phy_data *phy_cfg = (struct efx_mcdi_phy_data *)efx->phy_data;
  
#line 540 
  if ((unsigned int)ecmd->autoneg != 0U) {
    u32 tmp;
    
#line 541 
    tmp = ethtool_to_mcdi_cap(ecmd->advertising);
    
#line 541 
    caps = tmp | 1024U;
  }
  else 
    
#line 543 
    if ((unsigned int)ecmd->duplex != 0U) {
      __u32 tmp_0;
      
#line 544 
      tmp_0 = ethtool_cmd_speed((struct ethtool_cmd const *)ecmd);
      
#line 544 
      switch (tmp_0) {
        case (__u32)10: 
#line 545 
        ;
        
#line 545 
        caps = 4U;
        
#line 545 
        goto ldv_55971;
        case (__u32)100: 
#line 546 
        ;
        
#line 546 
        caps = 16U;
        
#line 546 
        goto ldv_55971;
        case (__u32)1000: 
#line 547 
        ;
        
#line 547 
        caps = 64U;
        
#line 547 
        goto ldv_55971;
        case (__u32)10000: 
#line 548 
        ;
        
#line 548 
        caps = 128U;
        
#line 548 
        goto ldv_55971;
        case (__u32)40000: 
#line 549 
        ;
        
#line 549 
        caps = 2048U;
        
#line 549 
        goto ldv_55971;
        default: 
#line 550 
        ;
        
#line 550 
        __retres = -22;
        
#line 550 
        goto return_label;
      }
      ldv_55971: 
#line 552 
      ;
    }
    else {
      __u32 tmp_1;
      
#line 553 
      tmp_1 = ethtool_cmd_speed((struct ethtool_cmd const *)ecmd);
      
#line 553 
      switch (tmp_1) {
        case (__u32)10: 
#line 554 
        ;
        
#line 554 
        caps = 2U;
        
#line 554 
        goto ldv_55978;
        case (__u32)100: 
#line 555 
        ;
        
#line 555 
        caps = 8U;
        
#line 555 
        goto ldv_55978;
        case (__u32)1000: 
#line 556 
        ;
        
#line 556 
        caps = 32U;
        
#line 556 
        goto ldv_55978;
        default: 
#line 557 
        ;
        
#line 557 
        __retres = -22;
        
#line 557 
        goto return_label;
      }
      ldv_55978: 
#line 559 
      ;
    }
  
#line 561 
  ;
  
#line 561 
  tmp_2 = efx_get_mcdi_phy_flags(efx);
  
#line 561 
  ;
  
#line 561 
  ;
  
#line 561 
  rc = efx_mcdi_set_link(efx,caps,tmp_2,(unsigned int)efx->loopback_mode,0U);
  
#line 563 
  if (rc != 0) {
    
#line 564 
    __retres = rc;
    
#line 564 
    goto return_label;
  }
  else ;
  
#line 566 
  if ((unsigned int)ecmd->autoneg != 0U) {
    
#line 567 
    efx_link_set_advertising(efx,ecmd->advertising | 64U);
    
#line 569 
    phy_cfg->forced_cap = 0U;
  }
  else {
    
#line 571 
    efx_link_set_advertising(efx,0U);
    
#line 572 
    phy_cfg->forced_cap = caps;
  }
  
#line 574 
  __retres = 0;
  return_label: 
#line 574 
                return __retres;
}


#line 583 
void __compiletime_assert_583(void);


#line 577  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
static int efx_mcdi_phy_test_alive(struct efx_nic *efx)
{
  int __retres;
  size_t outlen;
  int rc;
  
#line 579 
  efx_dword_t outbuf[1U] = {{.u32 = {0U}}};
  {
    
#line 583 
    bool __cond = (_Bool)0;
    
#line 583 
    if ((int)__cond != 0) 
#line 583 
                          __compiletime_assert_583(); else ;
  }
  
#line 585 
  rc = efx_mcdi_rpc(efx,67U,(efx_dword_t const *)0,0UL,(efx_dword_t *)(& outbuf),4UL,& outlen);
  
#line 587 
  if (rc != 0) {
    
#line 588 
    __retres = rc;
    
#line 588 
    goto return_label;
  }
  else ;
  
#line 590 
  if (outlen <= 3UL) {
    
#line 591 
    __retres = -5;
    
#line 591 
    goto return_label;
  }
  else ;
  
#line 592 
  if (((efx_dword_t *)(& outbuf))->u32[0] != 1U) {
    
#line 593 
    __retres = -22;
    
#line 593 
    goto return_label;
  }
  else ;
  
#line 595 
  __retres = 0;
  return_label: 
#line 595 
                return __retres;
}


#line 598  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
static char const * const mcdi_sft9001_cable_diag_names[8U] = {"cable.pairA.length", "cable.pairB.length", "cable.pairC.length", "cable.pairD.length", "cable.pairA.status", "cable.pairB.status", "cable.pairC.status", "cable.pairD.status"};

#line 620 
void __compiletime_assert_620(void);


#line 629 
void __compiletime_assert_629(void);


#line 609  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
static int efx_mcdi_bist(struct efx_nic *efx, unsigned int bist_mode, int *results)
{
  unsigned int retry;
  unsigned int i;
  size_t outlen;
  u32 status;
  u8 *ptr;
  int rc;
  unsigned int tmp;
  
#line 612 
  unsigned int count = 0U;
  
#line 615 
  efx_dword_t inbuf[1U] = {{.u32 = {0U}}};
  
#line 616 
  efx_dword_t outbuf[9U] = {{.u32 = {0U}}};
  {
    
#line 620 
    bool __cond = (_Bool)0;
    
#line 620 
    if ((int)__cond != 0) 
#line 620 
                          __compiletime_assert_620(); else ;
  }
  
#line 621 
  ((efx_dword_t *)(& inbuf))->u32[0] = bist_mode;
  
#line 622 
  rc = efx_mcdi_rpc(efx,37U,(efx_dword_t const *)(& inbuf),4UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 624 
  if (rc != 0) 
#line 625 
               goto out; else ;
  
#line 628 
  retry = 0U;
  
#line 628 
  goto ldv_56033;
  ldv_56032: 
#line 629 
  ;
  {
    
#line 629 
    bool __cond_0 = (_Bool)0;
    
#line 629 
    if ((int)__cond_0 != 0) 
#line 629 
                            __compiletime_assert_629(); else ;
  }
  
#line 630 
  rc = efx_mcdi_rpc(efx,38U,(efx_dword_t const *)0,0UL,(efx_dword_t *)(& outbuf),36UL,& outlen);
  
#line 632 
  if (rc != 0) 
#line 633 
               goto out; else ;
  
#line 635 
  status = ((efx_dword_t *)(& outbuf))->u32[0];
  
#line 636 
  if (status != 1U) 
#line 637 
                    goto finished; else ;
  
#line 639 
  msleep(100U);
  
#line 628 
  retry += 1U;
  ldv_56033: 
#line 629 
  ;
  
#line 628 
  if (retry <= 99U) 
#line 630 
                    goto ldv_56032; else 
#line 633 
                                         goto ldv_56034;
  ldv_56034: 
#line 634 
  ;
  
#line 642 
  rc = -110;
  
#line 643 
  goto out;
  finished: 
#line 645 
  ;
  
#line 646 
  tmp = count;
  
#line 646 
  count += 1U;
  
#line 646 
  if (status == 2U) 
#line 646 
                    *(results + tmp) = 1; else 
#line 646 
                                               *(results + tmp) = -1;
  
#line 649 
  if (efx->phy_type == 10U && bist_mode + 4294967295U <= 1U) {
    
#line 652 
    ptr = (u8 *)(& outbuf) + 4U;
    
#line 653 
    if (status == 2U && outlen > 35UL) {
      
#line 655 
      i = 0U;
      
#line 655 
      goto ldv_56036;
      ldv_56035: 
#line 656 
      ;
      
#line 656 
      *(results + (count + i)) = (int)((efx_dword_t *)ptr + i)->u32[0];
      
#line 655 
      i += 1U;
      ldv_56036: 
#line 656 
      ;
      
#line 655 
      if (i <= 7U) 
#line 657 
                   goto ldv_56035; else 
#line 660 
                                        goto ldv_56037;
      ldv_56037: 
#line 661 
      ;
    }
    else ;
    
#line 661 
    count += 8U;
  }
  else ;
  
#line 663 
  rc = (int)count;
  out: 
#line 665 
  ;
  
#line 666 
  return rc;
}


#line 669  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
static int efx_mcdi_phy_run_tests(struct efx_nic *efx, int *results, unsigned int flags)
{
  int __retres;
  u32 mode;
  int rc;
  
#line 672 
  struct efx_mcdi_phy_data *phy_cfg = (struct efx_mcdi_phy_data *)efx->phy_data;
  
#line 676 
  if ((phy_cfg->flags & 64U) != 0U) {
    
#line 677 
    rc = efx_mcdi_bist(efx,5U,results);
    
#line 678 
    if (rc < 0) {
      
#line 679 
      __retres = rc;
      
#line 679 
      goto return_label;
    }
    else ;
    
#line 681 
    results += rc;
  }
  else ;
  
#line 686 
  mode = 0U;
  
#line 687 
  if ((phy_cfg->flags & 2U) != 0U) 
    
#line 688 
    if ((flags & 1U) != 0U && (phy_cfg->flags & 4U) != 0U) 
#line 691 
                                                           mode = 2U; else 
                                                                    
#line 693 
                                                                    mode = 1U;
  else 
    
#line 694 
    if ((phy_cfg->flags & 4U) != 0U) 
#line 696 
                                     mode = 2U; else ;
  
#line 698 
  if (mode != 0U) {
    
#line 699 
    rc = efx_mcdi_bist(efx,mode,results);
    
#line 700 
    if (rc < 0) {
      
#line 701 
      __retres = rc;
      
#line 701 
      goto return_label;
    }
    else ;
    
#line 702 
    results += rc;
  }
  else ;
  
#line 705 
  __retres = 0;
  return_label: 
#line 705 
                return __retres;
}


#line 708  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
static char const *efx_mcdi_phy_test_name(struct efx_nic *efx, unsigned int index)
{
  char const *__retres;
  
#line 711 
  struct efx_mcdi_phy_data *phy_cfg = (struct efx_mcdi_phy_data *)efx->phy_data;
  
#line 713 
  if ((phy_cfg->flags & 64U) != 0U) {
    
#line 714 
    if (index == 0U) {
      
#line 715 
      __retres = "bist";
      
#line 715 
      goto return_label;
    }
    else ;
    
#line 716 
    index -= 1U;
  }
  else ;
  
#line 719 
  if ((phy_cfg->flags & 6U) != 0U) {
    
#line 721 
    if (index == 0U) {
      
#line 722 
      __retres = "cable";
      
#line 722 
      goto return_label;
    }
    else ;
    
#line 723 
    index -= 1U;
    
#line 725 
    if (efx->phy_type == 10U) {
      
#line 726 
      if (index <= 7U) {
        
#line 727 
        __retres = mcdi_sft9001_cable_diag_names[index];
        
#line 727 
        goto return_label;
      }
      else ;
      
#line 728 
      index += 4294967288U;
    }
    else ;
  }
  else ;
  
#line 732 
  __retres = (char const *)0;
  return_label: 
#line 732 
                return __retres;
}


#line 751 
void __compiletime_assert_751(void);


#line 737  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
static int efx_mcdi_phy_get_module_eeprom(struct efx_nic *efx, struct ethtool_eeprom *ee, u8 *data)
{
  int __retres;
  size_t outlen;
  int rc;
  unsigned int payload_len;
  unsigned int page;
  unsigned int page_off;
  unsigned int to_copy;
  
#line 740 
  efx_dword_t outbuf[63U] = {{.u32 = {0U}}};
  
#line 741 
  efx_dword_t inbuf[1U] = {{.u32 = {0U}}};
  
#line 745 
  unsigned int space_remaining = ee->len;
  
#line 749 
  u8 *user_data = data;
  {
    
#line 751 
    bool __cond = (_Bool)0;
    
#line 751 
    if ((int)__cond != 0) 
#line 751 
                          __compiletime_assert_751(); else ;
  }
  
#line 753 
  page_off = ee->offset & 127U;
  
#line 754 
  page = ee->offset / 128U;
  
#line 756 
  goto ldv_56086;
  ldv_56085: 
#line 757 
  ;
  
#line 757 
  ((efx_dword_t *)(& inbuf))->u32[0] = page;
  
#line 759 
  rc = efx_mcdi_rpc(efx,75U,(efx_dword_t const *)(& inbuf),4UL,(efx_dword_t *)(& outbuf),252UL,& outlen);
  
#line 763 
  if (rc != 0) {
    
#line 764 
    __retres = rc;
    
#line 764 
    goto return_label;
  }
  else ;
  
#line 766 
  if (outlen <= 131UL) {
    
#line 768 
    __retres = -5;
    
#line 768 
    goto return_label;
  }
  else ;
  
#line 770 
  payload_len = ((efx_dword_t *)(& outbuf))->u32[0];
  
#line 772 
  if (payload_len != 128U) {
    
#line 773 
    __retres = -5;
    
#line 773 
    goto return_label;
  }
  else ;
  
#line 776 
  payload_len -= page_off;
  
#line 777 
  if (space_remaining < payload_len) 
#line 777 
                                     to_copy = space_remaining; else 
                                                                  
#line 777 
                                                                  to_copy = payload_len;
  
#line 780 
  memcpy((void *)user_data,(void const *)(& outbuf) + (page_off + 4U),(unsigned long)to_copy);
  
#line 784 
  space_remaining -= to_copy;
  
#line 785 
  user_data += to_copy;
  
#line 786 
  page_off = 0U;
  
#line 787 
  page += 1U;
  ldv_56086: 
#line 789 
  ;
  
#line 756 
  if (space_remaining != 0U && page <= 1U) 
#line 758 
                                           goto ldv_56085; else 
#line 761 
                                                                goto ldv_56087;
  ldv_56087: 
#line 762 
  ;
  
#line 790 
  __retres = 0;
  return_label: 
#line 790 
                return __retres;
}


#line 793  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
static int efx_mcdi_phy_get_module_info(struct efx_nic *efx, struct ethtool_modinfo *modinfo)
{
  int __retres;
  
#line 796 
  struct efx_mcdi_phy_data *phy_cfg = (struct efx_mcdi_phy_data *)efx->phy_data;
  
#line 798 
  switch (phy_cfg->media) {
    case (u32)5: 
#line 799 
    ;
    
#line 800 
    modinfo->type = 1U;
    
#line 801 
    modinfo->eeprom_len = 256U;
    
#line 802 
    __retres = 0;
    
#line 802 
    goto return_label;
    default: 
#line 803 
    ;
    
#line 804 
    __retres = -95;
    
#line 804 
    goto return_label;
  }
  return_label: 
#line 798 
                return __retres;
}


#line 808  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
static struct efx_phy_operations const efx_mcdi_phy_ops = {.probe = & efx_mcdi_phy_probe, .init = & efx_port_dummy_op_int, .fini = & efx_port_dummy_op_void, .remove = & efx_mcdi_phy_remove, .reconfigure = & efx_mcdi_port_reconfigure, .poll = & efx_mcdi_phy_poll, .get_settings = & efx_mcdi_phy_get_settings, .set_settings = & efx_mcdi_phy_set_settings, .set_npage_adv = (void (*)(struct efx_nic *, u32 ))0, .test_alive = & efx_mcdi_phy_test_alive, .test_name = & efx_mcdi_phy_test_name, .run_tests = & efx_mcdi_phy_run_tests, .get_module_eeprom = & efx_mcdi_phy_get_module_eeprom, .get_module_info = & efx_mcdi_phy_get_module_info};

#line 824  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
u32 efx_mcdi_phy_get_caps(struct efx_nic *efx)
{
  u32 __retres;
  
#line 826 
  struct efx_mcdi_phy_data *phy_data = (struct efx_mcdi_phy_data *)efx->phy_data;
  
#line 828 
  __retres = phy_data->supported_cap;
  
#line 828 
  return __retres;
}


#line 831  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
static unsigned int efx_mcdi_event_link_speed[5U] = {[1] = 100U, 1000U, 10000U, 40000U};

#line 838  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
void efx_mcdi_process_link_change(struct efx_nic *efx, efx_qword_t *ev)
{
  u32 flags;
  u32 fcntl;
  u32 speed;
  u32 lpa;
  
#line 842 
  speed = (unsigned int)(ev->u64[0] >> 16) & 15U;
  
#line 844 
  speed = efx_mcdi_event_link_speed[speed];
  
#line 846 
  flags = (unsigned int)(ev->u64[0] >> 24) & 255U;
  
#line 847 
  fcntl = (unsigned int)(ev->u64[0] >> 20) & 15U;
  
#line 848 
  lpa = (unsigned int)ev->u64[0] & 65535U;
  
#line 854 
  efx_mcdi_phy_decode_link(efx,& efx->link_state,speed,flags,fcntl);
  
#line 856 
  efx_mcdi_phy_check_fcntl(efx,lpa);
  
#line 858 
  efx_link_status_changed(efx);
  
#line 859 
  return;
}


#line 866 
void __compiletime_assert_866(void);


#line 861  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
int efx_mcdi_set_mac(struct efx_nic *efx)
{
  u32 fcntl;
  int tmp;
  
#line 864 
  efx_dword_t cmdbytes[6U] = {{.u32 = {0U}}};
  {
    
#line 866 
    bool __cond = (_Bool)0;
    
#line 866 
    if ((int)__cond != 0) 
#line 866 
                          __compiletime_assert_866(); else ;
  }
  
#line 869 
  ether_addr_copy((u8 *)(& cmdbytes) + 8U,(u8 const *)(efx->net_dev)->dev_addr);
  
#line 872 
  ((efx_dword_t *)(& cmdbytes))->u32[0] = (((efx->net_dev)->mtu + 29U) & 4294967288U) + 16U;
  
#line 874 
  ((efx_dword_t *)(& cmdbytes) + 1U)->u32[0] = 0U;
  
#line 877 
  ((efx_dword_t *)(& cmdbytes) + 4U)->u32[0] = (unsigned int)efx->unicast_filter;
  
#line 880 
  switch ((int)efx->wanted_fc) {
    case 3: 
#line 881 
    ;
    
#line 882 
    fcntl = 2U;
    
#line 883 
    goto ldv_56128;
    case 2: 
#line 884 
    ;
    
#line 885 
    fcntl = 1U;
    
#line 886 
    goto ldv_56128;
    default: 
#line 887 
    ;
    
#line 888 
    fcntl = 0U;
    
#line 889 
    goto ldv_56128;
  }
  ldv_56128: 
#line 891 
  ;
  
#line 891 
  if (((int)efx->wanted_fc & 4) != 0) 
#line 892 
                                      fcntl = 3U; else ;
  
#line 893 
  if (efx->fc_disable != 0U) 
#line 894 
                             fcntl = 0U; else ;
  
#line 896 
  ((efx_dword_t *)(& cmdbytes) + 5U)->u32[0] = fcntl;
  
#line 898 
  tmp = efx_mcdi_rpc(efx,44U,(efx_dword_t const *)(& cmdbytes),24UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 898 
  return tmp;
}


#line 908 
void __compiletime_assert_908(void);


#line 902  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
bool efx_mcdi_mac_check_fault(struct efx_nic *efx)
{
  bool __retres;
  size_t outlength;
  int rc;
  
#line 904 
  efx_dword_t outbuf[7U] = {{.u32 = {0U}}};
  {
    
#line 908 
    bool __cond = (_Bool)0;
    
#line 908 
    if ((int)__cond != 0) 
#line 908 
                          __compiletime_assert_908(); else ;
  }
  
#line 910 
  rc = efx_mcdi_rpc(efx,41U,(efx_dword_t const *)0,0UL,(efx_dword_t *)(& outbuf),28UL,& outlength);
  
#line 912 
  if (rc != 0) {
    
#line 913 
    __retres = (_Bool)1;
    
#line 913 
    goto return_label;
  }
  else ;
  
#line 915 
  __retres = (_Bool)(((efx_dword_t *)(& outbuf) + 6U)->u32[0] != 0U);
  return_label: 
#line 915 
                return __retres;
}


#line 937 
void __compiletime_assert_937(void);


#line 924  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
static int efx_mcdi_mac_stats(struct efx_nic *efx, enum efx_stats_action action, int clear)
{
  int rc;
  int tmp;
  unsigned int tmp_0;
  
#line 927 
  struct efx_ef10_nic_data *nic_data = (struct efx_ef10_nic_data *)efx->nic_data;
  
#line 928 
  efx_dword_t inbuf[5U] = {{.u32 = {0U}}};
  
#line 930 
  int change = action != (unsigned int)EFX_STATS_PULL;
  
#line 931 
  int enable = action == (unsigned int)EFX_STATS_ENABLE;
  
#line 932 
  if (action == (unsigned int)EFX_STATS_ENABLE) 
#line 932 
                                                tmp = 1000; else 
#line 932 
                                                                 tmp = 0;
  
#line 932 
  int period = tmp;
  
#line 933 
  dma_addr_t dma_addr = efx->stats_buffer.dma_addr;
  
#line 934 
  if (action != (unsigned int)EFX_STATS_DISABLE) 
#line 934 
                                                 tmp_0 = 776U; else 
#line 934 
                                                                    tmp_0 = 0U;
  
#line 934 
  u32 dma_len = tmp_0;
  {
    
#line 937 
    bool __cond = (_Bool)0;
    
#line 937 
    if ((int)__cond != 0) 
#line 937 
                          __compiletime_assert_937(); else ;
  }
  
#line 939 
  ((efx_dword_t *)(& inbuf))->u32[0] = (unsigned int)dma_addr;
  
#line 939 
  ((efx_dword_t *)(& inbuf) + 1U)->u32[0] = (unsigned int)(dma_addr >> 32);
  
#line 940 
  ((efx_dword_t *)(& inbuf) + 2U)->u32[0] = (((((unsigned int)(enable != 0) | ((unsigned int)clear << 1)) | ((unsigned int)change << 2)) | ((unsigned int)enable << 3)) | ((unsigned int)period << 16)) | 32U;
  
#line 948 
  ((efx_dword_t *)(& inbuf) + 3U)->u32[0] = dma_len;
  
#line 949 
  ((efx_dword_t *)(& inbuf) + 4U)->u32[0] = nic_data->vport_id;
  
#line 951 
  rc = efx_mcdi_rpc_quiet(efx,46U,(efx_dword_t const *)(& inbuf),20UL,(efx_dword_t *)0,0UL,(size_t *)0UL);
  
#line 954 
  if (rc != 0) 
    
#line 954 
    if (rc != -2) 
#line 955 
                  efx_mcdi_display_error(efx,46U,20UL,(efx_dword_t *)0,0UL,rc);
    else {
      int tmp_1;
      
#line 954 
      tmp_1 = atomic_read((atomic_t const *)(& efx->active_queues));
      
#line 954 
      if (tmp_1 != 0) 
#line 955 
                      efx_mcdi_display_error(efx,46U,20UL,(efx_dword_t *)0,0UL,rc); else ;
    }
  else ;
  
#line 957 
  return rc;
}


#line 960  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
void efx_mcdi_mac_start_stats(struct efx_nic *efx)
{
  
#line 962 
  __le64 *dma_stats = (__le64 *)efx->stats_buffer.addr;
  
#line 964 
  *(dma_stats + 96U) = 18446744073709551615ULL;
  
#line 966 
  efx_mcdi_mac_stats(efx,(enum efx_stats_action)EFX_STATS_ENABLE,0);
  
#line 967 
  return;
}


#line 969  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
void efx_mcdi_mac_stop_stats(struct efx_nic *efx)
{
  
#line 971 
  efx_mcdi_mac_stats(efx,(enum efx_stats_action)EFX_STATS_DISABLE,0);
  
#line 972 
  return;
}


#line 977  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
void efx_mcdi_mac_pull_stats(struct efx_nic *efx)
{
  
#line 979 
  __le64 *dma_stats = (__le64 *)efx->stats_buffer.addr;
  
#line 980 
  int attempts = 10;
  
#line 982 
  *(dma_stats + 96U) = 18446744073709551615ULL;
  
#line 983 
  efx_mcdi_mac_stats(efx,(enum efx_stats_action)EFX_STATS_PULL,0);
  
#line 985 
  goto ldv_56199;
  ldv_56198: 
#line 986 
  ;
  
#line 988 
  __const_udelay(429500UL);
  ldv_56199: 
#line 990 
  ;
  
#line 985 
  if (*(dma_stats + 96U) == 18446744073709551615ULL) {
    int tmp;
    
#line 986 
    tmp = attempts;
    
#line 986 
    attempts -= 1;
    
#line 986 
    ;
    
#line 986 
    if (tmp != 0) 
#line 989 
                  goto ldv_56198; else 
#line 992 
                                       goto ldv_56200;
  }
  else 
#line 992 
       goto ldv_56200;
  ldv_56200: 
#line 993 
  ;
  
#line 994 
  return;
}


#line 991  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
int efx_mcdi_port_probe(struct efx_nic *efx)
{
  int __retres;
  int rc;
  
#line 996 
  efx->phy_op = & efx_mcdi_phy_ops;
  
#line 999 
  efx->mdio.mode_support = 6U;
  
#line 1000 
  efx->mdio.mdio_read = & efx_mcdi_mdio_read;
  
#line 1001 
  efx->mdio.mdio_write = & efx_mcdi_mdio_write;
  
#line 1004 
  rc = (*((efx->phy_op)->probe))(efx);
  
#line 1005 
  if (rc != 0) {
    
#line 1006 
    __retres = rc;
    
#line 1006 
    goto return_label;
  }
  else ;
  
#line 1009 
  rc = efx_nic_alloc_buffer(efx,& efx->stats_buffer,776U,208U);
  
#line 1011 
  if (rc != 0) {
    
#line 1012 
    __retres = rc;
    
#line 1012 
    goto return_label;
  }
  else ;
  
#line 1013 
  if ((efx->msg_enable & 2U) != 0U) {
    
#line 1013 
    struct _ddebug descriptor = {.modname = "sfc", .function = "efx_mcdi_port_probe", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c", .format = "stats buffer at %llx (virt %p phys %llx)\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1017U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1013 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      phys_addr_t tmp;
      
#line 1013 
      tmp = virt_to_phys((void volatile *)efx->stats_buffer.addr);
      
#line 1013 
      ;
      
#line 1013 
      ;
      
#line 1013 
      ;
      
#line 1013 
      __dynamic_netdev_dbg(& descriptor,(struct net_device const *)efx->net_dev,"stats buffer at %llx (virt %p phys %llx)\n",efx->stats_buffer.dma_addr,efx->stats_buffer.addr,tmp);
    }
    else ;
  }
  else ;
  
#line 1019 
  efx_mcdi_mac_stats(efx,(enum efx_stats_action)EFX_STATS_DISABLE,1);
  
#line 1021 
  __retres = 0;
  return_label: 
#line 1021 
                return __retres;
}


#line 1024  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
void efx_mcdi_port_remove(struct efx_nic *efx)
{
  
#line 1026 
  (*((efx->phy_op)->remove))(efx);
  
#line 1027 
  efx_nic_free_buffer(efx,& efx->stats_buffer);
  
#line 1028 
  return;
}


#line 1031  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/sfc/mcdi_port.c"
int efx_mcdi_port_get_number(struct efx_nic *efx)
{
  int __retres;
  int rc;
  
#line 1033 
  efx_dword_t outbuf[1U] = {{.u32 = {0U}}};
  
#line 1036 
  rc = efx_mcdi_rpc(efx,184U,(efx_dword_t const *)0,0UL,(efx_dword_t *)(& outbuf),4UL,(size_t *)0UL);
  
#line 1038 
  if (rc != 0) {
    
#line 1039 
    __retres = rc;
    
#line 1039 
    goto return_label;
  }
  else ;
  
#line 1041 
  __retres = (int)((efx_dword_t *)(& outbuf))->u32[0];
  return_label: 
#line 1041 
                return __retres;
}


#line 441  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi_port.c.aux"
static void *kzalloc_11(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 444 
  tmp = ldv_kzalloc(size,flags);
  
#line 444 
  return tmp;
}


#line 888  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/weaver/.tmp_mcdi_port.c.aux"
static int ldv_mutex_is_locked_87(struct mutex *lock)
{
  int tmp;
  
#line 891 
  tmp = ldv_mutex_model_is_locked(lock,(char *)"mac_lock_of_efx_nic");
  
#line 891 
  return tmp;
}


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_add(int i, atomic_t *v)
{
  
#line 23 
  v->counter += i;
  
#line 24 
  return;
}


#line 27  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_sub(int i, atomic_t *v)
{
  
#line 29 
  v->counter -= i;
  
#line 30 
  return;
}


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_sub_and_test(int i, atomic_t *v)
{
  int __retres;
  
#line 35 
  v->counter -= i;
  
#line 36 
  if (v->counter != 0) {
    
#line 37 
    __retres = 0;
    
#line 37 
    goto return_label;
  }
  else ;
  
#line 39 
  __retres = 1;
  return_label: 
#line 39 
                return __retres;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_inc(atomic_t *v)
{
  
#line 45 
  v->counter += 1;
  
#line 46 
  return;
}


#line 49  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_dec(atomic_t *v)
{
  
#line 51 
  v->counter -= 1;
  
#line 52 
  return;
}


#line 55  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_dec_and_test(atomic_t *v)
{
  int __retres;
  
#line 57 
  v->counter -= 1;
  
#line 58 
  if (v->counter != 0) {
    
#line 59 
    __retres = 0;
    
#line 59 
    goto return_label;
  }
  else ;
  
#line 61 
  __retres = 1;
  return_label: 
#line 61 
                return __retres;
}


#line 65  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_inc_and_test(atomic_t *v)
{
  int __retres;
  
#line 67 
  v->counter += 1;
  
#line 68 
  if (v->counter != 0) {
    
#line 69 
    __retres = 0;
    
#line 69 
    goto return_label;
  }
  else ;
  
#line 71 
  __retres = 1;
  return_label: 
#line 71 
                return __retres;
}


#line 75  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_add_return(int i, atomic_t *v)
{
  int __retres;
  
#line 77 
  v->counter += i;
  
#line 78 
  __retres = v->counter;
  
#line 78 
  return __retres;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_add_negative(int i, atomic_t *v)
{
  int __retres;
  
#line 84 
  v->counter += i;
  
#line 85 
  __retres = v->counter < 0;
  
#line 85 
  return __retres;
}


#line 89  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_inc_short(short *v)
{
  int __retres;
  
#line 91 
  *v = (short)((unsigned int)*v + 1U);
  
#line 92 
  __retres = (int)*v;
  
#line 92 
  return __retres;
}


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/device.h"
void *ldv_dev_get_drvdata(struct device const *dev);


#line 24 
int ldv_dev_set_drvdata(struct device *dev, void *data);


#line 30  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_xmalloc(size_t size);


#line 31 
void *ldv_xzalloc(size_t size);


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
struct ldv_list_element global_list = {.data = (void *)0, .next = (struct ldv_list_element *)0};

#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
__inline static ldv_list_ptr ldv_list_create(void *data)
{
  
#line 35 
  ldv_list_ptr list = (struct ldv_list_element *)0;
  
#line 37 
  list = (ldv_list_ptr)ldv_xmalloc(16UL);
  
#line 39 
  list->data = data;
  
#line 40 
  list->next = (struct ldv_list_element *)0;
  
#line 42 
  return list;
}


#line 45  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
__inline static void ldv_save_pointer(void *data)
{
  ldv_list_ptr element;
  ldv_list_ptr cached;
  
#line 50 
  if (global_list.data == (void *)0) {
    
#line 51 
    element = & global_list;
    
#line 52 
    element->data = data;
  }
  else {
    
#line 54 
    element = ldv_list_create(data);
    
#line 55 
    cached = global_list.next;
    
#line 56 
    global_list.next = element;
    
#line 57 
    element->next = cached;
  }
  
#line 60 
  return;
}


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
void *ldv_dev_get_drvdata(struct device const *dev)
{
  void *__retres;
  
#line 30 
  if (dev != (struct device const *)0 && dev->p != (struct device_private *)0) {
    
#line 31 
    __retres = (dev->p)->driver_data;
    
#line 31 
    goto return_label;
  }
  else ;
  
#line 33 
  __retres = (void *)0;
  return_label: 
#line 33 
                return __retres;
}


#line 42  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
int ldv_dev_set_drvdata(struct device *dev, void *data)
{
  int __retres;
  
#line 44 
  dev->p = (struct device_private *)ldv_xzalloc(8UL);
  
#line 45 
  ldv_save_pointer((void *)dev->p);
  
#line 46 
  (dev->p)->driver_data = data;
  
#line 48 
  __retres = 0;
  
#line 48 
  return __retres;
}


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_zalloc(size_t size);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/spi.c"
struct spi_master *ldv_spi_alloc_master(struct device *host, unsigned int size)
{
  struct spi_master *__retres;
  struct spi_master *master;
  
#line 27 
  master = (struct spi_master *)ldv_zalloc((unsigned long)size + 2192UL);
  
#line 29 
  if (master == (struct spi_master *)0) {
    
#line 30 
    __retres = (struct spi_master *)0;
    
#line 30 
    goto return_label;
  }
  else ;
  
#line 32 
  ldv_dev_set_drvdata(& master->dev,(void *)(master + 1U));
  
#line 34 
  __retres = master;
  return_label: 
#line 34 
                return __retres;
}


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/err.h"
long ldv_is_err_or_null(void const *ptr);


#line 29 
void *ldv_err_ptr(long error);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/common.h"
void __VERIFIER_assume(int);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_is_err(void const *ptr)
{
  long __retres;
  
#line 23 
  __retres = (long)((unsigned long)ptr > 4294967295UL);
  
#line 23 
  return __retres;
}


#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
void *ldv_err_ptr(long error)
{
  void *__retres;
  
#line 28 
  __VERIFIER_assume(error < 0L);
  
#line 29 
  __retres = (void *)(4294967295L - error);
  
#line 29 
  return __retres;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_ptr_err(void const *ptr)
{
  long __retres;
  
#line 34 
  __VERIFIER_assume((unsigned long)ptr > 4294967295UL);
  
#line 35 
  __retres = (long)(4294967295UL - (unsigned long)ptr);
  
#line 35 
  return __retres;
}


#line 38  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_is_err_or_null(void const *ptr)
{
  long __retres;
  int tmp_0;
  
#line 40 
  if (ptr == (void const *)0) 
#line 40 
                              tmp_0 = 1;
  else {
    long tmp;
    
#line 40 
    tmp = ldv_is_err(ptr);
    
#line 40 
    if (tmp != 0L) 
#line 40 
                   tmp_0 = 1; else 
#line 40 
                                   tmp_0 = 0;
  }
  
#line 40 
  __retres = (long)tmp_0;
  
#line 40 
  return __retres;
}


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/panic.h"
void ldv_panic(void);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/kernel/panic.c"
void ldv_panic(void)
{
  
#line 23 
  __VERIFIER_assume(0);
  
#line 24 
  return;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.h"
void ldv_switch_to_interrupt_context(void);


#line 42 
void ldv_switch_to_process_context(void);


#line 50 
bool ldv_in_interrupt_context(void);


#line 112 
int ldv_post_init(int init_ret_val);


#line 132 
int ldv_post_probe(int probe_ret_val);


#line 133 
void ldv_check_return_value_probe(int);


#line 141 
int ldv_filter_err_code(int ret_val);


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
static bool __ldv_in_interrupt_context = (_Bool)0;

#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
void ldv_switch_to_interrupt_context(void)
{
  
#line 30 
  __ldv_in_interrupt_context = (_Bool)1;
  
#line 31 
  return;
}


#line 34  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
void ldv_switch_to_process_context(void)
{
  
#line 36 
  __ldv_in_interrupt_context = (_Bool)0;
  
#line 37 
  return;
}


#line 39  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
bool ldv_in_interrupt_context(void)
{
  
#line 41 
  return __ldv_in_interrupt_context;
}


#line 44  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
static int ldv_filter_positive_int(int val)
{
  
#line 46 
  __VERIFIER_assume(val <= 0);
  
#line 47 
  return val;
}


#line 54  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_post_init(int init_ret_val)
{
  int tmp;
  
#line 56 
  tmp = ldv_filter_positive_int(init_ret_val);
  
#line 56 
  return tmp;
}


#line 60  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_post_probe(int probe_ret_val)
{
  int tmp;
  
#line 62 
  ldv_check_return_value_probe(probe_ret_val);
  
#line 63 
  tmp = ldv_filter_positive_int(probe_ret_val);
  
#line 63 
  return tmp;
}


#line 67  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_filter_err_code(int ret_val)
{
  int tmp;
  
#line 69 
  tmp = ldv_filter_positive_int(ret_val);
  
#line 69 
  return tmp;
}


#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kmalloc_array(size_t n, size_t size, gfp_t flags);


#line 28 
void ldv_check_alloc_flags(gfp_t);


#line 29 
void ldv_after_alloc(void *);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_malloc(size_t size);


#line 24 
void *ldv_calloc(size_t nmemb, size_t size);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc(size_t size, gfp_t flags)
{
  void *res;
  
#line 25 
  ldv_check_alloc_flags(flags);
  
#line 26 
  res = ldv_malloc(size);
  
#line 27 
  ldv_after_alloc(res);
  
#line 29 
  return res;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kcalloc(size_t n, size_t size, gfp_t flags)
{
  void *res;
  
#line 36 
  ldv_check_alloc_flags(flags);
  
#line 37 
  res = ldv_calloc(n,size);
  
#line 38 
  ldv_after_alloc(res);
  
#line 40 
  return res;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kzalloc(size_t size, gfp_t flags)
{
  void *res;
  
#line 47 
  ldv_check_alloc_flags(flags);
  
#line 48 
  res = ldv_zalloc(size);
  
#line 49 
  ldv_after_alloc(res);
  
#line 51 
  return res;
}


#line 54  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc_array(size_t n, size_t size, gfp_t flags)
{
  void *res;
  
#line 58 
  ldv_check_alloc_flags(flags);
  
#line 59 
  res = ldv_malloc(n * size);
  
#line 60 
  ldv_after_alloc(res);
  
#line 62 
  return res;
}


#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void ldv_free(void *s);


#line 35 
void *ldv_malloc_unknown_size(void);


#line 36 
void *ldv_calloc_unknown_size(void);


#line 37 
void *ldv_zalloc_unknown_size(void);


#line 40 
void *ldv_reference_malloc(size_t size);


#line 41 
void *ldv_reference_calloc(size_t nmemb, size_t size);


#line 42 
void *ldv_reference_zalloc(size_t size);


#line 43 
void ldv_reference_free(void *s);


#line 47 
void *ldv_reference_xmalloc(size_t size);


#line 48 
void *ldv_reference_xzalloc(size_t size);


#line 52 
void *ldv_reference_malloc_unknown_size(void);


#line 53 
void *ldv_reference_calloc_unknown_size(void);


#line 54 
void *ldv_reference_zalloc_unknown_size(void);


#line 61 
void *ldv_xmalloc_unknown_size(size_t size);


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_reference_xmalloc_unknown_size(size_t size);


#line 34  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_malloc(size_t size)
{
  void *res;
  
#line 37 
  res = ldv_reference_malloc(size);
  
#line 38 
  if (res != (void *)0) {
    long tmp;
    
#line 39 
    tmp = ldv_is_err((void const *)res);
    
#line 39 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 40 
  return res;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc(size_t nmemb, size_t size)
{
  void *res;
  
#line 46 
  res = ldv_reference_calloc(nmemb,size);
  
#line 47 
  if (res != (void *)0) {
    long tmp;
    
#line 48 
    tmp = ldv_is_err((void const *)res);
    
#line 48 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 49 
  return res;
}


#line 52  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc(size_t size)
{
  void *res;
  
#line 55 
  res = ldv_reference_zalloc(size);
  
#line 56 
  if (res != (void *)0) {
    long tmp;
    
#line 57 
    tmp = ldv_is_err((void const *)res);
    
#line 57 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 58 
  return res;
}


#line 61  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void ldv_free(void *s)
{
  
#line 63 
  ldv_reference_free(s);
  
#line 64 
  return;
}


#line 66  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc(size_t size)
{
  void *res;
  long tmp;
  
#line 69 
  res = ldv_reference_xmalloc(size);
  
#line 70 
  tmp = ldv_is_err((void const *)res);
  
#line 70 
  __VERIFIER_assume(tmp == 0L);
  
#line 71 
  return res;
}


#line 74  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xzalloc(size_t size)
{
  void *res;
  long tmp;
  
#line 77 
  res = ldv_reference_xzalloc(size);
  
#line 78 
  tmp = ldv_is_err((void const *)res);
  
#line 78 
  __VERIFIER_assume(tmp == 0L);
  
#line 79 
  return res;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_malloc_unknown_size(void)
{
  void *res;
  
#line 85 
  res = ldv_reference_malloc_unknown_size();
  
#line 86 
  if (res != (void *)0) {
    long tmp;
    
#line 87 
    tmp = ldv_is_err((void const *)res);
    
#line 87 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 88 
  return res;
}


#line 91  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc_unknown_size(void)
{
  void *res;
  
#line 94 
  res = ldv_reference_calloc_unknown_size();
  
#line 95 
  if (res != (void *)0) {
    long tmp;
    
#line 96 
    tmp = ldv_is_err((void const *)res);
    
#line 96 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 97 
  return res;
}


#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc_unknown_size(void)
{
  void *res;
  
#line 103 
  res = ldv_reference_zalloc_unknown_size();
  
#line 104 
  if (res != (void *)0) {
    long tmp;
    
#line 105 
    tmp = ldv_is_err((void const *)res);
    
#line 105 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 106 
  return res;
}


#line 109  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc_unknown_size(size_t size)
{
  void *res;
  long tmp;
  
#line 112 
  res = ldv_reference_xmalloc_unknown_size(size);
  
#line 113 
  tmp = ldv_is_err((void const *)res);
  
#line 113 
  __VERIFIER_assume(tmp == 0L);
  
#line 114 
  return res;
}

long __builtin_expect(long exp, long c);


#line 22  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/common.h"
void __VERIFIER_error(void);


#line 24  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/gcc.c"
long __builtin_expect(long exp, long c)
{
  
#line 26 
  return exp;
}


#line 35  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/gcc.c"
void __builtin_trap(void)
{
  
#line 37 
  __VERIFIER_error();
  
#line 38 
  return;
}


#line 24  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
int ldv_undef_long(void);


#line 25 
unsigned int ldv_undef_uint(void);


#line 26 
unsigned long ldv_undef_ulong(void);


#line 27 
unsigned long long ldv_undef_ulonglong(void);


#line 28 
void *ldv_undef_ptr(void);


#line 31 
int ldv_undef_int_positive(void);


#line 34 
int ldv_undef_int_negative(void);


#line 37 
int ldv_undef_int_nonpositive(void);


#line 40 
void *ldv_undef_ptr_non_null(void);


#line 29  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int __VERIFIER_nondet_int(void);


#line 31 
long __VERIFIER_nondet_long(void);


#line 38 
unsigned int __VERIFIER_nondet_uint(void);


#line 41 
unsigned long __VERIFIER_nondet_ulong(void);


#line 42 
unsigned long long __VERIFIER_nondet_ulonglong(void);


#line 43 
void *__VERIFIER_nondet_pointer(void);


#line 46  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int(void)
{
  int tmp;
  
#line 48 
  tmp = __VERIFIER_nondet_int();
  
#line 48 
  return tmp;
}


#line 51  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_long(void)
{
  int __retres;
  long tmp;
  
#line 53 
  tmp = __VERIFIER_nondet_long();
  
#line 53 
  __retres = (int)tmp;
  
#line 53 
  return __retres;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned int ldv_undef_uint(void)
{
  unsigned int tmp;
  
#line 58 
  tmp = __VERIFIER_nondet_uint();
  
#line 58 
  return tmp;
}


#line 61  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr(void)
{
  void *tmp;
  
#line 63 
  tmp = __VERIFIER_nondet_pointer();
  
#line 63 
  return tmp;
}


#line 66  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long ldv_undef_ulong(void)
{
  unsigned long tmp;
  
#line 68 
  tmp = __VERIFIER_nondet_ulong();
  
#line 68 
  return tmp;
}


#line 71  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long long ldv_undef_ulonglong(void)
{
  unsigned long long tmp;
  
#line 73 
  tmp = __VERIFIER_nondet_ulonglong();
  
#line 73 
  return tmp;
}


#line 76  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_positive(void)
{
  
#line 78 
  int ret = ldv_undef_int();
  
#line 80 
  __VERIFIER_assume(ret > 0);
  
#line 82 
  return ret;
}


#line 85  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_negative(void)
{
  
#line 87 
  int ret = ldv_undef_int();
  
#line 89 
  __VERIFIER_assume(ret < 0);
  
#line 91 
  return ret;
}


#line 94  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_nonpositive(void)
{
  
#line 96 
  int ret = ldv_undef_int();
  
#line 98 
  __VERIFIER_assume(ret <= 0);
  
#line 100 
  return ret;
}


#line 103  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr_non_null(void)
{
  
#line 105 
  void *ret = ldv_undef_ptr();
  
#line 107 
  __VERIFIER_assume(ret != (void *)0);
  
#line 109 
  return ret;
}


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *external_allocated_data(void);


#line 45 
void *ldv_reference_realloc(void *ptr, size_t size);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *malloc(size_t);


#line 24 
void *calloc(size_t, size_t);


#line 25 
void free(void *);


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc(size_t size)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 37 
  tmp = ldv_undef_int();
  
#line 37 
  if (tmp != 0) {
    
#line 39 
    res = malloc(size);
    
#line 40 
    __VERIFIER_assume(res != (void *)0);
    
#line 41 
    __retres = res;
    
#line 41 
    goto return_label;
  }
  else {
    
#line 44 
    __retres = (void *)0;
    
#line 44 
    goto return_label;
  }
  return_label: 
#line 37 
                return __retres;
}


#line 47  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc(size_t nmemb, size_t size)
{
  void *tmp;
  
#line 49 
  tmp = calloc(nmemb,size);
  
#line 49 
  return tmp;
}


#line 52  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc(size_t size)
{
  void *tmp;
  
#line 54 
  tmp = calloc(1UL,size);
  
#line 54 
  return tmp;
}


#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void ldv_reference_free(void *s)
{
  
#line 59 
  free(s);
  
#line 60 
  return;
}


#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_realloc(void *ptr, size_t size)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 66 
  if (ptr != (void *)0 && size == 0UL) {
    
#line 67 
    free(ptr);
    
#line 68 
    __retres = (void *)0;
    
#line 68 
    goto return_label;
  }
  else ;
  
#line 71 
  if (ptr == (void *)0) {
    
#line 72 
    res = malloc(size);
    
#line 73 
    __retres = res;
    
#line 73 
    goto return_label;
  }
  else ;
  
#line 76 
  tmp = ldv_undef_int();
  
#line 76 
  if (tmp != 0) {
    
#line 78 
    res = malloc(size);
    
#line 79 
    __VERIFIER_assume(res != (void *)0);
    
#line 81 
    memcpy(res,(void const *)ptr,size);
    
#line 82 
    free(ptr);
    
#line 84 
    __retres = res;
    
#line 84 
    goto return_label;
  }
  else {
    
#line 87 
    __retres = (void *)0;
    
#line 87 
    goto return_label;
  }
  return_label: 
#line 76 
                return __retres;
}


#line 90  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc(size_t size)
{
  void *res;
  
#line 94 
  res = malloc(size);
  
#line 95 
  __VERIFIER_assume(res != (void *)0);
  
#line 97 
  return res;
}


#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xzalloc(size_t size)
{
  void *res;
  
#line 104 
  res = calloc(1UL,size);
  
#line 105 
  __VERIFIER_assume(res != (void *)0);
  
#line 107 
  return res;
}


#line 110  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc_unknown_size(void)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 114 
  tmp = ldv_undef_int();
  
#line 114 
  if (tmp != 0) {
    
#line 115 
    res = external_allocated_data();
    
#line 116 
    __VERIFIER_assume(res != (void *)0);
    
#line 117 
    __retres = res;
    
#line 117 
    goto return_label;
  }
  else {
    
#line 120 
    __retres = (void *)0;
    
#line 120 
    goto return_label;
  }
  return_label: 
#line 114 
                return __retres;
}


#line 123  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc_unknown_size(void)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 127 
  tmp = ldv_undef_int();
  
#line 127 
  if (tmp != 0) {
    
#line 128 
    res = external_allocated_data();
    
#line 129 
    memset(res,0,8UL);
    
#line 130 
    __VERIFIER_assume(res != (void *)0);
    
#line 131 
    __retres = res;
    
#line 131 
    goto return_label;
  }
  else {
    
#line 134 
    __retres = (void *)0;
    
#line 134 
    goto return_label;
  }
  return_label: 
#line 127 
                return __retres;
}


#line 137  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc_unknown_size(void)
{
  void *tmp;
  
#line 139 
  tmp = ldv_reference_calloc_unknown_size();
  
#line 139 
  return tmp;
}


#line 142  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc_unknown_size(size_t size)
{
  void *res;
  
#line 146 
  res = external_allocated_data();
  
#line 147 
  __VERIFIER_assume(res != (void *)0);
  
#line 149 
  return res;
}


#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.h"
void ldv_initialize(void);


#line 123 
void ldv_pre_probe(void);


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
int pthread_create(pthread_t *, pthread_attr_t const *, void *(*)(void *), void *);


#line 37 
int pthread_join(pthread_t, void **);


#line 75  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_devattr_instance_21(void *arg0);


#line 78 
int main(void);


#line 79 
void *ldv_timer_scenario_22(void *arg0);


#line 81 
void *ldv_interrupt_scenario_24(void *arg0);


#line 82 
void ldv_dispatch_irq_deregister_8_1(int arg0);


#line 83 
void *ldv_devattr_instance_19(void *arg0);


#line 85 
void ldv_dispatch_deregister_7_1(struct device *arg0, struct device_attribute *arg1);


#line 86 
void ldv_dispatch_instance_register_3_3(struct timer_list *arg0);


#line 87 
void ldv_dispatch_register_11_3(struct pci_driver *arg0);


#line 88 
void ldv_dispatch_irq_register_13_3(int arg0, enum irqreturn (*arg1)(int , void *), enum irqreturn (*arg2)(int , void *), void *arg3);


#line 89 
void ldv_dispatch_register_12_3(struct device *arg0, struct device_attribute *arg1);


#line 94 
void ldv_dispatch_deregister_10_1(struct pci_driver *arg0);


#line 98 
void *ldv_pm_ops_scenario_23(void *arg0);


#line 99 
void *ldv_initialization_1(void *arg0);


#line 102 
void *ldv_devattr_instance_20(void *arg0);


#line 103 
void *ldv_devattr_instance_16(void *arg0);


#line 104 
void *ldv_pci_scenario_18(void *arg0);


#line 105 
void *ldv_devattr_instance_17(void *arg0);


#line 106 
void ldv_dispatch_instance_deregister_14_1(struct timer_list *arg0);


#line 110  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_17;

#line 111  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_21;

#line 112  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_16;

#line 113  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_19;

#line 114  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_24;

#line 115  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_22;

#line 116  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_18;

#line 117  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_20;

#line 118  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_23;

#line 122  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_devattr_instance_21(void *arg0)
{
  void *__retres;
  char *ldv_21_ldv_param_2_4;
  unsigned long ldv_21_ldv_param_3_3;
  char *ldv_21_ldv_param_2_2;
  struct device *ldv_21_device;
  int tmp;
  
#line 125 
  struct device_attribute *ldv_21_devattr = ldv_emg_alias_dev_attr_phy_type_3;
  
#line 131 
  struct ldv_struct_devattr_instance_16 *data = (struct ldv_struct_devattr_instance_16 *)arg0;
  
#line 136 
  if (data != (struct ldv_struct_devattr_instance_16 *)0) {
    
#line 137 
    ldv_21_device = data->arg0;
    
#line 138 
    ldv_21_devattr = data->arg1;
    
#line 139 
    ldv_free((void *)data);
  }
  else ;
  
#line 147 
  goto ldv_main_21;
  
#line 149 
  __retres = (void *)0;
  
#line 149 
  goto return_label;
  ldv_main_21: 
#line 152 
  ;
  
#line 155 
  tmp = ldv_undef_int();
  
#line 155 
  switch (tmp) {
    case 1: 
#line 156 
    ;
    
#line 158 
    ldv_21_ldv_param_2_4 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 163 
    ldv_emg_wrapper_show_phy_type_2(ldv_21_device,ldv_21_devattr,ldv_21_ldv_param_2_4);
    
#line 167 
    ldv_free((void *)ldv_21_ldv_param_2_4);
    
#line 174 
    goto ldv_main_21;
    case 2: 
#line 177 
    ;
    
#line 179 
    ldv_21_ldv_param_2_2 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 183 
    if (ldv_21_devattr->store != (ssize_t (*)(struct device *, struct device_attribute *, char const *, size_t ))0) 
      
#line 185 
      (*(ldv_21_devattr->store))(ldv_21_device,ldv_21_devattr,(char const *)ldv_21_ldv_param_2_2,ldv_21_ldv_param_3_3); else ;
    
#line 190 
    ldv_free((void *)ldv_21_ldv_param_2_2);
    
#line 197 
    goto ldv_main_21;
    case 3: 
#line 200 
    ;
    
#line 206 
    __retres = (void *)0;
    
#line 206 
    goto return_label;
    default: 
#line 209 
    ;
    
#line 209 
    __VERIFIER_assume(0);
  }
  
#line 212 
  __retres = (void *)0;
  return_label: 
#line 212 
                return __retres;
}


#line 217  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
_Bool ldv_emg_schedule_delayed_work(struct delayed_work *arg0, unsigned long arg1)
{
  _Bool __retres;
  struct work_struct *ldv_9_ldv_param_0_2;
  struct delayed_work *ldv_9_delayed_work;
  int tmp_0;
  
#line 225 
  tmp_0 = ldv_undef_int();
  
#line 225 
  if (tmp_0 != 0) {
    
#line 227 
    ldv_9_delayed_work = arg0;
    
#line 231 
    ldv_9_ldv_param_0_2 = (struct work_struct *)ldv_xmalloc_unknown_size(0UL);
    
#line 235 
    if (ldv_9_delayed_work->work.func != (void (*)(struct work_struct *))0) 
      
#line 237 
      (*(ldv_9_delayed_work->work.func))(ldv_9_ldv_param_0_2); else ;
    
#line 242 
    ldv_free((void *)ldv_9_ldv_param_0_2);
    
#line 246 
    __retres = (_Bool)1;
    
#line 246 
    goto return_label;
  }
  else {
    
#line 253 
    __retres = (_Bool)0;
    
#line 253 
    goto return_label;
  }
  return_label: 
#line 225 
                return __retres;
}


#line 263  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg___pci_register_driver(struct pci_driver *arg0, struct module *arg1, char *arg2)
{
  int __retres;
  int tmp_0;
  
#line 266 
  struct pci_driver *ldv_11_pci_driver = ldv_emg_alias_efx_pci_driver_2;
  
#line 270 
  tmp_0 = ldv_undef_int();
  
#line 270 
  if (tmp_0 != 0) {
    
#line 272 
    ldv_11_pci_driver = arg0;
    
#line 276 
    ldv_dispatch_register_11_3(ldv_11_pci_driver);
    
#line 280 
    __retres = 0;
    
#line 280 
    goto return_label;
  }
  else {
    int tmp;
    
#line 287 
    tmp = ldv_undef_int_negative();
    
#line 287 
    __retres = tmp;
    
#line 287 
    goto return_label;
  }
  return_label: 
#line 270 
                return __retres;
}


#line 297  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
int main(void)
{
  int __retres;
  
#line 300 
  ldv_initialize();
  
#line 303 
  ldv_initialization_1((void *)0);
  
#line 305 
  __retres = 0;
  
#line 305 
  return __retres;
}


#line 310  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_timer_scenario_22(void *arg0)
{
  void *__retres;
  struct timer_list *ldv_22_container;
  
#line 315 
  struct ldv_struct_timer_scenario_22 *data = (struct ldv_struct_timer_scenario_22 *)arg0;
  
#line 320 
  if (data != (struct ldv_struct_timer_scenario_22 *)0) {
    
#line 321 
    ldv_22_container = data->arg0;
    
#line 322 
    ldv_free((void *)data);
  }
  else ;
  
#line 327 
  if (ldv_22_container->function != (void (*)(unsigned long ))0) {
    
#line 329 
    ldv_switch_to_interrupt_context();
    
#line 331 
    (*(ldv_22_container->function))(ldv_22_container->data);
    
#line 333 
    ldv_switch_to_process_context();
  }
  else ;
  
#line 342 
  __retres = (void *)0;
  
#line 342 
  goto return_label;
  
#line 344 
  __retres = (void *)0;
  return_label: 
#line 344 
                return __retres;
}


#line 349  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
struct net_device *ldv_emg_alloc_etherdev_mqs(int arg0, unsigned int arg1, unsigned int arg2)
{
  struct net_device *__retres;
  struct net_device *ldv_4_netdev;
  int tmp_0;
  
#line 356 
  tmp_0 = ldv_undef_int();
  
#line 356 
  if (tmp_0 != 0) {
    
#line 358 
    ldv_4_netdev = (struct net_device *)ldv_xmalloc_unknown_size(0UL);
    
#line 362 
    __retres = ldv_4_netdev;
    
#line 362 
    goto return_label;
  }
  else {
    
#line 369 
    __retres = (struct net_device *)0;
    
#line 369 
    goto return_label;
  }
  return_label: 
#line 356 
                return __retres;
}


#line 379  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_instance_register_3_3(struct timer_list *arg0)
{
  int ret;
  struct ldv_struct_timer_scenario_22 *cf_arg_22;
  int tmp;
  
#line 382 
  tmp = ldv_undef_int();
  
#line 382 
  switch (tmp) {
    case 0: 
#line 383 
    ;
    
#line 384 
    cf_arg_22 = (struct ldv_struct_timer_scenario_22 *)ldv_xmalloc(16UL);
    
#line 385 
    cf_arg_22->arg0 = arg0;
    
#line 386 
    ret = pthread_create(& ldv_thread_22,(pthread_attr_t const *)0,& ldv_timer_scenario_22,(void *)cf_arg_22);
    
#line 387 
    __VERIFIER_assume(ret == 0);
    
#line 388 
    goto ldv_44930;
    default: 
#line 390 
    ;
    
#line 390 
    __VERIFIER_assume(0);
  }
  ldv_44930: 
#line 391 
  ;
  
#line 392 
  return;
}


#line 396  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_irq_deregister_8_1(int arg0)
{
  int ret;
  struct ldv_struct_free_irq_8 *cf_arg_24;
  int tmp;
  
#line 399 
  tmp = ldv_undef_int();
  
#line 399 
  switch (tmp) {
    case 0: 
#line 400 
    ;
    
#line 401 
    ret = pthread_join(ldv_thread_24,(void **)0);
    
#line 402 
    __VERIFIER_assume(ret == 0);
    
#line 403 
    goto ldv_44938;
    default: 
#line 405 
    ;
    
#line 405 
    __VERIFIER_assume(0);
  }
  ldv_44938: 
#line 406 
  ;
  
#line 407 
  return;
}


#line 411  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_devattr_instance_19(void *arg0)
{
  void *__retres;
  char *ldv_19_ldv_param_2_4;
  unsigned long ldv_19_ldv_param_3_3;
  char *ldv_19_ldv_param_2_2;
  struct device *ldv_19_device;
  int tmp;
  
#line 414 
  struct device_attribute *ldv_19_devattr = ldv_emg_alias_dev_attr_primary_flag_3;
  
#line 420 
  struct ldv_struct_devattr_instance_16 *data = (struct ldv_struct_devattr_instance_16 *)arg0;
  
#line 425 
  if (data != (struct ldv_struct_devattr_instance_16 *)0) {
    
#line 426 
    ldv_19_device = data->arg0;
    
#line 427 
    ldv_19_devattr = data->arg1;
    
#line 428 
    ldv_free((void *)data);
  }
  else ;
  
#line 436 
  goto ldv_main_19;
  
#line 438 
  __retres = (void *)0;
  
#line 438 
  goto return_label;
  ldv_main_19: 
#line 441 
  ;
  
#line 444 
  tmp = ldv_undef_int();
  
#line 444 
  switch (tmp) {
    case 1: 
#line 445 
    ;
    
#line 447 
    ldv_19_ldv_param_2_4 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 452 
    ldv_emg_wrapper_efx_ef10_show_primary_flag_2(ldv_19_device,ldv_19_devattr,ldv_19_ldv_param_2_4);
    
#line 456 
    ldv_free((void *)ldv_19_ldv_param_2_4);
    
#line 463 
    goto ldv_main_19;
    case 2: 
#line 466 
    ;
    
#line 468 
    ldv_19_ldv_param_2_2 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 472 
    if (ldv_19_devattr->store != (ssize_t (*)(struct device *, struct device_attribute *, char const *, size_t ))0) 
      
#line 474 
      (*(ldv_19_devattr->store))(ldv_19_device,ldv_19_devattr,(char const *)ldv_19_ldv_param_2_2,ldv_19_ldv_param_3_3); else ;
    
#line 479 
    ldv_free((void *)ldv_19_ldv_param_2_2);
    
#line 486 
    goto ldv_main_19;
    case 3: 
#line 489 
    ;
    
#line 495 
    __retres = (void *)0;
    
#line 495 
    goto return_label;
    default: 
#line 498 
    ;
    
#line 498 
    __VERIFIER_assume(0);
  }
  
#line 501 
  __retres = (void *)0;
  return_label: 
#line 501 
                return __retres;
}


#line 506  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_request_irq(unsigned int arg0, enum irqreturn (*arg1)(int , void *), unsigned long arg2, char *arg3, void *arg4)
{
  int __retres;
  int ldv_13_line;
  void *ldv_13_data;
  enum irqreturn (*ldv_13_callback)(int , void *);
  enum irqreturn (*ldv_13_thread)(int , void *);
  int tmp_0;
  
#line 516 
  tmp_0 = ldv_undef_int();
  
#line 516 
  if (tmp_0 != 0) {
    
#line 518 
    ldv_13_line = (int)arg0;
    
#line 519 
    ldv_13_callback = arg1;
    
#line 520 
    ldv_13_thread = (enum irqreturn (*)(int , void *))0;
    
#line 521 
    ldv_13_data = arg4;
    
#line 525 
    ldv_dispatch_irq_register_13_3(ldv_13_line,ldv_13_callback,ldv_13_thread,ldv_13_data);
    
#line 529 
    __retres = 0;
    
#line 529 
    goto return_label;
  }
  else {
    int tmp;
    
#line 536 
    tmp = ldv_undef_int_negative();
    
#line 536 
    __retres = tmp;
    
#line 536 
    goto return_label;
  }
  return_label: 
#line 516 
                return __retres;
}


#line 546  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_register_11_3(struct pci_driver *arg0)
{
  int ret;
  struct ldv_struct_pci_scenario_18 *cf_arg_18;
  int tmp;
  
#line 549 
  tmp = ldv_undef_int();
  
#line 549 
  switch (tmp) {
    case 0: 
#line 550 
    ;
    
#line 551 
    cf_arg_18 = (struct ldv_struct_pci_scenario_18 *)ldv_xmalloc(16UL);
    
#line 552 
    cf_arg_18->arg0 = arg0;
    
#line 553 
    ret = pthread_create(& ldv_thread_18,(pthread_attr_t const *)0,& ldv_pci_scenario_18,(void *)cf_arg_18);
    
#line 554 
    __VERIFIER_assume(ret == 0);
    
#line 555 
    goto ldv_44977;
    default: 
#line 557 
    ;
    
#line 557 
    __VERIFIER_assume(0);
  }
  ldv_44977: 
#line 558 
  ;
  
#line 559 
  return;
}


#line 563  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_deregister_7_1(struct device *arg0, struct device_attribute *arg1)
{
  int ret;
  struct ldv_struct_devattr_instance_16 *cf_arg_16;
  struct ldv_struct_devattr_instance_16 *cf_arg_17;
  struct ldv_struct_devattr_instance_16 *cf_arg_19;
  struct ldv_struct_devattr_instance_16 *cf_arg_20;
  struct ldv_struct_devattr_instance_16 *cf_arg_21;
  int tmp;
  
#line 570 
  tmp = ldv_undef_int();
  
#line 570 
  switch (tmp) {
    case 0: 
#line 571 
    ;
    
#line 572 
    ret = pthread_join(ldv_thread_16,(void **)0);
    
#line 573 
    __VERIFIER_assume(ret == 0);
    
#line 574 
    goto ldv_44990;
    case 1: 
#line 576 
    ;
    
#line 577 
    ret = pthread_join(ldv_thread_17,(void **)0);
    
#line 578 
    __VERIFIER_assume(ret == 0);
    
#line 579 
    goto ldv_44990;
    case 2: 
#line 581 
    ;
    
#line 582 
    ret = pthread_join(ldv_thread_19,(void **)0);
    
#line 583 
    __VERIFIER_assume(ret == 0);
    
#line 584 
    goto ldv_44990;
    case 3: 
#line 586 
    ;
    
#line 587 
    ret = pthread_join(ldv_thread_20,(void **)0);
    
#line 588 
    __VERIFIER_assume(ret == 0);
    
#line 589 
    goto ldv_44990;
    case 4: 
#line 591 
    ;
    
#line 592 
    ret = pthread_join(ldv_thread_21,(void **)0);
    
#line 593 
    __VERIFIER_assume(ret == 0);
    
#line 594 
    goto ldv_44990;
    default: 
#line 596 
    ;
    
#line 596 
    __VERIFIER_assume(0);
  }
  ldv_44990: 
#line 597 
  ;
  
#line 598 
  return;
}


#line 602  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_interrupt_scenario_24(void *arg0)
{
  void *__retres;
  enum irqreturn ldv_24_ret_val;
  int ldv_24_line;
  void *ldv_24_data;
  enum irqreturn (*ldv_24_callback)(int , void *);
  enum irqreturn (*ldv_24_thread)(int , void *);
  int tmp_0;
  
#line 611 
  struct ldv_struct_interrupt_scenario_24 *data = (struct ldv_struct_interrupt_scenario_24 *)arg0;
  
#line 616 
  if (data != (struct ldv_struct_interrupt_scenario_24 *)0) {
    
#line 617 
    ldv_24_line = data->arg0;
    
#line 618 
    ldv_24_callback = data->arg1;
    
#line 619 
    ldv_24_thread = data->arg2;
    
#line 620 
    ldv_24_data = data->arg3;
    
#line 621 
    ldv_free((void *)data);
  }
  else ;
  
#line 626 
  if (ldv_24_callback != (enum irqreturn (*)(int , void *))0) {
    
#line 628 
    ldv_switch_to_interrupt_context();
    
#line 630 
    ldv_24_ret_val = (*ldv_24_callback)(ldv_24_line,ldv_24_data);
    
#line 632 
    ldv_switch_to_process_context();
  }
  else {
    int tmp;
    
#line 634 
    tmp = ldv_undef_int();
    
#line 634 
    ldv_24_ret_val = (enum irqreturn)tmp;
  }
  
#line 638 
  tmp_0 = ldv_undef_int();
  
#line 638 
  if (tmp_0 != 0) {
    
#line 640 
    __VERIFIER_assume(ldv_24_ret_val == (unsigned int)IRQ_WAKE_THREAD);
    
#line 644 
    if (ldv_24_thread != (enum irqreturn (*)(int , void *))0) 
#line 646 
                                                              (*ldv_24_thread)(ldv_24_line,ldv_24_data); else ;
  }
  else 
#line 653 
       __VERIFIER_assume(ldv_24_ret_val != (unsigned int)IRQ_WAKE_THREAD);
  
#line 662 
  __retres = (void *)0;
  
#line 662 
  goto return_label;
  
#line 664 
  __retres = (void *)0;
  return_label: 
#line 664 
                return __retres;
}


#line 669  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_irq_register_13_3(int arg0, enum irqreturn (*arg1)(int , void *), enum irqreturn (*arg2)(int , void *), void *arg3)
{
  int ret;
  struct ldv_struct_interrupt_scenario_24 *cf_arg_24;
  int tmp;
  
#line 672 
  tmp = ldv_undef_int();
  
#line 672 
  switch (tmp) {
    case 0: 
#line 673 
    ;
    
#line 674 
    cf_arg_24 = (struct ldv_struct_interrupt_scenario_24 *)ldv_xmalloc(32UL);
    
#line 675 
    cf_arg_24->arg0 = arg0;
    
#line 676 
    cf_arg_24->arg1 = arg1;
    
#line 677 
    cf_arg_24->arg2 = arg2;
    
#line 678 
    cf_arg_24->arg3 = arg3;
    
#line 679 
    ret = pthread_create(& ldv_thread_24,(pthread_attr_t const *)0,& ldv_interrupt_scenario_24,(void *)cf_arg_24);
    
#line 680 
    __VERIFIER_assume(ret == 0);
    
#line 681 
    goto ldv_45022;
    default: 
#line 683 
    ;
    
#line 683 
    __VERIFIER_assume(0);
  }
  ldv_45022: 
#line 684 
  ;
  
#line 685 
  return;
}


#line 689  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_register_12_3(struct device *arg0, struct device_attribute *arg1)
{
  int ret;
  struct ldv_struct_devattr_instance_16 *cf_arg_16;
  struct ldv_struct_devattr_instance_16 *cf_arg_17;
  struct ldv_struct_devattr_instance_16 *cf_arg_19;
  struct ldv_struct_devattr_instance_16 *cf_arg_20;
  struct ldv_struct_devattr_instance_16 *cf_arg_21;
  int tmp;
  
#line 696 
  tmp = ldv_undef_int();
  
#line 696 
  switch (tmp) {
    case 0: 
#line 697 
    ;
    
#line 698 
    cf_arg_16 = (struct ldv_struct_devattr_instance_16 *)ldv_xmalloc(24UL);
    
#line 699 
    cf_arg_16->arg0 = arg0;
    
#line 700 
    cf_arg_16->arg1 = arg1;
    
#line 701 
    ret = pthread_create(& ldv_thread_16,(pthread_attr_t const *)0,& ldv_devattr_instance_16,(void *)cf_arg_16);
    
#line 702 
    __VERIFIER_assume(ret == 0);
    
#line 703 
    goto ldv_45035;
    case 1: 
#line 705 
    ;
    
#line 706 
    cf_arg_17 = (struct ldv_struct_devattr_instance_16 *)ldv_xmalloc(24UL);
    
#line 707 
    cf_arg_17->arg0 = arg0;
    
#line 708 
    cf_arg_17->arg1 = arg1;
    
#line 709 
    ret = pthread_create(& ldv_thread_17,(pthread_attr_t const *)0,& ldv_devattr_instance_17,(void *)cf_arg_17);
    
#line 710 
    __VERIFIER_assume(ret == 0);
    
#line 711 
    goto ldv_45035;
    case 2: 
#line 713 
    ;
    
#line 714 
    cf_arg_19 = (struct ldv_struct_devattr_instance_16 *)ldv_xmalloc(24UL);
    
#line 715 
    cf_arg_19->arg0 = arg0;
    
#line 716 
    cf_arg_19->arg1 = arg1;
    
#line 717 
    ret = pthread_create(& ldv_thread_19,(pthread_attr_t const *)0,& ldv_devattr_instance_19,(void *)cf_arg_19);
    
#line 718 
    __VERIFIER_assume(ret == 0);
    
#line 719 
    goto ldv_45035;
    case 3: 
#line 721 
    ;
    
#line 722 
    cf_arg_20 = (struct ldv_struct_devattr_instance_16 *)ldv_xmalloc(24UL);
    
#line 723 
    cf_arg_20->arg0 = arg0;
    
#line 724 
    cf_arg_20->arg1 = arg1;
    
#line 725 
    ret = pthread_create(& ldv_thread_20,(pthread_attr_t const *)0,& ldv_devattr_instance_20,(void *)cf_arg_20);
    
#line 726 
    __VERIFIER_assume(ret == 0);
    
#line 727 
    goto ldv_45035;
    case 4: 
#line 729 
    ;
    
#line 730 
    cf_arg_21 = (struct ldv_struct_devattr_instance_16 *)ldv_xmalloc(24UL);
    
#line 731 
    cf_arg_21->arg0 = arg0;
    
#line 732 
    cf_arg_21->arg1 = arg1;
    
#line 733 
    ret = pthread_create(& ldv_thread_21,(pthread_attr_t const *)0,& ldv_devattr_instance_21,(void *)cf_arg_21);
    
#line 734 
    __VERIFIER_assume(ret == 0);
    
#line 735 
    goto ldv_45035;
    default: 
#line 737 
    ;
    
#line 737 
    __VERIFIER_assume(0);
  }
  ldv_45035: 
#line 738 
  ;
  
#line 739 
  return;
}


#line 743  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_device_create_file(struct device *arg0, struct device_attribute *arg1)
{
  int __retres;
  struct device_attribute *ldv_12_devattr;
  struct device *ldv_12_device;
  int tmp_0;
  
#line 751 
  tmp_0 = ldv_undef_int();
  
#line 751 
  if (tmp_0 != 0) {
    
#line 753 
    ldv_12_device = arg0;
    
#line 754 
    ldv_12_devattr = arg1;
    
#line 758 
    ldv_dispatch_register_12_3(ldv_12_device,ldv_12_devattr);
    
#line 762 
    __retres = 0;
    
#line 762 
    goto return_label;
  }
  else {
    int tmp;
    
#line 769 
    tmp = ldv_undef_int_negative();
    
#line 769 
    __retres = tmp;
    
#line 769 
    goto return_label;
  }
  return_label: 
#line 751 
                return __retres;
}


#line 779  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_device_remove_file(struct device *arg0, struct device_attribute *arg1)
{
  struct device_attribute *ldv_7_devattr;
  struct device *ldv_7_device;
  
#line 786 
  ldv_7_device = arg0;
  
#line 787 
  ldv_7_devattr = arg1;
  
#line 791 
  ldv_dispatch_deregister_7_1(ldv_7_device,ldv_7_devattr);
  
#line 795 
  goto return_label;
  return_label: 
#line 797 
                return;
}


#line 802  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_instance_deregister_14_1(struct timer_list *arg0)
{
  int ret;
  struct ldv_struct_timer_scenario_22 *cf_arg_22;
  int tmp;
  
#line 805 
  tmp = ldv_undef_int();
  
#line 805 
  switch (tmp) {
    case 0: 
#line 806 
    ;
    
#line 807 
    ret = pthread_join(ldv_thread_22,(void **)0);
    
#line 808 
    __VERIFIER_assume(ret == 0);
    
#line 809 
    goto ldv_45059;
    default: 
#line 811 
    ;
    
#line 811 
    __VERIFIER_assume(0);
  }
  ldv_45059: 
#line 812 
  ;
  
#line 813 
  return;
}


#line 817  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
_Bool ldv_emg_queue_delayed_work(struct workqueue_struct *arg0, struct delayed_work *arg1, unsigned long arg2)
{
  _Bool __retres;
  struct work_struct *ldv_6_ldv_param_0_2;
  struct delayed_work *ldv_6_delayed_work;
  int tmp_0;
  
#line 825 
  tmp_0 = ldv_undef_int();
  
#line 825 
  if (tmp_0 != 0) {
    
#line 827 
    ldv_6_delayed_work = arg1;
    
#line 831 
    ldv_6_ldv_param_0_2 = (struct work_struct *)ldv_xmalloc_unknown_size(0UL);
    
#line 835 
    if (ldv_6_delayed_work->work.func != (void (*)(struct work_struct *))0) 
      
#line 837 
      (*(ldv_6_delayed_work->work.func))(ldv_6_ldv_param_0_2); else ;
    
#line 842 
    ldv_free((void *)ldv_6_ldv_param_0_2);
    
#line 846 
    __retres = (_Bool)1;
    
#line 846 
    goto return_label;
  }
  else {
    
#line 853 
    __retres = (_Bool)0;
    
#line 853 
    goto return_label;
  }
  return_label: 
#line 825 
                return __retres;
}


#line 863  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_deregister_10_1(struct pci_driver *arg0)
{
  int ret;
  struct ldv_struct_pci_scenario_18 *cf_arg_18;
  int tmp;
  
#line 866 
  tmp = ldv_undef_int();
  
#line 866 
  switch (tmp) {
    case 0: 
#line 867 
    ;
    
#line 868 
    ret = pthread_join(ldv_thread_18,(void **)0);
    
#line 869 
    __VERIFIER_assume(ret == 0);
    
#line 870 
    goto ldv_45074;
    default: 
#line 872 
    ;
    
#line 872 
    __VERIFIER_assume(0);
  }
  ldv_45074: 
#line 873 
  ;
  
#line 874 
  return;
}


#line 878  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
_Bool ldv_emg_queue_work(struct workqueue_struct *arg0, struct work_struct *arg1)
{
  _Bool __retres;
  struct work_struct *ldv_15_work_struct;
  int tmp;
  
#line 885 
  tmp = ldv_undef_int();
  
#line 885 
  if (tmp != 0) {
    
#line 887 
    ldv_15_work_struct = arg1;
    
#line 891 
    if (ldv_15_work_struct->func != (void (*)(struct work_struct *))0) 
      
#line 893 
      (*(ldv_15_work_struct->func))(ldv_15_work_struct); else ;
    
#line 898 
    __retres = (_Bool)1;
    
#line 898 
    goto return_label;
  }
  else {
    
#line 905 
    __retres = (_Bool)0;
    
#line 905 
    goto return_label;
  }
  return_label: 
#line 885 
                return __retres;
}


#line 915  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_del_timer_sync(struct timer_list *arg0)
{
  int __retres;
  struct timer_list *ldv_14_timer_list;
  
#line 921 
  ldv_14_timer_list = arg0;
  
#line 925 
  ldv_dispatch_instance_deregister_14_1(ldv_14_timer_list);
  
#line 926 
  ;
  
#line 926 
  __retres = 0;
  
#line 926 
  return __retres;
}


#line 934  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_pci_unregister_driver(struct pci_driver *arg0)
{
  
#line 937 
  struct pci_driver *ldv_10_pci_driver = ldv_emg_alias_efx_pci_driver_2;
  
#line 940 
  ldv_10_pci_driver = arg0;
  
#line 944 
  ldv_dispatch_deregister_10_1(ldv_10_pci_driver);
  
#line 948 
  goto return_label;
  return_label: 
#line 950 
                return;
}


#line 955  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_pm_ops_scenario_23(void *arg0)
{
  void *__retres;
  struct device *ldv_23_device;
  int tmp;
  
#line 958 
  struct dev_pm_ops *ldv_23_pm_ops = ldv_emg_alias_efx_pm_ops_4;
  
#line 969 
  goto ldv_do_23;
  
#line 971 
  __retres = (void *)0;
  
#line 971 
  goto return_label;
  ldv_do_23: 
#line 974 
  ;
  
#line 977 
  tmp = ldv_undef_int();
  
#line 977 
  switch (tmp) {
    int tmp_0;
    case 1: 
#line 978 
    ;
    
#line 980 
    if (ldv_23_pm_ops->runtime_idle != (int (*)(struct device *))0) 
#line 982 
                                                                    (*(ldv_23_pm_ops->runtime_idle))(ldv_23_device); else ;
    
#line 990 
    goto ldv_do_23;
    case 2: 
#line 993 
    ;
    
#line 995 
    if (ldv_23_pm_ops->runtime_suspend != (int (*)(struct device *))0) 
      
#line 997 
      (*(ldv_23_pm_ops->runtime_suspend))(ldv_23_device); else ;
    
#line 1002 
    if (ldv_23_pm_ops->runtime_resume != (int (*)(struct device *))0) 
      
#line 1004 
      (*(ldv_23_pm_ops->runtime_resume))(ldv_23_device); else ;
    
#line 1012 
    goto ldv_do_23;
    case 3: 
#line 1015 
    ;
    
#line 1017 
    if (ldv_23_pm_ops->prepare != (int (*)(struct device *))0) 
#line 1019 
                                                               (*(ldv_23_pm_ops->prepare))(ldv_23_device); else ;
    
#line 1023 
    tmp_0 = ldv_undef_int();
    
#line 1023 
    switch (tmp_0) {
      int tmp_1;
      int tmp_2;
      int tmp_3;
      case 1: 
#line 1024 
      ;
      
#line 1027 
      ldv_emg_wrapper_efx_pm_suspend_5(ldv_23_device);
      
#line 1030 
      tmp_1 = ldv_undef_int();
      
#line 1030 
      if (tmp_1 != 0) {
        
#line 1032 
        if (ldv_23_pm_ops->suspend_noirq != (int (*)(struct device *))0) 
          
#line 1034 
          (*(ldv_23_pm_ops->suspend_noirq))(ldv_23_device); else ;
        
#line 1039 
        if (ldv_23_pm_ops->resume_noirq != (int (*)(struct device *))0) 
          
#line 1041 
          (*(ldv_23_pm_ops->resume_noirq))(ldv_23_device); else ;
      }
      else {
        
#line 1048 
        if (ldv_23_pm_ops->suspend_late != (int (*)(struct device *))0) 
          
#line 1050 
          (*(ldv_23_pm_ops->suspend_late))(ldv_23_device); else ;
        
#line 1055 
        if (ldv_23_pm_ops->resume_early != (int (*)(struct device *))0) 
          
#line 1057 
          (*(ldv_23_pm_ops->resume_early))(ldv_23_device); else ;
      }
      
#line 1064 
      ldv_emg_wrapper_efx_pm_resume_6(ldv_23_device);
      
#line 1067 
      goto ldv_45099;
      case 2: 
#line 1069 
      ;
      
#line 1072 
      ldv_emg_wrapper_efx_pm_freeze_3(ldv_23_device);
      
#line 1075 
      tmp_2 = ldv_undef_int();
      
#line 1075 
      if (tmp_2 != 0) {
        
#line 1077 
        if (ldv_23_pm_ops->freeze_late != (int (*)(struct device *))0) 
          
#line 1079 
          (*(ldv_23_pm_ops->freeze_late))(ldv_23_device); else ;
        
#line 1084 
        if (ldv_23_pm_ops->thaw_early != (int (*)(struct device *))0) 
          
#line 1086 
          (*(ldv_23_pm_ops->thaw_early))(ldv_23_device); else ;
      }
      else {
        
#line 1093 
        if (ldv_23_pm_ops->freeze_noirq != (int (*)(struct device *))0) 
          
#line 1095 
          (*(ldv_23_pm_ops->freeze_noirq))(ldv_23_device); else ;
        
#line 1100 
        if (ldv_23_pm_ops->thaw_noirq != (int (*)(struct device *))0) 
          
#line 1102 
          (*(ldv_23_pm_ops->thaw_noirq))(ldv_23_device); else ;
      }
      
#line 1109 
      ldv_emg_wrapper_efx_pm_thaw_7(ldv_23_device);
      
#line 1112 
      goto ldv_45099;
      case 3: 
#line 1114 
      ;
      
#line 1117 
      ldv_emg_wrapper_efx_pm_poweroff_2(ldv_23_device);
      
#line 1120 
      tmp_3 = ldv_undef_int();
      
#line 1120 
      if (tmp_3 != 0) {
        
#line 1122 
        if (ldv_23_pm_ops->poweroff_late != (int (*)(struct device *))0) 
          
#line 1124 
          (*(ldv_23_pm_ops->poweroff_late))(ldv_23_device); else ;
        
#line 1129 
        if (ldv_23_pm_ops->restore_early != (int (*)(struct device *))0) 
          
#line 1131 
          (*(ldv_23_pm_ops->restore_early))(ldv_23_device); else ;
      }
      else {
        
#line 1138 
        if (ldv_23_pm_ops->poweroff_noirq != (int (*)(struct device *))0) 
          
#line 1140 
          (*(ldv_23_pm_ops->poweroff_noirq))(ldv_23_device); else ;
        
#line 1145 
        if (ldv_23_pm_ops->restore_noirq != (int (*)(struct device *))0) 
          
#line 1147 
          (*(ldv_23_pm_ops->restore_noirq))(ldv_23_device); else ;
      }
      
#line 1154 
      ldv_emg_wrapper_efx_pm_resume_6(ldv_23_device);
      
#line 1157 
      goto ldv_45099;
      default: 
#line 1159 
      ;
      
#line 1159 
      __VERIFIER_assume(0);
    }
    ldv_45099: 
#line 1162 
    ;
    
#line 1162 
    if (ldv_23_pm_ops->complete != (void (*)(struct device *))0) 
#line 1164 
                                                                 (*(ldv_23_pm_ops->complete))(ldv_23_device); else ;
    
#line 1172 
    goto ldv_do_23;
    case 4: 
#line 1175 
    ;
    
#line 1181 
    __retres = (void *)0;
    
#line 1181 
    goto return_label;
    default: 
#line 1184 
    ;
    
#line 1184 
    __VERIFIER_assume(0);
  }
  
#line 1187 
  __retres = (void *)0;
  return_label: 
#line 1187 
                return __retres;
}


#line 1192  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_initialization_1(void *arg0)
{
  void *__retres;
  int ldv_1_ret;
  int tmp;
  
#line 1199 
  ldv_1_ret = ldv_emg_efx_init_module();
  
#line 1200 
  ldv_1_ret = ldv_post_init(ldv_1_ret);
  
#line 1203 
  tmp = ldv_undef_int();
  
#line 1203 
  if (tmp != 0) {
    
#line 1205 
    __VERIFIER_assume(ldv_1_ret != 0);
    
#line 1209 
    __retres = (void *)0;
    
#line 1209 
    goto return_label;
  }
  else {
    
#line 1213 
    __VERIFIER_assume(ldv_1_ret == 0);
    
#line 1218 
    ldv_emg_efx_exit_module();
    
#line 1222 
    __retres = (void *)0;
    
#line 1222 
    goto return_label;
  }
  
#line 1225 
  __retres = (void *)0;
  return_label: 
#line 1225 
                return __retres;
}


#line 1230  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_unregister_netdev(struct net_device *arg0)
{
  struct net_device *ldv_5_netdev;
  
#line 1236 
  ldv_5_netdev = arg0;
  
#line 1241 
  efx_net_stop(ldv_5_netdev);
  
#line 1249 
  goto return_label;
  return_label: 
#line 1251 
                return;
}


#line 1256  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_free_irq(unsigned int arg0, void *arg1)
{
  int ldv_8_line;
  
#line 1262 
  ldv_8_line = (int)arg0;
  
#line 1266 
  ldv_dispatch_irq_deregister_8_1(ldv_8_line);
  
#line 1270 
  goto return_label;
  return_label: 
#line 1272 
                return;
}


#line 1277  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_devattr_instance_20(void *arg0)
{
  void *__retres;
  char *ldv_20_ldv_param_2_4;
  unsigned long ldv_20_ldv_param_3_3;
  char *ldv_20_ldv_param_2_2;
  struct device *ldv_20_device;
  int tmp;
  
#line 1280 
  struct device_attribute *ldv_20_devattr = ldv_emg_alias_dev_attr_mcdi_logging_3;
  
#line 1286 
  struct ldv_struct_devattr_instance_16 *data = (struct ldv_struct_devattr_instance_16 *)arg0;
  
#line 1291 
  if (data != (struct ldv_struct_devattr_instance_16 *)0) {
    
#line 1292 
    ldv_20_device = data->arg0;
    
#line 1293 
    ldv_20_devattr = data->arg1;
    
#line 1294 
    ldv_free((void *)data);
  }
  else ;
  
#line 1302 
  goto ldv_main_20;
  
#line 1304 
  __retres = (void *)0;
  
#line 1304 
  goto return_label;
  ldv_main_20: 
#line 1307 
  ;
  
#line 1310 
  tmp = ldv_undef_int();
  
#line 1310 
  switch (tmp) {
    case 1: 
#line 1311 
    ;
    
#line 1313 
    ldv_20_ldv_param_2_4 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 1318 
    ldv_emg_wrapper_show_mcdi_log_2(ldv_20_device,ldv_20_devattr,ldv_20_ldv_param_2_4);
    
#line 1322 
    ldv_free((void *)ldv_20_ldv_param_2_4);
    
#line 1329 
    goto ldv_main_20;
    case 2: 
#line 1332 
    ;
    
#line 1334 
    ldv_20_ldv_param_2_2 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 1339 
    ldv_emg_wrapper_set_mcdi_log_4(ldv_20_device,ldv_20_devattr,ldv_20_ldv_param_2_2,ldv_20_ldv_param_3_3);
    
#line 1343 
    ldv_free((void *)ldv_20_ldv_param_2_2);
    
#line 1350 
    goto ldv_main_20;
    case 3: 
#line 1353 
    ;
    
#line 1359 
    __retres = (void *)0;
    
#line 1359 
    goto return_label;
    default: 
#line 1362 
    ;
    
#line 1362 
    __VERIFIER_assume(0);
  }
  
#line 1365 
  __retres = (void *)0;
  return_label: 
#line 1365 
                return __retres;
}


#line 1370  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_devattr_instance_16(void *arg0)
{
  void *__retres;
  char *ldv_16_ldv_param_2_4;
  unsigned long ldv_16_ldv_param_3_3;
  char *ldv_16_ldv_param_2_2;
  struct device *ldv_16_device;
  int tmp;
  
#line 1373 
  struct device_attribute *ldv_16_devattr = ldv_emg_alias_dev_attr_link_control_flag_3;
  
#line 1379 
  struct ldv_struct_devattr_instance_16 *data = (struct ldv_struct_devattr_instance_16 *)arg0;
  
#line 1384 
  if (data != (struct ldv_struct_devattr_instance_16 *)0) {
    
#line 1385 
    ldv_16_device = data->arg0;
    
#line 1386 
    ldv_16_devattr = data->arg1;
    
#line 1387 
    ldv_free((void *)data);
  }
  else ;
  
#line 1395 
  goto ldv_main_16;
  
#line 1397 
  __retres = (void *)0;
  
#line 1397 
  goto return_label;
  ldv_main_16: 
#line 1400 
  ;
  
#line 1403 
  tmp = ldv_undef_int();
  
#line 1403 
  switch (tmp) {
    case 1: 
#line 1404 
    ;
    
#line 1406 
    ldv_16_ldv_param_2_4 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 1411 
    ldv_emg_wrapper_efx_ef10_show_link_control_flag_2(ldv_16_device,ldv_16_devattr,ldv_16_ldv_param_2_4);
    
#line 1415 
    ldv_free((void *)ldv_16_ldv_param_2_4);
    
#line 1422 
    goto ldv_main_16;
    case 2: 
#line 1425 
    ;
    
#line 1427 
    ldv_16_ldv_param_2_2 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 1431 
    if (ldv_16_devattr->store != (ssize_t (*)(struct device *, struct device_attribute *, char const *, size_t ))0) 
      
#line 1433 
      (*(ldv_16_devattr->store))(ldv_16_device,ldv_16_devattr,(char const *)ldv_16_ldv_param_2_2,ldv_16_ldv_param_3_3); else ;
    
#line 1438 
    ldv_free((void *)ldv_16_ldv_param_2_2);
    
#line 1445 
    goto ldv_main_16;
    case 3: 
#line 1448 
    ;
    
#line 1454 
    __retres = (void *)0;
    
#line 1454 
    goto return_label;
    default: 
#line 1457 
    ;
    
#line 1457 
    __VERIFIER_assume(0);
  }
  
#line 1460 
  __retres = (void *)0;
  return_label: 
#line 1460 
                return __retres;
}


#line 1465  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_pci_scenario_18(void *arg0)
{
  void *__retres;
  struct pci_dev *ldv_18_resource_1;
  struct pci_device_id *ldv_18_ldv_param_1_2;
  int ldv_18_ldv_param_1_3;
  struct pm_message ldv_18_resource_0;
  int tmp_2;
  int tmp_3;
  
#line 1471 
  struct pci_driver *ldv_18_container = ldv_emg_alias_efx_pci_driver_2;
  
#line 1472 
  int ldv_18_ret = ldv_undef_int();
  
#line 1475 
  struct ldv_struct_pci_scenario_18 *data = (struct ldv_struct_pci_scenario_18 *)arg0;
  
#line 1479 
  ldv_18_ret = ldv_undef_int();
  
#line 1482 
  if (data != (struct ldv_struct_pci_scenario_18 *)0) {
    
#line 1483 
    ldv_18_container = data->arg0;
    
#line 1484 
    ldv_free((void *)data);
  }
  else ;
  
#line 1495 
  goto ldv_main_18;
  
#line 1497 
  __retres = (void *)0;
  
#line 1497 
  goto return_label;
  ldv_main_18: 
#line 1500 
  ;
  
#line 1503 
  tmp_2 = ldv_undef_int();
  
#line 1503 
  if (tmp_2 != 0) {
    int tmp_1;
    
#line 1505 
    ldv_18_ldv_param_1_2 = (struct pci_device_id *)ldv_xmalloc_unknown_size(0UL);
    
#line 1510 
    ldv_pre_probe();
    
#line 1512 
    ldv_18_ret = ldv_emg_wrapper_efx_pci_probe_3(ldv_18_resource_1,ldv_18_ldv_param_1_2);
    
#line 1514 
    ldv_18_ret = ldv_post_probe(ldv_18_ret);
    
#line 1518 
    ldv_free((void *)ldv_18_ldv_param_1_2);
    
#line 1521 
    tmp_1 = ldv_undef_int();
    
#line 1521 
    if (tmp_1 != 0) {
      
#line 1523 
      __VERIFIER_assume(ldv_18_ret == 0);
      
#line 1530 
      goto ldv_call_18;
    }
    else {
      
#line 1534 
      __VERIFIER_assume(ldv_18_ret != 0);
      
#line 1541 
      goto ldv_main_18;
    }
  }
  else {
    
#line 1553 
    __retres = (void *)0;
    
#line 1553 
    goto return_label;
  }
  
#line 1556 
  __retres = (void *)0;
  
#line 1556 
  goto return_label;
  ldv_call_18: 
#line 1559 
  ;
  
#line 1562 
  tmp_3 = ldv_undef_int();
  
#line 1562 
  switch (tmp_3) {
    case 1: 
#line 1563 
    ;
    
#line 1569 
    ldv_emg_wrapper_efx_pci_sriov_configure_2(ldv_18_resource_1,ldv_18_ldv_param_1_3);
    
#line 1579 
    goto ldv_call_18;
    case 2: 
#line 1582 
    ;
    
#line 1584 
    if (ldv_18_container->suspend != (int (*)(struct pci_dev *, pm_message_t ))0) {
      
#line 1586 
      ldv_18_ret = (*(ldv_18_container->suspend))(ldv_18_resource_1,ldv_18_resource_0);
      
#line 1588 
      ldv_18_ret = ldv_filter_err_code(ldv_18_ret);
    }
    else 
#line 1590 
         ldv_18_ret = ldv_undef_int();
    
#line 1595 
    if (ldv_18_container->suspend_late != (int (*)(struct pci_dev *, pm_message_t ))0) {
      
#line 1597 
      ldv_18_ret = (*(ldv_18_container->suspend_late))(ldv_18_resource_1,ldv_18_resource_0);
      
#line 1599 
      ldv_18_ret = ldv_filter_err_code(ldv_18_ret);
    }
    else 
#line 1601 
         ldv_18_ret = ldv_undef_int();
    
#line 1606 
    if (ldv_18_container->resume_early != (int (*)(struct pci_dev *))0) 
      
#line 1608 
      (*(ldv_18_container->resume_early))(ldv_18_resource_1); else ;
    
#line 1613 
    if (ldv_18_container->resume != (int (*)(struct pci_dev *))0) 
#line 1615 
                                                                  (*(ldv_18_container->resume))(ldv_18_resource_1); else ;
    
#line 1623 
    goto ldv_call_18;
    case 3: 
#line 1626 
    ;
    
#line 1628 
    if (ldv_18_container->shutdown != (void (*)(struct pci_dev *))0) 
      
#line 1630 
      (*(ldv_18_container->shutdown))(ldv_18_resource_1); else ;
    
#line 1636 
    ldv_emg_wrapper_efx_pci_remove_4(ldv_18_resource_1);
    
#line 1643 
    goto ldv_main_18;
    default: 
#line 1646 
    ;
    
#line 1646 
    __VERIFIER_assume(0);
  }
  
#line 1649 
  __retres = (void *)0;
  return_label: 
#line 1649 
                return __retres;
}


#line 1654  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_devattr_instance_17(void *arg0)
{
  void *__retres;
  char *ldv_17_ldv_param_2_4;
  unsigned long ldv_17_ldv_param_3_3;
  char *ldv_17_ldv_param_2_2;
  struct device *ldv_17_device;
  int tmp;
  
#line 1657 
  struct device_attribute *ldv_17_devattr = ldv_emg_alias_dev_attr_phy_flash_cfg_3;
  
#line 1663 
  struct ldv_struct_devattr_instance_16 *data = (struct ldv_struct_devattr_instance_16 *)arg0;
  
#line 1668 
  if (data != (struct ldv_struct_devattr_instance_16 *)0) {
    
#line 1669 
    ldv_17_device = data->arg0;
    
#line 1670 
    ldv_17_devattr = data->arg1;
    
#line 1671 
    ldv_free((void *)data);
  }
  else ;
  
#line 1679 
  goto ldv_main_17;
  
#line 1681 
  __retres = (void *)0;
  
#line 1681 
  goto return_label;
  ldv_main_17: 
#line 1684 
  ;
  
#line 1687 
  tmp = ldv_undef_int();
  
#line 1687 
  switch (tmp) {
    case 1: 
#line 1688 
    ;
    
#line 1690 
    ldv_17_ldv_param_2_4 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 1695 
    ldv_emg_wrapper_show_phy_flash_cfg_2(ldv_17_device,ldv_17_devattr,ldv_17_ldv_param_2_4);
    
#line 1699 
    ldv_free((void *)ldv_17_ldv_param_2_4);
    
#line 1706 
    goto ldv_main_17;
    case 2: 
#line 1709 
    ;
    
#line 1711 
    ldv_17_ldv_param_2_2 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 1716 
    ldv_emg_wrapper_set_phy_flash_cfg_4(ldv_17_device,ldv_17_devattr,ldv_17_ldv_param_2_2,ldv_17_ldv_param_3_3);
    
#line 1720 
    ldv_free((void *)ldv_17_ldv_param_2_2);
    
#line 1727 
    goto ldv_main_17;
    case 3: 
#line 1730 
    ;
    
#line 1736 
    __retres = (void *)0;
    
#line 1736 
    goto return_label;
    default: 
#line 1739 
    ;
    
#line 1739 
    __VERIFIER_assume(0);
  }
  
#line 1742 
  __retres = (void *)0;
  return_label: 
#line 1742 
                return __retres;
}


#line 1747  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_free_netdev(struct net_device *arg0)
{
  struct net_device *ldv_2_netdev;
  
#line 1753 
  ldv_2_netdev = arg0;
  
#line 1754 
  ldv_free((void *)ldv_2_netdev);
  
#line 1758 
  goto return_label;
  return_label: 
#line 1760 
                return;
}


#line 1765  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/sfc/sfc.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_mod_timer(struct timer_list *arg0, unsigned long arg1)
{
  int __retres;
  struct timer_list *ldv_3_timer_list;
  int tmp_0;
  
#line 1772 
  tmp_0 = ldv_undef_int();
  
#line 1772 
  if (tmp_0 != 0) {
    
#line 1774 
    ldv_3_timer_list = arg0;
    
#line 1778 
    ldv_dispatch_instance_register_3_3(ldv_3_timer_list);
    
#line 1782 
    __retres = 0;
    
#line 1782 
    goto return_label;
  }
  else {
    int tmp;
    
#line 1789 
    tmp = ldv_undef_int_negative();
    
#line 1789 
    __retres = tmp;
    
#line 1789 
    goto return_label;
  }
  return_label: 
#line 1772 
                return __retres;
}


