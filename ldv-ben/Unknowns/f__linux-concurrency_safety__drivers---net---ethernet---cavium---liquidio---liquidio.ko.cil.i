/* Generated by Frama-C */

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef int __s32;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef signed char s8;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned char u8;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned short u16;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef int s32;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned int u32;

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef long long s64;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned long long u64;

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;

#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;

#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u16 __be16;

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __be32;

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __wsum;

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u32 __kernel_dev_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_dev_t dev_t;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned short umode_t;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_pid_t pid_t;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_clockid_t clockid_t;

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef _Bool bool;

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_uid32_t uid_t;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_gid32_t gid_t;

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_loff_t loff_t;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_size_t size_t;

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_time_t time_t;

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __s32 int32_t;

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u8 uint8_t;

#line 108  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u32 uint32_t;

#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u64 uint64_t;

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned long sector_t;

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned long blkcnt_t;

#line 152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef u64 dma_addr_t;

#line 157  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int gfp_t;

#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int fmode_t;

#line 159  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int oom_flags_t;

#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef u64 phys_addr_t;

#line 167  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef phys_addr_t resource_size_t;

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;

#line 183  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};

#line 188 
struct hlist_node;

#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};

#line 192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};

#line 203  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head *) ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct __anonstruct_9 {
   unsigned int a ;
   unsigned int b ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct __anonstruct_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) base1 : 8 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) type : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) s : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) dpl : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) p : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) limit : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) avl : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) l : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) g : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) base2 : 8 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
union __anonunion_8 {
   struct __anonstruct_9 __anonCompField___anonunion_8_4 ;
   struct __anonstruct_10 __anonCompField___anonunion_8_5 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion_8 __anonCompField_desc_struct_6 ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;

#line 361 
struct page;

#line 361  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;

#line 372 
struct file;

#line 385 
struct seq_file;

#line 423 
struct thread_struct;

#line 425 
struct mm_struct;

#line 426 
struct task_struct;

#line 427 
struct cpumask;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;

#line 234  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
struct _ddebug {
   char const *modname ;
   char const *function ;
   char const *filename ;
   char const *format ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))) lineno : 18 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) flags : 8 ;
};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_debug.h"
struct device;

#line 54 
struct net_device;

#line 420  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
struct file_operations;

#line 432 
struct completion;

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct timespec;

#line 103 
struct compat_timespec;

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_futex_16 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_nanosleep_17 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_poll_18 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
union __anonunion_15 {
   struct __anonstruct_futex_16 futex ;
   struct __anonstruct_nanosleep_17 nanosleep ;
   struct __anonstruct_poll_18 poll ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct restart_block {
   long (*fn)(struct restart_block *) ;
   union __anonunion_15 __anonCompField_restart_block_7 ;
};

#line 127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/vm86.h"
union __anonunion_19 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_19 __anonCompField_math_emu_info_8 ;
};

#line 328  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[128U] ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
typedef struct cpumask cpumask_t;

#line 652  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;

#line 260  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct __anonstruct_29 {
   u64 rip ;
   u64 rdp ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct __anonstruct_30 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union __anonunion_28 {
   struct __anonstruct_29 __anonCompField___anonunion_28_12 ;
   struct __anonstruct_30 __anonCompField___anonunion_28_13 ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union __anonunion_31 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_28 __anonCompField_fxregs_state_14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_31 __anonCompField_fxregs_state_15 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};

#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};

#line 179  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
   u8 __padding[4096U] ;
};

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
   union fpregs_state state ;
};

#line 170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
struct seq_operations;

#line 369 
struct perf_event;

#line 370  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   struct fpu fpu ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bottom_half.h"
struct lockdep_map;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};

#line 28  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};

#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const *name ;
   int cpu ;
   unsigned long ip ;
};

#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(13))) class_idx : 13 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) irq_context : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) trylock : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) read : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) check : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hardirqs_off : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))) references : 12 ;
   unsigned int pin_count ;
};

#line 546  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
struct __anonstruct_35 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
union __anonunion_34 {
   struct raw_spinlock rlock ;
   struct __anonstruct_35 __anonCompField___anonunion_34_17 ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_34 __anonCompField_spinlock_18 ;
};

#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_36 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_36 rwlock_t;

#line 41  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
struct mutex;

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};

#line 186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
   __u32 cls ;
   __u32 cls_msk ;
};

#line 221  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const *data ;
};

#line 652  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};

#line 193  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
typedef struct seqcount seqcount_t;

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
struct __anonstruct_seqlock_t_48 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_48 seqlock_t;

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;

#line 1170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debugobjects.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};

#line 437  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ktime.h"
typedef union ktime ktime_t;

#line 296  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
struct notifier_block;

#line 1120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
union __anonunion_49 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};

#line 1120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion_49 __anonCompField_idr_layer_19 ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};

#line 153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};

#line 185  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};

#line 97 
struct dentry;

#line 98 
struct iattr;

#line 99 
struct vm_area_struct;

#line 100 
struct super_block;

#line 101 
struct file_system_type;

#line 102 
struct kernfs_open_node;

#line 103 
struct kernfs_iattrs;

#line 126 
struct kernfs_root;

#line 126  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rbtree.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_node;

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};

#line 89 
struct kernfs_ops;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops const *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
union __anonunion_54 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const *name ;
   struct rb_node rb ;
   void const *ns ;
   unsigned int hash ;
   union __anonunion_54 __anonCompField_kernfs_node_20 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};

#line 138  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root *, int *, char *) ;
   int (*show_options)(struct seq_file *, struct kernfs_root *) ;
   int (*mkdir)(struct kernfs_node *, char const *, umode_t ) ;
   int (*rmdir)(struct kernfs_node *) ;
   int (*rename)(struct kernfs_node *, struct kernfs_node *, char const *) ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};

#line 171 
struct vm_operations_struct;

#line 171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct const *vm_ops ;
};

#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file *, void *) ;
   void *(*seq_start)(struct seq_file *, loff_t *) ;
   void *(*seq_next)(struct seq_file *, void *, loff_t *) ;
   void (*seq_stop)(struct seq_file *, void *) ;
   ssize_t (*read)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   int (*mmap)(struct kernfs_open_file *, struct vm_area_struct *) ;
   struct lock_class_key lockdep_key ;
};

#line 281 
struct inode;

#line 478 
struct kobject;

#line 479 
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
};

#line 485  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const *(*netlink_ns)(struct sock *) ;
   void const *(*initial_ns)(void) ;
   void (*drop_ns)(void *) ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/highuid.h"
struct user_namespace;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct __anonstruct_kuid_t_55 {
   uid_t val ;
};

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_55 kuid_t;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct __anonstruct_kgid_t_56 {
   gid_t val ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_56 kgid_t;

#line 139  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/stat.h"
struct bin_attribute;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/stat.h"
struct attribute {
   char const *name ;
   umode_t mode ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_lockdep : 1 ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct attribute_group {
   char const *name ;
   umode_t (*is_visible)(struct kobject *, struct attribute *, int ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};

#line 82  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t , size_t ) ;
   ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t , size_t ) ;
   int (*mmap)(struct file *, struct kobject *, struct bin_attribute *, struct vm_area_struct *) ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject *, struct attribute *, char *) ;
   ssize_t (*store)(struct kobject *, struct attribute *, char const *, size_t ) ;
};

#line 509  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kref.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};

#line 238  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
struct hrtimer;

#line 239 
enum hrtimer_restart;

#line 837  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/sysctl.h"
struct ctl_table;

#line 838 
struct nsproxy;

#line 839 
struct ctl_table_root;

#line 840 
struct ctl_table_header;

#line 841 
struct ctl_dir;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table *, int , void *, size_t *, loff_t *);

#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table {
   char const *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};

#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct __anonstruct_58 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
union __anonunion_57 {
   struct __anonstruct_58 __anonCompField___anonunion_57_21 ;
   struct callback_head rcu ;
};

#line 122 
struct ctl_table_set;

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion_57 __anonCompField_ctl_table_header_22 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};

#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};

#line 149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set *) ;
   struct ctl_dir dir ;
};

#line 154  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root *, struct nsproxy *) ;
   int (*permissions)(struct ctl_table_header *, struct ctl_table *) ;
};

#line 259  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
struct workqueue_struct;

#line 260 
struct work_struct;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct *) ;
   struct lockdep_map lockdep_map ;
};

#line 107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset;

#line 52 
struct kobj_type;

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobject {
   char const *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_initialized : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_in_sysfs : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_add_uevent_sent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_remove_uevent_sent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) uevent_suppress : 1 ;
};

#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject *) ;
   struct sysfs_ops const *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations const *(*child_ns_type)(struct kobject *) ;
   void const *(*namespace)(struct kobject *) ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const filter)(struct kset *, struct kobject *) ;
   char const *(* const name)(struct kset *, struct kobject *) ;
   int (* const uevent)(struct kset *, struct kobject *, struct kobj_uevent_env *) ;
};

#line 148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops const *uevent_ops ;
};

#line 223 
struct klist_node;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nodemask.h"
struct __anonstruct_nodemask_t_59 {
   unsigned long bits[16U] ;
};

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_59 nodemask_t;

#line 520 
struct path;

#line 521  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nodemask.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations const *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file *, loff_t *) ;
   void (*stop)(struct seq_file *, void *) ;
   void *(*next)(struct seq_file *, void *, loff_t *) ;
   int (*show)(struct seq_file *, void *) ;
};

#line 222 
struct pinctrl;

#line 223 
struct pinctrl_state;

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct pm_message {
   int event ;
};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
typedef struct pm_message pm_message_t;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device *) ;
   void (*complete)(struct device *) ;
   int (*suspend)(struct device *) ;
   int (*resume)(struct device *) ;
   int (*freeze)(struct device *) ;
   int (*thaw)(struct device *) ;
   int (*poweroff)(struct device *) ;
   int (*restore)(struct device *) ;
   int (*suspend_late)(struct device *) ;
   int (*resume_early)(struct device *) ;
   int (*freeze_late)(struct device *) ;
   int (*thaw_early)(struct device *) ;
   int (*poweroff_late)(struct device *) ;
   int (*restore_early)(struct device *) ;
   int (*suspend_noirq)(struct device *) ;
   int (*resume_noirq)(struct device *) ;
   int (*freeze_noirq)(struct device *) ;
   int (*thaw_noirq)(struct device *) ;
   int (*poweroff_noirq)(struct device *) ;
   int (*restore_noirq)(struct device *) ;
   int (*runtime_suspend)(struct device *) ;
   int (*runtime_resume)(struct device *) ;
   int (*runtime_idle)(struct device *) ;
};

#line 320 
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
};

#line 327 
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
};

#line 335 
struct wakeup_source;

#line 336 
struct wake_irq;

#line 338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};

#line 553 
struct dev_pm_qos;

#line 553  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) can_wakeup : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) async_suspend : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_prepared : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_noirq_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_late_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_children : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) early_init : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) direct_complete : 1 ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wakeup_path : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) syscore : 1 ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) disable_depth : 3 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) idle_notification : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) request_pending : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) deferred_resume : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) run_wake : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) runtime_auto : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_callbacks : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) irq_safe : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) use_autosuspend : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) timer_autosuspends : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device *, s32 ) ;
   struct dev_pm_qos *qos ;
};

#line 615  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device *, bool ) ;
   int (*activate)(struct device *) ;
   void (*sync)(struct device *) ;
   void (*dismiss)(struct device *) ;
};

#line 796  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
struct rw_semaphore;

#line 797  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block *, unsigned long , void *) ;
   struct notifier_block *next ;
   int priority ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/x86_init.h"
struct pci_dev;

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/topology.h"
struct pci_bus;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
struct ldt_struct;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_124 {
   struct ldt_struct *ldt ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_124 mm_context_t;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/xen/features.h"
struct bio_vec;

#line 1281  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
struct llist_node;

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/smp.h"
struct call_single_data {
   struct llist_node llist ;
   void (*func)(void *) ;
   void *info ;
   unsigned int flags ;
};

#line 428  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/gfp.h"
struct dma_map_ops;

#line 428  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/gfp.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/device.h"
struct device_driver;

#line 16 
struct driver_private;

#line 17 
struct class;

#line 18 
struct subsys_private;

#line 19 
struct bus_type;

#line 20 
struct device_node;

#line 21 
struct fwnode_handle;

#line 22 
struct iommu_ops;

#line 23 
struct iommu_group;

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_attribute;

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct bus_type {
   char const *name ;
   char const *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group const **bus_groups ;
   struct attribute_group const **dev_groups ;
   struct attribute_group const **drv_groups ;
   int (*match)(struct device *, struct device_driver *) ;
   int (*uevent)(struct device *, struct kobj_uevent_env *) ;
   int (*probe)(struct device *) ;
   int (*remove)(struct device *) ;
   void (*shutdown)(struct device *) ;
   int (*online)(struct device *) ;
   int (*offline)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct dev_pm_ops const *pm ;
   struct iommu_ops const *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};

#line 139 
struct device_type;

#line 197 
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
};

#line 203  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_driver {
   char const *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id const *of_match_table ;
   struct acpi_device_id const *acpi_match_table ;
   int (*probe)(struct device *) ;
   int (*remove)(struct device *) ;
   void (*shutdown)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct attribute_group const **groups ;
   struct dev_pm_ops const *pm ;
   struct driver_private *p ;
};

#line 353 
struct class_attribute;

#line 353  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct class {
   char const *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group const **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *, struct kobj_uevent_env *) ;
   char *(*devnode)(struct device *, umode_t *) ;
   void (*class_release)(struct class *) ;
   void (*dev_release)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct kobj_ns_type_operations const *ns_type ;
   void const *(*namespace)(struct device *) ;
   struct dev_pm_ops const *pm ;
   struct subsys_private *p ;
};

#line 446  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *, struct class_attribute *, char *) ;
   ssize_t (*store)(struct class *, struct class_attribute *, char const *, size_t ) ;
};

#line 514  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_type {
   char const *name ;
   struct attribute_group const **groups ;
   int (*uevent)(struct device *, struct kobj_uevent_env *) ;
   char *(*devnode)(struct device *, umode_t *, kuid_t *, kgid_t *) ;
   void (*release)(struct device *) ;
   struct dev_pm_ops const *pm ;
};

#line 542  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *, struct device_attribute *, char *) ;
   ssize_t (*store)(struct device *, struct device_attribute *, char const *, size_t ) ;
};

#line 675  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};

#line 684 
struct dma_coherent_mem;

#line 684 
struct cma;

#line 684  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const *init_name ;
   struct device_type const *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group const **groups ;
   void (*release)(struct device *) ;
   struct iommu_group *iommu_group ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) offline_disabled : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) offline : 1 ;
};

#line 830  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct wakeup_source {
   char const *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) active : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) autosleep_enabled : 1 ;
};

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kmemleak.h"
struct kmem_cache;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;

#line 84  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};

#line 66 
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct __anonstruct_157 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct __anonstruct_158 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
union __anonunion_156 {
   struct __anonstruct_157 __anonCompField___anonunion_156_35 ;
   struct __anonstruct_158 __anonCompField___anonunion_156_36 ;
};

#line 73 
struct uprobe;

#line 73 
struct return_instance;

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion_156 __anonCompField_uprobe_task_37 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};

#line 94  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uprobes.h"
struct xol_area;

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};

#line 133 
struct address_space;

#line 134 
struct mem_cgroup;

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
typedef void compound_page_dtor(struct page *);

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_159 {
   struct address_space *mapping ;
   void *s_mem ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_161 {
   unsigned long index ;
   void *freelist ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_165 {
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) inuse : 16 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(15))) objects : 15 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) frozen : 1 ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_164 {
   atomic_t _mapcount ;
   struct __anonstruct_165 __anonCompField___anonunion_164_40 ;
   int units ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_163 {
   union __anonunion_164 __anonCompField___anonstruct_163_41 ;
   atomic_t _count ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_162 {
   unsigned long counters ;
   struct __anonstruct_163 __anonCompField___anonunion_162_42 ;
   unsigned int active ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_160 {
   union __anonunion_161 __anonCompField___anonstruct_160_39 ;
   union __anonunion_162 __anonCompField___anonstruct_160_43 ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_167 {
   struct page *next ;
   int pages ;
   int pobjects ;
};

#line 32 
struct slab;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_168 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_166 {
   struct list_head lru ;
   struct __anonstruct_167 __anonCompField___anonunion_166_45 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct_168 __anonCompField___anonunion_166_46 ;
   pgtable_t pmd_huge_pte ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_169 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion_159 __anonCompField_page_38 ;
   struct __anonstruct_160 __anonCompField_page_44 ;
   union __anonunion_166 __anonCompField_page_47 ;
   union __anonunion_169 __anonCompField_page_48 ;
   struct mem_cgroup *mem_cgroup ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_shared_170 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};

#line 257 
struct anon_vma;

#line 257 
struct mempolicy;

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_170 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct const *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};

#line 331  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};

#line 344  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};

#line 352  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};

#line 357 
struct kioctx_table;

#line 358 
struct linux_binfmt;

#line 358 
struct mmu_notifier_mm;

#line 358  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};

#line 4  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sem.h"
struct sem_undo_list;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};

#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/shm.h"
struct user_struct;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_172 {
   unsigned long sig[1U] ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_172 sigset_t;

#line 25 
struct siginfo;

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int );

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};

#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_174 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_175 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_176 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_177 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_179 {
   void *_lower ;
   void *_upper ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_178 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_179 _addr_bnd ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_180 {
   long _band ;
   int _fd ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_181 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_173 {
   int _pad[28U] ;
   struct __anonstruct__kill_174 _kill ;
   struct __anonstruct__timer_175 _timer ;
   struct __anonstruct__rt_176 _rt ;
   struct __anonstruct__sigchld_177 _sigchld ;
   struct __anonstruct__sigfault_178 _sigfault ;
   struct __anonstruct__sigpoll_180 _sigpoll ;
   struct __anonstruct__sigsys_181 _sigsys ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_173 _sifields ;
};

#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};

#line 243  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};

#line 443 
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
};

#line 450 
struct pid_namespace;

#line 450  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/seccomp.h"
struct seccomp_filter;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rtmutex.h"
struct rt_mutex_waiter;

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};

#line 50 
struct hrtimer_clock_base;

#line 51 
struct hrtimer_cpu_base;

#line 60 
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer *) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};

#line 156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_hrtirq : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hres_active : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};

#line 466  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/latencytop.h"
struct assoc_array_ptr;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
typedef int32_t key_serial_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
typedef uint32_t key_perm_t;

#line 35 
struct key;

#line 36 
struct signal_struct;

#line 37 
struct cred;

#line 38 
struct key_type;

#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const *description ;
   size_t desc_len ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_188 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};

#line 123 
struct key_user;

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_189 {
   time_t expiry ;
   time_t revoked_at ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct __anonstruct_191 {
   struct key_type *type ;
   char *description ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_190 {
   struct keyring_index_key index_key ;
   struct __anonstruct_191 __anonCompField___anonunion_190_51 ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_type_data_192 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_payload_194 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_193 {
   union __anonunion_payload_194 payload ;
   struct assoc_array keys ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_188 __anonCompField_key_49 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_189 __anonCompField_key_50 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion_190 __anonCompField_key_52 ;
   union __anonunion_type_data_192 type_data ;
   union __anonunion_193 __anonCompField_key_53 ;
};

#line 358 
struct audit_context;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};

#line 369 
struct percpu_ref;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref *);

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) force_atomic : 1 ;
   struct callback_head rcu ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-rwsem.h"
struct cgroup;

#line 28 
struct cgroup_root;

#line 29 
struct cgroup_subsys;

#line 30 
struct cgroup_taskset;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-rwsem.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};

#line 197  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};

#line 270  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};

#line 306  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state *, struct cftype *) ;
   s64 (*read_s64)(struct cgroup_subsys_state *, struct cftype *) ;
   int (*seq_show)(struct seq_file *, void *) ;
   void *(*seq_start)(struct seq_file *, loff_t *) ;
   void *(*seq_next)(struct seq_file *, void *, loff_t *) ;
   void (*seq_stop)(struct seq_file *, void *) ;
   int (*write_u64)(struct cgroup_subsys_state *, struct cftype *, u64 ) ;
   int (*write_s64)(struct cgroup_subsys_state *, struct cftype *, s64 ) ;
   ssize_t (*write)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   struct lock_class_key lockdep_key ;
};

#line 388  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state *) ;
   int (*css_online)(struct cgroup_subsys_state *) ;
   void (*css_offline)(struct cgroup_subsys_state *) ;
   void (*css_released)(struct cgroup_subsys_state *) ;
   void (*css_free)(struct cgroup_subsys_state *) ;
   void (*css_reset)(struct cgroup_subsys_state *) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state *) ;
   int (*can_attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*cancel_attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*fork)(struct task_struct *) ;
   void (*exit)(struct cgroup_subsys_state *, struct cgroup_subsys_state *, struct task_struct *) ;
   void (*bind)(struct cgroup_subsys_state *) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};

#line 128  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct futex_pi_state;

#line 129 
struct robust_list_head;

#line 130 
struct bio_list;

#line 131 
struct fs_struct;

#line 132 
struct perf_event_context;

#line 133 
struct blk_plug;

#line 135 
struct nameidata;

#line 188 
struct cfs_rq;

#line 189 
struct task_group;

#line 477  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};

#line 516  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};

#line 524  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};

#line 531  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};

#line 543  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};

#line 563  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};

#line 584  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};

#line 620 
struct autogroup;

#line 621 
struct tty_struct;

#line 621 
struct taskstats;

#line 621 
struct tty_audit_buf;

#line 621  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_child_subreaper : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};

#line 802  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};

#line 845 
struct backing_dev_info;

#line 846 
struct reclaim_state;

#line 847  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};

#line 861  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};

#line 909  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};

#line 1138 
struct io_context;

#line 1172 
struct pipe_inode_info;

#line 1173 
struct uts_namespace;

#line 1174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};

#line 1181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};

#line 1206  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};

#line 1241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};

#line 1273 
struct rt_rq;

#line 1273  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};

#line 1289  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};

#line 1355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) may_oom : 1 ;
};

#line 1779 
struct sched_class;

#line 1779 
struct files_struct;

#line 1779 
struct compat_robust_list_head;

#line 1779 
struct numa_group;

#line 1779 
struct ftrace_ret_stack;

#line 1779  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_struct {
   long volatile state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class const *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_execve : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_iowait : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_reset_on_fork : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_contributes_to_load : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_migrated : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) memcg_kmem_skip_account : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred const *real_cred ;
   struct cred const *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void *) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
   struct thread_struct thread ;
};

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/resource_ext.h"
struct hotplug_slot;

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/resource_ext.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef int pci_power_t;

#line 137  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned int pci_channel_state_t;

#line 138 
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
};

#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;

#line 192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;

#line 249 
struct pcie_link_state;

#line 250 
struct pci_vpd;

#line 251 
struct pci_sriov;

#line 252 
struct pci_ats;

#line 253 
struct proc_dir_entry;

#line 253 
struct pci_driver;

#line 253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
union __anonunion_209 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};

#line 253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   u8 dma_alias_devfn ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(5))) pme_support : 5 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pme_interrupt : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pme_poll : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d1_support : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d2_support : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_d1d2 : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_d3cold : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d3cold_allowed : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) mmio_always_on : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wakeup_prepared : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) runtime_d3cold : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_hotplug : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) transparent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) multifunction : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_added : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_busmaster : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_msi : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_64bit_msi : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) block_cfg_access : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) broken_parity_status : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) irq_reroute_variant : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) msi_enabled : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) msix_enabled : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ari_enabled : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_managed : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) needs_freset : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_saved : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_physfn : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_virtfn : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) reset_fn : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_hotplug_bridge : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) __aer_firmware_first_valid : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) __aer_firmware_first : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) broken_intx_masking : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) io_window_1k : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) irq_managed : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) has_secondary_link : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct attribute_group const **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion_209 __anonCompField_pci_dev_57 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
};

#line 442 
struct pci_ops;

#line 442 
struct msi_controller;

#line 442  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_controller *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_added : 1 ;
};

#line 565  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_ops {
   void *(*map_bus)(struct pci_bus *, unsigned int , int ) ;
   int (*read)(struct pci_bus *, unsigned int , int , int , u32 *) ;
   int (*write)(struct pci_bus *, unsigned int , int , int , u32 ) ;
};

#line 593  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};

#line 607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned int pci_ers_result_t;

#line 617  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev *, enum pci_channel_state ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev *) ;
   pci_ers_result_t (*link_reset)(struct pci_dev *) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev *) ;
   void (*reset_notify)(struct pci_dev *, bool ) ;
   void (*resume)(struct pci_dev *) ;
};

#line 650  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const *name ;
   struct pci_device_id const *id_table ;
   int (*probe)(struct pci_dev *, struct pci_device_id const *) ;
   void (*remove)(struct pci_dev *) ;
   int (*suspend)(struct pci_dev *, pm_message_t ) ;
   int (*suspend_late)(struct pci_dev *, pm_message_t ) ;
   int (*resume_early)(struct pci_dev *) ;
   int (*resume)(struct pci_dev *) ;
   void (*shutdown)(struct pci_dev *) ;
   int (*sriov_configure)(struct pci_dev *, int ) ;
   struct pci_error_handlers const *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker *, struct shrink_control *) ;
   unsigned long (*scan_objects)(struct shrinker *, struct shrink_control *) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/page_ext.h"
struct file_ra_state;

#line 65 
struct writeback_control;

#line 66 
struct bdi_writeback;

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};

#line 239  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *) ;
   void (*close)(struct vm_area_struct *) ;
   int (*fault)(struct vm_area_struct *, struct vm_fault *) ;
   void (*map_pages)(struct vm_area_struct *, struct vm_fault *) ;
   int (*page_mkwrite)(struct vm_area_struct *, struct vm_fault *) ;
   int (*pfn_mkwrite)(struct vm_area_struct *, struct vm_fault *) ;
   int (*access)(struct vm_area_struct *, unsigned long , void *, int , int ) ;
   char const *(*name)(struct vm_area_struct *) ;
   int (*set_policy)(struct vm_area_struct *, struct mempolicy *) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct *, unsigned long ) ;
   struct page *(*find_special_page)(struct vm_area_struct *, unsigned long ) ;
};

#line 1249 
struct kvec;

#line 2291  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pci_64.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
};

#line 77  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-attrs.h"
struct dma_map_ops {
   void *(*alloc)(struct device *, size_t , dma_addr_t *, gfp_t , struct dma_attrs *) ;
   void (*free)(struct device *, size_t , void *, dma_addr_t , struct dma_attrs *) ;
   int (*mmap)(struct device *, struct vm_area_struct *, void *, dma_addr_t , size_t , struct dma_attrs *) ;
   int (*get_sgtable)(struct device *, struct sg_table *, void *, dma_addr_t , size_t , struct dma_attrs *) ;
   dma_addr_t (*map_page)(struct device *, struct page *, unsigned long , size_t , enum dma_data_direction , struct dma_attrs *) ;
   void (*unmap_page)(struct device *, dma_addr_t , size_t , enum dma_data_direction , struct dma_attrs *) ;
   int (*map_sg)(struct device *, struct scatterlist *, int , enum dma_data_direction , struct dma_attrs *) ;
   void (*unmap_sg)(struct device *, struct scatterlist *, int , enum dma_data_direction , struct dma_attrs *) ;
   void (*sync_single_for_cpu)(struct device *, dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_single_for_device)(struct device *, dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_sg_for_cpu)(struct device *, struct scatterlist *, int , enum dma_data_direction ) ;
   void (*sync_sg_for_device)(struct device *, struct scatterlist *, int , enum dma_data_direction ) ;
   int (*mapping_error)(struct device *, dma_addr_t ) ;
   int (*dma_supported)(struct device *, u64 ) ;
   int (*set_dma_mask)(struct device *, u64 ) ;
   int is_phys ;
};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/prefetch.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uio.h"
union __anonunion_210 {
   struct iovec const *iov ;
   struct kvec const *kvec ;
   struct bio_vec const *bvec ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion_210 __anonCompField_iov_iter_58 ;
   unsigned long nr_segs ;
};

#line 1182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dmaengine.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};

#line 38 
struct kiocb;

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_212 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_212 sync_serial_settings;

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_213 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_213 te1_settings;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_214 {
   unsigned short encoding ;
   unsigned short parity ;
};

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_214 raw_hdlc_proto;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_215 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_215 fr_proto;

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_216 {
   unsigned int dlci ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_216 fr_proto_pvc;

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_217 {
   unsigned int dlci ;
   char master[16U] ;
};

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_217 fr_proto_pvc_info;

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_218 {
   unsigned int interval ;
   unsigned int timeout ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_218 cisco_proto;

#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_219 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_219 ifs_ifsu ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_220 {
   char ifrn_name[16U] ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifr_ifru_221 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_220 ifr_ifrn ;
   union __anonunion_ifr_ifru_221 ifr_ifru ;
};

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kdev_t.h"
struct hlist_bl_node;

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kdev_t.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
struct __anonstruct_226 {
   spinlock_t lock ;
   int count ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
union __anonunion_225 {
   struct __anonstruct_226 __anonCompField___anonunion_225_59 ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
struct lockref {
   union __anonunion_225 __anonCompField_lockref_60 ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct vfsmount;

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct __anonstruct_228 {
   u32 hash ;
   u32 len ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
union __anonunion_227 {
   struct __anonstruct_228 __anonCompField___anonunion_227_61 ;
   u64 hash_len ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct qstr {
   union __anonunion_227 __anonCompField_qstr_62 ;
   unsigned char const *name ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry_operations;

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
union __anonunion_d_u_229 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations const *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_229 d_u ;
};

#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry *, unsigned int ) ;
   int (*d_weak_revalidate)(struct dentry *, unsigned int ) ;
   int (*d_hash)(struct dentry const *, struct qstr *) ;
   int (*d_compare)(struct dentry const *, struct dentry const *, unsigned int , char const *, struct qstr const *) ;
   int (*d_delete)(struct dentry const *) ;
   void (*d_release)(struct dentry *) ;
   void (*d_prune)(struct dentry *) ;
   void (*d_iput)(struct dentry *, struct inode *) ;
   char *(*d_dname)(struct dentry *, char *, int ) ;
   struct vfsmount *(*d_automount)(struct path *) ;
   int (*d_manage)(struct dentry *, bool ) ;
   struct inode *(*d_select_inode)(struct dentry *, unsigned int ) ;
};

#line 586  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/path.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};

#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct __anonstruct_233 {
   struct radix_tree_node *parent ;
   void *private_data ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
union __anonunion_232 {
   struct __anonstruct_233 __anonCompField___anonunion_232_63 ;
   struct callback_head callback_head ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion_232 __anonCompField_radix_tree_node_64 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
};

#line 47 
struct block_device;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/fs.h"
struct export_operations;

#line 63 
struct kstatfs;

#line 64 
struct swap_info_struct;

#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};

#line 212  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dqblk_xfs.h"
struct dquot;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
typedef __kernel_uid32_t projid_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
struct __anonstruct_kprojid_t_237 {
   projid_t val ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_237 kprojid_t;

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
typedef long long qsize_t;

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
union __anonunion_238 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct kqid {
   union __anonunion_238 __anonCompField_kqid_66 ;
   enum quota_type type ;
};

#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};

#line 206 
struct quota_format_type;

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};

#line 272  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};

#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *, int ) ;
   int (*read_file_info)(struct super_block *, int ) ;
   int (*write_file_info)(struct super_block *, int ) ;
   int (*free_file_info)(struct super_block *, int ) ;
   int (*read_dqblk)(struct dquot *) ;
   int (*commit_dqblk)(struct dquot *) ;
   int (*release_dqblk)(struct dquot *) ;
};

#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot *) ;
   struct dquot *(*alloc_dquot)(struct super_block *, int ) ;
   void (*destroy_dquot)(struct dquot *) ;
   int (*acquire_dquot)(struct dquot *) ;
   int (*release_dquot)(struct dquot *) ;
   int (*mark_dirty)(struct dquot *) ;
   int (*write_info)(struct super_block *, int ) ;
   qsize_t *(*get_reserved_space)(struct inode *) ;
   int (*get_projid)(struct inode *, kprojid_t *) ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};

#line 348  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};

#line 394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};

#line 405  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};

#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block *, int , int , struct path *) ;
   int (*quota_off)(struct super_block *, int ) ;
   int (*quota_enable)(struct super_block *, unsigned int ) ;
   int (*quota_disable)(struct super_block *, unsigned int ) ;
   int (*quota_sync)(struct super_block *, int ) ;
   int (*set_info)(struct super_block *, int , struct qc_info *) ;
   int (*get_dqblk)(struct super_block *, struct kqid , struct qc_dqblk *) ;
   int (*set_dqblk)(struct super_block *, struct kqid , struct qc_dqblk *) ;
   int (*get_state)(struct super_block *, struct qc_state *) ;
   int (*rm_xquota)(struct super_block *, unsigned int ) ;
};

#line 432  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops const *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};

#line 496  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops const *ops[3U] ;
};

#line 526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb *, long , long ) ;
   void *private ;
   int ki_flags ;
};

#line 366  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page *, struct writeback_control *) ;
   int (*readpage)(struct file *, struct page *) ;
   int (*writepages)(struct address_space *, struct writeback_control *) ;
   int (*set_page_dirty)(struct page *) ;
   int (*readpages)(struct file *, struct address_space *, struct list_head *, unsigned int ) ;
   int (*write_begin)(struct file *, struct address_space *, loff_t , unsigned int , unsigned int , struct page **, void **) ;
   int (*write_end)(struct file *, struct address_space *, loff_t , unsigned int , unsigned int , struct page *, void *) ;
   sector_t (*bmap)(struct address_space *, sector_t ) ;
   void (*invalidatepage)(struct page *, unsigned int , unsigned int ) ;
   int (*releasepage)(struct page *, gfp_t ) ;
   void (*freepage)(struct page *) ;
   ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *, loff_t ) ;
   int (*migratepage)(struct address_space *, struct page *, struct page *, enum migrate_mode ) ;
   int (*launder_page)(struct page *) ;
   int (*is_partially_uptodate)(struct page *, unsigned long , unsigned long ) ;
   void (*is_dirty_writeback)(struct page *, bool *, bool *) ;
   int (*error_remove_page)(struct address_space *, struct page *) ;
   int (*swap_activate)(struct swap_info_struct *, struct file *, sector_t *) ;
   void (*swap_deactivate)(struct file *) ;
};

#line 423  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations const *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};

#line 443 
struct request_queue;

#line 444 
struct hd_struct;

#line 444 
struct gendisk;

#line 444  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};

#line 560 
struct posix_acl;

#line 561 
struct inode_operations;

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_241 {
   unsigned int const i_nlink ;
   unsigned int __i_nlink ;
};

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_242 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};

#line 561 
struct file_lock_context;

#line 561 
struct cdev;

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_243 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations const *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_241 __anonCompField_inode_67 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_242 __anonCompField_inode_68 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations const *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion_243 __anonCompField_inode_69 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};

#line 807  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};

#line 815  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};

#line 838  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_f_u_244 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};

#line 838  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file {
   union __anonunion_f_u_244 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations const *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred const *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};

#line 923  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
typedef void *fl_owner_t;

#line 924 
struct file_lock;

#line 925  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock *, struct file_lock *) ;
   void (*fl_release_private)(struct file_lock *) ;
};

#line 931  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock *, struct file_lock *) ;
   unsigned long (*lm_owner_key)(struct file_lock *) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t ) ;
   void (*lm_put_owner)(fl_owner_t ) ;
   void (*lm_notify)(struct file_lock *) ;
   int (*lm_grant)(struct file_lock *, int ) ;
   bool (*lm_break)(struct file_lock *) ;
   int (*lm_change)(struct file_lock *, int , struct list_head *) ;
   void (*lm_setup)(struct file_lock *, void **) ;
};

#line 947 
struct net;

#line 952 
struct nlm_lockowner;

#line 953  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct nfs4_lock_state;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};

#line 19 
struct fasync_struct;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct __anonstruct_afs_246 {
   struct list_head link ;
   int state ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
union __anonunion_fl_u_245 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_246 afs ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations const *fl_ops ;
   struct lock_manager_operations const *fl_lmops ;
   union __anonunion_fl_u_245 fl_u ;
};

#line 1005  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};

#line 1221  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};

#line 1256  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};

#line 1287 
struct super_operations;

#line 1287 
struct xattr_handler;

#line 1287 
struct mtd_info;

#line 1287  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations const *s_op ;
   struct dquot_operations const *dq_op ;
   struct quotactl_ops const *s_qcop ;
   struct export_operations const *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler const **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations const *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};

#line 1526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};

#line 1540 
struct dir_context;

#line 1565  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context *, char const *, int , loff_t , u64 , unsigned int ) ;
   loff_t pos ;
};

#line 1572  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file *, loff_t , int ) ;
   ssize_t (*read)(struct file *, char *, size_t , loff_t *) ;
   ssize_t (*write)(struct file *, char const *, size_t , loff_t *) ;
   ssize_t (*read_iter)(struct kiocb *, struct iov_iter *) ;
   ssize_t (*write_iter)(struct kiocb *, struct iov_iter *) ;
   int (*iterate)(struct file *, struct dir_context *) ;
   unsigned int (*poll)(struct file *, struct poll_table_struct *) ;
   long (*unlocked_ioctl)(struct file *, unsigned int , unsigned long ) ;
   long (*compat_ioctl)(struct file *, unsigned int , unsigned long ) ;
   int (*mmap)(struct file *, struct vm_area_struct *) ;
   int (*mremap)(struct file *, struct vm_area_struct *) ;
   int (*open)(struct inode *, struct file *) ;
   int (*flush)(struct file *, fl_owner_t ) ;
   int (*release)(struct inode *, struct file *) ;
   int (*fsync)(struct file *, loff_t , loff_t , int ) ;
   int (*aio_fsync)(struct kiocb *, int ) ;
   int (*fasync)(int , struct file *, int ) ;
   int (*lock)(struct file *, int , struct file_lock *) ;
   ssize_t (*sendpage)(struct file *, struct page *, int , size_t , loff_t *, int ) ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   int (*check_flags)(int ) ;
   int (*flock)(struct file *, int , struct file_lock *) ;
   ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ) ;
   ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ) ;
   int (*setlease)(struct file *, long , struct file_lock **, void **) ;
   long (*fallocate)(struct file *, int , loff_t , loff_t ) ;
   void (*show_fdinfo)(struct seq_file *, struct file *) ;
};

#line 1633  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode *, struct dentry *, unsigned int ) ;
   char const *(*follow_link)(struct dentry *, void **) ;
   int (*permission)(struct inode *, int ) ;
   struct posix_acl *(*get_acl)(struct inode *, int ) ;
   int (*readlink)(struct dentry *, char *, int ) ;
   void (*put_link)(struct inode *, void *) ;
   int (*create)(struct inode *, struct dentry *, umode_t , bool ) ;
   int (*link)(struct dentry *, struct inode *, struct dentry *) ;
   int (*unlink)(struct inode *, struct dentry *) ;
   int (*symlink)(struct inode *, struct dentry *, char const *) ;
   int (*mkdir)(struct inode *, struct dentry *, umode_t ) ;
   int (*rmdir)(struct inode *, struct dentry *) ;
   int (*mknod)(struct inode *, struct dentry *, umode_t , dev_t ) ;
   int (*rename)(struct inode *, struct dentry *, struct inode *, struct dentry *) ;
   int (*rename2)(struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int ) ;
   int (*setattr)(struct dentry *, struct iattr *) ;
   int (*getattr)(struct vfsmount *, struct dentry *, struct kstat *) ;
   int (*setxattr)(struct dentry *, char const *, void const *, size_t , int ) ;
   ssize_t (*getxattr)(struct dentry *, char const *, void *, size_t ) ;
   ssize_t (*listxattr)(struct dentry *, char *, size_t ) ;
   int (*removexattr)(struct dentry *, char const *) ;
   int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 , u64 ) ;
   int (*update_time)(struct inode *, struct timespec *, int ) ;
   int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned int , umode_t , int *) ;
   int (*tmpfile)(struct inode *, struct dentry *, umode_t ) ;
   int (*set_acl)(struct inode *, struct posix_acl *, int ) ;
};

#line 1687  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *) ;
   void (*destroy_inode)(struct inode *) ;
   void (*dirty_inode)(struct inode *, int ) ;
   int (*write_inode)(struct inode *, struct writeback_control *) ;
   int (*drop_inode)(struct inode *) ;
   void (*evict_inode)(struct inode *) ;
   void (*put_super)(struct super_block *) ;
   int (*sync_fs)(struct super_block *, int ) ;
   int (*freeze_super)(struct super_block *) ;
   int (*freeze_fs)(struct super_block *) ;
   int (*thaw_super)(struct super_block *) ;
   int (*unfreeze_fs)(struct super_block *) ;
   int (*statfs)(struct dentry *, struct kstatfs *) ;
   int (*remount_fs)(struct super_block *, int *, char *) ;
   void (*umount_begin)(struct super_block *) ;
   int (*show_options)(struct seq_file *, struct dentry *) ;
   int (*show_devname)(struct seq_file *, struct dentry *) ;
   int (*show_path)(struct seq_file *, struct dentry *) ;
   int (*show_stats)(struct seq_file *, struct dentry *) ;
   ssize_t (*quota_read)(struct super_block *, int , char *, size_t , loff_t ) ;
   ssize_t (*quota_write)(struct super_block *, int , char const *, size_t , loff_t ) ;
   struct dquot **(*get_dquots)(struct inode *) ;
   int (*bdev_try_to_free_page)(struct super_block *, struct page *, gfp_t ) ;
   long (*nr_cached_objects)(struct super_block *, struct shrink_control *) ;
   long (*free_cached_objects)(struct super_block *, struct shrink_control *) ;
};

#line 1926  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_system_type {
   char const *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type *, int , char const *, void *) ;
   void (*kill_sb)(struct super_block *) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};

#line 276  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};

#line 280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};

#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/checksum_64.h"
struct in6_addr;

#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/checksum.h"
struct sk_buff;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
typedef u64 netdev_features_t;

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
union __anonunion_in6_u_261 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
struct in6_addr {
   union __anonunion_in6_u_261 in6_u ;
};

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/in6.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow_dissector.h"
struct pipe_buf_operations;

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow_dissector.h"
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
   struct pipe_buf_operations const *ops ;
   unsigned int flags ;
   unsigned long private ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pipe_fs_i.h"
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int nrbufs ;
   unsigned int curbuf ;
   unsigned int buffers ;
   unsigned int readers ;
   unsigned int writers ;
   unsigned int files ;
   unsigned int waiting_writers ;
   unsigned int r_counter ;
   unsigned int w_counter ;
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pipe_fs_i.h"
struct pipe_buf_operations {
   int can_merge ;
   int (*confirm)(struct pipe_inode_info *, struct pipe_buffer *) ;
   void (*release)(struct pipe_inode_info *, struct pipe_buffer *) ;
   int (*steal)(struct pipe_inode_info *, struct pipe_buffer *) ;
   void (*get)(struct pipe_inode_info *, struct pipe_buffer *) ;
};

#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/splice.h"
struct napi_struct;

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/splice.h"
struct nf_conntrack {
   atomic_t use ;
};

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
enum ldv_25987 {
    BRNF_PROTO_UNCHANGED = 0,
    BRNF_PROTO_8021Q = 1,
    BRNF_PROTO_PPPOE = 2
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_266 {
   struct net_device *physoutdev ;
   char neigh_header[8U] ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_267 {
   __be32 ipv4_daddr ;
   struct in6_addr ipv6_daddr ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   enum ldv_25987 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) orig_proto : 8 ;
   bool pkt_otherhost ;
   __u16 frag_max_size ;
   unsigned int mask ;
   struct net_device *physindev ;
   union __anonunion_266 __anonCompField_nf_bridge_info_73 ;
   union __anonunion_267 __anonCompField_nf_bridge_info_74 ;
};

#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};

#line 403  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_270 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_269 {
   u64 v64 ;
   struct __anonstruct_270 __anonCompField___anonunion_269_75 ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_mstamp {
   union __anonunion_269 __anonCompField_skb_mstamp_76 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_273 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_272 {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion_273 __anonCompField___anonstruct_272_77 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_271 {
   struct __anonstruct_272 __anonCompField___anonunion_271_78 ;
   struct rb_node rbnode ;
};

#line 457 
struct sec_path;

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_275 {
   __u16 csum_start ;
   __u16 csum_offset ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_274 {
   __wsum csum ;
   struct __anonstruct_275 __anonCompField___anonunion_274_80 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_276 {
   unsigned int napi_id ;
   unsigned int sender_cpu ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_277 {
   __u32 mark ;
   __u32 reserved_tailroom ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_278 {
   __be16 inner_protocol ;
   __u8 inner_ipproto ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct sk_buff {
   union __anonunion_271 __anonCompField_sk_buff_79 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   void (*destructor)(struct sk_buff *) ;
   struct sec_path *sp ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   __u16 queue_mapping ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cloned : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) nohdr : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) fclone : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) peeked : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) head_frag : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) xmit_more : 1 ;
   __u32 headers_start[0U] ;
   __u8 __pkt_type_offset[0U] ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) pkt_type : 3 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pfmemalloc : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_df : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) nfctinfo : 3 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) nf_trace : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) ip_summed : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ooo_okay : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) l4_hash : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sw_hash : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wifi_acked_valid : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wifi_acked : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_fcs : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) encapsulation : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) encap_hdr_csum : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_valid : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_complete_sw : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) csum_level : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_bad : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) ndisc_nodetype : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ipvs_property : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) inner_protocol_type : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) remcsum_offload : 1 ;
   __u16 tc_index ;
   __u16 tc_verd ;
   union __anonunion_274 __anonCompField_sk_buff_81 ;
   __u32 priority ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   union __anonunion_276 __anonCompField_sk_buff_82 ;
   __u32 secmark ;
   union __anonunion_277 __anonCompField_sk_buff_83 ;
   union __anonunion_278 __anonCompField_sk_buff_84 ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __be16 protocol ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   __u32 headers_end[0U] ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_ether.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};

#line 125  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char erom_version[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};

#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};

#line 233  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_tunable {
   __u32 cmd ;
   __u32 id ;
   __u32 type_id ;
   __u32 len ;
   void *data[0U] ;
};

#line 245  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 267  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 293  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};

#line 322  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};

#line 438  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};

#line 475  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};

#line 503  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};

#line 605  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};

#line 637  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};

#line 679  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};

#line 712  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};

#line 728  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};

#line 748  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};

#line 759  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};

#line 778  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};

#line 828  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};

#line 999  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};

#line 1007  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 1083  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
};

#line 99  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device *, struct ethtool_cmd *) ;
   int (*set_settings)(struct net_device *, struct ethtool_cmd *) ;
   void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *) ;
   int (*get_regs_len)(struct net_device *) ;
   void (*get_regs)(struct net_device *, struct ethtool_regs *, void *) ;
   void (*get_wol)(struct net_device *, struct ethtool_wolinfo *) ;
   int (*set_wol)(struct net_device *, struct ethtool_wolinfo *) ;
   u32 (*get_msglevel)(struct net_device *) ;
   void (*set_msglevel)(struct net_device *, u32 ) ;
   int (*nway_reset)(struct net_device *) ;
   u32 (*get_link)(struct net_device *) ;
   int (*get_eeprom_len)(struct net_device *) ;
   int (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_coalesce)(struct net_device *, struct ethtool_coalesce *) ;
   int (*set_coalesce)(struct net_device *, struct ethtool_coalesce *) ;
   void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *) ;
   int (*set_ringparam)(struct net_device *, struct ethtool_ringparam *) ;
   void (*get_pauseparam)(struct net_device *, struct ethtool_pauseparam *) ;
   int (*set_pauseparam)(struct net_device *, struct ethtool_pauseparam *) ;
   void (*self_test)(struct net_device *, struct ethtool_test *, u64 *) ;
   void (*get_strings)(struct net_device *, u32 , u8 *) ;
   int (*set_phys_id)(struct net_device *, enum ethtool_phys_id_state ) ;
   void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *, u64 *) ;
   int (*begin)(struct net_device *) ;
   void (*complete)(struct net_device *) ;
   u32 (*get_priv_flags)(struct net_device *) ;
   int (*set_priv_flags)(struct net_device *, u32 ) ;
   int (*get_sset_count)(struct net_device *, int ) ;
   int (*get_rxnfc)(struct net_device *, struct ethtool_rxnfc *, u32 *) ;
   int (*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *) ;
   int (*flash_device)(struct net_device *, struct ethtool_flash *) ;
   int (*reset)(struct net_device *, u32 *) ;
   u32 (*get_rxfh_key_size)(struct net_device *) ;
   u32 (*get_rxfh_indir_size)(struct net_device *) ;
   int (*get_rxfh)(struct net_device *, u32 *, u8 *, u8 *) ;
   int (*set_rxfh)(struct net_device *, u32 const *, u8 const *, u8 const ) ;
   void (*get_channels)(struct net_device *, struct ethtool_channels *) ;
   int (*set_channels)(struct net_device *, struct ethtool_channels *) ;
   int (*get_dump_flag)(struct net_device *, struct ethtool_dump *) ;
   int (*get_dump_data)(struct net_device *, struct ethtool_dump *, void *) ;
   int (*set_dump)(struct net_device *, struct ethtool_dump *) ;
   int (*get_ts_info)(struct net_device *, struct ethtool_ts_info *) ;
   int (*get_module_info)(struct net_device *, struct ethtool_modinfo *) ;
   int (*get_module_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_eee)(struct net_device *, struct ethtool_eee *) ;
   int (*set_eee)(struct net_device *, struct ethtool_eee *) ;
   int (*get_tunable)(struct net_device *, struct ethtool_tunable const *, void *) ;
   int (*set_tunable)(struct net_device *, struct ethtool_tunable const *, void const *) ;
};

#line 235  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow.h"
struct prot_inuse;

#line 236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct u64_stats_sync {
   
};

#line 146  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};

#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[9U] ;
};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[115U] ;
};

#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/packet.h"
struct netns_frags {
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};

#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_frag.h"
struct ipv4_devconf;

#line 185 
struct fib_rules_ops;

#line 186 
struct fib_table;

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
   bool warned ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};

#line 29 
struct xt_table;

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   bool fib_offload_disabled ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct inet_peer_base *peers ;
   struct sock **tcp_sk ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_tcp_ecn_fallback ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_ip_nonlocal_bind ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   int sysctl_tcp_mtu_probing ;
   int sysctl_tcp_base_mss ;
   int sysctl_tcp_probe_threshold ;
   u32 sysctl_tcp_probe_interval ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};

#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops *) ;
   struct dst_entry *(*check)(struct dst_entry *, __u32 ) ;
   unsigned int (*default_advmss)(struct dst_entry const *) ;
   unsigned int (*mtu)(struct dst_entry const *) ;
   u32 *(*cow_metrics)(struct dst_entry *, unsigned long ) ;
   void (*destroy)(struct dst_entry *) ;
   void (*ifdown)(struct dst_entry *, struct net_device *, int ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry *) ;
   void (*link_failure)(struct sk_buff *) ;
   void (*update_pmtu)(struct dst_entry *, struct sock *, struct sk_buff *, u32 ) ;
   void (*redirect)(struct dst_entry *, struct sock *, struct sk_buff *) ;
   int (*local_out)(struct sk_buff *) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry const *, struct sk_buff *, void const *) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int auto_flowlabels ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
   int idgen_retries ;
   int idgen_delay ;
   int flowlabel_state_ranges ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct rt6_info;

#line 39 
struct rt6_statistics;

#line 39 
struct fib6_table;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t fib6_sernum ;
};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
};

#line 20 
struct sctp_mib;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ieee802154_6lowpan.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netfilter.h"
struct nf_logger;

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger const *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/netfilter.h"
struct ebt_table;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   bool clusterip_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_node;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
};

#line 72 
struct ip_conntrack_stat;

#line 72 
struct nf_ct_event_notifier;

#line 72 
struct nf_exp_event_notifier;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct delayed_work ecache_dwork ;
   bool ecache_dwork_pending ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};

#line 114 
struct nft_af_info;

#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   struct nft_af_info *netdev ;
   unsigned int base_seq ;
   u8 gencursor ;
};

#line 508  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/xfrm.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;

#line 465  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long ) ;
   unsigned long data ;
};

#line 672  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flowcache.h"
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flowcache.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
   u8 dbits4 ;
   u8 sbits4 ;
   u8 dbits6 ;
   u8 sbits6 ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct xfrm_policy_hthresh {
   struct work_struct work ;
   seqlock_t lock ;
   u8 lbits4 ;
   u8 rbits4 ;
   u8 lbits6 ;
   u8 rbits6 ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[3U] ;
   struct xfrm_policy_hash policy_bydst[3U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct xfrm_policy_hthresh policy_hthresh ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};

#line 88 
struct mpls_route;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct netns_mpls {
   size_t platform_labels ;
   struct mpls_route **platform_label ;
   struct ctl_table_header *ctl ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mpls.h"
struct proc_ns_operations;

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mpls.h"
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations const *ops ;
   unsigned int inum ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ns_common.h"
struct net_generic;

#line 12 
struct netns_ipvs;

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ns_common.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   atomic64_t cookie_gen ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   spinlock_t nsid_lock ;
   struct idr netns_ids ;
   struct ns_common ns ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct netns_mpls mpls ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};

#line 241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
struct __anonstruct_possible_net_t_295 {
   struct net *net ;
};

#line 241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
typedef struct __anonstruct_possible_net_t_295 possible_net_t;

#line 376 
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2,
    FWNODE_PDATA = 3
};

#line 383  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
struct fwnode_handle {
   enum fwnode_type type ;
   struct fwnode_handle *secondary ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
typedef u32 phandle;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
struct device_node {
   char const *name ;
   char const *type ;
   phandle phandle ;
   char const *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};

#line 338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mii.h"
enum ldv_28748 {
    PHY_INTERFACE_MODE_NA = 0,
    PHY_INTERFACE_MODE_MII = 1,
    PHY_INTERFACE_MODE_GMII = 2,
    PHY_INTERFACE_MODE_SGMII = 3,
    PHY_INTERFACE_MODE_TBI = 4,
    PHY_INTERFACE_MODE_REVMII = 5,
    PHY_INTERFACE_MODE_RMII = 6,
    PHY_INTERFACE_MODE_RGMII = 7,
    PHY_INTERFACE_MODE_RGMII_ID = 8,
    PHY_INTERFACE_MODE_RGMII_RXID = 9,
    PHY_INTERFACE_MODE_RGMII_TXID = 10,
    PHY_INTERFACE_MODE_RTBI = 11,
    PHY_INTERFACE_MODE_SMII = 12,
    PHY_INTERFACE_MODE_XGMII = 13,
    PHY_INTERFACE_MODE_MOCA = 14,
    PHY_INTERFACE_MODE_QSGMII = 15,
    PHY_INTERFACE_MODE_MAX = 16
};

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
typedef enum ldv_28748 phy_interface_t;

#line 126 
enum ldv_28801 {
    MDIOBUS_ALLOCATED = 1,
    MDIOBUS_REGISTERED = 2,
    MDIOBUS_UNREGISTERED = 3,
    MDIOBUS_RELEASED = 4
};

#line 133 
struct phy_device;

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct mii_bus {
   char const *name ;
   char id[17U] ;
   void *priv ;
   int (*read)(struct mii_bus *, int , int ) ;
   int (*write)(struct mii_bus *, int , int , u16 ) ;
   int (*reset)(struct mii_bus *) ;
   struct mutex mdio_lock ;
   struct device *parent ;
   enum ldv_28801 state ;
   struct device dev ;
   struct phy_device *phy_map[32U] ;
   u32 phy_mask ;
   u32 phy_ignore_ta_mask ;
   int *irq ;
};

#line 214 
enum phy_state {
    PHY_DOWN = 0,
    PHY_STARTING = 1,
    PHY_READY = 2,
    PHY_PENDING = 3,
    PHY_UP = 4,
    PHY_AN = 5,
    PHY_RUNNING = 6,
    PHY_NOLINK = 7,
    PHY_FORCING = 8,
    PHY_CHANGELINK = 9,
    PHY_HALTED = 10,
    PHY_RESUMING = 11
};

#line 229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_c45_device_ids {
   u32 devices_in_package ;
   u32 device_ids[8U] ;
};

#line 323 
struct phy_driver;

#line 323  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_device {
   struct phy_driver *drv ;
   struct mii_bus *bus ;
   struct device dev ;
   u32 phy_id ;
   struct phy_c45_device_ids c45_ids ;
   bool is_c45 ;
   bool is_internal ;
   bool has_fixups ;
   bool suspended ;
   enum phy_state state ;
   u32 dev_flags ;
   phy_interface_t interface ;
   int addr ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
   int link ;
   u32 interrupts ;
   u32 supported ;
   u32 advertising ;
   u32 lp_advertising ;
   int autoneg ;
   int link_timeout ;
   int irq ;
   void *priv ;
   struct work_struct phy_queue ;
   struct delayed_work state_queue ;
   atomic_t irq_disable ;
   struct mutex lock ;
   struct net_device *attached_dev ;
   void (*adjust_link)(struct net_device *) ;
};

#line 429  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_driver {
   u32 phy_id ;
   char *name ;
   unsigned int phy_id_mask ;
   u32 features ;
   u32 flags ;
   void const *driver_data ;
   int (*soft_reset)(struct phy_device *) ;
   int (*config_init)(struct phy_device *) ;
   int (*probe)(struct phy_device *) ;
   int (*suspend)(struct phy_device *) ;
   int (*resume)(struct phy_device *) ;
   int (*config_aneg)(struct phy_device *) ;
   int (*aneg_done)(struct phy_device *) ;
   int (*read_status)(struct phy_device *) ;
   int (*ack_interrupt)(struct phy_device *) ;
   int (*config_intr)(struct phy_device *) ;
   int (*did_interrupt)(struct phy_device *) ;
   void (*remove)(struct phy_device *) ;
   int (*match_phy_device)(struct phy_device *) ;
   int (*ts_info)(struct phy_device *, struct ethtool_ts_info *) ;
   int (*hwtstamp)(struct phy_device *, struct ifreq *) ;
   bool (*rxtstamp)(struct phy_device *, struct sk_buff *, int ) ;
   void (*txtstamp)(struct phy_device *, struct sk_buff *, int ) ;
   int (*set_wol)(struct phy_device *, struct ethtool_wolinfo *) ;
   void (*get_wol)(struct phy_device *, struct ethtool_wolinfo *) ;
   void (*link_change_notify)(struct phy_device *) ;
   int (*read_mmd_indirect)(struct phy_device *, int , int , int ) ;
   void (*write_mmd_indirect)(struct phy_device *, int , int , int , u32 ) ;
   int (*module_info)(struct phy_device *, struct ethtool_modinfo *) ;
   int (*module_eeprom)(struct phy_device *, struct ethtool_eeprom *, u8 *) ;
   struct device_driver driver ;
};

#line 803  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct fixed_phy_status {
   int link ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy_fixed.h"
enum dsa_tag_protocol {
    DSA_TAG_PROTO_NONE = 0,
    DSA_TAG_PROTO_DSA = 1,
    DSA_TAG_PROTO_TRAILER = 2,
    DSA_TAG_PROTO_EDSA = 3,
    DSA_TAG_PROTO_BRCM = 4
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy_fixed.h"
struct dsa_chip_data {
   struct device *host_dev ;
   int sw_addr ;
   int eeprom_len ;
   struct device_node *of_node ;
   char *port_names[12U] ;
   struct device_node *port_dn[12U] ;
   s8 *rtable ;
};

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   struct net_device *of_netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};

#line 84 
struct packet_type;

#line 85 
struct dsa_switch;

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   int (*rcv)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *) ;
   enum dsa_tag_protocol tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};

#line 123 
struct dsa_switch_driver;

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   enum dsa_tag_protocol tag_protocol ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct device *master_dev ;
   char hwmon_name[24U] ;
   struct device *hwmon_dev ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   u32 phys_mii_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   enum dsa_tag_protocol tag_protocol ;
   int priv_size ;
   char *(*probe)(struct device *, int ) ;
   int (*setup)(struct dsa_switch *) ;
   int (*set_addr)(struct dsa_switch *, u8 *) ;
   u32 (*get_phy_flags)(struct dsa_switch *, int ) ;
   int (*phy_read)(struct dsa_switch *, int , int ) ;
   int (*phy_write)(struct dsa_switch *, int , int , u16 ) ;
   void (*poll_link)(struct dsa_switch *) ;
   void (*adjust_link)(struct dsa_switch *, int , struct phy_device *) ;
   void (*fixed_link_update)(struct dsa_switch *, int , struct fixed_phy_status *) ;
   void (*get_strings)(struct dsa_switch *, int , uint8_t *) ;
   void (*get_ethtool_stats)(struct dsa_switch *, int , uint64_t *) ;
   int (*get_sset_count)(struct dsa_switch *) ;
   void (*get_wol)(struct dsa_switch *, int , struct ethtool_wolinfo *) ;
   int (*set_wol)(struct dsa_switch *, int , struct ethtool_wolinfo *) ;
   int (*suspend)(struct dsa_switch *) ;
   int (*resume)(struct dsa_switch *) ;
   int (*port_enable)(struct dsa_switch *, int , struct phy_device *) ;
   void (*port_disable)(struct dsa_switch *, int , struct phy_device *) ;
   int (*set_eee)(struct dsa_switch *, int , struct phy_device *, struct ethtool_eee *) ;
   int (*get_eee)(struct dsa_switch *, int , struct ethtool_eee *) ;
   int (*get_temp)(struct dsa_switch *, int *) ;
   int (*get_temp_limit)(struct dsa_switch *, int *) ;
   int (*set_temp_limit)(struct dsa_switch *, int ) ;
   int (*get_temp_alarm)(struct dsa_switch *, bool *) ;
   int (*get_eeprom_len)(struct dsa_switch *) ;
   int (*get_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *) ;
   int (*set_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *) ;
   int (*get_regs_len)(struct dsa_switch *, int ) ;
   void (*get_regs)(struct dsa_switch *, int , struct ethtool_regs *, void *) ;
   int (*port_join_bridge)(struct dsa_switch *, int , u32 ) ;
   int (*port_leave_bridge)(struct dsa_switch *, int , u32 ) ;
   int (*port_stp_update)(struct dsa_switch *, int , u8 ) ;
   int (*fdb_add)(struct dsa_switch *, int , unsigned char const *, u16 ) ;
   int (*fdb_del)(struct dsa_switch *, int , unsigned char const *, u16 ) ;
   int (*fdb_getnext)(struct dsa_switch *, int , unsigned char *, bool *) ;
};

#line 320  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_qcn {
   __u8 rpg_enable[8U] ;
   __u32 rppp_max_rps[8U] ;
   __u32 rpg_time_reset[8U] ;
   __u32 rpg_byte_reset[8U] ;
   __u32 rpg_threshold[8U] ;
   __u32 rpg_max_rate[8U] ;
   __u32 rpg_ai_rate[8U] ;
   __u32 rpg_hai_rate[8U] ;
   __u32 rpg_gd[8U] ;
   __u32 rpg_min_dec_fac[8U] ;
   __u32 rpg_min_rate[8U] ;
   __u32 cndd_state_machine[8U] ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_qcn_stats {
   __u64 rppp_rp_centiseconds[8U] ;
   __u32 rppp_created_rps[8U] ;
};

#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};

#line 164  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};

#line 202  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};

#line 236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_setets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_getmaxrate)(struct net_device *, struct ieee_maxrate *) ;
   int (*ieee_setmaxrate)(struct net_device *, struct ieee_maxrate *) ;
   int (*ieee_getqcn)(struct net_device *, struct ieee_qcn *) ;
   int (*ieee_setqcn)(struct net_device *, struct ieee_qcn *) ;
   int (*ieee_getqcnstats)(struct net_device *, struct ieee_qcn_stats *) ;
   int (*ieee_getpfc)(struct net_device *, struct ieee_pfc *) ;
   int (*ieee_setpfc)(struct net_device *, struct ieee_pfc *) ;
   int (*ieee_getapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_setapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_delapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_peer_getets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_peer_getpfc)(struct net_device *, struct ieee_pfc *) ;
   u8 (*getstate)(struct net_device *) ;
   u8 (*setstate)(struct net_device *, u8 ) ;
   void (*getpermhwaddr)(struct net_device *, u8 *) ;
   void (*setpgtccfgtx)(struct net_device *, int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgtx)(struct net_device *, int , u8 ) ;
   void (*setpgtccfgrx)(struct net_device *, int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgrx)(struct net_device *, int , u8 ) ;
   void (*getpgtccfgtx)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *) ;
   void (*getpgbwgcfgtx)(struct net_device *, int , u8 *) ;
   void (*getpgtccfgrx)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *) ;
   void (*getpgbwgcfgrx)(struct net_device *, int , u8 *) ;
   void (*setpfccfg)(struct net_device *, int , u8 ) ;
   void (*getpfccfg)(struct net_device *, int , u8 *) ;
   u8 (*setall)(struct net_device *) ;
   u8 (*getcap)(struct net_device *, int , u8 *) ;
   int (*getnumtcs)(struct net_device *, int , u8 *) ;
   int (*setnumtcs)(struct net_device *, int , u8 ) ;
   u8 (*getpfcstate)(struct net_device *) ;
   void (*setpfcstate)(struct net_device *, u8 ) ;
   void (*getbcncfg)(struct net_device *, int , u32 *) ;
   void (*setbcncfg)(struct net_device *, int , u32 ) ;
   void (*getbcnrp)(struct net_device *, int , u8 *) ;
   void (*setbcnrp)(struct net_device *, int , u8 ) ;
   int (*setapp)(struct net_device *, u8 , u16 , u8 ) ;
   int (*getapp)(struct net_device *, u8 , u16 ) ;
   u8 (*getfeatcfg)(struct net_device *, int , u8 *) ;
   u8 (*setfeatcfg)(struct net_device *, int , u8 ) ;
   u8 (*getdcbx)(struct net_device *) ;
   u8 (*setdcbx)(struct net_device *, u8 ) ;
   int (*peer_getappinfo)(struct net_device *, struct dcb_peer_app_info *, u16 *) ;
   int (*peer_getapptable)(struct net_device *, struct dcb_app *) ;
   int (*cee_peer_getpg)(struct net_device *, struct cee_pg *) ;
   int (*cee_peer_getpfc)(struct net_device *, struct cee_pfc *) ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};

#line 515  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};

#line 1628  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/security.h"
struct mnt_namespace;

#line 1629 
struct ipc_namespace;

#line 1630  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};

#line 147  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr const *nlh ;
   int (*dump)(struct sk_buff *, struct netlink_callback *) ;
   int (*done)(struct netlink_callback *) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netlink.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};

#line 643  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_link.h"
struct ifla_vf_stats {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 broadcast ;
   __u64 multicast ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
   __u32 rss_query_en ;
};

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_bonding.h"
struct netpoll_info;

#line 119 
struct wireless_dev;

#line 120 
struct wpan_dev;

#line 121 
struct mpls_dev;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = -2147483648,
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;

#line 129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};

#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};

#line 245  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff *, struct net_device *, unsigned short , void const *, void const *, unsigned int ) ;
   int (*parse)(struct sk_buff const *, unsigned char *) ;
   int (*cache)(struct neighbour const *, struct hh_cache *, __be16 ) ;
   void (*cache_update)(struct hh_cache *, struct net_device const *, unsigned char const *) ;
};

#line 295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct *, int ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct hrtimer timer ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};

#line 340 
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
};

#line 388  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;

#line 389  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff **);

#line 537 
struct Qdisc;

#line 537  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
   unsigned long tx_maxrate ;
};

#line 607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};

#line 619  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};

#line 631  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};

#line 683  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};

#line 706  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};

#line 719  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};

#line 730  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};

#line 741  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};

#line 757  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_phys_item_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};

#line 770  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device *) ;
   void (*ndo_uninit)(struct net_device *) ;
   int (*ndo_open)(struct net_device *) ;
   int (*ndo_stop)(struct net_device *) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff *, struct net_device *) ;
   u16 (*ndo_select_queue)(struct net_device *, struct sk_buff *, void *, u16 (*)(struct net_device *, struct sk_buff *)) ;
   void (*ndo_change_rx_flags)(struct net_device *, int ) ;
   void (*ndo_set_rx_mode)(struct net_device *) ;
   int (*ndo_set_mac_address)(struct net_device *, void *) ;
   int (*ndo_validate_addr)(struct net_device *) ;
   int (*ndo_do_ioctl)(struct net_device *, struct ifreq *, int ) ;
   int (*ndo_set_config)(struct net_device *, struct ifmap *) ;
   int (*ndo_change_mtu)(struct net_device *, int ) ;
   int (*ndo_neigh_setup)(struct net_device *, struct neigh_parms *) ;
   void (*ndo_tx_timeout)(struct net_device *) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device *, struct rtnl_link_stats64 *) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device *) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device *, __be16 , u16 ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device *, __be16 , u16 ) ;
   void (*ndo_poll_controller)(struct net_device *) ;
   int (*ndo_netpoll_setup)(struct net_device *, struct netpoll_info *) ;
   void (*ndo_netpoll_cleanup)(struct net_device *) ;
   int (*ndo_busy_poll)(struct napi_struct *) ;
   int (*ndo_set_vf_mac)(struct net_device *, int , u8 *) ;
   int (*ndo_set_vf_vlan)(struct net_device *, int , u16 , u8 ) ;
   int (*ndo_set_vf_rate)(struct net_device *, int , int , int ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device *, int , bool ) ;
   int (*ndo_get_vf_config)(struct net_device *, int , struct ifla_vf_info *) ;
   int (*ndo_set_vf_link_state)(struct net_device *, int , int ) ;
   int (*ndo_get_vf_stats)(struct net_device *, int , struct ifla_vf_stats *) ;
   int (*ndo_set_vf_port)(struct net_device *, int , struct nlattr **) ;
   int (*ndo_get_vf_port)(struct net_device *, int , struct sk_buff *) ;
   int (*ndo_set_vf_rss_query_en)(struct net_device *, int , bool ) ;
   int (*ndo_setup_tc)(struct net_device *, u8 ) ;
   int (*ndo_fcoe_enable)(struct net_device *) ;
   int (*ndo_fcoe_disable)(struct net_device *) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device *, u16 , struct scatterlist *, unsigned int ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device *, u16 ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device *, u16 , struct scatterlist *, unsigned int ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device *, struct netdev_fcoe_hbainfo *) ;
   int (*ndo_fcoe_get_wwn)(struct net_device *, u64 *, int ) ;
   int (*ndo_rx_flow_steer)(struct net_device *, struct sk_buff const *, u16 , u32 ) ;
   int (*ndo_add_slave)(struct net_device *, struct net_device *) ;
   int (*ndo_del_slave)(struct net_device *, struct net_device *) ;
   netdev_features_t (*ndo_fix_features)(struct net_device *, netdev_features_t ) ;
   int (*ndo_set_features)(struct net_device *, netdev_features_t ) ;
   int (*ndo_neigh_construct)(struct neighbour *) ;
   void (*ndo_neigh_destroy)(struct neighbour *) ;
   int (*ndo_fdb_add)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 , u16 ) ;
   int (*ndo_fdb_del)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 ) ;
   int (*ndo_fdb_dump)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int ) ;
   int (*ndo_bridge_setlink)(struct net_device *, struct nlmsghdr *, u16 ) ;
   int (*ndo_bridge_getlink)(struct sk_buff *, u32 , u32 , struct net_device *, u32 , int ) ;
   int (*ndo_bridge_dellink)(struct net_device *, struct nlmsghdr *, u16 ) ;
   int (*ndo_change_carrier)(struct net_device *, bool ) ;
   int (*ndo_get_phys_port_id)(struct net_device *, struct netdev_phys_item_id *) ;
   int (*ndo_get_phys_port_name)(struct net_device *, char *, size_t ) ;
   void (*ndo_add_vxlan_port)(struct net_device *, sa_family_t , __be16 ) ;
   void (*ndo_del_vxlan_port)(struct net_device *, sa_family_t , __be16 ) ;
   void *(*ndo_dfwd_add_station)(struct net_device *, struct net_device *) ;
   void (*ndo_dfwd_del_station)(struct net_device *, void *) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff *, struct net_device *, void *) ;
   int (*ndo_get_lock_subclass)(struct net_device *) ;
   netdev_features_t (*ndo_features_check)(struct sk_buff *, struct net_device *, netdev_features_t ) ;
   int (*ndo_set_tx_maxrate)(struct net_device *, int , u32 ) ;
   int (*ndo_get_iflink)(struct net_device const *) ;
};

#line 1243 
enum ldv_30513 {
    NETREG_UNINITIALIZED = 0,
    NETREG_REGISTERED = 1,
    NETREG_UNREGISTERING = 2,
    NETREG_UNREGISTERED = 3,
    NETREG_RELEASED = 4,
    NETREG_DUMMY = 5
};

#line 1252 
enum ldv_30514 {
    RTNL_LINK_INITIALIZED = 0,
    RTNL_LINK_INITIALIZING = 1
};

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct __anonstruct_adj_list_305 {
   struct list_head upper ;
   struct list_head lower ;
};

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct __anonstruct_all_adj_list_306 {
   struct list_head upper ;
   struct list_head lower ;
};

#line 1257 
struct iw_handler_def;

#line 1257 
struct iw_public_data;

#line 1257 
struct switchdev_ops;

#line 1257 
struct vlan_info;

#line 1257 
struct tipc_bearer;

#line 1257 
struct in_device;

#line 1257 
struct dn_dev;

#line 1257 
struct tcf_proto;

#line 1257 
struct cpu_rmap;

#line 1257 
struct pcpu_lstats;

#line 1257 
struct pcpu_sw_netstats;

#line 1257 
struct pcpu_dstats;

#line 1257 
struct pcpu_vstats;

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
union __anonunion_307 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};

#line 1257 
struct garp_port;

#line 1257 
struct mrp_port;

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   atomic_t carrier_changes ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct list_head ptype_all ;
   struct list_head ptype_specific ;
   struct __anonstruct_adj_list_305 adj_list ;
   struct __anonstruct_all_adj_list_306 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int group ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   struct iw_handler_def const *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops const *netdev_ops ;
   struct ethtool_ops const *ethtool_ops ;
   struct switchdev_ops const *switchdev_ops ;
   struct header_ops const *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   unsigned char name_assign_type ;
   bool uc_promisc ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   struct wpan_dev *ieee802154_ptr ;
   struct mpls_dev *mpls_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   unsigned long gro_flush_timeout ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct tcf_proto *ingress_cl_list ;
   struct netdev_queue *ingress_queue ;
   struct list_head nf_hooks_ingress ;
   unsigned char broadcast[32U] ;
   struct cpu_rmap *rx_cpu_rmap ;
   struct hlist_node index_hlist ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   int watchdog_timeo ;
   struct xps_dev_maps *xps_maps ;
   unsigned long trans_start ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct list_head link_watch_list ;
   enum ldv_30513 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) reg_state : 8 ;
   bool dismantle ;
   enum ldv_30514 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) rtnl_link_state : 16 ;
   void (*destructor)(struct net_device *) ;
   struct netpoll_info *npinfo ;
   possible_net_t nd_net ;
   union __anonunion_307 __anonCompField_net_device_94 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group const *sysfs_groups[4U] ;
   struct attribute_group const *sysfs_rx_queue_group ;
   struct rtnl_link_ops const *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   u16 gso_min_segs ;
   struct dcbnl_rtnl_ops const *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
};

#line 1978  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct packet_type {
   __be16 type ;
   struct net_device *dev ;
   int (*func)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *) ;
   bool (*id_match)(struct packet_type *, struct sock *) ;
   void *af_packet_priv ;
   struct list_head list ;
};

#line 2025  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};

#line 2893 
enum skb_free_reason {
    SKB_REASON_CONSUMED = 0,
    SKB_REASON_DROPPED = 1
};

#line 199  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/vmalloc.h"
struct octeon_iq_config {
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) max_iqs : 8 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(32))) pending_list_size : 32 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(32))) instr_type : 32 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) db_min : 8 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) db_timeout : 16 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(32))) reserved : 32 ;
};

#line 197  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_config.h"
struct octeon_oq_config {
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) max_oqs : 8 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(32))) info_ptr : 32 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) refill_threshold : 16 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) oq_intr_pkt : 16 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) oq_intr_time : 16 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) pkts_per_intr : 16 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) reserved : 16 ;
};

#line 267  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_config.h"
struct octeon_nic_if_config {
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) max_txqs : 16 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) num_txqs : 16 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) max_rxqs : 16 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) num_rxqs : 16 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) num_rx_descs : 16 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) num_tx_descs : 16 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) rx_buf_size : 16 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) gmx_port_id : 8 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) base_queue : 16 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(56))) reserved : 56 ;
};

#line 333  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_config.h"
struct octeon_misc_config {
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) ctrlq_grp : 4 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) enable_sli_oq_bp : 1 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(32))) oct_link_query_interval : 32 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(32))) host_link_query_interval : 32 ;
};

#line 360  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_config.h"
struct octeon_config {
   u16 card_type ;
   char *card_name ;
   struct octeon_iq_config iq ;
   struct octeon_oq_config oq ;
   struct octeon_nic_if_config nic_if_cfg[32U] ;
   struct octeon_misc_config misc ;
   int num_nic_ports ;
   int num_def_tx_descs ;
   int num_def_rx_descs ;
   int def_rx_buf_size ;
};

#line 377  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/liquidio_common.h"
struct __anonstruct_r_314 {
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(32))) ossp : 32 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) reserved : 4 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(13))) rid : 13 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) len : 3 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) subcode : 8 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) opcode : 4 ;
};

#line 377  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/liquidio_common.h"
struct __anonstruct_r_dh_315 {
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) has_hwtstamp : 1 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) csum_verified : 3 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) link : 8 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(24))) extra : 24 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(13))) rid : 13 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) len : 3 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) subcode : 8 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) opcode : 4 ;
};

#line 377  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/liquidio_common.h"
struct __anonstruct_r_core_drv_init_316 {
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) app_mode : 16 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) app_cap_flags : 4 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) max_nic_ports : 8 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) num_gmx_ports : 8 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(13))) rid : 13 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) len : 3 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) subcode : 8 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) opcode : 4 ;
};

#line 377  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/liquidio_common.h"
struct __anonstruct_r_nic_info_317 {
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(7))) ifidx : 7 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(25))) extra : 25 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) reserved : 4 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(13))) rid : 13 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) len : 3 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) subcode : 8 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) opcode : 4 ;
};

#line 377  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/liquidio_common.h"
union octeon_rh {
   u64 u64 ;
   struct __anonstruct_r_314 r ;
   struct __anonstruct_r_dh_315 r_dh ;
   struct __anonstruct_r_core_drv_init_316 r_core_drv_init ;
   struct __anonstruct_r_nic_info_317 r_nic_info ;
};

#line 630  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/liquidio_common.h"
struct oct_intrmod_cfg {
   u64 intrmod_enable ;
   u64 intrmod_check_intrvl ;
   u64 intrmod_maxpkt_ratethr ;
   u64 intrmod_minpkt_ratethr ;
   u64 intrmod_maxcnt_trigger ;
   u64 intrmod_maxtmr_trigger ;
   u64 intrmod_mincnt_trigger ;
   u64 intrmod_mintmr_trigger ;
};

#line 672  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/liquidio_common.h"
struct octeon_droq_desc {
   u64 buffer_ptr ;
   u64 info_ptr ;
};

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.h"
struct octeon_droq_info {
   union octeon_rh rh ;
   u64 length ;
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.h"
struct octeon_recv_buffer {
   void *buffer ;
   u8 *data ;
};

#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.h"
struct oct_droq_stats {
   u64 pkts_received ;
   u64 bytes_received ;
   u64 dropped_nodispatch ;
   u64 dropped_nomem ;
   u64 dropped_toomany ;
   u64 rx_pkts_received ;
   u64 rx_bytes_received ;
   u64 rx_dropped ;
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.h"
struct octeon_recv_pkt {
   u16 buffer_count ;
   u16 octeon_id ;
   u32 length ;
   union octeon_rh rh ;
   void *buffer_ptr[64U] ;
   u32 buffer_size[64U] ;
};

#line 146  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.h"
struct octeon_recv_info {
   void *rsvd ;
   struct octeon_recv_pkt *recv_pkt ;
};

#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.h"
typedef int (*octeon_dispatch_fn_t)(struct octeon_recv_info *, void *);

#line 206  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.h"
struct octeon_droq_ops {
   void (*fptr)(u32 , void *, u32 , union octeon_rh *, void *) ;
   void (*napi_fn)(void *) ;
   u32 poll_mode ;
   u32 drop_on_max ;
};

#line 231 
struct octeon_device;

#line 231  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.h"
struct octeon_droq {
   spinlock_t lock ;
   u32 q_no ;
   struct octeon_droq_ops ops ;
   struct octeon_device *oct_dev ;
   struct octeon_droq_desc *desc_ring ;
   u32 read_idx ;
   u32 write_idx ;
   u32 refill_idx ;
   atomic_t pkts_pending ;
   u32 max_count ;
   u32 refill_count ;
   u32 pkts_per_intr ;
   u32 refill_threshold ;
   u32 max_empty_descs ;
   struct octeon_droq_info *info_list ;
   struct octeon_recv_buffer *recv_buf_list ;
   u32 buffer_size ;
   void *pkts_credit_reg ;
   void *pkts_sent_reg ;
   struct list_head dispatch_list ;
   struct oct_droq_stats stats ;
   size_t desc_ring_dma ;
   size_t info_base_addr ;
   size_t info_list_dma ;
   u32 info_alloc_size ;
   void *app_ctx ;
   struct napi_struct napi ;
   u32 cpu_id ;
   struct call_single_data csd ;
};

#line 424  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.h"
struct octeon_request_list {
   u32 reqtype ;
   void *buf ;
};

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_iq.h"
struct oct_iq_stats {
   u64 instr_posted ;
   u64 instr_processed ;
   u64 instr_dropped ;
   u64 bytes_sent ;
   u64 sgentry_sent ;
   u64 tx_done ;
   u64 tx_iq_busy ;
   u64 tx_dropped ;
   u64 tx_tot_bytes ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_iq.h"
struct octeon_instr_queue {
   spinlock_t lock ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) iqcmd_64B : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(5))) iq_no : 5 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(17))) rsvd : 17 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) do_auto_flush : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) status : 8 ;
   u32 max_count ;
   u32 host_write_index ;
   u32 octeon_read_index ;
   u32 flush_index ;
   atomic_t instr_pending ;
   u32 reset_instr_cnt ;
   u8 *base_addr ;
   struct octeon_request_list *request_list ;
   void *doorbell_reg ;
   void *inst_cnt_reg ;
   u32 fill_cnt ;
   u32 fill_threshold ;
   u64 last_db_time ;
   u32 db_timeout ;
   struct oct_iq_stats stats ;
   u64 base_addr_dma ;
   void *app_ctx ;
};

#line 242  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_iq.h"
struct octeon_sc_buffer_pool {
   struct list_head head ;
   spinlock_t lock ;
   atomic_t alloc_buf_count ;
};

#line 317  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_iq.h"
struct octeon_response_list {
   struct list_head head ;
   spinlock_t lock ;
   atomic_t pending_req_count ;
};

#line 145  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/response_manager.h"
struct octeon_dispatch {
   struct list_head list ;
   u16 opcode ;
   int (*dispatch_fn)(struct octeon_recv_info *, void *) ;
   void *arg ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.h"
struct octeon_dispatch_list {
   spinlock_t lock ;
   u32 count ;
   struct octeon_dispatch *dlist ;
};

#line 126  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.h"
struct octeon_mmio {
   u64 start ;
   u32 len ;
   u32 mapped_len ;
   u8 *hw_addr ;
   u32 done ;
};

#line 151  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.h"
struct octeon_io_enable {
   u32 iq ;
   u32 oq ;
   u32 iq64B ;
};

#line 159  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.h"
struct octeon_reg_list {
   u32 *pci_win_wr_addr_hi ;
   u32 *pci_win_wr_addr_lo ;
   u64 *pci_win_wr_addr ;
   u32 *pci_win_rd_addr_hi ;
   u32 *pci_win_rd_addr_lo ;
   u64 *pci_win_rd_addr ;
   u32 *pci_win_wr_data_hi ;
   u32 *pci_win_wr_data_lo ;
   u64 *pci_win_wr_data ;
   u32 *pci_win_rd_data_hi ;
   u32 *pci_win_rd_data_lo ;
   u64 *pci_win_rd_data ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.h"
struct octeon_console {
   u32 active ;
   u32 waiting ;
   u64 addr ;
   u32 buffer_size ;
   u64 input_base_addr ;
   u64 output_base_addr ;
   char leftover[512U] ;
};

#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.h"
struct octeon_board_info {
   char name[32U] ;
   char serial_number[64U] ;
   u64 major ;
   u64 minor ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.h"
struct octeon_fn_list {
   void (*setup_iq_regs)(struct octeon_device *, u32 ) ;
   void (*setup_oq_regs)(struct octeon_device *, u32 ) ;
   irqreturn_t (*process_interrupt_regs)(void *) ;
   int (*soft_reset)(struct octeon_device *) ;
   int (*setup_device_regs)(struct octeon_device *) ;
   void (*reinit_regs)(struct octeon_device *) ;
   void (*bar1_idx_setup)(struct octeon_device *, u64 , u32 , int ) ;
   void (*bar1_idx_write)(struct octeon_device *, u32 , u32 ) ;
   u32 (*bar1_idx_read)(struct octeon_device *, u32 ) ;
   u32 (*update_iq_read_idx)(struct octeon_device *, struct octeon_instr_queue *) ;
   void (*enable_oq_pkt_time_intr)(struct octeon_device *, u32 ) ;
   void (*disable_oq_pkt_time_intr)(struct octeon_device *, u32 ) ;
   void (*enable_interrupt)(void *) ;
   void (*disable_interrupt)(void *) ;
   void (*enable_io_queues)(struct octeon_device *) ;
   void (*disable_io_queues)(struct octeon_device *) ;
};

#line 219  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.h"
struct cvmx_bootmem_named_block_desc {
   u64 base_addr ;
   u64 size ;
   char name[128U] ;
};

#line 241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.h"
struct oct_fw_info {
   u32 max_nic_ports ;
   u32 num_gmx_ports ;
   u64 app_cap_flags ;
   u32 app_mode ;
   char liquidio_firmware_version[32U] ;
};

#line 253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.h"
struct cavium_wk {
   struct delayed_work work ;
   void *ctxptr ;
   size_t ctxul ;
};

#line 260  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.h"
struct cavium_wq {
   struct workqueue_struct *wq ;
   struct cavium_wk wk ;
};

#line 265  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.h"
struct octdev_props {
   struct net_device *netdev ;
};

#line 272  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.h"
struct octeon_device {
   spinlock_t pci_win_lock ;
   spinlock_t mem_access_lock ;
   struct pci_dev *pci_dev ;
   void *chip ;
   u32 ifcount ;
   struct octdev_props props[32U] ;
   u16 chip_id ;
   u16 rev_id ;
   u32 octeon_id ;
   u16 pcie_port ;
   u16 flags ;
   atomic_t status ;
   struct octeon_mmio mmio[3U] ;
   struct octeon_reg_list reg_list ;
   struct octeon_fn_list fn_list ;
   struct octeon_board_info boardinfo ;
   u32 num_iqs ;
   struct octeon_sc_buffer_pool sc_buf_pool ;
   struct octeon_instr_queue *instr_queue[32U] ;
   struct octeon_response_list response_list[4U] ;
   u32 num_oqs ;
   struct octeon_droq *droq[32U] ;
   struct octeon_io_enable io_qmask ;
   struct octeon_dispatch_list dispatch ;
   struct oct_intrmod_cfg intrmod ;
   u32 int_status ;
   u64 droq_intr ;
   u64 bootmem_desc_addr ;
   struct cvmx_bootmem_named_block_desc bootmem_named_block_desc ;
   u64 console_desc_addr ;
   u32 num_consoles ;
   struct octeon_console console[32U] ;
   u64 coproc_clock_rate ;
   u32 app_mode ;
   struct oct_fw_info fw_info ;
   char device_name[32U] ;
   void *app_ctx ;
   struct cavium_wq dma_comp_wq ;
   struct cavium_wq check_db_wq[32U] ;
   struct cavium_wk nic_poll_work ;
   struct cavium_wk console_poll_work[32U] ;
   void *priv ;
};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/pps.h"
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations const *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};

#line 223  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_network.h"
struct octeon_cn6xxx {
   u8 *intr_sum_reg64 ;
   u8 *intr_enb_reg64 ;
   u64 intr_mask64 ;
   struct octeon_config *conf ;
   spinlock_t lock_for_droq_int_enb_reg ;
};

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.c"
struct __dispatch {
   struct list_head list ;
   struct octeon_recv_info *rinfo ;
   int (*disp_fn)(struct octeon_recv_info *, void *) ;
};

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.h"
enum octeon_pcie_mps {
    PCIE_MPS_DEFAULT = -1,
    PCIE_MPS_128B = 0,
    PCIE_MPS_256B = 1
};

#line 60 
enum octeon_pcie_mrrs {
    PCIE_MRRS_DEFAULT = -1,
    PCIE_MRRS_128B = 0,
    PCIE_MRRS_256B = 1,
    PCIE_MRRS_512B = 2,
    PCIE_MRRS_1024B = 3,
    PCIE_MRRS_2048B = 4,
    PCIE_MRRS_4096B = 5
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
enum ldv_11876 {
    WORK_STRUCT_PENDING_BIT = 0,
    WORK_STRUCT_DELAYED_BIT = 1,
    WORK_STRUCT_PWQ_BIT = 2,
    WORK_STRUCT_LINKED_BIT = 3,
    WORK_STRUCT_STATIC_BIT = 4,
    WORK_STRUCT_COLOR_SHIFT = 5,
    WORK_STRUCT_COLOR_BITS = 4,
    WORK_STRUCT_PENDING = 1,
    WORK_STRUCT_DELAYED = 2,
    WORK_STRUCT_PWQ = 4,
    WORK_STRUCT_LINKED = 8,
    WORK_STRUCT_STATIC = 16,
    WORK_NR_COLORS = 15,
    WORK_NO_COLOR = 15,
    WORK_CPU_UNBOUND = 8192,
    WORK_STRUCT_FLAG_BITS = 9,
    WORK_OFFQ_FLAG_BASE = 5,
    __WORK_OFFQ_CANCELING = 5,
    WORK_OFFQ_CANCELING = 32,
    WORK_OFFQ_FLAG_BITS = 1,
    WORK_OFFQ_POOL_SHIFT = 6,
    WORK_OFFQ_LEFT = 58,
    WORK_OFFQ_POOL_BITS = 31,
    WORK_OFFQ_POOL_NONE = 2147483647,
    WORK_STRUCT_FLAG_MASK = 511,
    WORK_STRUCT_WQ_DATA_MASK = -512,
    WORK_STRUCT_NO_POOL = 137438953408,
    WORK_BUSY_PENDING = 1,
    WORK_BUSY_RUNNING = 2,
    WORKER_DESC_LEN = 24
};

#line 282  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/liquidio_common.h"
struct octeon_instr_ih {
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(32))) tag : 32 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) tagtype : 2 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) rs : 1 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) grp : 4 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) qos : 3 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))) fsz : 6 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(14))) dlengsz : 14 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) gather : 1 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) raw : 1 ;
};

#line 343  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/liquidio_common.h"
struct octeon_instr_irh {
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(32))) ossp : 32 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) reserved : 4 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(13))) rid : 13 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) len : 3 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(7))) subcode : 7 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) rflag : 1 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) opcode : 4 ;
};

#line 364  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/liquidio_common.h"
struct octeon_instr_rdp {
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))) rlen : 12 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) pcie_port : 3 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(49))) reserved : 49 ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_iq.h"
struct octeon_instr_64B {
   u64 dptr ;
   u64 ih ;
   u64 irh ;
   u64 ossp[2U] ;
   u64 rdp ;
   u64 rptr ;
   u64 reserved ;
};

#line 202  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_iq.h"
struct octeon_soft_command {
   struct list_head node ;
   u64 dma_addr ;
   u32 size ;
   struct octeon_instr_64B cmd ;
   u64 *status_word ;
   void *virtdptr ;
   u64 dmadptr ;
   u32 datasize ;
   void *virtrptr ;
   u64 dmarptr ;
   u32 rdatasize ;
   void *ctxptr ;
   u32 ctxsize ;
   size_t wait_time ;
   size_t timeout ;
   u32 iq_no ;
   void (*callback)(struct octeon_device *, u32 , void *) ;
   void *callback_arg ;
};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/liquidio_image.h"
struct iq_post_status {
   int status ;
   int index ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u64 __be64;

#line 395  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_config.h"
struct octeon_core_setup {
   u64 corefreq ;
   char boardname[32U] ;
   char board_serial_number[64U] ;
   u64 board_rev_major ;
   u64 board_rev_minor ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn68xx_device.h"
struct octeon_firmware_desc {
   __be64 addr ;
   __be32 len ;
   __be32 crc32 ;
};

#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/liquidio_image.h"
struct octeon_firmware_file_header {
   __be32 magic ;
   char version[16U] ;
   char bootcmd[1024U] ;
   __be32 num_images ;
   struct octeon_firmware_desc desc[16U] ;
   __be32 pad ;
   __be32 crc32 ;
};

#line 334  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
struct octeon_config_ptr {
   u32 conf_type ;
};

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef long long __s64;

#line 493  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
struct __anonstruct_mm_segment_t_1329 {
   unsigned long seg ;
};

#line 493  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
typedef struct __anonstruct_mm_segment_t_1329 mm_segment_t;

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/atomic-long.h"
struct thread_info {
   struct task_struct *task ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int saved_preempt_count ;
   mm_segment_t addr_limit ;
   void *sysenter_return ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sig_on_uaccess_error : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) uaccess_err : 1 ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
struct __wait_queue;

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t *, unsigned int , int , void *) ;
   struct list_head task_list ;
};

#line 180  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/liquidio_common.h"
struct __anonstruct_s_1609 {
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) param3 : 8 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) param2 : 16 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(29))) param1 : 29 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))) more : 6 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(5))) cmd : 5 ;
};

#line 180  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/liquidio_common.h"
union octnet_cmd {
   u64 u64 ;
   struct __anonstruct_s_1609 s ;
};

#line 491  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/liquidio_common.h"
struct __anonstruct_s_1615 {
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(10))) reserved : 10 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pause : 1 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) interface : 4 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) autoneg : 1 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) speed : 16 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) mtu : 16 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) status : 8 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) duplex : 8 ;
};

#line 491  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/liquidio_common.h"
union oct_link_status {
   u64 u64 ;
   struct __anonstruct_s_1615 s ;
};

#line 518  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/liquidio_common.h"
struct oct_link_info {
   union oct_link_status link ;
   u64 hw_addr ;
   u8 ifidx ;
   u8 num_rxpciq ;
   u8 num_txpciq ;
   u8 rsvd[3U] ;
   u16 gmxport ;
   u8 txpciq[32U] ;
   u8 rxpciq[32U] ;
};

#line 609  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/liquidio_common.h"
struct oct_mdio_cmd {
   u64 op ;
   u64 mdio_addr ;
   u64 value1 ;
   u64 value2 ;
   u64 value3 ;
};

#line 392  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.h"
struct oct_intrmod_cmd {
   struct octeon_device *oct_dev ;
   struct octeon_soft_command *sc ;
   struct oct_intrmod_cfg *cfg ;
};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_nic.h"
struct octnic_ctrl_pkt {
   union octnet_cmd ncmd ;
   void *data ;
   u64 dmadata ;
   void *rdata ;
   u64 dmardata ;
   u64 udd[32U] ;
   size_t wait_time ;
   u64 netpndev ;
   void (*cb_fn)(void *) ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_nic.h"
struct octnic_ctrl_params {
   u32 resp_order ;
};

#line 135  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pps_kernel.h"
struct ptp_clock_time {
   __s64 sec ;
   __u32 nsec ;
   __u32 reserved ;
};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ptp_clock.h"
struct ptp_extts_request {
   unsigned int index ;
   unsigned int flags ;
   unsigned int rsv[2U] ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ptp_clock.h"
struct ptp_perout_request {
   struct ptp_clock_time start ;
   struct ptp_clock_time period ;
   unsigned int index ;
   unsigned int flags ;
   unsigned int rsv[4U] ;
};

#line 83 
enum ptp_pin_function {
    PTP_PF_NONE = 0,
    PTP_PF_EXTTS = 1,
    PTP_PF_PEROUT = 2,
    PTP_PF_PHYSYNC = 3
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ptp_clock.h"
struct ptp_pin_desc {
   char name[64U] ;
   unsigned int index ;
   unsigned int func ;
   unsigned int chan ;
   unsigned int rsv[5U] ;
};

#line 134 
enum ldv_32763 {
    PTP_CLK_REQ_EXTTS = 0,
    PTP_CLK_REQ_PEROUT = 1,
    PTP_CLK_REQ_PPS = 2
};

#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ptp_clock.h"
union __anonunion_1619 {
   struct ptp_extts_request extts ;
   struct ptp_perout_request perout ;
};

#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ptp_clock.h"
struct ptp_clock_request {
   enum ldv_32763 type ;
   union __anonunion_1619 __anonCompField_ptp_clock_request_95 ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ptp_clock_kernel.h"
struct ptp_clock_info {
   struct module *owner ;
   char name[16U] ;
   s32 max_adj ;
   int n_alarm ;
   int n_ext_ts ;
   int n_per_out ;
   int n_pins ;
   int pps ;
   struct ptp_pin_desc *pin_config ;
   int (*adjfreq)(struct ptp_clock_info *, s32 ) ;
   int (*adjtime)(struct ptp_clock_info *, s64 ) ;
   int (*gettime64)(struct ptp_clock_info *, struct timespec *) ;
   int (*settime64)(struct ptp_clock_info *, struct timespec const *) ;
   int (*enable)(struct ptp_clock_info *, struct ptp_clock_request *, int ) ;
   int (*verify)(struct ptp_clock_info *, unsigned int , enum ptp_pin_function , unsigned int ) ;
};

#line 113 
struct ptp_clock;

#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ptp_clock_kernel.h"
struct lio {
   atomic_t ifstate ;
   int ifidx ;
   int txq ;
   int rxq ;
   spinlock_t lock ;
   struct list_head glist ;
   struct octdev_props *octprops ;
   struct octeon_device *oct_dev ;
   struct net_device *netdev ;
   struct oct_link_info linfo ;
   u32 tx_qsize ;
   u32 rx_qsize ;
   u32 mtu ;
   u32 msg_enable ;
   u64 dev_capability ;
   u32 phy_beacon_val ;
   u32 led_ctrl_val ;
   struct ptp_clock_info ptp_info ;
   struct ptp_clock *ptp_clock ;
   s64 ptp_adjust ;
   spinlock_t ptp_lock ;
   u32 intf_open ;
   struct cavium_wq txq_status_wq ;
};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/liquidio_image.h"
struct oct_mdio_cmd_context {
   int octeon_id ;
   wait_queue_head_t wc ;
   int cond ;
};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
struct oct_mdio_cmd_resp {
   u64 rh ;
   struct oct_mdio_cmd resp ;
   u64 status ;
};

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef short __s16;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u16 __sum16;

#line 14  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
struct kernel_symbol {
   unsigned long value ;
   char const *name ;
};

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/init.h"
typedef void (*ctor_fn_t)(void);

#line 555  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/percpu.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jump_label.h"
struct jump_entry;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/jump_label.h"
typedef u64 jump_label_t;

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/jump_label.h"
struct jump_entry {
   jump_label_t code ;
   jump_label_t target ;
   jump_label_t key ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
enum ldv_11782 {
    WORK_STRUCT_PENDING_BIT_0 = 0,
    WORK_STRUCT_DELAYED_BIT_0 = 1,
    WORK_STRUCT_PWQ_BIT_0 = 2,
    WORK_STRUCT_LINKED_BIT_0 = 3,
    WORK_STRUCT_STATIC_BIT_0 = 4,
    WORK_STRUCT_COLOR_SHIFT_0 = 5,
    WORK_STRUCT_COLOR_BITS_0 = 4,
    WORK_STRUCT_PENDING_0 = 1,
    WORK_STRUCT_DELAYED_0 = 2,
    WORK_STRUCT_PWQ_0 = 4,
    WORK_STRUCT_LINKED_0 = 8,
    WORK_STRUCT_STATIC_0 = 16,
    WORK_NR_COLORS_0 = 15,
    WORK_NO_COLOR_0 = 15,
    WORK_CPU_UNBOUND_0 = 8192,
    WORK_STRUCT_FLAG_BITS_0 = 9,
    WORK_OFFQ_FLAG_BASE_0 = 5,
    __WORK_OFFQ_CANCELING_0 = 5,
    WORK_OFFQ_CANCELING_0 = 32,
    WORK_OFFQ_FLAG_BITS_0 = 1,
    WORK_OFFQ_POOL_SHIFT_0 = 6,
    WORK_OFFQ_LEFT_0 = 58,
    WORK_OFFQ_POOL_BITS_0 = 31,
    WORK_OFFQ_POOL_NONE_0 = 2147483647,
    WORK_STRUCT_FLAG_MASK_0 = 511,
    WORK_STRUCT_WQ_DATA_MASK_0 = -512,
    WORK_STRUCT_NO_POOL_0 = 137438953408,
    WORK_BUSY_PENDING_0 = 1,
    WORK_BUSY_RUNNING_0 = 2,
    WORKER_DESC_LEN_0 = 24
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;

#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};

#line 198  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;

#line 223  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kernel_param;

#line 228  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const *, struct kernel_param const *) ;
   int (*get)(char *, struct kernel_param const *) ;
   void (*free)(void *) ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_string;

#line 62 
struct kparam_array;

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
union __anonunion_1796 {
   void *arg ;
   struct kparam_string const *str ;
   struct kparam_array const *arr ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kernel_param {
   char const *name ;
   struct module *mod ;
   struct kernel_param_ops const *ops ;
   u16 const perm ;
   s8 level ;
   u8 flags ;
   union __anonunion_1796 __anonCompField_kernel_param_49 ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops const *ops ;
   void *elem ;
};

#line 469  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rbtree_latch.h"
struct mod_arch_specific {
   
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_param_attrs;

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute *, struct module_kobject *, char *) ;
   ssize_t (*store)(struct module_attribute *, struct module_kobject *, char const *, size_t ) ;
   void (*setup)(struct module *, char const *) ;
   int (*test)(struct module *) ;
   void (*free)(struct module *) ;
};

#line 74 
struct exception_table_entry;

#line 290 
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
};

#line 297  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};

#line 304 
struct module_sect_attrs;

#line 304 
struct module_notes_attrs;

#line 304 
struct tracepoint;

#line 304 
struct trace_event_call;

#line 304 
struct trace_enum_map;

#line 304  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const *version ;
   char const *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol const *syms ;
   unsigned long const *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol const *gpl_syms ;
   unsigned long const *gpl_crcs ;
   struct kernel_symbol const *unused_syms ;
   unsigned long const *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol const *unused_gpl_syms ;
   unsigned long const *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol const *gpl_future_syms ;
   unsigned long const *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const *tracepoints_ptrs ;
   struct jump_entry *jump_entries ;
   unsigned int num_jump_entries ;
   unsigned int num_trace_bprintk_fmt ;
   char const **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iov_iter msg_iter ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
   struct kiocb *msg_iocb ;
};

#line 217  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/fcntl.h"
enum ldv_22951 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/net.h"
typedef enum ldv_22951 socket_state;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/net.h"
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   struct callback_head rcu ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct proto_ops;

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct socket_wq *wq ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops const *ops ;
};

#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket *) ;
   int (*bind)(struct socket *, struct sockaddr *, int ) ;
   int (*connect)(struct socket *, struct sockaddr *, int , int ) ;
   int (*socketpair)(struct socket *, struct socket *) ;
   int (*accept)(struct socket *, struct socket *, int ) ;
   int (*getname)(struct socket *, struct sockaddr *, int *, int ) ;
   unsigned int (*poll)(struct file *, struct socket *, struct poll_table_struct *) ;
   int (*ioctl)(struct socket *, unsigned int , unsigned long ) ;
   int (*compat_ioctl)(struct socket *, unsigned int , unsigned long ) ;
   int (*listen)(struct socket *, int ) ;
   int (*shutdown)(struct socket *, int ) ;
   int (*setsockopt)(struct socket *, int , int , char *, unsigned int ) ;
   int (*getsockopt)(struct socket *, int , int , char *, int *) ;
   int (*compat_setsockopt)(struct socket *, int , int , char *, unsigned int ) ;
   int (*compat_getsockopt)(struct socket *, int , int , char *, int *) ;
   int (*sendmsg)(struct socket *, struct msghdr *, size_t ) ;
   int (*recvmsg)(struct socket *, struct msghdr *, size_t , int ) ;
   int (*mmap)(struct file *, struct socket *, struct vm_area_struct *) ;
   ssize_t (*sendpage)(struct socket *, struct page *, int , size_t , int ) ;
   ssize_t (*splice_read)(struct socket *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ) ;
   int (*set_peek_off)(struct sock *, int ) ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};

#line 215  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_frag_struct;

#line 215  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
typedef struct skb_frag_struct skb_frag_t;

#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_page_1853 {
   struct page *p ;
};

#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_frag_struct {
   struct __anonstruct_page_1853 page ;
   __u32 page_offset ;
   __u32 size ;
};

#line 249  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_shared_hwtstamps {
   ktime_t hwtstamp ;
};

#line 319  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_shared_info {
   unsigned char nr_frags ;
   __u8 tx_flags ;
   unsigned short gso_size ;
   unsigned short gso_segs ;
   unsigned short gso_type ;
   struct sk_buff *frag_list ;
   struct skb_shared_hwtstamps hwtstamps ;
   u32 tskey ;
   __be32 ip6_frag_id ;
   atomic_t dataref ;
   void *destructor_arg ;
   skb_frag_t frags[17U] ;
};

#line 767 
struct rtable;

#line 3470  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct iphdr {
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) ihl : 4 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) version : 4 ;
   __u8 tos ;
   __be16 tot_len ;
   __be16 id ;
   __be16 frag_off ;
   __u8 ttl ;
   __u8 protocol ;
   __sum16 check ;
   __be32 saddr ;
   __be32 daddr ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6_mib_device {
   atomic_long_t mibs[6U] ;
};

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6msg_mib_device {
   atomic_long_t mibs[512U] ;
};

#line 97  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/security.h"
struct xfrm_policy;

#line 98 
struct xfrm_state;

#line 114 
struct request_sock;

#line 191  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_hw_addr {
   struct list_head list ;
   unsigned char addr[32U] ;
   unsigned char type ;
   bool global_use ;
   int sync_cnt ;
   int refcount ;
   int synced ;
   struct callback_head callback_head ;
};

#line 331 
enum gro_result {
    GRO_MERGED = 0,
    GRO_MERGED_FREE = 1,
    GRO_HELD = 2,
    GRO_NORMAL = 3,
    GRO_DROP = 4
};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum gro_result gro_result_t;

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uaccess.h"
struct page_counter {
   atomic_long_t count ;
   unsigned long limit ;
   struct page_counter *parent ;
   unsigned long watermark ;
   unsigned long failcnt ;
};

#line 170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/cacheflush.h"
struct sock_filter {
   __u16 code ;
   __u8 jt ;
   __u8 jf ;
   __u32 k ;
};

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/filter.h"
struct bpf_insn {
   __u8 code ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) dst_reg : 4 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) src_reg : 4 ;
   __s16 off ;
   __s32 imm ;
};

#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/bpf.h"
enum bpf_prog_type {
    BPF_PROG_TYPE_UNSPEC = 0,
    BPF_PROG_TYPE_SOCKET_FILTER = 1,
    BPF_PROG_TYPE_KPROBE = 2,
    BPF_PROG_TYPE_SCHED_CLS = 3,
    BPF_PROG_TYPE_SCHED_ACT = 4
};

#line 273 
struct bpf_prog_aux;

#line 314  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/filter.h"
struct sock_fprog_kern {
   u16 len ;
   struct sock_filter *filter ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/filter.h"
union __anonunion_1953 {
   struct sock_filter insns[0U] ;
   struct bpf_insn insnsi[0U] ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/filter.h"
struct bpf_prog {
   u16 pages ;
   bool jited ;
   bool gpl_compatible ;
   u32 len ;
   enum bpf_prog_type type ;
   struct bpf_prog_aux *aux ;
   struct sock_fprog_kern *orig_prog ;
   unsigned int (*bpf_func)(struct sk_buff const *, struct bpf_insn const *) ;
   union __anonunion_1953 __anonCompField_bpf_prog_100 ;
};

#line 342  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/filter.h"
struct sk_filter {
   atomic_t refcnt ;
   struct callback_head rcu ;
   struct bpf_prog *prog ;
};

#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_nulls.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file *, wait_queue_head_t *, struct poll_table_struct *) ;
   unsigned long _key ;
};

#line 136  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rtnetlink.h"
struct nla_policy {
   u16 type ;
   u16 len ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/rtnetlink.h"
struct rtnl_link_ops {
   struct list_head list ;
   char const *kind ;
   size_t priv_size ;
   void (*setup)(struct net_device *) ;
   int maxtype ;
   struct nla_policy const *policy ;
   int (*validate)(struct nlattr **, struct nlattr **) ;
   int (*newlink)(struct net *, struct net_device *, struct nlattr **, struct nlattr **) ;
   int (*changelink)(struct net_device *, struct nlattr **, struct nlattr **) ;
   void (*dellink)(struct net_device *, struct list_head *) ;
   size_t (*get_size)(struct net_device const *) ;
   int (*fill_info)(struct sk_buff *, struct net_device const *) ;
   size_t (*get_xstats_size)(struct net_device const *) ;
   int (*fill_xstats)(struct sk_buff *, struct net_device const *) ;
   unsigned int (*get_num_tx_queues)(void) ;
   unsigned int (*get_num_rx_queues)(void) ;
   int slave_maxtype ;
   struct nla_policy const *slave_policy ;
   int (*slave_validate)(struct nlattr **, struct nlattr **) ;
   int (*slave_changelink)(struct net_device *, struct net_device *, struct nlattr **, struct nlattr **) ;
   size_t (*get_slave_size)(struct net_device const *, struct net_device const *) ;
   int (*fill_slave_info)(struct sk_buff *, struct net_device const *, struct net_device const *) ;
   struct net *(*get_link_net)(struct net_device const *) ;
};

#line 171 
struct neigh_table;

#line 171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/rtnetlink.h"
struct neigh_parms {
   possible_net_t net ;
   struct net_device *dev ;
   struct list_head list ;
   int (*neigh_setup)(struct neighbour *) ;
   void (*neigh_cleanup)(struct neighbour *) ;
   struct neigh_table *tbl ;
   void *sysctl_table ;
   int dead ;
   atomic_t refcnt ;
   struct callback_head callback_head ;
   int reachable_time ;
   int data[13U] ;
   unsigned long data_state[1U] ;
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neigh_statistics {
   unsigned long allocs ;
   unsigned long destroys ;
   unsigned long hash_grows ;
   unsigned long res_failed ;
   unsigned long lookups ;
   unsigned long hits ;
   unsigned long rcv_probes_mcast ;
   unsigned long rcv_probes_ucast ;
   unsigned long periodic_gc_runs ;
   unsigned long forced_gc_runs ;
   unsigned long unres_discards ;
};

#line 129 
struct neigh_ops;

#line 129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neighbour {
   struct neighbour *next ;
   struct neigh_table *tbl ;
   struct neigh_parms *parms ;
   unsigned long confirmed ;
   unsigned long updated ;
   rwlock_t lock ;
   atomic_t refcnt ;
   struct sk_buff_head arp_queue ;
   unsigned int arp_queue_len_bytes ;
   struct timer_list timer ;
   unsigned long used ;
   atomic_t probes ;
   __u8 flags ;
   __u8 nud_state ;
   __u8 type ;
   __u8 dead ;
   seqlock_t ha_lock ;
   unsigned char ha[32U] ;
   struct hh_cache hh ;
   int (*output)(struct neighbour *, struct sk_buff *) ;
   struct neigh_ops const *ops ;
   struct callback_head rcu ;
   struct net_device *dev ;
   u8 primary_key[0U] ;
};

#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neigh_ops {
   int family ;
   void (*solicit)(struct neighbour *, struct sk_buff *) ;
   void (*error_report)(struct neighbour *, struct sk_buff *) ;
   int (*output)(struct neighbour *, struct sk_buff *) ;
   int (*connected_output)(struct neighbour *, struct sk_buff *) ;
};

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct pneigh_entry {
   struct pneigh_entry *next ;
   possible_net_t net ;
   struct net_device *dev ;
   u8 flags ;
   u8 key[0U] ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neigh_hash_table {
   struct neighbour **hash_buckets ;
   unsigned int hash_shift ;
   __u32 hash_rnd[4U] ;
   struct callback_head rcu ;
};

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neigh_table {
   int family ;
   int entry_size ;
   int key_len ;
   __be16 protocol ;
   __u32 (*hash)(void const *, struct net_device const *, __u32 *) ;
   bool (*key_eq)(struct neighbour const *, void const *) ;
   int (*constructor)(struct neighbour *) ;
   int (*pconstructor)(struct pneigh_entry *) ;
   void (*pdestructor)(struct pneigh_entry *) ;
   void (*proxy_redo)(struct sk_buff *) ;
   char *id ;
   struct neigh_parms parms ;
   struct list_head parms_list ;
   int gc_interval ;
   int gc_thresh1 ;
   int gc_thresh2 ;
   int gc_thresh3 ;
   unsigned long last_flush ;
   struct delayed_work gc_work ;
   struct timer_list proxy_timer ;
   struct sk_buff_head proxy_queue ;
   atomic_t entries ;
   rwlock_t lock ;
   unsigned long last_rand ;
   struct neigh_statistics *stats ;
   struct neigh_hash_table *nht ;
   struct pneigh_entry **phash_buckets ;
};

#line 519 
struct dn_route;

#line 519  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
union __anonunion_1964 {
   struct dst_entry *next ;
   struct rtable *rt_next ;
   struct rt6_info *rt6_next ;
   struct dn_route *dn_next ;
};

#line 519  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct dst_entry {
   struct callback_head callback_head ;
   struct dst_entry *child ;
   struct net_device *dev ;
   struct dst_ops *ops ;
   unsigned long _metrics ;
   unsigned long expires ;
   struct dst_entry *path ;
   struct dst_entry *from ;
   struct xfrm_state *xfrm ;
   int (*input)(struct sk_buff *) ;
   int (*output)(struct sock *, struct sk_buff *) ;
   unsigned short flags ;
   unsigned short pending_confirm ;
   short error ;
   short obsolete ;
   unsigned short header_len ;
   unsigned short trailer_len ;
   __u32 tclassid ;
   long __pad_to_align_refcnt[2U] ;
   atomic_t __refcnt ;
   int __use ;
   unsigned long lastuse ;
   union __anonunion_1964 __anonCompField_dst_entry_101 ;
};

#line 555  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dst.h"
struct hwtstamp_config {
   int flags ;
   int tx_type ;
   int rx_filter ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct __anonstruct_socket_lock_t_1965 {
   spinlock_t slock ;
   int owned ;
   wait_queue_head_t wq ;
   struct lockdep_map dep_map ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
typedef struct __anonstruct_socket_lock_t_1965 socket_lock_t;

#line 124 
struct proto;

#line 130  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
typedef __u32 __portpair;

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
typedef __u64 __addrpair;

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct __anonstruct_1967 {
   __be32 skc_daddr ;
   __be32 skc_rcv_saddr ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_1966 {
   __addrpair skc_addrpair ;
   struct __anonstruct_1967 __anonCompField___anonunion_1966_102 ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_1968 {
   unsigned int skc_hash ;
   __u16 skc_u16hashes[2U] ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct __anonstruct_1970 {
   __be16 skc_dport ;
   __u16 skc_num ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_1969 {
   __portpair skc_portpair ;
   struct __anonstruct_1970 __anonCompField___anonunion_1969_105 ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_1971 {
   struct hlist_node skc_bind_node ;
   struct hlist_nulls_node skc_portaddr_node ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_1972 {
   struct hlist_node skc_node ;
   struct hlist_nulls_node skc_nulls_node ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct sock_common {
   union __anonunion_1966 __anonCompField_sock_common_103 ;
   union __anonunion_1968 __anonCompField_sock_common_104 ;
   union __anonunion_1969 __anonCompField_sock_common_106 ;
   unsigned short skc_family ;
   unsigned char volatile skc_state ;
   unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) skc_reuse : 4 ;
   unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) skc_reuseport : 1 ;
   unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) skc_ipv6only : 1 ;
   unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) skc_net_refcnt : 1 ;
   int skc_bound_dev_if ;
   union __anonunion_1971 __anonCompField_sock_common_107 ;
   struct proto *skc_prot ;
   possible_net_t skc_net ;
   struct in6_addr skc_v6_daddr ;
   struct in6_addr skc_v6_rcv_saddr ;
   atomic64_t skc_cookie ;
   int skc_dontcopy_begin[0U] ;
   union __anonunion_1972 __anonCompField_sock_common_108 ;
   int skc_tx_queue_mapping ;
   atomic_t skc_refcnt ;
   int skc_dontcopy_end[0U] ;
};

#line 219 
struct cg_proto;

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct __anonstruct_sk_backlog_1973 {
   atomic_t rmem_alloc ;
   int len ;
   struct sk_buff *head ;
   struct sk_buff *tail ;
};

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct sock {
   struct sock_common __sk_common ;
   socket_lock_t sk_lock ;
   struct sk_buff_head sk_receive_queue ;
   struct __anonstruct_sk_backlog_1973 sk_backlog ;
   int sk_forward_alloc ;
   __u32 sk_rxhash ;
   u16 sk_incoming_cpu ;
   __u32 sk_txhash ;
   unsigned int sk_napi_id ;
   unsigned int sk_ll_usec ;
   atomic_t sk_drops ;
   int sk_rcvbuf ;
   struct sk_filter *sk_filter ;
   struct socket_wq *sk_wq ;
   struct xfrm_policy *sk_policy[2U] ;
   unsigned long sk_flags ;
   struct dst_entry *sk_rx_dst ;
   struct dst_entry *sk_dst_cache ;
   spinlock_t sk_dst_lock ;
   atomic_t sk_wmem_alloc ;
   atomic_t sk_omem_alloc ;
   int sk_sndbuf ;
   struct sk_buff_head sk_write_queue ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) sk_shutdown : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sk_no_check_tx : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sk_no_check_rx : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) sk_userlocks : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) sk_protocol : 8 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) sk_type : 16 ;
   int sk_wmem_queued ;
   gfp_t sk_allocation ;
   u32 sk_pacing_rate ;
   u32 sk_max_pacing_rate ;
   netdev_features_t sk_route_caps ;
   netdev_features_t sk_route_nocaps ;
   int sk_gso_type ;
   unsigned int sk_gso_max_size ;
   u16 sk_gso_max_segs ;
   int sk_rcvlowat ;
   unsigned long sk_lingertime ;
   struct sk_buff_head sk_error_queue ;
   struct proto *sk_prot_creator ;
   rwlock_t sk_callback_lock ;
   int sk_err ;
   int sk_err_soft ;
   u32 sk_ack_backlog ;
   u32 sk_max_ack_backlog ;
   __u32 sk_priority ;
   __u32 sk_cgrp_prioidx ;
   struct pid *sk_peer_pid ;
   struct cred const *sk_peer_cred ;
   long sk_rcvtimeo ;
   long sk_sndtimeo ;
   struct timer_list sk_timer ;
   ktime_t sk_stamp ;
   u16 sk_tsflags ;
   u32 sk_tskey ;
   struct socket *sk_socket ;
   void *sk_user_data ;
   struct page_frag sk_frag ;
   struct sk_buff *sk_send_head ;
   __s32 sk_peek_off ;
   int sk_write_pending ;
   void *sk_security ;
   __u32 sk_mark ;
   u32 sk_classid ;
   struct cg_proto *sk_cgrp ;
   void (*sk_state_change)(struct sock *) ;
   void (*sk_data_ready)(struct sock *) ;
   void (*sk_write_space)(struct sock *) ;
   void (*sk_error_report)(struct sock *) ;
   int (*sk_backlog_rcv)(struct sock *, struct sk_buff *) ;
   void (*sk_destruct)(struct sock *) ;
};

#line 914 
struct request_sock_ops;

#line 915 
struct timewait_sock_ops;

#line 916 
struct inet_hashinfo;

#line 917 
struct raw_hashinfo;

#line 932 
struct udp_table;

#line 932  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_h_1976 {
   struct inet_hashinfo *hashinfo ;
   struct udp_table *udp_table ;
   struct raw_hashinfo *raw_hash ;
};

#line 932  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct proto {
   void (*close)(struct sock *, long ) ;
   int (*connect)(struct sock *, struct sockaddr *, int ) ;
   int (*disconnect)(struct sock *, int ) ;
   struct sock *(*accept)(struct sock *, int , int *) ;
   int (*ioctl)(struct sock *, int , unsigned long ) ;
   int (*init)(struct sock *) ;
   void (*destroy)(struct sock *) ;
   void (*shutdown)(struct sock *, int ) ;
   int (*setsockopt)(struct sock *, int , int , char *, unsigned int ) ;
   int (*getsockopt)(struct sock *, int , int , char *, int *) ;
   int (*compat_setsockopt)(struct sock *, int , int , char *, unsigned int ) ;
   int (*compat_getsockopt)(struct sock *, int , int , char *, int *) ;
   int (*compat_ioctl)(struct sock *, unsigned int , unsigned long ) ;
   int (*sendmsg)(struct sock *, struct msghdr *, size_t ) ;
   int (*recvmsg)(struct sock *, struct msghdr *, size_t , int , int , int *) ;
   int (*sendpage)(struct sock *, struct page *, int , size_t , int ) ;
   int (*bind)(struct sock *, struct sockaddr *, int ) ;
   int (*backlog_rcv)(struct sock *, struct sk_buff *) ;
   void (*release_cb)(struct sock *) ;
   void (*hash)(struct sock *) ;
   void (*unhash)(struct sock *) ;
   void (*rehash)(struct sock *) ;
   int (*get_port)(struct sock *, unsigned short ) ;
   void (*clear_sk)(struct sock *, int ) ;
   unsigned int inuse_idx ;
   bool (*stream_memory_free)(struct sock const *) ;
   void (*enter_memory_pressure)(struct sock *) ;
   atomic_long_t *memory_allocated ;
   struct percpu_counter *sockets_allocated ;
   int *memory_pressure ;
   long *sysctl_mem ;
   int *sysctl_wmem ;
   int *sysctl_rmem ;
   int max_header ;
   bool no_autobind ;
   struct kmem_cache *slab ;
   unsigned int obj_size ;
   int slab_flags ;
   struct percpu_counter *orphan_count ;
   struct request_sock_ops *rsk_prot ;
   struct timewait_sock_ops *twsk_prot ;
   union __anonunion_h_1976 h ;
   struct module *owner ;
   char name[32U] ;
   struct list_head node ;
   int (*init_cgroup)(struct mem_cgroup *, struct cgroup_subsys *) ;
   void (*destroy_cgroup)(struct mem_cgroup *) ;
   struct cg_proto *(*proto_cgroup)(struct mem_cgroup *) ;
};

#line 1054  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct cg_proto {
   struct page_counter memory_allocated ;
   struct percpu_counter sockets_allocated ;
   int memory_pressure ;
   long sysctl_mem[3U] ;
   unsigned long flags ;
   struct mem_cgroup *memcg ;
};

#line 2242  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct request_sock_ops {
   int family ;
   int obj_size ;
   struct kmem_cache *slab ;
   char *slab_name ;
   int (*rtx_syn_ack)(struct sock *, struct request_sock *) ;
   void (*send_ack)(struct sock *, struct sk_buff *, struct request_sock *) ;
   void (*send_reset)(struct sock *, struct sk_buff *) ;
   void (*destructor)(struct request_sock *) ;
   void (*syn_ack_timeout)(struct request_sock const *) ;
};

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/request_sock.h"
struct request_sock {
   struct sock_common __req_common ;
   struct request_sock *dl_next ;
   struct sock *rsk_listener ;
   u16 mss ;
   u8 num_retrans ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cookie_ts : 1 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(7))) num_timeout : 7 ;
   u32 window_clamp ;
   u32 rcv_wnd ;
   u32 ts_recent ;
   struct timer_list rsk_timer ;
   struct request_sock_ops const *rsk_ops ;
   struct sock *sk ;
   u32 *saved_syn ;
   u32 secid ;
   u32 peer_secid ;
};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ipv6.h"
struct ipv6hdr {
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) priority : 4 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) version : 4 ;
   __u8 flow_lbl[3U] ;
   __be16 payload_len ;
   __u8 nexthdr ;
   __u8 hop_limit ;
   struct in6_addr saddr ;
   struct in6_addr daddr ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ipv6.h"
struct ipv6_stable_secret {
   bool initialized ;
   struct in6_addr secret ;
};

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ipv6.h"
struct ipv6_devconf {
   __s32 forwarding ;
   __s32 hop_limit ;
   __s32 mtu6 ;
   __s32 accept_ra ;
   __s32 accept_redirects ;
   __s32 autoconf ;
   __s32 dad_transmits ;
   __s32 rtr_solicits ;
   __s32 rtr_solicit_interval ;
   __s32 rtr_solicit_delay ;
   __s32 force_mld_version ;
   __s32 mldv1_unsolicited_report_interval ;
   __s32 mldv2_unsolicited_report_interval ;
   __s32 use_tempaddr ;
   __s32 temp_valid_lft ;
   __s32 temp_prefered_lft ;
   __s32 regen_max_retry ;
   __s32 max_desync_factor ;
   __s32 max_addresses ;
   __s32 accept_ra_defrtr ;
   __s32 accept_ra_pinfo ;
   __s32 accept_ra_rtr_pref ;
   __s32 rtr_probe_interval ;
   __s32 accept_ra_rt_info_max_plen ;
   __s32 proxy_ndp ;
   __s32 accept_source_route ;
   __s32 accept_ra_from_local ;
   __s32 optimistic_dad ;
   __s32 use_optimistic ;
   __s32 mc_forwarding ;
   __s32 disable_ipv6 ;
   __s32 accept_dad ;
   __s32 force_tllao ;
   __s32 ndisc_notify ;
   __s32 suppress_frag_ndisc ;
   __s32 accept_ra_mtu ;
   struct ipv6_stable_secret stable_secret ;
   void *sysctl ;
};

#line 330  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_connection_sock.h"
struct timewait_sock_ops {
   struct kmem_cache *twsk_slab ;
   char *twsk_slab_name ;
   unsigned int twsk_obj_size ;
   int (*twsk_unique)(struct sock *, struct sock *, void *) ;
   void (*twsk_destructor)(struct sock *) ;
};

#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct ip6_sf_list {
   struct ip6_sf_list *sf_next ;
   struct in6_addr sf_addr ;
   unsigned long sf_count[2U] ;
   unsigned char sf_gsresp ;
   unsigned char sf_oldin ;
   unsigned char sf_crcount ;
};

#line 109  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct ifmcaddr6 {
   struct in6_addr mca_addr ;
   struct inet6_dev *idev ;
   struct ifmcaddr6 *next ;
   struct ip6_sf_list *mca_sources ;
   struct ip6_sf_list *mca_tomb ;
   unsigned int mca_sfmode ;
   unsigned char mca_crcount ;
   unsigned long mca_sfcount[2U] ;
   struct timer_list mca_timer ;
   unsigned int mca_flags ;
   int mca_users ;
   atomic_t mca_refcnt ;
   spinlock_t mca_lock ;
   unsigned long mca_cstamp ;
   unsigned long mca_tstamp ;
};

#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct ifacaddr6 {
   struct in6_addr aca_addr ;
   struct inet6_dev *aca_idev ;
   struct rt6_info *aca_rt ;
   struct ifacaddr6 *aca_next ;
   int aca_users ;
   atomic_t aca_refcnt ;
   unsigned long aca_cstamp ;
   unsigned long aca_tstamp ;
};

#line 152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct ipv6_devstat {
   struct proc_dir_entry *proc_dir_entry ;
   struct ipstats_mib *ipv6 ;
   struct icmpv6_mib_device *icmpv6dev ;
   struct icmpv6msg_mib_device *icmpv6msgdev ;
};

#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct inet6_dev {
   struct net_device *dev ;
   struct list_head addr_list ;
   struct ifmcaddr6 *mc_list ;
   struct ifmcaddr6 *mc_tomb ;
   spinlock_t mc_lock ;
   unsigned char mc_qrv ;
   unsigned char mc_gq_running ;
   unsigned char mc_ifc_count ;
   unsigned char mc_dad_count ;
   unsigned long mc_v1_seen ;
   unsigned long mc_qi ;
   unsigned long mc_qri ;
   unsigned long mc_maxdelay ;
   struct timer_list mc_gq_timer ;
   struct timer_list mc_ifc_timer ;
   struct timer_list mc_dad_timer ;
   struct ifacaddr6 *ac_list ;
   rwlock_t lock ;
   atomic_t refcnt ;
   __u32 if_flags ;
   int dead ;
   u8 rndid[8U] ;
   struct timer_list regen_timer ;
   struct list_head tempaddr_list ;
   struct in6_addr token ;
   struct neigh_parms *nd_parms ;
   struct ipv6_devconf cnf ;
   struct ipv6_devstat stats ;
   struct timer_list rs_timer ;
   __u8 rs_probes ;
   __u8 addr_gen_mode ;
   unsigned long tstamp ;
   struct callback_head rcu ;
};

#line 971  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/ipv6.h"
union __anonunion_1996 {
   __be32 a4 ;
   __be32 a6[4U] ;
   struct in6_addr in6 ;
};

#line 971  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/ipv6.h"
struct inetpeer_addr_base {
   union __anonunion_1996 __anonCompField_inetpeer_addr_base_110 ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
struct inetpeer_addr {
   struct inetpeer_addr_base addr ;
   __u16 family ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
union __anonunion_1997 {
   struct list_head gc_list ;
   struct callback_head gc_rcu ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
struct __anonstruct_1999 {
   atomic_t rid ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
union __anonunion_1998 {
   struct __anonstruct_1999 __anonCompField___anonunion_1998_112 ;
   struct callback_head rcu ;
   struct inet_peer *gc_next ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
struct inet_peer {
   struct inet_peer *avl_left ;
   struct inet_peer *avl_right ;
   struct inetpeer_addr daddr ;
   __u32 avl_height ;
   u32 metrics[16U] ;
   u32 rate_tokens ;
   unsigned long rate_last ;
   union __anonunion_1997 __anonCompField_inet_peer_111 ;
   union __anonunion_1998 __anonCompField_inet_peer_113 ;
   __u32 dtime ;
   atomic_t refcnt ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
struct inet_peer_base {
   struct inet_peer *root ;
   seqlock_t lock ;
   int total ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/route.h"
struct uncached_list;

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/route.h"
struct rtable {
   struct dst_entry dst ;
   int rt_genid ;
   unsigned int rt_flags ;
   __u16 rt_type ;
   __u8 rt_is_input ;
   __u8 rt_uses_gateway ;
   int rt_iif ;
   __be32 rt_gateway ;
   u32 rt_pmtu ;
   struct list_head rt_uncached ;
   struct uncached_list *rt_uncached_list ;
};

#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_vlan.h"
struct vlan_ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_vlan_proto ;
   __be16 h_vlan_TCI ;
   __be16 h_vlan_encapsulated_proto ;
};

#line 646  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_vlan.h"
struct firmware {
   size_t size ;
   u8 const *data ;
   struct page **pages ;
   void *priv ;
};

#line 137  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/liquidio_common.h"
union __anonunion_u_2008 {
   u16 size[4U] ;
   u64 size64 ;
};

#line 137  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/liquidio_common.h"
struct octeon_sg_entry {
   union __anonunion_u_2008 u ;
   u64 ptr[4U] ;
};

#line 172 
enum octnet_ifflags {
    OCTNET_IFFLAG_PROMISC = 1,
    OCTNET_IFFLAG_ALLMULTI = 2,
    OCTNET_IFFLAG_MULTICAST = 4,
    OCTNET_IFFLAG_BROADCAST = 8,
    OCTNET_IFFLAG_UNICAST = 16
};

#line 460  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/liquidio_common.h"
struct __anonstruct_s_2014 {
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) ifidx : 8 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(9))) csoffset : 9 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) tsflag : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) ipsec_ops : 4 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) ipv4opts_ipv6exthdr : 2 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ip_csum : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) tnl_csum : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))) reserved : 6 ;
};

#line 460  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/liquidio_common.h"
union octnic_packet_params {
   u32 u32 ;
   struct __anonstruct_s_2014 s ;
};

#line 541  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/liquidio_common.h"
struct liquidio_if_cfg_info {
   u64 ifidx ;
   u64 iqmask ;
   u64 oqmask ;
   struct oct_link_info linfo ;
};

#line 651  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/liquidio_common.h"
struct __anonstruct_s_2016 {
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) reserved : 8 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) gmx_port_id : 8 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) num_oqueues : 16 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) num_iqueues : 16 ;
   u64 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) base_queue : 16 ;
};

#line 651  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/liquidio_common.h"
union oct_nic_if_cfg {
   u64 u64 ;
   struct __anonstruct_s_2016 s ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_nic.h"
struct octnic_data_pkt {
   void *buf ;
   u32 reqtype ;
   u32 datasize ;
   struct octeon_instr_64B cmd ;
   u32 q_no ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_nic.h"
union __anonunion_u_2018 {
   u32 datasize ;
   u32 gatherptrs ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_nic.h"
struct __anonstruct_s_2017 {
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) ifidx : 8 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(7))) cksum_offset : 7 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) gather : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) timestamp : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) ipv4opts_ipv6exthdr : 2 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ip_csum : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) tnl_csum : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(11))) rsvd : 11 ;
   union __anonunion_u_2018 u ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_nic.h"
union octnic_cmd_setup {
   struct __anonstruct_s_2017 s ;
   u64 u64 ;
};

#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
struct liquidio_if_cfg_context {
   int octeon_id ;
   wait_queue_head_t wc ;
   int cond ;
};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
struct liquidio_if_cfg_resp {
   u64 rh ;
   struct liquidio_if_cfg_info cfg_info ;
   u64 status ;
};

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
struct oct_timestamp_resp {
   u64 rh ;
   u64 timestamp ;
   u64 status ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
struct __anonstruct_s_2019 {
   u32 reserved ;
   u16 gso_segs ;
   u16 gso_size ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
union tx_info {
   u64 u64 ;
   struct __anonstruct_s_2019 s ;
};

#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
struct octnic_gather {
   struct list_head list ;
   int sg_size ;
   int adjust ;
   struct octeon_sg_entry *sg ;
};

#line 170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
struct octnet_buf_free_info {
   struct lio *lio ;
   struct sk_buff *skb ;
   struct octnic_gather *g ;
   u64 dptr ;
   struct octeon_soft_command *sc ;
};

#line 191  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
struct handshake {
   struct completion init ;
   struct completion started ;
   struct pci_dev *pci_dev ;
   int init_ok ;
   int started_ok ;
};

#line 199  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
struct octeon_device_priv {
   struct tasklet_struct droq_tasklet ;
   unsigned long napi_mask ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
enum ldv_11816 {
    WORK_STRUCT_PENDING_BIT_1 = 0,
    WORK_STRUCT_DELAYED_BIT_1 = 1,
    WORK_STRUCT_PWQ_BIT_1 = 2,
    WORK_STRUCT_LINKED_BIT_1 = 3,
    WORK_STRUCT_STATIC_BIT_1 = 4,
    WORK_STRUCT_COLOR_SHIFT_1 = 5,
    WORK_STRUCT_COLOR_BITS_1 = 4,
    WORK_STRUCT_PENDING_1 = 1,
    WORK_STRUCT_DELAYED_1 = 2,
    WORK_STRUCT_PWQ_1 = 4,
    WORK_STRUCT_LINKED_1 = 8,
    WORK_STRUCT_STATIC_1 = 16,
    WORK_NR_COLORS_1 = 15,
    WORK_NO_COLOR_1 = 15,
    WORK_CPU_UNBOUND_1 = 8192,
    WORK_STRUCT_FLAG_BITS_1 = 9,
    WORK_OFFQ_FLAG_BASE_1 = 5,
    __WORK_OFFQ_CANCELING_1 = 5,
    WORK_OFFQ_CANCELING_1 = 32,
    WORK_OFFQ_FLAG_BITS_1 = 1,
    WORK_OFFQ_POOL_SHIFT_1 = 6,
    WORK_OFFQ_LEFT_1 = 58,
    WORK_OFFQ_POOL_BITS_1 = 31,
    WORK_OFFQ_POOL_NONE_1 = 2147483647,
    WORK_STRUCT_FLAG_MASK_1 = 511,
    WORK_STRUCT_WQ_DATA_MASK_1 = -512,
    WORK_STRUCT_NO_POOL_1 = 137438953408,
    WORK_BUSY_PENDING_1 = 1,
    WORK_BUSY_RUNNING_1 = 2,
    WORKER_DESC_LEN_1 = 24
};

#line 21 
enum ldv_11832 {
    WORK_STRUCT_PENDING_BIT_2 = 0,
    WORK_STRUCT_DELAYED_BIT_2 = 1,
    WORK_STRUCT_PWQ_BIT_2 = 2,
    WORK_STRUCT_LINKED_BIT_2 = 3,
    WORK_STRUCT_STATIC_BIT_2 = 4,
    WORK_STRUCT_COLOR_SHIFT_2 = 5,
    WORK_STRUCT_COLOR_BITS_2 = 4,
    WORK_STRUCT_PENDING_2 = 1,
    WORK_STRUCT_DELAYED_2 = 2,
    WORK_STRUCT_PWQ_2 = 4,
    WORK_STRUCT_LINKED_2 = 8,
    WORK_STRUCT_STATIC_2 = 16,
    WORK_NR_COLORS_2 = 15,
    WORK_NO_COLOR_2 = 15,
    WORK_CPU_UNBOUND_2 = 8192,
    WORK_STRUCT_FLAG_BITS_2 = 9,
    WORK_OFFQ_FLAG_BASE_2 = 5,
    __WORK_OFFQ_CANCELING_2 = 5,
    WORK_OFFQ_CANCELING_2 = 32,
    WORK_OFFQ_FLAG_BITS_2 = 1,
    WORK_OFFQ_POOL_SHIFT_2 = 6,
    WORK_OFFQ_LEFT_2 = 58,
    WORK_OFFQ_POOL_BITS_2 = 31,
    WORK_OFFQ_POOL_NONE_2 = 2147483647,
    WORK_STRUCT_FLAG_MASK_2 = 511,
    WORK_STRUCT_WQ_DATA_MASK_2 = -512,
    WORK_STRUCT_NO_POOL_2 = 137438953408,
    WORK_BUSY_PENDING_2 = 1,
    WORK_BUSY_RUNNING_2 = 2,
    WORKER_DESC_LEN_2 = 24
};

#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
struct ldv_list_element {
   void *data ;
   struct ldv_list_element *next ;
};

#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
typedef struct ldv_list_element *ldv_list_ptr;

#line 41  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
struct device_private {
   void *driver_data ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef short s16;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_work;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_worker {
   spinlock_t lock ;
   struct list_head work_list ;
   struct task_struct *task ;
   struct kthread_work *current_work ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_work {
   struct list_head node ;
   void (*func)(struct kthread_work *) ;
   struct kthread_worker *worker ;
};

#line 380  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct dma_chan;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_master;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_device {
   struct device dev ;
   struct spi_master *master ;
   u32 max_speed_hz ;
   u8 chip_select ;
   u8 bits_per_word ;
   u16 mode ;
   int irq ;
   void *controller_state ;
   void *controller_data ;
   char modalias[32U] ;
   int cs_gpio ;
};

#line 151 
struct spi_message;

#line 152 
struct spi_transfer;

#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_master {
   struct device dev ;
   struct list_head list ;
   s16 bus_num ;
   u16 num_chipselect ;
   u16 dma_alignment ;
   u16 mode_bits ;
   u32 bits_per_word_mask ;
   u32 min_speed_hz ;
   u32 max_speed_hz ;
   u16 flags ;
   spinlock_t bus_lock_spinlock ;
   struct mutex bus_lock_mutex ;
   bool bus_lock_flag ;
   int (*setup)(struct spi_device *) ;
   int (*transfer)(struct spi_device *, struct spi_message *) ;
   void (*cleanup)(struct spi_device *) ;
   bool (*can_dma)(struct spi_master *, struct spi_device *, struct spi_transfer *) ;
   bool queued ;
   struct kthread_worker kworker ;
   struct task_struct *kworker_task ;
   struct kthread_work pump_messages ;
   spinlock_t queue_lock ;
   struct list_head queue ;
   struct spi_message *cur_msg ;
   bool idling ;
   bool busy ;
   bool running ;
   bool rt ;
   bool auto_runtime_pm ;
   bool cur_msg_prepared ;
   bool cur_msg_mapped ;
   struct completion xfer_completion ;
   size_t max_dma_len ;
   int (*prepare_transfer_hardware)(struct spi_master *) ;
   int (*transfer_one_message)(struct spi_master *, struct spi_message *) ;
   int (*unprepare_transfer_hardware)(struct spi_master *) ;
   int (*prepare_message)(struct spi_master *, struct spi_message *) ;
   int (*unprepare_message)(struct spi_master *, struct spi_message *) ;
   void (*set_cs)(struct spi_device *, bool ) ;
   int (*transfer_one)(struct spi_master *, struct spi_device *, struct spi_transfer *) ;
   void (*handle_err)(struct spi_master *, struct spi_message *) ;
   int *cs_gpios ;
   struct dma_chan *dma_tx ;
   struct dma_chan *dma_rx ;
   void *dummy_rx ;
   void *dummy_tx ;
};

#line 506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_transfer {
   void const *tx_buf ;
   void *rx_buf ;
   unsigned int len ;
   dma_addr_t tx_dma ;
   dma_addr_t rx_dma ;
   struct sg_table tx_sg ;
   struct sg_table rx_sg ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cs_change : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) tx_nbits : 3 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) rx_nbits : 3 ;
   u8 bits_per_word ;
   u16 delay_usecs ;
   u32 speed_hz ;
   struct list_head transfer_list ;
};

#line 630  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_message {
   struct list_head transfers ;
   struct spi_device *spi ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_dma_mapped : 1 ;
   void (*complete)(void *) ;
   void *context ;
   unsigned int frame_length ;
   unsigned int actual_length ;
   int status ;
   struct list_head queue ;
   void *state ;
};

#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
typedef unsigned long pthread_t;

#line 22  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
union pthread_attr_t {
   char __size[56U] ;
   long __align ;
};

#line 29  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
typedef union pthread_attr_t pthread_attr_t;

#line 3835  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct ldv_struct_free_irq_7 {
   int arg0 ;
   int signal_pending ;
};

#line 18  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_interrupt_scenario_15 {
   enum irqreturn (*arg2)(int , void *) ;
   enum irqreturn (*arg1)(int , void *) ;
   void *arg3 ;
   int arg0 ;
   int signal_pending ;
};

#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_pci_scenario_14 {
   struct pci_driver *arg0 ;
   int signal_pending ;
};

#line 31  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_random_allocationless_scenario_16 {
   struct net_device *arg0 ;
   int signal_pending ;
};
unsigned long __builtin_bswap64(unsigned long);

void __builtin_unreachable(void);


#line 7  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/fvtp/.tmp_octeon_droq.c"
void ldv_inline_asm(void);


#line 4  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_droq.c.aux"
void ldv_atomic_add(int i, atomic_t *v);


#line 5 
void ldv_atomic_sub(int i, atomic_t *v);


#line 437  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int fls(int x)
{
  int __retres;
  int r;
  
#line 440 
  ldv_inline_asm();
  
#line 464 
  __retres = r + 1;
  
#line 464 
  return __retres;
}


#line 479  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int fls64(__u64 x)
{
  int __retres;
  
#line 481 
  int bitpos = -1;
  
#line 482 
  ldv_inline_asm();
  
#line 490 
  __retres = bitpos + 1;
  
#line 490 
  return __retres;
}


#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/swab.h"
__inline static __u64 __fswab64(__u64 val)
{
  __u64 tmp;
  
#line 71 
  tmp = (__u64)__builtin_bswap64((unsigned long)val);
  
#line 71 
  return tmp;
}


#line 180  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/swab.h"
__inline static __u64 __swab64p(__u64 const *p)
{
  unsigned long long tmp_0;
  
#line 185 
  if (0 != 0) 
#line 185 
              tmp_0 = (((((((*p << 56) | ((*p << 40) & 71776119061217280ULL)) | ((*p << 24) & 280375465082880ULL)) | ((*p << 8) & 1095216660480ULL)) | ((*p >> 8) & 4278190080ULL)) | ((*p >> 24) & 16711680ULL)) | ((*p >> 40) & 65280ULL)) | (*p >> 56); else 
                                                                    
#line 185 
                                                                    tmp_0 = __fswab64(*p);
  
#line 185 
  return tmp_0;
}


#line 248  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/swab.h"
__inline static void __swab64s(__u64 *p)
{
  
#line 253 
  *p = __swab64p((__u64 const *)p);
  
#line 254 
  return;
}


#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/log2.h"
int ____ilog2_NaN(void);


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/log2.h"
__inline static int __ilog2_u32(u32 n)
{
  int __retres;
  int tmp;
  
#line 34 
  tmp = fls((int)n);
  
#line 34 
  __retres = tmp + -1;
  
#line 34 
  return __retres;
}


#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_debug.h"
void __dynamic_dev_dbg(struct _ddebug *, struct device const *, char const * , ...);


#line 431  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
void print_hex_dump(char const *, char const *, int, int, int, void const *, size_t, bool);


#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list)
{
  
#line 27 
  list->next = list;
  
#line 28 
  list->prev = list;
  
#line 29 
  return;
}


#line 48 
void __list_add(struct list_head *, struct list_head *, struct list_head *);


#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void list_add_tail(struct list_head *new, struct list_head *head)
{
  
#line 77 
  __list_add(new,head->prev,head);
  
#line 78 
  return;
}


#line 113 
void list_del(struct list_head *);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/page_64.h"
unsigned long __phys_addr(unsigned long);


#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/getorder.h"
__inline static int __get_order(unsigned long size)
{
  int order;
  
#line 17 
  size -= 1UL;
  
#line 18 
  size >>= 12;
  
#line 22 
  order = fls64((unsigned long long)size);
  
#line 24 
  return order;
}


#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
void *memcpy(void *, void const *, size_t);


#line 56 
void *memset(void *, int, size_t);


#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const *v)
{
  int __retres;
  int const volatile *tmp;
  {
    
#line 27 
    int const __var = 0;
    
#line 27 
    tmp = (int const volatile *)(& v->counter);
  }
  
#line 27 
  __retres = *tmp;
  
#line 27 
  return __retres;
}


#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v, int i)
{
  
#line 39 
  v->counter = i;
  
#line 40 
  return;
}


#line 49 
static void atomic_add(int i, atomic_t *v);


#line 67 
static void atomic_sub(int i, atomic_t *v);


#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
void __raw_spin_lock_init(raw_spinlock_t *, char const *, struct lock_class_key *);


#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_api_smp.h"
void _raw_spin_lock(raw_spinlock_t *);


#line 30 
void _raw_spin_lock_bh(raw_spinlock_t *);


#line 41 
void _raw_spin_unlock(raw_spinlock_t *);


#line 42 
void _raw_spin_unlock_bh(raw_spinlock_t *);


#line 45 
void _raw_spin_unlock_irqrestore(raw_spinlock_t *, unsigned long);


#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock)
{
  raw_spinlock_t *__retres;
  
#line 301 
  __retres = & lock->__anonCompField_spinlock_18.rlock;
  
#line 301 
  return __retres;
}


#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock(spinlock_t *lock)
{
  
#line 312 
  _raw_spin_lock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 313 
  return;
}


#line 358 
static void ldv_spin_lock_76(spinlock_t *lock);


#line 362 
static void ldv_spin_lock_78(spinlock_t *lock);


#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_bh(spinlock_t *lock)
{
  
#line 365 
  _raw_spin_lock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 366 
  return;
}


#line 391 
static void ldv_spin_lock_bh_73(spinlock_t *lock);


#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock(spinlock_t *lock)
{
  
#line 365 
  _raw_spin_unlock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 366 
  return;
}


#line 407 
static void ldv_spin_unlock_77(spinlock_t *lock);


#line 411 
static void ldv_spin_unlock_79(spinlock_t *lock);


#line 412  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_bh(spinlock_t *lock)
{
  
#line 414 
  _raw_spin_unlock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 415 
  return;
}


#line 440 
static void ldv_spin_unlock_bh_74(spinlock_t *lock);


#line 444 
static void ldv_spin_unlock_bh_75(spinlock_t *lock);


#line 458  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
{
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
  }
  
#line 460 
  _raw_spin_unlock_irqrestore(& lock->__anonCompField_spinlock_18.rlock,flags);
  
#line 461 
  return;
}


#line 490 
static void ldv_spin_unlock_irqrestore_81(spinlock_t *lock, unsigned long flags);


#line 494 
static void ldv_spin_unlock_irqrestore_83(spinlock_t *lock, unsigned long flags);


#line 498 
static void ldv_spin_unlock_irqrestore_85(spinlock_t *lock, unsigned long flags);


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_droq.c.aux"
void __ldv_spin_lock(spinlock_t *);


#line 70 
static void ldv___ldv_spin_lock_80(spinlock_t *ldv_func_arg1);


#line 74 
static void ldv___ldv_spin_lock_82(spinlock_t *ldv_func_arg1);


#line 78 
static void ldv___ldv_spin_lock_84(spinlock_t *ldv_func_arg1);


#line 86 
void ldv_spin_model_lock(char *);


#line 87 
void ldv_spin_model_unlock(char *);


#line 24  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kmalloc(size_t size, gfp_t flags);


#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static unsigned int readl(void const volatile *addr)
{
  unsigned int ret;
  
#line 59 
  ldv_inline_asm();
  
#line 58 
  return ret;
}


#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static void writel(unsigned int val, void volatile *addr)
{
  
#line 68 
  ldv_inline_asm();
  
#line 69 
  return;
}


#line 352  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/gfp.h"
unsigned long __get_free_pages(gfp_t, unsigned int);


#line 367 
void free_pages(unsigned long, unsigned int);


#line 1083  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
void dev_err(struct device const *, char const * , ...);


#line 1089 
void _dev_info(struct device const *, char const * , ...);


#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kmalloc(size_t size, gfp_t flags);


#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction)
{
  int __retres;
  
#line 76 
  __retres = (unsigned int)dma_direction <= 2U;
  
#line 76 
  return __retres;
}


#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address, unsigned int n)
{
  
#line 133 
  return;
}


#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-debug.h"
void debug_dma_map_page(struct device *, struct page *, size_t, size_t, int, dma_addr_t, bool);


#line 42 
void debug_dma_mapping_error(struct device *, dma_addr_t);


#line 44 
void debug_dma_unmap_page(struct device *, dma_addr_t, size_t, int, bool);


#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
extern struct dma_map_ops *dma_ops;


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev)
{
  struct dma_map_ops *__retres;
  
#line 37 
  if ((long)(dev == (struct device *)0) != 0L || dev->archdata.dma_ops == (struct dma_map_ops *)0) {
    
#line 38 
    __retres = dma_ops;
    
#line 38 
    goto return_label;
  }
  else {
    
#line 40 
    __retres = dev->archdata.dma_ops;
    
#line 40 
    goto return_label;
  }
  return_label: 
#line 37 
                return __retres;
}


#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_single_attrs(struct device *dev, void *ptr, size_t size, enum dma_data_direction dir, struct dma_attrs *attrs)
{
  dma_addr_t addr;
  int tmp_0;
  unsigned long tmp_1;
  unsigned long tmp_2;
  
#line 15 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 18 
  kmemcheck_mark_initialized(ptr,(unsigned int)size);
  
#line 19 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 19 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 21 
    ldv_inline_asm();
    
#line 19 
    ;
  }
  else ;
  
#line 20 
  ;
  
#line 20 
  ;
  
#line 20 
  ;
  
#line 20 
  ;
  
#line 20 
  tmp_1 = __phys_addr((unsigned long)ptr);
  
#line 20 
  ;
  
#line 20 
  addr = (*(ops->map_page))(dev,(struct page *)(-24189255811072) + (tmp_1 >> 12),(unsigned long)ptr & 4095UL,size,dir,attrs);
  
#line 23 
  ;
  
#line 23 
  ;
  
#line 23 
  ;
  
#line 23 
  ;
  
#line 23 
  tmp_2 = __phys_addr((unsigned long)ptr);
  
#line 23 
  ;
  
#line 23 
  debug_dma_map_page(dev,(struct page *)(-24189255811072) + (tmp_2 >> 12),(unsigned long)ptr & 4095UL,size,(int)dir,addr,(_Bool)1);
  
#line 26 
  return addr;
}


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_single_attrs(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir, struct dma_attrs *attrs)
{
  int tmp_0;
  
#line 34 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 36 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 36 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 38 
    ldv_inline_asm();
    
#line 36 
    ;
  }
  else ;
  
#line 37 
  if (ops->unmap_page != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction , struct dma_attrs *))0) 
    
#line 38 
    (*(ops->unmap_page))(dev,addr,size,dir,attrs); else ;
  
#line 39 
  debug_dma_unmap_page(dev,addr,size,(int)dir,(_Bool)1);
  
#line 40 
  return;
}


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
__inline static int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
  int __retres;
  
#line 49 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 50 
  debug_dma_mapping_error(dev,dma_addr);
  
#line 51 
  if (ops->mapping_error != (int (*)(struct device *, dma_addr_t ))0) {
    int tmp_0;
    
#line 52 
    tmp_0 = (*(ops->mapping_error))(dev,dma_addr);
    
#line 52 
    __retres = tmp_0;
    
#line 52 
    goto return_label;
  }
  else ;
  
#line 54 
  __retres = dma_addr == 0ULL;
  return_label: 
#line 54 
                return __retres;
}


#line 131 
void *dma_alloc_attrs(struct device *, size_t, dma_addr_t *, gfp_t, struct dma_attrs *);


#line 136 
void dma_free_attrs(struct device *, size_t, void *, dma_addr_t, struct dma_attrs *);


#line 1688  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
unsigned char *skb_put(struct sk_buff *, unsigned int);


#line 1789  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_reserve(struct sk_buff *skb, int len)
{
  
#line 1791 
  skb->data += len;
  
#line 1792 
  skb->tail += (unsigned int)len;
  
#line 1793 
  return;
}


#line 2140 
struct sk_buff *__netdev_alloc_skb(struct net_device *, unsigned int, gfp_t);


#line 2156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct sk_buff *netdev_alloc_skb(struct net_device *dev, unsigned int length)
{
  struct sk_buff *tmp;
  
#line 2159 
  tmp = __netdev_alloc_skb(dev,length,32U);
  
#line 2159 
  return tmp;
}


#line 2170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct sk_buff *dev_alloc_skb(unsigned int length)
{
  struct sk_buff *tmp;
  
#line 2172 
  tmp = netdev_alloc_skb((struct net_device *)0,length);
  
#line 2172 
  return tmp;
}


#line 2900  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
void __dev_kfree_skb_any(struct sk_buff *, enum skb_free_reason);


#line 2931  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void dev_kfree_skb_any(struct sk_buff *skb)
{
  
#line 2933 
  __dev_kfree_skb_any(skb,(enum skb_free_reason)SKB_REASON_DROPPED);
  
#line 2934 
  return;
}


#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/vmalloc.h"
void *vmalloc(unsigned long);


#line 83 
void vfree(void const *);


#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.h"
__inline static struct octeon_recv_info *octeon_alloc_recv_info(int extra_bytes)
{
  struct octeon_recv_info *__retres;
  struct octeon_recv_info *recv_info;
  u8 *buf;
  
#line 182 
  buf = (u8 *)kmalloc((unsigned long)extra_bytes + 800UL,32U);
  
#line 184 
  if (buf == (u8 *)0U) {
    
#line 185 
    __retres = (struct octeon_recv_info *)0;
    
#line 185 
    goto return_label;
  }
  else ;
  
#line 187 
  recv_info = (struct octeon_recv_info *)buf;
  
#line 188 
  recv_info->recv_pkt = (struct octeon_recv_pkt *)(buf + 16U);
  
#line 190 
  recv_info->rsvd = (void *)0;
  
#line 191 
  if (extra_bytes != 0) 
#line 192 
                        recv_info->rsvd = (void *)(buf + 800U); else ;
  
#line 194 
  __retres = recv_info;
  return_label: 
#line 194 
                return __retres;
}


#line 339 
int octeon_init_droq(struct octeon_device *oct, u32 q_no, u32 num_descs, u32 desc_size, void *app_ctx);


#line 352 
int octeon_delete_droq(struct octeon_device *oct, u32 q_no);


#line 366 
int octeon_register_droq_ops(struct octeon_device *oct, u32 q_no, struct octeon_droq_ops *ops);


#line 378 
int octeon_unregister_droq_ops(struct octeon_device *oct, u32 q_no);


#line 413 
u32 octeon_droq_check_hw_for_pkts(struct octeon_device *oct, struct octeon_droq *droq);


#line 416 
int octeon_create_droq(struct octeon_device *oct, u32 q_no, u32 num_descs, u32 desc_size, void *app_ctx);


#line 419 
int octeon_droq_process_packets(struct octeon_device *oct, struct octeon_droq *droq, u32 budget);


#line 423 
int octeon_process_droq_poll_cmd(struct octeon_device *oct, u32 q_no, int cmd, u32 arg);


#line 453  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.h"
octeon_dispatch_fn_t octeon_get_dispatch(struct octeon_device *octeon_dev, u16 opcode, u16 subcode);


#line 634 
void octeon_set_droq_pkt_op(struct octeon_device *oct, u32 q_no, u32 enable);


#line 647 
struct octeon_config *octeon_get_conf(struct octeon_device *oct);


#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_main.h"
__inline static void octeon_swap_8B_data(u64 *data, u32 blocks)
{
  
#line 59 
  goto ldv_46073;
  ldv_46072: 
#line 60 
  ;
  
#line 60 
  __swab64s(data);
  
#line 61 
  blocks -= 1U;
  
#line 62 
  data += 1;
  ldv_46073: 
#line 63 
  ;
  
#line 59 
  if (blocks != 0U) 
#line 61 
                    goto ldv_46072; else 
#line 64 
                                         goto ldv_46074;
  ldv_46074: 
#line 65 
  ;
  
#line 66 
  return;
}


#line 129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_main.h"
__inline static void *cnnic_alloc_aligned_dma(struct pci_dev *pci_dev, u32 size, u32 *alloc_size, size_t *orig_ptr, size_t *dma_addr)
{
  unsigned long tmp_71;
  int tmp_70;
  
#line 135 
  int retries = 0;
  
#line 136 
  void *ptr = (void *)0;
  ldv_46098: 
#line 137 
  ;
  
#line 142 
  if (0 != 0) {
    int tmp_68;
    
#line 142 
    if (size != 0U) {
      int tmp_67;
      
#line 142 
      if (size > 4095U) {
        int tmp_66;
        
#line 142 
        if (0 != 0) {
          int tmp_64;
          
#line 142 
          if (size == 1U) {
            int tmp;
            
#line 142 
            tmp = ____ilog2_NaN();
            
#line 142 
            tmp_64 = tmp + -11;
          }
          else {
            int tmp_63;
            
#line 142 
            if (((unsigned long long)(size + 4294967295U) & 4611686018427387904ULL) == 0ULL) {
              int tmp_62;
              
#line 142 
              if (((unsigned long long)(size + 4294967295U) & 2305843009213693952ULL) == 0ULL) {
                int tmp_61;
                
#line 142 
                if (((unsigned long long)(size + 4294967295U) & 1152921504606846976ULL) == 0ULL) {
                  int tmp_60;
                  
#line 142 
                  if (((unsigned long long)(size + 4294967295U) & 576460752303423488ULL) == 0ULL) {
                    int tmp_59;
                    
#line 142 
                    if (((unsigned long long)(size + 4294967295U) & 288230376151711744ULL) == 0ULL) {
                      int tmp_58;
                      
#line 142 
                      if (((unsigned long long)(size + 4294967295U) & 144115188075855872ULL) == 0ULL) {
                        int tmp_57;
                        
#line 142 
                        if (((unsigned long long)(size + 4294967295U) & 72057594037927936ULL) == 0ULL) {
                          int tmp_56;
                          
#line 142 
                          if (((unsigned long long)(size + 4294967295U) & 36028797018963968ULL) == 0ULL) {
                            int tmp_55;
                            
#line 142 
                            if (((unsigned long long)(size + 4294967295U) & 18014398509481984ULL) == 0ULL) {
                              int tmp_54;
                              
#line 142 
                              if (((unsigned long long)(size + 4294967295U) & 9007199254740992ULL) == 0ULL) {
                                int tmp_53;
                                
#line 142 
                                if (((unsigned long long)(size + 4294967295U) & 4503599627370496ULL) == 0ULL) {
                                  int tmp_52;
                                  
#line 142 
                                  if (((unsigned long long)(size + 4294967295U) & 2251799813685248ULL) == 0ULL) {
                                    int tmp_51;
                                    
#line 142 
                                    if (((unsigned long long)(size + 4294967295U) & 1125899906842624ULL) == 0ULL) {
                                      int tmp_50;
                                      
#line 142 
                                      if (((unsigned long long)(size + 4294967295U) & 562949953421312ULL) == 0ULL) {
                                        int tmp_49;
                                        
#line 142 
                                        if (((unsigned long long)(size + 4294967295U) & 281474976710656ULL) == 0ULL) {
                                          int tmp_48;
                                          
#line 142 
                                          if (((unsigned long long)(size + 4294967295U) & 140737488355328ULL) == 0ULL) {
                                            int tmp_47;
                                            
#line 142 
                                            if (((unsigned long long)(size + 4294967295U) & 70368744177664ULL) == 0ULL) {
                                              int tmp_46;
                                              
#line 142 
                                              if (((unsigned long long)(size + 4294967295U) & 35184372088832ULL) == 0ULL) {
                                                int tmp_45;
                                                
#line 142 
                                                if (((unsigned long long)(size + 4294967295U) & 17592186044416ULL) == 0ULL) {
                                                  int tmp_44;
                                                  
#line 142 
                                                  if (((unsigned long long)(size + 4294967295U) & 8796093022208ULL) == 0ULL) {
                                                    int tmp_43;
                                                    
#line 142 
                                                    if (((unsigned long long)(size + 4294967295U) & 4398046511104ULL) == 0ULL) {
                                                      int tmp_42;
                                                      
#line 142 
                                                      if (((unsigned long long)(size + 4294967295U) & 2199023255552ULL) == 0ULL) {
                                                        int tmp_41;
                                                        
#line 142 
                                                        if (((unsigned long long)(size + 4294967295U) & 1099511627776ULL) == 0ULL) {
                                                          int tmp_40;
                                                          
#line 142 
                                                          if (((unsigned long long)(size + 4294967295U) & 549755813888ULL) == 0ULL) {
                                                            int tmp_39;
                                                            
#line 142 
                                                            if (((unsigned long long)(size + 4294967295U) & 274877906944ULL) == 0ULL) {
                                                              int tmp_38;
                                                              
#line 142 
                                                              if (((unsigned long long)(size + 4294967295U) & 137438953472ULL) == 0ULL) {
                                                                int tmp_37;
                                                                
#line 142 
                                                                if (((unsigned long long)(size + 4294967295U) & 68719476736ULL) == 0ULL) {
                                                                  int tmp_36;
                                                                  
#line 142 
                                                                  if (
                                                                    ((unsigned long long)(size + 4294967295U) & 34359738368ULL) == 0ULL) {
                                                                    int tmp_35;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 17179869184ULL) == 0ULL) {
                                                                    int tmp_34;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 8589934592ULL) == 0ULL) {
                                                                    int tmp_33;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 4294967296ULL) == 0ULL) {
                                                                    int tmp_32;
                                                                    
#line 142 
                                                                    if (
                                                                    size + 4294967295U >= (u32)0) {
                                                                    int tmp_31;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 1073741824ULL) == 0ULL) {
                                                                    int tmp_30;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 536870912ULL) == 0ULL) {
                                                                    int tmp_29;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 268435456ULL) == 0ULL) {
                                                                    int tmp_28;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 134217728ULL) == 0ULL) {
                                                                    int tmp_27;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 67108864ULL) == 0ULL) {
                                                                    int tmp_26;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 33554432ULL) == 0ULL) {
                                                                    int tmp_25;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 16777216ULL) == 0ULL) {
                                                                    int tmp_24;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 8388608ULL) == 0ULL) {
                                                                    int tmp_23;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 4194304ULL) == 0ULL) {
                                                                    int tmp_22;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 2097152ULL) == 0ULL) {
                                                                    int tmp_21;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 1048576ULL) == 0ULL) {
                                                                    int tmp_20;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 524288ULL) == 0ULL) {
                                                                    int tmp_19;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 262144ULL) == 0ULL) {
                                                                    int tmp_18;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 131072ULL) == 0ULL) {
                                                                    int tmp_17;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 65536ULL) == 0ULL) {
                                                                    int tmp_16;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 32768ULL) == 0ULL) {
                                                                    int tmp_15;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 16384ULL) == 0ULL) {
                                                                    int tmp_14;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 8192ULL) == 0ULL) {
                                                                    int tmp_13;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 4096ULL) == 0ULL) {
                                                                    int tmp_12;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 2048ULL) == 0ULL) {
                                                                    int tmp_11;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 1024ULL) == 0ULL) {
                                                                    int tmp_10;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 512ULL) == 0ULL) {
                                                                    int tmp_9;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 256ULL) == 0ULL) {
                                                                    int tmp_8;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 128ULL) == 0ULL) {
                                                                    int tmp_7;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 64ULL) == 0ULL) {
                                                                    int tmp_6;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 32ULL) == 0ULL) {
                                                                    int tmp_5;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 16ULL) == 0ULL) {
                                                                    int tmp_4;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 8ULL) == 0ULL) {
                                                                    int tmp_3;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 4ULL) == 0ULL) {
                                                                    int tmp_2;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 2ULL) == 0ULL) {
                                                                    int tmp_1;
                                                                    
#line 142 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 1ULL) == 0ULL) {
                                                                    int tmp_0;
                                                                    
#line 142 
                                                                    tmp_0 = ____ilog2_NaN();
                                                                    
#line 142 
                                                                    tmp_1 = tmp_0 + -11;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_1 = -11;
                                                                    
#line 142 
                                                                    tmp_2 = tmp_1;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_2 = -10;
                                                                    
#line 142 
                                                                    tmp_3 = tmp_2;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_3 = -9;
                                                                    
#line 142 
                                                                    tmp_4 = tmp_3;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_4 = -8;
                                                                    
#line 142 
                                                                    tmp_5 = tmp_4;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_5 = -7;
                                                                    
#line 142 
                                                                    tmp_6 = tmp_5;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_6 = -6;
                                                                    
#line 142 
                                                                    tmp_7 = tmp_6;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_7 = -5;
                                                                    
#line 142 
                                                                    tmp_8 = tmp_7;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_8 = -4;
                                                                    
#line 142 
                                                                    tmp_9 = tmp_8;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_9 = -3;
                                                                    
#line 142 
                                                                    tmp_10 = tmp_9;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_10 = -2;
                                                                    
#line 142 
                                                                    tmp_11 = tmp_10;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_11 = -1;
                                                                    
#line 142 
                                                                    tmp_12 = tmp_11;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_12 = 0;
                                                                    
#line 142 
                                                                    tmp_13 = tmp_12;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_13 = 1;
                                                                    
#line 142 
                                                                    tmp_14 = tmp_13;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_14 = 2;
                                                                    
#line 142 
                                                                    tmp_15 = tmp_14;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_15 = 3;
                                                                    
#line 142 
                                                                    tmp_16 = tmp_15;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_16 = 4;
                                                                    
#line 142 
                                                                    tmp_17 = tmp_16;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_17 = 5;
                                                                    
#line 142 
                                                                    tmp_18 = tmp_17;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_18 = 6;
                                                                    
#line 142 
                                                                    tmp_19 = tmp_18;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_19 = 7;
                                                                    
#line 142 
                                                                    tmp_20 = tmp_19;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_20 = 8;
                                                                    
#line 142 
                                                                    tmp_21 = tmp_20;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_21 = 9;
                                                                    
#line 142 
                                                                    tmp_22 = tmp_21;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_22 = 10;
                                                                    
#line 142 
                                                                    tmp_23 = tmp_22;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_23 = 11;
                                                                    
#line 142 
                                                                    tmp_24 = tmp_23;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_24 = 12;
                                                                    
#line 142 
                                                                    tmp_25 = tmp_24;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_25 = 13;
                                                                    
#line 142 
                                                                    tmp_26 = tmp_25;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_26 = 14;
                                                                    
#line 142 
                                                                    tmp_27 = tmp_26;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_27 = 15;
                                                                    
#line 142 
                                                                    tmp_28 = tmp_27;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_28 = 16;
                                                                    
#line 142 
                                                                    tmp_29 = tmp_28;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_29 = 17;
                                                                    
#line 142 
                                                                    tmp_30 = tmp_29;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_30 = 18;
                                                                    
#line 142 
                                                                    tmp_31 = tmp_30;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_31 = 19;
                                                                    
#line 142 
                                                                    tmp_32 = tmp_31;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_32 = 20;
                                                                    
#line 142 
                                                                    tmp_33 = tmp_32;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_33 = 21;
                                                                    
#line 142 
                                                                    tmp_34 = tmp_33;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_34 = 22;
                                                                    
#line 142 
                                                                    tmp_35 = tmp_34;
                                                                    }
                                                                    else 
                                                                    
#line 142 
                                                                    tmp_35 = 23;
                                                                    
#line 142 
                                                                    tmp_36 = tmp_35;
                                                                  }
                                                                  else 
                                                                    
#line 142 
                                                                    tmp_36 = 24;
                                                                  
#line 142 
                                                                  tmp_37 = tmp_36;
                                                                }
                                                                else 
                                                                  
#line 142 
                                                                  tmp_37 = 25;
                                                                
#line 142 
                                                                tmp_38 = tmp_37;
                                                              }
                                                              else 
#line 142 
                                                                   tmp_38 = 26;
                                                              
#line 142 
                                                              tmp_39 = tmp_38;
                                                            }
                                                            else 
#line 142 
                                                                 tmp_39 = 27;
                                                            
#line 142 
                                                            tmp_40 = tmp_39;
                                                          }
                                                          else 
#line 142 
                                                               tmp_40 = 28;
                                                          
#line 142 
                                                          tmp_41 = tmp_40;
                                                        }
                                                        else 
#line 142 
                                                             tmp_41 = 29;
                                                        
#line 142 
                                                        tmp_42 = tmp_41;
                                                      }
                                                      else 
#line 142 
                                                           tmp_42 = 30;
                                                      
#line 142 
                                                      tmp_43 = tmp_42;
                                                    }
                                                    else 
#line 142 
                                                         tmp_43 = 31;
                                                    
#line 142 
                                                    tmp_44 = tmp_43;
                                                  }
                                                  else 
#line 142 
                                                       tmp_44 = 32;
                                                  
#line 142 
                                                  tmp_45 = tmp_44;
                                                }
                                                else 
#line 142 
                                                     tmp_45 = 33;
                                                
#line 142 
                                                tmp_46 = tmp_45;
                                              }
                                              else 
#line 142 
                                                   tmp_46 = 34;
                                              
#line 142 
                                              tmp_47 = tmp_46;
                                            }
                                            else 
#line 142 
                                                 tmp_47 = 35;
                                            
#line 142 
                                            tmp_48 = tmp_47;
                                          }
                                          else 
#line 142 
                                               tmp_48 = 36;
                                          
#line 142 
                                          tmp_49 = tmp_48;
                                        }
                                        else 
#line 142 
                                             tmp_49 = 37;
                                        
#line 142 
                                        tmp_50 = tmp_49;
                                      }
                                      else 
#line 142 
                                           tmp_50 = 38;
                                      
#line 142 
                                      tmp_51 = tmp_50;
                                    }
                                    else 
#line 142 
                                         tmp_51 = 39;
                                    
#line 142 
                                    tmp_52 = tmp_51;
                                  }
                                  else 
#line 142 
                                       tmp_52 = 40;
                                  
#line 142 
                                  tmp_53 = tmp_52;
                                }
                                else 
#line 142 
                                     tmp_53 = 41;
                                
#line 142 
                                tmp_54 = tmp_53;
                              }
                              else 
#line 142 
                                   tmp_54 = 42;
                              
#line 142 
                              tmp_55 = tmp_54;
                            }
                            else 
#line 142 
                                 tmp_55 = 43;
                            
#line 142 
                            tmp_56 = tmp_55;
                          }
                          else 
#line 142 
                               tmp_56 = 44;
                          
#line 142 
                          tmp_57 = tmp_56;
                        }
                        else 
#line 142 
                             tmp_57 = 45;
                        
#line 142 
                        tmp_58 = tmp_57;
                      }
                      else 
#line 142 
                           tmp_58 = 46;
                      
#line 142 
                      tmp_59 = tmp_58;
                    }
                    else 
#line 142 
                         tmp_59 = 47;
                    
#line 142 
                    tmp_60 = tmp_59;
                  }
                  else 
#line 142 
                       tmp_60 = 48;
                  
#line 142 
                  tmp_61 = tmp_60;
                }
                else 
#line 142 
                     tmp_61 = 49;
                
#line 142 
                tmp_62 = tmp_61;
              }
              else 
#line 142 
                   tmp_62 = 50;
              
#line 142 
              tmp_63 = tmp_62;
            }
            else 
#line 142 
                 tmp_63 = 51;
            
#line 142 
            tmp_64 = tmp_63;
          }
          
#line 142 
          tmp_66 = tmp_64;
        }
        else {
          int tmp_65;
          
#line 142 
          tmp_65 = __ilog2_u32(size + 4294967295U);
          
#line 142 
          tmp_66 = tmp_65 + -11;
        }
        
#line 142 
        tmp_67 = tmp_66;
      }
      else 
#line 142 
           tmp_67 = 0;
      
#line 142 
      tmp_68 = tmp_67;
    }
    else 
#line 142 
         tmp_68 = 52;
    
#line 142 
    tmp_70 = tmp_68;
  }
  else 
#line 142 
       tmp_70 = __get_order((unsigned long)size);
  
#line 141 
  tmp_71 = __get_free_pages(208U,(unsigned int)tmp_70);
  
#line 140 
  ptr = (void *)tmp_71;
  
#line 143 
  if (((unsigned long)ptr & 7UL) != 0UL) {
    int tmp_143;
    
#line 144 
    if (0 != 0) {
      int tmp_141;
      
#line 144 
      if (size != 0U) {
        int tmp_140;
        
#line 144 
        if (size > 4095U) {
          int tmp_139;
          
#line 144 
          if (0 != 0) {
            int tmp_137;
            
#line 144 
            if (size == 1U) {
              int tmp_72;
              
#line 144 
              tmp_72 = ____ilog2_NaN();
              
#line 144 
              tmp_137 = tmp_72 + -11;
            }
            else {
              int tmp_136;
              
#line 144 
              if (((unsigned long long)(size + 4294967295U) & 4611686018427387904ULL) == 0ULL) {
                int tmp_135;
                
#line 144 
                if (((unsigned long long)(size + 4294967295U) & 2305843009213693952ULL) == 0ULL) {
                  int tmp_134;
                  
#line 144 
                  if (((unsigned long long)(size + 4294967295U) & 1152921504606846976ULL) == 0ULL) {
                    int tmp_133;
                    
#line 144 
                    if (((unsigned long long)(size + 4294967295U) & 576460752303423488ULL) == 0ULL) {
                      int tmp_132;
                      
#line 144 
                      if (((unsigned long long)(size + 4294967295U) & 288230376151711744ULL) == 0ULL) {
                        int tmp_131;
                        
#line 144 
                        if (((unsigned long long)(size + 4294967295U) & 144115188075855872ULL) == 0ULL) {
                          int tmp_130;
                          
#line 144 
                          if (((unsigned long long)(size + 4294967295U) & 72057594037927936ULL) == 0ULL) {
                            int tmp_129;
                            
#line 144 
                            if (((unsigned long long)(size + 4294967295U) & 36028797018963968ULL) == 0ULL) {
                              int tmp_128;
                              
#line 144 
                              if (((unsigned long long)(size + 4294967295U) & 18014398509481984ULL) == 0ULL) {
                                int tmp_127;
                                
#line 144 
                                if (((unsigned long long)(size + 4294967295U) & 9007199254740992ULL) == 0ULL) {
                                  int tmp_126;
                                  
#line 144 
                                  if (((unsigned long long)(size + 4294967295U) & 4503599627370496ULL) == 0ULL) {
                                    int tmp_125;
                                    
#line 144 
                                    if (((unsigned long long)(size + 4294967295U) & 2251799813685248ULL) == 0ULL) {
                                      int tmp_124;
                                      
#line 144 
                                      if (((unsigned long long)(size + 4294967295U) & 1125899906842624ULL) == 0ULL) {
                                        int tmp_123;
                                        
#line 144 
                                        if (((unsigned long long)(size + 4294967295U) & 562949953421312ULL) == 0ULL) {
                                          int tmp_122;
                                          
#line 144 
                                          if (((unsigned long long)(size + 4294967295U) & 281474976710656ULL) == 0ULL) {
                                            int tmp_121;
                                            
#line 144 
                                            if (((unsigned long long)(size + 4294967295U) & 140737488355328ULL) == 0ULL) {
                                              int tmp_120;
                                              
#line 144 
                                              if (((unsigned long long)(size + 4294967295U) & 70368744177664ULL) == 0ULL) {
                                                int tmp_119;
                                                
#line 144 
                                                if (((unsigned long long)(size + 4294967295U) & 35184372088832ULL) == 0ULL) {
                                                  int tmp_118;
                                                  
#line 144 
                                                  if (((unsigned long long)(size + 4294967295U) & 17592186044416ULL) == 0ULL) {
                                                    int tmp_117;
                                                    
#line 144 
                                                    if (((unsigned long long)(size + 4294967295U) & 8796093022208ULL) == 0ULL) {
                                                      int tmp_116;
                                                      
#line 144 
                                                      if (((unsigned long long)(size + 4294967295U) & 4398046511104ULL) == 0ULL) {
                                                        int tmp_115;
                                                        
#line 144 
                                                        if (((unsigned long long)(size + 4294967295U) & 2199023255552ULL) == 0ULL) {
                                                          int tmp_114;
                                                          
#line 144 
                                                          if (((unsigned long long)(size + 4294967295U) & 1099511627776ULL) == 0ULL) {
                                                            int tmp_113;
                                                            
#line 144 
                                                            if (((unsigned long long)(size + 4294967295U) & 549755813888ULL) == 0ULL) {
                                                              int tmp_112;
                                                              
#line 144 
                                                              if (((unsigned long long)(size + 4294967295U) & 274877906944ULL) == 0ULL) {
                                                                int tmp_111;
                                                                
#line 144 
                                                                if (((unsigned long long)(size + 4294967295U) & 137438953472ULL) == 0ULL) {
                                                                  int tmp_110;
                                                                  
#line 144 
                                                                  if (
                                                                    ((unsigned long long)(size + 4294967295U) & 68719476736ULL) == 0ULL) {
                                                                    int tmp_109;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 34359738368ULL) == 0ULL) {
                                                                    int tmp_108;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 17179869184ULL) == 0ULL) {
                                                                    int tmp_107;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 8589934592ULL) == 0ULL) {
                                                                    int tmp_106;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 4294967296ULL) == 0ULL) {
                                                                    int tmp_105;
                                                                    
#line 144 
                                                                    if (
                                                                    size + 4294967295U >= (u32)0) {
                                                                    int tmp_104;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 1073741824ULL) == 0ULL) {
                                                                    int tmp_103;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 536870912ULL) == 0ULL) {
                                                                    int tmp_102;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 268435456ULL) == 0ULL) {
                                                                    int tmp_101;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 134217728ULL) == 0ULL) {
                                                                    int tmp_100;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 67108864ULL) == 0ULL) {
                                                                    int tmp_99;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 33554432ULL) == 0ULL) {
                                                                    int tmp_98;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 16777216ULL) == 0ULL) {
                                                                    int tmp_97;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 8388608ULL) == 0ULL) {
                                                                    int tmp_96;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 4194304ULL) == 0ULL) {
                                                                    int tmp_95;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 2097152ULL) == 0ULL) {
                                                                    int tmp_94;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 1048576ULL) == 0ULL) {
                                                                    int tmp_93;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 524288ULL) == 0ULL) {
                                                                    int tmp_92;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 262144ULL) == 0ULL) {
                                                                    int tmp_91;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 131072ULL) == 0ULL) {
                                                                    int tmp_90;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 65536ULL) == 0ULL) {
                                                                    int tmp_89;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 32768ULL) == 0ULL) {
                                                                    int tmp_88;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 16384ULL) == 0ULL) {
                                                                    int tmp_87;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 8192ULL) == 0ULL) {
                                                                    int tmp_86;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 4096ULL) == 0ULL) {
                                                                    int tmp_85;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 2048ULL) == 0ULL) {
                                                                    int tmp_84;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 1024ULL) == 0ULL) {
                                                                    int tmp_83;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 512ULL) == 0ULL) {
                                                                    int tmp_82;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 256ULL) == 0ULL) {
                                                                    int tmp_81;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 128ULL) == 0ULL) {
                                                                    int tmp_80;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 64ULL) == 0ULL) {
                                                                    int tmp_79;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 32ULL) == 0ULL) {
                                                                    int tmp_78;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 16ULL) == 0ULL) {
                                                                    int tmp_77;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 8ULL) == 0ULL) {
                                                                    int tmp_76;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 4ULL) == 0ULL) {
                                                                    int tmp_75;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 2ULL) == 0ULL) {
                                                                    int tmp_74;
                                                                    
#line 144 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 1ULL) == 0ULL) {
                                                                    int tmp_73;
                                                                    
#line 144 
                                                                    tmp_73 = ____ilog2_NaN();
                                                                    
#line 144 
                                                                    tmp_74 = tmp_73 + -11;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_74 = -11;
                                                                    
#line 144 
                                                                    tmp_75 = tmp_74;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_75 = -10;
                                                                    
#line 144 
                                                                    tmp_76 = tmp_75;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_76 = -9;
                                                                    
#line 144 
                                                                    tmp_77 = tmp_76;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_77 = -8;
                                                                    
#line 144 
                                                                    tmp_78 = tmp_77;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_78 = -7;
                                                                    
#line 144 
                                                                    tmp_79 = tmp_78;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_79 = -6;
                                                                    
#line 144 
                                                                    tmp_80 = tmp_79;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_80 = -5;
                                                                    
#line 144 
                                                                    tmp_81 = tmp_80;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_81 = -4;
                                                                    
#line 144 
                                                                    tmp_82 = tmp_81;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_82 = -3;
                                                                    
#line 144 
                                                                    tmp_83 = tmp_82;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_83 = -2;
                                                                    
#line 144 
                                                                    tmp_84 = tmp_83;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_84 = -1;
                                                                    
#line 144 
                                                                    tmp_85 = tmp_84;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_85 = 0;
                                                                    
#line 144 
                                                                    tmp_86 = tmp_85;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_86 = 1;
                                                                    
#line 144 
                                                                    tmp_87 = tmp_86;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_87 = 2;
                                                                    
#line 144 
                                                                    tmp_88 = tmp_87;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_88 = 3;
                                                                    
#line 144 
                                                                    tmp_89 = tmp_88;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_89 = 4;
                                                                    
#line 144 
                                                                    tmp_90 = tmp_89;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_90 = 5;
                                                                    
#line 144 
                                                                    tmp_91 = tmp_90;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_91 = 6;
                                                                    
#line 144 
                                                                    tmp_92 = tmp_91;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_92 = 7;
                                                                    
#line 144 
                                                                    tmp_93 = tmp_92;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_93 = 8;
                                                                    
#line 144 
                                                                    tmp_94 = tmp_93;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_94 = 9;
                                                                    
#line 144 
                                                                    tmp_95 = tmp_94;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_95 = 10;
                                                                    
#line 144 
                                                                    tmp_96 = tmp_95;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_96 = 11;
                                                                    
#line 144 
                                                                    tmp_97 = tmp_96;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_97 = 12;
                                                                    
#line 144 
                                                                    tmp_98 = tmp_97;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_98 = 13;
                                                                    
#line 144 
                                                                    tmp_99 = tmp_98;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_99 = 14;
                                                                    
#line 144 
                                                                    tmp_100 = tmp_99;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_100 = 15;
                                                                    
#line 144 
                                                                    tmp_101 = tmp_100;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_101 = 16;
                                                                    
#line 144 
                                                                    tmp_102 = tmp_101;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_102 = 17;
                                                                    
#line 144 
                                                                    tmp_103 = tmp_102;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_103 = 18;
                                                                    
#line 144 
                                                                    tmp_104 = tmp_103;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_104 = 19;
                                                                    
#line 144 
                                                                    tmp_105 = tmp_104;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_105 = 20;
                                                                    
#line 144 
                                                                    tmp_106 = tmp_105;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_106 = 21;
                                                                    
#line 144 
                                                                    tmp_107 = tmp_106;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_107 = 22;
                                                                    
#line 144 
                                                                    tmp_108 = tmp_107;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_108 = 23;
                                                                    
#line 144 
                                                                    tmp_109 = tmp_108;
                                                                    }
                                                                    else 
                                                                    
#line 144 
                                                                    tmp_109 = 24;
                                                                    
#line 144 
                                                                    tmp_110 = tmp_109;
                                                                  }
                                                                  else 
                                                                    
#line 144 
                                                                    tmp_110 = 25;
                                                                  
#line 144 
                                                                  tmp_111 = tmp_110;
                                                                }
                                                                else 
                                                                  
#line 144 
                                                                  tmp_111 = 26;
                                                                
#line 144 
                                                                tmp_112 = tmp_111;
                                                              }
                                                              else 
#line 144 
                                                                   tmp_112 = 27;
                                                              
#line 144 
                                                              tmp_113 = tmp_112;
                                                            }
                                                            else 
#line 144 
                                                                 tmp_113 = 28;
                                                            
#line 144 
                                                            tmp_114 = tmp_113;
                                                          }
                                                          else 
#line 144 
                                                               tmp_114 = 29;
                                                          
#line 144 
                                                          tmp_115 = tmp_114;
                                                        }
                                                        else 
#line 144 
                                                             tmp_115 = 30;
                                                        
#line 144 
                                                        tmp_116 = tmp_115;
                                                      }
                                                      else 
#line 144 
                                                           tmp_116 = 31;
                                                      
#line 144 
                                                      tmp_117 = tmp_116;
                                                    }
                                                    else 
#line 144 
                                                         tmp_117 = 32;
                                                    
#line 144 
                                                    tmp_118 = tmp_117;
                                                  }
                                                  else 
#line 144 
                                                       tmp_118 = 33;
                                                  
#line 144 
                                                  tmp_119 = tmp_118;
                                                }
                                                else 
#line 144 
                                                     tmp_119 = 34;
                                                
#line 144 
                                                tmp_120 = tmp_119;
                                              }
                                              else 
#line 144 
                                                   tmp_120 = 35;
                                              
#line 144 
                                              tmp_121 = tmp_120;
                                            }
                                            else 
#line 144 
                                                 tmp_121 = 36;
                                            
#line 144 
                                            tmp_122 = tmp_121;
                                          }
                                          else 
#line 144 
                                               tmp_122 = 37;
                                          
#line 144 
                                          tmp_123 = tmp_122;
                                        }
                                        else 
#line 144 
                                             tmp_123 = 38;
                                        
#line 144 
                                        tmp_124 = tmp_123;
                                      }
                                      else 
#line 144 
                                           tmp_124 = 39;
                                      
#line 144 
                                      tmp_125 = tmp_124;
                                    }
                                    else 
#line 144 
                                         tmp_125 = 40;
                                    
#line 144 
                                    tmp_126 = tmp_125;
                                  }
                                  else 
#line 144 
                                       tmp_126 = 41;
                                  
#line 144 
                                  tmp_127 = tmp_126;
                                }
                                else 
#line 144 
                                     tmp_127 = 42;
                                
#line 144 
                                tmp_128 = tmp_127;
                              }
                              else 
#line 144 
                                   tmp_128 = 43;
                              
#line 144 
                              tmp_129 = tmp_128;
                            }
                            else 
#line 144 
                                 tmp_129 = 44;
                            
#line 144 
                            tmp_130 = tmp_129;
                          }
                          else 
#line 144 
                               tmp_130 = 45;
                          
#line 144 
                          tmp_131 = tmp_130;
                        }
                        else 
#line 144 
                             tmp_131 = 46;
                        
#line 144 
                        tmp_132 = tmp_131;
                      }
                      else 
#line 144 
                           tmp_132 = 47;
                      
#line 144 
                      tmp_133 = tmp_132;
                    }
                    else 
#line 144 
                         tmp_133 = 48;
                    
#line 144 
                    tmp_134 = tmp_133;
                  }
                  else 
#line 144 
                       tmp_134 = 49;
                  
#line 144 
                  tmp_135 = tmp_134;
                }
                else 
#line 144 
                     tmp_135 = 50;
                
#line 144 
                tmp_136 = tmp_135;
              }
              else 
#line 144 
                   tmp_136 = 51;
              
#line 144 
              tmp_137 = tmp_136;
            }
            
#line 144 
            tmp_139 = tmp_137;
          }
          else {
            int tmp_138;
            
#line 144 
            tmp_138 = __ilog2_u32(size + 4294967295U);
            
#line 144 
            tmp_139 = tmp_138 + -11;
          }
          
#line 144 
          tmp_140 = tmp_139;
        }
        else 
#line 144 
             tmp_140 = 0;
        
#line 144 
        tmp_141 = tmp_140;
      }
      else 
#line 144 
           tmp_141 = 52;
      
#line 144 
      tmp_143 = tmp_141;
    }
    else 
#line 144 
         tmp_143 = __get_order((unsigned long)size);
    
#line 144 
    ;
    
#line 144 
    free_pages((unsigned long)ptr,(unsigned int)tmp_143);
    
#line 145 
    ptr = (void *)0;
    
#line 149 
    if (retries == 0) 
#line 150 
                      size += 7U; else ;
  }
  else ;
  
#line 152 
  retries += 1;
  
#line 153 
  if (retries <= 1 && ptr == (void *)0) 
#line 155 
                                        goto ldv_46098; else 
#line 158 
                                                             goto ldv_46099;
  ldv_46099: 
#line 159 
  ;
  
#line 155 
  *alloc_size = size;
  
#line 156 
  *orig_ptr = (unsigned long)ptr;
  
#line 157 
  if (((unsigned long)ptr & 7UL) != 0UL) 
#line 158 
                                         ptr = (void *)(((unsigned long)ptr + 7UL) & 18446744073709551608UL); else ;
  
#line 159 
  return ptr;
}


#line 135  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_network.h"
__inline static void *recv_buffer_alloc(struct octeon_device *oct, u32 q_no, u32 size)
{
  void *__retres;
  
#line 141 
  struct sk_buff *skb = dev_alloc_skb(size + 64U);
  
#line 143 
  if (((unsigned long)skb->data & 63UL) != 0UL) {
    
#line 144 
    u32 r = 64U - ((unsigned int)((long)skb->data) & 63U);
    
#line 146 
    skb_reserve(skb,(int)r);
  }
  else ;
  
#line 149 
  __retres = (void *)skb;
  
#line 149 
  return __retres;
}


#line 152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_network.h"
__inline static void recv_buffer_free(void *buffer)
{
  
#line 154 
  dev_kfree_skb_any((struct sk_buff *)buffer);
  
#line 155 
  return;
}


#line 165  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_network.h"
__inline static u64 lio_map_ring_info(struct octeon_droq *droq, u32 i)
{
  dma_addr_t dma_addr;
  int tmp;
  
#line 168 
  struct octeon_device *oct = droq->oct_dev;
  
#line 170 
  dma_addr = dma_map_single_attrs(& (oct->pci_dev)->dev,(void *)(droq->info_list + i),16UL,(enum dma_data_direction)DMA_FROM_DEVICE,(struct dma_attrs *)0);
  
#line 173 
  tmp = dma_mapping_error(& (oct->pci_dev)->dev,dma_addr);
  
#line 173 
  if ((long)(tmp != 0) != 0L) {
    
#line 175 
    ldv_inline_asm();
    
#line 173 
    ;
  }
  else ;
  
#line 175 
  return dma_addr;
}


#line 179  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_network.h"
__inline static void lio_unmap_ring_info(struct pci_dev *pci_dev, u64 info_ptr, u32 size)
{
  
#line 182 
  dma_unmap_single_attrs(& pci_dev->dev,info_ptr,(unsigned long)size,(enum dma_data_direction)DMA_FROM_DEVICE,(struct dma_attrs *)0);
  
#line 183 
  return;
}


#line 186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_network.h"
__inline static u64 lio_map_ring(struct pci_dev *pci_dev, void *buf, u32 size)
{
  dma_addr_t dma_addr;
  int tmp;
  
#line 191 
  dma_addr = dma_map_single_attrs(& pci_dev->dev,(void *)((struct sk_buff *)buf)->data,(unsigned long)size,(enum dma_data_direction)DMA_FROM_DEVICE,(struct dma_attrs *)0);
  
#line 194 
  tmp = dma_mapping_error(& pci_dev->dev,dma_addr);
  
#line 194 
  if ((long)(tmp != 0) != 0L) {
    
#line 196 
    ldv_inline_asm();
    
#line 194 
    ;
  }
  else ;
  
#line 196 
  return dma_addr;
}


#line 208  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_network.h"
__inline static void *octeon_fast_packet_alloc(struct octeon_device *oct, struct octeon_droq *droq, u32 q_no, u32 size)
{
  void *tmp;
  
#line 212 
  tmp = recv_buffer_alloc(oct,q_no,size);
  
#line 212 
  return tmp;
}


#line 215  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_network.h"
__inline static void octeon_fast_packet_next(struct octeon_droq *droq, struct sk_buff *nicbuf, int copy_len, int idx)
{
  unsigned char *tmp;
  
#line 220 
  ;
  
#line 220 
  ;
  
#line 220 
  tmp = skb_put(nicbuf,(unsigned int)copy_len);
  
#line 220 
  memcpy((void *)tmp,(void const *)((struct sk_buff *)(droq->recv_buf_list + idx)->buffer)->data,(unsigned long)copy_len);
  
#line 222 
  return;
}


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.c"
__inline static void *octeon_get_dispatch_arg(struct octeon_device *octeon_dev, u16 opcode, u16 subcode)
{
  void *__retres;
  int idx;
  struct list_head *dispatch;
  
#line 77 
  void *fn_arg = (void *)0;
  
#line 78 
  u16 combined_opcode = (unsigned short)((((int)opcode << 8) & 3840) | ((int)subcode & 127));
  
#line 80 
  idx = (int)combined_opcode & 63;
  
#line 82 
  ldv_spin_lock_bh_73(& octeon_dev->dispatch.lock);
  
#line 84 
  if (octeon_dev->dispatch.count == 0U) {
    
#line 85 
    ldv_spin_unlock_bh_74(& octeon_dev->dispatch.lock);
    
#line 86 
    __retres = (void *)0;
    
#line 86 
    goto return_label;
  }
  else ;
  
#line 89 
  if ((int)(octeon_dev->dispatch.dlist + idx)->opcode == (int)combined_opcode) 
    
#line 90 
    fn_arg = (octeon_dev->dispatch.dlist + idx)->arg;
  else {
    
#line 92 
    dispatch = (octeon_dev->dispatch.dlist + idx)->list.next;
    
#line 92 
    goto ldv_46610;
    ldv_46609: 
#line 93 
    ;
    
#line 94 
    if ((int)((struct octeon_dispatch *)dispatch)->opcode == (int)combined_opcode) {
      
#line 96 
      fn_arg = ((struct octeon_dispatch *)dispatch)->arg;
      
#line 98 
      goto ldv_46608;
    }
    else ;
    
#line 92 
    dispatch = dispatch->next;
    ldv_46610: 
#line 93 
    ;
    
#line 92 
    if (& (octeon_dev->dispatch.dlist + idx)->list != dispatch) 
#line 94 
                                                                goto ldv_46609; else 
                                                                    
#line 97 
                                                                    goto ldv_46608;
    ldv_46608: 
#line 98 
    ;
  }
  
#line 103 
  ldv_spin_unlock_bh_75(& octeon_dev->dispatch.lock);
  
#line 104 
  __retres = fn_arg;
  return_label: 
#line 104 
                return __retres;
}


#line 107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.c"
u32 octeon_droq_check_hw_for_pkts(struct octeon_device *oct, struct octeon_droq *droq)
{
  
#line 110 
  u32 pkt_count = 0U;
  
#line 112 
  pkt_count = readl((void const volatile *)droq->pkts_sent_reg);
  
#line 113 
  if (pkt_count != 0U) {
    
#line 114 
    atomic_add((int)pkt_count,& droq->pkts_pending);
    
#line 115 
    writel(pkt_count,(void volatile *)droq->pkts_sent_reg);
  }
  else ;
  
#line 118 
  return pkt_count;
}


#line 121  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.c"
static void octeon_droq_compute_max_packet_bufs(struct octeon_droq *droq)
{
  
#line 123 
  u32 count = 0U;
  
#line 130 
  droq->max_empty_descs = 0U;
  ldv_46620: 
#line 131 
  ;
  
#line 133 
  droq->max_empty_descs += 1U;
  
#line 134 
  count = droq->buffer_size + count;
  
#line 135 
  if (count <= 65535U) 
#line 137 
                       goto ldv_46620; else 
#line 140 
                                            goto ldv_46621;
  ldv_46621: 
#line 141 
  ;
  
#line 137 
  droq->max_empty_descs = droq->max_count - droq->max_empty_descs;
  
#line 138 
  return;
}


#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.c"
static void octeon_droq_reset_indices(struct octeon_droq *droq)
{
  
#line 142 
  droq->read_idx = 0U;
  
#line 143 
  droq->write_idx = 0U;
  
#line 144 
  droq->refill_idx = 0U;
  
#line 145 
  droq->refill_count = 0U;
  
#line 146 
  atomic_set(& droq->pkts_pending,0);
  
#line 147 
  return;
}


#line 150  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.c"
static void octeon_droq_destroy_ring_buffers(struct octeon_device *oct, struct octeon_droq *droq)
{
  u32 i;
  
#line 155 
  i = 0U;
  
#line 155 
  goto ldv_46631;
  ldv_46630: 
#line 156 
  ;
  
#line 156 
  if ((droq->recv_buf_list + i)->buffer != (void *)0) {
    
#line 157 
    if (droq->desc_ring != (struct octeon_droq_desc *)0) {
      
#line 158 
      lio_unmap_ring_info(oct->pci_dev,(droq->desc_ring + i)->info_ptr,16U);
      
#line 162 
      lio_unmap_ring_info(oct->pci_dev,(droq->desc_ring + i)->buffer_ptr,droq->buffer_size);
    }
    else ;
    
#line 167 
    recv_buffer_free((droq->recv_buf_list + i)->buffer);
    
#line 168 
    (droq->recv_buf_list + i)->buffer = (void *)0;
  }
  else ;
  
#line 155 
  i += 1U;
  ldv_46631: 
#line 156 
  ;
  
#line 155 
  if (droq->max_count > i) 
#line 157 
                           goto ldv_46630; else 
#line 160 
                                                goto ldv_46632;
  ldv_46632: 
#line 161 
  ;
  
#line 172 
  octeon_droq_reset_indices(droq);
  
#line 173 
  return;
}


#line 176  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.c"
static int octeon_droq_setup_ring_buffers(struct octeon_device *oct, struct octeon_droq *droq)
{
  int __retres;
  u32 i;
  void *buf;
  
#line 181 
  struct octeon_droq_desc *desc_ring = droq->desc_ring;
  
#line 183 
  i = 0U;
  
#line 183 
  goto ldv_46642;
  ldv_46641: 
#line 184 
  ;
  
#line 184 
  buf = recv_buffer_alloc(oct,droq->q_no,droq->buffer_size);
  
#line 186 
  if (buf == (void *)0) {
    
#line 187 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"%s buffer alloc failed\n","octeon_droq_setup_ring_buffers");
    
#line 189 
    __retres = -12;
    
#line 189 
    goto return_label;
  }
  else ;
  
#line 192 
  (droq->recv_buf_list + i)->buffer = buf;
  
#line 193 
  (droq->recv_buf_list + i)->data = ((struct sk_buff *)buf)->data;
  
#line 195 
  (droq->info_list + i)->length = 0ULL;
  
#line 198 
  (desc_ring + i)->info_ptr = lio_map_ring_info(droq,i);
  
#line 199 
  (desc_ring + i)->buffer_ptr = lio_map_ring(oct->pci_dev,(droq->recv_buf_list + i)->buffer,droq->buffer_size);
  
#line 183 
  i += 1U;
  ldv_46642: 
#line 184 
  ;
  
#line 183 
  if (droq->max_count > i) 
#line 185 
                           goto ldv_46641; else 
#line 188 
                                                goto ldv_46643;
  ldv_46643: 
#line 189 
  ;
  
#line 205 
  octeon_droq_reset_indices(droq);
  
#line 207 
  octeon_droq_compute_max_packet_bufs(droq);
  
#line 209 
  __retres = 0;
  return_label: 
#line 209 
                return __retres;
}


#line 212  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.c"
int octeon_delete_droq(struct octeon_device *oct, u32 q_no)
{
  int __retres;
  
#line 214 
  struct octeon_droq *droq = oct->droq[q_no];
  {
    
#line 216 
    struct _ddebug descriptor = {.modname = "liquidio", .function = "octeon_delete_droq", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.c", .format = "%s[%d]\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))216U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 216 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 216 
                                                        __dynamic_dev_dbg(& descriptor,(struct device const *)(& (oct->pci_dev)->dev),"%s[%d]\n","octeon_delete_droq",q_no); else ;
  }
  
#line 218 
  octeon_droq_destroy_ring_buffers(oct,droq);
  
#line 219 
  vfree((void const *)droq->recv_buf_list);
  
#line 221 
  if (droq->info_base_addr != 0UL) {
    int tmp_70;
    
#line 222 
    if (0 != 0) {
      int tmp_68;
      
#line 222 
      if (droq->info_alloc_size != 0U) {
        int tmp_67;
        
#line 222 
        if (droq->info_alloc_size > 4095U) {
          int tmp_66;
          
#line 222 
          if (0 != 0) {
            int tmp_64;
            
#line 222 
            if (droq->info_alloc_size == 1U) {
              int tmp;
              
#line 222 
              tmp = ____ilog2_NaN();
              
#line 222 
              tmp_64 = tmp + -11;
            }
            else {
              int tmp_63;
              
#line 222 
              if (((unsigned long long)(droq->info_alloc_size + 4294967295U) & 4611686018427387904ULL) == 0ULL) {
                int tmp_62;
                
#line 222 
                if (((unsigned long long)(droq->info_alloc_size + 4294967295U) & 2305843009213693952ULL) == 0ULL) {
                  int tmp_61;
                  
#line 222 
                  if (((unsigned long long)(droq->info_alloc_size + 4294967295U) & 1152921504606846976ULL) == 0ULL) {
                    int tmp_60;
                    
#line 222 
                    if (((unsigned long long)(droq->info_alloc_size + 4294967295U) & 576460752303423488ULL) == 0ULL) {
                      int tmp_59;
                      
#line 222 
                      if (((unsigned long long)(droq->info_alloc_size + 4294967295U) & 288230376151711744ULL) == 0ULL) {
                        int tmp_58;
                        
#line 222 
                        if (((unsigned long long)(droq->info_alloc_size + 4294967295U) & 144115188075855872ULL) == 0ULL) {
                          int tmp_57;
                          
#line 222 
                          if (((unsigned long long)(droq->info_alloc_size + 4294967295U) & 72057594037927936ULL) == 0ULL) {
                            int tmp_56;
                            
#line 222 
                            if (((unsigned long long)(droq->info_alloc_size + 4294967295U) & 36028797018963968ULL) == 0ULL) {
                              int tmp_55;
                              
#line 222 
                              if (((unsigned long long)(droq->info_alloc_size + 4294967295U) & 18014398509481984ULL) == 0ULL) {
                                int tmp_54;
                                
#line 222 
                                if (((unsigned long long)(droq->info_alloc_size + 4294967295U) & 9007199254740992ULL) == 0ULL) {
                                  int tmp_53;
                                  
#line 222 
                                  if (((unsigned long long)(droq->info_alloc_size + 4294967295U) & 4503599627370496ULL) == 0ULL) {
                                    int tmp_52;
                                    
#line 222 
                                    if (((unsigned long long)(droq->info_alloc_size + 4294967295U) & 2251799813685248ULL) == 0ULL) {
                                      int tmp_51;
                                      
#line 222 
                                      if (((unsigned long long)(droq->info_alloc_size + 4294967295U) & 1125899906842624ULL) == 0ULL) {
                                        int tmp_50;
                                        
#line 222 
                                        if (((unsigned long long)(droq->info_alloc_size + 4294967295U) & 562949953421312ULL) == 0ULL) {
                                          int tmp_49;
                                          
#line 222 
                                          if (((unsigned long long)(droq->info_alloc_size + 4294967295U) & 281474976710656ULL) == 0ULL) {
                                            int tmp_48;
                                            
#line 222 
                                            if (((unsigned long long)(droq->info_alloc_size + 4294967295U) & 140737488355328ULL) == 0ULL) {
                                              int tmp_47;
                                              
#line 222 
                                              if (((unsigned long long)(droq->info_alloc_size + 4294967295U) & 70368744177664ULL) == 0ULL) {
                                                int tmp_46;
                                                
#line 222 
                                                if (((unsigned long long)(droq->info_alloc_size + 4294967295U) & 35184372088832ULL) == 0ULL) {
                                                  int tmp_45;
                                                  
#line 222 
                                                  if (((unsigned long long)(droq->info_alloc_size + 4294967295U) & 17592186044416ULL) == 0ULL) {
                                                    int tmp_44;
                                                    
#line 222 
                                                    if (((unsigned long long)(droq->info_alloc_size + 4294967295U) & 8796093022208ULL) == 0ULL) {
                                                      int tmp_43;
                                                      
#line 222 
                                                      if (((unsigned long long)(droq->info_alloc_size + 4294967295U) & 4398046511104ULL) == 0ULL) {
                                                        int tmp_42;
                                                        
#line 222 
                                                        if (((unsigned long long)(droq->info_alloc_size + 4294967295U) & 2199023255552ULL) == 0ULL) {
                                                          int tmp_41;
                                                          
#line 222 
                                                          if (((unsigned long long)(droq->info_alloc_size + 4294967295U) & 1099511627776ULL) == 0ULL) {
                                                            int tmp_40;
                                                            
#line 222 
                                                            if (((unsigned long long)(droq->info_alloc_size + 4294967295U) & 549755813888ULL) == 0ULL) {
                                                              int tmp_39;
                                                              
#line 222 
                                                              if (((unsigned long long)(droq->info_alloc_size + 4294967295U) & 274877906944ULL) == 0ULL) {
                                                                int tmp_38;
                                                                
#line 222 
                                                                if (((unsigned long long)(droq->info_alloc_size + 4294967295U) & 137438953472ULL) == 0ULL) {
                                                                  int tmp_37;
                                                                  
#line 222 
                                                                  if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 68719476736ULL) == 0ULL) {
                                                                    int tmp_36;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 34359738368ULL) == 0ULL) {
                                                                    int tmp_35;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 17179869184ULL) == 0ULL) {
                                                                    int tmp_34;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 8589934592ULL) == 0ULL) {
                                                                    int tmp_33;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 4294967296ULL) == 0ULL) {
                                                                    int tmp_32;
                                                                    
#line 222 
                                                                    if (
                                                                    droq->info_alloc_size + 4294967295U >= (u32)0) {
                                                                    int tmp_31;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 1073741824ULL) == 0ULL) {
                                                                    int tmp_30;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 536870912ULL) == 0ULL) {
                                                                    int tmp_29;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 268435456ULL) == 0ULL) {
                                                                    int tmp_28;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 134217728ULL) == 0ULL) {
                                                                    int tmp_27;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 67108864ULL) == 0ULL) {
                                                                    int tmp_26;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 33554432ULL) == 0ULL) {
                                                                    int tmp_25;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 16777216ULL) == 0ULL) {
                                                                    int tmp_24;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 8388608ULL) == 0ULL) {
                                                                    int tmp_23;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 4194304ULL) == 0ULL) {
                                                                    int tmp_22;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 2097152ULL) == 0ULL) {
                                                                    int tmp_21;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 1048576ULL) == 0ULL) {
                                                                    int tmp_20;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 524288ULL) == 0ULL) {
                                                                    int tmp_19;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 262144ULL) == 0ULL) {
                                                                    int tmp_18;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 131072ULL) == 0ULL) {
                                                                    int tmp_17;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 65536ULL) == 0ULL) {
                                                                    int tmp_16;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 32768ULL) == 0ULL) {
                                                                    int tmp_15;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 16384ULL) == 0ULL) {
                                                                    int tmp_14;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 8192ULL) == 0ULL) {
                                                                    int tmp_13;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 4096ULL) == 0ULL) {
                                                                    int tmp_12;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 2048ULL) == 0ULL) {
                                                                    int tmp_11;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 1024ULL) == 0ULL) {
                                                                    int tmp_10;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 512ULL) == 0ULL) {
                                                                    int tmp_9;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 256ULL) == 0ULL) {
                                                                    int tmp_8;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 128ULL) == 0ULL) {
                                                                    int tmp_7;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 64ULL) == 0ULL) {
                                                                    int tmp_6;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 32ULL) == 0ULL) {
                                                                    int tmp_5;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 16ULL) == 0ULL) {
                                                                    int tmp_4;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 8ULL) == 0ULL) {
                                                                    int tmp_3;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 4ULL) == 0ULL) {
                                                                    int tmp_2;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 2ULL) == 0ULL) {
                                                                    int tmp_1;
                                                                    
#line 222 
                                                                    if (
                                                                    ((unsigned long long)(droq->info_alloc_size + 4294967295U) & 1ULL) == 0ULL) {
                                                                    int tmp_0;
                                                                    
#line 222 
                                                                    tmp_0 = ____ilog2_NaN();
                                                                    
#line 222 
                                                                    tmp_1 = tmp_0 + -11;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_1 = -11;
                                                                    
#line 222 
                                                                    tmp_2 = tmp_1;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_2 = -10;
                                                                    
#line 222 
                                                                    tmp_3 = tmp_2;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_3 = -9;
                                                                    
#line 222 
                                                                    tmp_4 = tmp_3;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_4 = -8;
                                                                    
#line 222 
                                                                    tmp_5 = tmp_4;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_5 = -7;
                                                                    
#line 222 
                                                                    tmp_6 = tmp_5;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_6 = -6;
                                                                    
#line 222 
                                                                    tmp_7 = tmp_6;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_7 = -5;
                                                                    
#line 222 
                                                                    tmp_8 = tmp_7;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_8 = -4;
                                                                    
#line 222 
                                                                    tmp_9 = tmp_8;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_9 = -3;
                                                                    
#line 222 
                                                                    tmp_10 = tmp_9;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_10 = -2;
                                                                    
#line 222 
                                                                    tmp_11 = tmp_10;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_11 = -1;
                                                                    
#line 222 
                                                                    tmp_12 = tmp_11;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_12 = 0;
                                                                    
#line 222 
                                                                    tmp_13 = tmp_12;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_13 = 1;
                                                                    
#line 222 
                                                                    tmp_14 = tmp_13;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_14 = 2;
                                                                    
#line 222 
                                                                    tmp_15 = tmp_14;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_15 = 3;
                                                                    
#line 222 
                                                                    tmp_16 = tmp_15;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_16 = 4;
                                                                    
#line 222 
                                                                    tmp_17 = tmp_16;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_17 = 5;
                                                                    
#line 222 
                                                                    tmp_18 = tmp_17;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_18 = 6;
                                                                    
#line 222 
                                                                    tmp_19 = tmp_18;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_19 = 7;
                                                                    
#line 222 
                                                                    tmp_20 = tmp_19;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_20 = 8;
                                                                    
#line 222 
                                                                    tmp_21 = tmp_20;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_21 = 9;
                                                                    
#line 222 
                                                                    tmp_22 = tmp_21;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_22 = 10;
                                                                    
#line 222 
                                                                    tmp_23 = tmp_22;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_23 = 11;
                                                                    
#line 222 
                                                                    tmp_24 = tmp_23;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_24 = 12;
                                                                    
#line 222 
                                                                    tmp_25 = tmp_24;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_25 = 13;
                                                                    
#line 222 
                                                                    tmp_26 = tmp_25;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_26 = 14;
                                                                    
#line 222 
                                                                    tmp_27 = tmp_26;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_27 = 15;
                                                                    
#line 222 
                                                                    tmp_28 = tmp_27;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_28 = 16;
                                                                    
#line 222 
                                                                    tmp_29 = tmp_28;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_29 = 17;
                                                                    
#line 222 
                                                                    tmp_30 = tmp_29;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_30 = 18;
                                                                    
#line 222 
                                                                    tmp_31 = tmp_30;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_31 = 19;
                                                                    
#line 222 
                                                                    tmp_32 = tmp_31;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_32 = 20;
                                                                    
#line 222 
                                                                    tmp_33 = tmp_32;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_33 = 21;
                                                                    
#line 222 
                                                                    tmp_34 = tmp_33;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_34 = 22;
                                                                    
#line 222 
                                                                    tmp_35 = tmp_34;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_35 = 23;
                                                                    
#line 222 
                                                                    tmp_36 = tmp_35;
                                                                    }
                                                                    else 
                                                                    
#line 222 
                                                                    tmp_36 = 24;
                                                                    
#line 222 
                                                                    tmp_37 = tmp_36;
                                                                  }
                                                                  else 
                                                                    
#line 222 
                                                                    tmp_37 = 25;
                                                                  
#line 222 
                                                                  tmp_38 = tmp_37;
                                                                }
                                                                else 
                                                                  
#line 222 
                                                                  tmp_38 = 26;
                                                                
#line 222 
                                                                tmp_39 = tmp_38;
                                                              }
                                                              else 
#line 222 
                                                                   tmp_39 = 27;
                                                              
#line 222 
                                                              tmp_40 = tmp_39;
                                                            }
                                                            else 
#line 222 
                                                                 tmp_40 = 28;
                                                            
#line 222 
                                                            tmp_41 = tmp_40;
                                                          }
                                                          else 
#line 222 
                                                               tmp_41 = 29;
                                                          
#line 222 
                                                          tmp_42 = tmp_41;
                                                        }
                                                        else 
#line 222 
                                                             tmp_42 = 30;
                                                        
#line 222 
                                                        tmp_43 = tmp_42;
                                                      }
                                                      else 
#line 222 
                                                           tmp_43 = 31;
                                                      
#line 222 
                                                      tmp_44 = tmp_43;
                                                    }
                                                    else 
#line 222 
                                                         tmp_44 = 32;
                                                    
#line 222 
                                                    tmp_45 = tmp_44;
                                                  }
                                                  else 
#line 222 
                                                       tmp_45 = 33;
                                                  
#line 222 
                                                  tmp_46 = tmp_45;
                                                }
                                                else 
#line 222 
                                                     tmp_46 = 34;
                                                
#line 222 
                                                tmp_47 = tmp_46;
                                              }
                                              else 
#line 222 
                                                   tmp_47 = 35;
                                              
#line 222 
                                              tmp_48 = tmp_47;
                                            }
                                            else 
#line 222 
                                                 tmp_48 = 36;
                                            
#line 222 
                                            tmp_49 = tmp_48;
                                          }
                                          else 
#line 222 
                                               tmp_49 = 37;
                                          
#line 222 
                                          tmp_50 = tmp_49;
                                        }
                                        else 
#line 222 
                                             tmp_50 = 38;
                                        
#line 222 
                                        tmp_51 = tmp_50;
                                      }
                                      else 
#line 222 
                                           tmp_51 = 39;
                                      
#line 222 
                                      tmp_52 = tmp_51;
                                    }
                                    else 
#line 222 
                                         tmp_52 = 40;
                                    
#line 222 
                                    tmp_53 = tmp_52;
                                  }
                                  else 
#line 222 
                                       tmp_53 = 41;
                                  
#line 222 
                                  tmp_54 = tmp_53;
                                }
                                else 
#line 222 
                                     tmp_54 = 42;
                                
#line 222 
                                tmp_55 = tmp_54;
                              }
                              else 
#line 222 
                                   tmp_55 = 43;
                              
#line 222 
                              tmp_56 = tmp_55;
                            }
                            else 
#line 222 
                                 tmp_56 = 44;
                            
#line 222 
                            tmp_57 = tmp_56;
                          }
                          else 
#line 222 
                               tmp_57 = 45;
                          
#line 222 
                          tmp_58 = tmp_57;
                        }
                        else 
#line 222 
                             tmp_58 = 46;
                        
#line 222 
                        tmp_59 = tmp_58;
                      }
                      else 
#line 222 
                           tmp_59 = 47;
                      
#line 222 
                      tmp_60 = tmp_59;
                    }
                    else 
#line 222 
                         tmp_60 = 48;
                    
#line 222 
                    tmp_61 = tmp_60;
                  }
                  else 
#line 222 
                       tmp_61 = 49;
                  
#line 222 
                  tmp_62 = tmp_61;
                }
                else 
#line 222 
                     tmp_62 = 50;
                
#line 222 
                tmp_63 = tmp_62;
              }
              else 
#line 222 
                   tmp_63 = 51;
              
#line 222 
              tmp_64 = tmp_63;
            }
            
#line 222 
            tmp_66 = tmp_64;
          }
          else {
            int tmp_65;
            
#line 222 
            tmp_65 = __ilog2_u32(droq->info_alloc_size + 4294967295U);
            
#line 222 
            tmp_66 = tmp_65 + -11;
          }
          
#line 222 
          tmp_67 = tmp_66;
        }
        else 
#line 222 
             tmp_67 = 0;
        
#line 222 
        tmp_68 = tmp_67;
      }
      else 
#line 222 
           tmp_68 = 52;
      
#line 222 
      tmp_70 = tmp_68;
    }
    else 
#line 222 
         tmp_70 = __get_order((unsigned long)droq->info_alloc_size);
    
#line 222 
    ;
    
#line 222 
    free_pages(droq->info_base_addr,(unsigned int)tmp_70);
  }
  else ;
  
#line 227 
  if (droq->desc_ring != (struct octeon_droq_desc *)0) 
#line 228 
                                                       dma_free_attrs(& (oct->pci_dev)->dev,(unsigned long)droq->max_count * 16UL,(void *)droq->desc_ring,(unsigned long long)droq->desc_ring_dma,(struct dma_attrs *)0); else ;
  
#line 231 
  memset((void *)droq,0,640UL);
  
#line 233 
  __retres = 0;
  
#line 233 
  return __retres;
}


#line 236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.c"
int octeon_init_droq(struct octeon_device *oct, u32 q_no, u32 num_descs, u32 desc_size, void *app_ctx)
{
  int __retres;
  struct octeon_droq *droq;
  int tmp_2;
  
#line 243 
  u32 desc_ring_size = 0U;
  
#line 243 
  u32 c_num_descs = 0U;
  
#line 243 
  u32 c_buf_size = 0U;
  
#line 244 
  u32 c_pkts_per_intr = 0U;
  
#line 244 
  u32 c_refill_threshold = 0U;
  {
    
#line 246 
    struct _ddebug descriptor = {.modname = "liquidio", .function = "octeon_init_droq", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.c", .format = "%s[%d]\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))246U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 246 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 246 
                                                        __dynamic_dev_dbg(& descriptor,(struct device const *)(& (oct->pci_dev)->dev),"%s[%d]\n","octeon_init_droq",q_no); else ;
  }
  
#line 248 
  droq = oct->droq[q_no];
  
#line 249 
  memset((void *)droq,0,640UL);
  
#line 251 
  droq->oct_dev = oct;
  
#line 252 
  droq->q_no = q_no;
  
#line 253 
  if (app_ctx != (void *)0) 
#line 254 
                            droq->app_ctx = app_ctx; else 
#line 256 
                                                          droq->app_ctx = (void *)((unsigned long)q_no);
  
#line 258 
  c_num_descs = num_descs;
  
#line 259 
  c_buf_size = desc_size;
  
#line 260 
  if ((unsigned int)oct->chip_id + 65391U <= 1U) {
    
#line 261 
    struct octeon_config *conf6x = ((struct octeon_cn6xxx *)oct->chip)->conf;
    
#line 263 
    c_pkts_per_intr = (unsigned int)conf6x->oq.pkts_per_intr;
    
#line 264 
    c_refill_threshold = (unsigned int)conf6x->oq.refill_threshold;
  }
  else ;
  
#line 267 
  droq->max_count = c_num_descs;
  
#line 268 
  droq->buffer_size = c_buf_size;
  
#line 270 
  desc_ring_size = droq->max_count * 16U;
  
#line 271 
  droq->desc_ring = (struct octeon_droq_desc *)dma_alloc_attrs(& (oct->pci_dev)->dev,(unsigned long)desc_ring_size,(dma_addr_t *)(& droq->desc_ring_dma),208U,(struct dma_attrs *)0);
  
#line 274 
  if (droq->desc_ring == (struct octeon_droq_desc *)0) {
    
#line 275 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Output queue %d ring alloc failed\n",q_no);
    
#line 277 
    __retres = 1;
    
#line 277 
    goto return_label;
  }
  else ;
  {
    
#line 280 
    struct _ddebug descriptor_0 = {.modname = "liquidio", .function = "octeon_init_droq", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.c", .format = "droq[%d]: desc_ring: virt: 0x%p, dma: %lx\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))281U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 280 
    if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 280 
                                                          __dynamic_dev_dbg(& descriptor_0,(struct device const *)(& (oct->pci_dev)->dev),"droq[%d]: desc_ring: virt: 0x%p, dma: %lx\n",q_no,droq->desc_ring,droq->desc_ring_dma); else ;
  }
  {
    
#line 282 
    struct _ddebug descriptor_1 = {.modname = "liquidio", .function = "octeon_init_droq", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.c", .format = "droq[%d]: num_desc: %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))283U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 282 
    if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) 
#line 282 
                                                          __dynamic_dev_dbg(& descriptor_1,(struct device const *)(& (oct->pci_dev)->dev),"droq[%d]: num_desc: %d\n",q_no,droq->max_count); else ;
  }
  
#line 286 
  droq->info_list = (struct octeon_droq_info *)cnnic_alloc_aligned_dma(oct->pci_dev,droq->max_count * 16U,& droq->info_alloc_size,& droq->info_base_addr,& droq->info_list_dma);
  
#line 292 
  if (droq->info_list == (struct octeon_droq_info *)0) {
    
#line 293 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Cannot allocate memory for info list.\n");
    
#line 294 
    dma_free_attrs(& (oct->pci_dev)->dev,(unsigned long)droq->max_count * 16UL,(void *)droq->desc_ring,(unsigned long long)droq->desc_ring_dma,(struct dma_attrs *)0);
    
#line 296 
    __retres = 1;
    
#line 296 
    goto return_label;
  }
  else ;
  
#line 299 
  droq->recv_buf_list = (struct octeon_recv_buffer *)vmalloc((unsigned long)droq->max_count * 16UL);
  
#line 302 
  if (droq->recv_buf_list == (struct octeon_recv_buffer *)0) {
    
#line 303 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Output queue recv buf list alloc failed\n");
    
#line 304 
    goto init_droq_fail;
  }
  else ;
  
#line 307 
  tmp_2 = octeon_droq_setup_ring_buffers(oct,droq);
  
#line 307 
  if (tmp_2 != 0) 
#line 308 
                  goto init_droq_fail; else ;
  
#line 310 
  droq->pkts_per_intr = c_pkts_per_intr;
  
#line 311 
  droq->refill_threshold = c_refill_threshold;
  {
    
#line 313 
    struct _ddebug descriptor_2 = {.modname = "liquidio", .function = "octeon_init_droq", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.c", .format = "DROQ INIT: max_empty_descs: %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))314U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 313 
    if ((long)(((int)descriptor_2.flags & 1) != 0) != 0L) 
#line 313 
                                                          __dynamic_dev_dbg(& descriptor_2,(struct device const *)(& (oct->pci_dev)->dev),"DROQ INIT: max_empty_descs: %d\n",droq->max_empty_descs); else ;
  }
  
#line 316 
  spinlock_check(& droq->lock);
  {
    struct lock_class_key __key;
    
#line 316 
    __raw_spin_lock_init(& droq->lock.__anonCompField_spinlock_18.rlock,"&(&droq->lock)->rlock",& __key);
  }
  
#line 318 
  INIT_LIST_HEAD(& droq->dispatch_list);
  
#line 321 
  (*(oct->fn_list.setup_oq_regs))(oct,q_no);
  
#line 323 
  oct->io_qmask.oq |= (unsigned int)(1 << q_no);
  
#line 325 
  __retres = 0;
  
#line 325 
  goto return_label;
  init_droq_fail: 
#line 327 
  ;
  
#line 328 
  octeon_delete_droq(oct,q_no);
  
#line 329 
  __retres = 1;
  return_label: 
#line 329 
                return __retres;
}


#line 351  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.c"
__inline static struct octeon_recv_info *octeon_create_recv_info(struct octeon_device *octeon_dev, struct octeon_droq *droq, u32 buf_cnt, u32 idx)
{
  struct octeon_recv_info *__retres;
  struct octeon_droq_info *info;
  struct octeon_recv_pkt *recv_pkt;
  struct octeon_recv_info *recv_info;
  u32 i;
  u32 bytes_left;
  
#line 362 
  info = droq->info_list + idx;
  
#line 364 
  recv_info = octeon_alloc_recv_info(32);
  
#line 365 
  if (recv_info == (struct octeon_recv_info *)0) {
    
#line 366 
    __retres = (struct octeon_recv_info *)0;
    
#line 366 
    goto return_label;
  }
  else ;
  
#line 368 
  recv_pkt = recv_info->recv_pkt;
  
#line 369 
  recv_pkt->rh = info->rh;
  
#line 370 
  recv_pkt->length = (unsigned int)info->length;
  
#line 371 
  recv_pkt->buffer_count = (unsigned short)buf_cnt;
  
#line 372 
  recv_pkt->octeon_id = (unsigned short)octeon_dev->octeon_id;
  
#line 374 
  i = 0U;
  
#line 375 
  bytes_left = (unsigned int)info->length;
  
#line 377 
  goto ldv_46684;
  ldv_46683: 
#line 378 
  ;
  
#line 378 
  lio_unmap_ring_info(octeon_dev->pci_dev,(droq->desc_ring + idx)->buffer_ptr,droq->buffer_size);
  
#line 382 
  if (bytes_left < droq->buffer_size) 
#line 382 
                                      recv_pkt->buffer_size[i] = bytes_left; else 
                                                                    
#line 382 
                                                                    recv_pkt->buffer_size[i] = droq->buffer_size;
  
#line 386 
  recv_pkt->buffer_ptr[i] = (droq->recv_buf_list + idx)->buffer;
  
#line 387 
  (droq->recv_buf_list + idx)->buffer = (void *)0;
  
#line 389 
  idx += 1U;
  
#line 389 
  ;
  
#line 389 
  if (idx == droq->max_count) 
#line 389 
                              idx = 0U; else ;
  
#line 390 
  bytes_left -= droq->buffer_size;
  
#line 391 
  i += 1U;
  
#line 392 
  buf_cnt -= 1U;
  ldv_46684: 
#line 393 
  ;
  
#line 377 
  if (buf_cnt != 0U) 
#line 379 
                     goto ldv_46683; else 
#line 382 
                                          goto ldv_46685;
  ldv_46685: 
#line 383 
  ;
  
#line 395 
  __retres = recv_info;
  return_label: 
#line 395 
                return __retres;
}


#line 402  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.c"
__inline static u32 octeon_droq_refill_pullup_descs(struct octeon_droq *droq, struct octeon_droq_desc *desc_ring)
{
  
#line 405 
  u32 desc_refilled = 0U;
  
#line 407 
  u32 refill_index = droq->refill_idx;
  
#line 409 
  goto ldv_46695;
  ldv_46694: 
#line 410 
  ;
  
#line 410 
  if ((droq->recv_buf_list + refill_index)->buffer != (void *)0) {
    
#line 411 
    (droq->recv_buf_list + droq->refill_idx)->buffer = (droq->recv_buf_list + refill_index)->buffer;
    
#line 413 
    (droq->recv_buf_list + droq->refill_idx)->data = (droq->recv_buf_list + refill_index)->data;
    
#line 415 
    (desc_ring + droq->refill_idx)->buffer_ptr = (desc_ring + refill_index)->buffer_ptr;
    
#line 417 
    (droq->recv_buf_list + refill_index)->buffer = (void *)0;
    
#line 418 
    (desc_ring + refill_index)->buffer_ptr = 0ULL;
    ldv_46692: 
#line 419 
    ;
    
#line 420 
    droq->refill_idx += 1U;
    
#line 420 
    ;
    
#line 420 
    if (droq->refill_idx == droq->max_count) 
#line 420 
                                             droq->refill_idx = 0U; else ;
    
#line 422 
    desc_refilled += 1U;
    
#line 423 
    droq->refill_count -= 1U;
    
#line 425 
    if ((droq->recv_buf_list + droq->refill_idx)->buffer != (void *)0) 
      
#line 426 
      goto ldv_46692; else 
#line 429 
                           goto ldv_46693;
    ldv_46693: 
#line 430 
    ;
  }
  else ;
  
#line 427 
  refill_index += 1U;
  
#line 427 
  ;
  
#line 427 
  if (refill_index == droq->max_count) 
#line 427 
                                       refill_index = 0U; else ;
  ldv_46695: 
#line 428 
  ;
  
#line 409 
  if (droq->read_idx != refill_index) 
#line 411 
                                      goto ldv_46694; else 
#line 414 
                                                           goto ldv_46696;
  ldv_46696: 
#line 415 
  ;
  
#line 429 
  return desc_refilled;
}


#line 446  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.c"
static u32 octeon_droq_refill(struct octeon_device *octeon_dev, struct octeon_droq *droq)
{
  struct octeon_droq_desc *desc_ring;
  u8 *data;
  
#line 449 
  void *buf = (void *)0;
  
#line 451 
  u32 desc_refilled = 0U;
  
#line 453 
  desc_ring = droq->desc_ring;
  
#line 455 
  goto ldv_46707;
  ldv_46706: 
#line 456 
  ;
  
#line 460 
  if ((droq->recv_buf_list + droq->refill_idx)->buffer == (void *)0) {
    
#line 461 
    buf = recv_buffer_alloc(octeon_dev,droq->q_no,droq->buffer_size);
    
#line 466 
    if (buf == (void *)0) 
#line 467 
                          goto ldv_46705; else ;
    
#line 468 
    (droq->recv_buf_list + droq->refill_idx)->buffer = buf;
    
#line 470 
    data = ((struct sk_buff *)buf)->data;
  }
  else 
#line 472 
       data = ((struct sk_buff *)(droq->recv_buf_list + droq->refill_idx)->buffer)->data;
  
#line 476 
  (droq->recv_buf_list + droq->refill_idx)->data = data;
  
#line 478 
  (desc_ring + droq->refill_idx)->buffer_ptr = lio_map_ring(octeon_dev->pci_dev,(droq->recv_buf_list + droq->refill_idx)->buffer,droq->buffer_size);
  
#line 485 
  (droq->info_list + droq->refill_idx)->length = 0ULL;
  
#line 487 
  droq->refill_idx += 1U;
  
#line 487 
  ;
  
#line 487 
  if (droq->refill_idx == droq->max_count) 
#line 487 
                                           droq->refill_idx = 0U; else ;
  
#line 488 
  desc_refilled += 1U;
  
#line 489 
  droq->refill_count -= 1U;
  ldv_46707: 
#line 490 
  ;
  
#line 455 
  if (droq->refill_count != 0U && droq->max_count > desc_refilled) 
#line 457 
                                                                   goto ldv_46706; else 
                                                                    
#line 460 
                                                                    goto ldv_46705;
  ldv_46705: 
#line 461 
  ;
  
#line 492 
  if (droq->refill_count != 0U) {
    u32 tmp;
    
#line 493 
    tmp = octeon_droq_refill_pullup_descs(droq,desc_ring);
    
#line 494 
    desc_refilled = tmp + desc_refilled;
  }
  else ;
  
#line 501 
  return desc_refilled;
}


#line 505  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.c"
__inline static u32 octeon_droq_get_bufcount(u32 buf_size, u32 total_len)
{
  
#line 507 
  u32 buf_cnt = 0U;
  
#line 509 
  goto ldv_46714;
  ldv_46713: 
#line 510 
  ;
  
#line 510 
  buf_cnt += 1U;
  ldv_46714: 
#line 511 
  ;
  
#line 509 
  if (buf_size * buf_cnt < total_len) 
#line 511 
                                      goto ldv_46713; else 
#line 514 
                                                           goto ldv_46715;
  ldv_46715: 
#line 515 
  ;
  
#line 511 
  return buf_cnt;
}


#line 515  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.c"
static int octeon_droq_dispatch_pkt(struct octeon_device *oct, struct octeon_droq *droq, union octeon_rh *rh, struct octeon_droq_info *info)
{
  int __retres;
  u32 cnt;
  int (*disp_fn)(struct octeon_recv_info *, void *);
  struct octeon_recv_info *rinfo;
  
#line 524 
  cnt = octeon_droq_get_bufcount(droq->buffer_size,(unsigned int)info->length);
  
#line 526 
  disp_fn = octeon_get_dispatch(oct,(unsigned short)((int)rh->r.opcode),(unsigned short)((int)rh->r.subcode));
  
#line 528 
  if (disp_fn != (int (*)(struct octeon_recv_info *, void *))0) {
    
#line 529 
    rinfo = octeon_create_recv_info(oct,droq,cnt,droq->read_idx);
    
#line 530 
    if (rinfo != (struct octeon_recv_info *)0) {
      
#line 531 
      struct __dispatch *rdisp = (struct __dispatch *)rinfo->rsvd;
      
#line 533 
      rdisp->rinfo = rinfo;
      
#line 534 
      rdisp->disp_fn = disp_fn;
      
#line 535 
      (rinfo->recv_pkt)->rh = *rh;
      
#line 536 
      list_add_tail(& rdisp->list,& droq->dispatch_list);
    }
    else 
#line 539 
         droq->stats.dropped_nomem += 1ULL;
  }
  else {
    
#line 542 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"DROQ: No dispatch function\n");
    
#line 543 
    droq->stats.dropped_nodispatch += 1ULL;
  }
  
#line 546 
  __retres = (int)cnt;
  
#line 546 
  return __retres;
}


#line 549  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.c"
__inline static void octeon_droq_drop_packets(struct octeon_device *oct, struct octeon_droq *droq, u32 cnt)
{
  u32 buf_cnt;
  struct octeon_droq_info *info;
  
#line 553 
  u32 i = 0U;
  
#line 556 
  i = 0U;
  
#line 556 
  goto ldv_46735;
  ldv_46734: 
#line 557 
  ;
  
#line 557 
  info = droq->info_list + droq->read_idx;
  
#line 558 
  octeon_swap_8B_data((u64 *)info,2U);
  
#line 560 
  if (info->length != 0ULL) {
    
#line 561 
    info->length += 18446744073709551608ULL;
    
#line 562 
    droq->stats.bytes_received += info->length;
    
#line 563 
    buf_cnt = octeon_droq_get_bufcount(droq->buffer_size,(unsigned int)info->length);
  }
  else {
    
#line 566 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"DROQ: In drop: pkt with len 0\n");
    
#line 567 
    buf_cnt = 1U;
  }
  
#line 570 
  if (droq->read_idx + buf_cnt >= droq->max_count) 
#line 570 
                                                   droq->read_idx = (droq->read_idx + buf_cnt) - droq->max_count; else 
                                                                    
#line 570 
                                                                    droq->read_idx += buf_cnt;
  
#line 571 
  droq->refill_count += buf_cnt;
  
#line 556 
  i += 1U;
  ldv_46735: 
#line 557 
  ;
  
#line 556 
  if (i < cnt) 
#line 558 
               goto ldv_46734; else 
#line 561 
                                    goto ldv_46736;
  ldv_46736: 
#line 562 
  ;
  
#line 563 
  return;
}


#line 576  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.c"
static u32 octeon_droq_fast_process_packets(struct octeon_device *oct, struct octeon_droq *droq, u32 pkts_to_process)
{
  u32 __retres;
  struct octeon_droq_info *info;
  union octeon_rh *rh;
  u32 pkt;
  u32 pkt_count;
  
#line 582 
  u32 total_len = 0U;
  
#line 584 
  pkt_count = pkts_to_process;
  
#line 586 
  pkt = 0U;
  
#line 586 
  goto ldv_46759;
  ldv_46758: 
#line 587 
  ;
  {
    
#line 587 
    u32 pkt_len = 0U;
    
#line 588 
    struct sk_buff *nicbuf = (struct sk_buff *)0;
    
#line 590 
    info = droq->info_list + droq->read_idx;
    
#line 591 
    octeon_swap_8B_data((u64 *)info,2U);
    
#line 593 
    if (info->length == 0ULL) {
      
#line 594 
      dev_err((struct device const *)(& (oct->pci_dev)->dev),"DROQ[%d] idx: %d len:0, pkt_cnt: %d\n",droq->q_no,droq->read_idx,pkt_count);
      {
        
#line 597 
        struct _ddebug descriptor = {.modname = "liquidio", .function = "octeon_droq_fast_process_packets", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.c", .format = "", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))599U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 597 
        if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 597 
                                                            print_hex_dump("\001","",1,16,1,(void const *)info,16UL,(_Bool)1); else ;
      }
      
#line 600 
      goto ldv_46751;
    }
    else ;
    
#line 604 
    info->length += 18446744073709551608ULL;
    
#line 605 
    rh = & info->rh;
    
#line 607 
    total_len = (unsigned int)info->length + total_len;
    
#line 609 
    if (((((int)rh->r.opcode << 8) & 3840) | ((int)rh->r.subcode & 127)) != 258) {
      u32 buf_cnt;
      int tmp;
      
#line 612 
      tmp = octeon_droq_dispatch_pkt(oct,droq,rh,info);
      
#line 612 
      buf_cnt = (unsigned int)tmp;
      
#line 613 
      if (droq->read_idx + buf_cnt >= droq->max_count) 
#line 613 
                                                       droq->read_idx = (droq->read_idx + buf_cnt) - droq->max_count; else 
                                                                    
#line 613 
                                                                    droq->read_idx += buf_cnt;
      
#line 614 
      droq->refill_count += buf_cnt;
    }
    else {
      
#line 616 
      if (info->length <= (unsigned long long)droq->buffer_size) {
        
#line 617 
        lio_unmap_ring_info(oct->pci_dev,(droq->desc_ring + droq->read_idx)->buffer_ptr,droq->buffer_size);
        
#line 621 
        pkt_len = (unsigned int)info->length;
        
#line 622 
        nicbuf = (struct sk_buff *)(droq->recv_buf_list + droq->read_idx)->buffer;
        
#line 624 
        (droq->recv_buf_list + droq->read_idx)->buffer = (void *)0;
        
#line 626 
        droq->read_idx += 1U;
        
#line 626 
        ;
        
#line 626 
        if (droq->read_idx == droq->max_count) 
#line 626 
                                               droq->read_idx = 0U; else ;
        
#line 627 
        skb_put(nicbuf,pkt_len);
        
#line 628 
        droq->refill_count += 1U;
      }
      else {
        
#line 630 
        nicbuf = (struct sk_buff *)octeon_fast_packet_alloc(oct,droq,droq->q_no,(unsigned int)info->length);
        
#line 634 
        pkt_len = 0U;
        
#line 638 
        goto ldv_46755;
        ldv_46754: 
#line 639 
        ;
        {
          int cpy_len;
          unsigned int tmp_1;
          
#line 641 
          if ((unsigned long long)(droq->buffer_size + pkt_len) > info->length) 
            
#line 641 
            tmp_1 = (unsigned int)info->length - pkt_len; else 
#line 641 
                                                               tmp_1 = droq->buffer_size;
          
#line 641 
          cpy_len = (int)tmp_1;
          
#line 647 
          if (nicbuf != (struct sk_buff *)0) {
            
#line 648 
            lio_unmap_ring_info(oct->pci_dev,(droq->desc_ring + droq->read_idx)->buffer_ptr,droq->buffer_size);
            
#line 655 
            octeon_fast_packet_next(droq,nicbuf,cpy_len,(int)droq->read_idx);
          }
          else ;
          
#line 663 
          pkt_len += (unsigned int)cpy_len;
          
#line 664 
          droq->read_idx += 1U;
          
#line 664 
          ;
          
#line 664 
          if (droq->read_idx == droq->max_count) 
#line 664 
                                                 droq->read_idx = 0U; else ;
          
#line 666 
          droq->refill_count += 1U;
        }
        ldv_46755: 
#line 668 
        ;
        
#line 638 
        if ((unsigned long long)pkt_len < info->length) 
#line 640 
                                                        goto ldv_46754; else 
                                                                    
#line 643 
                                                                    goto ldv_46756;
        ldv_46756: 
#line 644 
        ;
      }
      
#line 670 
      if (nicbuf != (struct sk_buff *)0) 
        
#line 671 
        if (droq->ops.fptr != (void (*)(u32 , void *, u32 , union octeon_rh *, void *))0) 
          
#line 672 
          (*(droq->ops.fptr))(oct->octeon_id,(void *)nicbuf,pkt_len,rh,(void *)(& droq->napi)); else 
                                                                    
#line 676 
                                                                    recv_buffer_free((void *)nicbuf);
      else ;
    }
    
#line 680 
    if (droq->refill_count >= droq->refill_threshold) {
      u32 tmp_2;
      
#line 681 
      tmp_2 = octeon_droq_refill(oct,droq);
      
#line 681 
      int desc_refilled = (int)tmp_2;
      
#line 682 
      ldv_inline_asm();
      
#line 688 
      writel((unsigned int)desc_refilled,(void volatile *)droq->pkts_credit_reg);
      
#line 689 
      ldv_inline_asm();
    }
    else ;
  }
  
#line 586 
  pkt += 1U;
  ldv_46759: 
#line 587 
  ;
  
#line 586 
  if (pkt < pkt_count) 
#line 588 
                       goto ldv_46758; else 
#line 591 
                                            goto ldv_46751;
  ldv_46751: 
#line 592 
  ;
  
#line 696 
  droq->stats.pkts_received += (unsigned long long)pkt;
  
#line 697 
  droq->stats.bytes_received += (unsigned long long)total_len;
  
#line 699 
  if (droq->ops.drop_on_max != 0U && pkts_to_process != pkt) {
    
#line 700 
    octeon_droq_drop_packets(oct,droq,pkts_to_process - pkt);
    
#line 702 
    droq->stats.dropped_toomany += (unsigned long long)(pkts_to_process - pkt);
    
#line 703 
    __retres = pkts_to_process;
    
#line 703 
    goto return_label;
  }
  else ;
  
#line 706 
  __retres = pkt;
  return_label: 
#line 706 
                return __retres;
}


#line 710  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.c"
int octeon_droq_process_packets(struct octeon_device *oct, struct octeon_droq *droq, u32 budget)
{
  int __retres;
  struct list_head *tmp;
  struct list_head *tmp2;
  int tmp_0;
  int tmp_2;
  
#line 714 
  u32 pkt_count = 0U;
  
#line 714 
  u32 pkts_processed = 0U;
  
#line 717 
  tmp_0 = atomic_read((atomic_t const *)(& droq->pkts_pending));
  
#line 717 
  pkt_count = (unsigned int)tmp_0;
  
#line 718 
  if (pkt_count == 0U) {
    
#line 719 
    __retres = 0;
    
#line 719 
    goto return_label;
  }
  else ;
  
#line 721 
  if (pkt_count > budget) 
#line 722 
                          pkt_count = budget; else ;
  
#line 725 
  ldv_spin_lock_76(& droq->lock);
  
#line 727 
  pkts_processed = octeon_droq_fast_process_packets(oct,droq,pkt_count);
  
#line 729 
  atomic_sub((int)pkts_processed,& droq->pkts_pending);
  
#line 732 
  ldv_spin_unlock_77(& droq->lock);
  
#line 734 
  tmp = droq->dispatch_list.next;
  
#line 734 
  tmp2 = tmp->next;
  
#line 734 
  goto ldv_46771;
  ldv_46770: 
#line 735 
  ;
  {
    void *tmp_1;
    
#line 735 
    struct __dispatch *rdisp = (struct __dispatch *)tmp;
    
#line 737 
    list_del(tmp);
    
#line 738 
    tmp_1 = octeon_get_dispatch_arg(oct,(unsigned short)((int)((rdisp->rinfo)->recv_pkt)->rh.r.opcode),(unsigned short)((int)((rdisp->rinfo)->recv_pkt)->rh.r.subcode));
    
#line 738 
    ;
    
#line 738 
    (*(rdisp->disp_fn))(rdisp->rinfo,tmp_1);
  }
  
#line 734 
  tmp = tmp2;
  
#line 734 
  tmp2 = tmp->next;
  ldv_46771: 
#line 735 
  ;
  
#line 734 
  if (& droq->dispatch_list != tmp) 
#line 736 
                                    goto ldv_46770; else 
#line 739 
                                                         goto ldv_46772;
  ldv_46772: 
#line 740 
  ;
  
#line 746 
  tmp_2 = atomic_read((atomic_t const *)(& droq->pkts_pending));
  
#line 746 
  if (tmp_2 != 0) {
    
#line 747 
    __retres = 1;
    
#line 747 
    goto return_label;
  }
  else ;
  
#line 749 
  __retres = 0;
  return_label: 
#line 749 
                return __retres;
}


#line 758  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.c"
static int octeon_droq_process_poll_pkts(struct octeon_device *oct, struct octeon_droq *droq, u32 budget)
{
  int __retres;
  struct list_head *tmp;
  struct list_head *tmp2;
  int tmp_0;
  
#line 762 
  u32 pkts_available = 0U;
  
#line 762 
  u32 pkts_processed = 0U;
  
#line 763 
  u32 total_pkts_processed = 0U;
  
#line 765 
  if (droq->max_count < budget) 
#line 766 
                                budget = droq->max_count; else ;
  
#line 768 
  ldv_spin_lock_78(& droq->lock);
  
#line 770 
  goto ldv_46785;
  ldv_46784: 
#line 771 
  ;
  
#line 772 
  tmp_0 = atomic_read((atomic_t const *)(& droq->pkts_pending));
  
#line 771 
  ;
  
#line 771 
  if (budget - total_pkts_processed < (unsigned int)tmp_0) 
#line 771 
                                                           pkts_available = budget - total_pkts_processed;
  else {
    int tmp_1;
    
#line 772 
    tmp_1 = atomic_read((atomic_t const *)(& droq->pkts_pending));
    
#line 771 
    pkts_available = (unsigned int)tmp_1;
  }
  
#line 775 
  if (pkts_available == 0U) 
#line 776 
                            goto ldv_46783; else ;
  
#line 778 
  pkts_processed = octeon_droq_fast_process_packets(oct,droq,pkts_available);
  
#line 782 
  atomic_sub((int)pkts_processed,& droq->pkts_pending);
  
#line 784 
  total_pkts_processed += pkts_processed;
  
#line 786 
  octeon_droq_check_hw_for_pkts(oct,droq);
  ldv_46785: 
#line 787 
  ;
  
#line 770 
  if (total_pkts_processed < budget) 
#line 772 
                                     goto ldv_46784; else 
#line 775 
                                                          goto ldv_46783;
  ldv_46783: 
#line 776 
  ;
  
#line 789 
  ldv_spin_unlock_79(& droq->lock);
  
#line 791 
  tmp = droq->dispatch_list.next;
  
#line 791 
  tmp2 = tmp->next;
  
#line 791 
  goto ldv_46788;
  ldv_46787: 
#line 792 
  ;
  {
    void *tmp_2;
    
#line 792 
    struct __dispatch *rdisp = (struct __dispatch *)tmp;
    
#line 794 
    list_del(tmp);
    
#line 795 
    tmp_2 = octeon_get_dispatch_arg(oct,(unsigned short)((int)((rdisp->rinfo)->recv_pkt)->rh.r.opcode),(unsigned short)((int)((rdisp->rinfo)->recv_pkt)->rh.r.subcode));
    
#line 795 
    ;
    
#line 795 
    (*(rdisp->disp_fn))(rdisp->rinfo,tmp_2);
  }
  
#line 791 
  tmp = tmp2;
  
#line 791 
  tmp2 = tmp->next;
  ldv_46788: 
#line 792 
  ;
  
#line 791 
  if (& droq->dispatch_list != tmp) 
#line 793 
                                    goto ldv_46787; else 
#line 796 
                                                         goto ldv_46789;
  ldv_46789: 
#line 797 
  ;
  
#line 802 
  __retres = (int)total_pkts_processed;
  
#line 802 
  return __retres;
}


#line 806  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.c"
int octeon_process_droq_poll_cmd(struct octeon_device *oct, u32 q_no, int cmd, u32 arg)
{
  int __retres;
  struct octeon_droq *droq;
  
#line 810 
  struct octeon_config *oct_cfg = (struct octeon_config *)0;
  
#line 812 
  oct_cfg = octeon_get_conf(oct);
  
#line 814 
  if (oct_cfg == (struct octeon_config *)0) {
    
#line 815 
    __retres = -22;
    
#line 815 
    goto return_label;
  }
  else ;
  
#line 817 
  if ((unsigned int)oct_cfg->oq.max_oqs <= q_no) {
    
#line 818 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"%s: droq id (%d) exceeds MAX (%d)\n","octeon_process_droq_poll_cmd",q_no,oct->num_oqs + 4294967295U);
    
#line 820 
    __retres = -22;
    
#line 820 
    goto return_label;
  }
  else ;
  
#line 823 
  droq = oct->droq[q_no];
  
#line 825 
  if (cmd == 2) {
    int tmp;
    
#line 826 
    tmp = octeon_droq_process_poll_pkts(oct,droq,arg);
    
#line 826 
    __retres = tmp;
    
#line 826 
    goto return_label;
  }
  else ;
  
#line 828 
  if (cmd == 3) {
    int tmp_0;
    int tmp_1;
    
#line 829 
    tmp_0 = atomic_read((atomic_t const *)(& droq->pkts_pending));
    
#line 829 
    u32 pkt_cnt = (unsigned int)tmp_0;
    
#line 831 
    tmp_1 = octeon_droq_process_packets(oct,droq,pkt_cnt);
    
#line 831 
    __retres = tmp_1;
    
#line 831 
    goto return_label;
  }
  else ;
  
#line 834 
  if (cmd == 4) {
    u32 value;
    unsigned long flags;
    
#line 839 
    switch ((int)oct->chip_id) {
      case 146: 
#line 840 
      ;
      case 145: 
#line 841 
      ;
      {
        
#line 842 
        struct octeon_cn6xxx *cn6xxx = (struct octeon_cn6xxx *)oct->chip;
        
#line 844 
        ldv___ldv_spin_lock_80(& cn6xxx->lock_for_droq_int_enb_reg);
        
#line 846 
        value = readl((void const volatile *)(oct->mmio[0].hw_addr + 4448U));
        
#line 849 
        value = (unsigned int)(1 << q_no) | value;
        
#line 850 
        writel(value,(void volatile *)(oct->mmio[0].hw_addr + 4448U));
        
#line 853 
        value = readl((void const volatile *)(oct->mmio[0].hw_addr + 4432U));
        
#line 856 
        value = (unsigned int)(1 << q_no) | value;
        
#line 857 
        writel(value,(void volatile *)(oct->mmio[0].hw_addr + 4432U));
        
#line 863 
        ldv_spin_unlock_irqrestore_81(& cn6xxx->lock_for_droq_int_enb_reg,flags);
        
#line 865 
        __retres = 0;
        
#line 865 
        goto return_label;
      }
    }
    
#line 870 
    __retres = 0;
    
#line 870 
    goto return_label;
  }
  else ;
  
#line 873 
  dev_err((struct device const *)(& (oct->pci_dev)->dev),"%s Unknown command: %d\n","octeon_process_droq_poll_cmd",cmd);
  
#line 874 
  __retres = -22;
  return_label: 
#line 874 
                return __retres;
}


#line 877  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.c"
int octeon_register_droq_ops(struct octeon_device *oct, u32 q_no, struct octeon_droq_ops *ops)
{
  int __retres;
  struct octeon_droq *droq;
  unsigned long flags;
  
#line 882 
  struct octeon_config *oct_cfg = (struct octeon_config *)0;
  
#line 884 
  oct_cfg = octeon_get_conf(oct);
  
#line 886 
  if (oct_cfg == (struct octeon_config *)0) {
    
#line 887 
    __retres = -22;
    
#line 887 
    goto return_label;
  }
  else ;
  
#line 889 
  if (ops == (struct octeon_droq_ops *)0) {
    
#line 890 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"%s: droq_ops pointer is NULL\n","octeon_register_droq_ops");
    
#line 892 
    __retres = -22;
    
#line 892 
    goto return_label;
  }
  else ;
  
#line 895 
  if ((unsigned int)oct_cfg->oq.max_oqs <= q_no) {
    
#line 896 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"%s: droq id (%d) exceeds MAX (%d)\n","octeon_register_droq_ops",q_no,oct->num_oqs + 4294967295U);
    
#line 898 
    __retres = -22;
    
#line 898 
    goto return_label;
  }
  else ;
  
#line 901 
  droq = oct->droq[q_no];
  
#line 903 
  ldv___ldv_spin_lock_82(& droq->lock);
  
#line 905 
  memcpy((void *)(& droq->ops),(void const *)ops,24UL);
  
#line 907 
  ldv_spin_unlock_irqrestore_83(& droq->lock,flags);
  
#line 909 
  __retres = 0;
  return_label: 
#line 909 
                return __retres;
}


#line 912  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.c"
int octeon_unregister_droq_ops(struct octeon_device *oct, u32 q_no)
{
  int __retres;
  unsigned long flags;
  struct octeon_droq *droq;
  
#line 916 
  struct octeon_config *oct_cfg = (struct octeon_config *)0;
  
#line 918 
  oct_cfg = octeon_get_conf(oct);
  
#line 920 
  if (oct_cfg == (struct octeon_config *)0) {
    
#line 921 
    __retres = -22;
    
#line 921 
    goto return_label;
  }
  else ;
  
#line 923 
  if ((unsigned int)oct_cfg->oq.max_oqs <= q_no) {
    
#line 924 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"%s: droq id (%d) exceeds MAX (%d)\n","octeon_unregister_droq_ops",q_no,oct->num_oqs + 4294967295U);
    
#line 926 
    __retres = -22;
    
#line 926 
    goto return_label;
  }
  else ;
  
#line 929 
  droq = oct->droq[q_no];
  
#line 931 
  if (droq == (struct octeon_droq *)0) {
    
#line 932 
    _dev_info((struct device const *)(& (oct->pci_dev)->dev),"Droq id (%d) not available.\n",q_no);
    
#line 934 
    __retres = 0;
    
#line 934 
    goto return_label;
  }
  else ;
  
#line 937 
  ldv___ldv_spin_lock_84(& droq->lock);
  
#line 939 
  droq->ops.fptr = (void (*)(u32 , void *, u32 , union octeon_rh *, void *))0;
  
#line 940 
  droq->ops.drop_on_max = 0U;
  
#line 942 
  ldv_spin_unlock_irqrestore_85(& droq->lock,flags);
  
#line 944 
  __retres = 0;
  return_label: 
#line 944 
                return __retres;
}


#line 947  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.c"
int octeon_create_droq(struct octeon_device *oct, u32 q_no, u32 num_descs, u32 desc_size, void *app_ctx)
{
  int __retres;
  struct octeon_droq *droq;
  
#line 953 
  if (oct->droq[q_no] != (struct octeon_droq *)0) {
    {
      
#line 954 
      struct _ddebug descriptor = {.modname = "liquidio", .function = "octeon_create_droq", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.c", .format = "Droq already in use. Cannot create droq %d again\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))955U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 954 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 954 
                                                          __dynamic_dev_dbg(& descriptor,(struct device const *)(& (oct->pci_dev)->dev),"Droq already in use. Cannot create droq %d again\n",q_no); else ;
    }
    
#line 956 
    __retres = 1;
    
#line 956 
    goto return_label;
  }
  else ;
  
#line 960 
  droq = (struct octeon_droq *)vmalloc(640UL);
  
#line 961 
  if (droq == (struct octeon_droq *)0) 
#line 962 
                                       goto create_droq_fail; else ;
  
#line 963 
  memset((void *)droq,0,640UL);
  
#line 966 
  octeon_set_droq_pkt_op(oct,q_no,0U);
  
#line 967 
  oct->droq[q_no] = droq;
  
#line 970 
  octeon_init_droq(oct,q_no,num_descs,desc_size,app_ctx);
  
#line 972 
  oct->num_oqs += 1U;
  {
    
#line 974 
    struct _ddebug descriptor_0 = {.modname = "liquidio", .function = "octeon_create_droq", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.c", .format = "%s: Total number of OQ: %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))975U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 974 
    if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 974 
                                                          __dynamic_dev_dbg(& descriptor_0,(struct device const *)(& (oct->pci_dev)->dev),"%s: Total number of OQ: %d\n","octeon_create_droq",oct->num_oqs); else ;
  }
  
#line 982 
  __retres = 0;
  
#line 982 
  goto return_label;
  create_droq_fail: 
#line 984 
  ;
  
#line 985 
  octeon_delete_droq(oct,q_no);
  
#line 986 
  __retres = -1;
  return_label: 
#line 986 
                return __retres;
}


#line 101  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_droq.c.aux"
static void atomic_add(int i, atomic_t *v)
{
  
#line 104 
  ldv_atomic_add(i,v);
  
#line 105 
  return;
}


#line 108  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_droq.c.aux"
static void atomic_sub(int i, atomic_t *v)
{
  
#line 111 
  ldv_atomic_sub(i,v);
  
#line 112 
  return;
}


#line 480  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_droq.c.aux"
static void *kmalloc(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 483 
  tmp = ldv_kmalloc(size,flags);
  
#line 483 
  return tmp;
}


#line 747  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_droq.c.aux"
static void ldv_spin_lock_bh_73(spinlock_t *lock)
{
  
#line 751 
  ldv_spin_model_lock((char *)"lock_of_octeon_dispatch_list");
  
#line 753 
  spin_lock_bh(lock);
  
#line 754 
  return;
}


#line 757  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_droq.c.aux"
static void ldv_spin_unlock_bh_74(spinlock_t *lock)
{
  
#line 761 
  ldv_spin_model_unlock((char *)"lock_of_octeon_dispatch_list");
  
#line 763 
  spin_unlock_bh(lock);
  
#line 764 
  return;
}


#line 767  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_droq.c.aux"
static void ldv_spin_unlock_bh_75(spinlock_t *lock)
{
  
#line 771 
  ldv_spin_model_unlock((char *)"lock_of_octeon_dispatch_list");
  
#line 773 
  spin_unlock_bh(lock);
  
#line 774 
  return;
}


#line 777  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_droq.c.aux"
static void ldv_spin_lock_76(spinlock_t *lock)
{
  
#line 781 
  ldv_spin_model_lock((char *)"lock_of_octeon_droq");
  
#line 783 
  spin_lock(lock);
  
#line 784 
  return;
}


#line 787  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_droq.c.aux"
static void ldv_spin_unlock_77(spinlock_t *lock)
{
  
#line 791 
  ldv_spin_model_unlock((char *)"lock_of_octeon_droq");
  
#line 793 
  spin_unlock(lock);
  
#line 794 
  return;
}


#line 797  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_droq.c.aux"
static void ldv_spin_lock_78(spinlock_t *lock)
{
  
#line 801 
  ldv_spin_model_lock((char *)"lock_of_octeon_droq");
  
#line 803 
  spin_lock(lock);
  
#line 804 
  return;
}


#line 807  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_droq.c.aux"
static void ldv_spin_unlock_79(spinlock_t *lock)
{
  
#line 811 
  ldv_spin_model_unlock((char *)"lock_of_octeon_droq");
  
#line 813 
  spin_unlock(lock);
  
#line 814 
  return;
}


#line 817  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_droq.c.aux"
static void ldv___ldv_spin_lock_80(spinlock_t *ldv_func_arg1)
{
  
#line 821 
  ldv_spin_model_lock((char *)"lock_for_droq_int_enb_reg_of_octeon_cn6xxx");
  
#line 823 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 824 
  return;
}


#line 827  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_droq.c.aux"
static void ldv_spin_unlock_irqrestore_81(spinlock_t *lock, unsigned long flags)
{
  
#line 831 
  ldv_spin_model_unlock((char *)"lock_for_droq_int_enb_reg_of_octeon_cn6xxx");
  
#line 833 
  spin_unlock_irqrestore(lock,flags);
  
#line 834 
  return;
}


#line 837  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_droq.c.aux"
static void ldv___ldv_spin_lock_82(spinlock_t *ldv_func_arg1)
{
  
#line 841 
  ldv_spin_model_lock((char *)"lock_of_octeon_droq");
  
#line 843 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 844 
  return;
}


#line 847  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_droq.c.aux"
static void ldv_spin_unlock_irqrestore_83(spinlock_t *lock, unsigned long flags)
{
  
#line 851 
  ldv_spin_model_unlock((char *)"lock_of_octeon_droq");
  
#line 853 
  spin_unlock_irqrestore(lock,flags);
  
#line 854 
  return;
}


#line 857  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_droq.c.aux"
static void ldv___ldv_spin_lock_84(spinlock_t *ldv_func_arg1)
{
  
#line 861 
  ldv_spin_model_lock((char *)"lock_of_octeon_droq");
  
#line 863 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 864 
  return;
}


#line 867  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_droq.c.aux"
static void ldv_spin_unlock_irqrestore_85(spinlock_t *lock, unsigned long flags)
{
  
#line 871 
  ldv_spin_model_unlock((char *)"lock_of_octeon_droq");
  
#line 873 
  spin_unlock_irqrestore(lock,flags);
  
#line 874 
  return;
}


#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static unsigned long readq(void const volatile *addr)
{
  unsigned long ret;
  
#line 91 
  ldv_inline_asm();
  
#line 90 
  return ret;
}


#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static void writeq(unsigned long val, void volatile *addr)
{
  
#line 93 
  ldv_inline_asm();
  
#line 94 
  return;
}


#line 181 
void *ioremap_nocache(resource_size_t, unsigned long);


#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static void *ioremap(resource_size_t offset, unsigned long size)
{
  void *tmp;
  
#line 192 
  tmp = ioremap_nocache(offset,size);
  
#line 192 
  return tmp;
}


#line 195 
void iounmap(void volatile *);


#line 863  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
int pci_bus_read_config_dword(struct pci_bus *, unsigned int, int, u32 *);


#line 869 
int pci_bus_write_config_dword(struct pci_bus *, unsigned int, int, u32);


#line 891  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_read_config_dword(struct pci_dev const *dev, int where, u32 *val)
{
  int tmp;
  
#line 894 
  tmp = pci_bus_read_config_dword(dev->bus,dev->devfn,where,val);
  
#line 894 
  return tmp;
}


#line 904  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_write_config_dword(struct pci_dev const *dev, int where, u32 val)
{
  int tmp;
  
#line 907 
  tmp = pci_bus_write_config_dword(dev->bus,dev->devfn,where,val);
  
#line 907 
  return tmp;
}


#line 1097 
int pci_request_region(struct pci_dev *, int, char const *);


#line 1099 
void pci_release_region(struct pci_dev *, int);


#line 492  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.h"
u64 lio_pci_readq(struct octeon_device *oct, u64 addr);


#line 504 
void lio_pci_writeq(struct octeon_device *oct, u64 val, u64 addr);


#line 642 
void *oct_get_config_info(struct octeon_device *oct, u16 card_type);


#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_main.h"
__inline static void octeon_unmap_pci_barx(struct octeon_device *oct, int baridx)
{
  {
    
#line 73 
    struct _ddebug descriptor = {.modname = "liquidio", .function = "octeon_unmap_pci_barx", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_main.h", .format = "Freeing PCI mapped regions for Bar%d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))74U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 73 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 73 
                                                        __dynamic_dev_dbg(& descriptor,(struct device const *)(& (oct->pci_dev)->dev),"Freeing PCI mapped regions for Bar%d\n",baridx); else ;
  }
  
#line 76 
  if (oct->mmio[baridx].done != 0U) 
#line 77 
                                    iounmap((void volatile *)oct->mmio[baridx].hw_addr); else ;
  
#line 79 
  if (oct->mmio[baridx].start != 0ULL) 
#line 80 
                                       pci_release_region(oct->pci_dev,baridx * 2); else ;
  
#line 81 
  return;
}


#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_main.h"
__inline static int octeon_map_pci_barx(struct octeon_device *oct, int baridx, int max_map_len)
{
  int __retres;
  int tmp;
  
#line 92 
  u32 mapped_len = 0U;
  
#line 94 
  tmp = pci_request_region(oct->pci_dev,baridx * 2,"LiquidIO");
  
#line 94 
  if (tmp != 0) {
    
#line 95 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"pci_request_region failed for bar %d\n",baridx);
    
#line 97 
    __retres = 1;
    
#line 97 
    goto return_label;
  }
  else ;
  
#line 100 
  oct->mmio[baridx].start = (oct->pci_dev)->resource[baridx * 2].start;
  
#line 101 
  if ((oct->pci_dev)->resource[baridx * 2].start != 0ULL || (oct->pci_dev)->resource[baridx * 2].end != (oct->pci_dev)->resource[baridx * 2].start) 
    
#line 101 
    oct->mmio[baridx].len = ((unsigned int)(oct->pci_dev)->resource[baridx * 2].end - (unsigned int)(oct->pci_dev)->resource[baridx * 2].start) + 1U; else 
                                                                    
#line 101 
                                                                    oct->mmio[baridx].len = 0U;
  
#line 103 
  mapped_len = oct->mmio[baridx].len;
  
#line 104 
  if (mapped_len == 0U) {
    
#line 105 
    __retres = 1;
    
#line 105 
    goto return_label;
  }
  else ;
  
#line 107 
  if (max_map_len != 0 && mapped_len > (unsigned int)max_map_len) 
#line 108 
                                                                  mapped_len = (unsigned int)max_map_len; else ;
  
#line 111 
  oct->mmio[baridx].hw_addr = (u8 *)ioremap(oct->mmio[baridx].start,(unsigned long)mapped_len);
  
#line 112 
  oct->mmio[baridx].mapped_len = mapped_len;
  {
    
#line 114 
    struct _ddebug descriptor = {.modname = "liquidio", .function = "octeon_map_pci_barx", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_main.h", .format = "BAR%d start: 0x%llx mapped %u of %u bytes\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))116U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 114 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 114 
                                                        __dynamic_dev_dbg(& descriptor,(struct device const *)(& (oct->pci_dev)->dev),"BAR%d start: 0x%llx mapped %u of %u bytes\n",baridx,oct->mmio[baridx].start,mapped_len,oct->mmio[baridx].len); else ;
  }
  
#line 118 
  if (oct->mmio[baridx].hw_addr == (u8 *)0U) {
    
#line 119 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"error ioremap for bar %d\n",baridx);
    
#line 121 
    __retres = 1;
    
#line 121 
    goto return_label;
  }
  else ;
  
#line 123 
  oct->mmio[baridx].done = 1U;
  
#line 125 
  __retres = 0;
  return_label: 
#line 125 
                return __retres;
}


#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.h"
int lio_cn6xxx_soft_reset(struct octeon_device *oct);


#line 74 
void lio_cn6xxx_enable_error_reporting(struct octeon_device *oct);


#line 75 
void lio_cn6xxx_setup_pcie_mps(struct octeon_device *oct, enum octeon_pcie_mps mps);


#line 77 
void lio_cn6xxx_setup_pcie_mrrs(struct octeon_device *oct, enum octeon_pcie_mrrs mrrs);


#line 79 
void lio_cn6xxx_setup_global_input_regs(struct octeon_device *oct);


#line 80 
void lio_cn6xxx_setup_global_output_regs(struct octeon_device *oct);


#line 81 
void lio_cn6xxx_setup_iq_regs(struct octeon_device *oct, u32 iq_no);


#line 82 
void lio_cn6xxx_setup_oq_regs(struct octeon_device *oct, u32 oq_no);


#line 83 
void lio_cn6xxx_enable_io_queues(struct octeon_device *oct);


#line 84 
void lio_cn6xxx_disable_io_queues(struct octeon_device *oct);


#line 87 
irqreturn_t lio_cn6xxx_process_interrupt_regs(void *dev);


#line 88 
void lio_cn6xxx_reinit_regs(struct octeon_device *oct);


#line 89 
void lio_cn6xxx_bar1_idx_setup(struct octeon_device *oct, u64 core_addr, u32 idx, int valid);


#line 91 
void lio_cn6xxx_bar1_idx_write(struct octeon_device *oct, u32 idx, u32 mask);


#line 92 
u32 lio_cn6xxx_bar1_idx_read(struct octeon_device *oct, u32 idx);


#line 94 
u32 lio_cn6xxx_update_read_index(struct octeon_device *oct, struct octeon_instr_queue *iq);


#line 96 
void lio_cn6xxx_enable_interrupt(void *chip);


#line 97 
void lio_cn6xxx_disable_interrupt(void *chip);


#line 99 
void lio_cn6xxx_setup_reg_address(struct octeon_device *oct, void *chip, struct octeon_reg_list *reg_list);


#line 101 
u32 lio_cn6xxx_coprocessor_clock(struct octeon_device *oct);


#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn68xx_device.h"
int lio_setup_cn68xx_octeon_device(struct octeon_device *oct);


#line 31 
int lio_is_210nv(struct octeon_device *oct);


#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn68xx_device.c"
static void lio_cn68xx_set_dpi_regs(struct octeon_device *oct)
{
  u32 i;
  
#line 48 
  u32 fifo_sizes[6U] = {3U, 3U, 1U, 1U, 1U, 8U};
  
#line 50 
  lio_pci_writeq(oct,504403158265544704ULL,526666069704776ULL);
  {
    
#line 51 
    struct _ddebug descriptor = {.modname = "liquidio", .function = "lio_cn68xx_set_dpi_regs", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn68xx_device.c", .format = "DPI_DMA_CONTROL: 0x%016llx\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))52U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 51 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      u64 tmp;
      
#line 51 
      tmp = lio_pci_readq(oct,526666069704776ULL);
      
#line 51 
      ;
      
#line 51 
      __dynamic_dev_dbg(& descriptor,(struct device const *)(& (oct->pci_dev)->dev),"DPI_DMA_CONTROL: 0x%016llx\n",tmp);
    }
    else ;
  }
  
#line 54 
  i = 0U;
  
#line 54 
  goto ldv_46377;
  ldv_46376: 
#line 55 
  ;
  
#line 59 
  lio_pci_writeq(oct,0ULL,(unsigned long long)(i * 8U) + 526666069704832ULL);
  
#line 60 
  lio_pci_writeq(oct,(unsigned long long)fifo_sizes[i],(unsigned long long)(i * 8U) + 526666069706880ULL);
  {
    
#line 61 
    struct _ddebug descriptor_0 = {.modname = "liquidio", .function = "lio_cn68xx_set_dpi_regs", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn68xx_device.c", .format = "DPI_ENG_BUF%d: 0x%016llx\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))62U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 61 
    if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) {
      u64 tmp_0;
      
#line 61 
      tmp_0 = lio_pci_readq(oct,(unsigned long long)(i * 8U) + 526666069706880ULL);
      
#line 61 
      ;
      
#line 61 
      ;
      
#line 61 
      __dynamic_dev_dbg(& descriptor_0,(struct device const *)(& (oct->pci_dev)->dev),"DPI_ENG_BUF%d: 0x%016llx\n",i,tmp_0);
    }
    else ;
  }
  
#line 54 
  i += 1U;
  ldv_46377: 
#line 55 
  ;
  
#line 54 
  if (i <= 5U) 
#line 56 
               goto ldv_46376; else 
#line 59 
                                    goto ldv_46378;
  ldv_46378: 
#line 60 
  ;
  
#line 69 
  lio_pci_writeq(oct,1ULL,526666069704768ULL);
  {
    
#line 70 
    struct _ddebug descriptor_1 = {.modname = "liquidio", .function = "lio_cn68xx_set_dpi_regs", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn68xx_device.c", .format = "DPI_CTL: 0x%016llx\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))71U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 70 
    if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) {
      u64 tmp_1;
      
#line 70 
      tmp_1 = lio_pci_readq(oct,526666069704768ULL);
      
#line 70 
      ;
      
#line 70 
      __dynamic_dev_dbg(& descriptor_1,(struct device const *)(& (oct->pci_dev)->dev),"DPI_CTL: 0x%016llx\n",tmp_1);
    }
    else ;
  }
  
#line 72 
  return;
}


#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn68xx_device.c"
static int lio_cn68xx_soft_reset(struct octeon_device *oct)
{
  int __retres;
  
#line 76 
  lio_cn6xxx_soft_reset(oct);
  
#line 77 
  lio_cn68xx_set_dpi_regs(oct);
  
#line 79 
  __retres = 0;
  
#line 79 
  return __retres;
}


#line 82  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn68xx_device.c"
static void lio_cn68xx_setup_pkt_ctl_regs(struct octeon_device *oct)
{
  u64 pktctl;
  u64 tx_pipe;
  u64 max_oqs;
  
#line 84 
  struct octeon_cn6xxx *cn68xx = (struct octeon_cn6xxx *)oct->chip;
  
#line 87 
  pktctl = (u64)readq((void const volatile *)(oct->mmio[0].hw_addr + 4640U));
  
#line 90 
  max_oqs = (unsigned long long)(((struct octeon_cn6xxx *)oct->chip)->conf)->oq.max_oqs;
  
#line 91 
  tx_pipe = (u64)readq((void const volatile *)(oct->mmio[0].hw_addr + 4656U));
  
#line 92 
  tx_pipe &= 18446744073692839935ULL;
  
#line 93 
  tx_pipe = (max_oqs << 16) | tx_pipe;
  
#line 94 
  writeq((unsigned long)tx_pipe,(void volatile *)(oct->mmio[0].hw_addr + 4656U));
  
#line 96 
  if ((unsigned int)*((unsigned char *)(& (cn68xx->conf)->misc) + 0UL) != 0U) 
    
#line 97 
    pktctl |= 15ULL; else 
#line 100 
                          pktctl &= 18446744073709551600ULL;
  
#line 101 
  writeq((unsigned long)pktctl,(void volatile *)(oct->mmio[0].hw_addr + 4640U));
  
#line 102 
  return;
}


#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn68xx_device.c"
static int lio_cn68xx_setup_device_regs(struct octeon_device *oct)
{
  int __retres;
  
#line 106 
  lio_cn6xxx_setup_pcie_mps(oct,(enum octeon_pcie_mps)PCIE_MPS_DEFAULT);
  
#line 107 
  lio_cn6xxx_setup_pcie_mrrs(oct,(enum octeon_pcie_mrrs)PCIE_MRRS_256B);
  
#line 108 
  lio_cn6xxx_enable_error_reporting(oct);
  
#line 110 
  lio_cn6xxx_setup_global_input_regs(oct);
  
#line 111 
  lio_cn68xx_setup_pkt_ctl_regs(oct);
  
#line 112 
  lio_cn6xxx_setup_global_output_regs(oct);
  
#line 117 
  writeq(2097152UL,(void volatile *)(oct->mmio[0].hw_addr + 736U));
  
#line 119 
  __retres = 0;
  
#line 119 
  return __retres;
}


#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn68xx_device.c"
__inline static void lio_cn68xx_vendor_message_fix(struct octeon_device *oct)
{
  
#line 124 
  u32 val = 0U;
  
#line 127 
  pci_read_config_dword((struct pci_dev const *)oct->pci_dev,1824,& val);
  
#line 128 
  val |= 3U;
  
#line 129 
  pci_write_config_dword((struct pci_dev const *)oct->pci_dev,1824,val);
  
#line 130 
  return;
}


#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn68xx_device.c"
int lio_is_210nv(struct octeon_device *oct)
{
  int __retres;
  
#line 134 
  u64 mio_qlm4_cfg = lio_pci_readq(oct,307863255782832ULL);
  
#line 136 
  __retres = (mio_qlm4_cfg & 7ULL) == 0ULL;
  
#line 136 
  return __retres;
}


#line 139  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn68xx_device.c"
int lio_setup_cn68xx_octeon_device(struct octeon_device *oct)
{
  int __retres;
  int tmp;
  int tmp_0;
  int tmp_1;
  u32 tmp_4;
  
#line 141 
  struct octeon_cn6xxx *cn68xx = (struct octeon_cn6xxx *)oct->chip;
  
#line 142 
  u16 card_type = (unsigned short)2U;
  
#line 144 
  tmp = octeon_map_pci_barx(oct,0,0);
  
#line 144 
  if (tmp != 0) {
    
#line 145 
    __retres = 1;
    
#line 145 
    goto return_label;
  }
  else ;
  
#line 147 
  tmp_0 = octeon_map_pci_barx(oct,1,12582912);
  
#line 147 
  if (tmp_0 != 0) {
    
#line 148 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"%s CN68XX BAR1 map failed\n","lio_setup_cn68xx_octeon_device");
    
#line 150 
    octeon_unmap_pci_barx(oct,0);
    
#line 151 
    __retres = 1;
    
#line 151 
    goto return_label;
  }
  else ;
  
#line 154 
  spinlock_check(& cn68xx->lock_for_droq_int_enb_reg);
  {
    struct lock_class_key __key;
    
#line 154 
    __raw_spin_lock_init(& cn68xx->lock_for_droq_int_enb_reg.__anonCompField_spinlock_18.rlock,"&(&cn68xx->lock_for_droq_int_enb_reg)->rlock",& __key);
  }
  
#line 156 
  oct->fn_list.setup_iq_regs = & lio_cn6xxx_setup_iq_regs;
  
#line 157 
  oct->fn_list.setup_oq_regs = & lio_cn6xxx_setup_oq_regs;
  
#line 159 
  oct->fn_list.process_interrupt_regs = & lio_cn6xxx_process_interrupt_regs;
  
#line 160 
  oct->fn_list.soft_reset = & lio_cn68xx_soft_reset;
  
#line 161 
  oct->fn_list.setup_device_regs = & lio_cn68xx_setup_device_regs;
  
#line 162 
  oct->fn_list.reinit_regs = & lio_cn6xxx_reinit_regs;
  
#line 163 
  oct->fn_list.update_iq_read_idx = & lio_cn6xxx_update_read_index;
  
#line 165 
  oct->fn_list.bar1_idx_setup = & lio_cn6xxx_bar1_idx_setup;
  
#line 166 
  oct->fn_list.bar1_idx_write = & lio_cn6xxx_bar1_idx_write;
  
#line 167 
  oct->fn_list.bar1_idx_read = & lio_cn6xxx_bar1_idx_read;
  
#line 169 
  oct->fn_list.enable_interrupt = & lio_cn6xxx_enable_interrupt;
  
#line 170 
  oct->fn_list.disable_interrupt = & lio_cn6xxx_disable_interrupt;
  
#line 172 
  oct->fn_list.enable_io_queues = & lio_cn6xxx_enable_io_queues;
  
#line 173 
  oct->fn_list.disable_io_queues = & lio_cn6xxx_disable_io_queues;
  
#line 175 
  lio_cn6xxx_setup_reg_address(oct,oct->chip,& oct->reg_list);
  
#line 178 
  tmp_1 = lio_is_210nv(oct);
  
#line 178 
  if (tmp_1 != 0) 
#line 179 
                  card_type = (unsigned short)1U; else ;
  
#line 181 
  cn68xx->conf = (struct octeon_config *)oct_get_config_info(oct,(unsigned short)((int)card_type));
  
#line 183 
  if (cn68xx->conf == (struct octeon_config *)0) {
    char *tmp_3;
    
#line 185 
    if ((unsigned int)card_type == 2U) 
#line 185 
                                       tmp_3 = (char *)"410nv"; else 
                                                                  
#line 185 
                                                                  tmp_3 = (char *)"210nv";
    
#line 184 
    ;
    
#line 184 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"%s No Config found for CN68XX %s\n","lio_setup_cn68xx_octeon_device",tmp_3);
    
#line 188 
    octeon_unmap_pci_barx(oct,0);
    
#line 189 
    octeon_unmap_pci_barx(oct,1);
    
#line 190 
    __retres = 1;
    
#line 190 
    goto return_label;
  }
  else ;
  
#line 193 
  tmp_4 = lio_cn6xxx_coprocessor_clock(oct);
  
#line 193 
  oct->coproc_clock_rate = (unsigned long long)tmp_4 * 1000000ULL;
  
#line 195 
  lio_cn68xx_vendor_message_fix(oct);
  
#line 197 
  __retres = 0;
  return_label: 
#line 197 
                return __retres;
}


#line 7  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_request_manager.c.aux"
void ldv_atomic_inc(atomic_t *v);


#line 8 
void ldv_atomic_dec(atomic_t *v);


#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static int list_empty(struct list_head const *head)
{
  int __retres;
  
#line 189 
  __retres = (struct list_head const *)head->next == head;
  
#line 189 
  return __retres;
}


#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/atomic.h"
static void atomic_sub_0(int i, atomic_t *v);


#line 98 
static void atomic_inc(atomic_t *v);


#line 114 
static void atomic_dec(atomic_t *v);


#line 280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
void lockdep_init_map(struct lockdep_map *, char const *, struct lock_class_key *, int);


#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_0(spinlock_t *lock)
{
  
#line 312 
  _raw_spin_lock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 313 
  return;
}


#line 358 
static void ldv_spin_lock_83(spinlock_t *lock);


#line 362 
static void ldv_spin_lock_85(spinlock_t *lock);


#line 366 
static void ldv_spin_lock_88(spinlock_t *lock);


#line 367  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_bh_0(spinlock_t *lock)
{
  
#line 369 
  _raw_spin_lock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 370 
  return;
}


#line 395 
static void ldv_spin_lock_bh_74(spinlock_t *lock);


#line 399 
static void ldv_spin_lock_bh_76(spinlock_t *lock);


#line 403 
static void ldv_spin_lock_bh_78(spinlock_t *lock);


#line 407 
static void ldv_spin_lock_bh_81(spinlock_t *lock);


#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_0(spinlock_t *lock)
{
  
#line 365 
  _raw_spin_unlock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 366 
  return;
}


#line 407 
static void ldv_spin_unlock_84(spinlock_t *lock);


#line 411 
static void ldv_spin_unlock_86(spinlock_t *lock);


#line 415 
static void ldv_spin_unlock_87(spinlock_t *lock);


#line 419 
static void ldv_spin_unlock_89(spinlock_t *lock);


#line 420  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_bh_0(spinlock_t *lock)
{
  
#line 422 
  _raw_spin_unlock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 423 
  return;
}


#line 448 
static void ldv_spin_unlock_bh_75_0(spinlock_t *lock);


#line 452 
static void ldv_spin_unlock_bh_77(spinlock_t *lock);


#line 456 
static void ldv_spin_unlock_bh_79(spinlock_t *lock);


#line 460 
static void ldv_spin_unlock_bh_82(spinlock_t *lock);


#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
extern unsigned long volatile jiffies;


#line 292 
unsigned long __msecs_to_jiffies(unsigned int const);


#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
__inline static unsigned long _msecs_to_jiffies(unsigned int const m)
{
  unsigned long __retres;
  
#line 301 
  __retres = (unsigned long)(((long)m + 3L) / 4L);
  
#line 301 
  return __retres;
}


#line 354  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
__inline static unsigned long msecs_to_jiffies(unsigned int const m)
{
  unsigned long __retres;
  
#line 356 
  if (0 != 0) {
    unsigned long tmp;
    
#line 357 
    if ((int)m < 0) {
      
#line 358 
      __retres = 4611686018427387902UL;
      
#line 358 
      goto return_label;
    }
    else ;
    
#line 359 
    tmp = _msecs_to_jiffies(m);
    
#line 359 
    __retres = tmp;
    
#line 359 
    goto return_label;
  }
  else {
    unsigned long tmp_0;
    
#line 361 
    tmp_0 = __msecs_to_jiffies(m);
    
#line 361 
    __retres = tmp_0;
    
#line 361 
    goto return_label;
  }
  return_label: 
#line 356 
                return __retres;
}


#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
void init_timer_key(struct timer_list *, unsigned int, char const *, struct lock_class_key *);


#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
void delayed_work_timer_fn(unsigned long);


#line 181 
void __init_work(struct work_struct *, int);


#line 361 
struct workqueue_struct *__alloc_workqueue_key(char const *, unsigned int, int, struct lock_class_key *, char const * , ...);


#line 421 
void destroy_workqueue(struct workqueue_struct *);


#line 436 
void flush_workqueue(struct workqueue_struct *);


#line 448 
bool cancel_delayed_work_sync(struct delayed_work *);


#line 505 
static bool ldv_queue_delayed_work_73(struct workqueue_struct *wq, struct delayed_work *dwork, unsigned long delay);


#line 509 
static bool ldv_queue_delayed_work_80(struct workqueue_struct *wq, struct delayed_work *dwork, unsigned long delay);


#line 424  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
long schedule_timeout_uninterruptible(long);


#line 259  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_iq.h"
int octeon_setup_sc_buffer_pool(struct octeon_device *oct);


#line 260 
int octeon_free_sc_buffer_pool(struct octeon_device *oct);


#line 262 
struct octeon_soft_command *octeon_alloc_soft_command(struct octeon_device *oct, u32 datasize, u32 rdatasize, u32 ctxsize);


#line 265 
void octeon_free_soft_command(struct octeon_device *oct, struct octeon_soft_command *sc);


#line 278 
int octeon_init_instr_queue(struct octeon_device *oct, u32 iq_no, u32 num_descs);


#line 291 
int octeon_delete_instr_queue(struct octeon_device *oct, u32 iq_no);


#line 293 
int lio_wait_for_instr_fetch(struct octeon_device *oct);


#line 296 
int octeon_register_reqtype_free_fn(struct octeon_device *oct, int reqtype, void (*fn)(void *));


#line 300 
int lio_process_iq_request_list(struct octeon_device *oct, struct octeon_instr_queue *iq);


#line 303 
int octeon_send_command(struct octeon_device *oct, u32 iq_no, u32 force_db, void *cmd, void *buf, u32 datasize, u32 reqtype);


#line 307 
void octeon_prepare_soft_command(struct octeon_device *oct, struct octeon_soft_command *sc, u8 opcode, u8 subcode, u32 irh_ossp, u64 ossp0, u64 ossp1);


#line 313 
int octeon_send_soft_command(struct octeon_device *oct, struct octeon_soft_command *sc);


#line 316 
int octeon_setup_iq(struct octeon_device *oct, u32 iq_no, u32 num_descs, void *app_ctx);


#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_main.h"
void octeon_report_sent_bytes_to_bql(void *buf, int reqtype);


#line 50 
void octeon_update_tx_completion_counters(void *buf, int reqtype, unsigned int *pkts_compl, unsigned int *bytes_compl);


#line 53 
void octeon_report_tx_completion_to_bql(void *txq, unsigned int pkts_compl, unsigned int bytes_compl);


#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/request_manager.c"
static void check_db_timeout(struct work_struct *work);


#line 54 
static void __check_db_timeout(struct octeon_device *oct, unsigned long iq_no);


#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/request_manager.c"
static void (*reqtype_free_fn[32U][6U])(void *);

#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/request_manager.c"
int octeon_init_instr_queue(struct octeon_device *oct, u32 iq_no, u32 num_descs)
{
  int __retres;
  struct octeon_instr_queue *iq;
  u32 q_size;
  struct cavium_wq *db_wq;
  struct workqueue_struct *tmp_2;
  unsigned long tmp_3;
  
#line 75 
  struct octeon_iq_config *conf = (struct octeon_iq_config *)0;
  
#line 79 
  if ((unsigned int)oct->chip_id + 65391U <= 1U) 
#line 80 
                                                 conf = & (((struct octeon_cn6xxx *)oct->chip)->conf)->iq; else ;
  
#line 82 
  if (conf == (struct octeon_iq_config *)0) {
    
#line 83 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Unsupported Chip %x\n",(int)oct->chip_id);
    
#line 85 
    __retres = 1;
    
#line 85 
    goto return_label;
  }
  else ;
  
#line 88 
  if (((num_descs + 4294967295U) & num_descs) != 0U) {
    
#line 89 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Number of descriptors for instr queue %d not in power of 2.\n",iq_no);
    
#line 92 
    __retres = 1;
    
#line 92 
    goto return_label;
  }
  else ;
  
#line 95 
  q_size = (unsigned int)conf->instr_type * num_descs;
  
#line 97 
  iq = oct->instr_queue[iq_no];
  
#line 99 
  iq->base_addr = (u8 *)dma_alloc_attrs(& (oct->pci_dev)->dev,(unsigned long)q_size,& iq->base_addr_dma,208U,(struct dma_attrs *)0);
  
#line 101 
  if (iq->base_addr == (u8 *)0U) {
    
#line 102 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Cannot allocate memory for instr queue %d\n",iq_no);
    
#line 104 
    __retres = 1;
    
#line 104 
    goto return_label;
  }
  else ;
  
#line 107 
  iq->max_count = num_descs;
  
#line 112 
  iq->request_list = (struct octeon_request_list *)vmalloc((unsigned long)num_descs * 16UL);
  
#line 113 
  if (iq->request_list == (struct octeon_request_list *)0) {
    
#line 114 
    dma_free_attrs(& (oct->pci_dev)->dev,(unsigned long)q_size,(void *)iq->base_addr,iq->base_addr_dma,(struct dma_attrs *)0);
    
#line 115 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Alloc failed for IQ[%d] nr free list\n",iq_no);
    
#line 117 
    __retres = 1;
    
#line 117 
    goto return_label;
  }
  else ;
  
#line 120 
  memset((void *)iq->request_list,0,(unsigned long)num_descs * 16UL);
  {
    
#line 122 
    struct _ddebug descriptor = {.modname = "liquidio", .function = "octeon_init_instr_queue", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/request_manager.c", .format = "IQ[%d]: base: %p basedma: %llx count: %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))123U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 122 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 122 
                                                        __dynamic_dev_dbg(& descriptor,(struct device const *)(& (oct->pci_dev)->dev),"IQ[%d]: base: %p basedma: %llx count: %d\n",iq_no,iq->base_addr,iq->base_addr_dma,iq->max_count); else ;
  }
  
#line 125 
  iq->iq_no = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(5))))iq_no;
  
#line 126 
  iq->fill_threshold = (unsigned int)conf->db_min;
  
#line 127 
  iq->fill_cnt = 0U;
  
#line 128 
  iq->host_write_index = 0U;
  
#line 129 
  iq->octeon_read_index = 0U;
  
#line 130 
  iq->flush_index = 0U;
  
#line 131 
  iq->last_db_time = 0ULL;
  
#line 132 
  iq->do_auto_flush = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U;
  
#line 133 
  iq->db_timeout = (unsigned int)conf->db_timeout;
  
#line 134 
  atomic_set(& iq->instr_pending,0);
  
#line 137 
  spinlock_check(& iq->lock);
  {
    struct lock_class_key __key;
    
#line 137 
    __raw_spin_lock_init(& iq->lock.__anonCompField_spinlock_18.rlock,"&(&iq->lock)->rlock",& __key);
  }
  
#line 139 
  oct->io_qmask.iq |= (unsigned int)(1 << iq_no);
  
#line 142 
  oct->io_qmask.iq64B |= (unsigned int)(((unsigned int)conf->instr_type == 64U) << iq_no);
  
#line 143 
  iq->iqcmd_64B = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))((unsigned int)conf->instr_type == 64U);
  
#line 145 
  (*(oct->fn_list.setup_iq_regs))(oct,iq_no);
  {
    struct lock_class_key __key_0;
    char const *__lock_name;
    
#line 147 
    __lock_name = "\"%s\"";
    
#line 147 
    tmp_2 = __alloc_workqueue_key("%s",8U,1,& __key_0,__lock_name,(char *)"check_iq_db");
  }
  
#line 147 
  oct->check_db_wq[iq_no].wq = tmp_2;
  
#line 148 
  if (oct->check_db_wq[iq_no].wq == (struct workqueue_struct *)0) {
    
#line 149 
    dma_free_attrs(& (oct->pci_dev)->dev,(unsigned long)q_size,(void *)iq->base_addr,iq->base_addr_dma,(struct dma_attrs *)0);
    
#line 150 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"check db wq create failed for iq %d\n",iq_no);
    
#line 152 
    __retres = 1;
    
#line 152 
    goto return_label;
  }
  else ;
  
#line 155 
  db_wq = & oct->check_db_wq[iq_no];
  {
    struct lock_class_key __key_1;
    
#line 157 
    __init_work(& db_wq->wk.work.work,0);
    
#line 157 
    atomic_long_t __constr_expr_37 = {.counter = WORK_STRUCT_NO_POOL};
    
#line 157 
    db_wq->wk.work.work.data = __constr_expr_37;
    
#line 157 
    lockdep_init_map(& db_wq->wk.work.work.lockdep_map,"(&(&db_wq->wk.work)->work)",& __key_1,0);
    
#line 157 
    INIT_LIST_HEAD(& db_wq->wk.work.work.entry);
    
#line 157 
    db_wq->wk.work.work.func = & check_db_timeout;
  }
  {
    struct lock_class_key __key_2;
    
#line 157 
    init_timer_key(& db_wq->wk.work.timer,2097152U,"(&(&db_wq->wk.work)->timer)",& __key_2);
  }
  
#line 157 
  db_wq->wk.work.timer.function = & delayed_work_timer_fn;
  
#line 157 
  db_wq->wk.work.timer.data = (unsigned long)(& db_wq->wk.work);
  
#line 158 
  db_wq->wk.ctxptr = (void *)oct;
  
#line 159 
  db_wq->wk.ctxul = (unsigned long)iq_no;
  
#line 160 
  tmp_3 = msecs_to_jiffies(1U);
  
#line 160 
  ;
  
#line 160 
  ;
  
#line 160 
  ldv_queue_delayed_work_73(db_wq->wq,& db_wq->wk.work,tmp_3);
  
#line 162 
  __retres = 0;
  return_label: 
#line 162 
                return __retres;
}


#line 165  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/request_manager.c"
int octeon_delete_instr_queue(struct octeon_device *oct, u32 iq_no)
{
  int __retres;
  u64 q_size;
  
#line 167 
  u64 desc_size = 0ULL;
  
#line 168 
  struct octeon_instr_queue *iq = oct->instr_queue[iq_no];
  
#line 170 
  cancel_delayed_work_sync(& oct->check_db_wq[iq_no].wk.work);
  
#line 171 
  flush_workqueue(oct->check_db_wq[iq_no].wq);
  
#line 172 
  destroy_workqueue(oct->check_db_wq[iq_no].wq);
  
#line 174 
  if ((unsigned int)oct->chip_id + 65391U <= 1U) 
#line 175 
                                                 desc_size = (unsigned long long)(((struct octeon_cn6xxx *)oct->chip)->conf)->iq.instr_type; else ;
  
#line 178 
  vfree((void const *)iq->request_list);
  
#line 180 
  if (iq->base_addr != (u8 *)0U) {
    
#line 181 
    q_size = (unsigned long long)iq->max_count * desc_size;
    
#line 182 
    dma_free_attrs(& (oct->pci_dev)->dev,(unsigned long)((unsigned int)q_size),(void *)iq->base_addr,iq->base_addr_dma,(struct dma_attrs *)0);
    
#line 184 
    __retres = 0;
    
#line 184 
    goto return_label;
  }
  else ;
  
#line 186 
  __retres = 1;
  return_label: 
#line 186 
                return __retres;
}


#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/request_manager.c"
int octeon_setup_iq(struct octeon_device *oct, u32 iq_no, u32 num_descs, void *app_ctx)
{
  int __retres;
  int tmp_0;
  
#line 195 
  if (oct->instr_queue[iq_no] != (struct octeon_instr_queue *)0) {
    {
      
#line 196 
      struct _ddebug descriptor = {.modname = "liquidio", .function = "octeon_setup_iq", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/request_manager.c", .format = "IQ is in use. Cannot create the IQ: %d again\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))197U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 196 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 196 
                                                          __dynamic_dev_dbg(& descriptor,(struct device const *)(& (oct->pci_dev)->dev),"IQ is in use. Cannot create the IQ: %d again\n",iq_no); else ;
    }
    
#line 198 
    (oct->instr_queue[iq_no])->app_ctx = app_ctx;
    
#line 199 
    __retres = 0;
    
#line 199 
    goto return_label;
  }
  else ;
  
#line 202 
  oct->instr_queue[iq_no] = (struct octeon_instr_queue *)vmalloc(248UL);
  
#line 203 
  if (oct->instr_queue[iq_no] == (struct octeon_instr_queue *)0) {
    
#line 204 
    __retres = 1;
    
#line 204 
    goto return_label;
  }
  else ;
  
#line 206 
  memset((void *)oct->instr_queue[iq_no],0,248UL);
  
#line 209 
  (oct->instr_queue[iq_no])->app_ctx = app_ctx;
  
#line 210 
  tmp_0 = octeon_init_instr_queue(oct,iq_no,num_descs);
  
#line 210 
  if (tmp_0 != 0) {
    
#line 211 
    vfree((void const *)oct->instr_queue[iq_no]);
    
#line 212 
    oct->instr_queue[iq_no] = (struct octeon_instr_queue *)0;
    
#line 213 
    __retres = 1;
    
#line 213 
    goto return_label;
  }
  else ;
  
#line 216 
  oct->num_iqs += 1U;
  
#line 217 
  (*(oct->fn_list.enable_io_queues))(oct);
  
#line 218 
  __retres = 0;
  return_label: 
#line 218 
                return __retres;
}


#line 221  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/request_manager.c"
int lio_wait_for_instr_fetch(struct octeon_device *oct)
{
  int i;
  int pending;
  int tmp;
  
#line 223 
  int retry = 1000;
  
#line 223 
  int instr_cnt = 0;
  ldv_46658: 
#line 224 
  ;
  
#line 226 
  instr_cnt = 0;
  
#line 229 
  i = 0;
  
#line 229 
  goto ldv_46655;
  ldv_46654: 
#line 230 
  ;
  
#line 230 
  if ((((unsigned long)oct->io_qmask.iq >> i) & 1UL) == 0UL) 
#line 231 
                                                             goto ldv_46653; else ;
  
#line 232 
  pending = atomic_read((atomic_t const *)(& (oct->instr_queue[i])->instr_pending));
  
#line 235 
  if (pending != 0) 
#line 236 
                    __check_db_timeout(oct,(unsigned long)i); else ;
  
#line 237 
  instr_cnt += pending;
  ldv_46653: 
#line 238 
  ;
  
#line 229 
  i += 1;
  ldv_46655: 
#line 230 
  ;
  
#line 229 
  if (i <= 31) 
#line 231 
               goto ldv_46654; else 
#line 234 
                                    goto ldv_46656;
  ldv_46656: 
#line 235 
  ;
  
#line 240 
  if (instr_cnt == 0) 
#line 241 
                      goto ldv_46657; else ;
  
#line 243 
  schedule_timeout_uninterruptible(1L);
  
#line 245 
  tmp = retry;
  
#line 245 
  retry -= 1;
  
#line 245 
  ;
  
#line 245 
  if (tmp != 0) {
    
#line 245 
    if (instr_cnt != 0) 
#line 247 
                        goto ldv_46658; else 
#line 250 
                                             goto ldv_46657;
  }
  else 
#line 250 
       goto ldv_46657;
  ldv_46657: 
#line 251 
  ;
  
#line 247 
  return instr_cnt;
}


#line 251  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/request_manager.c"
__inline static void ring_doorbell(struct octeon_device *oct, struct octeon_instr_queue *iq)
{
  int tmp;
  
#line 253 
  tmp = atomic_read((atomic_t const *)(& oct->status));
  
#line 253 
  if (tmp == 11) {
    
#line 254 
    writel(iq->fill_cnt,(void volatile *)iq->doorbell_reg);
    
#line 255 
    ldv_inline_asm();
    
#line 257 
    iq->fill_cnt = 0U;
    
#line 258 
    iq->last_db_time = (unsigned long long)jiffies;
    
#line 259 
    goto return_label;
  }
  else ;
  return_label: 
#line 261 
                return;
}


#line 263  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/request_manager.c"
__inline static void __copy_cmd_into_iq(struct octeon_instr_queue *iq, u8 *cmd)
{
  u8 *iqptr;
  u8 cmdsize;
  
#line 268 
  if ((unsigned int)*((unsigned char *)iq + 72UL) != 0U) 
#line 268 
                                                         cmdsize = (unsigned char)64U; else 
                                                                    
#line 268 
                                                                    cmdsize = (unsigned char)32U;
  
#line 269 
  iqptr = iq->base_addr + (unsigned int)cmdsize * iq->host_write_index;
  
#line 271 
  memcpy((void *)iqptr,(void const *)cmd,(unsigned long)cmdsize);
  
#line 272 
  return;
}


#line 305  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/request_manager.c"
__inline static struct iq_post_status __post_command2(struct octeon_device *octeon_dev, struct octeon_instr_queue *iq, u32 force_db, u8 *cmd)
{
  struct iq_post_status __retres;
  struct iq_post_status st;
  int tmp;
  int tmp_0;
  
#line 311 
  st.status = 0;
  
#line 316 
  tmp = atomic_read((atomic_t const *)(& iq->instr_pending));
  
#line 316 
  ;
  
#line 316 
  if (tmp >= (int)(iq->max_count + 4294967295U)) {
    
#line 317 
    st.status = -1;
    
#line 318 
    st.index = -1;
    
#line 319 
    __retres = st;
    
#line 319 
    goto return_label;
  }
  else ;
  
#line 322 
  tmp_0 = atomic_read((atomic_t const *)(& iq->instr_pending));
  
#line 322 
  ;
  
#line 322 
  if (tmp_0 >= (int)(iq->max_count + 4294967294U)) 
#line 323 
                                                   st.status = 1; else ;
  
#line 325 
  __copy_cmd_into_iq(iq,cmd);
  
#line 328 
  st.index = (int)iq->host_write_index;
  
#line 329 
  iq->host_write_index += 1U;
  
#line 329 
  ;
  
#line 329 
  if (iq->host_write_index == iq->max_count) 
#line 329 
                                             iq->host_write_index = 0U; else ;
  
#line 330 
  iq->fill_cnt += 1U;
  
#line 331 
  ldv_inline_asm();
  
#line 337 
  atomic_inc(& iq->instr_pending);
  
#line 339 
  __retres = st;
  return_label: 
#line 339 
                return __retres;
}


#line 343  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/request_manager.c"
int octeon_register_reqtype_free_fn(struct octeon_device *oct, int reqtype, void (*fn)(void *))
{
  int __retres;
  
#line 346 
  if (reqtype > 5) {
    
#line 347 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"%s: Invalid reqtype: %d\n","octeon_register_reqtype_free_fn",reqtype);
    
#line 349 
    __retres = -22;
    
#line 349 
    goto return_label;
  }
  else ;
  
#line 352 
  reqtype_free_fn[oct->octeon_id][reqtype] = fn;
  
#line 354 
  __retres = 0;
  return_label: 
#line 354 
                return __retres;
}


#line 358  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/request_manager.c"
__inline static void __add_to_request_list(struct octeon_instr_queue *iq, int idx, void *buf, int reqtype)
{
  
#line 361 
  (iq->request_list + idx)->buf = buf;
  
#line 362 
  (iq->request_list + idx)->reqtype = (unsigned int)reqtype;
  
#line 363 
  return;
}


#line 366  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/request_manager.c"
int lio_process_iq_request_list(struct octeon_device *oct, struct octeon_instr_queue *iq)
{
  int __retres;
  int reqtype;
  void *buf;
  struct octeon_soft_command *sc;
  struct octeon_instr_irh *irh;
  
#line 371 
  u32 old = iq->flush_index;
  
#line 372 
  u32 inst_count = 0U;
  
#line 373 
  unsigned int pkts_compl = 0U;
  
#line 373 
  unsigned int bytes_compl = 0U;
  
#line 377 
  goto ldv_46718;
  ldv_46717: 
#line 378 
  ;
  
#line 378 
  reqtype = (int)(iq->request_list + old)->reqtype;
  
#line 379 
  buf = (iq->request_list + old)->buf;
  
#line 381 
  if (reqtype == 0) 
#line 382 
                    goto skip_this; else ;
  
#line 384 
  octeon_update_tx_completion_counters(buf,reqtype,& pkts_compl,& bytes_compl);
  
#line 387 
  switch (reqtype) {
    case 1: 
#line 388 
    ;
    case 2: 
#line 389 
    ;
    case 4: 
#line 390 
    ;
    
#line 391 
    (*(reqtype_free_fn[oct->octeon_id][reqtype]))(buf);
    
#line 392 
    goto ldv_46712;
    case 3: 
#line 393 
    ;
    case 5: 
#line 394 
    ;
    
#line 395 
    sc = (struct octeon_soft_command *)buf;
    
#line 397 
    irh = (struct octeon_instr_irh *)(& sc->cmd.irh);
    
#line 398 
    if ((unsigned int)*((unsigned char *)irh + 7UL) != 0U) {
      
#line 405 
      ldv_spin_lock_bh_74(& oct->response_list[3].lock);
      
#line 407 
      atomic_inc(& oct->response_list[3].pending_req_count);
      
#line 410 
      list_add_tail(& sc->node,& oct->response_list[3].head);
      
#line 412 
      ldv_spin_unlock_bh_75_0(& oct->response_list[3].lock);
    }
    else 
      
#line 415 
      if (sc->callback != (void (*)(struct octeon_device *, u32 , void *))0) 
        
#line 416 
        (*(sc->callback))(oct,0U,sc->callback_arg); else ;
    
#line 420 
    goto ldv_46712;
    default: 
#line 421 
    ;
    
#line 422 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"%s Unknown reqtype: %d buf: %p at idx %d\n","lio_process_iq_request_list",reqtype,buf,old);
  }
  ldv_46712: 
#line 427 
  ;
  
#line 427 
  (iq->request_list + old)->buf = (void *)0;
  
#line 428 
  (iq->request_list + old)->reqtype = 0U;
  skip_this: 
#line 430 
  ;
  
#line 431 
  inst_count += 1U;
  
#line 432 
  old += 1U;
  
#line 432 
  ;
  
#line 432 
  if (old == iq->max_count) 
#line 432 
                            old = 0U; else ;
  ldv_46718: 
#line 433 
  ;
  
#line 377 
  if (iq->octeon_read_index != old) 
#line 379 
                                    goto ldv_46717; else 
#line 382 
                                                         goto ldv_46719;
  ldv_46719: 
#line 383 
  ;
  
#line 434 
  if (bytes_compl != 0U) 
#line 435 
                         octeon_report_tx_completion_to_bql(iq->app_ctx,pkts_compl,bytes_compl); else ;
  
#line 437 
  iq->flush_index = old;
  
#line 439 
  __retres = (int)inst_count;
  
#line 439 
  return __retres;
}


#line 443  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/request_manager.c"
__inline static void update_iq_indices(struct octeon_device *oct, struct octeon_instr_queue *iq)
{
  
#line 445 
  u32 inst_processed = 0U;
  
#line 450 
  iq->octeon_read_index = (*(oct->fn_list.update_iq_read_idx))(oct,iq);
  
#line 453 
  if (iq->flush_index != iq->octeon_read_index) {
    int tmp;
    
#line 454 
    tmp = lio_process_iq_request_list(oct,iq);
    
#line 454 
    inst_processed = (unsigned int)tmp;
  }
  else ;
  
#line 456 
  if (inst_processed != 0U) {
    
#line 457 
    atomic_sub_0((int)inst_processed,& iq->instr_pending);
    
#line 458 
    iq->stats.instr_processed += (unsigned long long)inst_processed;
  }
  else ;
  
#line 460 
  return;
}


#line 463  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/request_manager.c"
static void octeon_flush_iq(struct octeon_device *oct, struct octeon_instr_queue *iq, u32 pending_thresh)
{
  int tmp;
  
#line 466 
  tmp = atomic_read((atomic_t const *)(& iq->instr_pending));
  
#line 466 
  ;
  
#line 466 
  if (tmp >= (int)pending_thresh) {
    
#line 467 
    ldv_spin_lock_bh_76(& iq->lock);
    
#line 468 
    update_iq_indices(oct,iq);
    
#line 469 
    ldv_spin_unlock_bh_77(& iq->lock);
  }
  else ;
  
#line 471 
  return;
}


#line 473  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/request_manager.c"
static void __check_db_timeout(struct octeon_device *oct, unsigned long iq_no)
{
  struct octeon_instr_queue *iq;
  u64 next_time;
  int tmp;
  
#line 478 
  if (oct == (struct octeon_device *)0) 
#line 479 
                                        goto return_label; else ;
  
#line 480 
  iq = oct->instr_queue[iq_no];
  
#line 481 
  if (iq == (struct octeon_instr_queue *)0) 
#line 482 
                                            goto return_label; else ;
  
#line 485 
  next_time = iq->last_db_time + (unsigned long long)iq->db_timeout;
  {
    unsigned long __dummy;
    unsigned long volatile __dummy2;
    
#line 486 
    tmp = 1;
  }
  
#line 486 
  if (tmp == 0) 
#line 487 
                goto return_label;
  else {
    int tmp_0;
    {
      unsigned long __dummy_0;
      unsigned long __dummy2_0;
      
#line 486 
      tmp_0 = 1;
    }
    
#line 486 
    if (tmp_0 == 0) 
#line 487 
                    goto return_label;
    else 
      
#line 486 
      if ((long)((unsigned long)next_time - jiffies) >= 0L) 
#line 487 
                                                            goto return_label; else ;
  }
  
#line 488 
  iq->last_db_time = (unsigned long long)jiffies;
  
#line 493 
  ldv_spin_lock_bh_78(& iq->lock);
  
#line 494 
  if (iq->fill_cnt != 0U) 
#line 495 
                          ring_doorbell(oct,iq); else ;
  
#line 497 
  ldv_spin_unlock_bh_79(& iq->lock);
  
#line 500 
  if ((unsigned int)*((unsigned char *)iq + 74UL) != 0U) 
#line 501 
                                                         octeon_flush_iq(oct,iq,1U); else ;
  return_label: 
#line 502 
                return;
}


#line 507  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/request_manager.c"
static void check_db_timeout(struct work_struct *work)
{
  unsigned long tmp;
  
#line 509 
  struct cavium_wk *wk = (struct cavium_wk *)work;
  
#line 510 
  struct octeon_device *oct = (struct octeon_device *)wk->ctxptr;
  
#line 511 
  unsigned long iq_no = wk->ctxul;
  
#line 512 
  struct cavium_wq *db_wq = & oct->check_db_wq[iq_no];
  
#line 514 
  __check_db_timeout(oct,iq_no);
  
#line 515 
  tmp = msecs_to_jiffies(1U);
  
#line 515 
  ;
  
#line 515 
  ;
  
#line 515 
  ldv_queue_delayed_work_80(db_wq->wq,& db_wq->wk.work,tmp);
  
#line 516 
  return;
}


#line 519  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/request_manager.c"
int octeon_send_command(struct octeon_device *oct, u32 iq_no, u32 force_db, void *cmd, void *buf, u32 datasize, u32 reqtype)
{
  int __retres;
  struct iq_post_status st;
  
#line 524 
  struct octeon_instr_queue *iq = oct->instr_queue[iq_no];
  
#line 526 
  ldv_spin_lock_bh_81(& iq->lock);
  
#line 528 
  st = __post_command2(oct,iq,force_db,(u8 *)cmd);
  
#line 530 
  if (st.status != -1) {
    
#line 531 
    octeon_report_sent_bytes_to_bql(buf,(int)reqtype);
    
#line 532 
    __add_to_request_list(iq,st.index,buf,(int)reqtype);
    
#line 533 
    (oct->instr_queue[iq_no])->stats.bytes_sent += (unsigned long long)datasize;
    
#line 534 
    (oct->instr_queue[iq_no])->stats.instr_posted += 1ULL;
    
#line 536 
    if (iq->fill_cnt >= iq->fill_threshold || force_db != 0U) 
#line 537 
                                                              ring_doorbell(oct,iq); else ;
  }
  else 
#line 539 
       (oct->instr_queue[iq_no])->stats.instr_dropped += 1ULL;
  
#line 542 
  ldv_spin_unlock_bh_82(& iq->lock);
  
#line 544 
  if ((unsigned int)*((unsigned char *)iq + 74UL) != 0U) 
#line 545 
                                                         octeon_flush_iq(oct,iq,2U); else ;
  
#line 547 
  __retres = st.status;
  
#line 547 
  return __retres;
}


#line 551  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/request_manager.c"
void octeon_prepare_soft_command(struct octeon_device *oct, struct octeon_soft_command *sc, u8 opcode, u8 subcode, u32 irh_ossp, u64 ossp0, u64 ossp1)
{
  struct octeon_config *oct_cfg;
  struct octeon_instr_ih *ih;
  struct octeon_instr_irh *irh;
  struct octeon_instr_rdp *rdp;
  
#line 564 
  if ((long)((unsigned int)opcode > 15U) != 0L) {
    
#line 566 
    ldv_inline_asm();
    
#line 564 
    ;
  }
  else ;
  
#line 565 
  if ((long)((int)subcode < 0) != 0L) {
    
#line 567 
    ldv_inline_asm();
    
#line 565 
    ;
  }
  else ;
  
#line 567 
  oct_cfg = octeon_get_conf(oct);
  
#line 569 
  ih = (struct octeon_instr_ih *)(& sc->cmd.ih);
  
#line 570 
  ih->tagtype = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U;
  
#line 571 
  ih->tag = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(32))))286331152U;
  
#line 572 
  ih->raw = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U;
  
#line 573 
  ih->grp = oct_cfg->misc.ctrlq_grp;
  
#line 575 
  if (sc->datasize != 0U) {
    
#line 576 
    ih->dlengsz = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(14))))sc->datasize;
    
#line 577 
    ih->rs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U;
  }
  else ;
  
#line 580 
  irh = (struct octeon_instr_irh *)(& sc->cmd.irh);
  
#line 581 
  irh->opcode = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))opcode;
  
#line 582 
  irh->subcode = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(7))))subcode;
  
#line 585 
  irh->ossp = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(32))))irh_ossp;
  
#line 586 
  sc->cmd.ossp[0] = ossp0;
  
#line 587 
  sc->cmd.ossp[1] = ossp1;
  
#line 589 
  if (sc->rdatasize != 0U) {
    
#line 590 
    rdp = (struct octeon_instr_rdp *)(& sc->cmd.rdp);
    
#line 591 
    rdp->pcie_port = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))oct->pcie_port;
    
#line 592 
    rdp->rlen = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))))sc->rdatasize;
    
#line 594 
    irh->rflag = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U;
    
#line 595 
    irh->len = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U;
    
#line 596 
    ih->fsz = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))40U;
  }
  else {
    
#line 598 
    irh->rflag = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U;
    
#line 599 
    irh->len = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U;
    
#line 600 
    ih->fsz = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))24U;
  }
  
#line 603 
  goto ldv_46774;
  ldv_46773: 
#line 604 
  ;
  
#line 604 
  sc->iq_no += 1U;
  ldv_46774: 
#line 605 
  ;
  
#line 603 
  if ((oct->io_qmask.iq & (unsigned int)(1 << sc->iq_no)) == 0U) 
#line 605 
                                                                 goto ldv_46773; else 
                                                                    
#line 608 
                                                                    goto ldv_46775;
  ldv_46775: 
#line 609 
  ;
  
#line 610 
  return;
}


#line 607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/request_manager.c"
int octeon_send_soft_command(struct octeon_device *oct, struct octeon_soft_command *sc)
{
  struct octeon_instr_ih *ih;
  struct octeon_instr_irh *irh;
  struct octeon_instr_rdp *rdp;
  int tmp;
  
#line 614 
  ih = (struct octeon_instr_ih *)(& sc->cmd.ih);
  
#line 615 
  if ((unsigned int)*((unsigned short *)ih + 3UL) != 0U) {
    
#line 616 
    if ((long)(sc->dmadptr == 0ULL) != 0L) {
      
#line 618 
      ldv_inline_asm();
      
#line 616 
      ;
    }
    else ;
    
#line 617 
    sc->cmd.dptr = sc->dmadptr;
  }
  else ;
  
#line 620 
  irh = (struct octeon_instr_irh *)(& sc->cmd.irh);
  
#line 621 
  if ((unsigned int)*((unsigned char *)irh + 7UL) != 0U) {
    
#line 622 
    if ((long)(sc->dmarptr == 0ULL) != 0L) {
      
#line 624 
      ldv_inline_asm();
      
#line 622 
      ;
    }
    else ;
    
#line 623 
    if ((long)(sc->status_word == (u64 *)0ULL) != 0L) {
      
#line 625 
      ldv_inline_asm();
      
#line 623 
      ;
    }
    else ;
    
#line 624 
    *(sc->status_word) = 18446744073709551615ULL;
    
#line 626 
    rdp = (struct octeon_instr_rdp *)(& sc->cmd.rdp);
    
#line 628 
    sc->cmd.rptr = sc->dmarptr;
  }
  else ;
  
#line 631 
  if (sc->wait_time != 0UL) 
#line 632 
                            sc->timeout = sc->wait_time + jiffies; else ;
  
#line 634 
  tmp = octeon_send_command(oct,sc->iq_no,1U,(void *)(& sc->cmd),(void *)sc,(unsigned int)ih->dlengsz,5U);
  
#line 634 
  return tmp;
}


#line 638  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/request_manager.c"
int octeon_setup_sc_buffer_pool(struct octeon_device *oct)
{
  int __retres;
  int i;
  u64 dma_addr;
  struct octeon_soft_command *sc;
  
#line 644 
  INIT_LIST_HEAD(& oct->sc_buf_pool.head);
  
#line 645 
  spinlock_check(& oct->sc_buf_pool.lock);
  {
    struct lock_class_key __key;
    
#line 645 
    __raw_spin_lock_init(& oct->sc_buf_pool.lock.__anonCompField_spinlock_18.rlock,"&(&oct->sc_buf_pool.lock)->rlock",& __key);
  }
  
#line 646 
  atomic_set(& oct->sc_buf_pool.alloc_buf_count,0);
  
#line 648 
  i = 0;
  
#line 648 
  goto ldv_46791;
  ldv_46790: 
#line 649 
  ;
  
#line 649 
  sc = (struct octeon_soft_command *)dma_alloc_attrs(& (oct->pci_dev)->dev,1024UL,& dma_addr,208U,(struct dma_attrs *)0);
  
#line 653 
  if (sc == (struct octeon_soft_command *)0) {
    
#line 654 
    __retres = 1;
    
#line 654 
    goto return_label;
  }
  else ;
  
#line 656 
  sc->dma_addr = dma_addr;
  
#line 657 
  sc->size = 1024U;
  
#line 659 
  list_add_tail(& sc->node,& oct->sc_buf_pool.head);
  
#line 648 
  i += 1;
  ldv_46791: 
#line 649 
  ;
  
#line 648 
  if (i <= 15) 
#line 650 
               goto ldv_46790; else 
#line 653 
                                    goto ldv_46792;
  ldv_46792: 
#line 654 
  ;
  
#line 662 
  __retres = 0;
  return_label: 
#line 662 
                return __retres;
}


#line 665  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/request_manager.c"
int octeon_free_sc_buffer_pool(struct octeon_device *oct)
{
  int __retres;
  struct list_head *tmp;
  struct list_head *tmp2;
  struct octeon_soft_command *sc;
  
#line 670 
  ldv_spin_lock_83(& oct->sc_buf_pool.lock);
  
#line 672 
  tmp = oct->sc_buf_pool.head.next;
  
#line 672 
  tmp2 = tmp->next;
  
#line 672 
  goto ldv_46800;
  ldv_46799: 
#line 673 
  ;
  
#line 673 
  list_del(tmp);
  
#line 675 
  sc = (struct octeon_soft_command *)tmp;
  
#line 677 
  dma_free_attrs(& (oct->pci_dev)->dev,(unsigned long)sc->size,(void *)sc,sc->dma_addr,(struct dma_attrs *)0);
  
#line 672 
  tmp = tmp2;
  
#line 672 
  tmp2 = tmp->next;
  ldv_46800: 
#line 673 
  ;
  
#line 672 
  if (& oct->sc_buf_pool.head != tmp) 
#line 674 
                                      goto ldv_46799; else 
#line 677 
                                                           goto ldv_46801;
  ldv_46801: 
#line 678 
  ;
  
#line 680 
  INIT_LIST_HEAD(& oct->sc_buf_pool.head);
  
#line 682 
  ldv_spin_unlock_84(& oct->sc_buf_pool.lock);
  
#line 684 
  __retres = 0;
  
#line 684 
  return __retres;
}


#line 687  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/request_manager.c"
struct octeon_soft_command *octeon_alloc_soft_command(struct octeon_device *oct, u32 datasize, u32 rdatasize, u32 ctxsize)
{
  struct octeon_soft_command *__retres;
  u64 dma_addr;
  u32 size;
  struct list_head *tmp;
  int tmp_0;
  
#line 694 
  u32 offset = 208U;
  
#line 695 
  struct octeon_soft_command *sc = (struct octeon_soft_command *)0;
  
#line 698 
  if ((long)(((offset + datasize) + rdatasize) + ctxsize > 1024U) != 0L) {
    
#line 700 
    ldv_inline_asm();
    
#line 698 
    ;
  }
  else ;
  
#line 701 
  ldv_spin_lock_85(& oct->sc_buf_pool.lock);
  
#line 703 
  tmp_0 = list_empty((struct list_head const *)(& oct->sc_buf_pool.head));
  
#line 703 
  if (tmp_0 != 0) {
    
#line 704 
    ldv_spin_unlock_86(& oct->sc_buf_pool.lock);
    
#line 705 
    __retres = (struct octeon_soft_command *)0;
    
#line 705 
    goto return_label;
  }
  else ;
  
#line 708 
  tmp = oct->sc_buf_pool.head.next;
  
#line 708 
  goto ldv_46815;
  ldv_46814: 
#line 709 
  ;
  
#line 709 
  goto ldv_46813;
  
#line 708 
  tmp = tmp->next;
  ldv_46815: 
#line 709 
  ;
  
#line 708 
  if (& oct->sc_buf_pool.head != tmp) 
#line 710 
                                      goto ldv_46814; else 
#line 713 
                                                           goto ldv_46813;
  ldv_46813: 
#line 714 
  ;
  
#line 711 
  list_del(tmp);
  
#line 713 
  atomic_inc(& oct->sc_buf_pool.alloc_buf_count);
  
#line 715 
  ldv_spin_unlock_87(& oct->sc_buf_pool.lock);
  
#line 717 
  sc = (struct octeon_soft_command *)tmp;
  
#line 719 
  dma_addr = sc->dma_addr;
  
#line 720 
  size = sc->size;
  
#line 722 
  memset((void *)sc,0,(unsigned long)sc->size);
  
#line 724 
  sc->dma_addr = dma_addr;
  
#line 725 
  sc->size = size;
  
#line 727 
  if (ctxsize != 0U) {
    
#line 728 
    sc->ctxptr = (void *)sc + offset;
    
#line 729 
    sc->ctxsize = ctxsize;
  }
  else ;
  
#line 733 
  offset = ((offset + ctxsize) + 127U) & 4294967168U;
  
#line 735 
  if (datasize != 0U) {
    
#line 736 
    sc->virtdptr = (void *)sc + offset;
    
#line 737 
    sc->dmadptr = (unsigned long long)offset + dma_addr;
    
#line 738 
    sc->datasize = datasize;
  }
  else ;
  
#line 742 
  offset = ((offset + datasize) + 127U) & 4294967168U;
  
#line 744 
  if (rdatasize != 0U) {
    
#line 745 
    if ((long)(rdatasize <= 15U) != 0L) {
      
#line 747 
      ldv_inline_asm();
      
#line 745 
      ;
    }
    else ;
    
#line 746 
    sc->virtrptr = (void *)sc + offset;
    
#line 747 
    sc->dmarptr = (unsigned long long)offset + dma_addr;
    
#line 748 
    sc->rdatasize = rdatasize;
    
#line 749 
    sc->status_word = (u64 *)sc->virtrptr + ((unsigned long)rdatasize + 18446744073709551608U);
  }
  else ;
  
#line 752 
  __retres = sc;
  return_label: 
#line 752 
                return __retres;
}


#line 755  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/request_manager.c"
void octeon_free_soft_command(struct octeon_device *oct, struct octeon_soft_command *sc)
{
  
#line 758 
  ldv_spin_lock_88(& oct->sc_buf_pool.lock);
  
#line 760 
  list_add_tail(& sc->node,& oct->sc_buf_pool.head);
  
#line 762 
  atomic_dec(& oct->sc_buf_pool.alloc_buf_count);
  
#line 764 
  ldv_spin_unlock_89(& oct->sc_buf_pool.lock);
  
#line 765 
  return;
}


#line 58  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_request_manager.c.aux"
_Bool ldv_emg_queue_delayed_work(struct workqueue_struct *arg0, struct delayed_work *arg1, unsigned long arg2);


#line 108  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_request_manager.c.aux"
static void atomic_sub_0(int i, atomic_t *v)
{
  
#line 111 
  ldv_atomic_sub(i,v);
  
#line 112 
  return;
}


#line 122  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_request_manager.c.aux"
static void atomic_inc(atomic_t *v)
{
  
#line 125 
  ldv_atomic_inc(v);
  
#line 126 
  return;
}


#line 129  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_request_manager.c.aux"
static void atomic_dec(atomic_t *v)
{
  
#line 132 
  ldv_atomic_dec(v);
  
#line 133 
  return;
}


#line 747  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_request_manager.c.aux"
static bool ldv_queue_delayed_work_73(struct workqueue_struct *wq, struct delayed_work *dwork, unsigned long delay)
{
  bool __retres;
  bool tmp;
  
#line 751 
  tmp = ldv_emg_queue_delayed_work(wq,dwork,delay);
  
#line 751 
  __retres = tmp != 0;
  
#line 751 
  return __retres;
}


#line 755  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_request_manager.c.aux"
static void ldv_spin_lock_bh_74(spinlock_t *lock)
{
  
#line 759 
  ldv_spin_model_lock((char *)"lock_of_octeon_response_list");
  
#line 761 
  spin_lock_bh_0(lock);
  
#line 762 
  return;
}


#line 765  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_request_manager.c.aux"
static void ldv_spin_unlock_bh_75_0(spinlock_t *lock)
{
  
#line 769 
  ldv_spin_model_unlock((char *)"lock_of_octeon_response_list");
  
#line 771 
  spin_unlock_bh_0(lock);
  
#line 772 
  return;
}


#line 775  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_request_manager.c.aux"
static void ldv_spin_lock_bh_76(spinlock_t *lock)
{
  
#line 779 
  ldv_spin_model_lock((char *)"lock_of_octeon_instr_queue");
  
#line 781 
  spin_lock_bh_0(lock);
  
#line 782 
  return;
}


#line 785  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_request_manager.c.aux"
static void ldv_spin_unlock_bh_77(spinlock_t *lock)
{
  
#line 789 
  ldv_spin_model_unlock((char *)"lock_of_octeon_instr_queue");
  
#line 791 
  spin_unlock_bh_0(lock);
  
#line 792 
  return;
}


#line 795  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_request_manager.c.aux"
static void ldv_spin_lock_bh_78(spinlock_t *lock)
{
  
#line 799 
  ldv_spin_model_lock((char *)"lock_of_octeon_instr_queue");
  
#line 801 
  spin_lock_bh_0(lock);
  
#line 802 
  return;
}


#line 805  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_request_manager.c.aux"
static void ldv_spin_unlock_bh_79(spinlock_t *lock)
{
  
#line 809 
  ldv_spin_model_unlock((char *)"lock_of_octeon_instr_queue");
  
#line 811 
  spin_unlock_bh_0(lock);
  
#line 812 
  return;
}


#line 815  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_request_manager.c.aux"
static bool ldv_queue_delayed_work_80(struct workqueue_struct *wq, struct delayed_work *dwork, unsigned long delay)
{
  bool __retres;
  bool tmp;
  
#line 819 
  tmp = ldv_emg_queue_delayed_work(wq,dwork,delay);
  
#line 819 
  __retres = tmp != 0;
  
#line 819 
  return __retres;
}


#line 823  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_request_manager.c.aux"
static void ldv_spin_lock_bh_81(spinlock_t *lock)
{
  
#line 827 
  ldv_spin_model_lock((char *)"lock_of_octeon_instr_queue");
  
#line 829 
  spin_lock_bh_0(lock);
  
#line 830 
  return;
}


#line 833  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_request_manager.c.aux"
static void ldv_spin_unlock_bh_82(spinlock_t *lock)
{
  
#line 837 
  ldv_spin_model_unlock((char *)"lock_of_octeon_instr_queue");
  
#line 839 
  spin_unlock_bh_0(lock);
  
#line 840 
  return;
}


#line 843  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_request_manager.c.aux"
static void ldv_spin_lock_83(spinlock_t *lock)
{
  
#line 847 
  ldv_spin_model_lock((char *)"lock_of_octeon_sc_buffer_pool");
  
#line 849 
  spin_lock_0(lock);
  
#line 850 
  return;
}


#line 853  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_request_manager.c.aux"
static void ldv_spin_unlock_84(spinlock_t *lock)
{
  
#line 857 
  ldv_spin_model_unlock((char *)"lock_of_octeon_sc_buffer_pool");
  
#line 859 
  spin_unlock_0(lock);
  
#line 860 
  return;
}


#line 863  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_request_manager.c.aux"
static void ldv_spin_lock_85(spinlock_t *lock)
{
  
#line 867 
  ldv_spin_model_lock((char *)"lock_of_octeon_sc_buffer_pool");
  
#line 869 
  spin_lock_0(lock);
  
#line 870 
  return;
}


#line 873  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_request_manager.c.aux"
static void ldv_spin_unlock_86(spinlock_t *lock)
{
  
#line 877 
  ldv_spin_model_unlock((char *)"lock_of_octeon_sc_buffer_pool");
  
#line 879 
  spin_unlock_0(lock);
  
#line 880 
  return;
}


#line 883  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_request_manager.c.aux"
static void ldv_spin_unlock_87(spinlock_t *lock)
{
  
#line 887 
  ldv_spin_model_unlock((char *)"lock_of_octeon_sc_buffer_pool");
  
#line 889 
  spin_unlock_0(lock);
  
#line 890 
  return;
}


#line 893  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_request_manager.c.aux"
static void ldv_spin_lock_88(spinlock_t *lock)
{
  
#line 897 
  ldv_spin_model_lock((char *)"lock_of_octeon_sc_buffer_pool");
  
#line 899 
  spin_lock_0(lock);
  
#line 900 
  return;
}


#line 903  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_request_manager.c.aux"
static void ldv_spin_unlock_89(spinlock_t *lock)
{
  
#line 907 
  ldv_spin_model_unlock((char *)"lock_of_octeon_sc_buffer_pool");
  
#line 909 
  spin_unlock_0(lock);
  
#line 910 
  return;
}

unsigned int __builtin_bswap32(unsigned int);


#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/swab.h"
__inline static __u32 __fswab32(__u32 val)
{
  __u32 tmp;
  
#line 60 
  tmp = __builtin_bswap32(val);
  
#line 60 
  return tmp;
}


#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
int printk(char const * , ...);


#line 405  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
int snprintf(char *, size_t, char const * , ...);


#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void list_add(struct list_head *new, struct list_head *head)
{
  
#line 63 
  __list_add(new,head,head->next);
  
#line 64 
  return;
}


#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
int memcmp(void const *, void const *, size_t);


#line 64 
size_t strlen(char const *);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/string.h"
char *strncpy(char *, char const *, __kernel_size_t);


#line 355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_bh_1(spinlock_t *lock)
{
  
#line 357 
  _raw_spin_lock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 358 
  return;
}


#line 383 
static void ldv_spin_lock_bh_73_0(spinlock_t *lock);


#line 387 
static void ldv_spin_lock_bh_75(spinlock_t *lock);


#line 391 
static void ldv_spin_lock_bh_79(spinlock_t *lock);


#line 395 
static void ldv_spin_lock_bh_82(spinlock_t *lock);


#line 399 
static void ldv_spin_lock_bh_84(spinlock_t *lock);


#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_bh_1(spinlock_t *lock)
{
  
#line 406 
  _raw_spin_unlock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 407 
  return;
}


#line 432 
static void ldv_spin_unlock_bh_74_0(spinlock_t *lock);


#line 436 
static void ldv_spin_unlock_bh_76(spinlock_t *lock);


#line 440 
static void ldv_spin_unlock_bh_77_0(spinlock_t *lock);


#line 444 
static void ldv_spin_unlock_bh_78(spinlock_t *lock);


#line 448 
static void ldv_spin_unlock_bh_80(spinlock_t *lock);


#line 452 
static void ldv_spin_unlock_bh_81(spinlock_t *lock);


#line 456 
static void ldv_spin_unlock_bh_83(spinlock_t *lock);


#line 460 
static void ldv_spin_unlock_bh_85(spinlock_t *lock);


#line 464 
static void ldv_spin_unlock_bh_86(spinlock_t *lock);


#line 478  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_irqrestore_0(spinlock_t *lock, unsigned long flags)
{
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
  }
  
#line 480 
  _raw_spin_unlock_irqrestore(& lock->__anonCompField_spinlock_18.rlock,flags);
  
#line 481 
  return;
}


#line 510 
static void ldv_spin_unlock_irqrestore_88(spinlock_t *lock, unsigned long flags);


#line 514 
static void ldv_spin_unlock_irqrestore_90(spinlock_t *lock, unsigned long flags);


#line 70  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_device.c.aux"
static void ldv___ldv_spin_lock_87(spinlock_t *ldv_func_arg1);


#line 74 
static void ldv___ldv_spin_lock_89(spinlock_t *ldv_func_arg1);


#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
void kfree(void const *);


#line 418 
static void *kmalloc_0(size_t size, gfp_t flags);


#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/crc32.h"
u32 crc32_le(u32, unsigned char const *, size_t);


#line 200  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_droq.h"
__inline static void octeon_free_recv_info(struct octeon_recv_info *recv_info)
{
  
#line 202 
  kfree((void const *)recv_info);
  
#line 203 
  return;
}


#line 392 
int octeon_register_dispatch_fn(struct octeon_device *oct, u16 opcode, u16 subcode, int (*fn)(struct octeon_recv_info *, void *), void *fn_arg);


#line 407 
int octeon_unregister_dispatch_fn(struct octeon_device *oct, u16 opcode, u16 subcode);


#line 407  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.h"
void octeon_init_device_list(int conf_type_0);


#line 410 
void octeon_free_device_mem(struct octeon_device *oct);


#line 416 
struct octeon_device *octeon_allocate_device(u32 pci_id, u32 priv_size);


#line 424 
int octeon_init_dispatch_list(struct octeon_device *oct);


#line 430 
void octeon_delete_dispatch_list(struct octeon_device *oct);


#line 436 
int octeon_core_drv_init(struct octeon_recv_info *recv_info, void *buf);


#line 461 
struct octeon_device *lio_get_device(u32 octeon_id);


#line 468 
int lio_get_device_id(void *dev);


#line 525 
int octeon_mem_access_ok(struct octeon_device *oct);


#line 537 
int octeon_wait_for_ddr_init(struct octeon_device *oct, u32 *timeout);


#line 588 
int octeon_console_send_cmd(struct octeon_device *oct, char *cmd_str, u32 wait_hundredths);


#line 601 
int octeon_download_firmware(struct octeon_device *oct, u8 const *data, size_t size);


#line 604 
char *lio_get_state_string(atomic_t *state_ptr);


#line 611 
int octeon_setup_instr_queues(struct octeon_device *oct);


#line 618 
int octeon_setup_output_queues(struct octeon_device *oct);


#line 620 
int octeon_get_tx_qsize(struct octeon_device *oct, u32 q_no);


#line 622 
int octeon_get_rx_qsize(struct octeon_device *oct, u32 q_no);


#line 627 
void octeon_set_io_queues_off(struct octeon_device *oct);


#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_main.h"
__inline static void octeon_swap_8B_data_0(u64 *data, u32 blocks)
{
  
#line 59 
  goto ldv_46134;
  ldv_46133: 
#line 60 
  ;
  
#line 60 
  __swab64s(data);
  
#line 61 
  blocks -= 1U;
  
#line 62 
  data += 1;
  ldv_46134: 
#line 63 
  ;
  
#line 59 
  if (blocks != 0U) 
#line 61 
                    goto ldv_46133; else 
#line 64 
                                         goto ldv_46135;
  ldv_46135: 
#line 65 
  ;
  
#line 66 
  return;
}


#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.h"
int lio_validate_cn6xxx_config_info(struct octeon_device *oct, struct octeon_config *conf6xxx);


#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_mem_ops.h"
void octeon_pci_write_core_mem(struct octeon_device *oct, u64 coreaddr, u8 *buf, u32 len);


#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
static struct octeon_config default_cn66xx_conf = {.card_type = (unsigned short)0U, .card_name = (char *)"210sv", .iq = {.max_iqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))32U, .pending_list_size = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(32))))65536U, .instr_type = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(32))))64U, .db_min = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))1U, .db_timeout = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))1U, .reserved = 0ULL}, .oq = {.max_oqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))32U, .info_ptr = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(32))))1U, .refill_threshold = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))128U, .oq_intr_pkt = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))64U, .oq_intr_time = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))100U, .pkts_per_intr = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))128U, .reserved = 0ULL}, .nic_if_cfg = {{.max_txqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))8U, .num_txqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))4U, .max_rxqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))8U, .num_rxqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))4U, .num_rx_descs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))2048U, .num_tx_descs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))2048U, .rx_buf_size = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))1536U, .gmx_port_id = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U, .base_queue = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))65535U, .reserved = 0ULL}, {.max_txqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))8U, .num_txqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))4U, .max_rxqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))8U, .num_rxqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))4U, .num_rx_descs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))2048U, .num_tx_descs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))2048U, .rx_buf_size = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))1536U, .gmx_port_id = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))1U, .base_queue = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))65535U, .reserved = 0ULL}}, .misc = {.ctrlq_grp = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))1U, .enable_sli_oq_bp = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .oct_link_query_interval = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(32))))100U, .host_link_query_interval = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(32))))500U}, .num_nic_ports = 2, .num_def_tx_descs = 2048, .num_def_rx_descs = 2048, .def_rx_buf_size = 1536};

#line 160  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
static struct octeon_config default_cn68xx_conf = {.card_type = (unsigned short)2U, .card_name = (char *)"410nv", .iq = {.max_iqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))32U, .pending_list_size = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(32))))65536U, .instr_type = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(32))))64U, .db_min = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))1U, .db_timeout = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))1U, .reserved = 0ULL}, .oq = {.max_oqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))32U, .info_ptr = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(32))))1U, .refill_threshold = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))128U, .oq_intr_pkt = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))64U, .oq_intr_time = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))100U, .pkts_per_intr = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))128U, .reserved = 0ULL}, .nic_if_cfg = {{.max_txqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))8U, .num_txqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))4U, .max_rxqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))8U, .num_rxqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))4U, .num_rx_descs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))2048U, .num_tx_descs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))2048U, .rx_buf_size = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))1536U, .gmx_port_id = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U, .base_queue = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))65535U, .reserved = 0ULL}, {.max_txqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))8U, .num_txqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))4U, .max_rxqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))8U, .num_rxqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))4U, .num_rx_descs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))2048U, .num_tx_descs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))2048U, .rx_buf_size = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))1536U, .gmx_port_id = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))1U, .base_queue = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))65535U, .reserved = 0ULL}, {.max_txqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))8U, .num_txqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))4U, .max_rxqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))8U, .num_rxqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))4U, .num_rx_descs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))2048U, .num_tx_descs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))2048U, .rx_buf_size = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))1536U, .gmx_port_id = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))2U, .base_queue = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))65535U, .reserved = 0ULL}, {.max_txqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))8U, .num_txqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))4U, .max_rxqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))8U, .num_rxqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))4U, .num_rx_descs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))2048U, .num_tx_descs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))2048U, .rx_buf_size = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))1536U, .gmx_port_id = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))3U, .base_queue = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))65535U, .reserved = 0ULL}}, .misc = {.ctrlq_grp = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))1U, .enable_sli_oq_bp = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .oct_link_query_interval = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(32))))100U, .host_link_query_interval = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(32))))500U}, .num_nic_ports = 4, .num_def_tx_descs = 2048, .num_def_rx_descs = 2048, .def_rx_buf_size = 1536};

#line 326  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
static struct octeon_config default_cn68xx_210nv_conf = {.card_type = (unsigned short)1U, .card_name = (char *)"210nv", .iq = {.max_iqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))32U, .pending_list_size = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(32))))65536U, .instr_type = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(32))))64U, .db_min = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))1U, .db_timeout = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))1U, .reserved = 0ULL}, .oq = {.max_oqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))32U, .info_ptr = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(32))))1U, .refill_threshold = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))128U, .oq_intr_pkt = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))64U, .oq_intr_time = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))100U, .pkts_per_intr = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))128U, .reserved = 0ULL}, .nic_if_cfg = {{.max_txqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))8U, .num_txqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))4U, .max_rxqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))8U, .num_rxqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))4U, .num_rx_descs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))2048U, .num_tx_descs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))2048U, .rx_buf_size = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))1536U, .gmx_port_id = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U, .base_queue = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))65535U, .reserved = 0ULL}, {.max_txqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))8U, .num_txqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))4U, .max_rxqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))8U, .num_rxqs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))4U, .num_rx_descs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))2048U, .num_tx_descs = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))2048U, .rx_buf_size = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))1536U, .gmx_port_id = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))1U, .base_queue = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))65535U, .reserved = 0ULL}}, .misc = {.ctrlq_grp = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))1U, .enable_sli_oq_bp = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .oct_link_query_interval = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(32))))100U, .host_link_query_interval = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(32))))500U}, .num_nic_ports = 2, .num_def_tx_descs = 2048, .num_def_rx_descs = 2048, .def_rx_buf_size = 1536};

#line 439  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
static struct octeon_config_ptr oct_conf_info[32U] = {{.conf_type = 0U}, {.conf_type = 0U}, {.conf_type = 0U}, {.conf_type = 0U}};

#line 451  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
static char oct_dev_state_str[14U][32U] = {{(char)'B', (char)'E', (char)'G', (char)'I', (char)'N', (char)'\000'}, {(char)'P', (char)'C', (char)'I', (char)'-', (char)'M', (char)'A', (char)'P', (char)'-', (char)'D', (char)'O', (char)'N', (char)'E', (char)'\000'}, {(char)'D', (char)'I', (char)'S', (char)'P', (char)'A', (char)'T', (char)'C', (char)'H', (char)'-', (char)'I', (char)'N', (char)'I', (char)'T', (char)'-', (char)'D', (char)'O', (char)'N', (char)'E', (char)'\000'}, {(char)'I', (char)'Q', (char)'-', (char)'I', (char)'N', (char)'I', (char)'T', (char)'-', (char)'D', (char)'O', (char)'N', (char)'E', (char)'\000'}, {(char)'S', (char)'C', (char)'B', (char)'U', (char)'F', (char)'F', (char)'-', (char)'P', (char)'O', (char)'O', (char)'L', (char)'-', (char)'I', (char)'N', (char)'I', (char)'T', (char)'-', (char)'D', (char)'O', (char)'N', (char)'E', (char)'\000'}, {(char)'R', (char)'E', (char)'S', (char)'P', (char)'L', (char)'I', (char)'S', (char)'T', (char)'-', (char)'I', (char)'N', (char)'I', (char)'T', (char)'-', (char)'D', (char)'O', (char)'N', (char)'E', (char)'\000'}, {(char)'D', (char)'R', (char)'O', (char)'Q', (char)'-', (char)'I', (char)'N', (char)'I', (char)'T', (char)'-', (char)'D', (char)'O', (char)'N', (char)'E', (char)'\000'}, {(char)'I', (char)'O', (char)'-', (char)'Q', (char)'U', (char)'E', (char)'U', (char)'E', (char)'S', (char)'-', (char)'I', (char)'N', (char)'I', (char)'T', (char)'-', (char)'D', (char)'O', (char)'N', (char)'E', (char)'\000'}, {(char)'C', (char)'O', (char)'N', (char)'S', (char)'O', (char)'L', (char)'E', (char)'-', (char)'I', (char)'N', (char)'I', (char)'T', (char)'-', (char)'D', (char)'O', (char)'N', (char)'E', (char)'\000'}, {(char)'H', (char)'O', (char)'S', (char)'T', (char)'-', (char)'R', (char)'E', (char)'A', (char)'D', (char)'Y', (char)'\000'}, {(char)'C', (char)'O', (char)'R', (char)'E', (char)'-', (char)'R', (char)'E', (char)'A', (char)'D', (char)'Y', (char)'\000'}, {(char)'R', (char)'U', (char)'N', (char)'N', (char)'I', (char)'N', (char)'G', (char)'\000'}, {(char)'I', (char)'N', (char)'-', (char)'R', (char)'E', (char)'S', (char)'E', (char)'T', (char)'\000'}, {(char)'I', (char)'N', (char)'V', (char)'A', (char)'L', (char)'I', (char)'D', (char)'\000'}};

#line 459  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
static char oct_dev_app_str[3U][32U] = {{(char)'B', (char)'A', (char)'S', (char)'E', (char)'\000'}, {(char)'N', (char)'I', (char)'C', (char)'\000'}, {(char)'U', (char)'N', (char)'K', (char)'N', (char)'O', (char)'W', (char)'N', (char)'\000'}};

#line 462  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
static struct octeon_device *octeon_device[32U];

#line 463  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
static u32 octeon_device_count;

#line 465  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
static struct octeon_core_setup core_setup[32U];

#line 467  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
static void oct_set_config_info(int oct_id, int conf_type_0)
{
  
#line 469 
  if (conf_type_0 != 0) 
#line 470 
                        conf_type_0 = 0; else ;
  
#line 471 
  oct_conf_info[oct_id].conf_type = (unsigned int)conf_type_0;
  
#line 472 
  return;
}


#line 474  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
void octeon_init_device_list(int conf_type_0)
{
  int i;
  
#line 478 
  memset((void *)(& octeon_device),0,256UL);
  
#line 479 
  i = 0;
  
#line 479 
  goto ldv_46676;
  ldv_46675: 
#line 480 
  ;
  
#line 480 
  oct_set_config_info(i,conf_type_0);
  
#line 479 
  i += 1;
  ldv_46676: 
#line 480 
  ;
  
#line 479 
  if (i <= 31) 
#line 481 
               goto ldv_46675; else 
#line 484 
                                    goto ldv_46677;
  ldv_46677: 
#line 485 
  ;
  
#line 486 
  return;
}


#line 483  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
static void *__retrieve_octeon_config_info(struct octeon_device *oct, u16 card_type)
{
  
#line 486 
  u32 oct_id = oct->octeon_id;
  
#line 487 
  void *ret = (void *)0;
  
#line 489 
  switch (oct_conf_info[oct_id].conf_type) {
    case (u32)0: 
#line 490 
    ;
    
#line 491 
    if ((unsigned int)oct->chip_id == 146U) 
#line 492 
                                            ret = (void *)(& default_cn66xx_conf);
    else 
      
#line 493 
      if ((unsigned int)oct->chip_id == 145U && (unsigned int)card_type == 1U) 
        
#line 495 
        ret = (void *)(& default_cn68xx_210nv_conf);
      else 
        
#line 496 
        if ((unsigned int)oct->chip_id == 145U && (unsigned int)card_type == 2U) 
          
#line 498 
          ret = (void *)(& default_cn68xx_conf); else ;
    
#line 500 
    goto ldv_46685;
    default: 
#line 501 
    ;
    
#line 502 
    goto ldv_46685;
  }
  ldv_46685: 
#line 504 
  ;
  
#line 504 
  return ret;
}


#line 507  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
static int __verify_octeon_config_info(struct octeon_device *oct, void *conf)
{
  int __retres;
  
#line 509 
  switch ((int)oct->chip_id) {
    int tmp;
    case 146: 
#line 510 
    ;
    case 145: 
#line 511 
    ;
    
#line 512 
    tmp = lio_validate_cn6xxx_config_info(oct,(struct octeon_config *)conf);
    
#line 512 
    __retres = tmp;
    
#line 512 
    goto return_label;
    default: 
#line 514 
    ;
    
#line 515 
    goto ldv_46694;
  }
  ldv_46694: 
#line 518 
  ;
  
#line 518 
  __retres = 1;
  return_label: 
#line 518 
                return __retres;
}


#line 521  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
void *oct_get_config_info(struct octeon_device *oct, u16 card_type)
{
  void *__retres;
  int tmp;
  
#line 523 
  void *conf = (void *)0;
  
#line 525 
  conf = __retrieve_octeon_config_info(oct,(unsigned short)((int)card_type));
  
#line 526 
  if (conf == (void *)0) {
    
#line 527 
    __retres = (void *)0;
    
#line 527 
    goto return_label;
  }
  else ;
  
#line 529 
  tmp = __verify_octeon_config_info(oct,conf);
  
#line 529 
  if (tmp != 0) {
    
#line 530 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Configuration verification failed\n");
    
#line 531 
    __retres = (void *)0;
    
#line 531 
    goto return_label;
  }
  else ;
  
#line 534 
  __retres = conf;
  return_label: 
#line 534 
                return __retres;
}


#line 537  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
char *lio_get_state_string(atomic_t *state_ptr)
{
  char *__retres;
  
#line 539 
  s32 istate = atomic_read((atomic_t const *)state_ptr);
  
#line 541 
  if ((unsigned int)istate > 13U) {
    
#line 542 
    __retres = (char *)(& oct_dev_state_str[13]);
    
#line 542 
    goto return_label;
  }
  else ;
  
#line 543 
  __retres = (char *)(& oct_dev_state_str[istate]);
  return_label: 
#line 543 
                return __retres;
}


#line 546  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
static char *get_oct_app_string(u32 app_mode)
{
  char *__retres;
  
#line 548 
  if (app_mode <= 1U) {
    
#line 549 
    __retres = (char *)(& oct_dev_app_str[app_mode]);
    
#line 549 
    goto return_label;
  }
  else ;
  
#line 550 
  __retres = (char *)(& oct_dev_app_str[2]);
  return_label: 
#line 550 
                return __retres;
}


#line 553  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
int octeon_download_firmware(struct octeon_device *oct, u8 const *data, size_t size)
{
  int __retres;
  u8 *p;
  u8 *buffer;
  u32 crc32_result;
  u64 load_addr;
  u32 image_len;
  struct octeon_firmware_file_header *h;
  u32 i;
  int tmp_0;
  u32 tmp_1;
  unsigned int tmp_5;
  int tmp_7;
  size_t tmp_6;
  int tmp_11;
  u32 tmp_15;
  unsigned int tmp_19;
  unsigned int tmp_21;
  
#line 556 
  int ret = 0;
  
#line 565 
  if (size <= 1311UL) {
    
#line 566 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Firmware file too small (%d < %d).\n",(unsigned int)size,1312U);
    
#line 569 
    __retres = -22;
    
#line 569 
    goto return_label;
  }
  else ;
  
#line 572 
  h = (struct octeon_firmware_file_header *)data;
  
#line 574 
  if (0 != 0) 
#line 574 
              tmp_0 = ((((h->magic << 24) | ((h->magic << 8) & 16711680U)) | ((h->magic >> 8) & 65280U)) | (h->magic >> 24)) != 1129204035U;
  else {
    __u32 tmp;
    
#line 574 
    tmp = __fswab32(h->magic);
    
#line 574 
    tmp_0 = tmp != 1129204035U;
  }
  
#line 574 
  if (tmp_0) {
    
#line 575 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Unrecognized firmware file.\n");
    
#line 576 
    __retres = -22;
    
#line 576 
    goto return_label;
  }
  else ;
  
#line 582 
  tmp_1 = crc32_le(4294967295U,data,1308UL);
  
#line 579 
  crc32_result = ~ tmp_1;
  
#line 583 
  if (0 != 0) 
#line 583 
              tmp_5 = (((h->crc32 << 24) | ((h->crc32 << 8) & 16711680U)) | ((h->crc32 >> 8) & 65280U)) | (h->crc32 >> 24); else 
                                                                    
#line 583 
                                                                    tmp_5 = __fswab32(h->crc32);
  
#line 583 
  ;
  
#line 583 
  if (tmp_5 != crc32_result) {
    unsigned int tmp_3;
    
#line 584 
    if (0 != 0) 
#line 584 
                tmp_3 = (((h->crc32 << 24) | ((h->crc32 << 8) & 16711680U)) | ((h->crc32 >> 8) & 65280U)) | (h->crc32 >> 24); else 
                                                                    
#line 585 
                                                                    tmp_3 = __fswab32(h->crc32);
    
#line 584 
    ;
    
#line 584 
    ;
    
#line 584 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Firmware CRC mismatch (0x%08x != 0x%08x).\n",crc32_result,tmp_3);
    
#line 586 
    __retres = -22;
    
#line 586 
    goto return_label;
  }
  else ;
  
#line 589 
  tmp_6 = strlen("1.1.9");
  
#line 589 
  ;
  
#line 589 
  tmp_7 = memcmp((void const *)"1.1.9",(void const *)(& h->version),tmp_6);
  
#line 589 
  if (tmp_7 != 0) {
    
#line 590 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Unmatched firmware version. Expected %s, got %s.\n",(char *)"1.1.9",(char *)(& h->version));
    
#line 592 
    __retres = -22;
    
#line 592 
    goto return_label;
  }
  else ;
  
#line 595 
  if (0 != 0) 
#line 595 
              tmp_11 = ((((h->num_images << 24) | ((h->num_images << 8) & 16711680U)) | ((h->num_images >> 8) & 65280U)) | (h->num_images >> 24)) > 16U;
  else {
    __u32 tmp_10;
    
#line 595 
    tmp_10 = __fswab32(h->num_images);
    
#line 595 
    tmp_11 = tmp_10 > 16U;
  }
  
#line 595 
  if (tmp_11) {
    unsigned int tmp_9;
    
#line 596 
    if (0 != 0) 
#line 596 
                tmp_9 = (((h->num_images << 24) | ((h->num_images << 8) & 16711680U)) | ((h->num_images >> 8) & 65280U)) | (h->num_images >> 24); else 
                                                                    
#line 597 
                                                                    tmp_9 = __fswab32(h->num_images);
    
#line 596 
    ;
    
#line 596 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Too many images in firmware file (%d).\n",tmp_9);
    
#line 598 
    __retres = -22;
    
#line 598 
    goto return_label;
  }
  else ;
  
#line 601 
  _dev_info((struct device const *)(& (oct->pci_dev)->dev),"Firmware version: %s\n",(char *)(& h->version));
  
#line 602 
  snprintf((char *)(& oct->fw_info.liquidio_firmware_version),32UL,"LIQUIDIO: %s",(char *)(& h->version));
  
#line 605 
  buffer = (u8 *)kmalloc_0(size,208U);
  
#line 606 
  if (buffer == (u8 *)0U) {
    
#line 607 
    __retres = -12;
    
#line 607 
    goto return_label;
  }
  else ;
  
#line 609 
  memcpy((void *)buffer,(void const *)data,size);
  
#line 611 
  p = buffer + 1312U;
  
#line 614 
  i = 0U;
  
#line 614 
  goto ldv_46724;
  ldv_46723: 
#line 615 
  ;
  
#line 615 
  if (0 != 0) 
#line 615 
              load_addr = (((((((h->desc[i].addr << 56) | ((h->desc[i].addr << 40) & 71776119061217280ULL)) | ((h->desc[i].addr << 24) & 280375465082880ULL)) | ((h->desc[i].addr << 8) & 1095216660480ULL)) | ((h->desc[i].addr >> 8) & 4278190080ULL)) | ((h->desc[i].addr >> 24) & 16711680ULL)) | ((h->desc[i].addr >> 40) & 65280ULL)) | (h->desc[i].addr >> 56); else 
                                                                    
#line 615 
                                                                    load_addr = __fswab64(h->desc[i].addr);
  
#line 616 
  if (0 != 0) 
#line 616 
              image_len = (((h->desc[i].len << 24) | ((h->desc[i].len << 8) & 16711680U)) | ((h->desc[i].len >> 8) & 65280U)) | (h->desc[i].len >> 24); else 
                                                                    
#line 616 
                                                                    image_len = __fswab32(h->desc[i].len);
  
#line 619 
  tmp_15 = crc32_le(4294967295U,(unsigned char const *)p,(unsigned long)image_len);
  
#line 619 
  crc32_result = ~ tmp_15;
  
#line 620 
  if (0 != 0) 
#line 620 
              tmp_19 = (((h->desc[i].crc32 << 24) | ((h->desc[i].crc32 << 8) & 16711680U)) | ((h->desc[i].crc32 >> 8) & 65280U)) | (h->desc[i].crc32 >> 24); else 
                                                                    
#line 620 
                                                                    tmp_19 = __fswab32(h->desc[i].crc32);
  
#line 620 
  ;
  
#line 620 
  if (tmp_19 != crc32_result) {
    unsigned int tmp_17;
    
#line 622 
    if (0 != 0) 
#line 622 
                tmp_17 = (((h->desc[i].crc32 << 24) | ((h->desc[i].crc32 << 8) & 16711680U)) | ((h->desc[i].crc32 >> 8) & 65280U)) | (h->desc[i].crc32 >> 24); else 
                                                                    
#line 624 
                                                                    tmp_17 = __fswab32(h->desc[i].crc32);
    
#line 621 
    ;
    
#line 621 
    ;
    
#line 621 
    ;
    
#line 621 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Firmware CRC mismatch in image %d (0x%08x != 0x%08x).\n",i,crc32_result,tmp_17);
    
#line 625 
    ret = -22;
    
#line 626 
    goto done_downloading;
  }
  else ;
  
#line 630 
  octeon_pci_write_core_mem(oct,load_addr,p,image_len);
  
#line 632 
  p += image_len;
  {
    
#line 633 
    struct _ddebug descriptor = {.modname = "liquidio", .function = "octeon_download_firmware", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c", .format = "Downloaded image %d (%d bytes) to address 0x%016llx\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))635U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 633 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 633 
                                                        __dynamic_dev_dbg(& descriptor,(struct device const *)(& (oct->pci_dev)->dev),"Downloaded image %d (%d bytes) to address 0x%016llx\n",i,image_len,load_addr); else ;
  }
  
#line 614 
  i += 1U;
  ldv_46724: 
#line 615 
  ;
  
#line 614 
  if (0 != 0) 
#line 614 
              tmp_21 = (((h->num_images << 24) | ((h->num_images << 8) & 16711680U)) | ((h->num_images >> 8) & 65280U)) | (h->num_images >> 24); else 
                                                                    
#line 614 
                                                                    tmp_21 = __fswab32(h->num_images);
  
#line 614 
  ;
  
#line 614 
  if (tmp_21 > i) 
#line 616 
                  goto ldv_46723; else 
#line 619 
                                       goto ldv_46725;
  ldv_46725: 
#line 620 
  ;
  
#line 639 
  ret = octeon_console_send_cmd(oct,(char *)(& h->bootcmd),50U);
  done_downloading: 
#line 641 
  ;
  
#line 642 
  kfree((void const *)buffer);
  
#line 644 
  __retres = ret;
  return_label: 
#line 644 
                return __retres;
}


#line 647  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
void octeon_free_device_mem(struct octeon_device *oct)
{
  u32 i;
  
#line 651 
  i = 0U;
  
#line 651 
  goto ldv_46731;
  ldv_46730: 
#line 652 
  ;
  
#line 653 
  vfree((void const *)oct->droq[i]);
  
#line 651 
  i += 1U;
  ldv_46731: 
#line 652 
  ;
  
#line 651 
  if (i <= 31U) 
#line 653 
                goto ldv_46730; else 
#line 656 
                                     goto ldv_46732;
  ldv_46732: 
#line 657 
  ;
  
#line 656 
  i = 0U;
  
#line 656 
  goto ldv_46734;
  ldv_46733: 
#line 657 
  ;
  
#line 658 
  vfree((void const *)oct->instr_queue[i]);
  
#line 656 
  i += 1U;
  ldv_46734: 
#line 657 
  ;
  
#line 656 
  if (i <= 31U) 
#line 658 
                goto ldv_46733; else 
#line 661 
                                     goto ldv_46735;
  ldv_46735: 
#line 662 
  ;
  
#line 661 
  i = oct->octeon_id;
  
#line 662 
  vfree((void const *)oct);
  
#line 664 
  octeon_device[i] = (struct octeon_device *)0;
  
#line 665 
  octeon_device_count -= 1U;
  
#line 666 
  return;
}


#line 668  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
static struct octeon_device *octeon_allocate_device_mem(u32 pci_id, u32 priv_size)
{
  struct octeon_device *__retres;
  struct octeon_device *oct;
  u32 size;
  
#line 672 
  u8 *buf = (u8 *)0U;
  
#line 673 
  u32 octdevsize = 0U;
  
#line 673 
  u32 configsize = 0U;
  
#line 675 
  switch (pci_id) {
    case (u32)145: 
#line 676 
    ;
    case (u32)146: 
#line 677 
    ;
    
#line 678 
    configsize = 104U;
    
#line 679 
    goto ldv_46747;
    default: 
#line 681 
    ;
    
#line 682 
    printk("\001","octeon_allocate_device_mem",pci_id);
    
#line 685 
    __retres = (struct octeon_device *)0;
    
#line 685 
    goto return_label;
  }
  ldv_46747: 
#line 688 
  ;
  
#line 688 
  if ((configsize & 7U) != 0U) 
#line 689 
                               configsize = (configsize & 4294967288U) + 8U; else ;
  
#line 691 
  octdevsize = 36120U;
  
#line 692 
  if ((octdevsize & 7U) != 0U) 
#line 693 
                               octdevsize = (octdevsize & 4294967288U) + 8U; else ;
  
#line 695 
  if ((priv_size & 7U) != 0U) 
#line 696 
                              priv_size = (priv_size & 4294967288U) + 8U; else ;
  
#line 698 
  size = ((octdevsize + priv_size) + configsize) + 2560U;
  
#line 701 
  buf = (u8 *)vmalloc((unsigned long)size);
  
#line 702 
  if (buf == (u8 *)0U) {
    
#line 703 
    __retres = (struct octeon_device *)0;
    
#line 703 
    goto return_label;
  }
  else ;
  
#line 705 
  memset((void *)buf,0,(unsigned long)size);
  
#line 707 
  oct = (struct octeon_device *)buf;
  
#line 708 
  oct->priv = (void *)(buf + octdevsize);
  
#line 709 
  oct->chip = (void *)(buf + (octdevsize + priv_size));
  
#line 710 
  oct->dispatch.dlist = (struct octeon_dispatch *)(buf + ((octdevsize + priv_size) + configsize));
  
#line 713 
  __retres = oct;
  return_label: 
#line 713 
                return __retres;
}


#line 716  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
struct octeon_device *octeon_allocate_device(u32 pci_id, u32 priv_size)
{
  struct octeon_device *__retres;
  
#line 719 
  u32 oct_idx = 0U;
  
#line 720 
  struct octeon_device *oct = (struct octeon_device *)0;
  
#line 722 
  oct_idx = 0U;
  
#line 722 
  goto ldv_46758;
  ldv_46757: 
#line 723 
  ;
  
#line 723 
  if (octeon_device[oct_idx] == (struct octeon_device *)0) 
#line 724 
                                                           goto ldv_46756; else ;
  
#line 722 
  oct_idx += 1U;
  ldv_46758: 
#line 723 
  ;
  
#line 722 
  if (oct_idx <= 31U) 
#line 724 
                      goto ldv_46757; else 
#line 727 
                                           goto ldv_46756;
  ldv_46756: 
#line 728 
  ;
  
#line 726 
  if (oct_idx == 32U) {
    
#line 727 
    __retres = (struct octeon_device *)0;
    
#line 727 
    goto return_label;
  }
  else ;
  
#line 729 
  oct = octeon_allocate_device_mem(pci_id,priv_size);
  
#line 730 
  if (oct == (struct octeon_device *)0) {
    
#line 731 
    __retres = (struct octeon_device *)0;
    
#line 731 
    goto return_label;
  }
  else ;
  
#line 733 
  spinlock_check(& oct->pci_win_lock);
  {
    struct lock_class_key __key;
    
#line 733 
    __raw_spin_lock_init(& oct->pci_win_lock.__anonCompField_spinlock_18.rlock,"&(&oct->pci_win_lock)->rlock",& __key);
  }
  
#line 734 
  spinlock_check(& oct->mem_access_lock);
  {
    struct lock_class_key __key_0;
    
#line 734 
    __raw_spin_lock_init(& oct->mem_access_lock.__anonCompField_spinlock_18.rlock,"&(&oct->mem_access_lock)->rlock",& __key_0);
  }
  
#line 736 
  octeon_device_count += 1U;
  
#line 737 
  octeon_device[oct_idx] = oct;
  
#line 739 
  oct->octeon_id = oct_idx;
  
#line 740 
  snprintf((char *)(& oct->device_name),32UL,"LiquidIO%d",oct->octeon_id);
  
#line 743 
  __retres = oct;
  return_label: 
#line 743 
                return __retres;
}


#line 746  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
int octeon_setup_instr_queues(struct octeon_device *oct)
{
  int __retres;
  u32 i;
  int tmp_0;
  
#line 748 
  u32 num_iqs = 0U;
  
#line 749 
  u32 num_descs = 0U;
  
#line 752 
  if ((unsigned int)oct->chip_id + 65391U <= 1U) {
    
#line 753 
    num_iqs = 1U;
    
#line 754 
    num_descs = (unsigned int)(((struct octeon_cn6xxx *)oct->chip)->conf)->num_def_tx_descs;
  }
  else ;
  
#line 758 
  oct->num_iqs = 0U;
  
#line 760 
  i = 0U;
  
#line 760 
  goto ldv_46768;
  ldv_46767: 
#line 761 
  ;
  
#line 762 
  oct->instr_queue[i] = (struct octeon_instr_queue *)vmalloc(248UL);
  
#line 763 
  if (oct->instr_queue[i] == (struct octeon_instr_queue *)0) {
    
#line 764 
    __retres = 1;
    
#line 764 
    goto return_label;
  }
  else ;
  
#line 766 
  memset((void *)oct->instr_queue[i],0,248UL);
  
#line 769 
  (oct->instr_queue[i])->app_ctx = (void *)((unsigned long)i);
  
#line 770 
  tmp_0 = octeon_init_instr_queue(oct,i,num_descs);
  
#line 770 
  if (tmp_0 != 0) {
    
#line 771 
    __retres = 1;
    
#line 771 
    goto return_label;
  }
  else ;
  
#line 773 
  oct->num_iqs += 1U;
  
#line 760 
  i += 1U;
  ldv_46768: 
#line 761 
  ;
  
#line 760 
  if (i < num_iqs) 
#line 762 
                   goto ldv_46767; else 
#line 765 
                                        goto ldv_46769;
  ldv_46769: 
#line 766 
  ;
  
#line 776 
  __retres = 0;
  return_label: 
#line 776 
                return __retres;
}


#line 779  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
int octeon_setup_output_queues(struct octeon_device *oct)
{
  int __retres;
  u32 i;
  int tmp_0;
  
#line 781 
  u32 num_oqs = 0U;
  
#line 782 
  u32 num_descs = 0U;
  
#line 783 
  u32 desc_size = 0U;
  
#line 786 
  if ((unsigned int)oct->chip_id + 65391U <= 1U) {
    
#line 788 
    num_oqs = 1U;
    
#line 789 
    num_descs = (unsigned int)(((struct octeon_cn6xxx *)oct->chip)->conf)->num_def_rx_descs;
    
#line 791 
    desc_size = (unsigned int)(((struct octeon_cn6xxx *)oct->chip)->conf)->def_rx_buf_size;
  }
  else ;
  
#line 795 
  oct->num_oqs = 0U;
  
#line 797 
  i = 0U;
  
#line 797 
  goto ldv_46778;
  ldv_46777: 
#line 798 
  ;
  
#line 798 
  oct->droq[i] = (struct octeon_droq *)vmalloc(640UL);
  
#line 799 
  if (oct->droq[i] == (struct octeon_droq *)0) {
    
#line 800 
    __retres = 1;
    
#line 800 
    goto return_label;
  }
  else ;
  
#line 802 
  memset((void *)oct->droq[i],0,640UL);
  
#line 804 
  tmp_0 = octeon_init_droq(oct,i,num_descs,desc_size,(void *)0);
  
#line 804 
  if (tmp_0 != 0) {
    
#line 805 
    __retres = 1;
    
#line 805 
    goto return_label;
  }
  else ;
  
#line 807 
  oct->num_oqs += 1U;
  
#line 797 
  i += 1U;
  ldv_46778: 
#line 798 
  ;
  
#line 797 
  if (i < num_oqs) 
#line 799 
                   goto ldv_46777; else 
#line 802 
                                        goto ldv_46779;
  ldv_46779: 
#line 803 
  ;
  
#line 810 
  __retres = 0;
  return_label: 
#line 810 
                return __retres;
}


#line 813  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
void octeon_set_io_queues_off(struct octeon_device *oct)
{
  
#line 817 
  writel(0U,(void volatile *)(oct->mmio[0].hw_addr + 4096U));
  
#line 818 
  writel(0U,(void volatile *)(oct->mmio[0].hw_addr + 4112U));
  
#line 819 
  return;
}


#line 821  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
void octeon_set_droq_pkt_op(struct octeon_device *oct, u32 q_no, u32 enable)
{
  
#line 825 
  u32 reg_val = 0U;
  
#line 828 
  reg_val = readl((void const volatile *)(oct->mmio[0].hw_addr + 4112U));
  
#line 830 
  if (enable != 0U) 
#line 831 
                    reg_val = (unsigned int)(1 << q_no) | reg_val; else 
                                                                    
#line 833 
                                                                    reg_val = (unsigned int)(~ (1 << q_no)) & reg_val;
  
#line 835 
  writel(reg_val,(void volatile *)(oct->mmio[0].hw_addr + 4112U));
  
#line 836 
  return;
}


#line 838  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
int octeon_init_dispatch_list(struct octeon_device *oct)
{
  int __retres;
  u32 i;
  
#line 842 
  oct->dispatch.count = 0U;
  
#line 844 
  i = 0U;
  
#line 844 
  goto ldv_46794;
  ldv_46793: 
#line 845 
  ;
  
#line 845 
  (oct->dispatch.dlist + i)->opcode = (unsigned short)0U;
  
#line 846 
  INIT_LIST_HEAD(& (oct->dispatch.dlist + i)->list);
  
#line 844 
  i += 1U;
  ldv_46794: 
#line 845 
  ;
  
#line 844 
  if (i <= 63U) 
#line 846 
                goto ldv_46793; else 
#line 849 
                                     goto ldv_46795;
  ldv_46795: 
#line 850 
  ;
  
#line 849 
  i = 0U;
  
#line 849 
  goto ldv_46797;
  ldv_46796: 
#line 850 
  ;
  
#line 850 
  octeon_register_reqtype_free_fn(oct,(int)i,(void (*)(void *))0);
  
#line 849 
  i += 1U;
  ldv_46797: 
#line 850 
  ;
  
#line 849 
  if (i <= 5U) 
#line 851 
               goto ldv_46796; else 
#line 854 
                                    goto ldv_46798;
  ldv_46798: 
#line 855 
  ;
  
#line 852 
  spinlock_check(& oct->dispatch.lock);
  {
    struct lock_class_key __key;
    
#line 852 
    __raw_spin_lock_init(& oct->dispatch.lock.__anonCompField_spinlock_18.rlock,"&(&oct->dispatch.lock)->rlock",& __key);
  }
  
#line 854 
  __retres = 0;
  
#line 854 
  return __retres;
}


#line 857  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
void octeon_delete_dispatch_list(struct octeon_device *oct)
{
  u32 i;
  struct list_head freelist;
  struct list_head *temp;
  struct list_head *tmp2;
  
#line 862 
  INIT_LIST_HEAD(& freelist);
  
#line 864 
  ldv_spin_lock_bh_73_0(& oct->dispatch.lock);
  
#line 866 
  i = 0U;
  
#line 866 
  goto ldv_46812;
  ldv_46811: 
#line 867 
  ;
  {
    struct list_head *dispatch;
    
#line 869 
    dispatch = & (oct->dispatch.dlist + i)->list;
    
#line 870 
    goto ldv_46809;
    ldv_46808: 
#line 871 
    ;
    
#line 871 
    temp = dispatch->next;
    
#line 872 
    list_del(temp);
    
#line 873 
    list_add_tail(temp,& freelist);
    ldv_46809: 
#line 874 
    ;
    
#line 870 
    if (dispatch->next != dispatch) 
#line 872 
                                    goto ldv_46808; else 
#line 875 
                                                         goto ldv_46810;
    ldv_46810: 
#line 876 
    ;
    
#line 876 
    (oct->dispatch.dlist + i)->opcode = (unsigned short)0U;
  }
  
#line 866 
  i += 1U;
  ldv_46812: 
#line 867 
  ;
  
#line 866 
  if (i <= 63U) 
#line 868 
                goto ldv_46811; else 
#line 871 
                                     goto ldv_46813;
  ldv_46813: 
#line 872 
  ;
  
#line 879 
  oct->dispatch.count = 0U;
  
#line 881 
  ldv_spin_unlock_bh_74_0(& oct->dispatch.lock);
  
#line 883 
  temp = freelist.next;
  
#line 883 
  tmp2 = temp->next;
  
#line 883 
  goto ldv_46815;
  ldv_46814: 
#line 884 
  ;
  
#line 884 
  list_del(temp);
  
#line 885 
  vfree((void const *)temp);
  
#line 883 
  temp = tmp2;
  
#line 883 
  tmp2 = temp->next;
  ldv_46815: 
#line 884 
  ;
  
#line 883 
  if (& freelist != temp) 
#line 885 
                          goto ldv_46814; else 
#line 888 
                                               goto ldv_46816;
  ldv_46816: 
#line 889 
  ;
  
#line 890 
  return;
}


#line 890  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
octeon_dispatch_fn_t octeon_get_dispatch(struct octeon_device *octeon_dev, u16 opcode, u16 subcode)
{
  octeon_dispatch_fn_t __retres;
  u32 idx;
  struct list_head *dispatch;
  
#line 895 
  int (*fn)(struct octeon_recv_info *, void *) = (int (*)(struct octeon_recv_info *, void *))0;
  
#line 896 
  u16 combined_opcode = (unsigned short)((((int)opcode << 8) & 3840) | ((int)subcode & 127));
  
#line 898 
  idx = (unsigned int)combined_opcode & 63U;
  
#line 900 
  ldv_spin_lock_bh_75(& octeon_dev->dispatch.lock);
  
#line 902 
  if (octeon_dev->dispatch.count == 0U) {
    
#line 903 
    ldv_spin_unlock_bh_76(& octeon_dev->dispatch.lock);
    
#line 904 
    __retres = (int (*)(struct octeon_recv_info *, void *))0;
    
#line 904 
    goto return_label;
  }
  else ;
  
#line 907 
  if ((unsigned int)(octeon_dev->dispatch.dlist + idx)->opcode == 0U) {
    
#line 908 
    ldv_spin_unlock_bh_77_0(& octeon_dev->dispatch.lock);
    
#line 909 
    __retres = (int (*)(struct octeon_recv_info *, void *))0;
    
#line 909 
    goto return_label;
  }
  else ;
  
#line 912 
  if ((int)(octeon_dev->dispatch.dlist + idx)->opcode == (int)combined_opcode) 
    
#line 913 
    fn = (octeon_dev->dispatch.dlist + idx)->dispatch_fn;
  else {
    
#line 915 
    dispatch = (octeon_dev->dispatch.dlist + idx)->list.next;
    
#line 915 
    goto ldv_46828;
    ldv_46827: 
#line 916 
    ;
    
#line 917 
    if ((int)((struct octeon_dispatch *)dispatch)->opcode == (int)combined_opcode) {
      
#line 919 
      fn = ((struct octeon_dispatch *)dispatch)->dispatch_fn;
      
#line 921 
      goto ldv_46826;
    }
    else ;
    
#line 915 
    dispatch = dispatch->next;
    ldv_46828: 
#line 916 
    ;
    
#line 915 
    if (& (octeon_dev->dispatch.dlist + idx)->list != dispatch) 
#line 917 
                                                                goto ldv_46827; else 
                                                                    
#line 920 
                                                                    goto ldv_46826;
    ldv_46826: 
#line 921 
    ;
  }
  
#line 926 
  ldv_spin_unlock_bh_78(& octeon_dev->dispatch.lock);
  
#line 927 
  __retres = fn;
  return_label: 
#line 927 
                return __retres;
}


#line 948  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
int octeon_register_dispatch_fn(struct octeon_device *oct, u16 opcode, u16 subcode, int (*fn)(struct octeon_recv_info *, void *), void *fn_arg)
{
  int __retres;
  u32 idx;
  int (*pfn)(struct octeon_recv_info *, void *);
  
#line 955 
  u16 combined_opcode = (unsigned short)((((int)opcode << 8) & 3840) | ((int)subcode & 127));
  
#line 957 
  idx = (unsigned int)combined_opcode & 63U;
  
#line 959 
  ldv_spin_lock_bh_79(& oct->dispatch.lock);
  
#line 961 
  if ((unsigned int)(oct->dispatch.dlist + idx)->opcode == 0U) {
    
#line 962 
    (oct->dispatch.dlist + idx)->opcode = combined_opcode;
    
#line 963 
    (oct->dispatch.dlist + idx)->dispatch_fn = fn;
    
#line 964 
    (oct->dispatch.dlist + idx)->arg = fn_arg;
    
#line 965 
    oct->dispatch.count += 1U;
    
#line 966 
    ldv_spin_unlock_bh_80(& oct->dispatch.lock);
    
#line 967 
    __retres = 0;
    
#line 967 
    goto return_label;
  }
  else ;
  
#line 970 
  ldv_spin_unlock_bh_81(& oct->dispatch.lock);
  
#line 975 
  pfn = octeon_get_dispatch(oct,(unsigned short)((int)opcode),(unsigned short)((int)subcode));
  
#line 976 
  if (pfn == (int (*)(struct octeon_recv_info *, void *))0) {
    struct octeon_dispatch *dispatch;
    {
      
#line 979 
      struct _ddebug descriptor = {.modname = "liquidio", .function = "octeon_register_dispatch_fn", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c", .format = "Adding opcode to dispatch list linked list\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))980U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 979 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 979 
                                                          __dynamic_dev_dbg(& descriptor,(struct device const *)(& (oct->pci_dev)->dev),"Adding opcode to dispatch list linked list\n"); else ;
    }
    
#line 981 
    dispatch = (struct octeon_dispatch *)vmalloc(40UL);
    
#line 983 
    if (dispatch == (struct octeon_dispatch *)0) {
      
#line 984 
      dev_err((struct device const *)(& (oct->pci_dev)->dev),"No memory to add dispatch function\n");
      
#line 986 
      __retres = 1;
      
#line 986 
      goto return_label;
    }
    else ;
    
#line 988 
    dispatch->opcode = combined_opcode;
    
#line 989 
    dispatch->dispatch_fn = fn;
    
#line 990 
    dispatch->arg = fn_arg;
    
#line 995 
    ldv_spin_lock_bh_82(& oct->dispatch.lock);
    
#line 996 
    list_add(& dispatch->list,& (oct->dispatch.dlist + idx)->list);
    
#line 997 
    oct->dispatch.count += 1U;
    
#line 998 
    ldv_spin_unlock_bh_83(& oct->dispatch.lock);
  }
  else {
    
#line 1001 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Found previously registered dispatch fn for opcode/subcode: %x/%x\n",(int)opcode,(int)subcode);
    
#line 1004 
    __retres = 1;
    
#line 1004 
    goto return_label;
  }
  
#line 1007 
  __retres = 0;
  return_label: 
#line 1007 
                return __retres;
}


#line 1024  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
int octeon_unregister_dispatch_fn(struct octeon_device *oct, u16 opcode, u16 subcode)
{
  int __retres;
  u32 idx;
  struct list_head *dispatch;
  struct list_head *tmp2;
  
#line 1027 
  int retval = 0;
  
#line 1029 
  struct list_head *dfree = (struct list_head *)0;
  
#line 1030 
  u16 combined_opcode = (unsigned short)((((int)opcode << 8) & 3840) | ((int)subcode & 127));
  
#line 1032 
  idx = (unsigned int)combined_opcode & 63U;
  
#line 1034 
  ldv_spin_lock_bh_84(& oct->dispatch.lock);
  
#line 1036 
  if (oct->dispatch.count == 0U) {
    
#line 1037 
    ldv_spin_unlock_bh_85(& oct->dispatch.lock);
    
#line 1038 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"No dispatch functions registered for this device\n");
    
#line 1040 
    __retres = 1;
    
#line 1040 
    goto return_label;
  }
  else ;
  
#line 1043 
  if ((int)(oct->dispatch.dlist + idx)->opcode == (int)combined_opcode) {
    
#line 1044 
    dispatch = & (oct->dispatch.dlist + idx)->list;
    
#line 1045 
    if (dispatch->next != dispatch) {
      
#line 1046 
      dispatch = dispatch->next;
      
#line 1047 
      (oct->dispatch.dlist + idx)->opcode = ((struct octeon_dispatch *)dispatch)->opcode;
      
#line 1049 
      (oct->dispatch.dlist + idx)->dispatch_fn = ((struct octeon_dispatch *)dispatch)->dispatch_fn;
      
#line 1052 
      (oct->dispatch.dlist + idx)->arg = ((struct octeon_dispatch *)dispatch)->arg;
      
#line 1054 
      list_del(dispatch);
      
#line 1055 
      dfree = dispatch;
    }
    else {
      
#line 1057 
      (oct->dispatch.dlist + idx)->opcode = (unsigned short)0U;
      
#line 1058 
      (oct->dispatch.dlist + idx)->dispatch_fn = (int (*)(struct octeon_recv_info *, void *))0;
      
#line 1059 
      (oct->dispatch.dlist + idx)->arg = (void *)0;
    }
  }
  else {
    
#line 1062 
    retval = 1;
    
#line 1063 
    dispatch = (oct->dispatch.dlist + idx)->list.next;
    
#line 1063 
    tmp2 = dispatch->next;
    
#line 1063 
    goto ldv_46854;
    ldv_46853: 
#line 1064 
    ;
    
#line 1066 
    if ((int)((struct octeon_dispatch *)dispatch)->opcode == (int)combined_opcode) {
      
#line 1068 
      list_del(dispatch);
      
#line 1069 
      dfree = dispatch;
      
#line 1070 
      retval = 0;
    }
    else ;
    
#line 1063 
    dispatch = tmp2;
    
#line 1063 
    tmp2 = dispatch->next;
    ldv_46854: 
#line 1064 
    ;
    
#line 1063 
    if (& (oct->dispatch.dlist + idx)->list != dispatch) 
#line 1065 
                                                         goto ldv_46853; else 
                                                                    
#line 1068 
                                                                    goto ldv_46855;
    ldv_46855: 
#line 1069 
    ;
  }
  
#line 1075 
  if (retval == 0) 
#line 1076 
                   oct->dispatch.count -= 1U; else ;
  
#line 1078 
  ldv_spin_unlock_bh_86(& oct->dispatch.lock);
  
#line 1079 
  vfree((void const *)dfree);
  
#line 1080 
  __retres = retval;
  return_label: 
#line 1080 
                return __retres;
}


#line 1083  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
int octeon_core_drv_init(struct octeon_recv_info *recv_info, void *buf)
{
  int __retres;
  u32 i;
  char app_name[16U];
  int tmp_0;
  char *tmp_1;
  
#line 1087 
  struct octeon_device *oct = (struct octeon_device *)buf;
  
#line 1088 
  struct octeon_recv_pkt *recv_pkt = recv_info->recv_pkt;
  
#line 1089 
  struct octeon_core_setup *cs = (struct octeon_core_setup *)0;
  
#line 1090 
  u32 num_nic_ports = 0U;
  
#line 1092 
  if ((unsigned int)oct->chip_id + 65391U <= 1U) 
#line 1093 
                                                 num_nic_ports = (unsigned int)(((struct octeon_cn6xxx *)oct->chip)->conf)->num_nic_ports; else ;
  
#line 1096 
  tmp_0 = atomic_read((atomic_t const *)(& oct->status));
  
#line 1096 
  if (tmp_0 > 10) {
    int tmp;
    
#line 1097 
    tmp = atomic_read((atomic_t const *)(& oct->status));
    
#line 1097 
    ;
    
#line 1097 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Received CORE OK when device state is 0x%x\n",tmp);
    
#line 1099 
    goto core_drv_init_err;
  }
  else ;
  
#line 1103 
  tmp_1 = get_oct_app_string((unsigned int)recv_pkt->rh.r_core_drv_init.app_mode);
  
#line 1102 
  strncpy((char *)(& app_name),(char const *)tmp_1,15UL);
  
#line 1106 
  oct->app_mode = (unsigned int)recv_pkt->rh.r_core_drv_init.app_mode;
  
#line 1107 
  if ((unsigned int)recv_pkt->rh.r_core_drv_init.app_mode == 1U) {
    
#line 1108 
    oct->fw_info.max_nic_ports = (unsigned int)recv_pkt->rh.r_core_drv_init.max_nic_ports;
    
#line 1110 
    oct->fw_info.num_gmx_ports = (unsigned int)recv_pkt->rh.r_core_drv_init.num_gmx_ports;
  }
  else ;
  
#line 1114 
  if (oct->fw_info.max_nic_ports < num_nic_ports) {
    
#line 1115 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Config has more ports than firmware allows (%d > %d).\n",num_nic_ports,oct->fw_info.max_nic_ports);
    
#line 1118 
    goto core_drv_init_err;
  }
  else ;
  
#line 1120 
  oct->fw_info.app_cap_flags = (unsigned long long)recv_pkt->rh.r_core_drv_init.app_cap_flags;
  
#line 1121 
  oct->fw_info.app_mode = (unsigned int)recv_pkt->rh.r_core_drv_init.app_mode;
  
#line 1123 
  atomic_set(& oct->status,10);
  
#line 1125 
  cs = & core_setup[oct->octeon_id];
  
#line 1127 
  if (recv_pkt->buffer_size[0] != 120U) {
    
#line 1128 
    struct _ddebug descriptor = {.modname = "liquidio", .function = "octeon_core_drv_init", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c", .format = "Core setup bytes expected %u found %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1130U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1128 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1128 
                                                        __dynamic_dev_dbg(& descriptor,(struct device const *)(& (oct->pci_dev)->dev),"Core setup bytes expected %u found %d\n",120U,recv_pkt->buffer_size[0]); else ;
  }
  else ;
  
#line 1133 
  memcpy((void *)cs,(void const *)((struct sk_buff *)recv_pkt->buffer_ptr[0])->data,120UL);
  
#line 1134 
  strncpy((char *)(& oct->boardinfo.name),(char const *)(& cs->boardname),32UL);
  
#line 1135 
  strncpy((char *)(& oct->boardinfo.serial_number),(char const *)(& cs->board_serial_number),64UL);
  
#line 1138 
  octeon_swap_8B_data_0((u64 *)cs,15U);
  
#line 1140 
  oct->boardinfo.major = cs->board_rev_major;
  
#line 1141 
  oct->boardinfo.minor = cs->board_rev_minor;
  
#line 1143 
  _dev_info((struct device const *)(& (oct->pci_dev)->dev),"Running %s (%llu Hz)\n",(char *)(& app_name),(long long)cs->corefreq);
  core_drv_init_err: 
#line 1147 
  ;
  
#line 1148 
  i = 0U;
  
#line 1148 
  goto ldv_46870;
  ldv_46869: 
#line 1149 
  ;
  
#line 1149 
  recv_buffer_free(recv_pkt->buffer_ptr[i]);
  
#line 1148 
  i += 1U;
  ldv_46870: 
#line 1149 
  ;
  
#line 1148 
  if ((unsigned int)recv_pkt->buffer_count > i) 
#line 1150 
                                                goto ldv_46869; else 
                                                                  
#line 1153 
                                                                  goto ldv_46871;
  ldv_46871: 
#line 1154 
  ;
  
#line 1150 
  octeon_free_recv_info(recv_info);
  
#line 1151 
  __retres = 0;
  
#line 1151 
  return __retres;
}


#line 1154  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
int octeon_get_tx_qsize(struct octeon_device *oct, u32 q_no)
{
  int __retres;
  
#line 1157 
  if ((oct != (struct octeon_device *)0 && q_no <= 31U) && (((unsigned long)oct->io_qmask.iq >> q_no) & 1UL) != 0UL) {
    
#line 1159 
    __retres = (int)(oct->instr_queue[q_no])->max_count;
    
#line 1159 
    goto return_label;
  }
  else ;
  
#line 1161 
  __retres = -1;
  return_label: 
#line 1161 
                return __retres;
}


#line 1164  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
int octeon_get_rx_qsize(struct octeon_device *oct, u32 q_no)
{
  int __retres;
  
#line 1166 
  if ((oct != (struct octeon_device *)0 && q_no <= 31U) && (((unsigned long)oct->io_qmask.oq >> q_no) & 1UL) != 0UL) {
    
#line 1168 
    __retres = (int)(oct->droq[q_no])->max_count;
    
#line 1168 
    goto return_label;
  }
  else ;
  
#line 1169 
  __retres = -1;
  return_label: 
#line 1169 
                return __retres;
}


#line 1173  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
struct octeon_config *octeon_get_conf(struct octeon_device *oct)
{
  
#line 1175 
  struct octeon_config *default_oct_conf = (struct octeon_config *)0;
  
#line 1181 
  if ((unsigned int)oct->chip_id + 65391U <= 1U) 
#line 1182 
                                                 default_oct_conf = ((struct octeon_cn6xxx *)oct->chip)->conf; else ;
  
#line 1186 
  return default_oct_conf;
}


#line 1197  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
struct octeon_device *lio_get_device(u32 octeon_id)
{
  struct octeon_device *__retres;
  
#line 1199 
  if (octeon_id > 31U) {
    
#line 1200 
    __retres = (struct octeon_device *)0;
    
#line 1200 
    goto return_label;
  }
  else {
    
#line 1202 
    __retres = octeon_device[octeon_id];
    
#line 1202 
    goto return_label;
  }
  return_label: 
#line 1199 
                return __retres;
}


#line 1205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
u64 lio_pci_readq(struct octeon_device *oct, u64 addr)
{
  u64 val64;
  unsigned long flags;
  u32 val32;
  u32 addrhi;
  
#line 1211 
  ldv___ldv_spin_lock_87(& oct->pci_win_lock);
  
#line 1216 
  addrhi = (unsigned int)(addr >> 32);
  
#line 1217 
  if ((unsigned int)oct->chip_id + 65391U <= 1U) 
#line 1218 
                                                 addrhi |= 393216U; else ;
  
#line 1219 
  writel(addrhi,(void volatile *)oct->reg_list.pci_win_rd_addr_hi);
  
#line 1222 
  val32 = readl((void const volatile *)oct->reg_list.pci_win_rd_addr_hi);
  
#line 1224 
  writel((unsigned int)addr,(void volatile *)oct->reg_list.pci_win_rd_addr_lo);
  
#line 1225 
  val32 = readl((void const volatile *)oct->reg_list.pci_win_rd_addr_lo);
  
#line 1227 
  val64 = (u64)readq((void const volatile *)oct->reg_list.pci_win_rd_data);
  
#line 1229 
  ldv_spin_unlock_irqrestore_88(& oct->pci_win_lock,flags);
  
#line 1231 
  return val64;
}


#line 1234  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
void lio_pci_writeq(struct octeon_device *oct, u64 val, u64 addr)
{
  u32 val32;
  unsigned long flags;
  
#line 1241 
  ldv___ldv_spin_lock_89(& oct->pci_win_lock);
  
#line 1243 
  writeq((unsigned long)addr,(void volatile *)oct->reg_list.pci_win_wr_addr);
  
#line 1246 
  writel((unsigned int)(val >> 32),(void volatile *)oct->reg_list.pci_win_wr_data_hi);
  
#line 1248 
  val32 = readl((void const volatile *)oct->reg_list.pci_win_wr_data_hi);
  
#line 1250 
  writel((unsigned int)val,(void volatile *)oct->reg_list.pci_win_wr_data_lo);
  
#line 1252 
  ldv_spin_unlock_irqrestore_90(& oct->pci_win_lock,flags);
  
#line 1253 
  return;
}


#line 1255  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
int octeon_mem_access_ok(struct octeon_device *oct)
{
  int __retres;
  
#line 1257 
  u64 access_okay = 0ULL;
  
#line 1260 
  u64 lmc0_reset_ctl = lio_pci_readq(oct,307865537479040ULL);
  
#line 1262 
  access_okay = lmc0_reset_ctl & 1ULL;
  
#line 1264 
  __retres = access_okay == 0ULL;
  
#line 1264 
  return __retres;
}


#line 1267  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
int octeon_wait_for_ddr_init(struct octeon_device *oct, u32 *timeout)
{
  int __retres;
  u32 ms;
  
#line 1269 
  int ret = 1;
  
#line 1272 
  if (timeout == (u32 *)0U) {
    
#line 1273 
    __retres = ret;
    
#line 1273 
    goto return_label;
  }
  else ;
  
#line 1275 
  goto ldv_46914;
  ldv_46913: 
#line 1276 
  ;
  
#line 1276 
  schedule_timeout_uninterruptible(25L);
  ldv_46914: 
#line 1277 
  ;
  
#line 1275 
  if (*timeout == 0U) 
#line 1277 
                      goto ldv_46913; else 
#line 1280 
                                           goto ldv_46915;
  ldv_46915: 
#line 1281 
  ;
  
#line 1278 
  ms = 0U;
  
#line 1278 
  goto ldv_46917;
  ldv_46916: 
#line 1279 
  ;
  
#line 1280 
  ret = octeon_mem_access_ok(oct);
  
#line 1283 
  if (ret != 0) 
#line 1284 
                schedule_timeout_uninterruptible(25L); else ;
  
#line 1279 
  ms += 25U;
  ldv_46917: 
#line 1280 
  ;
  
#line 1278 
  if (ret != 0 && (*timeout == 0U || *timeout >= ms)) 
#line 1280 
                                                      goto ldv_46916; else 
                                                                    
#line 1283 
                                                                    goto ldv_46918;
  ldv_46918: 
#line 1284 
  ;
  
#line 1287 
  __retres = ret;
  return_label: 
#line 1287 
                return __retres;
}


#line 1295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.c"
int lio_get_device_id(void *dev)
{
  int __retres;
  u32 i;
  
#line 1297 
  struct octeon_device *octeon_dev = (struct octeon_device *)dev;
  
#line 1300 
  i = 0U;
  
#line 1300 
  goto ldv_46925;
  ldv_46924: 
#line 1301 
  ;
  
#line 1301 
  if (octeon_device[i] == octeon_dev) {
    
#line 1302 
    __retres = (int)octeon_dev->octeon_id;
    
#line 1302 
    goto return_label;
  }
  else ;
  
#line 1300 
  i += 1U;
  ldv_46925: 
#line 1301 
  ;
  
#line 1300 
  if (i <= 31U) 
#line 1302 
                goto ldv_46924; else 
#line 1305 
                                     goto ldv_46926;
  ldv_46926: 
#line 1306 
  ;
  
#line 1303 
  __retres = -1;
  return_label: 
#line 1303 
                return __retres;
}


#line 480  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_device.c.aux"
static void *kmalloc_0(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 483 
  tmp = ldv_kmalloc(size,flags);
  
#line 483 
  return tmp;
}


#line 747  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_device.c.aux"
static void ldv_spin_lock_bh_73_0(spinlock_t *lock)
{
  
#line 751 
  ldv_spin_model_lock((char *)"lock_of_octeon_dispatch_list");
  
#line 753 
  spin_lock_bh_1(lock);
  
#line 754 
  return;
}


#line 757  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_device.c.aux"
static void ldv_spin_unlock_bh_74_0(spinlock_t *lock)
{
  
#line 761 
  ldv_spin_model_unlock((char *)"lock_of_octeon_dispatch_list");
  
#line 763 
  spin_unlock_bh_1(lock);
  
#line 764 
  return;
}


#line 767  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_device.c.aux"
static void ldv_spin_lock_bh_75(spinlock_t *lock)
{
  
#line 771 
  ldv_spin_model_lock((char *)"lock_of_octeon_dispatch_list");
  
#line 773 
  spin_lock_bh_1(lock);
  
#line 774 
  return;
}


#line 777  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_device.c.aux"
static void ldv_spin_unlock_bh_76(spinlock_t *lock)
{
  
#line 781 
  ldv_spin_model_unlock((char *)"lock_of_octeon_dispatch_list");
  
#line 783 
  spin_unlock_bh_1(lock);
  
#line 784 
  return;
}


#line 787  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_device.c.aux"
static void ldv_spin_unlock_bh_77_0(spinlock_t *lock)
{
  
#line 791 
  ldv_spin_model_unlock((char *)"lock_of_octeon_dispatch_list");
  
#line 793 
  spin_unlock_bh_1(lock);
  
#line 794 
  return;
}


#line 797  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_device.c.aux"
static void ldv_spin_unlock_bh_78(spinlock_t *lock)
{
  
#line 801 
  ldv_spin_model_unlock((char *)"lock_of_octeon_dispatch_list");
  
#line 803 
  spin_unlock_bh_1(lock);
  
#line 804 
  return;
}


#line 807  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_device.c.aux"
static void ldv_spin_lock_bh_79(spinlock_t *lock)
{
  
#line 811 
  ldv_spin_model_lock((char *)"lock_of_octeon_dispatch_list");
  
#line 813 
  spin_lock_bh_1(lock);
  
#line 814 
  return;
}


#line 817  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_device.c.aux"
static void ldv_spin_unlock_bh_80(spinlock_t *lock)
{
  
#line 821 
  ldv_spin_model_unlock((char *)"lock_of_octeon_dispatch_list");
  
#line 823 
  spin_unlock_bh_1(lock);
  
#line 824 
  return;
}


#line 827  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_device.c.aux"
static void ldv_spin_unlock_bh_81(spinlock_t *lock)
{
  
#line 831 
  ldv_spin_model_unlock((char *)"lock_of_octeon_dispatch_list");
  
#line 833 
  spin_unlock_bh_1(lock);
  
#line 834 
  return;
}


#line 837  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_device.c.aux"
static void ldv_spin_lock_bh_82(spinlock_t *lock)
{
  
#line 841 
  ldv_spin_model_lock((char *)"lock_of_octeon_dispatch_list");
  
#line 843 
  spin_lock_bh_1(lock);
  
#line 844 
  return;
}


#line 847  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_device.c.aux"
static void ldv_spin_unlock_bh_83(spinlock_t *lock)
{
  
#line 851 
  ldv_spin_model_unlock((char *)"lock_of_octeon_dispatch_list");
  
#line 853 
  spin_unlock_bh_1(lock);
  
#line 854 
  return;
}


#line 857  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_device.c.aux"
static void ldv_spin_lock_bh_84(spinlock_t *lock)
{
  
#line 861 
  ldv_spin_model_lock((char *)"lock_of_octeon_dispatch_list");
  
#line 863 
  spin_lock_bh_1(lock);
  
#line 864 
  return;
}


#line 867  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_device.c.aux"
static void ldv_spin_unlock_bh_85(spinlock_t *lock)
{
  
#line 871 
  ldv_spin_model_unlock((char *)"lock_of_octeon_dispatch_list");
  
#line 873 
  spin_unlock_bh_1(lock);
  
#line 874 
  return;
}


#line 877  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_device.c.aux"
static void ldv_spin_unlock_bh_86(spinlock_t *lock)
{
  
#line 881 
  ldv_spin_model_unlock((char *)"lock_of_octeon_dispatch_list");
  
#line 883 
  spin_unlock_bh_1(lock);
  
#line 884 
  return;
}


#line 887  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_device.c.aux"
static void ldv___ldv_spin_lock_87(spinlock_t *ldv_func_arg1)
{
  
#line 891 
  ldv_spin_model_lock((char *)"pci_win_lock_of_octeon_device");
  
#line 893 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 894 
  return;
}


#line 897  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_device.c.aux"
static void ldv_spin_unlock_irqrestore_88(spinlock_t *lock, unsigned long flags)
{
  
#line 901 
  ldv_spin_model_unlock((char *)"pci_win_lock_of_octeon_device");
  
#line 903 
  spin_unlock_irqrestore_0(lock,flags);
  
#line 904 
  return;
}


#line 907  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_device.c.aux"
static void ldv___ldv_spin_lock_89(spinlock_t *ldv_func_arg1)
{
  
#line 911 
  ldv_spin_model_lock((char *)"pci_win_lock_of_octeon_device");
  
#line 913 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 914 
  return;
}


#line 917  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_device.c.aux"
static void ldv_spin_unlock_irqrestore_90(spinlock_t *lock, unsigned long flags)
{
  
#line 921 
  ldv_spin_model_unlock((char *)"pci_win_lock_of_octeon_device");
  
#line 923 
  spin_unlock_irqrestore_0(lock,flags);
  
#line 924 
  return;
}


#line 308  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr, unsigned long const volatile *addr)
{
  int __retres;
  
#line 311 
  __retres = ((*(addr + (nr >> 6)) >> (nr & 63L)) & 1UL) != 0UL;
  
#line 311 
  return __retres;
}


#line 314  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(long nr, unsigned long const volatile *addr)
{
  int oldbit;
  
#line 317 
  ldv_inline_asm();
  
#line 323 
  return oldbit;
}


#line 402  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
int sprintf(char *, char const * , ...);


#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/percpu.h"
void __bad_percpu_size(void);


#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void)
{
  struct task_struct *tmp;
  {
    struct task_struct *pfo_ret__;
    
#line 14 
    switch (8UL) {
      case (unsigned long)1: 
#line 14 
      ;
      
#line 15 
      ldv_inline_asm();
      
#line 14 
      goto ldv_3477;
      case (unsigned long)2: 
#line 14 
      ;
      
#line 15 
      ldv_inline_asm();
      
#line 14 
      goto ldv_3477;
      case (unsigned long)4: 
#line 14 
      ;
      
#line 15 
      ldv_inline_asm();
      
#line 14 
      goto ldv_3477;
      case (unsigned long)8: 
#line 14 
      ;
      
#line 15 
      ldv_inline_asm();
      
#line 14 
      goto ldv_3477;
      default: 
#line 14 
      ;
      
#line 14 
      __bad_percpu_size();
    }
    ldv_3477: 
#line 14 
    ;
    
#line 14 
    tmp = pfo_ret__;
  }
  
#line 14 
  return tmp;
}


#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
char *strcpy(char *, char const *);


#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/cmpxchg.h"
void __xchg_wrong_size(void);


#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/thread_info.h"
__inline static int test_ti_thread_flag(struct thread_info *ti, int flag)
{
  int tmp_1;
  
#line 91 
  if (0 != 0) 
#line 91 
              tmp_1 = constant_test_bit((long)flag,(unsigned long const volatile *)(& ti->flags)); else 
                                                                    
#line 91 
                                                                    tmp_1 = variable_test_bit((long)flag,(unsigned long const volatile *)(& ti->flags));
  
#line 91 
  return tmp_1;
}


#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
int default_wake_function(wait_queue_t *, unsigned int, int, void *);


#line 72 
void __init_waitqueue_head(wait_queue_head_t *, char const *, struct lock_class_key *);


#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
__inline static void init_waitqueue_entry(wait_queue_t *q, struct task_struct *p)
{
  
#line 92 
  q->flags = 0U;
  
#line 93 
  q->private = (void *)p;
  
#line 94 
  q->func = & default_wake_function;
  
#line 95 
  return;
}


#line 110 
void add_wait_queue(wait_queue_head_t *, wait_queue_t *);


#line 112 
void remove_wait_queue(wait_queue_head_t *, wait_queue_t *);


#line 149 
void __wake_up(wait_queue_head_t *, unsigned int, int, void *);


#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
__inline static char const *kobject_name(struct kobject const *kobj)
{
  char const *__retres;
  
#line 89 
  __retres = kobj->name;
  
#line 89 
  return __retres;
}


#line 833  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static char const *dev_name(struct device const *dev)
{
  char const *__retres;
  char const *tmp;
  
#line 836 
  if (dev->init_name != (char const *)0) {
    
#line 837 
    __retres = dev->init_name;
    
#line 837 
    goto return_label;
  }
  else ;
  
#line 839 
  tmp = kobject_name(& dev->kobj);
  
#line 839 
  __retres = tmp;
  return_label: 
#line 839 
                return __retres;
}


#line 425  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
void schedule(void);


#line 2845  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
__inline static int test_tsk_thread_flag(struct task_struct *tsk, int flag)
{
  int tmp;
  
#line 2847 
  tmp = test_ti_thread_flag((struct thread_info *)tsk->stack,flag);
  
#line 2847 
  return tmp;
}


#line 2871  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
__inline static int signal_pending(struct task_struct *p)
{
  int __retres;
  int tmp;
  
#line 2873 
  tmp = test_tsk_thread_flag(p,2);
  
#line 2873 
  __retres = (long)(tmp != 0);
  
#line 2873 
  return __retres;
}


#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
__inline static void ethtool_cmd_speed_set(struct ethtool_cmd *ep, __u32 speed)
{
  
#line 117 
  ep->speed = (unsigned short)speed;
  
#line 118 
  ep->speed_hi = (unsigned short)(speed >> 16);
  
#line 119 
  return;
}


#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
u32 ethtool_op_get_link(struct net_device *);


#line 1880  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void *netdev_priv(struct net_device const *dev)
{
  void *__retres;
  
#line 1882 
  __retres = (void *)dev + 3008U;
  
#line 1882 
  return __retres;
}


#line 2769  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool netif_running(struct net_device const *dev)
{
  bool __retres;
  int tmp;
  
#line 2771 
  tmp = constant_test_bit(0L,(unsigned long const volatile *)(& dev->state));
  
#line 2771 
  __retres = (_Bool)(tmp != 0);
  
#line 2771 
  return __retres;
}


#line 3834 
void netdev_info(struct net_device const *, char const * , ...);


#line 1484  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static char const *pci_name(struct pci_dev const *pdev)
{
  char const *tmp;
  
#line 1486 
  tmp = dev_name(& pdev->dev);
  
#line 1486 
  return tmp;
}


#line 223  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_nic.h"
int octnet_send_nic_ctrl_pkt(struct octeon_device *oct, struct octnic_ctrl_pkt *nctrl, struct octnic_ctrl_params nparams);


#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_main.h"
__inline static void octeon_swap_8B_data_1(u64 *data, u32 blocks)
{
  
#line 59 
  goto ldv_45826;
  ldv_45825: 
#line 60 
  ;
  
#line 60 
  __swab64s(data);
  
#line 61 
  blocks -= 1U;
  
#line 62 
  data += 1;
  ldv_45826: 
#line 63 
  ;
  
#line 59 
  if (blocks != 0U) 
#line 61 
                    goto ldv_45825; else 
#line 64 
                                         goto ldv_45827;
  ldv_45827: 
#line 65 
  ;
  
#line 66 
  return;
}


#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_main.h"
__inline static void sleep_cond(wait_queue_head_t *wait_queue, int *condition)
{
  wait_queue_t we;
  struct task_struct *tmp;
  struct task_struct *tmp_0;
  int tmp_2_0;
  struct task_struct *tmp_1;
  int volatile *tmp_3;
  struct task_struct *tmp_4;
  
#line 170 
  tmp = get_current();
  
#line 170 
  init_waitqueue_entry(& we,tmp);
  
#line 171 
  add_wait_queue(wait_queue,& we);
  
#line 172 
  goto ldv_45872;
  ldv_45871: 
#line 173 
  ;
  
#line 173 
  tmp_0 = get_current();
  __here_0: 
#line 173 
  ;
  
#line 173 
  tmp_0->task_state_change = (unsigned long)((void *)0);
  {
    
#line 173 
    long volatile __ret = 1L;
    
#line 173 
    switch (8UL) {
      case (unsigned long)1: 
#line 173 
      ;
      
#line 174 
      ldv_inline_asm();
      
#line 173 
      goto ldv_45864;
      case (unsigned long)2: 
#line 173 
      ;
      
#line 174 
      ldv_inline_asm();
      
#line 173 
      goto ldv_45864;
      case (unsigned long)4: 
#line 173 
      ;
      
#line 174 
      ldv_inline_asm();
      
#line 173 
      goto ldv_45864;
      case (unsigned long)8: 
#line 173 
      ;
      
#line 174 
      ldv_inline_asm();
      
#line 173 
      goto ldv_45864;
      default: 
#line 173 
      ;
      
#line 173 
      __xchg_wrong_size();
    }
    ldv_45864: 
#line 173 
    ;
    
#line 173 
    long tmp_2 = __ret;
  }
  
#line 174 
  tmp_1 = get_current();
  
#line 174 
  tmp_2_0 = signal_pending(tmp_1);
  
#line 174 
  if (tmp_2_0 != 0) 
#line 175 
                    goto out; else ;
  
#line 176 
  schedule();
  ldv_45872: 
#line 177 
  ;
  {
    
#line 172 
    int __var = 0;
    
#line 172 
    tmp_3 = (int volatile *)condition;
  }
  
#line 172 
  ;
  
#line 172 
  if (*tmp_3 == 0) 
#line 174 
                   goto ldv_45871; else 
#line 177 
                                        goto ldv_45873;
  ldv_45873: 
#line 178 
  ;
  out: 
#line 178 
  ;
  
#line 179 
  tmp_4 = get_current();
  __here_1: 
#line 179 
  ;
  
#line 179 
  tmp_4->task_state_change = (unsigned long)((void *)1);
  {
    
#line 179 
    long volatile __ret_0 = 0L;
    
#line 179 
    switch (8UL) {
      case (unsigned long)1: 
#line 179 
      ;
      
#line 180 
      ldv_inline_asm();
      
#line 179 
      goto ldv_45878;
      case (unsigned long)2: 
#line 179 
      ;
      
#line 180 
      ldv_inline_asm();
      
#line 179 
      goto ldv_45878;
      case (unsigned long)4: 
#line 179 
      ;
      
#line 180 
      ldv_inline_asm();
      
#line 179 
      goto ldv_45878;
      case (unsigned long)8: 
#line 179 
      ;
      
#line 180 
      ldv_inline_asm();
      
#line 179 
      goto ldv_45878;
      default: 
#line 179 
      ;
      
#line 179 
      __xchg_wrong_size();
    }
    ldv_45878: 
#line 179 
    ;
    
#line 179 
    long tmp_5 = __ret_0;
  }
  
#line 180 
  remove_wait_queue(wait_queue,& we);
  
#line 181 
  return;
}


#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ptp_clock_kernel.h"
int ptp_clock_index(struct ptp_clock *);


#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_network.h"
int liquidio_set_feature(struct net_device *netdev, int cmd);


#line 126 
void liquidio_link_ctrl_cmd_completion(void *nctrl_ptr);


#line 132 
void liquidio_set_ethtool_ops(struct net_device *netdev);


#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.h"
u32 lio_cn6xxx_get_oq_ticks(struct octeon_device *oct, u32 time_intr_in_us);


#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static char const oct_iq_stats_strings[10U][32U] = {{(char)'I', (char)'n', (char)'s', (char)'t', (char)'r', (char)' ', (char)'p', (char)'o', (char)'s', (char)'t', (char)'e', (char)'d', (char)'\000'}, {(char)'I', (char)'n', (char)'s', (char)'t', (char)'r', (char)' ', (char)'p', (char)'r', (char)'o', (char)'c', (char)'e', (char)'s', (char)'s', (char)'e', (char)'d', (char)'\000'}, {(char)'I', (char)'n', (char)'s', (char)'t', (char)'r', (char)' ', (char)'d', (char)'r', (char)'o', (char)'p', (char)'p', (char)'e', (char)'d', (char)'\000'}, {(char)'B', (char)'y', (char)'t', (char)'e', (char)'s', (char)' ', (char)'S', (char)'e', (char)'n', (char)'t', (char)'\000'}, {(char)'S', (char)'g', (char)'e', (char)'n', (char)'t', (char)'r', (char)'y', (char)'_', (char)'s', (char)'e', (char)'n', (char)'t', (char)'\000'}, {(char)'I', (char)'n', (char)'s', (char)'t', (char)' ', (char)'c', (char)'n', (char)'t', (char)'r', (char)'e', (char)'g', (char)'\000'}, {(char)'T', (char)'x', (char)' ', (char)'d', (char)'o', (char)'n', (char)'e', (char)'\000'}, {(char)'T', (char)'x', (char)' ', (char)'I', (char)'q', (char)' ', (char)'b', (char)'u', (char)'s', (char)'y', (char)'\000'}, {(char)'T', (char)'x', (char)' ', (char)'d', (char)'r', (char)'o', (char)'p', (char)'p', (char)'e', (char)'d', (char)'\000'}, {(char)'T', (char)'x', (char)' ', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s', (char)'\000'}};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static char const oct_droq_stats_strings[8U][32U] = {{(char)'O', (char)'Q', (char)' ', (char)'P', (char)'k', (char)'t', (char)'s', (char)' ', (char)'R', (char)'e', (char)'c', (char)'e', (char)'i', (char)'v', (char)'e', (char)'d', (char)'\000'}, {(char)'O', (char)'Q', (char)' ', (char)'B', (char)'y', (char)'t', (char)'e', (char)'s', (char)' ', (char)'R', (char)'e', (char)'c', (char)'e', (char)'i', (char)'v', (char)'e', (char)'d', (char)'\000'}, {(char)'D', (char)'r', (char)'o', (char)'p', (char)'p', (char)'e', (char)'d', (char)' ', (char)'n', (char)'o', (char)' ', (char)'d', (char)'i', (char)'s', (char)'p', (char)'a', (char)'t', (char)'c', (char)'h', (char)'\000'}, {(char)'D', (char)'r', (char)'o', (char)'p', (char)'p', (char)'e', (char)'d', (char)' ', (char)'n', (char)'o', (char)'m', (char)'e', (char)'m', (char)'\000'}, {(char)'D', (char)'r', (char)'o', (char)'p', (char)'p', (char)'e', (char)'d', (char)' ', (char)'t', (char)'o', (char)'o', (char)'m', (char)'a', (char)'n', (char)'y', (char)'\000'}, {(char)'S', (char)'t', (char)'a', (char)'c', (char)'k', (char)' ', (char)'R', (char)'X', (char)' ', (char)'c', (char)'n', (char)'t', (char)'\000'}, {(char)'S', (char)'t', (char)'a', (char)'c', (char)'k', (char)' ', (char)'R', (char)'X', (char)' ', (char)'B', (char)'y', (char)'t', (char)'e', (char)'s', (char)'\000'}, {(char)'R', (char)'X', (char)' ', (char)'d', (char)'r', (char)'o', (char)'p', (char)'p', (char)'e', (char)'d', (char)'\000'}};

#line 107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static int lio_get_settings(struct net_device *netdev, struct ethtool_cmd *ecmd)
{
  int __retres;
  struct oct_link_info *linfo;
  
#line 109 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 110 
  struct octeon_device *oct = lio->oct_dev;
  
#line 113 
  linfo = & lio->linfo;
  
#line 115 
  if ((unsigned int)*((unsigned char *)(& linfo->link.s) + 1UL) == 40U || (unsigned int)*((unsigned char *)(& linfo->link.s) + 1UL) == 96U) {
    
#line 117 
    ecmd->port = (unsigned char)3U;
    
#line 118 
    ecmd->supported = 13312U;
    
#line 121 
    ecmd->advertising = 12288U;
    
#line 123 
    ecmd->transceiver = (unsigned char)1U;
    
#line 124 
    ecmd->autoneg = (unsigned char)0U;
  }
  else 
#line 127 
       dev_err((struct device const *)(& (oct->pci_dev)->dev),"Unknown link interface reported\n");
  
#line 130 
  if ((unsigned int)linfo->link.s.status != 0U) {
    
#line 131 
    ethtool_cmd_speed_set(ecmd,(unsigned int)linfo->link.s.speed);
    
#line 132 
    ecmd->duplex = (unsigned char)linfo->link.s.duplex;
  }
  else {
    
#line 134 
    ethtool_cmd_speed_set(ecmd,4294967295U);
    
#line 135 
    ecmd->duplex = (unsigned char)255U;
  }
  
#line 138 
  __retres = 0;
  
#line 138 
  return __retres;
}


#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static void lio_get_drvinfo(struct net_device *netdev, struct ethtool_drvinfo *drvinfo)
{
  struct lio *lio;
  struct octeon_device *oct;
  char const *tmp_0;
  
#line 147 
  lio = (struct lio *)netdev_priv((struct net_device const *)netdev);
  
#line 148 
  oct = lio->oct_dev;
  
#line 150 
  memset((void *)drvinfo,0,196UL);
  
#line 151 
  strcpy((char *)(& drvinfo->driver),"liquidio");
  
#line 152 
  strcpy((char *)(& drvinfo->version),"1.1.9");
  
#line 153 
  strncpy((char *)(& drvinfo->fw_version),(char const *)(& oct->fw_info.liquidio_firmware_version),32UL);
  
#line 155 
  tmp_0 = pci_name((struct pci_dev const *)oct->pci_dev);
  
#line 155 
  ;
  
#line 155 
  strncpy((char *)(& drvinfo->bus_info),tmp_0,32UL);
  
#line 156 
  drvinfo->regdump_len = 4096U;
  
#line 157 
  return;
}


#line 160  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static void lio_ethtool_get_channels(struct net_device *dev, struct ethtool_channels *channel)
{
  
#line 163 
  struct lio *lio = netdev_priv((struct net_device const *)dev);
  
#line 164 
  struct octeon_device *oct = lio->oct_dev;
  
#line 165 
  u32 max_rx = 0U;
  
#line 165 
  u32 max_tx = 0U;
  
#line 165 
  u32 tx_count = 0U;
  
#line 165 
  u32 rx_count = 0U;
  
#line 167 
  if ((unsigned int)oct->chip_id + 65391U <= 1U) {
    
#line 168 
    struct octeon_config *conf6x = ((struct octeon_cn6xxx *)oct->chip)->conf;
    
#line 170 
    max_rx = (unsigned int)conf6x->oq.max_oqs;
    
#line 171 
    max_tx = (unsigned int)conf6x->iq.max_iqs;
    
#line 172 
    rx_count = (unsigned int)conf6x->nic_if_cfg[lio->ifidx].num_rxqs;
    
#line 173 
    tx_count = (unsigned int)conf6x->nic_if_cfg[lio->ifidx].num_txqs;
  }
  else ;
  
#line 176 
  channel->max_rx = max_rx;
  
#line 177 
  channel->max_tx = max_tx;
  
#line 178 
  channel->rx_count = rx_count;
  
#line 179 
  channel->tx_count = tx_count;
  
#line 180 
  return;
}


#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static int lio_get_eeprom_len(struct net_device *netdev)
{
  u8 buf[128U];
  struct octeon_board_info *board_info;
  int len;
  
#line 185 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 186 
  struct octeon_device *oct_dev = lio->oct_dev;
  
#line 190 
  board_info = & oct_dev->boardinfo;
  
#line 191 
  len = sprintf((char *)(& buf),"boardname:%s serialnum:%s maj:%lld min:%lld\n",(char *)(& board_info->name),(char *)(& board_info->serial_number),board_info->major,board_info->minor);
  
#line 195 
  return len;
}


#line 199  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static int lio_get_eeprom(struct net_device *netdev, struct ethtool_eeprom *eeprom, u8 *bytes)
{
  int __retres;
  struct octeon_board_info *board_info;
  int len;
  
#line 202 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 203 
  struct octeon_device *oct_dev = lio->oct_dev;
  
#line 207 
  if (eeprom->offset != 0U) {
    
#line 208 
    __retres = -22;
    
#line 208 
    goto return_label;
  }
  else ;
  
#line 210 
  eeprom->magic = (unsigned int)(oct_dev->pci_dev)->vendor;
  
#line 211 
  board_info = & oct_dev->boardinfo;
  
#line 212 
  len = sprintf((char *)bytes,"boardname:%s serialnum:%s maj:%lld min:%lld\n",(char *)(& board_info->name),(char *)(& board_info->serial_number),board_info->major,board_info->minor);
  
#line 218 
  __retres = 0;
  return_label: 
#line 218 
                return __retres;
}


#line 221  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static int octnet_gpio_access(struct net_device *netdev, int addr, int val)
{
  int __retres;
  struct octnic_ctrl_pkt nctrl;
  struct octnic_ctrl_params nparams;
  
#line 223 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 224 
  struct octeon_device *oct = lio->oct_dev;
  
#line 227 
  int ret = 0;
  
#line 229 
  memset((void *)(& nctrl),0,320UL);
  
#line 231 
  nctrl.ncmd.u64 = 0ULL;
  
#line 232 
  nctrl.ncmd.s.cmd = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(5))))10U;
  
#line 233 
  nctrl.ncmd.s.param1 = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(29))))lio->linfo.ifidx;
  
#line 234 
  nctrl.ncmd.s.param2 = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))((unsigned short)addr);
  
#line 235 
  nctrl.ncmd.s.param3 = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))((unsigned char)val);
  
#line 236 
  nctrl.wait_time = 100UL;
  
#line 237 
  nctrl.netpndev = (unsigned long long)netdev;
  
#line 238 
  nctrl.cb_fn = & liquidio_link_ctrl_cmd_completion;
  
#line 240 
  nparams.resp_order = 0U;
  
#line 242 
  ret = octnet_send_nic_ctrl_pkt(lio->oct_dev,& nctrl,nparams);
  
#line 243 
  if (ret < 0) {
    
#line 244 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Failed to configure gpio value\n");
    
#line 245 
    __retres = -22;
    
#line 245 
    goto return_label;
  }
  else ;
  
#line 248 
  __retres = 0;
  return_label: 
#line 248 
                return __retres;
}


#line 253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static void octnet_mdio_resp_callback(struct octeon_device *oct, u32 status, void *buf)
{
  struct oct_mdio_cmd_resp *mdio_cmd_rsp;
  struct oct_mdio_cmd_context *mdio_cmd_ctx;
  
#line 259 
  struct octeon_soft_command *sc = (struct octeon_soft_command *)buf;
  
#line 261 
  mdio_cmd_rsp = (struct oct_mdio_cmd_resp *)sc->virtrptr;
  
#line 262 
  mdio_cmd_ctx = (struct oct_mdio_cmd_context *)sc->ctxptr;
  
#line 264 
  oct = lio_get_device((unsigned int)mdio_cmd_ctx->octeon_id);
  
#line 265 
  if (status != 0U) {
    int volatile *tmp;
    
#line 266 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"MIDO instruction failed. Status: %llx\n",(long long)status);
    {
      
#line 268 
      int __var = 0;
      
#line 268 
      tmp = (int volatile *)(& mdio_cmd_ctx->cond);
    }
    
#line 268 
    *tmp = -1;
  }
  else {
    int volatile *tmp_0;
    {
      
#line 270 
      int __var_0 = 0;
      
#line 270 
      tmp_0 = (int volatile *)(& mdio_cmd_ctx->cond);
    }
    
#line 270 
    *tmp_0 = 1;
  }
  
#line 272 
  __wake_up(& mdio_cmd_ctx->wc,1U,1,(void *)0);
  
#line 273 
  return;
}


#line 279  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static int octnet_mdio45_access(struct lio *lio, int op, int loc, int *value)
{
  int __retres;
  struct octeon_soft_command *sc;
  struct oct_mdio_cmd_resp *mdio_cmd_rsp;
  struct oct_mdio_cmd_context *mdio_cmd_ctx;
  struct oct_mdio_cmd *mdio_cmd;
  int volatile *tmp;
  
#line 281 
  struct octeon_device *oct_dev = lio->oct_dev;
  
#line 286 
  int retval = 0;
  
#line 288 
  sc = octeon_alloc_soft_command(oct_dev,40U,56U,104U);
  
#line 294 
  if (sc == (struct octeon_soft_command *)0) {
    
#line 295 
    __retres = -12;
    
#line 295 
    goto return_label;
  }
  else ;
  
#line 297 
  mdio_cmd_ctx = (struct oct_mdio_cmd_context *)sc->ctxptr;
  
#line 298 
  mdio_cmd_rsp = (struct oct_mdio_cmd_resp *)sc->virtrptr;
  
#line 299 
  mdio_cmd = (struct oct_mdio_cmd *)sc->virtdptr;
  {
    
#line 301 
    int __var = 0;
    
#line 301 
    tmp = (int volatile *)(& mdio_cmd_ctx->cond);
  }
  
#line 301 
  *tmp = 0;
  
#line 302 
  mdio_cmd_ctx->octeon_id = lio_get_device_id((void *)oct_dev);
  
#line 303 
  mdio_cmd->op = (unsigned long long)op;
  
#line 304 
  mdio_cmd->mdio_addr = (unsigned long long)loc;
  
#line 305 
  if (op != 0) 
#line 306 
               mdio_cmd->value1 = (unsigned long long)*value; else ;
  
#line 307 
  mdio_cmd->value2 = (unsigned long long)lio->linfo.ifidx;
  
#line 308 
  octeon_swap_8B_data_1((u64 *)mdio_cmd,5U);
  
#line 310 
  octeon_prepare_soft_command(oct_dev,sc,(unsigned char)1,(unsigned char)6,0U,0ULL,0ULL);
  
#line 313 
  sc->wait_time = 1000UL;
  
#line 314 
  sc->callback = & octnet_mdio_resp_callback;
  
#line 315 
  sc->callback_arg = (void *)sc;
  {
    struct lock_class_key __key;
    
#line 317 
    __init_waitqueue_head(& mdio_cmd_ctx->wc,"&mdio_cmd_ctx->wc",& __key);
  }
  
#line 319 
  retval = octeon_send_soft_command(oct_dev,sc);
  
#line 321 
  if (retval != 0) {
    
#line 322 
    dev_err((struct device const *)(& (oct_dev->pci_dev)->dev),"octnet_mdio45_access instruction failed status: %x\n",retval);
    
#line 325 
    retval = -16;
  }
  else {
    
#line 330 
    sleep_cond(& mdio_cmd_ctx->wc,& mdio_cmd_ctx->cond);
    
#line 331 
    retval = (int)mdio_cmd_rsp->status;
    
#line 332 
    if (retval != 0) {
      
#line 333 
      dev_err((struct device const *)(& (oct_dev->pci_dev)->dev),"octnet mdio45 access failed\n");
      
#line 334 
      retval = -16;
    }
    else {
      int volatile *tmp_0;
      
#line 336 
      octeon_swap_8B_data_1((u64 *)(& mdio_cmd_rsp->resp),5U);
      {
        
#line 339 
        int __var_0 = 0;
        
#line 339 
        tmp_0 = (int volatile *)(& mdio_cmd_ctx->cond);
      }
      
#line 339 
      ;
      
#line 339 
      if (*tmp_0 == 1) {
        
#line 340 
        if (op == 0) 
#line 341 
                     *value = (int)mdio_cmd_rsp->resp.value1; else ;
      }
      else 
#line 343 
           retval = -22;
    }
  }
  
#line 348 
  octeon_free_soft_command(oct_dev,sc);
  
#line 350 
  __retres = retval;
  return_label: 
#line 350 
                return __retres;
}


#line 353  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static int lio_set_phys_id(struct net_device *netdev, enum ethtool_phys_id_state state)
{
  int __retres;
  int value;
  int ret;
  
#line 356 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 357 
  struct octeon_device *oct = lio->oct_dev;
  
#line 360 
  switch ((unsigned int)state) {
    case (unsigned int)1: 
#line 361 
    ;
    
#line 362 
    if ((unsigned int)oct->chip_id == 146U) {
      
#line 363 
      octnet_gpio_access(netdev,8,1);
      
#line 365 
      __retres = 2;
      
#line 365 
      goto return_label;
    }
    else 
      
#line 367 
      if ((unsigned int)oct->chip_id == 145U) {
        
#line 369 
        ret = octnet_mdio45_access(lio,0,13576,(int *)(& lio->phy_beacon_val));
        
#line 372 
        if (ret != 0) {
          
#line 373 
          __retres = ret;
          
#line 373 
          goto return_label;
        }
        else ;
        
#line 375 
        ret = octnet_mdio45_access(lio,0,13569,(int *)(& lio->led_ctrl_val));
        
#line 378 
        if (ret != 0) {
          
#line 379 
          __retres = ret;
          
#line 379 
          goto return_label;
        }
        else ;
        
#line 382 
        value = 18429;
        
#line 383 
        ret = octnet_mdio45_access(lio,1,13576,& value);
        
#line 387 
        if (ret != 0) {
          
#line 388 
          __retres = ret;
          
#line 388 
          goto return_label;
        }
        else ;
        
#line 390 
        value = 31;
        
#line 391 
        ret = octnet_mdio45_access(lio,1,13569,& value);
        
#line 395 
        if (ret != 0) {
          
#line 396 
          __retres = ret;
          
#line 396 
          goto return_label;
        }
        else ;
      }
      else {
        
#line 398 
        __retres = -22;
        
#line 398 
        goto return_label;
      }
    
#line 400 
    goto ldv_46440;
    case (unsigned int)2: 
#line 402 
    ;
    
#line 403 
    if ((unsigned int)oct->chip_id == 146U) 
#line 404 
                                            octnet_gpio_access(netdev,8,2);
    else 
      
#line 407 
      if ((unsigned int)oct->chip_id == 145U) {
        
#line 408 
        __retres = -22;
        
#line 408 
        goto return_label;
      }
      else {
        
#line 410 
        __retres = -22;
        
#line 410 
        goto return_label;
      }
    
#line 412 
    goto ldv_46440;
    case (unsigned int)3: 
#line 414 
    ;
    
#line 415 
    if ((unsigned int)oct->chip_id == 146U) 
#line 416 
                                            octnet_gpio_access(netdev,8,3);
    else 
      
#line 418 
      if ((unsigned int)oct->chip_id == 145U) {
        
#line 419 
        __retres = -22;
        
#line 419 
        goto return_label;
      }
      else {
        
#line 421 
        __retres = -22;
        
#line 421 
        goto return_label;
      }
    
#line 423 
    goto ldv_46440;
    case (unsigned int)0: 
#line 425 
    ;
    
#line 426 
    if ((unsigned int)oct->chip_id == 146U) 
#line 427 
                                            octnet_gpio_access(netdev,8,4);
    else 
      
#line 429 
      if ((unsigned int)oct->chip_id == 145U) {
        
#line 431 
        ret = octnet_mdio45_access(lio,1,13569,(int *)(& lio->led_ctrl_val));
        
#line 434 
        if (ret != 0) {
          
#line 435 
          __retres = ret;
          
#line 435 
          goto return_label;
        }
        else ;
        
#line 437 
        ret = octnet_mdio45_access(lio,1,13576,(int *)(& lio->phy_beacon_val));
        
#line 440 
        if (ret != 0) {
          
#line 441 
          __retres = ret;
          
#line 441 
          goto return_label;
        }
        else ;
      }
      else {
        
#line 444 
        __retres = -22;
        
#line 444 
        goto return_label;
      }
    
#line 446 
    goto ldv_46440;
    default: 
#line 448 
    ;
    
#line 449 
    __retres = -22;
    
#line 449 
    goto return_label;
  }
  ldv_46440: 
#line 452 
  ;
  
#line 452 
  __retres = 0;
  return_label: 
#line 452 
                return __retres;
}


#line 456  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static void lio_ethtool_get_ringparam(struct net_device *netdev, struct ethtool_ringparam *ering)
{
  
#line 459 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 460 
  struct octeon_device *oct = lio->oct_dev;
  
#line 461 
  u32 tx_max_pending = 0U;
  
#line 461 
  u32 rx_max_pending = 0U;
  
#line 461 
  u32 tx_pending = 0U;
  
#line 462 
  u32 rx_pending = 0U;
  
#line 464 
  if ((unsigned int)oct->chip_id + 65391U <= 1U) {
    
#line 465 
    struct octeon_config *conf6x = ((struct octeon_cn6xxx *)oct->chip)->conf;
    
#line 467 
    tx_max_pending = 2048U;
    
#line 468 
    rx_max_pending = 2048U;
    
#line 469 
    rx_pending = (unsigned int)conf6x->nic_if_cfg[lio->ifidx].num_rx_descs;
    
#line 470 
    tx_pending = (unsigned int)conf6x->nic_if_cfg[lio->ifidx].num_tx_descs;
  }
  else ;
  
#line 473 
  if (lio->mtu > 1530U) {
    
#line 474 
    ering->rx_pending = 0U;
    
#line 475 
    ering->rx_max_pending = 0U;
    
#line 476 
    ering->rx_mini_pending = 0U;
    
#line 477 
    ering->rx_jumbo_pending = rx_pending;
    
#line 478 
    ering->rx_mini_max_pending = 0U;
    
#line 479 
    ering->rx_jumbo_max_pending = rx_max_pending;
  }
  else {
    
#line 481 
    ering->rx_pending = rx_pending;
    
#line 482 
    ering->rx_max_pending = rx_max_pending;
    
#line 483 
    ering->rx_mini_pending = 0U;
    
#line 484 
    ering->rx_jumbo_pending = 0U;
    
#line 485 
    ering->rx_mini_max_pending = 0U;
    
#line 486 
    ering->rx_jumbo_max_pending = 0U;
  }
  
#line 489 
  ering->tx_pending = tx_pending;
  
#line 490 
  ering->tx_max_pending = tx_max_pending;
  
#line 491 
  return;
}


#line 493  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static u32 lio_get_msglevel(struct net_device *netdev)
{
  u32 __retres;
  
#line 495 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 497 
  __retres = lio->msg_enable;
  
#line 497 
  return __retres;
}


#line 500  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static void lio_set_msglevel(struct net_device *netdev, u32 msglvl)
{
  
#line 502 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 504 
  if (((lio->msg_enable ^ msglvl) & 8192U) != 0U) 
    
#line 505 
    if ((msglvl & 8192U) != 0U) 
#line 506 
                                liquidio_set_feature(netdev,20); else 
                                                                   
#line 509 
                                                                   liquidio_set_feature(netdev,21);
  else ;
  
#line 513 
  lio->msg_enable = msglvl;
  
#line 514 
  return;
}


#line 517  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static void lio_get_pauseparam(struct net_device *netdev, struct ethtool_pauseparam *pause)
{
  
#line 522 
  pause->tx_pause = 1U;
  
#line 523 
  pause->rx_pause = 1U;
  
#line 524 
  return;
}


#line 527  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static void lio_get_ethtool_stats(struct net_device *netdev, struct ethtool_stats *stats, u64 *data)
{
  int j;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  int tmp_4;
  int tmp_5;
  unsigned int tmp_6;
  int tmp_7;
  int tmp_8;
  int tmp_9;
  int tmp_10;
  int tmp_11;
  int tmp_12;
  int tmp_13;
  int tmp_14;
  int tmp_15;
  int tmp_16;
  int tmp_17;
  int tmp_18;
  
#line 530 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 531 
  struct octeon_device *oct_dev = lio->oct_dev;
  
#line 532 
  int i = 0;
  
#line 534 
  j = 0;
  
#line 534 
  goto ldv_46480;
  ldv_46479: 
#line 535 
  ;
  
#line 535 
  if ((((unsigned long)oct_dev->io_qmask.iq >> j) & 1UL) == 0UL) 
#line 536 
                                                                 goto ldv_46478; else ;
  
#line 537 
  tmp_0 = i;
  
#line 537 
  i += 1;
  
#line 537 
  *(data + tmp_0) = (oct_dev->instr_queue[j])->stats.instr_posted;
  
#line 539 
  tmp_1 = i;
  
#line 539 
  i += 1;
  
#line 539 
  *(data + tmp_1) = (oct_dev->instr_queue[j])->stats.instr_processed;
  
#line 542 
  tmp_2 = i;
  
#line 542 
  i += 1;
  
#line 542 
  *(data + tmp_2) = (oct_dev->instr_queue[j])->stats.instr_dropped;
  
#line 545 
  tmp_3 = i;
  
#line 545 
  i += 1;
  
#line 545 
  *(data + tmp_3) = (oct_dev->instr_queue[j])->stats.bytes_sent;
  
#line 547 
  tmp_4 = i;
  
#line 547 
  i += 1;
  
#line 547 
  *(data + tmp_4) = (oct_dev->instr_queue[j])->stats.sgentry_sent;
  
#line 549 
  tmp_5 = i;
  
#line 549 
  i += 1;
  
#line 550 
  tmp_6 = readl((void const volatile *)(oct_dev->instr_queue[j])->inst_cnt_reg);
  
#line 549 
  *(data + tmp_5) = (unsigned long long)tmp_6;
  
#line 551 
  tmp_7 = i;
  
#line 551 
  i += 1;
  
#line 551 
  *(data + tmp_7) = (oct_dev->instr_queue[j])->stats.tx_done;
  
#line 553 
  tmp_8 = i;
  
#line 553 
  i += 1;
  
#line 553 
  *(data + tmp_8) = (oct_dev->instr_queue[j])->stats.tx_iq_busy;
  
#line 555 
  tmp_9 = i;
  
#line 555 
  i += 1;
  
#line 555 
  *(data + tmp_9) = (oct_dev->instr_queue[j])->stats.tx_dropped;
  
#line 557 
  tmp_10 = i;
  
#line 557 
  i += 1;
  
#line 557 
  *(data + tmp_10) = (oct_dev->instr_queue[j])->stats.tx_tot_bytes;
  ldv_46478: 
#line 559 
  ;
  
#line 534 
  j += 1;
  ldv_46480: 
#line 535 
  ;
  
#line 534 
  if (j <= 31) 
#line 536 
               goto ldv_46479; else 
#line 539 
                                    goto ldv_46481;
  ldv_46481: 
#line 540 
  ;
  
#line 562 
  j = 0;
  
#line 562 
  goto ldv_46484;
  ldv_46483: 
#line 563 
  ;
  
#line 563 
  if ((((unsigned long)oct_dev->io_qmask.oq >> j) & 1UL) == 0UL) 
#line 564 
                                                                 goto ldv_46482; else ;
  
#line 565 
  tmp_11 = i;
  
#line 565 
  i += 1;
  
#line 565 
  *(data + tmp_11) = (oct_dev->droq[j])->stats.pkts_received;
  
#line 566 
  tmp_12 = i;
  
#line 566 
  i += 1;
  
#line 566 
  *(data + tmp_12) = (oct_dev->droq[j])->stats.bytes_received;
  
#line 567 
  tmp_13 = i;
  
#line 567 
  i += 1;
  
#line 567 
  *(data + tmp_13) = (oct_dev->droq[j])->stats.dropped_nodispatch;
  
#line 569 
  tmp_14 = i;
  
#line 569 
  i += 1;
  
#line 569 
  *(data + tmp_14) = (oct_dev->droq[j])->stats.dropped_nomem;
  
#line 570 
  tmp_15 = i;
  
#line 570 
  i += 1;
  
#line 570 
  *(data + tmp_15) = (oct_dev->droq[j])->stats.dropped_toomany;
  
#line 571 
  tmp_16 = i;
  
#line 571 
  i += 1;
  
#line 571 
  *(data + tmp_16) = (oct_dev->droq[j])->stats.rx_pkts_received;
  
#line 573 
  tmp_17 = i;
  
#line 573 
  i += 1;
  
#line 573 
  *(data + tmp_17) = (oct_dev->droq[j])->stats.rx_bytes_received;
  
#line 575 
  tmp_18 = i;
  
#line 575 
  i += 1;
  
#line 575 
  *(data + tmp_18) = (oct_dev->droq[j])->stats.rx_dropped;
  ldv_46482: 
#line 577 
  ;
  
#line 562 
  j += 1;
  ldv_46484: 
#line 563 
  ;
  
#line 562 
  if (j <= 31) 
#line 564 
               goto ldv_46483; else 
#line 567 
                                    goto ldv_46485;
  ldv_46485: 
#line 568 
  ;
  
#line 569 
  return;
}


#line 580  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static void lio_get_strings(struct net_device *netdev, u32 stringset, u8 *data)
{
  int num_iq_stats;
  int num_oq_stats;
  int i;
  int j;
  
#line 582 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 583 
  struct octeon_device *oct_dev = lio->oct_dev;
  
#line 586 
  num_iq_stats = 10;
  
#line 587 
  i = 0;
  
#line 587 
  goto ldv_46505;
  ldv_46504: 
#line 588 
  ;
  
#line 588 
  if ((((unsigned long)oct_dev->io_qmask.iq >> i) & 1UL) == 0UL) 
#line 589 
                                                                 goto ldv_46500; else ;
  
#line 590 
  j = 0;
  
#line 590 
  goto ldv_46502;
  ldv_46501: 
#line 591 
  ;
  
#line 591 
  sprintf((char *)data,"IQ%d %s",i,(char const *)(& oct_iq_stats_strings[j]));
  
#line 592 
  data += 32U;
  
#line 590 
  j += 1;
  ldv_46502: 
#line 591 
  ;
  
#line 590 
  if (j < num_iq_stats) 
#line 592 
                        goto ldv_46501; else 
#line 595 
                                             goto ldv_46503;
  ldv_46503: 
#line 596 
  ;
  ldv_46500: 
#line 597 
  ;
  
#line 587 
  i += 1;
  ldv_46505: 
#line 588 
  ;
  
#line 587 
  if (i <= 31) 
#line 589 
               goto ldv_46504; else 
#line 592 
                                    goto ldv_46506;
  ldv_46506: 
#line 593 
  ;
  
#line 596 
  num_oq_stats = 8;
  
#line 598 
  i = 0;
  
#line 598 
  goto ldv_46515;
  ldv_46514: 
#line 599 
  ;
  
#line 599 
  if ((((unsigned long)oct_dev->io_qmask.oq >> i) & 1UL) == 0UL) 
#line 600 
                                                                 goto ldv_46510; else ;
  
#line 601 
  j = 0;
  
#line 601 
  goto ldv_46512;
  ldv_46511: 
#line 602 
  ;
  
#line 602 
  sprintf((char *)data,"OQ%d %s",i,(char const *)(& oct_droq_stats_strings[j]));
  
#line 603 
  data += 32U;
  
#line 601 
  j += 1;
  ldv_46512: 
#line 602 
  ;
  
#line 601 
  if (j < num_oq_stats) 
#line 603 
                        goto ldv_46511; else 
#line 606 
                                             goto ldv_46513;
  ldv_46513: 
#line 607 
  ;
  ldv_46510: 
#line 608 
  ;
  
#line 598 
  i += 1;
  ldv_46515: 
#line 599 
  ;
  
#line 598 
  if (i <= 31) 
#line 600 
               goto ldv_46514; else 
#line 603 
                                    goto ldv_46516;
  ldv_46516: 
#line 604 
  ;
  
#line 605 
  return;
}


#line 608  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static int lio_get_sset_count(struct net_device *netdev, int sset)
{
  int __retres;
  
#line 610 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 611 
  struct octeon_device *oct_dev = lio->oct_dev;
  
#line 613 
  __retres = (int)(oct_dev->num_iqs * 10U + oct_dev->num_oqs * 8U);
  
#line 613 
  return __retres;
}


#line 617  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static int lio_get_intr_coalesce(struct net_device *netdev, struct ethtool_coalesce *intr_coal)
{
  int __retres;
  struct octeon_instr_queue *iq;
  struct oct_intrmod_cfg *intrmod_cfg;
  
#line 620 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 621 
  struct octeon_device *oct = lio->oct_dev;
  
#line 622 
  struct octeon_cn6xxx *cn6xxx = (struct octeon_cn6xxx *)oct->chip;
  
#line 626 
  intrmod_cfg = & oct->intrmod;
  
#line 628 
  switch ((int)oct->chip_id) {
    case 145: 
#line 631 
    ;
    case 146: 
#line 632 
    ;
    
#line 633 
    if (intrmod_cfg->intrmod_enable == 0ULL) {
      
#line 634 
      intr_coal->rx_coalesce_usecs = (unsigned int)(cn6xxx->conf)->oq.oq_intr_time;
      
#line 636 
      intr_coal->rx_max_coalesced_frames = (unsigned int)(cn6xxx->conf)->oq.oq_intr_pkt;
    }
    else {
      
#line 639 
      intr_coal->use_adaptive_rx_coalesce = (unsigned int)intrmod_cfg->intrmod_enable;
      
#line 641 
      intr_coal->rate_sample_interval = (unsigned int)intrmod_cfg->intrmod_check_intrvl;
      
#line 643 
      intr_coal->pkt_rate_high = (unsigned int)intrmod_cfg->intrmod_maxpkt_ratethr;
      
#line 645 
      intr_coal->pkt_rate_low = (unsigned int)intrmod_cfg->intrmod_minpkt_ratethr;
      
#line 647 
      intr_coal->rx_max_coalesced_frames_high = (unsigned int)intrmod_cfg->intrmod_maxcnt_trigger;
      
#line 649 
      intr_coal->rx_coalesce_usecs_high = (unsigned int)intrmod_cfg->intrmod_maxtmr_trigger;
      
#line 651 
      intr_coal->rx_coalesce_usecs_low = (unsigned int)intrmod_cfg->intrmod_mintmr_trigger;
      
#line 653 
      intr_coal->rx_max_coalesced_frames_low = (unsigned int)intrmod_cfg->intrmod_mincnt_trigger;
    }
    
#line 657 
    iq = oct->instr_queue[(int)lio->linfo.txpciq[0]];
    
#line 658 
    intr_coal->tx_max_coalesced_frames = iq->fill_threshold;
    
#line 659 
    goto ldv_46540;
    default: 
#line 661 
    ;
    
#line 662 
    if ((lio->msg_enable & 1U) != 0U) 
#line 662 
                                      netdev_info((struct net_device const *)lio->netdev,"Unknown Chip !!\n"); else ;
    
#line 663 
    __retres = -22;
    
#line 663 
    goto return_label;
  }
  ldv_46540: 
#line 666 
  ;
  
#line 666 
  __retres = 0;
  return_label: 
#line 666 
                return __retres;
}


#line 670  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static void octnet_intrmod_callback(struct octeon_device *oct_dev, u32 status, void *ptr)
{
  
#line 674 
  struct oct_intrmod_cmd *cmd = (struct oct_intrmod_cmd *)ptr;
  
#line 675 
  struct octeon_soft_command *sc = cmd->sc;
  
#line 677 
  oct_dev = cmd->oct_dev;
  
#line 679 
  if (status != 0U) 
#line 680 
                    dev_err((struct device const *)(& (oct_dev->pci_dev)->dev),"intrmod config failed. Status: %llx\n",(long long)status); else 
                                                                    
#line 683 
                                                                    _dev_info((struct device const *)(& (oct_dev->pci_dev)->dev),"Rx-Adaptive Interrupt moderation enabled:%llx\n",oct_dev->intrmod.intrmod_enable);
  
#line 687 
  octeon_free_soft_command(oct_dev,sc);
  
#line 688 
  return;
}


#line 691  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static int octnet_set_intrmod_cfg(void *oct, struct oct_intrmod_cfg *intr_cfg)
{
  int __retres;
  struct octeon_soft_command *sc;
  struct oct_intrmod_cmd *cmd;
  struct oct_intrmod_cfg *cfg;
  int retval;
  
#line 697 
  struct octeon_device *oct_dev = (struct octeon_device *)oct;
  
#line 700 
  sc = octeon_alloc_soft_command(oct_dev,64U,0U,24U);
  
#line 706 
  if (sc == (struct octeon_soft_command *)0) {
    
#line 707 
    __retres = -12;
    
#line 707 
    goto return_label;
  }
  else ;
  
#line 709 
  cmd = (struct oct_intrmod_cmd *)sc->ctxptr;
  
#line 710 
  cfg = (struct oct_intrmod_cfg *)sc->virtdptr;
  
#line 712 
  memcpy((void *)cfg,(void const *)intr_cfg,64UL);
  
#line 713 
  octeon_swap_8B_data_1((u64 *)cfg,8U);
  
#line 714 
  cmd->sc = sc;
  
#line 715 
  cmd->cfg = cfg;
  
#line 716 
  cmd->oct_dev = oct_dev;
  
#line 718 
  octeon_prepare_soft_command(oct_dev,sc,(unsigned char)1,(unsigned char)8,0U,0ULL,0ULL);
  
#line 721 
  sc->callback = & octnet_intrmod_callback;
  
#line 722 
  sc->callback_arg = (void *)cmd;
  
#line 723 
  sc->wait_time = 1000UL;
  
#line 725 
  retval = octeon_send_soft_command(oct_dev,sc);
  
#line 726 
  if (retval != 0) {
    
#line 727 
    octeon_free_soft_command(oct_dev,sc);
    
#line 728 
    __retres = -22;
    
#line 728 
    goto return_label;
  }
  else ;
  
#line 731 
  __retres = 0;
  return_label: 
#line 731 
                return __retres;
}


#line 735  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static int oct_cfg_adaptive_intr(struct lio *lio, struct ethtool_coalesce *intr_coal, int adaptive)
{
  struct oct_intrmod_cfg *intrmod_cfg;
  
#line 738 
  int ret = 0;
  
#line 739 
  struct octeon_device *oct = lio->oct_dev;
  
#line 742 
  intrmod_cfg = & oct->intrmod;
  
#line 744 
  if (adaptive != 0) {
    
#line 745 
    if (intr_coal->rate_sample_interval != 0U) 
#line 746 
                                               intrmod_cfg->intrmod_check_intrvl = (unsigned long long)intr_coal->rate_sample_interval; else 
                                                                    
#line 749 
                                                                    intrmod_cfg->intrmod_check_intrvl = 1ULL;
    
#line 752 
    if (intr_coal->pkt_rate_high != 0U) 
#line 753 
                                        intrmod_cfg->intrmod_maxpkt_ratethr = (unsigned long long)intr_coal->pkt_rate_high; else 
                                                                    
#line 756 
                                                                    intrmod_cfg->intrmod_maxpkt_ratethr = 196608ULL;
    
#line 759 
    if (intr_coal->pkt_rate_low != 0U) 
#line 760 
                                       intrmod_cfg->intrmod_minpkt_ratethr = (unsigned long long)intr_coal->pkt_rate_low; else 
                                                                    
#line 763 
                                                                    intrmod_cfg->intrmod_minpkt_ratethr = 9216ULL;
    
#line 766 
    if (intr_coal->rx_max_coalesced_frames_high != 0U) 
#line 767 
                                                       intrmod_cfg->intrmod_maxcnt_trigger = (unsigned long long)intr_coal->rx_max_coalesced_frames_high; else 
                                                                    
#line 770 
                                                                    intrmod_cfg->intrmod_maxcnt_trigger = 384ULL;
    
#line 773 
    if (intr_coal->rx_coalesce_usecs_high != 0U) 
#line 774 
                                                 intrmod_cfg->intrmod_maxtmr_trigger = (unsigned long long)intr_coal->rx_coalesce_usecs_high; else 
                                                                    
#line 777 
                                                                    intrmod_cfg->intrmod_maxtmr_trigger = 128ULL;
    
#line 780 
    if (intr_coal->rx_coalesce_usecs_low != 0U) 
#line 781 
                                                intrmod_cfg->intrmod_mintmr_trigger = (unsigned long long)intr_coal->rx_coalesce_usecs_low; else 
                                                                    
#line 784 
                                                                    intrmod_cfg->intrmod_mintmr_trigger = 32ULL;
    
#line 787 
    if (intr_coal->rx_max_coalesced_frames_low != 0U) 
#line 788 
                                                      intrmod_cfg->intrmod_mincnt_trigger = (unsigned long long)intr_coal->rx_max_coalesced_frames_low; else 
                                                                    
#line 791 
                                                                    intrmod_cfg->intrmod_mincnt_trigger = 1ULL;
  }
  else ;
  
#line 795 
  intrmod_cfg->intrmod_enable = (unsigned long long)adaptive;
  
#line 796 
  ret = octnet_set_intrmod_cfg((void *)oct,intrmod_cfg);
  
#line 798 
  return ret;
}


#line 802  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static int oct_cfg_rx_intrcnt(struct lio *lio, struct ethtool_coalesce *intr_coal)
{
  int __retres;
  int ret;
  u32 rx_max_coalesced_frames;
  
#line 805 
  struct octeon_device *oct = lio->oct_dev;
  
#line 806 
  struct octeon_cn6xxx *cn6xxx = (struct octeon_cn6xxx *)oct->chip;
  
#line 809 
  if (intr_coal->rx_max_coalesced_frames == 0U) 
#line 810 
                                                rx_max_coalesced_frames = 64U; else 
                                                                    
#line 812 
                                                                    rx_max_coalesced_frames = intr_coal->rx_max_coalesced_frames;
  
#line 815 
  ret = oct_cfg_adaptive_intr(lio,intr_coal,0);
  
#line 816 
  if (ret != 0) {
    
#line 817 
    __retres = ret;
    
#line 817 
    goto return_label;
  }
  else ;
  
#line 820 
  writel(rx_max_coalesced_frames,(void volatile *)(oct->mmio[0].hw_addr + 4384U));
  
#line 822 
  (cn6xxx->conf)->oq.oq_intr_pkt = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))((unsigned short)rx_max_coalesced_frames);
  
#line 823 
  __retres = 0;
  return_label: 
#line 823 
                return __retres;
}


#line 826  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static int oct_cfg_rx_intrtime(struct lio *lio, struct ethtool_coalesce *intr_coal)
{
  int __retres;
  int ret;
  u32 time_threshold;
  u32 rx_coalesce_usecs;
  
#line 830 
  struct octeon_device *oct = lio->oct_dev;
  
#line 831 
  struct octeon_cn6xxx *cn6xxx = (struct octeon_cn6xxx *)oct->chip;
  
#line 834 
  if (intr_coal->rx_coalesce_usecs == 0U) 
#line 835 
                                          rx_coalesce_usecs = 100U; else 
                                                                    
#line 837 
                                                                    rx_coalesce_usecs = intr_coal->rx_coalesce_usecs;
  
#line 840 
  ret = oct_cfg_adaptive_intr(lio,intr_coal,0);
  
#line 841 
  if (ret != 0) {
    
#line 842 
    __retres = ret;
    
#line 842 
    goto return_label;
  }
  else ;
  
#line 845 
  time_threshold = lio_cn6xxx_get_oq_ticks(oct,rx_coalesce_usecs);
  
#line 846 
  writel(time_threshold,(void volatile *)(oct->mmio[0].hw_addr + 4388U));
  
#line 847 
  (cn6xxx->conf)->oq.oq_intr_time = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))((unsigned short)rx_coalesce_usecs);
  
#line 849 
  __retres = 0;
  return_label: 
#line 849 
                return __retres;
}


#line 852  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static int lio_set_intr_coalesce(struct net_device *netdev, struct ethtool_coalesce *intr_coal)
{
  int __retres;
  int ret;
  u32 j;
  u32 q_no;
  
#line 855 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 857 
  struct octeon_device *oct = lio->oct_dev;
  
#line 860 
  if (intr_coal->tx_max_coalesced_frames + 4294967295U <= 7U) {
    
#line 862 
    j = 0U;
    
#line 862 
    goto ldv_46593;
    ldv_46592: 
#line 863 
    ;
    
#line 863 
    q_no = (unsigned int)lio->linfo.txpciq[j];
    
#line 864 
    (oct->instr_queue[q_no])->fill_threshold = intr_coal->tx_max_coalesced_frames;
    
#line 862 
    j += 1U;
    ldv_46593: 
#line 863 
    ;
    
#line 862 
    if ((unsigned int)lio->linfo.num_txpciq > j) 
#line 864 
                                                 goto ldv_46592; else 
                                                                   
#line 867 
                                                                   goto ldv_46594;
    ldv_46594: 
#line 868 
    ;
  }
  else {
    
#line 868 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"LIQUIDIO: Invalid tx-frames:%d. Range is min:%d max:%d\n",intr_coal->tx_max_coalesced_frames,1,8);
    
#line 872 
    __retres = -22;
    
#line 872 
    goto return_label;
  }
  
#line 876 
  if (intr_coal->use_adaptive_rx_coalesce != 0U) {
    
#line 877 
    ret = oct_cfg_adaptive_intr(lio,intr_coal,1);
    
#line 878 
    if (ret != 0) 
#line 879 
                  goto ret_intrmod; else ;
  }
  else ;
  
#line 883 
  if (intr_coal->rx_coalesce_usecs != 0U && intr_coal->use_adaptive_rx_coalesce == 0U) {
    
#line 885 
    ret = oct_cfg_rx_intrtime(lio,intr_coal);
    
#line 886 
    if (ret != 0) 
#line 887 
                  goto ret_intrmod; else ;
  }
  else ;
  
#line 891 
  if (intr_coal->rx_max_coalesced_frames != 0U && intr_coal->use_adaptive_rx_coalesce == 0U) {
    
#line 893 
    ret = oct_cfg_rx_intrcnt(lio,intr_coal);
    
#line 894 
    if (ret != 0) 
#line 895 
                  goto ret_intrmod; else ;
  }
  else ;
  
#line 899 
  if ((intr_coal->rx_max_coalesced_frames == 0U && intr_coal->use_adaptive_rx_coalesce == 0U) && intr_coal->rx_coalesce_usecs == 0U) {
    
#line 902 
    _dev_info((struct device const *)(& (oct->pci_dev)->dev),"Turning off adaptive-rx interrupt moderation\n");
    
#line 904 
    _dev_info((struct device const *)(& (oct->pci_dev)->dev),"Using RX Coalesce Default values rx_coalesce_usecs:%d rx_max_coalesced_frames:%d\n",100,64);
    
#line 907 
    ret = oct_cfg_rx_intrtime(lio,intr_coal);
    
#line 908 
    if (ret != 0) 
#line 909 
                  goto ret_intrmod; else ;
    
#line 911 
    ret = oct_cfg_rx_intrcnt(lio,intr_coal);
    
#line 912 
    if (ret != 0) 
#line 913 
                  goto ret_intrmod; else ;
  }
  else ;
  
#line 916 
  __retres = 0;
  
#line 916 
  goto return_label;
  ret_intrmod: 
#line 917 
  ;
  
#line 918 
  __retres = ret;
  return_label: 
#line 918 
                return __retres;
}


#line 921  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static int lio_get_ts_info(struct net_device *netdev, struct ethtool_ts_info *info)
{
  int __retres;
  
#line 924 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 926 
  info->so_timestamping = 95U;
  
#line 933 
  if (lio->ptp_clock != (struct ptp_clock *)0) 
#line 934 
                                               info->phc_index = ptp_clock_index(lio->ptp_clock); else 
                                                                    
#line 936 
                                                                    info->phc_index = -1;
  
#line 938 
  info->tx_types = 3U;
  
#line 940 
  info->rx_filters = 585U;
  
#line 945 
  __retres = 0;
  
#line 945 
  return __retres;
}


#line 948  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static int lio_set_settings(struct net_device *netdev, struct ethtool_cmd *ecmd)
{
  int __retres;
  struct oct_link_info *linfo;
  struct octnic_ctrl_pkt nctrl;
  struct octnic_ctrl_params nparams;
  
#line 950 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 951 
  struct octeon_device *oct = lio->oct_dev;
  
#line 955 
  int ret = 0;
  
#line 958 
  linfo = & lio->linfo;
  
#line 960 
  if ((unsigned int)ecmd->autoneg > 1U) {
    
#line 961 
    __retres = -22;
    
#line 961 
    goto return_label;
  }
  else ;
  
#line 963 
  if ((unsigned int)ecmd->autoneg == 0U && (((unsigned int)ecmd->speed != 100U && (unsigned int)ecmd->speed != 10U) || (unsigned int)ecmd->duplex > 1U)) {
    
#line 967 
    __retres = -22;
    
#line 967 
    goto return_label;
  }
  else ;
  
#line 972 
  if ((unsigned int)*((unsigned char *)(& linfo->link.s) + 1UL) == 40U || (unsigned int)*((unsigned char *)(& linfo->link.s) + 1UL) == 96U) {
    
#line 974 
    _dev_info((struct device const *)(& (oct->pci_dev)->dev),"XAUI IFs settings cannot be modified.\n");
    
#line 975 
    __retres = -22;
    
#line 975 
    goto return_label;
  }
  else ;
  
#line 978 
  memset((void *)(& nctrl),0,320UL);
  
#line 980 
  nctrl.ncmd.u64 = 0ULL;
  
#line 981 
  nctrl.ncmd.s.cmd = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(5))))7U;
  
#line 982 
  nctrl.wait_time = 1000UL;
  
#line 983 
  nctrl.netpndev = (unsigned long long)netdev;
  
#line 984 
  nctrl.ncmd.s.param1 = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(29))))lio->linfo.ifidx;
  
#line 985 
  nctrl.cb_fn = & liquidio_link_ctrl_cmd_completion;
  
#line 990 
  if ((unsigned int)ecmd->autoneg == 1U) {
    
#line 992 
    nctrl.ncmd.s.more = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))3U;
    
#line 994 
    nctrl.ncmd.s.param2 = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))((unsigned short)ecmd->advertising);
  }
  else {
    
#line 997 
    nctrl.ncmd.s.more = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))2U;
    
#line 999 
    nctrl.ncmd.s.param3 = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))ecmd->duplex;
    
#line 1001 
    nctrl.ncmd.s.param2 = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))ecmd->speed;
  }
  
#line 1004 
  nparams.resp_order = 0U;
  
#line 1006 
  ret = octnet_send_nic_ctrl_pkt(lio->oct_dev,& nctrl,nparams);
  
#line 1007 
  if (ret < 0) {
    
#line 1008 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Failed to set settings\n");
    
#line 1009 
    __retres = -1;
    
#line 1009 
    goto return_label;
  }
  else ;
  
#line 1012 
  __retres = 0;
  return_label: 
#line 1012 
                return __retres;
}


#line 1015  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static int lio_nway_reset(struct net_device *netdev)
{
  int __retres;
  bool tmp;
  
#line 1017 
  tmp = netif_running((struct net_device const *)netdev);
  
#line 1017 
  if ((int)tmp != 0) {
    struct ethtool_cmd ecmd;
    
#line 1020 
    memset((void *)(& ecmd),0,44UL);
    
#line 1021 
    ecmd.autoneg = (unsigned char)0U;
    
#line 1022 
    ecmd.speed = (unsigned short)0U;
    
#line 1023 
    ecmd.duplex = (unsigned char)0U;
    
#line 1024 
    lio_set_settings(netdev,& ecmd);
  }
  else ;
  
#line 1026 
  __retres = 0;
  
#line 1026 
  return __retres;
}


#line 1030  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static int lio_get_regs_len(struct net_device *dev)
{
  int __retres;
  
#line 1032 
  __retres = 4096;
  
#line 1032 
  return __retres;
}


#line 1035  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static int cn6xxx_read_csr_reg(char *s, struct octeon_device *oct)
{
  u32 reg;
  int i;
  int tmp;
  int tmp_1;
  unsigned int tmp_0;
  int tmp_3;
  unsigned int tmp_2;
  int tmp_5;
  unsigned int tmp_4;
  int tmp_7;
  unsigned int tmp_6;
  int tmp_9;
  unsigned int tmp_8;
  int tmp_11;
  unsigned int tmp_10;
  int tmp_13;
  unsigned int tmp_12;
  int tmp_15;
  unsigned int tmp_14;
  int tmp_17;
  unsigned int tmp_16;
  int tmp_19;
  unsigned int tmp_18;
  int tmp_21;
  unsigned int tmp_20;
  int tmp_23;
  unsigned int tmp_22;
  int tmp_25;
  unsigned int tmp_24;
  int tmp_27;
  unsigned int tmp_26;
  int tmp_33;
  unsigned int tmp_32;
  int tmp_35;
  unsigned int tmp_34;
  int tmp_37;
  unsigned int tmp_36;
  int tmp_39;
  unsigned int tmp_38;
  int tmp_41;
  unsigned int tmp_40;
  int tmp_43;
  unsigned int tmp_42;
  int tmp_44;
  u64 tmp_45;
  int tmp_46;
  
#line 1038 
  int len = 0;
  
#line 1042 
  tmp = sprintf(s + len,"\n\t Octeon CSR Registers\n\n");
  
#line 1042 
  len = tmp + len;
  
#line 1043 
  reg = 0U;
  
#line 1044 
  tmp_0 = readl((void const volatile *)(oct->mmio[0].hw_addr + reg));
  
#line 1044 
  ;
  
#line 1044 
  tmp_1 = sprintf(s + len,"\n[%02x] (WIN_WR_ADDR_LO): %08x\n",0,tmp_0);
  
#line 1045 
  len = tmp_1 + len;
  
#line 1046 
  reg = 4U;
  
#line 1047 
  tmp_2 = readl((void const volatile *)(oct->mmio[0].hw_addr + reg));
  
#line 1047 
  ;
  
#line 1047 
  tmp_3 = sprintf(s + len,"[%02x] (WIN_WR_ADDR_HI): %08x\n",4,tmp_2);
  
#line 1048 
  len = tmp_3 + len;
  
#line 1049 
  reg = 16U;
  
#line 1050 
  tmp_4 = readl((void const volatile *)(oct->mmio[0].hw_addr + reg));
  
#line 1050 
  ;
  
#line 1050 
  tmp_5 = sprintf(s + len,"[%02x] (WIN_RD_ADDR_LO): %08x\n",16,tmp_4);
  
#line 1051 
  len = tmp_5 + len;
  
#line 1052 
  reg = 20U;
  
#line 1053 
  tmp_6 = readl((void const volatile *)(oct->mmio[0].hw_addr + reg));
  
#line 1053 
  ;
  
#line 1053 
  tmp_7 = sprintf(s + len,"[%02x] (WIN_RD_ADDR_HI): %08x\n",20,tmp_6);
  
#line 1054 
  len = tmp_7 + len;
  
#line 1055 
  reg = 32U;
  
#line 1056 
  tmp_8 = readl((void const volatile *)(oct->mmio[0].hw_addr + reg));
  
#line 1056 
  ;
  
#line 1056 
  tmp_9 = sprintf(s + len,"[%02x] (WIN_WR_DATA_LO): %08x\n",32,tmp_8);
  
#line 1057 
  len = tmp_9 + len;
  
#line 1058 
  reg = 36U;
  
#line 1059 
  tmp_10 = readl((void const volatile *)(oct->mmio[0].hw_addr + reg));
  
#line 1059 
  ;
  
#line 1059 
  tmp_11 = sprintf(s + len,"[%02x] (WIN_WR_DATA_HI): %08x\n",36,tmp_10);
  
#line 1060 
  len = tmp_11 + len;
  
#line 1061 
  tmp_12 = readl((void const volatile *)(oct->mmio[0].hw_addr + 48U));
  
#line 1061 
  ;
  
#line 1061 
  tmp_13 = sprintf(s + len,"[%02x] (WIN_WR_MASK_REG): %08x\n",48,tmp_12);
  
#line 1063 
  len = tmp_13 + len;
  
#line 1066 
  tmp_14 = readl((void const volatile *)(oct->mmio[0].hw_addr + 832U));
  
#line 1066 
  ;
  
#line 1066 
  tmp_15 = sprintf(s + len,"\n[%x] (INT_ENABLE PORT 0): %08x\n",832,tmp_14);
  
#line 1068 
  len = tmp_15 + len;
  
#line 1069 
  tmp_16 = readl((void const volatile *)(oct->mmio[0].hw_addr + 848U));
  
#line 1069 
  ;
  
#line 1069 
  tmp_17 = sprintf(s + len,"\n[%x] (INT_ENABLE PORT 1): %08x\n",848,tmp_16);
  
#line 1071 
  len = tmp_17 + len;
  
#line 1072 
  tmp_18 = readl((void const volatile *)(oct->mmio[0].hw_addr + 816U));
  
#line 1072 
  ;
  
#line 1072 
  tmp_19 = sprintf(s + len,"[%x] (INT_SUM): %08x\n",816,tmp_18);
  
#line 1073 
  len = tmp_19 + len;
  
#line 1076 
  i = 0;
  
#line 1076 
  goto ldv_46626;
  ldv_46625: 
#line 1077 
  ;
  
#line 1077 
  reg = (unsigned int)((i + 576) * 16);
  
#line 1078 
  tmp_20 = readl((void const volatile *)(oct->mmio[0].hw_addr + reg));
  
#line 1078 
  ;
  
#line 1078 
  ;
  
#line 1078 
  ;
  
#line 1078 
  tmp_21 = sprintf(s + len,"\n[%x] (PKTS_SENT_%d): %08x\n",reg,i,tmp_20);
  
#line 1079 
  len = tmp_21 + len;
  
#line 1080 
  reg = (unsigned int)((i + 384) * 16);
  
#line 1081 
  tmp_22 = readl((void const volatile *)(oct->mmio[0].hw_addr + reg));
  
#line 1081 
  ;
  
#line 1081 
  ;
  
#line 1081 
  ;
  
#line 1081 
  tmp_23 = sprintf(s + len,"[%x] (PKT_CREDITS_%d): %08x\n",reg,i,tmp_22);
  
#line 1082 
  len = tmp_23 + len;
  
#line 1076 
  i += 1;
  ldv_46626: 
#line 1077 
  ;
  
#line 1076 
  if (oct->num_oqs > (unsigned int)i) 
#line 1078 
                                      goto ldv_46625; else 
#line 1081 
                                                           goto ldv_46627;
  ldv_46627: 
#line 1082 
  ;
  
#line 1084 
  reg = 4384U;
  
#line 1085 
  tmp_24 = readl((void const volatile *)(oct->mmio[0].hw_addr + reg));
  
#line 1085 
  ;
  
#line 1085 
  ;
  
#line 1085 
  tmp_25 = sprintf(s + len,"\n[%x] (PKTS_SENT_INT_LEVEL): %08x\n",reg,tmp_24);
  
#line 1086 
  len = tmp_25 + len;
  
#line 1087 
  reg = 4388U;
  
#line 1088 
  tmp_26 = readl((void const volatile *)(oct->mmio[0].hw_addr + reg));
  
#line 1088 
  ;
  
#line 1088 
  ;
  
#line 1088 
  tmp_27 = sprintf(s + len,"[%x] (PKTS_SENT_TIME): %08x\n",reg,tmp_26);
  
#line 1089 
  len = tmp_27 + len;
  
#line 1092 
  i = 0;
  
#line 1092 
  goto ldv_46630;
  ldv_46629: 
#line 1093 
  ;
  {
    u32 reg_0;
    int tmp_29;
    unsigned int tmp_28;
    int tmp_31;
    unsigned int tmp_30;
    
#line 1095 
    reg_0 = (unsigned int)((i + 704) * 16);
    
#line 1096 
    tmp_28 = readl((void const volatile *)(oct->mmio[0].hw_addr + reg_0));
    
#line 1096 
    ;
    
#line 1096 
    ;
    
#line 1096 
    ;
    
#line 1096 
    tmp_29 = sprintf(s + len,"\n[%x] (INSTR_DOORBELL_%d): %08x\n",reg_0,i,tmp_28);
    
#line 1097 
    len = tmp_29 + len;
    
#line 1098 
    reg_0 = (unsigned int)((i + 512) * 16);
    
#line 1099 
    tmp_30 = readl((void const volatile *)(oct->mmio[0].hw_addr + reg_0));
    
#line 1099 
    ;
    
#line 1099 
    ;
    
#line 1099 
    ;
    
#line 1099 
    tmp_31 = sprintf(s + len,"[%x] (INSTR_COUNT_%d): %08x\n",reg_0,i,tmp_30);
    
#line 1100 
    len = tmp_31 + len;
  }
  
#line 1092 
  i += 1;
  ldv_46630: 
#line 1093 
  ;
  
#line 1092 
  if (i <= 3) 
#line 1094 
              goto ldv_46629; else 
#line 1097 
                                   goto ldv_46631;
  ldv_46631: 
#line 1098 
  ;
  
#line 1105 
  tmp_32 = readl((void const volatile *)(oct->mmio[0].hw_addr + 1024U));
  
#line 1105 
  ;
  
#line 1105 
  tmp_33 = sprintf(s + len,"\n[%x] (DMA_CNT_0): %08x\n",1024,tmp_32);
  
#line 1107 
  len = tmp_33 + len;
  
#line 1108 
  reg = 992U;
  
#line 1109 
  tmp_34 = readl((void const volatile *)(oct->mmio[0].hw_addr + reg));
  
#line 1109 
  ;
  
#line 1109 
  tmp_35 = sprintf(s + len,"[%x] (DMA_INT_LEV_0): %08x\n",992,tmp_34);
  
#line 1110 
  len = tmp_35 + len;
  
#line 1111 
  reg = 996U;
  
#line 1112 
  tmp_36 = readl((void const volatile *)(oct->mmio[0].hw_addr + reg));
  
#line 1112 
  ;
  
#line 1112 
  tmp_37 = sprintf(s + len,"[%x] (DMA_TIME_0): %08x\n",996,tmp_36);
  
#line 1114 
  len = tmp_37 + len;
  
#line 1116 
  tmp_38 = readl((void const volatile *)(oct->mmio[0].hw_addr + 1040U));
  
#line 1116 
  ;
  
#line 1116 
  tmp_39 = sprintf(s + len,"\n[%x] (DMA_CNT_1): %08x\n",1040,tmp_38);
  
#line 1118 
  len = tmp_39 + len;
  
#line 1119 
  reg = 1008U;
  
#line 1120 
  tmp_40 = readl((void const volatile *)(oct->mmio[0].hw_addr + reg));
  
#line 1120 
  ;
  
#line 1120 
  tmp_41 = sprintf(s + len,"[%x] (DMA_INT_LEV_1): %08x\n",1008,tmp_40);
  
#line 1122 
  len = tmp_41 + len;
  
#line 1123 
  reg = 1008U;
  
#line 1124 
  tmp_42 = readl((void const volatile *)(oct->mmio[0].hw_addr + reg));
  
#line 1124 
  ;
  
#line 1124 
  tmp_43 = sprintf(s + len,"[%x] (DMA_TIME_1): %08x\n",1012,tmp_42);
  
#line 1126 
  len = tmp_43 + len;
  
#line 1130 
  tmp_44 = sprintf(s + len,"\n");
  
#line 1130 
  len = tmp_44 + len;
  
#line 1132 
  i = 0;
  
#line 1132 
  goto ldv_46633;
  ldv_46632: 
#line 1133 
  ;
  
#line 1133 
  tmp_45 = lio_pci_readq(oct,((unsigned long long)oct->pcie_port * 16777216ULL + (unsigned long long)(i * 8)) + 307866477002920ULL);
  
#line 1133 
  reg = (unsigned int)tmp_45;
  
#line 1134 
  tmp_46 = sprintf(s + len,"[%llx] (BAR1_INDEX_%02d): %08x\n",((unsigned long long)oct->pcie_port * 16777216ULL + (unsigned long long)(i * 8)) + 307866477002920ULL,i,reg);
  
#line 1135 
  len = tmp_46 + len;
  
#line 1132 
  i += 1;
  ldv_46633: 
#line 1133 
  ;
  
#line 1132 
  if (i <= 15) 
#line 1134 
               goto ldv_46632; else 
#line 1137 
                                    goto ldv_46634;
  ldv_46634: 
#line 1138 
  ;
  
#line 1138 
  return len;
}


#line 1141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static int cn6xxx_read_config_reg(char *s, struct octeon_device *oct)
{
  u32 val;
  int i;
  int tmp;
  int tmp_0;
  int tmp_1;
  
#line 1144 
  int len = 0;
  
#line 1148 
  tmp = sprintf(s + len,"\n\t Octeon Config space Registers\n\n");
  
#line 1149 
  len = tmp + len;
  
#line 1151 
  i = 0;
  
#line 1151 
  goto ldv_46643;
  ldv_46642: 
#line 1152 
  ;
  
#line 1152 
  pci_read_config_dword((struct pci_dev const *)oct->pci_dev,i * 4,& val);
  
#line 1153 
  tmp_0 = sprintf(s + len,"[0x%x] (Config[%d]): 0x%08x\n",i * 4,i,val);
  
#line 1154 
  len = tmp_0 + len;
  
#line 1151 
  i += 1;
  ldv_46643: 
#line 1152 
  ;
  
#line 1151 
  if (i <= 13) 
#line 1153 
               goto ldv_46642; else 
#line 1156 
                                    goto ldv_46644;
  ldv_46644: 
#line 1157 
  ;
  
#line 1157 
  i = 30;
  
#line 1157 
  goto ldv_46646;
  ldv_46645: 
#line 1158 
  ;
  
#line 1158 
  pci_read_config_dword((struct pci_dev const *)oct->pci_dev,i * 4,& val);
  
#line 1159 
  tmp_1 = sprintf(s + len,"[0x%x] (Config[%d]): 0x%08x\n",i * 4,i,val);
  
#line 1160 
  len = tmp_1 + len;
  
#line 1157 
  i += 1;
  ldv_46646: 
#line 1158 
  ;
  
#line 1157 
  if (i <= 34) 
#line 1159 
               goto ldv_46645; else 
#line 1162 
                                    goto ldv_46647;
  ldv_46647: 
#line 1163 
  ;
  
#line 1163 
  return len;
}


#line 1167  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static void lio_get_regs(struct net_device *dev, struct ethtool_regs *regs, void *regbuf)
{
  
#line 1170 
  struct lio *lio = netdev_priv((struct net_device const *)dev);
  
#line 1171 
  int len = 0;
  
#line 1172 
  struct octeon_device *oct = lio->oct_dev;
  
#line 1174 
  memset(regbuf,0,4096UL);
  
#line 1175 
  regs->version = 1U;
  
#line 1177 
  switch ((int)oct->chip_id) {
    int tmp_0;
    int tmp_1;
    case 145: 
#line 1179 
    ;
    case 146: 
#line 1180 
    ;
    
#line 1181 
    tmp_0 = cn6xxx_read_csr_reg((char *)(regbuf + len),oct);
    
#line 1181 
    len = tmp_0 + len;
    
#line 1182 
    tmp_1 = cn6xxx_read_config_reg((char *)(regbuf + len),oct);
    
#line 1182 
    len = tmp_1 + len;
    
#line 1183 
    goto ldv_46658;
    default: 
#line 1184 
    ;
    
#line 1185 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"%s Unknown chipid: %d\n","lio_get_regs",(int)oct->chip_id);
  }
  ldv_46658: 
#line 1188 
  ;
  
#line 1189 
  return;
}


#line 1190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
static struct ethtool_ops const lio_ethtool_ops = {.get_settings = & lio_get_settings, .set_settings = & lio_set_settings, .get_drvinfo = & lio_get_drvinfo, .get_regs_len = & lio_get_regs_len, .get_regs = & lio_get_regs, .get_wol = (void (*)(struct net_device *, struct ethtool_wolinfo *))0, .set_wol = (int (*)(struct net_device *, struct ethtool_wolinfo *))0, .get_msglevel = & lio_get_msglevel, .set_msglevel = & lio_set_msglevel, .nway_reset = & lio_nway_reset, .get_link = & ethtool_op_get_link, .get_eeprom_len = & lio_get_eeprom_len, .get_eeprom = & lio_get_eeprom, .set_eeprom = (int (*)(struct net_device *, struct ethtool_eeprom *, u8 *))0, .get_coalesce = & lio_get_intr_coalesce, .set_coalesce = & lio_set_intr_coalesce, .get_ringparam = & lio_ethtool_get_ringparam, .set_ringparam = (int (*)(struct net_device *, struct ethtool_ringparam *))0, .get_pauseparam = & lio_get_pauseparam, .set_pauseparam = (int (*)(struct net_device *, struct ethtool_pauseparam *))0, .self_test = (void (*)(struct net_device *, struct ethtool_test *, u64 *))0, .get_strings = & lio_get_strings, .set_phys_id = & lio_set_phys_id, .get_ethtool_stats = & lio_get_ethtool_stats, .begin = (int (*)(struct net_device *))0, .complete = (void (*)(struct net_device *))0, .get_priv_flags = (u32 (*)(struct net_device *))0, .set_priv_flags = (int (*)(struct net_device *, u32 ))0, .get_sset_count = & lio_get_sset_count, .get_rxnfc = (int (*)(struct net_device *, struct ethtool_rxnfc *, u32 *))0, .set_rxnfc = (int (*)(struct net_device *, struct ethtool_rxnfc *))0, .flash_device = (int (*)(struct net_device *, struct ethtool_flash *))0, .reset = (int (*)(struct net_device *, u32 *))0, .get_rxfh_key_size = (u32 (*)(struct net_device *))0, .get_rxfh_indir_size = (u32 (*)(struct net_device *))0, .get_rxfh = (int (*)(struct net_device *, u32 *, u8 *, u8 *))0, .set_rxfh = (int (*)(struct net_device *, u32 const *, u8 const *, u8 const ))0, .get_channels = & lio_ethtool_get_channels, .set_channels = (int (*)(struct net_device *, struct ethtool_channels *))0, .get_dump_flag = (int (*)(struct net_device *, struct ethtool_dump *))0, .get_dump_data = (int (*)(struct net_device *, struct ethtool_dump *, void *))0, .set_dump = (int (*)(struct net_device *, struct ethtool_dump *))0, .get_ts_info = & lio_get_ts_info, .get_module_info = (int (*)(struct net_device *, struct ethtool_modinfo *))0, .get_module_eeprom = (int (*)(struct net_device *, struct ethtool_eeprom *, u8 *))0, .get_eee = (int (*)(struct net_device *, struct ethtool_eee *))0, .set_eee = (int (*)(struct net_device *, struct ethtool_eee *))0, .get_tunable = (int (*)(struct net_device *, struct ethtool_tunable const *, void *))0, .set_tunable = (int (*)(struct net_device *, struct ethtool_tunable const *, void const *))0};

#line 1214  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c"
void liquidio_set_ethtool_ops(struct net_device *netdev)
{
  
#line 1216 
  netdev->ethtool_ops = & lio_ethtool_ops;
  
#line 1217 
  return;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_ethtool.c.aux"
unsigned int (*ldv_emg_alias_ethtool_op_get_link_11)(struct net_device *) = & ethtool_op_get_link;

#line 73  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_ethtool.c.aux"
int ldv_emg_wrapper_lio_set_phys_id_5(struct net_device *arg0, enum ethtool_phys_id_state arg1)
{
  int tmp;
  
#line 74 
  tmp = lio_set_phys_id(arg0,arg1);
  
#line 74 
  return tmp;
}


#line 78  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_ethtool.c.aux"
void ldv_emg_wrapper_lio_get_ethtool_stats_9(struct net_device *arg0, struct ethtool_stats *arg1, unsigned long long *arg2)
{
  
#line 79 
  lio_get_ethtool_stats(arg0,arg1,arg2);
  
#line 80 
  return;
}


#line 83  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_ethtool.c.aux"
unsigned int ldv_emg_wrapper_lio_get_msglevel_15(struct net_device *arg0)
{
  unsigned int tmp;
  
#line 84 
  tmp = lio_get_msglevel(arg0);
  
#line 84 
  return tmp;
}


#line 88  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_ethtool.c.aux"
int ldv_emg_wrapper_lio_get_regs_len_27(struct net_device *arg0)
{
  int tmp;
  
#line 89 
  tmp = lio_get_regs_len(arg0);
  
#line 89 
  return tmp;
}


#line 93  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_ethtool.c.aux"
void ldv_emg_wrapper_lio_get_strings_6(struct net_device *arg0, unsigned int arg1, unsigned char *arg2)
{
  
#line 94 
  lio_get_strings(arg0,arg1,arg2);
  
#line 95 
  return;
}


#line 98  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_ethtool.c.aux"
int ldv_emg_wrapper_lio_set_intr_coalesce_28(struct net_device *arg0, struct ethtool_coalesce *arg1)
{
  int tmp;
  
#line 99 
  tmp = lio_set_intr_coalesce(arg0,arg1);
  
#line 99 
  return tmp;
}


#line 103  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_ethtool.c.aux"
int ldv_emg_wrapper_lio_get_settings_3(struct net_device *arg0, struct ethtool_cmd *arg1)
{
  int tmp;
  
#line 104 
  tmp = lio_get_settings(arg0,arg1);
  
#line 104 
  return tmp;
}


#line 108  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_ethtool.c.aux"
void ldv_emg_wrapper_lio_get_pauseparam_2(struct net_device *arg0, struct ethtool_pauseparam *arg1)
{
  
#line 109 
  lio_get_pauseparam(arg0,arg1);
  
#line 110 
  return;
}


#line 113  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_ethtool.c.aux"
int ldv_emg_wrapper_lio_get_sset_count_22(struct net_device *arg0, int arg1)
{
  int tmp;
  
#line 114 
  tmp = lio_get_sset_count(arg0,arg1);
  
#line 114 
  return tmp;
}


#line 118  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_ethtool.c.aux"
int ldv_emg_wrapper_lio_nway_reset_30(struct net_device *arg0)
{
  int tmp;
  
#line 119 
  tmp = lio_nway_reset(arg0);
  
#line 119 
  return tmp;
}


#line 123  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_ethtool.c.aux"
void ldv_emg_wrapper_lio_get_regs_21(struct net_device *arg0, struct ethtool_regs *arg1, void *arg2)
{
  
#line 124 
  lio_get_regs(arg0,arg1,arg2);
  
#line 125 
  return;
}


#line 128  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_ethtool.c.aux"
void ldv_emg_wrapper_lio_get_drvinfo_13(struct net_device *arg0, struct ethtool_drvinfo *arg1)
{
  
#line 129 
  lio_get_drvinfo(arg0,arg1);
  
#line 130 
  return;
}


#line 133  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_ethtool.c.aux"
int ldv_emg_wrapper_lio_get_ts_info_25(struct net_device *arg0, struct ethtool_ts_info *arg1)
{
  int tmp;
  
#line 134 
  tmp = lio_get_ts_info(arg0,arg1);
  
#line 134 
  return tmp;
}


#line 138  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_ethtool.c.aux"
int ldv_emg_wrapper_lio_set_settings_4(struct net_device *arg0, struct ethtool_cmd *arg1)
{
  int tmp;
  
#line 139 
  tmp = lio_set_settings(arg0,arg1);
  
#line 139 
  return tmp;
}


#line 143  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_ethtool.c.aux"
int ldv_emg_wrapper_lio_get_intr_coalesce_26(struct net_device *arg0, struct ethtool_coalesce *arg1)
{
  int tmp;
  
#line 144 
  tmp = lio_get_intr_coalesce(arg0,arg1);
  
#line 144 
  return tmp;
}


#line 148  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_ethtool.c.aux"
int ldv_emg_wrapper_lio_get_eeprom_len_31(struct net_device *arg0)
{
  int tmp;
  
#line 149 
  tmp = lio_get_eeprom_len(arg0);
  
#line 149 
  return tmp;
}


#line 153  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_ethtool.c.aux"
void ldv_emg_wrapper_lio_ethtool_get_ringparam_8(struct net_device *arg0, struct ethtool_ringparam *arg1)
{
  
#line 154 
  lio_ethtool_get_ringparam(arg0,arg1);
  
#line 155 
  return;
}


#line 158  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_ethtool.c.aux"
int ldv_emg_wrapper_lio_get_eeprom_18(struct net_device *arg0, struct ethtool_eeprom *arg1, unsigned char *arg2)
{
  int tmp;
  
#line 159 
  tmp = lio_get_eeprom(arg0,arg1,arg2);
  
#line 159 
  return tmp;
}


#line 163  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_ethtool.c.aux"
void ldv_emg_wrapper_lio_ethtool_get_channels_24(struct net_device *arg0, struct ethtool_channels *arg1)
{
  
#line 164 
  lio_ethtool_get_channels(arg0,arg1);
  
#line 165 
  return;
}


#line 168  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_ethtool.c.aux"
void ldv_emg_wrapper_lio_set_msglevel_29(struct net_device *arg0, unsigned int arg1)
{
  
#line 169 
  lio_set_msglevel(arg0,arg1);
  
#line 170 
  return;
}


#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/export.h"
extern struct module __this_module;


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr, unsigned long volatile *addr)
{
  
#line 74 
  if (0 != 0) 
#line 76 
              ldv_inline_asm(); else 
#line 79 
                                     ldv_inline_asm();
  
#line 80 
  return;
}


#line 204  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr, unsigned long volatile *addr)
{
  int __retres;
  
#line 206 
  ldv_inline_asm();
  
#line 207 
  ldv_inline_asm();
  
#line 206 
  __retres = 0;
  
#line 206 
  goto return_label;
  cc_label: 
#line 206 
  ;
  
#line 206 
  __retres = 1;
  return_label: 
#line 206 
                return __retres;
}


#line 346  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static unsigned long __ffs(unsigned long word)
{
  
#line 348 
  ldv_inline_asm();
  
#line 351 
  return word;
}


#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/arch_hweight.h"
__inline static unsigned long __arch_hweight64(__u64 w)
{
  
#line 47 
  unsigned long res = 0UL;
  
#line 48 
  ldv_inline_asm();
  
#line 58 
  return res;
}


#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitops.h"
__inline static unsigned long hweight_long(unsigned long w)
{
  unsigned long tmp_0;
  
#line 80 
  if (0 != 0) 
#line 80 
              tmp_0 = (unsigned long)((((unsigned int)((((((((((unsigned long long)w & 1ULL) != 0ULL) + (((unsigned long long)w & 2ULL) != 0ULL)) + (((unsigned long long)w & 4ULL) != 0ULL)) + (((unsigned long long)w & 8ULL) != 0ULL)) + (((unsigned long long)w & 16ULL) != 0ULL)) + (((unsigned long long)w & 32ULL) != 0ULL)) + (((unsigned long long)w & 64ULL) != 0ULL)) + (((unsigned long long)w & 128ULL) != 0ULL)) + (unsigned int)((((((((((unsigned long long)(w >> 8) & 1ULL) != 0ULL) + (((unsigned long long)(w >> 8) & 2ULL) != 0ULL)) + (((unsigned long long)(w >> 8) & 4ULL) != 0ULL)) + (((unsigned long long)(w >> 8) & 8ULL) != 0ULL)) + (((unsigned long long)(w >> 8) & 16ULL) != 0ULL)) + (((unsigned long long)(w >> 8) & 32ULL) != 0ULL)) + (((unsigned long long)(w >> 8) & 64ULL) != 0ULL)) + (((unsigned long long)(w >> 8) & 128ULL) != 0ULL))) + ((unsigned int)((((((((((unsigned long long)(w >> 16) & 1ULL) != 0ULL) + (((unsigned long long)(w >> 16) & 2ULL) != 0ULL)) + (((unsigned long long)(w >> 16) & 4ULL) != 0ULL)) + (((unsigned long long)(w >> 16) & 8ULL) != 0ULL)) + (((unsigned long long)(w >> 16) & 16ULL) != 0ULL)) + (((unsigned long long)(w >> 16) & 32ULL) != 0ULL)) + (((unsigned long long)(w >> 16) & 64ULL) != 0ULL)) + (((unsigned long long)(w >> 16) & 128ULL) != 0ULL)) + (unsigned int)((((((((((unsigned long long)(w >> 24) & 1ULL) != 0ULL) + (((unsigned long long)(w >> 24) & 2ULL) != 0ULL)) + (((unsigned long long)(w >> 24) & 4ULL) != 0ULL)) + (((unsigned long long)(w >> 24) & 8ULL) != 0ULL)) + (((unsigned long long)(w >> 24) & 16ULL) != 0ULL)) + (((unsigned long long)(w >> 24) & 32ULL) != 0ULL)) + (((unsigned long long)(w >> 24) & 64ULL) != 0ULL)) + (((unsigned long long)(w >> 24) & 128ULL) != 0ULL)))) + (((unsigned int)((((((((((unsigned long long)(w >> 32) & 1ULL) != 0ULL) + (((unsigned long long)(w >> 32) & 2ULL) != 0ULL)) + (((unsigned long long)(w >> 32) & 4ULL) != 0ULL)) + (((unsigned long long)(w >> 32) & 8ULL) != 0ULL)) + (((unsigned long long)(w >> 32) & 16ULL) != 0ULL)) + (((unsigned long long)(w >> 32) & 32ULL) != 0ULL)) + (((unsigned long long)(w >> 32) & 64ULL) != 0ULL)) + (((unsigned long long)(w >> 32) & 128ULL) != 0ULL)) + (unsigned int)((((((((((unsigned long long)(w >> 40) & 1ULL) != 0ULL) + (((unsigned long long)(w >> 40) & 2ULL) != 0ULL)) + (((unsigned long long)(w >> 40) & 4ULL) != 0ULL)) + (((unsigned long long)(w >> 40) & 8ULL) != 0ULL)) + (((unsigned long long)(w >> 40) & 16ULL) != 0ULL)) + (((unsigned long long)(w >> 40) & 32ULL) != 0ULL)) + (((unsigned long long)(w >> 40) & 64ULL) != 0ULL)) + (((unsigned long long)(w >> 40) & 128ULL) != 0ULL))) + ((unsigned int)((((((((((unsigned long long)(w >> 48) & 1ULL) != 0ULL) + (((unsigned long long)(w >> 48) & 2ULL) != 0ULL)) + (((unsigned long long)(w >> 48) & 4ULL) != 0ULL)) + (((unsigned long long)(w >> 48) & 8ULL) != 0ULL)) + (((unsigned long long)(w >> 48) & 16ULL) != 0ULL)) + (((unsigned long long)(w >> 48) & 32ULL) != 0ULL)) + (((unsigned long long)(w >> 48) & 64ULL) != 0ULL)) + (((unsigned long long)(w >> 48) & 128ULL) != 0ULL)) + (unsigned int)((((((((((unsigned long long)(w >> 56) & 1ULL) != 0ULL) + (((unsigned long long)(w >> 56) & 2ULL) != 0ULL)) + (((unsigned long long)(w >> 56) & 4ULL) != 0ULL)) + (((unsigned long long)(w >> 56) & 8ULL) != 0ULL)) + (((unsigned long long)(w >> 56) & 16ULL) != 0ULL)) + (((unsigned long long)(w >> 56) & 32ULL) != 0ULL)) + (((unsigned long long)(w >> 56) & 64ULL) != 0ULL)) + (((unsigned long long)(w >> 56) & 128ULL) != 0ULL))))); else 
                                                                    
#line 80 
                                                                    tmp_0 = __arch_hweight64((unsigned long long)w);
  
#line 80 
  return tmp_0;
}


#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitops.h"
__inline static unsigned long __ffs64(u64 word)
{
  unsigned long tmp;
  
#line 197 
  tmp = __ffs((unsigned long)word);
  
#line 197 
  return tmp;
}


#line 248  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
void __might_fault(char const *, int);


#line 295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-defs.h"
void __bad_size_call_parameter(void);


#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/string.h"
int strncmp(char const *, char const *, __kernel_size_t);


#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitmap.h"
int __bitmap_weight(unsigned long const *, unsigned int);


#line 298  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitmap.h"
__inline static int bitmap_weight(unsigned long const *src, unsigned int nbits)
{
  int __retres;
  int tmp_0;
  
#line 300 
  if (0 != 0 && nbits <= 64U) {
    unsigned long tmp;
    
#line 301 
    tmp = hweight_long(*src & (18446744073709551615UL >> (- nbits & 63U)));
    
#line 301 
    __retres = (int)tmp;
    
#line 301 
    goto return_label;
  }
  else ;
  
#line 302 
  tmp_0 = __bitmap_weight(src,nbits);
  
#line 302 
  __retres = tmp_0;
  return_label: 
#line 302 
                return __retres;
}


#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
extern int nr_cpu_ids;


#line 89 
extern struct cpumask const * const cpu_online_mask;


#line 90 
extern struct cpumask const * const cpu_present_mask;


#line 474  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
__inline static unsigned int cpumask_weight(struct cpumask const *srcp)
{
  unsigned int __retres;
  int tmp;
  
#line 476 
  tmp = bitmap_weight((unsigned long const *)(& srcp->bits),(unsigned int)nr_cpu_ids);
  
#line 476 
  __retres = (unsigned int)tmp;
  
#line 476 
  return __retres;
}


#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/math64.h"
__inline static u64 div_u64_rem(u64 dividend, u32 divisor, u32 *remainder)
{
  u64 __retres;
  
#line 20 
  *remainder = (unsigned int)(dividend % (unsigned long long)divisor);
  
#line 21 
  __retres = dividend / (unsigned long long)divisor;
  
#line 21 
  return __retres;
}


#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/err.h"
static bool IS_ERR(void const *ptr);


#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_1(spinlock_t *lock)
{
  
#line 312 
  _raw_spin_lock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 313 
  return;
}


#line 358 
static void ldv_spin_lock_86(spinlock_t *lock);


#line 362 
static void ldv_spin_lock_88_0(spinlock_t *lock);


#line 366 
static void ldv_spin_lock_100(spinlock_t *lock);


#line 367  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_bh_2(spinlock_t *lock)
{
  
#line 369 
  _raw_spin_lock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 370 
  return;
}


#line 395 
static void ldv_spin_lock_bh_76_0(spinlock_t *lock);


#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_1(spinlock_t *lock)
{
  
#line 365 
  _raw_spin_unlock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 366 
  return;
}


#line 407 
static void ldv_spin_unlock_87_0(spinlock_t *lock);


#line 411 
static void ldv_spin_unlock_89_0(spinlock_t *lock);


#line 415 
static void ldv_spin_unlock_101(spinlock_t *lock);


#line 416  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_bh_2(spinlock_t *lock)
{
  
#line 418 
  _raw_spin_unlock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 419 
  return;
}


#line 448 
static void ldv_spin_unlock_bh_77_1(spinlock_t *lock);


#line 462  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_irqrestore_1(spinlock_t *lock, unsigned long flags)
{
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
  }
  
#line 464 
  _raw_spin_unlock_irqrestore(& lock->__anonCompField_spinlock_18.rlock,flags);
  
#line 465 
  return;
}


#line 494 
static void ldv_spin_unlock_irqrestore_91(spinlock_t *lock, unsigned long flags);


#line 498 
static void ldv_spin_unlock_irqrestore_93(spinlock_t *lock, unsigned long flags);


#line 502 
static void ldv_spin_unlock_irqrestore_95(spinlock_t *lock, unsigned long flags);


#line 506 
static void ldv_spin_unlock_irqrestore_97(spinlock_t *lock, unsigned long flags);


#line 70  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static void ldv___ldv_spin_lock_90(spinlock_t *ldv_func_arg1);


#line 74 
static void ldv___ldv_spin_lock_92(spinlock_t *ldv_func_arg1);


#line 78 
static void ldv___ldv_spin_lock_94(spinlock_t *ldv_func_arg1);


#line 82 
static void ldv___ldv_spin_lock_96(spinlock_t *ldv_func_arg1);


#line 27  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/err.h"
long ldv_is_err(void const *ptr);


#line 191  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/time.h"
__inline static s64 timespec_to_ns(struct timespec const *ts)
{
  s64 __retres;
  
#line 193 
  __retres = (long long)ts->tv_sec * 1000000000LL + (long long)ts->tv_nsec;
  
#line 193 
  return __retres;
}


#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/completion.h"
__inline static void init_completion(struct completion *x)
{
  
#line 75 
  x->done = 0U;
  {
    struct lock_class_key __key;
    
#line 76 
    __init_waitqueue_head(& x->wait,"&x->wait",& __key);
  }
  
#line 78 
  return;
}


#line 91 
void wait_for_completion(struct completion *);


#line 95 
unsigned long wait_for_completion_timeout(struct completion *, unsigned long);


#line 106 
void complete(struct completion *);


#line 283  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ktime.h"
__inline static ktime_t ns_to_ktime(u64 ns)
{
  
#line 285 
  ktime_t const ktime_zero = {.tv64 = 0LL};
  
#line 287 
  ktime_t __constr_expr_17 = {.tv64 = (long long)((unsigned long long)ktime_zero.tv64 + ns)};
  
#line 287 
  return __constr_expr_17;
}


#line 505  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
static bool ldv_queue_delayed_work_98(struct workqueue_struct *wq, struct delayed_work *dwork, unsigned long delay);


#line 509 
static bool ldv_queue_delayed_work_99(struct workqueue_struct *wq, struct delayed_work *dwork, unsigned long delay);


#line 597 
static bool ldv_schedule_delayed_work_104(struct delayed_work *dwork, unsigned long delay);


#line 601 
static bool ldv_schedule_delayed_work_105(struct delayed_work *dwork, unsigned long delay);


#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/smp.h"
int smp_call_function_single_async(int, struct call_single_data *);


#line 586  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
bool try_module_get(struct module *);


#line 588 
void module_put(struct module *);


#line 864  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static void *dev_get_drvdata(struct device const *dev)
{
  void *__retres;
  
#line 866 
  __retres = dev->driver_data;
  
#line 866 
  return __retres;
}


#line 869  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev, void *data)
{
  
#line 871 
  dev->driver_data = data;
  
#line 872 
  return;
}


#line 1085 
void dev_warn(struct device const *, char const * , ...);


#line 945  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
__inline static void *lowmem_page_address(struct page const *page)
{
  void *__retres;
  
#line 947 
  __retres = (void *)((unsigned long)((unsigned long long)(((long)page + 24189255811072L) / 64L) << 12) + 18446612132314218496UL);
  
#line 947 
  return __retres;
}


#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_page(struct device *dev, struct page *page, size_t offset, size_t size, enum dma_data_direction dir)
{
  dma_addr_t addr;
  void *tmp_0;
  int tmp_1;
  
#line 80 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 83 
  ;
  
#line 83 
  tmp_0 = lowmem_page_address((struct page const *)page);
  
#line 83 
  ;
  
#line 83 
  kmemcheck_mark_initialized(tmp_0 + offset,(unsigned int)size);
  
#line 84 
  tmp_1 = valid_dma_direction((int)dir);
  
#line 84 
  if ((long)(tmp_1 == 0) != 0L) {
    
#line 86 
    ldv_inline_asm();
    
#line 84 
    ;
  }
  else ;
  
#line 85 
  addr = (*(ops->map_page))(dev,page,offset,size,dir,(struct dma_attrs *)0);
  
#line 86 
  debug_dma_map_page(dev,page,offset,size,(int)dir,addr,(_Bool)0);
  
#line 88 
  return addr;
}


#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_page(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir)
{
  int tmp_0;
  
#line 94 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 96 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 96 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 98 
    ldv_inline_asm();
    
#line 96 
    ;
  }
  else ;
  
#line 97 
  if (ops->unmap_page != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction , struct dma_attrs *))0) 
    
#line 98 
    (*(ops->unmap_page))(dev,addr,size,dir,(struct dma_attrs *)0); else ;
  
#line 99 
  debug_dma_unmap_page(dev,addr,size,(int)dir,(_Bool)0);
  
#line 100 
  return;
}


#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
int dma_supported(struct device *, u64);


#line 61 
int dma_set_mask(struct device *, u64);


#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
__inline static int dma_set_coherent_mask(struct device *dev, u64 mask)
{
  int __retres;
  int tmp;
  
#line 103 
  tmp = dma_supported(dev,mask);
  
#line 103 
  if (tmp == 0) {
    
#line 104 
    __retres = -5;
    
#line 104 
    goto return_label;
  }
  else ;
  
#line 105 
  dev->coherent_dma_mask = mask;
  
#line 106 
  __retres = 0;
  return_label: 
#line 106 
                return __retres;
}


#line 116  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
__inline static int dma_set_mask_and_coherent(struct device *dev, u64 mask)
{
  
#line 118 
  int rc = dma_set_mask(dev,mask);
  
#line 119 
  if (rc == 0) 
#line 120 
               dma_set_coherent_mask(dev,mask); else ;
  
#line 121 
  return rc;
}


#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kmalloc_1(size_t size, gfp_t flags);


#line 951  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
int pci_enable_device(struct pci_dev *);


#line 968 
void pci_disable_device(struct pci_dev *);


#line 971 
void pci_set_master(struct pci_dev *);


#line 1146 
static int ldv___pci_register_driver_79(struct pci_driver *ldv_func_arg1, struct module *ldv_func_arg2, char const *ldv_func_arg3);


#line 1158 
static void ldv_pci_unregister_driver_80(struct pci_driver *ldv_func_arg1);


#line 1212 
void pci_disable_msi(struct pci_dev *);


#line 1219 
int pci_enable_msi_range(struct pci_dev *, int, int);


#line 1220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_enable_msi_exact(struct pci_dev *dev, int nvec)
{
  int __retres;
  
#line 1222 
  int rc = pci_enable_msi_range(dev,nvec,nvec);
  
#line 1223 
  if (rc < 0) {
    
#line 1224 
    __retres = rc;
    
#line 1224 
    goto return_label;
  }
  else ;
  
#line 1225 
  __retres = 0;
  return_label: 
#line 1225 
                return __retres;
}


#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/pci-dma-compat.h"
__inline static void pci_unmap_page(struct pci_dev *hwdev, dma_addr_t dma_address, size_t size, int direction)
{
  struct device *tmp;
  
#line 61 
  ;
  
#line 61 
  ;
  
#line 61 
  ;
  
#line 61 
  if (hwdev != (struct pci_dev *)0) 
#line 61 
                                    tmp = & hwdev->dev; else 
#line 61 
                                                             tmp = (struct device *)0;
  
#line 61 
  dma_unmap_page(tmp,dma_address,size,(enum dma_data_direction)direction);
  
#line 62 
  return;
}


#line 1471  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev)
{
  void *tmp;
  
#line 1473 
  tmp = dev_get_drvdata((struct device const *)(& pdev->dev));
  
#line 1473 
  return tmp;
}


#line 1476  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev, void *data)
{
  
#line 1478 
  dev_set_drvdata(& pdev->dev,data);
  
#line 1479 
  return;
}


#line 650  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
unsigned long _copy_from_user(void *, void const *, unsigned int);


#line 652 
unsigned long _copy_to_user(void *, void const *, unsigned int);


#line 662 
void copy_from_user_overflow(void);


#line 664 
void copy_to_user_overflow(void);


#line 672 
void __copy_from_user_overflow(void);


#line 677 
void __copy_to_user_overflow(void);


#line 693  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_from_user(void *to, void const *from, unsigned long n)
{
  
#line 695 
  int sz = -1;
  
#line 697 
  __might_fault("./arch/x86/include/asm/uaccess.h",697);
  
#line 717 
  if ((long)(sz < 0) != 0L || (long)((unsigned long)sz >= n) != 0L) 
#line 718 
                                                                    n = _copy_from_user(to,from,(unsigned int)n);
  else 
    
#line 719 
    if (0 != 0) 
#line 720 
                copy_from_user_overflow(); else 
#line 722 
                                                __copy_from_user_overflow();
  
#line 724 
  return n;
}


#line 728  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_to_user(void *to, void const *from, unsigned long n)
{
  
#line 730 
  int sz = -1;
  
#line 732 
  __might_fault("./arch/x86/include/asm/uaccess.h",732);
  
#line 735 
  if ((long)(sz < 0) != 0L || (long)((unsigned long)sz >= n) != 0L) 
#line 736 
                                                                    n = _copy_to_user(to,from,(unsigned int)n);
  else 
    
#line 737 
    if (0 != 0) 
#line 738 
                copy_to_user_overflow(); else 
#line 740 
                                              __copy_to_user_overflow();
  
#line 742 
  return n;
}


#line 976  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_end_pointer(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 978 
  __retres = skb->head + skb->end;
  
#line 978 
  return __retres;
}


#line 1000  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct skb_shared_hwtstamps *skb_hwtstamps(struct sk_buff *skb)
{
  struct skb_shared_hwtstamps *__retres;
  unsigned char *tmp;
  
#line 1002 
  tmp = skb_end_pointer((struct sk_buff const *)skb);
  
#line 1002 
  __retres = & ((struct skb_shared_info *)tmp)->hwtstamps;
  
#line 1002 
  return __retres;
}


#line 1706 
unsigned char *skb_pull(struct sk_buff *, unsigned int);


#line 1880  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_transport_header(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 1882 
  __retres = skb->head + (int)skb->transport_header;
  
#line 1882 
  return __retres;
}


#line 1897  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_network_header(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 1899 
  __retres = skb->head + (int)skb->network_header;
  
#line 1899 
  return __retres;
}


#line 1913  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_mac_header(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 1915 
  __retres = skb->head + (int)skb->mac_header;
  
#line 1915 
  return __retres;
}


#line 2911 
void skb_tstamp_tx(struct sk_buff *, struct skb_shared_hwtstamps *);


#line 3295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static u16 skb_get_queue_mapping(struct sk_buff const *skb)
{
  u16 __retres;
  
#line 3297 
  __retres = skb->queue_mapping;
  
#line 3297 
  return __retres;
}


#line 3310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static u16 skb_get_rx_queue(struct sk_buff const *skb)
{
  u16 __retres;
  
#line 3312 
  __retres = (unsigned short)((unsigned int)skb->queue_mapping + 65535U);
  
#line 3312 
  return __retres;
}


#line 3315  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static bool skb_rx_queue_recorded(struct sk_buff const *skb)
{
  bool __retres;
  
#line 3317 
  __retres = (_Bool)((unsigned int)skb->queue_mapping != 0U);
  
#line 3317 
  return __retres;
}


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ip.h"
__inline static struct iphdr *ip_hdr(struct sk_buff const *skb)
{
  struct iphdr *tmp;
  
#line 25 
  tmp = (struct iphdr *)skb_network_header(skb);
  
#line 25 
  return tmp;
}


#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/delay.h"
void __const_udelay(unsigned long);


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_queue_limits.h"
__inline static void dql_queued(struct dql *dql, unsigned int count)
{
  
#line 74 
  if ((long)(count > 268435455U) != 0L) {
    
#line 76 
    ldv_inline_asm();
    
#line 74 
    ;
  }
  else ;
  
#line 76 
  dql->last_obj_cnt = count;
  
#line 77 
  ldv_inline_asm();
  
#line 85 
  dql->num_queued += count;
  
#line 86 
  return;
}


#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_queue_limits.h"
__inline static int dql_avail(struct dql const *dql)
{
  int __retres;
  unsigned int const volatile *tmp;
  unsigned int const volatile *tmp_0;
  {
    
#line 91 
    unsigned int const __var = 0U;
    
#line 91 
    tmp = (unsigned int const volatile *)(& dql->adj_limit);
  }
  {
    
#line 91 
    unsigned int const __var_0 = 0U;
    
#line 91 
    tmp_0 = (unsigned int const volatile *)(& dql->num_queued);
  }
  
#line 91 
  ;
  
#line 91 
  __retres = (int)(*tmp - *tmp_0);
  
#line 91 
  return __retres;
}


#line 95 
void dql_completed(struct dql *, unsigned int);


#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
static int ldv_request_irq_82(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev);


#line 153 
static void ldv_free_irq_78(unsigned int ldv_func_arg1, void *ldv_func_arg2);


#line 157 
static void ldv_free_irq_83(unsigned int ldv_func_arg1, void *ldv_func_arg2);


#line 540 
static void ldv_tasklet_schedule_74(struct tasklet_struct *t);


#line 544 
static void ldv_tasklet_schedule_75(struct tasklet_struct *t);


#line 548 
static void ldv_tasklet_schedule_81(struct tasklet_struct *t);


#line 591 
void tasklet_kill(struct tasklet_struct *);


#line 597 
static void ldv_tasklet_init_106(struct tasklet_struct *ldv_func_arg1, void (*ldv_func_arg2)(unsigned long ), unsigned long ldv_func_arg3);


#line 391  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
void __napi_schedule(struct napi_struct *);


#line 394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool napi_disable_pending(struct napi_struct *n)
{
  bool __retres;
  int tmp;
  
#line 396 
  tmp = constant_test_bit(1L,(unsigned long const volatile *)(& n->state));
  
#line 396 
  __retres = (_Bool)(tmp != 0);
  
#line 396 
  return __retres;
}


#line 408  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool napi_schedule_prep(struct napi_struct *n)
{
  bool __retres;
  int tmp_2;
  int tmp_0;
  bool tmp;
  
#line 410 
  tmp = napi_disable_pending(n);
  
#line 410 
  if (tmp) 
#line 410 
           tmp_0 = 0; else 
#line 410 
                           tmp_0 = 1;
  
#line 410 
  if (tmp_0) {
    int tmp_1;
    
#line 410 
    tmp_1 = test_and_set_bit(0L,(unsigned long volatile *)(& n->state));
    
#line 410 
    if (tmp_1 == 0) 
#line 410 
                    tmp_2 = 1; else 
#line 410 
                                    tmp_2 = 0;
  }
  else 
#line 410 
       tmp_2 = 0;
  
#line 410 
  __retres = (_Bool)(tmp_2 != 0);
  
#line 410 
  return __retres;
}


#line 421  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void napi_schedule(struct napi_struct *n)
{
  bool tmp;
  
#line 423 
  tmp = napi_schedule_prep(n);
  
#line 423 
  if ((int)tmp != 0) 
#line 424 
                     __napi_schedule(n); else ;
  
#line 425 
  return;
}


#line 450 
void napi_complete_done(struct napi_struct *, int);


#line 458  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void napi_complete(struct napi_struct *n)
{
  
#line 460 
  napi_complete_done(n,0);
  
#line 461 
  return;
}


#line 496 
void napi_disable(struct napi_struct *);


#line 505  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void napi_enable(struct napi_struct *n)
{
  int tmp;
  
#line 507 
  tmp = constant_test_bit(0L,(unsigned long const volatile *)(& n->state));
  
#line 507 
  if ((long)(tmp == 0) != 0L) {
    
#line 509 
    ldv_inline_asm();
    
#line 507 
    ;
  }
  else ;
  
#line 509 
  ldv_inline_asm();
  
#line 509 
  set_bit(0L,(unsigned long volatile *)(& n->state));
  
#line 510 
  return;
}


#line 1822  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static struct netdev_queue *netdev_get_tx_queue(struct net_device const *dev, unsigned int index)
{
  struct netdev_queue *__retres;
  
#line 1825 
  __retres = dev->_tx + index;
  
#line 1825 
  return __retres;
}


#line 1911 
void netif_napi_add(struct net_device *, struct napi_struct *, int (*)(struct napi_struct *, int ), int);


#line 2205 
static void ldv_free_netdev_85(struct net_device *ldv_func_arg1);


#line 2505 
void netif_schedule_queue(struct netdev_queue *);


#line 2515  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_start_queue(struct netdev_queue *dev_queue)
{
  
#line 2517 
  set_bit(0L,(unsigned long volatile *)(& dev_queue->state));
  
#line 2518 
  return;
}


#line 2526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_start_queue(struct net_device *dev)
{
  struct netdev_queue *tmp;
  
#line 2528 
  tmp = netdev_get_tx_queue((struct net_device const *)dev,0U);
  
#line 2528 
  netif_tx_start_queue(tmp);
  
#line 2529 
  return;
}


#line 2541 
void netif_tx_wake_queue(struct netdev_queue *);


#line 2550  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_wake_queue(struct net_device *dev)
{
  struct netdev_queue *tmp;
  
#line 2552 
  tmp = netdev_get_tx_queue((struct net_device const *)dev,0U);
  
#line 2552 
  netif_tx_wake_queue(tmp);
  
#line 2553 
  return;
}


#line 2645  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netdev_tx_sent_queue(struct netdev_queue *dev_queue, unsigned int bytes)
{
  int tmp;
  int tmp_0;
  
#line 2649 
  dql_queued(& dev_queue->dql,bytes);
  
#line 2651 
  tmp = dql_avail((struct dql const *)(& dev_queue->dql));
  
#line 2651 
  if ((long)(tmp >= 0) != 0L) 
#line 2652 
                              goto return_label; else ;
  
#line 2654 
  set_bit(1L,(unsigned long volatile *)(& dev_queue->state));
  
#line 2655 
  ldv_inline_asm();
  
#line 2664 
  tmp_0 = dql_avail((struct dql const *)(& dev_queue->dql));
  
#line 2664 
  if ((long)(tmp_0 >= 0) != 0L) 
#line 2665 
                                set_bit(1L,(unsigned long volatile *)(& dev_queue->state)); else ;
  return_label: 
#line 2666 
                return;
}


#line 2683  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netdev_tx_completed_queue(struct netdev_queue *dev_queue, unsigned int pkts, unsigned int bytes)
{
  int tmp;
  int tmp_0;
  
#line 2687 
  if ((long)(bytes == 0U) != 0L) 
#line 2688 
                                 goto return_label; else ;
  
#line 2690 
  dql_completed(& dev_queue->dql,bytes);
  
#line 2691 
  ldv_inline_asm();
  
#line 2699 
  tmp = dql_avail((struct dql const *)(& dev_queue->dql));
  
#line 2699 
  if (tmp < 0) 
#line 2700 
               goto return_label; else ;
  
#line 2702 
  tmp_0 = test_and_set_bit(1L,(unsigned long volatile *)(& dev_queue->state));
  
#line 2702 
  if (tmp_0 != 0) 
#line 2703 
                  netif_schedule_queue(dev_queue); else ;
  return_label: 
#line 2704 
                return;
}


#line 2788  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_start_subqueue(struct net_device *dev, u16 queue_index)
{
  
#line 2790 
  struct netdev_queue *txq = netdev_get_tx_queue((struct net_device const *)dev,(unsigned int)queue_index);
  
#line 2792 
  netif_tx_start_queue(txq);
  
#line 2793 
  return;
}


#line 2829 
void netif_wake_subqueue(struct net_device *, u16);


#line 2862  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool netif_is_multiqueue(struct net_device const *dev)
{
  bool __retres;
  
#line 2864 
  __retres = (_Bool)(dev->num_tx_queues > 1U);
  
#line 2864 
  return __retres;
}


#line 2948 
gro_result_t napi_gro_receive(struct napi_struct *, struct sk_buff *);


#line 3047 
void netif_carrier_on(struct net_device *);


#line 3049 
void netif_carrier_off(struct net_device *);


#line 3159  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static u32 netif_msg_init(int debug_value, int default_msg_enable_bits)
{
  u32 __retres;
  
#line 3162 
  if ((unsigned int)debug_value > 31U) {
    
#line 3163 
    __retres = (unsigned int)default_msg_enable_bits;
    
#line 3163 
    goto return_label;
  }
  else ;
  
#line 3164 
  if (debug_value == 0) {
    
#line 3165 
    __retres = 0U;
    
#line 3165 
    goto return_label;
  }
  else ;
  
#line 3167 
  __retres = (unsigned int)((1 << debug_value) + -1);
  return_label: 
#line 3167 
                return __retres;
}


#line 3355 
static int ldv_register_netdev_103(struct net_device *ldv_func_arg1);


#line 3360 
static void ldv_unregister_netdev_84(struct net_device *ldv_func_arg1);


#line 3730  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_set_gso_max_size(struct net_device *dev, unsigned int size)
{
  
#line 3733 
  dev->gso_max_size = size;
  
#line 3734 
  return;
}


#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ipv6.h"
__inline static struct ipv6hdr *ipv6_hdr(struct sk_buff const *skb)
{
  struct ipv6hdr *tmp;
  
#line 76 
  tmp = (struct ipv6hdr *)skb_network_header(skb);
  
#line 76 
  return tmp;
}


#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__be16 eth_type_trans(struct sk_buff *, struct net_device *);


#line 53 
static struct net_device *ldv_alloc_etherdev_mqs_102(int ldv_func_arg1, unsigned int ldv_func_arg2, unsigned int ldv_func_arg3);


#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool is_zero_ether_addr(u8 const *addr)
{
  bool __retres;
  
#line 96 
  __retres = (_Bool)((*((u32 const *)addr) | (unsigned int)*((u16 const *)(addr + 4U))) == 0U);
  
#line 96 
  return __retres;
}


#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool is_multicast_ether_addr(u8 const *addr)
{
  bool __retres;
  
#line 114 
  u32 a = *((u32 const *)addr);
  
#line 121 
  __retres = (_Bool)((a & 1U) != 0U);
  
#line 121 
  return __retres;
}


#line 186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool is_valid_ether_addr(u8 const *addr)
{
  bool __retres;
  int tmp_3;
  int tmp_0;
  bool tmp;
  
#line 190 
  tmp = is_multicast_ether_addr(addr);
  
#line 190 
  if (tmp) 
#line 190 
           tmp_0 = 0; else 
#line 190 
                           tmp_0 = 1;
  
#line 190 
  if (tmp_0) {
    int tmp_2;
    bool tmp_1;
    
#line 190 
    tmp_1 = is_zero_ether_addr(addr);
    
#line 190 
    if (tmp_1) 
#line 190 
               tmp_2 = 0; else 
#line 190 
                               tmp_2 = 1;
    
#line 190 
    if (tmp_2) 
#line 190 
               tmp_3 = 1; else 
#line 190 
                               tmp_3 = 0;
  }
  else 
#line 190 
       tmp_3 = 0;
  
#line 190 
  __retres = (_Bool)(tmp_3 != 0);
  
#line 190 
  return __retres;
}


#line 271  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static void ether_addr_copy(u8 *dst, u8 const *src)
{
  
#line 274 
  *((u32 *)dst) = *((u32 const *)src);
  
#line 275 
  *((u16 *)(dst + 4U)) = *((u16 const *)(src + 4U));
  
#line 276 
  return;
}


#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_vlan.h"
__inline static struct vlan_ethhdr *vlan_eth_hdr(struct sk_buff const *skb)
{
  struct vlan_ethhdr *tmp;
  
#line 63 
  tmp = (struct vlan_ethhdr *)skb_mac_header(skb);
  
#line 63 
  return tmp;
}


#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/firmware.h"
int request_firmware(struct firmware const **, char const *, struct device *);


#line 51 
void release_firmware(struct firmware const *);


#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ptp_clock_kernel.h"
struct ptp_clock *ptp_clock_register(struct ptp_clock_info *, struct device *);


#line 133 
int ptp_clock_unregister(struct ptp_clock *);


#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/liquidio_common.h"
__inline static void add_sg_size(struct octeon_sg_entry *sg_entry, u16 size, u32 pos)
{
  
#line 170 
  sg_entry->u.size[3U - pos] = size;
  
#line 171 
  return;
}


#line 127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/response_manager.h"
int octeon_setup_response_list(struct octeon_device *oct);


#line 129 
void octeon_delete_response_list(struct octeon_device *oct);


#line 137 
int lio_process_ordered_list(struct octeon_device *octeon_dev, u32 force_quit);


#line 470  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.h"
__inline static u16 OCTEON_MAJOR_REV(struct octeon_device *oct)
{
  u16 __retres;
  unsigned int tmp;
  
#line 472 
  u16 rev = (unsigned short)((unsigned int)((unsigned short)((int)oct->rev_id >> 2)) & 3U);
  
#line 474 
  if ((unsigned int)rev != 0U) 
#line 474 
                               tmp = (unsigned int)rev; else 
#line 474 
                                                             tmp = 1U;
  
#line 474 
  __retres = (unsigned short)tmp;
  
#line 474 
  return __retres;
}


#line 477  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.h"
__inline static u16 OCTEON_MINOR_REV(struct octeon_device *oct)
{
  u16 __retres;
  
#line 479 
  __retres = (unsigned short)((unsigned int)oct->rev_id & 3U);
  
#line 479 
  return __retres;
}


#line 548 
int octeon_wait_for_bootloader(struct octeon_device *oct, u32 wait_time_hundredths);


#line 557 
int octeon_init_consoles(struct octeon_device *oct);


#line 566 
int octeon_add_console(struct octeon_device *oct, u32 console_num);


#line 577 
void octeon_remove_consoles(struct octeon_device *oct);


#line 120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_nic.h"
__inline static int octnet_iq_is_full(struct octeon_device *oct, u32 q_no)
{
  int __retres;
  int tmp;
  
#line 122 
  tmp = atomic_read((atomic_t const *)(& (oct->instr_queue[q_no])->instr_pending));
  
#line 122 
  ;
  
#line 123 
  __retres = (unsigned int)tmp >= (oct->instr_queue[q_no])->max_count + 4294967294U;
  
#line 123 
  return __retres;
}


#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_nic.h"
__inline static void octnet_prepare_pci_cmd(struct octeon_instr_64B *cmd, union octnic_cmd_setup *setup, u32 tag)
{
  struct octeon_instr_ih *ih;
  struct octeon_instr_irh *irh;
  union octnic_packet_params packet_params;
  
#line 141 
  memset((void *)cmd,0,64UL);
  
#line 143 
  ih = (struct octeon_instr_ih *)(& cmd->ih);
  
#line 148 
  ih->fsz = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))24U;
  
#line 150 
  ih->tagtype = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U;
  
#line 151 
  ih->grp = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U;
  
#line 153 
  if (tag != 0U) 
#line 154 
                 ih->tag = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(32))))tag; else 
                                                                    
#line 156 
                                                                    ih->tag = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(32))))((unsigned int)((int)setup->s.ifidx + 286331153));
  
#line 158 
  ih->raw = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U;
  
#line 159 
  ih->qos = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))(((unsigned int)setup->s.ifidx & 3U) + 4U);
  
#line 161 
  if ((unsigned int)*((unsigned char *)(& setup->s) + 1UL) == 0U) 
#line 162 
                                                                  ih->dlengsz = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(14))))setup->s.u.datasize;
  else {
    
#line 164 
    ih->gather = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U;
    
#line 165 
    ih->dlengsz = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(14))))setup->s.u.gatherptrs;
  }
  
#line 168 
  irh = (struct octeon_instr_irh *)(& cmd->irh);
  
#line 170 
  irh->opcode = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))1U;
  
#line 171 
  irh->subcode = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(7))))2U;
  
#line 173 
  packet_params.u32 = 0U;
  
#line 175 
  if ((unsigned int)*((unsigned char *)(& setup->s) + 1UL) != 0U) {
    
#line 176 
    packet_params.s.csoffset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(9))))setup->s.cksum_offset;
    
#line 177 
    packet_params.s.ipv4opts_ipv6exthdr = setup->s.ipv4opts_ipv6exthdr;
  }
  else ;
  
#line 181 
  packet_params.s.ip_csum = setup->s.ip_csum;
  
#line 182 
  packet_params.s.tnl_csum = setup->s.tnl_csum;
  
#line 183 
  packet_params.s.ifidx = setup->s.ifidx;
  
#line 184 
  packet_params.s.tsflag = setup->s.timestamp;
  
#line 186 
  irh->ossp = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(32))))packet_params.u32;
  
#line 187 
  return;
}


#line 200 
void *octeon_alloc_soft_command_resp(struct octeon_device *oct, struct octeon_instr_64B *cmd, size_t rdatasize);


#line 211 
int octnet_send_nic_data_pkt(struct octeon_device *oct, struct octnic_data_pkt *ndata, u32 xmit_more);


#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_main.h"
int octeon_console_debug_enabled(u32 console);


#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_main.h"
__inline static void octeon_swap_8B_data_2(u64 *data, u32 blocks)
{
  
#line 59 
  goto ldv_54495;
  ldv_54494: 
#line 60 
  ;
  
#line 60 
  __swab64s(data);
  
#line 61 
  blocks -= 1U;
  
#line 62 
  data += 1;
  ldv_54495: 
#line 63 
  ;
  
#line 59 
  if (blocks != 0U) 
#line 61 
                    goto ldv_54494; else 
#line 64 
                                         goto ldv_54496;
  ldv_54496: 
#line 65 
  ;
  
#line 66 
  return;
}


#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_main.h"
__inline static void sleep_cond_0(wait_queue_head_t *wait_queue, int *condition)
{
  wait_queue_t we;
  struct task_struct *tmp;
  struct task_struct *tmp_0;
  int tmp_2_0;
  struct task_struct *tmp_1;
  int volatile *tmp_3;
  struct task_struct *tmp_4;
  
#line 170 
  tmp = get_current();
  
#line 170 
  init_waitqueue_entry(& we,tmp);
  
#line 171 
  add_wait_queue(wait_queue,& we);
  
#line 172 
  goto ldv_54541;
  ldv_54540: 
#line 173 
  ;
  
#line 173 
  tmp_0 = get_current();
  __here_0: 
#line 173 
  ;
  
#line 173 
  tmp_0->task_state_change = (unsigned long)((void *)0);
  {
    
#line 173 
    long volatile __ret = 1L;
    
#line 173 
    switch (8UL) {
      case (unsigned long)1: 
#line 173 
      ;
      
#line 174 
      ldv_inline_asm();
      
#line 173 
      goto ldv_54533;
      case (unsigned long)2: 
#line 173 
      ;
      
#line 174 
      ldv_inline_asm();
      
#line 173 
      goto ldv_54533;
      case (unsigned long)4: 
#line 173 
      ;
      
#line 174 
      ldv_inline_asm();
      
#line 173 
      goto ldv_54533;
      case (unsigned long)8: 
#line 173 
      ;
      
#line 174 
      ldv_inline_asm();
      
#line 173 
      goto ldv_54533;
      default: 
#line 173 
      ;
      
#line 173 
      __xchg_wrong_size();
    }
    ldv_54533: 
#line 173 
    ;
    
#line 173 
    long tmp_2 = __ret;
  }
  
#line 174 
  tmp_1 = get_current();
  
#line 174 
  tmp_2_0 = signal_pending(tmp_1);
  
#line 174 
  if (tmp_2_0 != 0) 
#line 175 
                    goto out; else ;
  
#line 176 
  schedule();
  ldv_54541: 
#line 177 
  ;
  {
    
#line 172 
    int __var = 0;
    
#line 172 
    tmp_3 = (int volatile *)condition;
  }
  
#line 172 
  ;
  
#line 172 
  if (*tmp_3 == 0) 
#line 174 
                   goto ldv_54540; else 
#line 177 
                                        goto ldv_54542;
  ldv_54542: 
#line 178 
  ;
  out: 
#line 178 
  ;
  
#line 179 
  tmp_4 = get_current();
  __here_1: 
#line 179 
  ;
  
#line 179 
  tmp_4->task_state_change = (unsigned long)((void *)1);
  {
    
#line 179 
    long volatile __ret_0 = 0L;
    
#line 179 
    switch (8UL) {
      case (unsigned long)1: 
#line 179 
      ;
      
#line 180 
      ldv_inline_asm();
      
#line 179 
      goto ldv_54547;
      case (unsigned long)2: 
#line 179 
      ;
      
#line 180 
      ldv_inline_asm();
      
#line 179 
      goto ldv_54547;
      case (unsigned long)4: 
#line 179 
      ;
      
#line 180 
      ldv_inline_asm();
      
#line 179 
      goto ldv_54547;
      case (unsigned long)8: 
#line 179 
      ;
      
#line 180 
      ldv_inline_asm();
      
#line 179 
      goto ldv_54547;
      default: 
#line 179 
      ;
      
#line 179 
      __xchg_wrong_size();
    }
    ldv_54547: 
#line 179 
    ;
    
#line 179 
    long tmp_5 = __ret_0;
  }
  
#line 180 
  remove_wait_queue(wait_queue,& we);
  
#line 181 
  return;
}


#line 103  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.h"
int lio_setup_cn66xx_octeon_device(struct octeon_device *oct);


#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int ddr_timeout = 10000;

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static u32 console_bitmask;

#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int debug = -1;

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static char fw_type[8U];

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int conf_type;

#line 206 
static int octeon_device_init(struct octeon_device *octeon_dev);


#line 207 
static void liquidio_remove(struct pci_dev *pdev);


#line 208 
static int liquidio_probe(struct pci_dev *pdev, struct pci_device_id const *ent);


#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static struct handshake handshake[32U];

#line 212  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static struct completion first_stage;

#line 214  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static void octeon_droq_bh(unsigned long pdev)
{
  int q_no;
  int tmp;
  
#line 217 
  int reschedule = 0;
  
#line 218 
  struct octeon_device *oct = (struct octeon_device *)pdev;
  
#line 219 
  struct octeon_device_priv *oct_priv = (struct octeon_device_priv *)oct->priv;
  
#line 223 
  q_no = 0;
  
#line 223 
  goto ldv_54981;
  ldv_54980: 
#line 224 
  ;
  
#line 224 
  if ((((unsigned long)oct->io_qmask.oq >> q_no) & 1UL) == 0UL) 
#line 225 
                                                                goto ldv_54979; else ;
  
#line 226 
  tmp = octeon_droq_process_packets(oct,oct->droq[q_no],4294967295U);
  
#line 227 
  reschedule = tmp | reschedule;
  ldv_54979: 
#line 227 
  ;
  
#line 223 
  q_no += 1;
  ldv_54981: 
#line 224 
  ;
  
#line 223 
  if (q_no <= 31) 
#line 225 
                  goto ldv_54980; else 
#line 228 
                                       goto ldv_54982;
  ldv_54982: 
#line 229 
  ;
  
#line 230 
  if (reschedule != 0) 
#line 231 
                       ldv_tasklet_schedule_74(& oct_priv->droq_tasklet); else ;
  
#line 232 
  return;
}


#line 234  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int lio_wait_for_oq_pkts(struct octeon_device *oct)
{
  int i;
  u32 tmp;
  int tmp_0;
  
#line 236 
  struct octeon_device_priv *oct_priv = (struct octeon_device_priv *)oct->priv;
  
#line 238 
  int retry = 100;
  
#line 238 
  int pkt_cnt = 0;
  
#line 238 
  int pending_pkts = 0;
  ldv_54995: 
#line 240 
  ;
  
#line 242 
  pending_pkts = 0;
  
#line 244 
  i = 0;
  
#line 244 
  goto ldv_54993;
  ldv_54992: 
#line 245 
  ;
  
#line 245 
  if ((((unsigned long)oct->io_qmask.oq >> i) & 1UL) == 0UL) 
#line 246 
                                                             goto ldv_54991; else ;
  
#line 247 
  tmp = octeon_droq_check_hw_for_pkts(oct,oct->droq[i]);
  
#line 248 
  pkt_cnt = (int)(tmp + (unsigned int)pkt_cnt);
  ldv_54991: 
#line 248 
  ;
  
#line 244 
  i += 1;
  ldv_54993: 
#line 245 
  ;
  
#line 244 
  if (i <= 31) 
#line 246 
               goto ldv_54992; else 
#line 249 
                                    goto ldv_54994;
  ldv_54994: 
#line 250 
  ;
  
#line 250 
  if (pkt_cnt > 0) {
    
#line 251 
    pending_pkts += pkt_cnt;
    
#line 252 
    ldv_tasklet_schedule_75(& oct_priv->droq_tasklet);
  }
  else ;
  
#line 254 
  pkt_cnt = 0;
  
#line 255 
  schedule_timeout_uninterruptible(1L);
  
#line 257 
  tmp_0 = retry;
  
#line 257 
  retry -= 1;
  
#line 257 
  ;
  
#line 257 
  if (tmp_0 != 0) {
    
#line 257 
    if (pending_pkts != 0) 
#line 259 
                           goto ldv_54995; else 
#line 262 
                                                goto ldv_54996;
  }
  else 
#line 262 
       goto ldv_54996;
  ldv_54996: 
#line 263 
  ;
  
#line 259 
  return pkt_cnt;
}


#line 262  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
void octeon_report_tx_completion_to_bql(void *txq, unsigned int pkts_compl, unsigned int bytes_compl)
{
  
#line 265 
  struct netdev_queue *netdev_queue = (struct netdev_queue *)txq;
  
#line 267 
  netdev_tx_completed_queue(netdev_queue,pkts_compl,bytes_compl);
  
#line 268 
  return;
}


#line 270  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
void octeon_update_tx_completion_counters(void *buf, int reqtype, unsigned int *pkts_compl, unsigned int *bytes_compl)
{
  struct octnet_buf_free_info *finfo;
  struct octeon_soft_command *sc;
  
#line 275 
  struct sk_buff *skb = (struct sk_buff *)0;
  
#line 278 
  switch (reqtype) {
    case 1: 
#line 279 
    ;
    case 2: 
#line 280 
    ;
    
#line 281 
    finfo = (struct octnet_buf_free_info *)buf;
    
#line 282 
    skb = finfo->skb;
    
#line 283 
    goto ldv_55014;
    case 4: 
#line 285 
    ;
    case 3: 
#line 286 
    ;
    
#line 287 
    sc = (struct octeon_soft_command *)buf;
    
#line 288 
    skb = (struct sk_buff *)sc->callback_arg;
    
#line 289 
    goto ldv_55014;
    default: 
#line 291 
    ;
    
#line 292 
    goto return_label;
  }
  ldv_55014: 
#line 295 
  ;
  
#line 295 
  *pkts_compl += 1U;
  
#line 296 
  *bytes_compl += skb->len;
  return_label: 
#line 297 
                return;
}


#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
void octeon_report_sent_bytes_to_bql(void *buf, int reqtype)
{
  struct octnet_buf_free_info *finfo;
  struct sk_buff *skb;
  struct octeon_soft_command *sc;
  struct netdev_queue *txq;
  u16 tmp;
  
#line 306 
  switch (reqtype) {
    case 1: 
#line 307 
    ;
    case 2: 
#line 308 
    ;
    
#line 309 
    finfo = (struct octnet_buf_free_info *)buf;
    
#line 310 
    skb = finfo->skb;
    
#line 311 
    goto ldv_55028;
    case 4: 
#line 313 
    ;
    case 3: 
#line 314 
    ;
    
#line 315 
    sc = (struct octeon_soft_command *)buf;
    
#line 316 
    skb = (struct sk_buff *)sc->callback_arg;
    
#line 317 
    goto ldv_55028;
    default: 
#line 319 
    ;
    
#line 320 
    goto return_label;
  }
  ldv_55028: 
#line 323 
  ;
  
#line 323 
  tmp = skb_get_queue_mapping((struct sk_buff const *)skb);
  
#line 323 
  ;
  
#line 323 
  txq = netdev_get_tx_queue((struct net_device const *)skb->dev,(unsigned int)tmp);
  
#line 324 
  netdev_tx_sent_queue(txq,skb->len);
  return_label: 
#line 325 
                return;
}


#line 327  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
int octeon_console_debug_enabled(u32 console)
{
  int __retres;
  
#line 329 
  __retres = (int)(console_bitmask >> console) & 1;
  
#line 329 
  return __retres;
}


#line 336  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static void force_io_queues_off(struct octeon_device *oct)
{
  
#line 338 
  if ((unsigned int)oct->chip_id + 65391U <= 1U) {
    
#line 341 
    writel(0U,(void volatile *)(oct->mmio[0].hw_addr + 4096U));
    
#line 344 
    writel(0U,(void volatile *)(oct->mmio[0].hw_addr + 4112U));
  }
  else ;
  
#line 346 
  return;
}


#line 354  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int wait_for_pending_requests(struct octeon_device *oct)
{
  int __retres;
  int i;
  
#line 356 
  int pcount = 0;
  
#line 358 
  i = 0;
  
#line 358 
  goto ldv_55045;
  ldv_55044: 
#line 359 
  ;
  
#line 359 
  pcount = atomic_read((atomic_t const *)(& oct->response_list[3].pending_req_count));
  
#line 362 
  if (pcount != 0) 
#line 363 
                   schedule_timeout_uninterruptible(25L); else 
#line 365 
                                                               goto ldv_55043;
  
#line 358 
  i += 1;
  ldv_55045: 
#line 359 
  ;
  
#line 358 
  if (i <= 99) 
#line 360 
               goto ldv_55044; else 
#line 363 
                                    goto ldv_55043;
  ldv_55043: 
#line 364 
  ;
  
#line 368 
  if (pcount != 0) {
    
#line 369 
    __retres = 1;
    
#line 369 
    goto return_label;
  }
  else ;
  
#line 371 
  __retres = 0;
  return_label: 
#line 371 
                return __retres;
}


#line 378  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
__inline static void pcierror_quiesce_device(struct octeon_device *oct)
{
  int i;
  int tmp;
  
#line 386 
  force_io_queues_off(oct);
  
#line 389 
  schedule_timeout_uninterruptible(100L);
  
#line 391 
  tmp = wait_for_pending_requests(oct);
  
#line 391 
  if (tmp != 0) 
#line 392 
                dev_err((struct device const *)(& (oct->pci_dev)->dev),"There were pending requests\n"); else ;
  
#line 395 
  i = 0;
  
#line 395 
  goto ldv_55053;
  ldv_55052: 
#line 396 
  ;
  {
    struct octeon_instr_queue *iq;
    int tmp_1;
    
#line 398 
    if ((((unsigned long)oct->io_qmask.iq >> i) & 1UL) == 0UL) 
#line 399 
                                                               goto ldv_55051; else ;
    
#line 400 
    iq = oct->instr_queue[i];
    
#line 402 
    tmp_1 = atomic_read((atomic_t const *)(& iq->instr_pending));
    
#line 402 
    if (tmp_1 != 0) {
      int tmp_0;
      
#line 403 
      ldv_spin_lock_bh_76_0(& iq->lock);
      
#line 404 
      iq->fill_cnt = 0U;
      
#line 405 
      iq->octeon_read_index = iq->host_write_index;
      
#line 407 
      tmp_0 = atomic_read((atomic_t const *)(& iq->instr_pending));
      
#line 407 
      iq->stats.instr_processed += (unsigned long long)tmp_0;
      
#line 408 
      lio_process_iq_request_list(oct,iq);
      
#line 409 
      ldv_spin_unlock_bh_77_1(& iq->lock);
    }
    else ;
  }
  ldv_55051: 
#line 412 
  ;
  
#line 395 
  i += 1;
  ldv_55053: 
#line 396 
  ;
  
#line 395 
  if (i <= 31) 
#line 397 
               goto ldv_55052; else 
#line 400 
                                    goto ldv_55054;
  ldv_55054: 
#line 401 
  ;
  
#line 414 
  lio_process_ordered_list(oct,1U);
  
#line 415 
  return;
}


#line 423  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static void cleanup_aer_uncorrect_error_status(struct pci_dev *dev)
{
  u32 status;
  u32 mask;
  
#line 425 
  int pos = 256;
  
#line 428 
  printk("\001","cleanup_aer_uncorrect_error_status");
  
#line 430 
  pci_read_config_dword((struct pci_dev const *)dev,pos + 4,& status);
  
#line 431 
  pci_read_config_dword((struct pci_dev const *)dev,pos + 12,& mask);
  
#line 432 
  if (dev->error_state == 1U) 
#line 433 
                              status = ~ mask & status; else 
#line 435 
                                                             status &= mask;
  
#line 436 
  pci_write_config_dword((struct pci_dev const *)dev,pos + 4,status);
  
#line 437 
  return;
}


#line 443  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static void stop_pci_io(struct octeon_device *oct)
{
  
#line 446 
  atomic_set(& oct->status,12);
  
#line 448 
  pci_disable_device(oct->pci_dev);
  
#line 451 
  (*(oct->fn_list.disable_interrupt))(oct->chip);
  
#line 453 
  pcierror_quiesce_device(oct);
  
#line 456 
  ldv_free_irq_78((oct->pci_dev)->irq,(void *)oct);
  
#line 458 
  if (((unsigned int)oct->flags & 2U) != 0U) 
#line 459 
                                             pci_disable_msi(oct->pci_dev); else ;
  {
    
#line 461 
    struct _ddebug descriptor = {.modname = "liquidio", .function = "stop_pci_io", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c", .format = "Device state is now %s\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))462U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 461 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      char *tmp;
      
#line 461 
      tmp = lio_get_state_string(& oct->status);
      
#line 461 
      ;
      
#line 461 
      __dynamic_dev_dbg(& descriptor,(struct device const *)(& (oct->pci_dev)->dev),"Device state is now %s\n",tmp);
    }
    else ;
  }
  
#line 466 
  cleanup_aer_uncorrect_error_status(oct->pci_dev);
  
#line 467 
  return;
}


#line 477  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static pci_ers_result_t liquidio_pcie_error_detected(struct pci_dev *pdev, pci_channel_state_t state)
{
  pci_ers_result_t __retres;
  
#line 480 
  struct octeon_device *oct = pci_get_drvdata(pdev);
  
#line 483 
  if (state == 1U) {
    
#line 484 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Non-correctable non-fatal error reported:\n");
    
#line 485 
    cleanup_aer_uncorrect_error_status(oct->pci_dev);
    
#line 486 
    __retres = 2U;
    
#line 486 
    goto return_label;
  }
  else ;
  
#line 490 
  dev_err((struct device const *)(& (oct->pci_dev)->dev),"Non-correctable FATAL reported by PCI AER driver\n");
  
#line 491 
  stop_pci_io(oct);
  
#line 496 
  __retres = 4U;
  return_label: 
#line 496 
                return __retres;
}


#line 503  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static pci_ers_result_t liquidio_pcie_mmio_enabled(struct pci_dev *pdev)
{
  pci_ers_result_t __retres;
  
#line 509 
  __retres = 5U;
  
#line 509 
  return __retres;
}


#line 519  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static pci_ers_result_t liquidio_pcie_slot_reset(struct pci_dev *pdev)
{
  pci_ers_result_t __retres;
  
#line 525 
  __retres = 5U;
  
#line 525 
  return __retres;
}


#line 536  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static void liquidio_pcie_resume(struct pci_dev *pdev)
{
  
#line 538 
  return;
}


#line 547  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int liquidio_suspend(struct pci_dev *pdev, pm_message_t state)
{
  int __retres;
  
#line 549 
  __retres = 0;
  
#line 549 
  return __retres;
}


#line 556  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int liquidio_resume(struct pci_dev *pdev)
{
  int __retres;
  
#line 558 
  __retres = 0;
  
#line 558 
  return __retres;
}


#line 563  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static struct pci_error_handlers liquidio_err_handler = {.error_detected = (pci_ers_result_t (*)(struct pci_dev *, enum pci_channel_state ))(& liquidio_pcie_error_detected), .mmio_enabled = & liquidio_pcie_mmio_enabled, .link_reset = (pci_ers_result_t (*)(struct pci_dev *))0, .slot_reset = & liquidio_pcie_slot_reset, .reset_notify = (void (*)(struct pci_dev *, bool ))0, .resume = & liquidio_pcie_resume};

#line 570  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static struct pci_device_id const liquidio_pci_tbl[3U] = {{.vendor = 6013U, .device = 145U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 6013U, .device = 146U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 0U, .device = 0U, .subvendor = 0U, .subdevice = 0U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}};

#line 581  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
struct pci_device_id const __mod_pci__liquidio_pci_tbl_device_table[3U];

#line 583  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static struct pci_driver liquidio_pci_driver = {.node = {.next = (struct list_head *)0, .prev = (struct list_head *)0}, .name = "LiquidIO", .id_table = (struct pci_device_id const *)(& liquidio_pci_tbl), .probe = & liquidio_probe, .remove = & liquidio_remove, .suspend = & liquidio_suspend, .suspend_late = (int (*)(struct pci_dev *, pm_message_t ))0, .resume_early = (int (*)(struct pci_dev *))0, .resume = & liquidio_resume, .shutdown = (void (*)(struct pci_dev *))0, .sriov_configure = (int (*)(struct pci_dev *, int ))0, .err_handler = (struct pci_error_handlers const *)(& liquidio_err_handler), .driver = {.name = (char const *)0, .bus = (struct bus_type *)0, .owner = (struct module *)0, .mod_name = (char const *)0, .suppress_bind_attrs = (_Bool)0, .probe_type = 0, .of_match_table = (struct of_device_id const *)0, .acpi_match_table = (struct acpi_device_id const *)0, .probe = (int (*)(struct device *))0, .remove = (int (*)(struct device *))0, .shutdown = (void (*)(struct device *))0, .suspend = (int (*)(struct device *, pm_message_t ))0, .resume = (int (*)(struct device *))0, .groups = (struct attribute_group const **)0, .pm = (struct dev_pm_ops const *)0, .p = (struct driver_private *)0}, .dynids = {.lock = {.__anonCompField_spinlock_18 = {.rlock = {.raw_lock = {.val = {.counter = 0}}, .magic = 0U, .owner_cpu = 0U, .owner = (void *)0, .dep_map = {.key = (struct lock_class_key *)0, .class_cache = {(struct lock_class *)0, (struct lock_class *)0}, .name = (char const *)0, .cpu = 0, .ip = 0UL}}}}, .list = {.next = (struct list_head *)0, .prev = (struct list_head *)0}}};

#line 600  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int liquidio_init_pci(void)
{
  int tmp;
  
#line 602 
  tmp = ldv___pci_register_driver_79(& liquidio_pci_driver,& __this_module,"liquidio");
  
#line 602 
  return tmp;
}


#line 608  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static void liquidio_deinit_pci(void)
{
  
#line 610 
  ldv_pci_unregister_driver_80(& liquidio_pci_driver);
  
#line 611 
  return;
}


#line 618  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
__inline static int ifstate_check(struct lio *lio, int state_flag)
{
  int __retres;
  int tmp;
  
#line 620 
  tmp = atomic_read((atomic_t const *)(& lio->ifstate));
  
#line 620 
  ;
  
#line 620 
  __retres = tmp & state_flag;
  
#line 620 
  return __retres;
}


#line 628  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
__inline static void ifstate_set(struct lio *lio, int state_flag)
{
  int tmp;
  
#line 630 
  tmp = atomic_read((atomic_t const *)(& lio->ifstate));
  
#line 630 
  ;
  
#line 630 
  ;
  
#line 630 
  atomic_set(& lio->ifstate,tmp | state_flag);
  
#line 631 
  return;
}


#line 638  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
__inline static void ifstate_reset(struct lio *lio, int state_flag)
{
  int tmp;
  
#line 640 
  tmp = atomic_read((atomic_t const *)(& lio->ifstate));
  
#line 640 
  ;
  
#line 640 
  ;
  
#line 640 
  atomic_set(& lio->ifstate,tmp & ~ state_flag);
  
#line 641 
  return;
}


#line 647  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
__inline static void txqs_stop(struct net_device *netdev)
{
  bool tmp;
  
#line 649 
  tmp = netif_is_multiqueue((struct net_device const *)netdev);
  
#line 649 
  if ((int)tmp != 0) {
    int i;
    
#line 652 
    i = 0;
    
#line 652 
    goto ldv_55115;
    ldv_55114: 
#line 653 
    ;
    
#line 653 
    netif_start_subqueue(netdev,(unsigned short)((int)((unsigned short)i)));
    
#line 652 
    i += 1;
    ldv_55115: 
#line 653 
    ;
    
#line 652 
    if (netdev->num_tx_queues > (unsigned int)i) 
#line 654 
                                                 goto ldv_55114; else 
                                                                   
#line 657 
                                                                   goto ldv_55116;
    ldv_55116: 
#line 658 
    ;
  }
  else 
#line 655 
       netif_start_queue(netdev);
  
#line 656 
  return;
}


#line 663  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
__inline static void txqs_start(struct net_device *netdev)
{
  bool tmp;
  
#line 665 
  tmp = netif_is_multiqueue((struct net_device const *)netdev);
  
#line 665 
  if ((int)tmp != 0) {
    int i;
    
#line 668 
    i = 0;
    
#line 668 
    goto ldv_55122;
    ldv_55121: 
#line 669 
    ;
    
#line 669 
    netif_start_subqueue(netdev,(unsigned short)((int)((unsigned short)i)));
    
#line 668 
    i += 1;
    ldv_55122: 
#line 669 
    ;
    
#line 668 
    if (netdev->num_tx_queues > (unsigned int)i) 
#line 670 
                                                 goto ldv_55121; else 
                                                                   
#line 673 
                                                                   goto ldv_55123;
    ldv_55123: 
#line 674 
    ;
  }
  else 
#line 671 
       netif_start_queue(netdev);
  
#line 672 
  return;
}


#line 679  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
__inline static void txqs_wake(struct net_device *netdev)
{
  bool tmp;
  
#line 681 
  tmp = netif_is_multiqueue((struct net_device const *)netdev);
  
#line 681 
  if ((int)tmp != 0) {
    int i;
    
#line 684 
    i = 0;
    
#line 684 
    goto ldv_55129;
    ldv_55128: 
#line 685 
    ;
    
#line 685 
    netif_wake_subqueue(netdev,(unsigned short)((int)((unsigned short)i)));
    
#line 684 
    i += 1;
    ldv_55129: 
#line 685 
    ;
    
#line 684 
    if (netdev->num_tx_queues > (unsigned int)i) 
#line 686 
                                                 goto ldv_55128; else 
                                                                   
#line 689 
                                                                   goto ldv_55130;
    ldv_55130: 
#line 690 
    ;
  }
  else 
#line 687 
       netif_wake_queue(netdev);
  
#line 688 
  return;
}


#line 695  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static void stop_txq(struct net_device *netdev)
{
  
#line 697 
  txqs_stop(netdev);
  
#line 698 
  return;
}


#line 704  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static void start_txq(struct net_device *netdev)
{
  
#line 706 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 708 
  if ((unsigned int)lio->linfo.link.s.status != 0U) {
    
#line 709 
    txqs_start(netdev);
    
#line 710 
    goto return_label;
  }
  else ;
  return_label: 
#line 712 
                return;
}


#line 719  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
__inline static void wake_q(struct net_device *netdev, int q)
{
  bool tmp;
  
#line 721 
  tmp = netif_is_multiqueue((struct net_device const *)netdev);
  
#line 721 
  if ((int)tmp != 0) 
#line 722 
                     netif_wake_subqueue(netdev,(unsigned short)((int)((unsigned short)q))); else 
                                                                    
#line 724 
                                                                    netif_wake_queue(netdev);
  
#line 725 
  return;
}


#line 732  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
__inline static void stop_q(struct net_device *netdev, int q)
{
  bool tmp;
  
#line 734 
  tmp = netif_is_multiqueue((struct net_device const *)netdev);
  
#line 734 
  if ((int)tmp != 0) 
#line 735 
                     netif_start_subqueue(netdev,(unsigned short)((int)((unsigned short)q))); else 
                                                                    
#line 737 
                                                                    netif_start_queue(netdev);
  
#line 738 
  return;
}


#line 745  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
__inline static int check_txq_status(struct lio *lio)
{
  int __retres;
  bool tmp_1;
  
#line 747 
  int ret_val = 0;
  
#line 749 
  tmp_1 = netif_is_multiqueue((struct net_device const *)lio->netdev);
  
#line 749 
  if ((int)tmp_1 != 0) {
    int q;
    int tmp;
    
#line 750 
    int numqs = (int)(lio->netdev)->num_tx_queues;
    
#line 751 
    int iq = 0;
    
#line 754 
    q = 0;
    
#line 754 
    goto ldv_55155;
    ldv_55154: 
#line 755 
    ;
    
#line 755 
    iq = (int)lio->linfo.txpciq[((int)lio->linfo.num_txpciq + -1) & q];
    
#line 756 
    tmp = octnet_iq_is_full(lio->oct_dev,(unsigned int)iq);
    
#line 756 
    if (tmp != 0) 
#line 757 
                  goto ldv_55153; else ;
    
#line 758 
    wake_q(lio->netdev,q);
    
#line 759 
    ret_val += 1;
    ldv_55153: 
#line 760 
    ;
    
#line 754 
    q += 1;
    ldv_55155: 
#line 755 
    ;
    
#line 754 
    if (q < numqs) 
#line 756 
                   goto ldv_55154; else 
#line 759 
                                        goto ldv_55156;
    ldv_55156: 
#line 760 
    ;
  }
  else {
    int tmp_0;
    
#line 762 
    tmp_0 = octnet_iq_is_full(lio->oct_dev,(unsigned int)lio->txq);
    
#line 762 
    if (tmp_0 != 0) {
      
#line 763 
      __retres = 0;
      
#line 763 
      goto return_label;
    }
    else ;
    
#line 764 
    wake_q(lio->netdev,lio->txq);
    
#line 765 
    ret_val = 1;
  }
  
#line 767 
  __retres = ret_val;
  return_label: 
#line 767 
                return __retres;
}


#line 774  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
__inline static struct list_head *list_delete_head(struct list_head *root)
{
  struct list_head *node;
  
#line 778 
  if (root->prev == root && root->next == root) 
#line 779 
                                                node = (struct list_head *)0; else 
                                                                    
#line 781 
                                                                    node = root->next;
  
#line 783 
  if (node != (struct list_head *)0) 
#line 784 
                                     list_del(node); else ;
  
#line 786 
  return node;
}


#line 793  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static void delete_glist(struct lio *lio)
{
  struct octnic_gather *g;
  ldv_55165: 
#line 796 
  ;
  
#line 798 
  g = (struct octnic_gather *)list_delete_head(& lio->glist);
  
#line 800 
  if (g != (struct octnic_gather *)0) {
    
#line 801 
    if (g->sg != (struct octeon_sg_entry *)0) 
#line 802 
                                              kfree((void const *)((unsigned long)g->sg - (unsigned long)g->adjust)); else ;
    
#line 804 
    kfree((void const *)g);
  }
  else ;
  
#line 806 
  if (g != (struct octnic_gather *)0) 
#line 808 
                                      goto ldv_55165; else 
#line 811 
                                                           goto ldv_55166;
  ldv_55166: 
#line 812 
  ;
  
#line 813 
  return;
}


#line 813  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int setup_glist(struct lio *lio)
{
  int __retres;
  int i;
  struct octnic_gather *g;
  
#line 818 
  INIT_LIST_HEAD(& lio->glist);
  
#line 820 
  i = 0;
  
#line 820 
  goto ldv_55174;
  ldv_55173: 
#line 821 
  ;
  
#line 821 
  g = (struct octnic_gather *)kmalloc_1(32UL,208U);
  
#line 822 
  if (g == (struct octnic_gather *)0) 
#line 823 
                                      goto ldv_55172; else ;
  
#line 824 
  memset((void *)g,0,32UL);
  
#line 826 
  g->sg_size = 200;
  
#line 829 
  g->sg = (struct octeon_sg_entry *)kmalloc_1((unsigned long)(g->sg_size + 8),208U);
  
#line 830 
  if (g->sg == (struct octeon_sg_entry *)0) {
    
#line 831 
    kfree((void const *)g);
    
#line 832 
    goto ldv_55172;
  }
  else ;
  
#line 836 
  if (((unsigned long)g->sg & 7UL) != 0UL) {
    
#line 837 
    g->adjust = (int)((long)8U - ((long)g->sg & (long)7U));
    
#line 838 
    g->sg = (struct octeon_sg_entry *)((unsigned long)g->sg + (unsigned long)g->adjust);
  }
  else ;
  
#line 841 
  list_add_tail(& g->list,& lio->glist);
  
#line 820 
  i += 1;
  ldv_55174: 
#line 821 
  ;
  
#line 820 
  if (lio->tx_qsize > (unsigned int)i) 
#line 822 
                                       goto ldv_55173; else 
#line 825 
                                                            goto ldv_55172;
  ldv_55172: 
#line 826 
  ;
  
#line 844 
  if (lio->tx_qsize == (unsigned int)i) {
    
#line 845 
    __retres = 0;
    
#line 845 
    goto return_label;
  }
  else ;
  
#line 847 
  delete_glist(lio);
  
#line 848 
  __retres = 1;
  return_label: 
#line 848 
                return __retres;
}


#line 855  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static void print_link_info(struct net_device *netdev)
{
  int tmp_1;
  
#line 857 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 859 
  tmp_1 = atomic_read((atomic_t const *)(& lio->ifstate));
  
#line 859 
  if ((tmp_1 & 2) != 0) {
    
#line 860 
    struct oct_link_info *linfo = & lio->linfo;
    
#line 862 
    if ((unsigned int)linfo->link.s.status != 0U) {
      
#line 863 
      if ((lio->msg_enable & 4U) != 0U) {
        char *tmp_0;
        
#line 863 
        if ((unsigned int)linfo->link.s.duplex != 0U) 
#line 863 
                                                      tmp_0 = (char *)"Full"; else 
                                                                    
#line 863 
                                                                    tmp_0 = (char *)"Half";
        
#line 863 
        ;
        
#line 863 
        ;
        
#line 863 
        netdev_info((struct net_device const *)lio->netdev,"%d Mbps %s Duplex UP\n",(int)linfo->link.s.speed,tmp_0);
      }
      else ;
    }
    else 
      
#line 867 
      if ((lio->msg_enable & 4U) != 0U) 
#line 867 
                                        netdev_info((struct net_device const *)lio->netdev,"Link Down\n"); else ;
  }
  else ;
  
#line 869 
  return;
}


#line 880  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
__inline static void update_link_status(struct net_device *netdev, union oct_link_status *ls)
{
  
#line 883 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 885 
  if (lio->intf_open != 0U && lio->linfo.link.u64 != ls->u64) {
    
#line 886 
    lio->linfo.link.u64 = ls->u64;
    
#line 888 
    print_link_info(netdev);
    
#line 890 
    if ((unsigned int)lio->linfo.link.s.status != 0U) {
      
#line 891 
      netif_carrier_on(netdev);
      
#line 893 
      txqs_wake(netdev);
    }
    else {
      
#line 895 
      netif_carrier_off(netdev);
      
#line 896 
      stop_txq(netdev);
    }
  }
  else ;
  
#line 899 
  return;
}


#line 906  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static void liquidio_schedule_droq_pkt_handlers(struct octeon_device *oct)
{
  u64 oq_no;
  struct octeon_droq *droq;
  
#line 908 
  struct octeon_device_priv *oct_priv = (struct octeon_device_priv *)oct->priv;
  
#line 913 
  if ((oct->int_status & 4U) != 0U) {
    
#line 914 
    oq_no = 0ULL;
    
#line 914 
    goto ldv_55193;
    ldv_55192: 
#line 915 
    ;
    
#line 915 
    if ((oct->droq_intr & (unsigned long long)(1 << oq_no)) == 0ULL) 
      
#line 916 
      goto ldv_55191; else ;
    
#line 918 
    droq = oct->droq[oq_no];
    
#line 920 
    if (droq->ops.poll_mode != 0U) {
      
#line 921 
      (*(droq->ops.napi_fn))((void *)droq);
      
#line 922 
      oct_priv->napi_mask |= (unsigned long)(1 << oq_no);
    }
    else 
#line 924 
         ldv_tasklet_schedule_81(& oct_priv->droq_tasklet);
    ldv_55191: 
#line 925 
    ;
    
#line 914 
    oq_no += 1ULL;
    ldv_55193: 
#line 915 
    ;
    
#line 914 
    if (oq_no <= 31ULL) 
#line 916 
                        goto ldv_55192; else 
#line 919 
                                             goto ldv_55194;
    ldv_55194: 
#line 920 
    ;
  }
  else ;
  
#line 922 
  return;
}


#line 936  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static irqreturn_t liquidio_intr_handler(int irq, void *dev)
{
  irqreturn_t ret;
  int tmp;
  
#line 938 
  struct octeon_device *oct = (struct octeon_device *)dev;
  
#line 942 
  (*(oct->fn_list.disable_interrupt))(oct->chip);
  
#line 944 
  ret = (*(oct->fn_list.process_interrupt_regs))((void *)oct);
  
#line 946 
  if (ret == (unsigned int)IRQ_HANDLED) 
#line 947 
                                        liquidio_schedule_droq_pkt_handlers(oct); else ;
  
#line 950 
  tmp = atomic_read((atomic_t const *)(& oct->status));
  
#line 950 
  if (tmp != 12) 
#line 951 
                 (*(oct->fn_list.enable_interrupt))(oct->chip); else ;
  
#line 953 
  return ret;
}


#line 962  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int octeon_setup_interrupt(struct octeon_device *oct)
{
  int __retres;
  int irqret;
  int err;
  
#line 966 
  err = pci_enable_msi_exact(oct->pci_dev,1);
  
#line 967 
  if (err != 0) 
#line 968 
                dev_warn((struct device const *)(& (oct->pci_dev)->dev),"Reverting to legacy interrupts. Error: %d\n",err); else 
                                                                    
#line 971 
                                                                    oct->flags = (unsigned short)((unsigned int)oct->flags | 2U);
  
#line 973 
  irqret = ldv_request_irq_82((oct->pci_dev)->irq,& liquidio_intr_handler,128UL,"octeon",(void *)oct);
  
#line 975 
  if (irqret != 0) {
    
#line 976 
    if (((unsigned int)oct->flags & 2U) != 0U) 
#line 977 
                                               pci_disable_msi(oct->pci_dev); else ;
    
#line 978 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Request IRQ failed with code: %d\n",irqret);
    
#line 980 
    __retres = 1;
    
#line 980 
    goto return_label;
  }
  else ;
  
#line 983 
  __retres = 0;
  return_label: 
#line 983 
                return __retres;
}


#line 991  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int liquidio_probe(struct pci_dev *pdev, struct pci_device_id const *ent)
{
  int __retres;
  struct handshake *hs;
  int tmp;
  
#line 993 
  struct octeon_device *oct_dev = (struct octeon_device *)0;
  
#line 996 
  oct_dev = octeon_allocate_device((unsigned int)pdev->device,48U);
  
#line 998 
  if (oct_dev == (struct octeon_device *)0) {
    
#line 999 
    dev_err((struct device const *)(& pdev->dev),"Unable to allocate device\n");
    
#line 1000 
    __retres = -12;
    
#line 1000 
    goto return_label;
  }
  else ;
  
#line 1003 
  _dev_info((struct device const *)(& pdev->dev),"Initializing device %x:%x.\n",(unsigned int)pdev->vendor,(unsigned int)pdev->device);
  
#line 1007 
  pci_set_drvdata(pdev,(void *)oct_dev);
  
#line 1010 
  oct_dev->pci_dev = pdev;
  
#line 1012 
  hs = & handshake[oct_dev->octeon_id];
  
#line 1013 
  init_completion(& hs->init);
  
#line 1014 
  init_completion(& hs->started);
  
#line 1015 
  hs->pci_dev = pdev;
  
#line 1017 
  if (oct_dev->octeon_id == 0U) 
#line 1019 
                                complete(& first_stage); else ;
  
#line 1021 
  tmp = octeon_device_init(oct_dev);
  
#line 1021 
  if (tmp != 0) {
    
#line 1022 
    liquidio_remove(pdev);
    
#line 1023 
    __retres = -12;
    
#line 1023 
    goto return_label;
  }
  else ;
  {
    
#line 1026 
    struct _ddebug descriptor = {.modname = "liquidio", .function = "liquidio_probe", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c", .format = "Device is ready\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1026U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1026 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1026 
                                                        __dynamic_dev_dbg(& descriptor,(struct device const *)(& (oct_dev->pci_dev)->dev),"Device is ready\n"); else ;
  }
  
#line 1028 
  __retres = 0;
  return_label: 
#line 1028 
                return __retres;
}


#line 1036  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static void octeon_destroy_resources(struct octeon_device *oct)
{
  int i;
  struct handshake *hs;
  int tmp;
  
#line 1039 
  struct octeon_device_priv *oct_priv = (struct octeon_device_priv *)oct->priv;
  
#line 1044 
  tmp = atomic_read((atomic_t const *)(& oct->status));
  
#line 1044 
  switch (tmp) {
    int tmp_1;
    int tmp_2;
    int tmp_3;
    case 11: 
#line 1045 
    ;
    case 10: 
#line 1046 
    ;
    
#line 1049 
    atomic_set(& oct->status,12);
    
#line 1051 
    oct->app_mode = 2U;
    {
      
#line 1052 
      struct _ddebug descriptor = {.modname = "liquidio", .function = "octeon_destroy_resources", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c", .format = "Device state is now %s\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1053U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1052 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
        char *tmp_0;
        
#line 1052 
        tmp_0 = lio_get_state_string(& oct->status);
        
#line 1052 
        ;
        
#line 1052 
        __dynamic_dev_dbg(& descriptor,(struct device const *)(& (oct->pci_dev)->dev),"Device state is now %s\n",tmp_0);
      }
      else ;
    }
    
#line 1055 
    schedule_timeout_uninterruptible(25L);
    case 9: 
#line 1058 
    ;
    case 8: 
#line 1061 
    ;
    
#line 1063 
    octeon_remove_consoles(oct);
    case 7: 
#line 1066 
    ;
    
#line 1067 
    tmp_1 = wait_for_pending_requests(oct);
    
#line 1067 
    if (tmp_1 != 0) 
#line 1068 
                    dev_err((struct device const *)(& (oct->pci_dev)->dev),"There were pending requests\n"); else ;
    
#line 1070 
    tmp_2 = lio_wait_for_instr_fetch(oct);
    
#line 1070 
    if (tmp_2 != 0) 
#line 1071 
                    dev_err((struct device const *)(& (oct->pci_dev)->dev),"IQ had pending instructions\n"); else ;
    
#line 1077 
    (*(oct->fn_list.disable_io_queues))(oct);
    
#line 1079 
    tmp_3 = lio_wait_for_oq_pkts(oct);
    
#line 1079 
    if (tmp_3 != 0) 
#line 1080 
                    dev_err((struct device const *)(& (oct->pci_dev)->dev),"OQ had pending packets\n"); else ;
    
#line 1083 
    (*(oct->fn_list.disable_interrupt))(oct->chip);
    
#line 1086 
    ldv_free_irq_83((oct->pci_dev)->irq,(void *)oct);
    
#line 1088 
    if (((unsigned int)oct->flags & 2U) != 0U) 
#line 1089 
                                               pci_disable_msi(oct->pci_dev); else ;
    
#line 1092 
    (*(oct->fn_list.soft_reset))(oct);
    
#line 1095 
    pci_disable_device(oct->pci_dev);
    case 12: 
#line 1098 
    ;
    case 6: 
#line 1099 
    ;
    {
      
#line 1101 
      unsigned long __ms = 100UL;
      {
        unsigned long tmp_4;
        
#line 1101 
        goto ldv_55231;
        ldv_55230: 
#line 1102 
        ;
        
#line 1101 
        __const_udelay(4295000UL);
        ldv_55231: 
#line 1103 
        ;
        
#line 1101 
        tmp_4 = __ms;
        
#line 1101 
        __ms -= 1UL;
        
#line 1101 
        ;
        
#line 1101 
        if (tmp_4 != 0UL) 
#line 1103 
                          goto ldv_55230; else 
#line 1106 
                                               goto ldv_55232;
        ldv_55232: 
#line 1107 
        ;
      }
    }
    
#line 1102 
    i = 0;
    
#line 1102 
    goto ldv_55235;
    ldv_55234: 
#line 1103 
    ;
    
#line 1103 
    if ((((unsigned long)oct->io_qmask.oq >> i) & 1UL) == 0UL) 
#line 1104 
                                                               goto ldv_55233; else ;
    
#line 1105 
    octeon_delete_droq(oct,(unsigned int)i);
    ldv_55233: 
#line 1106 
    ;
    
#line 1102 
    i += 1;
    ldv_55235: 
#line 1103 
    ;
    
#line 1102 
    if (i <= 31) 
#line 1104 
                 goto ldv_55234; else 
#line 1107 
                                      goto ldv_55236;
    ldv_55236: 
#line 1108 
    ;
    
#line 1109 
    i = 0;
    
#line 1109 
    goto ldv_55238;
    ldv_55237: 
#line 1110 
    ;
    
#line 1110 
    hs = & handshake[i];
    
#line 1112 
    if (hs->pci_dev != (struct pci_dev *)0) {
      
#line 1113 
      handshake[oct->octeon_id].init_ok = 0;
      
#line 1114 
      complete(& handshake[oct->octeon_id].init);
      
#line 1115 
      handshake[oct->octeon_id].started_ok = 0;
      
#line 1116 
      complete(& handshake[oct->octeon_id].started);
    }
    else ;
    
#line 1109 
    i += 1;
    ldv_55238: 
#line 1110 
    ;
    
#line 1109 
    if (i <= 31) 
#line 1111 
                 goto ldv_55237; else 
#line 1114 
                                      goto ldv_55239;
    ldv_55239: 
#line 1115 
    ;
    case 5: 
#line 1121 
    ;
    
#line 1122 
    octeon_delete_response_list(oct);
    case 4: 
#line 1125 
    ;
    
#line 1126 
    octeon_free_sc_buffer_pool(oct);
    case 3: 
#line 1129 
    ;
    
#line 1130 
    i = 0;
    
#line 1130 
    goto ldv_55245;
    ldv_55244: 
#line 1131 
    ;
    
#line 1131 
    if ((((unsigned long)oct->io_qmask.iq >> i) & 1UL) == 0UL) 
#line 1132 
                                                               goto ldv_55243; else ;
    
#line 1133 
    octeon_delete_instr_queue(oct,(unsigned int)i);
    ldv_55243: 
#line 1134 
    ;
    
#line 1130 
    i += 1;
    ldv_55245: 
#line 1131 
    ;
    
#line 1130 
    if (i <= 31) 
#line 1132 
                 goto ldv_55244; else 
#line 1135 
                                      goto ldv_55246;
    ldv_55246: 
#line 1136 
    ;
    case 2: 
#line 1137 
    ;
    
#line 1138 
    octeon_delete_dispatch_list(oct);
    
#line 1139 
    cancel_delayed_work_sync(& oct->nic_poll_work.work);
    case 1: 
#line 1142 
    ;
    
#line 1143 
    octeon_unmap_pci_barx(oct,0);
    
#line 1144 
    octeon_unmap_pci_barx(oct,1);
    case 0: 
#line 1147 
    ;
    
#line 1149 
    goto ldv_55250;
  }
  ldv_55250: 
#line 1152 
  ;
  
#line 1152 
  tasklet_kill(& oct_priv->droq_tasklet);
  
#line 1153 
  return;
}


#line 1160  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static void send_rx_ctrl_cmd(struct lio *lio, int start_stop)
{
  struct octnic_ctrl_pkt nctrl;
  struct octnic_ctrl_params nparams;
  int tmp;
  
#line 1165 
  memset((void *)(& nctrl),0,320UL);
  
#line 1167 
  nctrl.ncmd.s.cmd = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(5))))4U;
  
#line 1168 
  nctrl.ncmd.s.param1 = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(29))))lio->linfo.ifidx;
  
#line 1169 
  nctrl.ncmd.s.param2 = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))((unsigned short)start_stop);
  
#line 1170 
  nctrl.netpndev = (unsigned long long)lio->netdev;
  
#line 1172 
  nparams.resp_order = 2U;
  
#line 1174 
  tmp = octnet_send_nic_ctrl_pkt(lio->oct_dev,& nctrl,nparams);
  
#line 1174 
  if (tmp < 0) {
    
#line 1175 
    if ((lio->msg_enable & 64U) != 0U) 
#line 1175 
                                       netdev_info((struct net_device const *)lio->netdev,"Failed to send RX Control message\n"); else ;
  }
  else ;
  
#line 1176 
  return;
}


#line 1186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static void liquidio_destroy_nic_device(struct octeon_device *oct, int ifidx)
{
  struct lio *lio;
  int tmp_0;
  int tmp_1;
  
#line 1188 
  struct net_device *netdev = oct->props[ifidx].netdev;
  
#line 1191 
  if (netdev == (struct net_device *)0) {
    
#line 1192 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"%s No netdevice ptr for index %d\n","liquidio_destroy_nic_device",ifidx);
    
#line 1194 
    goto return_label;
  }
  else ;
  
#line 1197 
  lio = (struct lio *)netdev_priv((struct net_device const *)netdev);
  {
    
#line 1199 
    struct _ddebug descriptor = {.modname = "liquidio", .function = "liquidio_destroy_nic_device", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c", .format = "NIC device cleanup\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1199U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1199 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1199 
                                                        __dynamic_dev_dbg(& descriptor,(struct device const *)(& (oct->pci_dev)->dev),"NIC device cleanup\n"); else ;
  }
  
#line 1201 
  send_rx_ctrl_cmd(lio,0);
  
#line 1203 
  tmp_0 = atomic_read((atomic_t const *)(& lio->ifstate));
  
#line 1203 
  if ((tmp_0 & 4) != 0) 
#line 1204 
                        txqs_stop(netdev); else ;
  
#line 1206 
  tmp_1 = atomic_read((atomic_t const *)(& lio->ifstate));
  
#line 1206 
  if ((tmp_1 & 2) != 0) 
#line 1207 
                        ldv_unregister_netdev_84(netdev); else ;
  
#line 1209 
  delete_glist(lio);
  
#line 1211 
  ldv_free_netdev_85(netdev);
  
#line 1213 
  oct->props[ifidx].netdev = (struct net_device *)0;
  return_label: 
#line 1214 
                return;
}


#line 1220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int liquidio_stop_nic_module(struct octeon_device *oct)
{
  int __retres;
  int i;
  int j;
  struct lio *lio;
  {
    
#line 1225 
    struct _ddebug descriptor = {.modname = "liquidio", .function = "liquidio_stop_nic_module", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c", .format = "Stopping network interfaces\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1225U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1225 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1225 
                                                        __dynamic_dev_dbg(& descriptor,(struct device const *)(& (oct->pci_dev)->dev),"Stopping network interfaces\n"); else ;
  }
  
#line 1226 
  if (oct->ifcount == 0U) {
    
#line 1227 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Init for Octeon was not completed\n");
    
#line 1228 
    __retres = 1;
    
#line 1228 
    goto return_label;
  }
  else ;
  
#line 1231 
  i = 0;
  
#line 1231 
  goto ldv_55277;
  ldv_55276: 
#line 1232 
  ;
  
#line 1232 
  lio = (struct lio *)netdev_priv((struct net_device const *)oct->props[i].netdev);
  
#line 1233 
  j = 0;
  
#line 1233 
  goto ldv_55274;
  ldv_55273: 
#line 1234 
  ;
  
#line 1234 
  octeon_unregister_droq_ops(oct,(unsigned int)lio->linfo.rxpciq[j]);
  
#line 1233 
  j += 1;
  ldv_55274: 
#line 1234 
  ;
  
#line 1233 
  if ((int)lio->linfo.num_rxpciq > j) 
#line 1235 
                                      goto ldv_55273; else 
#line 1238 
                                                           goto ldv_55275;
  ldv_55275: 
#line 1239 
  ;
  
#line 1231 
  i += 1;
  ldv_55277: 
#line 1232 
  ;
  
#line 1231 
  if (oct->ifcount > (unsigned int)i) 
#line 1233 
                                      goto ldv_55276; else 
#line 1236 
                                                           goto ldv_55278;
  ldv_55278: 
#line 1237 
  ;
  
#line 1237 
  i = 0;
  
#line 1237 
  goto ldv_55280;
  ldv_55279: 
#line 1238 
  ;
  
#line 1238 
  liquidio_destroy_nic_device(oct,i);
  
#line 1237 
  i += 1;
  ldv_55280: 
#line 1238 
  ;
  
#line 1237 
  if (oct->ifcount > (unsigned int)i) 
#line 1239 
                                      goto ldv_55279; else 
#line 1242 
                                                           goto ldv_55281;
  ldv_55281: 
#line 1243 
  ;
  {
    
#line 1240 
    struct _ddebug descriptor_0 = {.modname = "liquidio", .function = "liquidio_stop_nic_module", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c", .format = "Network interfaces stopped\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1240U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1240 
    if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 1240 
                                                          __dynamic_dev_dbg(& descriptor_0,(struct device const *)(& (oct->pci_dev)->dev),"Network interfaces stopped\n"); else ;
  }
  
#line 1241 
  __retres = 0;
  return_label: 
#line 1241 
                return __retres;
}


#line 1248  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static void liquidio_remove(struct pci_dev *pdev)
{
  
#line 1250 
  struct octeon_device *oct_dev = pci_get_drvdata(pdev);
  {
    
#line 1252 
    struct _ddebug descriptor = {.modname = "liquidio", .function = "liquidio_remove", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c", .format = "Stopping device\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1252U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1252 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1252 
                                                        __dynamic_dev_dbg(& descriptor,(struct device const *)(& (oct_dev->pci_dev)->dev),"Stopping device\n"); else ;
  }
  
#line 1254 
  if (oct_dev->app_mode == 1U) 
#line 1255 
                               liquidio_stop_nic_module(oct_dev); else ;
  
#line 1260 
  octeon_destroy_resources(oct_dev);
  
#line 1262 
  _dev_info((struct device const *)(& (oct_dev->pci_dev)->dev),"Device removed\n");
  
#line 1267 
  octeon_free_device_mem(oct_dev);
  
#line 1268 
  return;
}


#line 1274  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int octeon_chip_specific_setup(struct octeon_device *oct)
{
  u32 dev_id;
  u32 rev_id;
  
#line 1277 
  int ret = 1;
  
#line 1279 
  pci_read_config_dword((struct pci_dev const *)oct->pci_dev,0,& dev_id);
  
#line 1280 
  pci_read_config_dword((struct pci_dev const *)oct->pci_dev,8,& rev_id);
  
#line 1281 
  oct->rev_id = (unsigned short)((unsigned int)((unsigned short)rev_id) & 255U);
  
#line 1283 
  switch (dev_id) {
    case (u32)9508733: 
#line 1284 
    ;
    
#line 1285 
    oct->chip_id = (unsigned short)145U;
    
#line 1286 
    ret = lio_setup_cn68xx_octeon_device(oct);
    
#line 1287 
    goto ldv_55296;
    case (u32)9574269: 
#line 1289 
    ;
    
#line 1290 
    oct->chip_id = (unsigned short)146U;
    
#line 1291 
    ret = lio_setup_cn66xx_octeon_device(oct);
    
#line 1292 
    goto ldv_55296;
    default: 
#line 1293 
    ;
    
#line 1294 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Unknown device found (dev_id: %x)\n",dev_id);
  }
  ldv_55296: 
#line 1298 
  ;
  
#line 1298 
  if (ret == 0) {
    struct octeon_config *tmp;
    u16 tmp_0;
    u16 tmp_1;
    
#line 1299 
    tmp = octeon_get_conf(oct);
    
#line 1299 
    tmp_0 = OCTEON_MINOR_REV(oct);
    
#line 1299 
    tmp_1 = OCTEON_MAJOR_REV(oct);
    
#line 1299 
    ;
    
#line 1299 
    _dev_info((struct device const *)(& (oct->pci_dev)->dev),"CN68XX PASS%d.%d %s\n",(int)tmp_1,(int)tmp_0,tmp->card_name);
  }
  else ;
  
#line 1304 
  return ret;
}


#line 1311  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int octeon_pci_os_setup(struct octeon_device *oct)
{
  int __retres;
  int tmp;
  int tmp_0;
  
#line 1314 
  tmp = pci_enable_device(oct->pci_dev);
  
#line 1314 
  if (tmp != 0) {
    
#line 1315 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"pci_enable_device failed\n");
    
#line 1316 
    __retres = 1;
    
#line 1316 
    goto return_label;
  }
  else ;
  
#line 1319 
  tmp_0 = dma_set_mask_and_coherent(& (oct->pci_dev)->dev,18446744073709551615ULL);
  
#line 1319 
  if (tmp_0 != 0) {
    
#line 1320 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Unexpected DMA device capability\n");
    
#line 1321 
    __retres = 1;
    
#line 1321 
    goto return_label;
  }
  else ;
  
#line 1325 
  pci_set_master(oct->pci_dev);
  
#line 1327 
  __retres = 0;
  return_label: 
#line 1327 
                return __retres;
}


#line 1335  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
__inline static int check_txq_state(struct lio *lio, struct sk_buff *skb)
{
  int __retres;
  bool tmp;
  int tmp_0;
  
#line 1337 
  int q = 0;
  
#line 1337 
  int iq = 0;
  
#line 1339 
  tmp = netif_is_multiqueue((struct net_device const *)lio->netdev);
  
#line 1339 
  if ((int)tmp != 0) {
    
#line 1340 
    q = (int)skb->queue_mapping;
    
#line 1341 
    iq = (int)lio->linfo.txpciq[((int)lio->linfo.num_txpciq + -1) & q];
  }
  else 
#line 1343 
       iq = lio->txq;
  
#line 1346 
  tmp_0 = octnet_iq_is_full(lio->oct_dev,(unsigned int)iq);
  
#line 1346 
  if (tmp_0 != 0) {
    
#line 1347 
    __retres = 0;
    
#line 1347 
    goto return_label;
  }
  else ;
  
#line 1348 
  wake_q(lio->netdev,q);
  
#line 1349 
  __retres = 1;
  return_label: 
#line 1349 
                return __retres;
}


#line 1356  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static void free_netbuf(void *buf)
{
  struct sk_buff *skb;
  struct octnet_buf_free_info *finfo;
  struct lio *lio;
  
#line 1362 
  finfo = (struct octnet_buf_free_info *)buf;
  
#line 1363 
  skb = finfo->skb;
  
#line 1364 
  lio = finfo->lio;
  
#line 1366 
  dma_unmap_single_attrs(& ((lio->oct_dev)->pci_dev)->dev,finfo->dptr,(unsigned long)skb->len,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
  
#line 1369 
  check_txq_state(lio,skb);
  
#line 1371 
  recv_buffer_free((void *)skb);
  
#line 1372 
  return;
}


#line 1378  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static void free_netsgbuf(void *buf)
{
  struct octnet_buf_free_info *finfo;
  struct sk_buff *skb;
  struct lio *lio;
  struct octnic_gather *g;
  int i;
  int frags;
  unsigned char *tmp;
  int tmp_1;
  
#line 1386 
  finfo = (struct octnet_buf_free_info *)buf;
  
#line 1387 
  skb = finfo->skb;
  
#line 1388 
  lio = finfo->lio;
  
#line 1389 
  g = finfo->g;
  
#line 1390 
  tmp = skb_end_pointer((struct sk_buff const *)skb);
  
#line 1390 
  frags = (int)((struct skb_shared_info *)tmp)->nr_frags;
  
#line 1392 
  dma_unmap_single_attrs(& ((lio->oct_dev)->pci_dev)->dev,(g->sg)->ptr[0],(unsigned long)(skb->len - skb->data_len),(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
  
#line 1396 
  i = 1;
  
#line 1397 
  goto ldv_55325;
  ldv_55324: 
#line 1398 
  ;
  {
    unsigned char *tmp_0;
    
#line 1398 
    tmp_0 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 1398 
    struct skb_frag_struct *frag = & ((struct skb_shared_info *)tmp_0)->frags[i + -1];
    
#line 1400 
    pci_unmap_page((lio->oct_dev)->pci_dev,(g->sg + (i >> 2))->ptr[i & 3],(unsigned long)frag->size,1);
    
#line 1403 
    i += 1;
  }
  ldv_55325: 
#line 1405 
  ;
  
#line 1397 
  tmp_1 = frags;
  
#line 1397 
  frags -= 1;
  
#line 1397 
  ;
  
#line 1397 
  if (tmp_1 != 0) 
#line 1399 
                  goto ldv_55324; else 
#line 1402 
                                       goto ldv_55326;
  ldv_55326: 
#line 1403 
  ;
  
#line 1406 
  dma_unmap_single_attrs(& ((lio->oct_dev)->pci_dev)->dev,finfo->dptr,(unsigned long)g->sg_size,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
  
#line 1410 
  ldv_spin_lock_86(& lio->lock);
  
#line 1411 
  list_add_tail(& g->list,& lio->glist);
  
#line 1412 
  ldv_spin_unlock_87_0(& lio->lock);
  
#line 1414 
  check_txq_state(lio,skb);
  
#line 1416 
  recv_buffer_free((void *)skb);
  
#line 1417 
  return;
}


#line 1423  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static void free_netsgbuf_with_resp(void *buf)
{
  struct octeon_soft_command *sc;
  struct octnet_buf_free_info *finfo;
  struct sk_buff *skb;
  struct lio *lio;
  struct octnic_gather *g;
  int i;
  int frags;
  unsigned char *tmp;
  int tmp_1;
  
#line 1432 
  sc = (struct octeon_soft_command *)buf;
  
#line 1433 
  skb = (struct sk_buff *)sc->callback_arg;
  
#line 1434 
  finfo = (struct octnet_buf_free_info *)(& skb->cb);
  
#line 1436 
  lio = finfo->lio;
  
#line 1437 
  g = finfo->g;
  
#line 1438 
  tmp = skb_end_pointer((struct sk_buff const *)skb);
  
#line 1438 
  frags = (int)((struct skb_shared_info *)tmp)->nr_frags;
  
#line 1440 
  dma_unmap_single_attrs(& ((lio->oct_dev)->pci_dev)->dev,(g->sg)->ptr[0],(unsigned long)(skb->len - skb->data_len),(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
  
#line 1444 
  i = 1;
  
#line 1445 
  goto ldv_55339;
  ldv_55338: 
#line 1446 
  ;
  {
    unsigned char *tmp_0;
    
#line 1446 
    tmp_0 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 1446 
    struct skb_frag_struct *frag = & ((struct skb_shared_info *)tmp_0)->frags[i + -1];
    
#line 1448 
    pci_unmap_page((lio->oct_dev)->pci_dev,(g->sg + (i >> 2))->ptr[i & 3],(unsigned long)frag->size,1);
    
#line 1451 
    i += 1;
  }
  ldv_55339: 
#line 1453 
  ;
  
#line 1445 
  tmp_1 = frags;
  
#line 1445 
  frags -= 1;
  
#line 1445 
  ;
  
#line 1445 
  if (tmp_1 != 0) 
#line 1447 
                  goto ldv_55338; else 
#line 1450 
                                       goto ldv_55340;
  ldv_55340: 
#line 1451 
  ;
  
#line 1454 
  dma_unmap_single_attrs(& ((lio->oct_dev)->pci_dev)->dev,finfo->dptr,(unsigned long)g->sg_size,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
  
#line 1458 
  ldv_spin_lock_88_0(& lio->lock);
  
#line 1459 
  list_add_tail(& g->list,& lio->glist);
  
#line 1460 
  ldv_spin_unlock_89_0(& lio->lock);
  
#line 1464 
  check_txq_state(lio,skb);
  
#line 1465 
  return;
}


#line 1472  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int liquidio_ptp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)
{
  int __retres;
  struct lio *tmp;
  u64 comp;
  u64 delta;
  unsigned long flags;
  {
    
#line 1474 
    struct ptp_clock_info const *__mptr = (struct ptp_clock_info const *)ptp;
    
#line 1474 
    tmp = (struct lio *)__mptr + 18446744073709551368U;
  }
  
#line 1474 
  struct lio *lio = tmp;
  
#line 1475 
  struct octeon_device *oct = lio->oct_dev;
  
#line 1478 
  bool neg_adj = (_Bool)0;
  
#line 1480 
  if (ppb < 0) {
    
#line 1481 
    neg_adj = (_Bool)1;
    
#line 1482 
    ppb = - ppb;
  }
  else ;
  
#line 1489 
  delta = (unsigned long long)ppb << 32;
  {
    uint32_t __rem;
    
#line 1490 
    uint32_t __base = (unsigned int)oct->coproc_clock_rate;
    
#line 1490 
    __rem = (unsigned int)(delta % (unsigned long long)__base);
    
#line 1490 
    delta /= (unsigned long long)__base;
    
#line 1490 
    uint32_t tmp_2 = __rem;
  }
  
#line 1492 
  ldv___ldv_spin_lock_90(& lio->ptp_lock);
  
#line 1493 
  comp = lio_pci_readq(oct,289171558108952ULL);
  
#line 1494 
  if ((int)neg_adj != 0) 
#line 1495 
                         comp -= delta; else 
#line 1497 
                                             comp += delta;
  
#line 1498 
  lio_pci_writeq(oct,comp,289171558108952ULL);
  
#line 1499 
  ldv_spin_unlock_irqrestore_91(& lio->ptp_lock,flags);
  
#line 1501 
  __retres = 0;
  
#line 1501 
  return __retres;
}


#line 1509  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int liquidio_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)
{
  int __retres;
  unsigned long flags;
  struct lio *tmp;
  {
    
#line 1512 
    struct ptp_clock_info const *__mptr = (struct ptp_clock_info const *)ptp;
    
#line 1512 
    tmp = (struct lio *)__mptr + 18446744073709551368U;
  }
  
#line 1512 
  struct lio *lio = tmp;
  
#line 1514 
  ldv___ldv_spin_lock_92(& lio->ptp_lock);
  
#line 1515 
  lio->ptp_adjust += delta;
  
#line 1516 
  ldv_spin_unlock_irqrestore_93(& lio->ptp_lock,flags);
  
#line 1518 
  __retres = 0;
  
#line 1518 
  return __retres;
}


#line 1526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int liquidio_ptp_gettime(struct ptp_clock_info *ptp, struct timespec *ts)
{
  int __retres;
  u64 ns;
  u32 remainder;
  unsigned long flags;
  struct lio *tmp;
  u64 tmp_0;
  {
    
#line 1532 
    struct ptp_clock_info const *__mptr = (struct ptp_clock_info const *)ptp;
    
#line 1532 
    tmp = (struct lio *)__mptr + 18446744073709551368U;
  }
  
#line 1532 
  struct lio *lio = tmp;
  
#line 1533 
  struct octeon_device *oct = lio->oct_dev;
  
#line 1535 
  ldv___ldv_spin_lock_94(& lio->ptp_lock);
  
#line 1536 
  ns = lio_pci_readq(oct,289171558108944ULL);
  
#line 1537 
  ns = (unsigned long long)lio->ptp_adjust + ns;
  
#line 1538 
  ldv_spin_unlock_irqrestore_95(& lio->ptp_lock,flags);
  
#line 1540 
  tmp_0 = div_u64_rem(ns,1000000000U,& remainder);
  
#line 1540 
  ts->tv_sec = (long)tmp_0;
  
#line 1541 
  ts->tv_nsec = (long)remainder;
  
#line 1543 
  __retres = 0;
  
#line 1543 
  return __retres;
}


#line 1551  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int liquidio_ptp_settime(struct ptp_clock_info *ptp, struct timespec const *ts)
{
  int __retres;
  u64 ns;
  unsigned long flags;
  struct lio *tmp;
  s64 tmp_0;
  {
    
#line 1556 
    struct ptp_clock_info const *__mptr = (struct ptp_clock_info const *)ptp;
    
#line 1556 
    tmp = (struct lio *)__mptr + 18446744073709551368U;
  }
  
#line 1556 
  struct lio *lio = tmp;
  
#line 1557 
  struct octeon_device *oct = lio->oct_dev;
  
#line 1559 
  tmp_0 = timespec_to_ns(ts);
  
#line 1559 
  ns = (unsigned long long)tmp_0;
  
#line 1561 
  ldv___ldv_spin_lock_96(& lio->ptp_lock);
  
#line 1562 
  lio_pci_writeq(oct,ns,289171558108944ULL);
  
#line 1563 
  lio->ptp_adjust = 0LL;
  
#line 1564 
  ldv_spin_unlock_irqrestore_97(& lio->ptp_lock,flags);
  
#line 1566 
  __retres = 0;
  
#line 1566 
  return __retres;
}


#line 1575  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int liquidio_ptp_enable(struct ptp_clock_info *ptp, struct ptp_clock_request *rq, int on)
{
  int __retres;
  
#line 1578 
  __retres = -95;
  
#line 1578 
  return __retres;
}


#line 1585  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static void oct_ptp_open(struct net_device *netdev)
{
  bool tmp_0;
  
#line 1587 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 1588 
  struct octeon_device *oct = lio->oct_dev;
  
#line 1590 
  spinlock_check(& lio->ptp_lock);
  {
    struct lock_class_key __key;
    
#line 1590 
    __raw_spin_lock_init(& lio->ptp_lock.__anonCompField_spinlock_18.rlock,"&(&lio->ptp_lock)->rlock",& __key);
  }
  
#line 1592 
  snprintf((char *)(& lio->ptp_info.name),16UL,"%s",(char *)(& netdev->name));
  
#line 1593 
  lio->ptp_info.owner = & __this_module;
  
#line 1594 
  lio->ptp_info.max_adj = 250000000;
  
#line 1595 
  lio->ptp_info.n_alarm = 0;
  
#line 1596 
  lio->ptp_info.n_ext_ts = 0;
  
#line 1597 
  lio->ptp_info.n_per_out = 0;
  
#line 1598 
  lio->ptp_info.pps = 0;
  
#line 1599 
  lio->ptp_info.adjfreq = & liquidio_ptp_adjfreq;
  
#line 1600 
  lio->ptp_info.adjtime = & liquidio_ptp_adjtime;
  
#line 1601 
  lio->ptp_info.gettime64 = & liquidio_ptp_gettime;
  
#line 1602 
  lio->ptp_info.settime64 = & liquidio_ptp_settime;
  
#line 1603 
  lio->ptp_info.enable = & liquidio_ptp_enable;
  
#line 1605 
  lio->ptp_adjust = 0LL;
  
#line 1607 
  lio->ptp_clock = ptp_clock_register(& lio->ptp_info,& (oct->pci_dev)->dev);
  
#line 1610 
  tmp_0 = IS_ERR((void const *)lio->ptp_clock);
  
#line 1610 
  if ((int)tmp_0 != 0) 
#line 1611 
                       lio->ptp_clock = (struct ptp_clock *)0; else ;
  
#line 1612 
  return;
}


#line 1618  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static void liquidio_ptp_init(struct octeon_device *oct)
{
  u64 clock_comp;
  u64 cfg;
  
#line 1622 
  clock_comp = 4294967296000000000ULL;
  {
    uint32_t __rem;
    
#line 1623 
    uint32_t __base = (unsigned int)oct->coproc_clock_rate;
    
#line 1623 
    __rem = (unsigned int)(clock_comp % (unsigned long long)__base);
    
#line 1623 
    clock_comp /= (unsigned long long)__base;
    
#line 1623 
    uint32_t tmp = __rem;
  }
  
#line 1624 
  lio_pci_writeq(oct,clock_comp,289171558108952ULL);
  
#line 1627 
  cfg = lio_pci_readq(oct,289171558108928ULL);
  
#line 1628 
  lio_pci_writeq(oct,cfg | 1ULL,289171558108928ULL);
  
#line 1629 
  return;
}


#line 1637  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int load_firmware(struct octeon_device *oct)
{
  int __retres;
  struct firmware const *fw;
  char fw_name[256U];
  char *tmp_fw_type;
  int tmp;
  struct octeon_config *tmp_0;
  
#line 1639 
  int ret = 0;
  
#line 1644 
  tmp = strncmp((char const *)(& fw_type),"none",5UL);
  
#line 1644 
  if (tmp == 0) {
    
#line 1646 
    _dev_info((struct device const *)(& (oct->pci_dev)->dev),"Skipping firmware load\n");
    
#line 1647 
    __retres = ret;
    
#line 1647 
    goto return_label;
  }
  else ;
  
#line 1650 
  if ((int)fw_type[0] == 0) 
#line 1651 
                            tmp_fw_type = (char *)"nic"; else 
#line 1653 
                                                              tmp_fw_type = (char *)(& fw_type);
  
#line 1655 
  ;
  
#line 1656 
  tmp_0 = octeon_get_conf(oct);
  
#line 1655 
  sprintf((char *)(& fw_name),"%s%s%s_%s%s",(char *)"liquidio/",(char *)"lio_",tmp_0->card_name,tmp_fw_type,(char *)".bin");
  
#line 1659 
  ret = request_firmware(& fw,(char const *)(& fw_name),& (oct->pci_dev)->dev);
  
#line 1660 
  if (ret != 0) {
    
#line 1661 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Request firmware failed. Could not find file %s.\n.",(char *)(& fw_name));
    
#line 1663 
    __retres = ret;
    
#line 1663 
    goto return_label;
  }
  else ;
  
#line 1666 
  ret = octeon_download_firmware(oct,fw->data,fw->size);
  
#line 1668 
  release_firmware(fw);
  
#line 1670 
  __retres = ret;
  return_label: 
#line 1670 
                return __retres;
}


#line 1681  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int octeon_setup_droq(struct octeon_device *oct, int q_no, int num_descs, int desc_size, void *app_ctx)
{
  int __retres;
  
#line 1684 
  int ret_val = 0;
  {
    
#line 1686 
    struct _ddebug descriptor = {.modname = "liquidio", .function = "octeon_setup_droq", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c", .format = "Creating Droq: %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1686U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1686 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1686 
                                                        __dynamic_dev_dbg(& descriptor,(struct device const *)(& (oct->pci_dev)->dev),"Creating Droq: %d\n",q_no); else ;
  }
  
#line 1688 
  ret_val = octeon_create_droq(oct,(unsigned int)q_no,(unsigned int)num_descs,(unsigned int)desc_size,app_ctx);
  
#line 1689 
  if (ret_val == -1) {
    
#line 1690 
    __retres = ret_val;
    
#line 1690 
    goto return_label;
  }
  else ;
  
#line 1692 
  if (ret_val == 1) {
    {
      
#line 1693 
      struct _ddebug descriptor_0 = {.modname = "liquidio", .function = "octeon_setup_droq", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c", .format = "Using default droq %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1693U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1693 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 1693 
                                                            __dynamic_dev_dbg(& descriptor_0,(struct device const *)(& (oct->pci_dev)->dev),"Using default droq %d\n",q_no); else ;
    }
    
#line 1694 
    __retres = 0;
    
#line 1694 
    goto return_label;
  }
  else ;
  
#line 1699 
  octeon_set_droq_pkt_op(oct,(unsigned int)q_no,1U);
  
#line 1704 
  writel((oct->droq[q_no])->max_count,(void volatile *)(oct->droq[q_no])->pkts_credit_reg);
  
#line 1707 
  __retres = ret_val;
  return_label: 
#line 1707 
                return __retres;
}


#line 1715  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static void if_cfg_callback(struct octeon_device *oct, u32 status, void *buf)
{
  struct liquidio_if_cfg_resp *resp;
  struct liquidio_if_cfg_context *ctx;
  int volatile *tmp;
  
#line 1719 
  struct octeon_soft_command *sc = (struct octeon_soft_command *)buf;
  
#line 1723 
  resp = (struct liquidio_if_cfg_resp *)sc->virtrptr;
  
#line 1724 
  ctx = (struct liquidio_if_cfg_context *)sc->ctxptr;
  
#line 1726 
  oct = lio_get_device((unsigned int)ctx->octeon_id);
  
#line 1727 
  if (resp->status != 0ULL) 
#line 1728 
                            dev_err((struct device const *)(& (oct->pci_dev)->dev),"nic if cfg instruction failed. Status: %llx\n",(long long)resp->status); else ;
  {
    
#line 1730 
    int __var = 0;
    
#line 1730 
    tmp = (int volatile *)(& ctx->cond);
  }
  
#line 1730 
  *tmp = 1;
  
#line 1731 
  ldv_inline_asm();
  
#line 1737 
  __wake_up(& ctx->wc,1U,1,(void *)0);
  
#line 1738 
  return;
}


#line 1746  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static u16 select_q(struct net_device *dev, struct sk_buff *skb, void *accel_priv, u16 (*fallback)(struct net_device *, struct sk_buff *))
{
  u16 __retres;
  int qindex;
  struct lio *lio;
  bool tmp_0;
  
#line 1752 
  lio = (struct lio *)netdev_priv((struct net_device const *)dev);
  
#line 1754 
  tmp_0 = skb_rx_queue_recorded((struct sk_buff const *)skb);
  
#line 1754 
  if ((int)tmp_0 != 0) {
    u16 tmp_1;
    
#line 1755 
    tmp_1 = skb_get_rx_queue((struct sk_buff const *)skb);
    
#line 1754 
    qindex = (int)tmp_1;
  }
  else {
    int tmp_6;
    {
      int pscr_ret__;
      {
        
#line 1755 
        void const *__vpp_verify = (void const *)0;
        
#line 1755 
        void const *tmp_2 = __vpp_verify;
      }
      
#line 1755 
      switch (4UL) {
        int tmp_2_0;
        int tmp_3;
        int tmp_4;
        int tmp_5;
        case (unsigned long)1: 
#line 1755 
        ;
        {
          int pfo_ret__;
          
#line 1755 
          switch (4UL) {
            case (unsigned long)1: 
#line 1755 
            ;
            
#line 1756 
            ldv_inline_asm();
            
#line 1755 
            goto ldv_55445;
            case (unsigned long)2: 
#line 1755 
            ;
            
#line 1756 
            ldv_inline_asm();
            
#line 1755 
            goto ldv_55445;
            case (unsigned long)4: 
#line 1755 
            ;
            
#line 1756 
            ldv_inline_asm();
            
#line 1755 
            goto ldv_55445;
            case (unsigned long)8: 
#line 1755 
            ;
            
#line 1756 
            ldv_inline_asm();
            
#line 1755 
            goto ldv_55445;
            default: 
#line 1755 
            ;
            
#line 1755 
            __bad_percpu_size();
          }
          ldv_55445: 
#line 1755 
          ;
          
#line 1755 
          tmp_2_0 = pfo_ret__;
        }
        
#line 1755 
        pscr_ret__ = tmp_2_0;
        
#line 1755 
        goto ldv_55451;
        case (unsigned long)2: 
#line 1755 
        ;
        {
          int pfo_ret___0;
          
#line 1755 
          switch (4UL) {
            case (unsigned long)1: 
#line 1755 
            ;
            
#line 1756 
            ldv_inline_asm();
            
#line 1755 
            goto ldv_55455;
            case (unsigned long)2: 
#line 1755 
            ;
            
#line 1756 
            ldv_inline_asm();
            
#line 1755 
            goto ldv_55455;
            case (unsigned long)4: 
#line 1755 
            ;
            
#line 1756 
            ldv_inline_asm();
            
#line 1755 
            goto ldv_55455;
            case (unsigned long)8: 
#line 1755 
            ;
            
#line 1756 
            ldv_inline_asm();
            
#line 1755 
            goto ldv_55455;
            default: 
#line 1755 
            ;
            
#line 1755 
            __bad_percpu_size();
          }
          ldv_55455: 
#line 1755 
          ;
          
#line 1755 
          tmp_3 = pfo_ret___0;
        }
        
#line 1755 
        pscr_ret__ = tmp_3;
        
#line 1755 
        goto ldv_55451;
        case (unsigned long)4: 
#line 1755 
        ;
        {
          int pfo_ret___1;
          
#line 1755 
          switch (4UL) {
            case (unsigned long)1: 
#line 1755 
            ;
            
#line 1756 
            ldv_inline_asm();
            
#line 1755 
            goto ldv_55464;
            case (unsigned long)2: 
#line 1755 
            ;
            
#line 1756 
            ldv_inline_asm();
            
#line 1755 
            goto ldv_55464;
            case (unsigned long)4: 
#line 1755 
            ;
            
#line 1756 
            ldv_inline_asm();
            
#line 1755 
            goto ldv_55464;
            case (unsigned long)8: 
#line 1755 
            ;
            
#line 1756 
            ldv_inline_asm();
            
#line 1755 
            goto ldv_55464;
            default: 
#line 1755 
            ;
            
#line 1755 
            __bad_percpu_size();
          }
          ldv_55464: 
#line 1755 
          ;
          
#line 1755 
          tmp_4 = pfo_ret___1;
        }
        
#line 1755 
        pscr_ret__ = tmp_4;
        
#line 1755 
        goto ldv_55451;
        case (unsigned long)8: 
#line 1755 
        ;
        {
          int pfo_ret___2;
          
#line 1755 
          switch (4UL) {
            case (unsigned long)1: 
#line 1755 
            ;
            
#line 1756 
            ldv_inline_asm();
            
#line 1755 
            goto ldv_55473;
            case (unsigned long)2: 
#line 1755 
            ;
            
#line 1756 
            ldv_inline_asm();
            
#line 1755 
            goto ldv_55473;
            case (unsigned long)4: 
#line 1755 
            ;
            
#line 1756 
            ldv_inline_asm();
            
#line 1755 
            goto ldv_55473;
            case (unsigned long)8: 
#line 1755 
            ;
            
#line 1756 
            ldv_inline_asm();
            
#line 1755 
            goto ldv_55473;
            default: 
#line 1755 
            ;
            
#line 1755 
            __bad_percpu_size();
          }
          ldv_55473: 
#line 1755 
          ;
          
#line 1755 
          tmp_5 = pfo_ret___2;
        }
        
#line 1755 
        pscr_ret__ = tmp_5;
        
#line 1755 
        goto ldv_55451;
        default: 
#line 1755 
        ;
        
#line 1755 
        __bad_size_call_parameter();
        
#line 1755 
        goto ldv_55451;
      }
      ldv_55451: 
#line 1755 
      ;
      
#line 1755 
      tmp_6 = pscr_ret__;
    }
    
#line 1754 
    qindex = tmp_6;
  }
  
#line 1756 
  __retres = (unsigned short)((unsigned int)qindex & ((unsigned int)lio->linfo.num_txpciq + 65535U));
  
#line 1756 
  return __retres;
}


#line 1767  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static void liquidio_push_packet(u32 octeon_id, void *skbuff, u32 len, union octeon_rh *rh, void *param)
{
  struct skb_shared_hwtstamps *shhwtstamps;
  u64 ns;
  struct octeon_droq *tmp_0;
  
#line 1773 
  struct napi_struct *napi = (struct napi_struct *)param;
  
#line 1774 
  struct octeon_device *oct = lio_get_device(octeon_id);
  
#line 1775 
  struct sk_buff *skb = (struct sk_buff *)skbuff;
  
#line 1778 
  struct net_device *netdev = oct->props[(int)rh->r_dh.link].netdev;
  {
    
#line 1780 
    struct napi_struct const *__mptr = (struct napi_struct const *)param;
    
#line 1780 
    tmp_0 = (struct octeon_droq *)__mptr + 18446744073709551296U;
  }
  
#line 1780 
  struct octeon_droq *droq = tmp_0;
  
#line 1782 
  if (netdev != (struct net_device *)0) {
    int packet_was_received;
    int tmp_2;
    gro_result_t tmp_4;
    
#line 1784 
    struct lio *lio = netdev_priv((struct net_device const *)netdev);
    
#line 1787 
    tmp_2 = ifstate_check(lio,4);
    
#line 1787 
    if (tmp_2 == 0) {
      
#line 1788 
      recv_buffer_free((void *)skb);
      
#line 1789 
      droq->stats.rx_dropped += 1ULL;
      
#line 1790 
      goto return_label;
    }
    else ;
    
#line 1793 
    skb->dev = netdev;
    
#line 1795 
    if ((unsigned int)*((unsigned char *)(& rh->r_dh) + 0UL) != 0U) {
      int tmp_3;
      
#line 1799 
      tmp_3 = ifstate_check(lio,8);
      
#line 1799 
      if (tmp_3 != 0) {
        
#line 1804 
        memcpy((void *)(& ns),(void const *)skb->data,8UL);
        
#line 1805 
        shhwtstamps = skb_hwtstamps(skb);
        
#line 1806 
        shhwtstamps->hwtstamp = ns_to_ktime((unsigned long long)lio->ptp_adjust + ns);
      }
      else ;
      
#line 1809 
      skb_pull(skb,8U);
    }
    else ;
    
#line 1812 
    skb->protocol = eth_type_trans(skb,skb->dev);
    
#line 1814 
    if ((netdev->features & 17179869184ULL) != 0ULL && (unsigned int)*((unsigned char *)(& rh->r_dh) + 0UL) == 6U) 
      
#line 1817 
      skb->ip_summed = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U; else 
                                                                    
#line 1819 
                                                                    skb->ip_summed = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U;
    
#line 1821 
    tmp_4 = napi_gro_receive(napi,skb);
    
#line 1821 
    packet_was_received = tmp_4 != (unsigned int)GRO_DROP;
    
#line 1823 
    if (packet_was_received != 0) {
      
#line 1824 
      droq->stats.rx_bytes_received += (unsigned long long)len;
      
#line 1825 
      droq->stats.rx_pkts_received += 1ULL;
      
#line 1826 
      netdev->last_rx = jiffies;
    }
    else {
      
#line 1828 
      droq->stats.rx_dropped += 1ULL;
      
#line 1829 
      if ((lio->msg_enable & 64U) != 0U) 
#line 1829 
                                         netdev_info((struct net_device const *)lio->netdev,"droq:%d  error rx_dropped:%llu\n",droq->q_no,droq->stats.rx_dropped); else ;
    }
  }
  else 
#line 1835 
       recv_buffer_free((void *)skb);
  return_label: 
#line 1836 
                return;
}


#line 1845  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static void napi_schedule_wrapper(void *param)
{
  
#line 1847 
  struct napi_struct *napi = (struct napi_struct *)param;
  
#line 1849 
  napi_schedule(napi);
  
#line 1850 
  return;
}


#line 1856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static void liquidio_napi_drv_callback(void *arg)
{
  int tmp_3;
  
#line 1858 
  struct octeon_droq *droq = (struct octeon_droq *)arg;
  {
    int pscr_ret__;
    {
      
#line 1859 
      void const *__vpp_verify = (void const *)0;
      
#line 1859 
      void const *tmp = __vpp_verify;
    }
    
#line 1859 
    switch (4UL) {
      int tmp_0;
      int tmp_0_0;
      int tmp_1;
      int tmp_2;
      case (unsigned long)1: 
#line 1859 
      ;
      {
        int pfo_ret__;
        
#line 1859 
        switch (4UL) {
          case (unsigned long)1: 
#line 1859 
          ;
          
#line 1860 
          ldv_inline_asm();
          
#line 1859 
          goto ldv_55513;
          case (unsigned long)2: 
#line 1859 
          ;
          
#line 1860 
          ldv_inline_asm();
          
#line 1859 
          goto ldv_55513;
          case (unsigned long)4: 
#line 1859 
          ;
          
#line 1860 
          ldv_inline_asm();
          
#line 1859 
          goto ldv_55513;
          case (unsigned long)8: 
#line 1859 
          ;
          
#line 1860 
          ldv_inline_asm();
          
#line 1859 
          goto ldv_55513;
          default: 
#line 1859 
          ;
          
#line 1859 
          __bad_percpu_size();
        }
        ldv_55513: 
#line 1859 
        ;
        
#line 1859 
        tmp_0 = pfo_ret__;
      }
      
#line 1859 
      pscr_ret__ = tmp_0;
      
#line 1859 
      goto ldv_55519;
      case (unsigned long)2: 
#line 1859 
      ;
      {
        int pfo_ret___0;
        
#line 1859 
        switch (4UL) {
          case (unsigned long)1: 
#line 1859 
          ;
          
#line 1860 
          ldv_inline_asm();
          
#line 1859 
          goto ldv_55523;
          case (unsigned long)2: 
#line 1859 
          ;
          
#line 1860 
          ldv_inline_asm();
          
#line 1859 
          goto ldv_55523;
          case (unsigned long)4: 
#line 1859 
          ;
          
#line 1860 
          ldv_inline_asm();
          
#line 1859 
          goto ldv_55523;
          case (unsigned long)8: 
#line 1859 
          ;
          
#line 1860 
          ldv_inline_asm();
          
#line 1859 
          goto ldv_55523;
          default: 
#line 1859 
          ;
          
#line 1859 
          __bad_percpu_size();
        }
        ldv_55523: 
#line 1859 
        ;
        
#line 1859 
        tmp_0_0 = pfo_ret___0;
      }
      
#line 1859 
      pscr_ret__ = tmp_0_0;
      
#line 1859 
      goto ldv_55519;
      case (unsigned long)4: 
#line 1859 
      ;
      {
        int pfo_ret___1;
        
#line 1859 
        switch (4UL) {
          case (unsigned long)1: 
#line 1859 
          ;
          
#line 1860 
          ldv_inline_asm();
          
#line 1859 
          goto ldv_55532;
          case (unsigned long)2: 
#line 1859 
          ;
          
#line 1860 
          ldv_inline_asm();
          
#line 1859 
          goto ldv_55532;
          case (unsigned long)4: 
#line 1859 
          ;
          
#line 1860 
          ldv_inline_asm();
          
#line 1859 
          goto ldv_55532;
          case (unsigned long)8: 
#line 1859 
          ;
          
#line 1860 
          ldv_inline_asm();
          
#line 1859 
          goto ldv_55532;
          default: 
#line 1859 
          ;
          
#line 1859 
          __bad_percpu_size();
        }
        ldv_55532: 
#line 1859 
        ;
        
#line 1859 
        tmp_1 = pfo_ret___1;
      }
      
#line 1859 
      pscr_ret__ = tmp_1;
      
#line 1859 
      goto ldv_55519;
      case (unsigned long)8: 
#line 1859 
      ;
      {
        int pfo_ret___2;
        
#line 1859 
        switch (4UL) {
          case (unsigned long)1: 
#line 1859 
          ;
          
#line 1860 
          ldv_inline_asm();
          
#line 1859 
          goto ldv_55541;
          case (unsigned long)2: 
#line 1859 
          ;
          
#line 1860 
          ldv_inline_asm();
          
#line 1859 
          goto ldv_55541;
          case (unsigned long)4: 
#line 1859 
          ;
          
#line 1860 
          ldv_inline_asm();
          
#line 1859 
          goto ldv_55541;
          case (unsigned long)8: 
#line 1859 
          ;
          
#line 1860 
          ldv_inline_asm();
          
#line 1859 
          goto ldv_55541;
          default: 
#line 1859 
          ;
          
#line 1859 
          __bad_percpu_size();
        }
        ldv_55541: 
#line 1859 
        ;
        
#line 1859 
        tmp_2 = pfo_ret___2;
      }
      
#line 1859 
      pscr_ret__ = tmp_2;
      
#line 1859 
      goto ldv_55519;
      default: 
#line 1859 
      ;
      
#line 1859 
      __bad_size_call_parameter();
      
#line 1859 
      goto ldv_55519;
    }
    ldv_55519: 
#line 1859 
    ;
    
#line 1859 
    tmp_3 = pscr_ret__;
  }
  
#line 1859 
  int this_cpu = tmp_3;
  
#line 1861 
  if (droq->cpu_id == (unsigned int)this_cpu) 
#line 1862 
                                              napi_schedule(& droq->napi);
  else {
    
#line 1864 
    struct call_single_data *csd = & droq->csd;
    
#line 1866 
    csd->func = & napi_schedule_wrapper;
    
#line 1867 
    csd->info = (void *)(& droq->napi);
    
#line 1868 
    csd->flags = 0U;
    
#line 1870 
    smp_call_function_single_async((int)droq->cpu_id,csd);
  }
  
#line 1872 
  return;
}


#line 1879  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int liquidio_napi_do_rx(struct octeon_droq *droq, int budget)
{
  int __retres;
  int work_done;
  
#line 1882 
  struct lio *lio = netdev_priv((struct net_device const *)droq->napi.dev);
  
#line 1883 
  struct octeon_device *oct = lio->oct_dev;
  
#line 1885 
  work_done = octeon_process_droq_poll_cmd(oct,droq->q_no,2,(unsigned int)budget);
  
#line 1888 
  if (work_done < 0) {
    
#line 1889 
    if ((lio->msg_enable & 64U) != 0U) 
#line 1889 
                                       netdev_info((struct net_device const *)lio->netdev,"Receive work_done < 0, rxq:%d\n",droq->q_no); else ;
    
#line 1891 
    goto octnet_napi_finish;
  }
  else ;
  
#line 1894 
  if (work_done > budget) 
#line 1895 
                          dev_err((struct device const *)(& (oct->pci_dev)->dev),">>>> %s work_done: %d budget: %d\n","liquidio_napi_do_rx",work_done,budget); else ;
  
#line 1898 
  __retres = work_done;
  
#line 1898 
  goto return_label;
  octnet_napi_finish: 
#line 1900 
  ;
  
#line 1901 
  napi_complete(& droq->napi);
  
#line 1902 
  octeon_process_droq_poll_cmd(oct,droq->q_no,4,0U);
  
#line 1904 
  __retres = 0;
  return_label: 
#line 1904 
                return __retres;
}


#line 1912  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int liquidio_napi_poll(struct napi_struct *napi, int budget)
{
  int __retres;
  struct octeon_droq *droq;
  int work_done;
  struct octeon_droq *tmp;
  {
    
#line 1917 
    struct napi_struct const *__mptr = (struct napi_struct const *)napi;
    
#line 1917 
    tmp = (struct octeon_droq *)__mptr + 18446744073709551296U;
  }
  
#line 1917 
  droq = tmp;
  
#line 1919 
  work_done = liquidio_napi_do_rx(droq,budget);
  
#line 1921 
  if (work_done < budget) {
    
#line 1922 
    napi_complete(napi);
    
#line 1923 
    octeon_process_droq_poll_cmd(droq->oct_dev,droq->q_no,4,0U);
    
#line 1925 
    __retres = 0;
    
#line 1925 
    goto return_label;
  }
  else ;
  
#line 1928 
  __retres = work_done;
  return_label: 
#line 1928 
                return __retres;
}


#line 1940  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
__inline static int setup_io_queues(struct octeon_device *octeon_dev, struct net_device *net_device)
{
  int __retres;
  struct octeon_droq_ops droq_ops;
  int cpu_id;
  int cpu_id_modulus;
  struct octeon_droq *droq;
  struct napi_struct *napi;
  int q;
  int q_no;
  struct lio *lio;
  int num_tx_descs;
  struct octeon_config *tmp_1;
  struct octeon_config *tmp_2;
  struct octeon_config *tmp_3;
  struct netdev_queue *tmp_4;
  
#line 1943 
  int first_time = 1;
  
#line 1949 
  int retval = 0;
  
#line 1953 
  lio = (struct lio *)netdev_priv((struct net_device const *)net_device);
  
#line 1954 
  if (first_time != 0) {
    unsigned int tmp_0;
    
#line 1955 
    first_time = 0;
    
#line 1956 
    memset((void *)(& droq_ops),0,24UL);
    
#line 1958 
    droq_ops.fptr = & liquidio_push_packet;
    
#line 1960 
    droq_ops.poll_mode = 1U;
    
#line 1961 
    droq_ops.napi_fn = & liquidio_napi_drv_callback;
    
#line 1962 
    cpu_id = 0;
    
#line 1963 
    tmp_0 = cpumask_weight(cpu_present_mask);
    
#line 1963 
    cpu_id_modulus = (int)tmp_0;
  }
  else ;
  
#line 1967 
  q = 0;
  
#line 1967 
  goto ldv_55584;
  ldv_55583: 
#line 1968 
  ;
  
#line 1968 
  q_no = (int)lio->linfo.rxpciq[q];
  
#line 1974 
  tmp_1 = octeon_get_conf(octeon_dev);
  
#line 1971 
  tmp_2 = octeon_get_conf(octeon_dev);
  
#line 1970 
  ;
  
#line 1970 
  ;
  
#line 1970 
  retval = octeon_setup_droq(octeon_dev,q_no,(int)tmp_2->nic_if_cfg[lio->ifidx].num_rx_descs,(int)tmp_1->nic_if_cfg[lio->ifidx].rx_buf_size,(void *)0);
  
#line 1977 
  if (retval != 0) {
    
#line 1978 
    dev_err((struct device const *)(& (octeon_dev->pci_dev)->dev)," %s : Runtime DROQ(RxQ) creation failed.\n","setup_io_queues");
    
#line 1981 
    __retres = 1;
    
#line 1981 
    goto return_label;
  }
  else ;
  
#line 1984 
  droq = octeon_dev->droq[q_no];
  
#line 1985 
  napi = & droq->napi;
  
#line 1986 
  netif_napi_add(net_device,napi,& liquidio_napi_poll,64);
  
#line 1989 
  droq->cpu_id = (unsigned int)cpu_id;
  
#line 1990 
  cpu_id += 1;
  
#line 1991 
  if (cpu_id >= cpu_id_modulus) 
#line 1992 
                                cpu_id = 0; else ;
  
#line 1994 
  octeon_register_droq_ops(octeon_dev,(unsigned int)q_no,& droq_ops);
  
#line 1967 
  q += 1;
  ldv_55584: 
#line 1968 
  ;
  
#line 1967 
  if ((int)lio->linfo.num_rxpciq > q) 
#line 1969 
                                      goto ldv_55583; else 
#line 1972 
                                                           goto ldv_55585;
  ldv_55585: 
#line 1973 
  ;
  
#line 1998 
  q = 0;
  
#line 1998 
  goto ldv_55587;
  ldv_55586: 
#line 1999 
  ;
  
#line 1999 
  tmp_3 = octeon_get_conf(octeon_dev);
  
#line 1999 
  num_tx_descs = (int)tmp_3->nic_if_cfg[lio->ifidx].num_tx_descs;
  
#line 2004 
  tmp_4 = netdev_get_tx_queue((struct net_device const *)net_device,(unsigned int)q);
  
#line 2002 
  ;
  
#line 2002 
  ;
  
#line 2002 
  ;
  
#line 2002 
  retval = octeon_setup_iq(octeon_dev,(unsigned int)lio->linfo.txpciq[q],(unsigned int)num_tx_descs,(void *)tmp_4);
  
#line 2005 
  if (retval != 0) {
    
#line 2006 
    dev_err((struct device const *)(& (octeon_dev->pci_dev)->dev)," %s : Runtime IQ(TxQ) creation failed.\n","setup_io_queues");
    
#line 2009 
    __retres = 1;
    
#line 2009 
    goto return_label;
  }
  else ;
  
#line 1998 
  q += 1;
  ldv_55587: 
#line 1999 
  ;
  
#line 1998 
  if ((int)lio->linfo.num_txpciq > q) 
#line 2000 
                                      goto ldv_55586; else 
#line 2003 
                                                           goto ldv_55588;
  ldv_55588: 
#line 2004 
  ;
  
#line 2013 
  __retres = 0;
  return_label: 
#line 2013 
                return __retres;
}


#line 2020  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static void octnet_poll_check_txq_status(struct work_struct *work)
{
  int tmp;
  unsigned long tmp_0;
  
#line 2022 
  struct cavium_wk *wk = (struct cavium_wk *)work;
  
#line 2023 
  struct lio *lio = (struct lio *)wk->ctxptr;
  
#line 2025 
  tmp = ifstate_check(lio,4);
  
#line 2025 
  if (tmp == 0) 
#line 2026 
                goto return_label; else ;
  
#line 2028 
  check_txq_status(lio);
  
#line 2030 
  tmp_0 = msecs_to_jiffies(1U);
  
#line 2029 
  ;
  
#line 2029 
  ;
  
#line 2029 
  ldv_queue_delayed_work_98(lio->txq_status_wq.wq,& lio->txq_status_wq.wk.work,tmp_0);
  return_label: 
#line 2031 
                return;
}


#line 2037  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
__inline static void setup_tx_poll_fn(struct net_device *netdev)
{
  struct workqueue_struct *tmp_1;
  unsigned long tmp_2;
  
#line 2039 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 2040 
  struct octeon_device *oct = lio->oct_dev;
  {
    struct lock_class_key __key;
    char const *__lock_name;
    
#line 2042 
    __lock_name = "\"%s\"";
    
#line 2042 
    tmp_1 = __alloc_workqueue_key("%s",8U,1,& __key,__lock_name,(char *)"txq-status");
  }
  
#line 2042 
  lio->txq_status_wq.wq = tmp_1;
  
#line 2043 
  if (lio->txq_status_wq.wq == (struct workqueue_struct *)0) {
    
#line 2044 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"unable to create cavium txq status wq\n");
    
#line 2045 
    goto return_label;
  }
  else ;
  {
    struct lock_class_key __key_0;
    
#line 2047 
    __init_work(& lio->txq_status_wq.wk.work.work,0);
    
#line 2047 
    atomic_long_t __constr_expr_37 = {.counter = WORK_STRUCT_NO_POOL_0};
    
#line 2047 
    lio->txq_status_wq.wk.work.work.data = __constr_expr_37;
    
#line 2047 
    lockdep_init_map(& lio->txq_status_wq.wk.work.work.lockdep_map,"(&(&lio->txq_status_wq.wk.work)->work)",& __key_0,0);
    
#line 2047 
    INIT_LIST_HEAD(& lio->txq_status_wq.wk.work.work.entry);
    
#line 2047 
    lio->txq_status_wq.wk.work.work.func = & octnet_poll_check_txq_status;
  }
  {
    struct lock_class_key __key_1;
    
#line 2047 
    init_timer_key(& lio->txq_status_wq.wk.work.timer,2097152U,"(&(&lio->txq_status_wq.wk.work)->timer)",& __key_1);
  }
  
#line 2047 
  lio->txq_status_wq.wk.work.timer.function = & delayed_work_timer_fn;
  
#line 2047 
  lio->txq_status_wq.wk.work.timer.data = (unsigned long)(& lio->txq_status_wq.wk.work);
  
#line 2049 
  lio->txq_status_wq.wk.ctxptr = (void *)lio;
  
#line 2051 
  tmp_2 = msecs_to_jiffies(1U);
  
#line 2050 
  ;
  
#line 2050 
  ;
  
#line 2050 
  ldv_queue_delayed_work_99(lio->txq_status_wq.wq,& lio->txq_status_wq.wk.work,tmp_2);
  return_label: 
#line 2052 
                return;
}


#line 2058  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int liquidio_open(struct net_device *netdev)
{
  int __retres;
  struct napi_struct *napi;
  struct napi_struct *n;
  struct napi_struct *tmp_0;
  struct napi_struct *tmp_1;
  struct napi_struct *tmp_2;
  
#line 2060 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 2061 
  struct octeon_device *oct = lio->oct_dev;
  {
    
#line 2064 
    struct list_head const *__mptr = (struct list_head const *)netdev->napi_list.next;
    
#line 2064 
    tmp_0 = (struct napi_struct *)__mptr + 18446744073709551376U;
  }
  
#line 2064 
  napi = tmp_0;
  {
    
#line 2064 
    struct list_head const *__mptr_0 = (struct list_head const *)napi->dev_list.next;
    
#line 2064 
    tmp_1 = (struct napi_struct *)__mptr_0 + 18446744073709551376U;
  }
  
#line 2065 
  n = tmp_1;
  
#line 2064 
  goto ldv_55619;
  ldv_55618: 
#line 2065 
  ;
  
#line 2065 
  napi_enable(napi);
  
#line 2064 
  napi = n;
  {
    
#line 2064 
    struct list_head const *__mptr_1 = (struct list_head const *)n->dev_list.next;
    
#line 2064 
    tmp_2 = (struct napi_struct *)__mptr_1 + 18446744073709551376U;
  }
  
#line 2064 
  n = tmp_2;
  ldv_55619: 
#line 2066 
  ;
  
#line 2064 
  if (& napi->dev_list != & netdev->napi_list) 
#line 2066 
                                               goto ldv_55618; else 
#line 2069 
                                                                    goto ldv_55620;
  ldv_55620: 
#line 2070 
  ;
  
#line 2067 
  oct_ptp_open(netdev);
  
#line 2069 
  ifstate_set(lio,4);
  
#line 2070 
  setup_tx_poll_fn(netdev);
  
#line 2071 
  start_txq(netdev);
  
#line 2073 
  if ((lio->msg_enable & 32U) != 0U) 
#line 2073 
                                     netdev_info((struct net_device const *)lio->netdev,"Interface Open, ready for traffic\n"); else ;
  
#line 2074 
  try_module_get(& __this_module);
  
#line 2077 
  send_rx_ctrl_cmd(lio,1);
  
#line 2080 
  lio->intf_open = 1U;
  
#line 2082 
  _dev_info((struct device const *)(& (oct->pci_dev)->dev),"%s interface is opened\n",(char *)(& netdev->name));
  
#line 2085 
  __retres = 0;
  
#line 2085 
  return __retres;
}


#line 2092  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int liquidio_stop(struct net_device *netdev)
{
  int __retres;
  struct napi_struct *napi;
  struct napi_struct *n;
  struct napi_struct *tmp_0;
  struct napi_struct *tmp_1;
  struct napi_struct *tmp_2;
  
#line 2095 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 2096 
  struct octeon_device *oct = lio->oct_dev;
  
#line 2098 
  if ((lio->msg_enable & 16U) != 0U) 
#line 2098 
                                     netdev_info((struct net_device const *)lio->netdev,"Stopping interface!\n"); else ;
  
#line 2100 
  lio->intf_open = 0U;
  
#line 2101 
  lio->linfo.link.s.status = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U;
  
#line 2103 
  netif_carrier_off(netdev);
  
#line 2106 
  send_rx_ctrl_cmd(lio,0);
  
#line 2108 
  cancel_delayed_work_sync(& lio->txq_status_wq.wk.work);
  
#line 2109 
  flush_workqueue(lio->txq_status_wq.wq);
  
#line 2110 
  destroy_workqueue(lio->txq_status_wq.wq);
  
#line 2112 
  if (lio->ptp_clock != (struct ptp_clock *)0) {
    
#line 2113 
    ptp_clock_unregister(lio->ptp_clock);
    
#line 2114 
    lio->ptp_clock = (struct ptp_clock *)0;
  }
  else ;
  
#line 2117 
  ifstate_reset(lio,4);
  
#line 2120 
  set_bit(0L,(unsigned long volatile *)(& (lio->netdev)->state));
  {
    
#line 2122 
    struct list_head const *__mptr = (struct list_head const *)netdev->napi_list.next;
    
#line 2122 
    tmp_0 = (struct napi_struct *)__mptr + 18446744073709551376U;
  }
  
#line 2122 
  napi = tmp_0;
  {
    
#line 2122 
    struct list_head const *__mptr_0 = (struct list_head const *)napi->dev_list.next;
    
#line 2122 
    tmp_1 = (struct napi_struct *)__mptr_0 + 18446744073709551376U;
  }
  
#line 2123 
  n = tmp_1;
  
#line 2122 
  goto ldv_55635;
  ldv_55634: 
#line 2123 
  ;
  
#line 2123 
  napi_disable(napi);
  
#line 2122 
  napi = n;
  {
    
#line 2122 
    struct list_head const *__mptr_1 = (struct list_head const *)n->dev_list.next;
    
#line 2122 
    tmp_2 = (struct napi_struct *)__mptr_1 + 18446744073709551376U;
  }
  
#line 2122 
  n = tmp_2;
  ldv_55635: 
#line 2124 
  ;
  
#line 2122 
  if (& napi->dev_list != & netdev->napi_list) 
#line 2124 
                                               goto ldv_55634; else 
#line 2127 
                                                                    goto ldv_55636;
  ldv_55636: 
#line 2128 
  ;
  
#line 2125 
  txqs_stop(netdev);
  
#line 2127 
  _dev_info((struct device const *)(& (oct->pci_dev)->dev),"%s interface is stopped\n",(char *)(& netdev->name));
  
#line 2128 
  module_put(& __this_module);
  
#line 2130 
  __retres = 0;
  
#line 2130 
  return __retres;
}


#line 2133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
void liquidio_link_ctrl_cmd_completion(void *nctrl_ptr)
{
  
#line 2135 
  struct octnic_ctrl_pkt *nctrl = (struct octnic_ctrl_pkt *)nctrl_ptr;
  
#line 2136 
  struct net_device *netdev = (struct net_device *)nctrl->netpndev;
  
#line 2137 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 2138 
  struct octeon_device *oct = lio->oct_dev;
  
#line 2140 
  switch ((int)nctrl->ncmd.s.cmd) {
    case 3: 
#line 2141 
    ;
    case 5: 
#line 2142 
    ;
    
#line 2143 
    goto ldv_55646;
    case 2: 
#line 2145 
    ;
    
#line 2147 
    if ((lio->msg_enable & 2U) != 0U) 
#line 2147 
                                      netdev_info((struct net_device const *)lio->netdev," MACAddr changed to 0x%llx\n",(long long)nctrl->udd[0]); else ;
    
#line 2149 
    _dev_info((struct device const *)(& (oct->pci_dev)->dev),"%s MACAddr changed to 0x%llx\n",(char *)(& netdev->name),(long long)nctrl->udd[0]);
    
#line 2151 
    memcpy((void *)netdev->dev_addr,(void const *)(& nctrl->udd[0]) + 2U,6UL);
    
#line 2152 
    goto ldv_55646;
    case 1: 
#line 2154 
    ;
    
#line 2156 
    if ((lio->msg_enable & 2U) != 0U) 
#line 2156 
                                      netdev_info((struct net_device const *)lio->netdev," MTU Changed from %d to %d\n",netdev->mtu,(int)nctrl->ncmd.s.param2); else ;
    
#line 2158 
    _dev_info((struct device const *)(& (oct->pci_dev)->dev),"%s MTU Changed from %d to %d\n",(char *)(& netdev->name),netdev->mtu,(int)nctrl->ncmd.s.param2);
    
#line 2161 
    netdev->mtu = (unsigned int)nctrl->ncmd.s.param2;
    
#line 2162 
    goto ldv_55646;
    case 10: 
#line 2164 
    ;
    
#line 2165 
    if ((lio->msg_enable & 2U) != 0U) 
#line 2165 
                                      netdev_info((struct net_device const *)lio->netdev,"LED Flashing visual identification\n"); else ;
    
#line 2167 
    goto ldv_55646;
    case 11: 
#line 2169 
    ;
    
#line 2170 
    _dev_info((struct device const *)(& (oct->pci_dev)->dev),"%s LRO Enabled\n",(char *)(& netdev->name));
    
#line 2171 
    goto ldv_55646;
    case 12: 
#line 2173 
    ;
    
#line 2174 
    _dev_info((struct device const *)(& (oct->pci_dev)->dev),"%s LRO Disabled\n",(char *)(& netdev->name));
    
#line 2176 
    goto ldv_55646;
    case 20: 
#line 2178 
    ;
    
#line 2179 
    _dev_info((struct device const *)(& (oct->pci_dev)->dev),"%s LRO Enabled\n",(char *)(& netdev->name));
    
#line 2180 
    goto ldv_55646;
    case 21: 
#line 2182 
    ;
    
#line 2183 
    _dev_info((struct device const *)(& (oct->pci_dev)->dev),"%s LRO Disabled\n",(char *)(& netdev->name));
    
#line 2185 
    goto ldv_55646;
    case 7: 
#line 2187 
    ;
    
#line 2188 
    _dev_info((struct device const *)(& (oct->pci_dev)->dev),"%s settings changed\n",(char *)(& netdev->name));
    
#line 2191 
    goto ldv_55646;
    default: 
#line 2193 
    ;
    
#line 2194 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"%s Unknown cmd %d\n","liquidio_link_ctrl_cmd_completion",(int)nctrl->ncmd.s.cmd);
  }
  ldv_55646: 
#line 2197 
  ;
  
#line 2198 
  return;
}


#line 2206  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
__inline static enum octnet_ifflags get_new_flags(struct net_device *netdev)
{
  
#line 2208 
  enum octnet_ifflags f = OCTNET_IFFLAG_UNICAST;
  
#line 2210 
  if ((netdev->flags & 256U) != 0U) 
#line 2211 
                                    f = (enum octnet_ifflags)((unsigned int)f | 1U); else ;
  
#line 2213 
  if ((netdev->flags & 512U) != 0U) 
#line 2214 
                                    f = (enum octnet_ifflags)((unsigned int)f | 2U); else ;
  
#line 2216 
  if ((netdev->flags & 4096U) != 0U) {
    
#line 2217 
    f = (enum octnet_ifflags)((unsigned int)f | 4U);
    
#line 2222 
    if (netdev->mc.count > 32) 
#line 2223 
                               f = (enum octnet_ifflags)((unsigned int)f | 2U); else ;
  }
  else ;
  
#line 2226 
  if ((netdev->flags & 2U) != 0U) 
#line 2227 
                                  f = (enum octnet_ifflags)((unsigned int)f | 8U); else ;
  
#line 2229 
  return f;
}


#line 2236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static void liquidio_set_mcast_list(struct net_device *netdev)
{
  struct octnic_ctrl_pkt nctrl;
  struct octnic_ctrl_params nparams;
  struct netdev_hw_addr *ha;
  u64 *mc;
  int ret;
  int i;
  int tmp_1;
  enum octnet_ifflags tmp_2;
  struct netdev_hw_addr *tmp_3;
  struct netdev_hw_addr *tmp_4;
  
#line 2238 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 2239 
  struct octeon_device *oct = lio->oct_dev;
  {
    int tmp_0;
    
#line 2245 
    int _min1 = netdev->mc.count;
    
#line 2245 
    int _min2 = 32;
    
#line 2245 
    if (_min1 < _min2) 
#line 2245 
                       tmp_0 = _min1; else 
#line 2245 
                                           tmp_0 = _min2;
    
#line 2245 
    tmp_1 = tmp_0;
  }
  
#line 2245 
  int mc_count = tmp_1;
  
#line 2247 
  memset((void *)(& nctrl),0,320UL);
  
#line 2250 
  nctrl.ncmd.u64 = 0ULL;
  
#line 2251 
  nctrl.ncmd.s.cmd = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(5))))5U;
  
#line 2252 
  nctrl.ncmd.s.param1 = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(29))))lio->linfo.ifidx;
  
#line 2253 
  tmp_2 = get_new_flags(netdev);
  
#line 2253 
  nctrl.ncmd.s.param2 = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))((unsigned short)tmp_2);
  
#line 2254 
  nctrl.ncmd.s.param3 = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))((unsigned char)mc_count);
  
#line 2255 
  nctrl.ncmd.s.more = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))mc_count;
  
#line 2256 
  nctrl.netpndev = (unsigned long long)netdev;
  
#line 2257 
  nctrl.cb_fn = & liquidio_link_ctrl_cmd_completion;
  
#line 2260 
  i = 0;
  
#line 2261 
  mc = & nctrl.udd[0];
  {
    
#line 2262 
    struct list_head const *__mptr = (struct list_head const *)netdev->mc.list.next;
    
#line 2262 
    tmp_3 = (struct netdev_hw_addr *)__mptr;
  }
  
#line 2262 
  ha = tmp_3;
  
#line 2262 
  goto ldv_55682;
  ldv_55681: 
#line 2263 
  ;
  
#line 2263 
  *mc = 0ULL;
  
#line 2264 
  memcpy((void *)mc + 2U,(void const *)(& ha->addr),6UL);
  
#line 2267 
  mc += 1;
  
#line 2267 
  ;
  
#line 2267 
  if (mc > & nctrl.udd[mc_count]) 
#line 2268 
                                  goto ldv_55680; else ;
  {
    
#line 2262 
    struct list_head const *__mptr_0 = (struct list_head const *)ha->list.next;
    
#line 2262 
    tmp_4 = (struct netdev_hw_addr *)__mptr_0;
  }
  
#line 2262 
  ha = tmp_4;
  ldv_55682: 
#line 2264 
  ;
  
#line 2262 
  if (& ha->list != & netdev->mc.list) 
#line 2264 
                                       goto ldv_55681; else 
#line 2267 
                                                            goto ldv_55680;
  ldv_55680: 
#line 2268 
  ;
  
#line 2274 
  nctrl.wait_time = 0UL;
  
#line 2276 
  nparams.resp_order = 2U;
  
#line 2278 
  ret = octnet_send_nic_ctrl_pkt(lio->oct_dev,& nctrl,nparams);
  
#line 2279 
  if (ret < 0) 
#line 2280 
               dev_err((struct device const *)(& (oct->pci_dev)->dev),"DEVFLAGS change failed in core (ret: 0x%x)\n",ret); else ;
  
#line 2281 
  return;
}


#line 2289  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int liquidio_set_mac(struct net_device *netdev, void *p)
{
  int __retres;
  struct octnic_ctrl_pkt nctrl;
  struct octnic_ctrl_params nparams;
  int tmp_1;
  bool tmp_0;
  
#line 2291 
  int ret = 0;
  
#line 2292 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 2293 
  struct octeon_device *oct = lio->oct_dev;
  
#line 2294 
  struct sockaddr *addr = (struct sockaddr *)p;
  
#line 2298 
  tmp_0 = is_valid_ether_addr((u8 const *)(& addr->sa_data));
  
#line 2298 
  if (tmp_0) 
#line 2298 
             tmp_1 = 0; else 
#line 2298 
                             tmp_1 = 1;
  
#line 2298 
  if (tmp_1) {
    
#line 2300 
    __retres = -99;
    
#line 2300 
    goto return_label;
  }
  else {
    int tmp_2;
    
#line 2298 
    tmp_2 = ifstate_check(lio,4);
    
#line 2298 
    if (tmp_2 != 0) {
      
#line 2300 
      __retres = -99;
      
#line 2300 
      goto return_label;
    }
    else ;
  }
  
#line 2302 
  memset((void *)(& nctrl),0,320UL);
  
#line 2304 
  nctrl.ncmd.u64 = 0ULL;
  
#line 2305 
  nctrl.ncmd.s.cmd = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(5))))2U;
  
#line 2306 
  nctrl.ncmd.s.param1 = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(29))))lio->linfo.ifidx;
  
#line 2307 
  nctrl.ncmd.s.param2 = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))0U;
  
#line 2308 
  nctrl.ncmd.s.more = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))1U;
  
#line 2309 
  nctrl.netpndev = (unsigned long long)netdev;
  
#line 2310 
  nctrl.cb_fn = & liquidio_link_ctrl_cmd_completion;
  
#line 2311 
  nctrl.wait_time = 100UL;
  
#line 2313 
  nctrl.udd[0] = 0ULL;
  
#line 2315 
  memcpy((void *)(& nctrl.udd[0]) + 2U,(void const *)(& addr->sa_data),6UL);
  
#line 2317 
  nparams.resp_order = 0U;
  
#line 2319 
  ret = octnet_send_nic_ctrl_pkt(lio->oct_dev,& nctrl,nparams);
  
#line 2320 
  if (ret < 0) {
    
#line 2321 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"MAC Address change failed\n");
    
#line 2322 
    __retres = -12;
    
#line 2322 
    goto return_label;
  }
  else ;
  
#line 2324 
  memcpy((void *)netdev->dev_addr,(void const *)(& addr->sa_data),(unsigned long)netdev->addr_len);
  
#line 2325 
  memcpy((void *)(& lio->linfo.hw_addr) + 2U,(void const *)(& addr->sa_data),6UL);
  
#line 2327 
  __retres = 0;
  return_label: 
#line 2327 
                return __retres;
}


#line 2334  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static struct net_device_stats *liquidio_get_stats(struct net_device *netdev)
{
  struct octeon_device *oct;
  struct oct_droq_stats *oq_stats;
  struct oct_iq_stats *iq_stats;
  int i;
  int iq_no;
  int oq_no;
  
#line 2336 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 2337 
  struct net_device_stats *stats = & netdev->stats;
  
#line 2339 
  u64 pkts = 0ULL;
  
#line 2339 
  u64 drop = 0ULL;
  
#line 2339 
  u64 bytes = 0ULL;
  
#line 2344 
  oct = lio->oct_dev;
  
#line 2346 
  i = 0;
  
#line 2346 
  goto ldv_55708;
  ldv_55707: 
#line 2347 
  ;
  
#line 2347 
  iq_no = (int)lio->linfo.txpciq[i];
  
#line 2348 
  iq_stats = & (oct->instr_queue[iq_no])->stats;
  
#line 2349 
  pkts = iq_stats->tx_done + pkts;
  
#line 2350 
  drop = iq_stats->tx_dropped + drop;
  
#line 2351 
  bytes = iq_stats->tx_tot_bytes + bytes;
  
#line 2346 
  i += 1;
  ldv_55708: 
#line 2347 
  ;
  
#line 2346 
  if ((int)lio->linfo.num_txpciq > i) 
#line 2348 
                                      goto ldv_55707; else 
#line 2351 
                                                           goto ldv_55709;
  ldv_55709: 
#line 2352 
  ;
  
#line 2354 
  stats->tx_packets = (unsigned long)pkts;
  
#line 2355 
  stats->tx_bytes = (unsigned long)bytes;
  
#line 2356 
  stats->tx_dropped = (unsigned long)drop;
  
#line 2358 
  pkts = 0ULL;
  
#line 2359 
  drop = 0ULL;
  
#line 2360 
  bytes = 0ULL;
  
#line 2362 
  i = 0;
  
#line 2362 
  goto ldv_55711;
  ldv_55710: 
#line 2363 
  ;
  
#line 2363 
  oq_no = (int)lio->linfo.rxpciq[i];
  
#line 2364 
  oq_stats = & (oct->droq[oq_no])->stats;
  
#line 2365 
  pkts = oq_stats->rx_pkts_received + pkts;
  
#line 2366 
  drop = (((oq_stats->rx_dropped + oq_stats->dropped_nodispatch) + oq_stats->dropped_toomany) + oq_stats->dropped_nomem) + drop;
  
#line 2370 
  bytes = oq_stats->rx_bytes_received + bytes;
  
#line 2362 
  i += 1;
  ldv_55711: 
#line 2363 
  ;
  
#line 2362 
  if ((int)lio->linfo.num_rxpciq > i) 
#line 2364 
                                      goto ldv_55710; else 
#line 2367 
                                                           goto ldv_55712;
  ldv_55712: 
#line 2368 
  ;
  
#line 2373 
  stats->rx_bytes = (unsigned long)bytes;
  
#line 2374 
  stats->rx_packets = (unsigned long)pkts;
  
#line 2375 
  stats->rx_dropped = (unsigned long)drop;
  
#line 2377 
  return stats;
}


#line 2384  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int liquidio_change_mtu(struct net_device *netdev, int new_mtu)
{
  int __retres;
  struct octnic_ctrl_pkt nctrl;
  struct octnic_ctrl_params nparams;
  
#line 2386 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 2387 
  struct octeon_device *oct = lio->oct_dev;
  
#line 2390 
  int max_frm_size = new_mtu + 30;
  
#line 2391 
  int ret = 0;
  
#line 2396 
  if ((unsigned int)max_frm_size + 4294967224U > 15958U) {
    
#line 2398 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Invalid MTU: %d\n",new_mtu);
    
#line 2399 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Valid range %d and %d\n",42,16000);
    
#line 2402 
    __retres = -22;
    
#line 2402 
    goto return_label;
  }
  else ;
  
#line 2405 
  memset((void *)(& nctrl),0,320UL);
  
#line 2407 
  nctrl.ncmd.u64 = 0ULL;
  
#line 2408 
  nctrl.ncmd.s.cmd = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(5))))1U;
  
#line 2409 
  nctrl.ncmd.s.param1 = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(29))))lio->linfo.ifidx;
  
#line 2410 
  nctrl.ncmd.s.param2 = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))((unsigned short)new_mtu);
  
#line 2411 
  nctrl.wait_time = 100UL;
  
#line 2412 
  nctrl.netpndev = (unsigned long long)netdev;
  
#line 2413 
  nctrl.cb_fn = & liquidio_link_ctrl_cmd_completion;
  
#line 2415 
  nparams.resp_order = 0U;
  
#line 2417 
  ret = octnet_send_nic_ctrl_pkt(lio->oct_dev,& nctrl,nparams);
  
#line 2418 
  if (ret < 0) {
    
#line 2419 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Failed to set MTU\n");
    
#line 2420 
    __retres = -1;
    
#line 2420 
    goto return_label;
  }
  else ;
  
#line 2423 
  lio->mtu = (unsigned int)new_mtu;
  
#line 2425 
  __retres = 0;
  return_label: 
#line 2425 
                return __retres;
}


#line 2434  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int hwtstamp_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
{
  int __retres;
  struct hwtstamp_config conf;
  unsigned long tmp_0;
  int tmp_2;
  unsigned long tmp_1;
  
#line 2437 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 2439 
  tmp_0 = copy_from_user((void *)(& conf),(void const *)ifr->ifr_ifru.ifru_data,12UL);
  
#line 2439 
  if (tmp_0 != 0UL) {
    
#line 2440 
    __retres = -14;
    
#line 2440 
    goto return_label;
  }
  else ;
  
#line 2442 
  if (conf.flags != 0) {
    
#line 2443 
    __retres = -22;
    
#line 2443 
    goto return_label;
  }
  else ;
  
#line 2445 
  switch (conf.tx_type) {
    case 1: 
#line 2446 
    ;
    case 0: 
#line 2447 
    ;
    
#line 2448 
    goto ldv_55732;
    default: 
#line 2449 
    ;
    
#line 2450 
    __retres = -34;
    
#line 2450 
    goto return_label;
  }
  ldv_55732: 
#line 2453 
  ;
  
#line 2453 
  switch (conf.rx_filter) {
    case 0: 
#line 2454 
    ;
    
#line 2455 
    goto ldv_55735;
    case 1: 
#line 2456 
    ;
    case 2: 
#line 2457 
    ;
    case 3: 
#line 2458 
    ;
    case 4: 
#line 2459 
    ;
    case 5: 
#line 2460 
    ;
    case 6: 
#line 2461 
    ;
    case 7: 
#line 2462 
    ;
    case 8: 
#line 2463 
    ;
    case 9: 
#line 2464 
    ;
    case 10: 
#line 2465 
    ;
    case 11: 
#line 2466 
    ;
    case 12: 
#line 2467 
    ;
    case 13: 
#line 2468 
    ;
    case 14: 
#line 2469 
    ;
    
#line 2470 
    conf.rx_filter = 1;
    
#line 2471 
    goto ldv_55735;
    default: 
#line 2472 
    ;
    
#line 2473 
    __retres = -34;
    
#line 2473 
    goto return_label;
  }
  ldv_55735: 
#line 2476 
  ;
  
#line 2476 
  if (conf.rx_filter == 1) 
#line 2477 
                           ifstate_set(lio,8); else 
#line 2480 
                                                    ifstate_reset(lio,8);
  
#line 2482 
  tmp_1 = copy_to_user(ifr->ifr_ifru.ifru_data,(void const *)(& conf),12UL);
  
#line 2482 
  if (tmp_1 != 0UL) 
#line 2482 
                    tmp_2 = -14; else 
#line 2482 
                                      tmp_2 = 0;
  
#line 2482 
  __retres = tmp_2;
  return_label: 
#line 2482 
                return __retres;
}


#line 2491  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int liquidio_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
{
  int __retres;
  
#line 2493 
  switch (cmd) {
    int tmp;
    case 35248: 
#line 2494 
    ;
    
#line 2495 
    tmp = hwtstamp_ioctl(netdev,ifr,cmd);
    
#line 2495 
    __retres = tmp;
    
#line 2495 
    goto return_label;
    default: 
#line 2496 
    ;
    
#line 2497 
    __retres = -95;
    
#line 2497 
    goto return_label;
  }
  return_label: 
#line 2493 
                return __retres;
}


#line 2506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static void handle_timestamp(struct octeon_device *oct, u32 status, void *buf)
{
  struct octnet_buf_free_info *finfo;
  struct octeon_soft_command *sc;
  struct oct_timestamp_resp *resp;
  struct lio *lio;
  unsigned char *tmp;
  
#line 2514 
  struct sk_buff *skb = (struct sk_buff *)buf;
  
#line 2516 
  finfo = (struct octnet_buf_free_info *)(& skb->cb);
  
#line 2517 
  lio = finfo->lio;
  
#line 2518 
  sc = finfo->sc;
  
#line 2519 
  oct = lio->oct_dev;
  
#line 2520 
  resp = (struct oct_timestamp_resp *)sc->virtrptr;
  
#line 2522 
  if (status != 0U) {
    
#line 2523 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Tx timestamp instruction failed. Status: %llx\n",(long long)status);
    
#line 2525 
    resp->timestamp = 0ULL;
  }
  else ;
  
#line 2528 
  octeon_swap_8B_data_2(& resp->timestamp,1U);
  
#line 2530 
  tmp = skb_end_pointer((struct sk_buff const *)skb);
  
#line 2530 
  if (1L != 0L) {
    struct skb_shared_hwtstamps ts;
    
#line 2532 
    u64 ns = resp->timestamp;
    
#line 2534 
    if ((lio->msg_enable & 1024U) != 0U) 
#line 2534 
                                         netdev_info((struct net_device const *)lio->netdev,"Got resulting SKBTX_HW_TSTAMP skb=%p ns=%016llu\n",skb,ns); else ;
    
#line 2537 
    ts.hwtstamp = ns_to_ktime((unsigned long long)lio->ptp_adjust + ns);
    
#line 2538 
    skb_tstamp_tx(skb,& ts);
  }
  else ;
  
#line 2541 
  octeon_free_soft_command(oct,sc);
  
#line 2542 
  recv_buffer_free((void *)skb);
  
#line 2543 
  return;
}


#line 2550  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
__inline static int send_nic_timestamp_pkt(struct octeon_device *oct, struct octnic_data_pkt *ndata, struct octnet_buf_free_info *finfo, int xmit_more)
{
  int __retres;
  int retval;
  struct octeon_soft_command *sc;
  struct octeon_instr_ih *ih;
  struct octeon_instr_rdp *rdp;
  struct lio *lio;
  int ring_doorbell_0;
  
#line 2562 
  lio = finfo->lio;
  
#line 2564 
  sc = (struct octeon_soft_command *)octeon_alloc_soft_command_resp(oct,& ndata->cmd,24UL);
  
#line 2566 
  finfo->sc = sc;
  
#line 2568 
  if (sc == (struct octeon_soft_command *)0) {
    
#line 2569 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"No memory for timestamped data packet\n");
    
#line 2570 
    __retres = -1;
    
#line 2570 
    goto return_label;
  }
  else ;
  
#line 2573 
  if (ndata->reqtype == 1U) 
#line 2574 
                            ndata->reqtype = 3U;
  else 
    
#line 2575 
    if (ndata->reqtype == 2U) 
#line 2576 
                              ndata->reqtype = 4U; else ;
  
#line 2578 
  sc->callback = & handle_timestamp;
  
#line 2579 
  sc->callback_arg = (void *)finfo->skb;
  
#line 2580 
  sc->iq_no = ndata->q_no;
  
#line 2582 
  ih = (struct octeon_instr_ih *)(& sc->cmd.ih);
  
#line 2583 
  rdp = (struct octeon_instr_rdp *)(& sc->cmd.rdp);
  
#line 2585 
  ring_doorbell_0 = xmit_more == 0;
  
#line 2586 
  retval = octeon_send_command(oct,sc->iq_no,(unsigned int)ring_doorbell_0,(void *)(& sc->cmd),(void *)sc,(unsigned int)ih->dlengsz,ndata->reqtype);
  
#line 2589 
  if (retval != 0) {
    
#line 2590 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"timestamp data packet failed status: %x\n",retval);
    
#line 2592 
    octeon_free_soft_command(oct,sc);
  }
  else 
    
#line 2594 
    if ((lio->msg_enable & 256U) != 0U) 
#line 2594 
                                        netdev_info((struct net_device const *)lio->netdev,"Queued timestamp packet\n"); else ;
  
#line 2597 
  __retres = retval;
  return_label: 
#line 2597 
                return __retres;
}


#line 2600  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
__inline static int is_ipv4(struct sk_buff *skb)
{
  int tmp_0;
  
#line 2602 
  if ((unsigned int)skb->protocol == 8U) {
    struct iphdr *tmp;
    
#line 2603 
    tmp = ip_hdr((struct sk_buff const *)skb);
    
#line 2602 
    ;
    
#line 2602 
    if ((unsigned int)*((unsigned char *)tmp + 0UL) == 64U) 
#line 2602 
                                                            tmp_0 = 1; else 
                                                                    
#line 2602 
                                                                    tmp_0 = 0;
  }
  else 
#line 2602 
       tmp_0 = 0;
  
#line 2602 
  return tmp_0;
}


#line 2606  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
__inline static int is_vlan(struct sk_buff *skb)
{
  int __retres;
  
#line 2608 
  __retres = (unsigned int)skb->protocol == 129U;
  
#line 2608 
  return __retres;
}


#line 2611  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
__inline static int is_ip_fragmented(struct sk_buff *skb)
{
  int __retres;
  struct iphdr *tmp;
  
#line 2619 
  tmp = ip_hdr((struct sk_buff const *)skb);
  
#line 2619 
  ;
  
#line 2619 
  __retres = ((int)tmp->frag_off & 65343) != 0;
  
#line 2619 
  return __retres;
}


#line 2622  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
__inline static int is_ipv6(struct sk_buff *skb)
{
  int tmp_0;
  
#line 2624 
  if ((unsigned int)skb->protocol == 56710U) {
    struct ipv6hdr *tmp;
    
#line 2625 
    tmp = ipv6_hdr((struct sk_buff const *)skb);
    
#line 2624 
    ;
    
#line 2624 
    if ((unsigned int)*((unsigned char *)tmp + 0UL) == 96U) 
#line 2624 
                                                            tmp_0 = 1; else 
                                                                    
#line 2624 
                                                                    tmp_0 = 0;
  }
  else 
#line 2624 
       tmp_0 = 0;
  
#line 2624 
  return tmp_0;
}


#line 2628  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
__inline static int is_with_extn_hdr(struct sk_buff *skb)
{
  int tmp_1;
  struct ipv6hdr *tmp;
  
#line 2630 
  tmp = ipv6_hdr((struct sk_buff const *)skb);
  
#line 2630 
  ;
  
#line 2630 
  if ((unsigned int)tmp->nexthdr != 6U) {
    struct ipv6hdr *tmp_0;
    
#line 2631 
    tmp_0 = ipv6_hdr((struct sk_buff const *)skb);
    
#line 2630 
    ;
    
#line 2630 
    if ((unsigned int)tmp_0->nexthdr != 17U) 
#line 2630 
                                             tmp_1 = 1; else 
#line 2630 
                                                             tmp_1 = 0;
  }
  else 
#line 2630 
       tmp_1 = 0;
  
#line 2630 
  return tmp_1;
}


#line 2634  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
__inline static int is_tcpudp(struct sk_buff *skb)
{
  int tmp_1;
  struct iphdr *tmp;
  
#line 2636 
  tmp = ip_hdr((struct sk_buff const *)skb);
  
#line 2636 
  ;
  
#line 2636 
  if ((unsigned int)tmp->protocol == 6U) 
#line 2636 
                                         tmp_1 = 1;
  else {
    struct iphdr *tmp_0;
    
#line 2637 
    tmp_0 = ip_hdr((struct sk_buff const *)skb);
    
#line 2636 
    ;
    
#line 2636 
    if ((unsigned int)tmp_0->protocol == 17U) 
#line 2636 
                                              tmp_1 = 1; else 
#line 2636 
                                                              tmp_1 = 0;
  }
  
#line 2636 
  return tmp_1;
}


#line 2640  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
__inline static u32 get_ipv4_5tuple_tag(struct sk_buff *skb)
{
  u32 tag;
  unsigned char *tmp_0;
  
#line 2643 
  struct iphdr *iphdr = ip_hdr((struct sk_buff const *)skb);
  
#line 2645 
  tag = crc32_le(0U,(unsigned char const *)(& iphdr->protocol),1UL);
  
#line 2646 
  tag = crc32_le(tag,(unsigned char const *)(& iphdr->saddr),8UL);
  
#line 2647 
  tmp_0 = skb_transport_header((struct sk_buff const *)skb);
  
#line 2647 
  tag = crc32_le(tag,(unsigned char const *)tmp_0,4UL);
  
#line 2648 
  return tag;
}


#line 2651  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
__inline static u32 get_ipv6_5tuple_tag(struct sk_buff *skb)
{
  u32 tag;
  unsigned char *tmp_0;
  
#line 2654 
  struct ipv6hdr *ipv6hdr = ipv6_hdr((struct sk_buff const *)skb);
  
#line 2656 
  tag = crc32_le(0U,(unsigned char const *)(& ipv6hdr->nexthdr),1UL);
  
#line 2657 
  tag = crc32_le(tag,(unsigned char const *)(& ipv6hdr->saddr),32UL);
  
#line 2658 
  tmp_0 = skb_transport_header((struct sk_buff const *)skb);
  
#line 2658 
  tag = crc32_le(tag,(unsigned char const *)tmp_0,4UL);
  
#line 2659 
  return tag;
}


#line 2668  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int liquidio_xmit(struct sk_buff *skb, struct net_device *netdev)
{
  int __retres;
  struct lio *lio;
  struct octnet_buf_free_info *finfo;
  union octnic_cmd_setup cmdsetup;
  struct octnic_data_pkt ndata;
  struct octeon_device *oct;
  struct oct_iq_stats *stats;
  int xmit_more;
  bool tmp_0;
  int tmp_1;
  bool tmp_4;
  unsigned char *tmp_20;
  unsigned char *tmp_29;
  unsigned char *tmp_32;
  
#line 2676 
  int cpu = 0;
  
#line 2676 
  int status = 0;
  
#line 2677 
  int q_idx = 0;
  
#line 2677 
  int iq_no = 0;
  
#line 2679 
  u32 tag = 0U;
  
#line 2681 
  lio = (struct lio *)netdev_priv((struct net_device const *)netdev);
  
#line 2682 
  oct = lio->oct_dev;
  
#line 2684 
  tmp_0 = netif_is_multiqueue((struct net_device const *)netdev);
  
#line 2684 
  if ((int)tmp_0 != 0) {
    
#line 2685 
    cpu = (int)skb->queue_mapping;
    
#line 2686 
    q_idx = ((int)lio->linfo.num_txpciq + -1) & cpu;
    
#line 2687 
    iq_no = (int)lio->linfo.txpciq[q_idx];
  }
  else 
#line 2689 
       iq_no = lio->txq;
  
#line 2692 
  stats = & (oct->instr_queue[iq_no])->stats;
  
#line 2697 
  tmp_1 = atomic_read((atomic_t const *)(& lio->ifstate));
  
#line 2697 
  if ((tmp_1 & 4) == 0) 
#line 2697 
                        goto _LOR;
  else 
    
#line 2697 
    if ((unsigned int)lio->linfo.link.s.status == 0U) 
#line 2697 
                                                      goto _LOR;
    else 
      
#line 2698 
      if (skb->len == 0U) {
        _LOR: {
                
#line 2700 
                if ((lio->msg_enable & 128U) != 0U) 
#line 2700 
                                                    netdev_info((struct net_device const *)lio->netdev,"Transmit failed link_status : %d\n",(int)lio->linfo.link.s.status); else ;
                
#line 2703 
                goto lio_xmit_failed;
              }
      }
      else ;
  
#line 2709 
  finfo = (struct octnet_buf_free_info *)(& skb->cb);
  
#line 2710 
  finfo->lio = lio;
  
#line 2711 
  finfo->skb = skb;
  
#line 2712 
  finfo->sc = (struct octeon_soft_command *)0;
  
#line 2715 
  memset((void *)(& ndata),0,88UL);
  
#line 2717 
  ndata.buf = (void *)finfo;
  
#line 2719 
  ndata.q_no = (unsigned int)iq_no;
  
#line 2721 
  tmp_4 = netif_is_multiqueue((struct net_device const *)netdev);
  
#line 2721 
  if ((int)tmp_4 != 0) {
    int tmp_2;
    
#line 2722 
    tmp_2 = octnet_iq_is_full(oct,ndata.q_no);
    
#line 2722 
    if (tmp_2 != 0) {
      
#line 2724 
      if ((lio->msg_enable & 128U) != 0U) 
#line 2724 
                                          netdev_info((struct net_device const *)lio->netdev,"Transmit failed iq:%d full\n",ndata.q_no); else ;
      
#line 2726 
      stats->tx_iq_busy += 1ULL;
      
#line 2727 
      __retres = 16;
      
#line 2727 
      goto return_label;
    }
    else ;
  }
  else {
    int tmp_3;
    
#line 2730 
    tmp_3 = octnet_iq_is_full(oct,(unsigned int)lio->txq);
    
#line 2730 
    if (tmp_3 != 0) {
      
#line 2732 
      stats->tx_iq_busy += 1ULL;
      
#line 2733 
      if ((lio->msg_enable & 128U) != 0U) 
#line 2733 
                                          netdev_info((struct net_device const *)lio->netdev,"Transmit failed iq:%d full\n",ndata.q_no); else ;
      
#line 2735 
      __retres = 16;
      
#line 2735 
      goto return_label;
    }
    else ;
  }
  
#line 2742 
  ndata.datasize = skb->len;
  
#line 2744 
  cmdsetup.u64 = 0ULL;
  
#line 2745 
  cmdsetup.s.ifidx = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))lio->linfo.ifidx;
  
#line 2747 
  if ((unsigned int)*((unsigned char *)skb + 145UL) == 6U) {
    int tmp_15;
    
#line 2748 
    tmp_15 = is_ipv4(skb);
    
#line 2748 
    if (tmp_15 != 0) {
      int tmp_16;
      
#line 2748 
      tmp_16 = is_ip_fragmented(skb);
      
#line 2748 
      if (tmp_16 == 0) {
        int tmp_17;
        
#line 2748 
        tmp_17 = is_tcpudp(skb);
        
#line 2748 
        if (tmp_17 != 0) {
          struct iphdr *tmp_5;
          
#line 2749 
          tag = get_ipv4_5tuple_tag(skb);
          
#line 2751 
          cmdsetup.s.cksum_offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(7))))15U;
          
#line 2753 
          tmp_5 = ip_hdr((struct sk_buff const *)skb);
          
#line 2753 
          ;
          
#line 2753 
          if ((unsigned int)tmp_5->ihl > 5U) 
#line 2754 
                                             cmdsetup.s.ipv4opts_ipv6exthdr = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U; else ;
        }
        else 
#line 2748 
             goto _LAND_2;
      }
      else 
#line 2748 
           goto _LAND_2;
    }
    else {
      int tmp_14;
      _LAND_2: 
#line 2757 
      tmp_14 = is_ipv6(skb);
      
#line 2757 
      if (tmp_14 != 0) {
        int tmp_6;
        
#line 2758 
        tag = get_ipv6_5tuple_tag(skb);
        
#line 2760 
        cmdsetup.s.cksum_offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(7))))15U;
        
#line 2762 
        tmp_6 = is_with_extn_hdr(skb);
        
#line 2762 
        if (tmp_6 != 0) 
#line 2763 
                        cmdsetup.s.ipv4opts_ipv6exthdr = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U; else ;
      }
      else {
        int tmp_13;
        
#line 2766 
        tmp_13 = is_vlan(skb);
        
#line 2766 
        if (tmp_13 != 0) {
          struct vlan_ethhdr *tmp_10;
          
#line 2767 
          tmp_10 = vlan_eth_hdr((struct sk_buff const *)skb);
          
#line 2767 
          ;
          
#line 2767 
          if ((unsigned int)tmp_10->h_vlan_encapsulated_proto == 8U) {
            int tmp_11;
            
#line 2768 
            tmp_11 = is_ip_fragmented(skb);
            
#line 2768 
            if (tmp_11 == 0) {
              int tmp_12;
              
#line 2769 
              tmp_12 = is_tcpudp(skb);
              
#line 2769 
              if (tmp_12 != 0) {
                struct iphdr *tmp_7;
                
#line 2770 
                tag = get_ipv4_5tuple_tag(skb);
                
#line 2772 
                cmdsetup.s.cksum_offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(7))))19U;
                
#line 2775 
                tmp_7 = ip_hdr((struct sk_buff const *)skb);
                
#line 2775 
                ;
                
#line 2775 
                if ((unsigned int)tmp_7->ihl > 5U) 
#line 2776 
                                                   cmdsetup.s.ipv4opts_ipv6exthdr = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U; else ;
              }
              else 
#line 2767 
                   goto _LAND_0;
            }
            else 
#line 2767 
                 goto _LAND_0;
          }
          else {
            struct vlan_ethhdr *tmp_9;
            _LAND_0: { /* sequence */
                       
#line 2779 
                       tmp_9 = vlan_eth_hdr((struct sk_buff const *)skb);
                       
#line 2779 
                       ;
                     }
            
#line 2779 
            if ((unsigned int)tmp_9->h_vlan_encapsulated_proto == 56710U) {
              int tmp_8;
              
#line 2781 
              tag = get_ipv6_5tuple_tag(skb);
              
#line 2783 
              cmdsetup.s.cksum_offset = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(7))))19U;
              
#line 2786 
              tmp_8 = is_with_extn_hdr(skb);
              
#line 2786 
              if (tmp_8 != 0) 
#line 2787 
                              cmdsetup.s.ipv4opts_ipv6exthdr = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U; else ;
            }
            else ;
          }
        }
        else ;
      }
    }
  }
  else ;
  
#line 2792 
  tmp_20 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 2792 
  ;
  
#line 2792 
  if ((long)(((int)((struct skb_shared_info *)tmp_20)->tx_flags & 1) != 0) != 0L) {
    unsigned char *tmp_18;
    unsigned char *tmp_19;
    
#line 2793 
    tmp_18 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 2793 
    tmp_19 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 2793 
    ((struct skb_shared_info *)tmp_18)->tx_flags = (unsigned char)((unsigned int)((struct skb_shared_info *)tmp_19)->tx_flags | 4U);
    
#line 2794 
    cmdsetup.s.timestamp = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U;
  }
  else ;
  
#line 2797 
  tmp_29 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 2797 
  ;
  
#line 2797 
  if ((unsigned int)((struct skb_shared_info *)tmp_29)->nr_frags == 0U) {
    int tmp_21;
    
#line 2798 
    cmdsetup.s.u.datasize = skb->len;
    
#line 2799 
    octnet_prepare_pci_cmd(& ndata.cmd,& cmdsetup,tag);
    
#line 2801 
    ndata.cmd.dptr = dma_map_single_attrs(& (oct->pci_dev)->dev,(void *)skb->data,(unsigned long)skb->len,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
    
#line 2805 
    tmp_21 = dma_mapping_error(& (oct->pci_dev)->dev,ndata.cmd.dptr);
    
#line 2805 
    if (tmp_21 != 0) {
      
#line 2806 
      dev_err((struct device const *)(& (oct->pci_dev)->dev),"%s DMA mapping error 1\n","liquidio_xmit");
      
#line 2808 
      __retres = 16;
      
#line 2808 
      goto return_label;
    }
    else ;
    
#line 2811 
    finfo->dptr = ndata.cmd.dptr;
    
#line 2813 
    ndata.reqtype = 1U;
  }
  else {
    int i;
    int frags;
    struct skb_frag_struct *frag;
    struct octnic_gather *g;
    unsigned char *tmp_23;
    int tmp_24;
    unsigned char *tmp_25;
    unsigned char *tmp_26;
    int tmp_27;
    int tmp_28;
    
#line 2820 
    ldv_spin_lock_100(& lio->lock);
    
#line 2821 
    g = (struct octnic_gather *)list_delete_head(& lio->glist);
    
#line 2822 
    ldv_spin_unlock_101(& lio->lock);
    
#line 2824 
    if (g == (struct octnic_gather *)0) {
      
#line 2825 
      if ((lio->msg_enable & 128U) != 0U) 
#line 2825 
                                          netdev_info((struct net_device const *)lio->netdev,"Transmit scatter gather: glist null!\n"); else ;
      
#line 2827 
      goto lio_xmit_failed;
    }
    else ;
    
#line 2830 
    cmdsetup.s.gather = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U;
    
#line 2831 
    tmp_23 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 2831 
    cmdsetup.s.u.gatherptrs = (unsigned int)((int)((struct skb_shared_info *)tmp_23)->nr_frags + 1);
    
#line 2832 
    octnet_prepare_pci_cmd(& ndata.cmd,& cmdsetup,tag);
    
#line 2834 
    memset((void *)g->sg,0,(unsigned long)g->sg_size);
    
#line 2836 
    (g->sg)->ptr[0] = dma_map_single_attrs(& (oct->pci_dev)->dev,(void *)skb->data,(unsigned long)(skb->len - skb->data_len),(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
    
#line 2840 
    tmp_24 = dma_mapping_error(& (oct->pci_dev)->dev,(g->sg)->ptr[0]);
    
#line 2840 
    if (tmp_24 != 0) {
      
#line 2841 
      dev_err((struct device const *)(& (oct->pci_dev)->dev),"%s DMA mapping error 2\n","liquidio_xmit");
      
#line 2843 
      __retres = 16;
      
#line 2843 
      goto return_label;
    }
    else ;
    
#line 2845 
    add_sg_size(g->sg,(unsigned short)((int)((unsigned short)skb->len) - (int)((unsigned short)skb->data_len)),0U);
    
#line 2847 
    tmp_25 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 2847 
    frags = (int)((struct skb_shared_info *)tmp_25)->nr_frags;
    
#line 2848 
    i = 1;
    
#line 2849 
    goto ldv_55833;
    ldv_55832: 
#line 2850 
    ;
    
#line 2850 
    tmp_26 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 2850 
    frag = & ((struct skb_shared_info *)tmp_26)->frags[i + -1];
    
#line 2852 
    (g->sg + (i >> 2))->ptr[i & 3] = dma_map_page(& (oct->pci_dev)->dev,frag->page.p,(unsigned long)frag->page_offset,(unsigned long)frag->size,(enum dma_data_direction)DMA_TO_DEVICE);
    
#line 2859 
    add_sg_size(g->sg + (i >> 2),(unsigned short)((int)((unsigned short)frag->size)),(unsigned int)i & 3U);
    
#line 2860 
    i += 1;
    ldv_55833: 
#line 2861 
    ;
    
#line 2849 
    tmp_27 = frags;
    
#line 2849 
    frags -= 1;
    
#line 2849 
    ;
    
#line 2849 
    if (tmp_27 != 0) 
#line 2851 
                     goto ldv_55832; else 
#line 2854 
                                          goto ldv_55834;
    ldv_55834: 
#line 2855 
    ;
    
#line 2863 
    ndata.cmd.dptr = dma_map_single_attrs(& (oct->pci_dev)->dev,(void *)g->sg,(unsigned long)g->sg_size,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
    
#line 2866 
    tmp_28 = dma_mapping_error(& (oct->pci_dev)->dev,ndata.cmd.dptr);
    
#line 2866 
    if (tmp_28 != 0) {
      
#line 2867 
      dev_err((struct device const *)(& (oct->pci_dev)->dev),"%s DMA mapping error 3\n","liquidio_xmit");
      
#line 2869 
      dma_unmap_single_attrs(& (oct->pci_dev)->dev,(g->sg)->ptr[0],(unsigned long)(skb->len - skb->data_len),(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
      
#line 2872 
      __retres = 16;
      
#line 2872 
      goto return_label;
    }
    else ;
    
#line 2875 
    finfo->dptr = ndata.cmd.dptr;
    
#line 2876 
    finfo->g = g;
    
#line 2878 
    ndata.reqtype = 2U;
  }
  
#line 2881 
  tmp_32 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 2881 
  ;
  
#line 2881 
  if ((unsigned int)((struct skb_shared_info *)tmp_32)->gso_size != 0U) {
    unsigned char *tmp_30;
    unsigned char *tmp_31;
    
#line 2882 
    struct octeon_instr_irh *irh = (struct octeon_instr_irh *)(& ndata.cmd.irh);
    
#line 2884 
    union tx_info *tx_info = (union tx_info *)(& ndata.cmd.ossp[0]);
    
#line 2886 
    irh->len = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U;
    
#line 2887 
    tmp_30 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 2887 
    tx_info->s.gso_size = ((struct skb_shared_info *)tmp_30)->gso_size;
    
#line 2888 
    tmp_31 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 2888 
    tx_info->s.gso_segs = ((struct skb_shared_info *)tmp_31)->gso_segs;
  }
  else ;
  
#line 2891 
  xmit_more = (int)skb->xmit_more;
  
#line 2893 
  if ((long)((unsigned int)*((unsigned char *)(& cmdsetup.s) + 2UL) != 0U) != 0L) 
    
#line 2894 
    status = send_nic_timestamp_pkt(oct,& ndata,finfo,xmit_more); else 
                                                                    
#line 2896 
                                                                    status = octnet_send_nic_data_pkt(oct,& ndata,(unsigned int)xmit_more);
  
#line 2897 
  if (status == -1) 
#line 2898 
                    goto lio_xmit_failed; else ;
  
#line 2900 
  if ((lio->msg_enable & 256U) != 0U) 
#line 2900 
                                      netdev_info((struct net_device const *)lio->netdev,"Transmit queued successfully\n"); else ;
  
#line 2902 
  if (status == 1) 
#line 2903 
                   stop_q(lio->netdev,q_idx); else ;
  
#line 2905 
  netdev->trans_start = jiffies;
  
#line 2907 
  stats->tx_done += 1ULL;
  
#line 2908 
  stats->tx_tot_bytes += (unsigned long long)skb->len;
  
#line 2910 
  __retres = 0;
  
#line 2910 
  goto return_label;
  lio_xmit_failed: 
#line 2912 
  ;
  
#line 2913 
  stats->tx_dropped += 1ULL;
  
#line 2914 
  if ((lio->msg_enable & 128U) != 0U) 
#line 2914 
                                      netdev_info((struct net_device const *)lio->netdev,"IQ%d Transmit dropped:%llu\n",iq_no,stats->tx_dropped); else ;
  
#line 2916 
  dma_unmap_single_attrs(& (oct->pci_dev)->dev,ndata.cmd.dptr,(unsigned long)ndata.datasize,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
  
#line 2918 
  recv_buffer_free((void *)skb);
  
#line 2919 
  __retres = 0;
  return_label: 
#line 2919 
                return __retres;
}


#line 2925  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static void liquidio_tx_timeout(struct net_device *netdev)
{
  struct lio *lio;
  
#line 2929 
  lio = (struct lio *)netdev_priv((struct net_device const *)netdev);
  
#line 2931 
  if ((lio->msg_enable & 128U) != 0U) 
#line 2931 
                                      netdev_info((struct net_device const *)lio->netdev,"Transmit timeout tx_dropped:%ld, waking up queues now!!\n",netdev->stats.tx_dropped); else ;
  
#line 2934 
  netdev->trans_start = jiffies;
  
#line 2935 
  txqs_wake(netdev);
  
#line 2936 
  return;
}


#line 2938  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
int liquidio_set_feature(struct net_device *netdev, int cmd)
{
  struct octnic_ctrl_pkt nctrl;
  struct octnic_ctrl_params nparams;
  
#line 2940 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 2941 
  struct octeon_device *oct = lio->oct_dev;
  
#line 2944 
  int ret = 0;
  
#line 2946 
  memset((void *)(& nctrl),0,320UL);
  
#line 2948 
  nctrl.ncmd.u64 = 0ULL;
  
#line 2949 
  nctrl.ncmd.s.cmd = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(5))))cmd;
  
#line 2950 
  nctrl.ncmd.s.param1 = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(29))))lio->linfo.ifidx;
  
#line 2951 
  nctrl.ncmd.s.param2 = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))3U;
  
#line 2952 
  nctrl.wait_time = 100UL;
  
#line 2953 
  nctrl.netpndev = (unsigned long long)netdev;
  
#line 2954 
  nctrl.cb_fn = & liquidio_link_ctrl_cmd_completion;
  
#line 2956 
  nparams.resp_order = 2U;
  
#line 2958 
  ret = octnet_send_nic_ctrl_pkt(lio->oct_dev,& nctrl,nparams);
  
#line 2959 
  if (ret < 0) 
#line 2960 
               dev_err((struct device const *)(& (oct->pci_dev)->dev),"Feature change failed in core (ret: 0x%x)\n",ret); else ;
  
#line 2963 
  return ret;
}


#line 2971  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static netdev_features_t liquidio_fix_features(struct net_device *netdev, netdev_features_t request)
{
  
#line 2974 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 2976 
  if ((request & 17179869184ULL) != 0ULL && (lio->dev_capability & 17179869184ULL) == 0ULL) 
    
#line 2978 
    request &= 18446744056529682431ULL; else ;
  
#line 2980 
  if ((request & 8ULL) != 0ULL && (lio->dev_capability & 8ULL) == 0ULL) 
    
#line 2982 
    request &= 18446744073709551607ULL; else ;
  
#line 2984 
  if ((request & 65536ULL) != 0ULL && (lio->dev_capability & 65536ULL) == 0ULL) 
    
#line 2985 
    request &= 18446744073709486079ULL; else ;
  
#line 2987 
  if ((request & 1048576ULL) != 0ULL && (lio->dev_capability & 1048576ULL) == 0ULL) 
    
#line 2988 
    request &= 18446744073708503039ULL; else ;
  
#line 2990 
  if ((request & 32768ULL) != 0ULL && (lio->dev_capability & 32768ULL) == 0ULL) 
    
#line 2991 
    request &= 18446744073709518847ULL; else ;
  
#line 2994 
  if (((request & 17179869184ULL) == 0ULL && (netdev->features & 32768ULL) != 0ULL) && (lio->dev_capability & 32768ULL) != 0ULL) 
    
#line 2996 
    request &= 18446744073709518847ULL; else ;
  
#line 2998 
  return request;
}


#line 3005  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int liquidio_set_features(struct net_device *netdev, netdev_features_t features)
{
  int __retres;
  
#line 3008 
  struct lio *lio = netdev_priv((struct net_device const *)netdev);
  
#line 3010 
  if (((netdev->features ^ features) & 32768ULL) == 0ULL) {
    
#line 3011 
    __retres = 0;
    
#line 3011 
    goto return_label;
  }
  else ;
  
#line 3013 
  if ((features & 32768ULL) != 0ULL && (lio->dev_capability & 32768ULL) != 0ULL) 
    
#line 3014 
    liquidio_set_feature(netdev,11);
  else 
    
#line 3015 
    if ((features & 32768ULL) == 0ULL && (lio->dev_capability & 32768ULL) != 0ULL) 
      
#line 3017 
      liquidio_set_feature(netdev,12); else ;
  
#line 3019 
  __retres = 0;
  return_label: 
#line 3019 
                return __retres;
}


#line 3022  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static struct net_device_ops lionetdevops = {.ndo_init = (int (*)(struct net_device *))0, .ndo_uninit = (void (*)(struct net_device *))0, .ndo_open = & liquidio_open, .ndo_stop = & liquidio_stop, .ndo_start_xmit = (netdev_tx_t (*)(struct sk_buff *, struct net_device *))(& liquidio_xmit), .ndo_select_queue = (u16 (*)(struct net_device *, struct sk_buff *, void *, u16 (*)(struct net_device *, struct sk_buff *)))0, .ndo_change_rx_flags = (void (*)(struct net_device *, int ))0, .ndo_set_rx_mode = & liquidio_set_mcast_list, .ndo_set_mac_address = & liquidio_set_mac, .ndo_validate_addr = (int (*)(struct net_device *))0, .ndo_do_ioctl = & liquidio_ioctl, .ndo_set_config = (int (*)(struct net_device *, struct ifmap *))0, .ndo_change_mtu = & liquidio_change_mtu, .ndo_neigh_setup = (int (*)(struct net_device *, struct neigh_parms *))0, .ndo_tx_timeout = & liquidio_tx_timeout, .ndo_get_stats64 = (struct rtnl_link_stats64 *(*)(struct net_device *, struct rtnl_link_stats64 *))0, .ndo_get_stats = & liquidio_get_stats, .ndo_vlan_rx_add_vid = (int (*)(struct net_device *, __be16 , u16 ))0, .ndo_vlan_rx_kill_vid = (int (*)(struct net_device *, __be16 , u16 ))0, .ndo_poll_controller = (void (*)(struct net_device *))0, .ndo_netpoll_setup = (int (*)(struct net_device *, struct netpoll_info *))0, .ndo_netpoll_cleanup = (void (*)(struct net_device *))0, .ndo_busy_poll = (int (*)(struct napi_struct *))0, .ndo_set_vf_mac = (int (*)(struct net_device *, int , u8 *))0, .ndo_set_vf_vlan = (int (*)(struct net_device *, int , u16 , u8 ))0, .ndo_set_vf_rate = (int (*)(struct net_device *, int , int , int ))0, .ndo_set_vf_spoofchk = (int (*)(struct net_device *, int , bool ))0, .ndo_get_vf_config = (int (*)(struct net_device *, int , struct ifla_vf_info *))0, .ndo_set_vf_link_state = (int (*)(struct net_device *, int , int ))0, .ndo_get_vf_stats = (int (*)(struct net_device *, int , struct ifla_vf_stats *))0, .ndo_set_vf_port = (int (*)(struct net_device *, int , struct nlattr **))0, .ndo_get_vf_port = (int (*)(struct net_device *, int , struct sk_buff *))0, .ndo_set_vf_rss_query_en = (int (*)(struct net_device *, int , bool ))0, .ndo_setup_tc = (int (*)(struct net_device *, u8 ))0, .ndo_fcoe_enable = (int (*)(struct net_device *))0, .ndo_fcoe_disable = (int (*)(struct net_device *))0, .ndo_fcoe_ddp_setup = (int (*)(struct net_device *, u16 , struct scatterlist *, unsigned int ))0, .ndo_fcoe_ddp_done = (int (*)(struct net_device *, u16 ))0, .ndo_fcoe_ddp_target = (int (*)(struct net_device *, u16 , struct scatterlist *, unsigned int ))0, .ndo_fcoe_get_hbainfo = (int (*)(struct net_device *, struct netdev_fcoe_hbainfo *))0, .ndo_fcoe_get_wwn = (int (*)(struct net_device *, u64 *, int ))0, .ndo_rx_flow_steer = (int (*)(struct net_device *, struct sk_buff const *, u16 , u32 ))0, .ndo_add_slave = (int (*)(struct net_device *, struct net_device *))0, .ndo_del_slave = (int (*)(struct net_device *, struct net_device *))0, .ndo_fix_features = & liquidio_fix_features, .ndo_set_features = & liquidio_set_features, .ndo_neigh_construct = (int (*)(struct neighbour *))0, .ndo_neigh_destroy = (void (*)(struct neighbour *))0, .ndo_fdb_add = (int (*)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 , u16 ))0, .ndo_fdb_del = (int (*)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 ))0, .ndo_fdb_dump = (int (*)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int ))0, .ndo_bridge_setlink = (int (*)(struct net_device *, struct nlmsghdr *, u16 ))0, .ndo_bridge_getlink = (int (*)(struct sk_buff *, u32 , u32 , struct net_device *, u32 , int ))0, .ndo_bridge_dellink = (int (*)(struct net_device *, struct nlmsghdr *, u16 ))0, .ndo_change_carrier = (int (*)(struct net_device *, bool ))0, .ndo_get_phys_port_id = (int (*)(struct net_device *, struct netdev_phys_item_id *))0, .ndo_get_phys_port_name = (int (*)(struct net_device *, char *, size_t ))0, .ndo_add_vxlan_port = (void (*)(struct net_device *, sa_family_t , __be16 ))0, .ndo_del_vxlan_port = (void (*)(struct net_device *, sa_family_t , __be16 ))0, .ndo_dfwd_add_station = (void *(*)(struct net_device *, struct net_device *))0, .ndo_dfwd_del_station = (void (*)(struct net_device *, void *))0, .ndo_dfwd_start_xmit = (netdev_tx_t (*)(struct sk_buff *, struct net_device *, void *))0, .ndo_get_lock_subclass = (int (*)(struct net_device *))0, .ndo_features_check = (netdev_features_t (*)(struct sk_buff *, struct net_device *, netdev_features_t ))0, .ndo_set_tx_maxrate = (int (*)(struct net_device *, int , u32 ))0, .ndo_get_iflink = (int (*)(struct net_device const *))0};

#line 3038  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int liquidio_init(void)
{
  int __retres;
  int i;
  struct handshake *hs;
  int tmp;
  unsigned long tmp_0;
  
#line 3043 
  init_completion(& first_stage);
  
#line 3045 
  octeon_init_device_list(conf_type);
  
#line 3047 
  tmp = liquidio_init_pci();
  
#line 3047 
  if (tmp != 0) {
    
#line 3048 
    __retres = -22;
    
#line 3048 
    goto return_label;
  }
  else ;
  
#line 3050 
  tmp_0 = msecs_to_jiffies(1000U);
  
#line 3050 
  wait_for_completion_timeout(& first_stage,tmp_0);
  
#line 3052 
  i = 0;
  
#line 3052 
  goto ldv_55867;
  ldv_55866: 
#line 3053 
  ;
  
#line 3053 
  hs = & handshake[i];
  
#line 3054 
  if (hs->pci_dev != (struct pci_dev *)0) {
    
#line 3055 
    wait_for_completion(& hs->init);
    
#line 3056 
    if (hs->init_ok == 0) {
      
#line 3058 
      dev_err((struct device const *)(& (hs->pci_dev)->dev),"Failed to init device\n");
      
#line 3060 
      liquidio_deinit_pci();
      
#line 3061 
      __retres = -5;
      
#line 3061 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 3052 
  i += 1;
  ldv_55867: 
#line 3053 
  ;
  
#line 3052 
  if (i <= 31) 
#line 3054 
               goto ldv_55866; else 
#line 3057 
                                    goto ldv_55868;
  ldv_55868: 
#line 3058 
  ;
  
#line 3066 
  i = 0;
  
#line 3066 
  goto ldv_55870;
  ldv_55869: 
#line 3067 
  ;
  
#line 3067 
  hs = & handshake[i];
  
#line 3068 
  if (hs->pci_dev != (struct pci_dev *)0) {
    unsigned long tmp_1;
    
#line 3069 
    tmp_1 = msecs_to_jiffies(30000U);
    
#line 3069 
    ;
    
#line 3069 
    wait_for_completion_timeout(& hs->started,tmp_1);
    
#line 3071 
    if (hs->started_ok == 0) {
      
#line 3073 
      dev_err((struct device const *)(& (hs->pci_dev)->dev),"Firmware failed to start\n");
      
#line 3075 
      liquidio_deinit_pci();
      
#line 3076 
      __retres = -5;
      
#line 3076 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 3066 
  i += 1;
  ldv_55870: 
#line 3067 
  ;
  
#line 3066 
  if (i <= 31) 
#line 3068 
               goto ldv_55869; else 
#line 3071 
                                    goto ldv_55871;
  ldv_55871: 
#line 3072 
  ;
  
#line 3081 
  __retres = 0;
  return_label: 
#line 3081 
                return __retres;
}


#line 3084  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int lio_nic_info(struct octeon_recv_info *recv_info, void *buf)
{
  int __retres;
  union oct_link_status *ls;
  int i;
  
#line 3086 
  struct octeon_device *oct = (struct octeon_device *)buf;
  
#line 3087 
  struct octeon_recv_pkt *recv_pkt = recv_info->recv_pkt;
  
#line 3088 
  int ifidx = 0;
  
#line 3092 
  if (recv_pkt->buffer_size[0] != 8U || (unsigned int)recv_pkt->rh.r_nic_info.ifidx > oct->ifcount) {
    
#line 3094 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Malformed NIC_INFO, len=%d, ifidx=%d\n",recv_pkt->buffer_size[0],(int)recv_pkt->rh.r_nic_info.ifidx);
    
#line 3097 
    goto nic_info_err;
  }
  else ;
  
#line 3100 
  ifidx = (int)recv_pkt->rh.r_nic_info.ifidx;
  
#line 3101 
  ls = (union oct_link_status *)((struct sk_buff *)recv_pkt->buffer_ptr[0])->data;
  
#line 3103 
  octeon_swap_8B_data_2((u64 *)ls,1U);
  
#line 3105 
  update_link_status(oct->props[ifidx].netdev,ls);
  nic_info_err: 
#line 3107 
  ;
  
#line 3108 
  i = 0;
  
#line 3108 
  goto ldv_55883;
  ldv_55882: 
#line 3109 
  ;
  
#line 3109 
  recv_buffer_free(recv_pkt->buffer_ptr[i]);
  
#line 3108 
  i += 1;
  ldv_55883: 
#line 3109 
  ;
  
#line 3108 
  if ((int)recv_pkt->buffer_count > i) 
#line 3110 
                                       goto ldv_55882; else 
#line 3113 
                                                            goto ldv_55884;
  ldv_55884: 
#line 3114 
  ;
  
#line 3110 
  octeon_free_recv_info(recv_info);
  
#line 3111 
  __retres = 0;
  
#line 3111 
  return __retres;
}


#line 3122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int setup_nic_devices(struct octeon_device *octeon_dev)
{
  int __retres;
  struct net_device *netdev;
  u8 mac[6U];
  u8 i;
  u8 j;
  struct octeon_soft_command *sc;
  struct liquidio_if_cfg_context *ctx;
  struct liquidio_if_cfg_resp *resp;
  struct octdev_props *props;
  int retval;
  int num_iqueues;
  int num_oqueues;
  int q_no;
  u64 q_mask;
  unsigned int tmp;
  union oct_nic_if_cfg if_cfg;
  unsigned int base_queue;
  unsigned int gmx_port_id;
  u32 resp_size;
  u32 ctx_size;
  struct octeon_config *tmp_0;
  struct octeon_config *tmp_1;
  struct octeon_config *tmp_2;
  struct octeon_config *tmp_3;
  int volatile *tmp_4;
  unsigned long tmp_8;
  unsigned long tmp_9;
  int tmp_10;
  int tmp_11;
  int tmp_12;
  int tmp_13;
  int tmp_14;
  u8 tmp_15;
  
#line 3124 
  struct lio *lio = (struct lio *)0;
  
#line 3133 
  tmp = cpumask_weight(cpu_online_mask);
  
#line 3133 
  int num_cpus = (int)tmp;
  
#line 3140 
  octeon_register_dispatch_fn(octeon_dev,(unsigned short)1,(unsigned short)4,& lio_nic_info,(void *)octeon_dev);
  
#line 3147 
  octeon_register_reqtype_free_fn(octeon_dev,1,& free_netbuf);
  
#line 3150 
  octeon_register_reqtype_free_fn(octeon_dev,2,& free_netsgbuf);
  
#line 3153 
  octeon_register_reqtype_free_fn(octeon_dev,4,& free_netsgbuf_with_resp);
  
#line 3156 
  i = (unsigned char)0U;
  
#line 3156 
  goto ldv_55929;
  ldv_55928: 
#line 3157 
  ;
  
#line 3157 
  resp_size = 128U;
  
#line 3158 
  ctx_size = 104U;
  
#line 3159 
  sc = octeon_alloc_soft_command(octeon_dev,0U,resp_size,ctx_size);
  
#line 3162 
  resp = (struct liquidio_if_cfg_resp *)sc->virtrptr;
  
#line 3163 
  ctx = (struct liquidio_if_cfg_context *)sc->ctxptr;
  
#line 3166 
  tmp_0 = octeon_get_conf(octeon_dev);
  
#line 3165 
  num_iqueues = (int)tmp_0->nic_if_cfg[(int)i].num_txqs;
  
#line 3168 
  tmp_1 = octeon_get_conf(octeon_dev);
  
#line 3167 
  num_oqueues = (int)tmp_1->nic_if_cfg[(int)i].num_rxqs;
  
#line 3170 
  tmp_2 = octeon_get_conf(octeon_dev);
  
#line 3169 
  base_queue = (unsigned int)tmp_2->nic_if_cfg[(int)i].base_queue;
  
#line 3172 
  tmp_3 = octeon_get_conf(octeon_dev);
  
#line 3171 
  gmx_port_id = (unsigned int)tmp_3->nic_if_cfg[(int)i].gmx_port_id;
  
#line 3173 
  if (num_iqueues > num_cpus) 
#line 3174 
                              num_iqueues = num_cpus; else ;
  
#line 3175 
  if (num_oqueues > num_cpus) 
#line 3176 
                              num_oqueues = num_cpus; else ;
  {
    
#line 3177 
    struct _ddebug descriptor = {.modname = "liquidio", .function = "setup_nic_devices", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c", .format = "requesting config for interface %d, iqs %d, oqs %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3179U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 3177 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 3177 
                                                        __dynamic_dev_dbg(& descriptor,(struct device const *)(& (octeon_dev->pci_dev)->dev),"requesting config for interface %d, iqs %d, oqs %d\n",(int)i,num_iqueues,num_oqueues); else ;
  }
  {
    
#line 3180 
    int __var = 0;
    
#line 3180 
    tmp_4 = (int volatile *)(& ctx->cond);
  }
  
#line 3180 
  *tmp_4 = 0;
  
#line 3181 
  ctx->octeon_id = lio_get_device_id((void *)octeon_dev);
  {
    struct lock_class_key __key;
    
#line 3182 
    __init_waitqueue_head(& ctx->wc,"&ctx->wc",& __key);
  }
  
#line 3184 
  if_cfg.u64 = 0ULL;
  
#line 3185 
  if_cfg.s.num_iqueues = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))((unsigned short)num_iqueues);
  
#line 3186 
  if_cfg.s.num_oqueues = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))((unsigned short)num_oqueues);
  
#line 3187 
  if_cfg.s.base_queue = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))))((unsigned short)base_queue);
  
#line 3188 
  if_cfg.s.gmx_port_id = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))((unsigned char)gmx_port_id);
  
#line 3189 
  octeon_prepare_soft_command(octeon_dev,sc,(unsigned char)1,(unsigned char)9,(unsigned int)i,if_cfg.u64,0ULL);
  
#line 3193 
  sc->callback = & if_cfg_callback;
  
#line 3194 
  sc->callback_arg = (void *)sc;
  
#line 3195 
  sc->wait_time = 1000UL;
  
#line 3197 
  retval = octeon_send_soft_command(octeon_dev,sc);
  
#line 3198 
  if (retval != 0) {
    
#line 3199 
    dev_err((struct device const *)(& (octeon_dev->pci_dev)->dev),"iq/oq config failed status: %x\n",retval);
    
#line 3203 
    goto setup_nic_dev_fail;
  }
  else ;
  
#line 3209 
  sleep_cond_0(& ctx->wc,& ctx->cond);
  
#line 3210 
  retval = (int)resp->status;
  
#line 3211 
  if (retval != 0) {
    
#line 3212 
    dev_err((struct device const *)(& (octeon_dev->pci_dev)->dev),"iq/oq config failed\n");
    
#line 3213 
    goto setup_nic_dev_fail;
  }
  else ;
  
#line 3216 
  octeon_swap_8B_data_2((u64 *)(& resp->cfg_info),14U);
  
#line 3219 
  if (0 != 0) 
#line 3219 
              num_iqueues = (int)((((unsigned int)(((((((((resp->cfg_info.iqmask & 1ULL) != 0ULL) + ((resp->cfg_info.iqmask & 2ULL) != 0ULL)) + ((resp->cfg_info.iqmask & 4ULL) != 0ULL)) + ((resp->cfg_info.iqmask & 8ULL) != 0ULL)) + ((resp->cfg_info.iqmask & 16ULL) != 0ULL)) + ((resp->cfg_info.iqmask & 32ULL) != 0ULL)) + ((resp->cfg_info.iqmask & 64ULL) != 0ULL)) + ((resp->cfg_info.iqmask & 128ULL) != 0ULL)) + (unsigned int)((((((((((resp->cfg_info.iqmask >> 8) & 1ULL) != 0ULL) + (((resp->cfg_info.iqmask >> 8) & 2ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 8) & 4ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 8) & 8ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 8) & 16ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 8) & 32ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 8) & 64ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 8) & 128ULL) != 0ULL))) + ((unsigned int)((((((((((resp->cfg_info.iqmask >> 16) & 1ULL) != 0ULL) + (((resp->cfg_info.iqmask >> 16) & 2ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 16) & 4ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 16) & 8ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 16) & 16ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 16) & 32ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 16) & 64ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 16) & 128ULL) != 0ULL)) + (unsigned int)((((((((((resp->cfg_info.iqmask >> 24) & 1ULL) != 0ULL) + (((resp->cfg_info.iqmask >> 24) & 2ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 24) & 4ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 24) & 8ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 24) & 16ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 24) & 32ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 24) & 64ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 24) & 128ULL) != 0ULL)))) + (((unsigned int)((((((((((resp->cfg_info.iqmask >> 32) & 1ULL) != 0ULL) + (((resp->cfg_info.iqmask >> 32) & 2ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 32) & 4ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 32) & 8ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 32) & 16ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 32) & 32ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 32) & 64ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 32) & 128ULL) != 0ULL)) + (unsigned int)((((((((((resp->cfg_info.iqmask >> 40) & 1ULL) != 0ULL) + (((resp->cfg_info.iqmask >> 40) & 2ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 40) & 4ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 40) & 8ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 40) & 16ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 40) & 32ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 40) & 64ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 40) & 128ULL) != 0ULL))) + ((unsigned int)((((((((((resp->cfg_info.iqmask >> 48) & 1ULL) != 0ULL) + (((resp->cfg_info.iqmask >> 48) & 2ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 48) & 4ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 48) & 8ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 48) & 16ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 48) & 32ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 48) & 64ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 48) & 128ULL) != 0ULL)) + (unsigned int)((((((((((resp->cfg_info.iqmask >> 56) & 1ULL) != 0ULL) + (((resp->cfg_info.iqmask >> 56) & 2ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 56) & 4ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 56) & 8ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 56) & 16ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 56) & 32ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 56) & 64ULL) != 0ULL)) + (((resp->cfg_info.iqmask >> 56) & 128ULL) != 0ULL)))));
  else {
    unsigned long tmp_5;
    
#line 3219 
    tmp_5 = __arch_hweight64(resp->cfg_info.iqmask);
    
#line 3219 
    num_iqueues = (int)tmp_5;
  }
  
#line 3220 
  if (0 != 0) 
#line 3220 
              num_oqueues = (int)((((unsigned int)(((((((((resp->cfg_info.oqmask & 1ULL) != 0ULL) + ((resp->cfg_info.oqmask & 2ULL) != 0ULL)) + ((resp->cfg_info.oqmask & 4ULL) != 0ULL)) + ((resp->cfg_info.oqmask & 8ULL) != 0ULL)) + ((resp->cfg_info.oqmask & 16ULL) != 0ULL)) + ((resp->cfg_info.oqmask & 32ULL) != 0ULL)) + ((resp->cfg_info.oqmask & 64ULL) != 0ULL)) + ((resp->cfg_info.oqmask & 128ULL) != 0ULL)) + (unsigned int)((((((((((resp->cfg_info.oqmask >> 8) & 1ULL) != 0ULL) + (((resp->cfg_info.oqmask >> 8) & 2ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 8) & 4ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 8) & 8ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 8) & 16ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 8) & 32ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 8) & 64ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 8) & 128ULL) != 0ULL))) + ((unsigned int)((((((((((resp->cfg_info.oqmask >> 16) & 1ULL) != 0ULL) + (((resp->cfg_info.oqmask >> 16) & 2ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 16) & 4ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 16) & 8ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 16) & 16ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 16) & 32ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 16) & 64ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 16) & 128ULL) != 0ULL)) + (unsigned int)((((((((((resp->cfg_info.oqmask >> 24) & 1ULL) != 0ULL) + (((resp->cfg_info.oqmask >> 24) & 2ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 24) & 4ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 24) & 8ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 24) & 16ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 24) & 32ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 24) & 64ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 24) & 128ULL) != 0ULL)))) + (((unsigned int)((((((((((resp->cfg_info.oqmask >> 32) & 1ULL) != 0ULL) + (((resp->cfg_info.oqmask >> 32) & 2ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 32) & 4ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 32) & 8ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 32) & 16ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 32) & 32ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 32) & 64ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 32) & 128ULL) != 0ULL)) + (unsigned int)((((((((((resp->cfg_info.oqmask >> 40) & 1ULL) != 0ULL) + (((resp->cfg_info.oqmask >> 40) & 2ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 40) & 4ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 40) & 8ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 40) & 16ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 40) & 32ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 40) & 64ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 40) & 128ULL) != 0ULL))) + ((unsigned int)((((((((((resp->cfg_info.oqmask >> 48) & 1ULL) != 0ULL) + (((resp->cfg_info.oqmask >> 48) & 2ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 48) & 4ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 48) & 8ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 48) & 16ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 48) & 32ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 48) & 64ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 48) & 128ULL) != 0ULL)) + (unsigned int)((((((((((resp->cfg_info.oqmask >> 56) & 1ULL) != 0ULL) + (((resp->cfg_info.oqmask >> 56) & 2ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 56) & 4ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 56) & 8ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 56) & 16ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 56) & 32ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 56) & 64ULL) != 0ULL)) + (((resp->cfg_info.oqmask >> 56) & 128ULL) != 0ULL)))));
  else {
    unsigned long tmp_6;
    
#line 3220 
    tmp_6 = __arch_hweight64(resp->cfg_info.oqmask);
    
#line 3220 
    num_oqueues = (int)tmp_6;
  }
  
#line 3222 
  if (num_iqueues == 0 || num_oqueues == 0) {
    
#line 3223 
    dev_err((struct device const *)(& (octeon_dev->pci_dev)->dev),"Got bad iqueues (%016llx) or oqueues (%016llx) from firmware.\n",resp->cfg_info.iqmask,resp->cfg_info.oqmask);
    
#line 3227 
    goto setup_nic_dev_fail;
  }
  else ;
  {
    
#line 3229 
    struct _ddebug descriptor_0 = {.modname = "liquidio", .function = "setup_nic_devices", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c", .format = "interface %d, iqmask %016llx, oqmask %016llx, numiqueues %d, numoqueues %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3232U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 3229 
    if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 3229 
                                                          __dynamic_dev_dbg(& descriptor_0,(struct device const *)(& (octeon_dev->pci_dev)->dev),"interface %d, iqmask %016llx, oqmask %016llx, numiqueues %d, numoqueues %d\n",(int)i,resp->cfg_info.iqmask,resp->cfg_info.oqmask,num_iqueues,num_oqueues); else ;
  }
  
#line 3233 
  netdev = ldv_alloc_etherdev_mqs_102(696,(unsigned int)num_iqueues,(unsigned int)num_iqueues);
  
#line 3235 
  if (netdev == (struct net_device *)0) {
    
#line 3236 
    dev_err((struct device const *)(& (octeon_dev->pci_dev)->dev),"Device allocation failed\n");
    
#line 3237 
    goto setup_nic_dev_fail;
  }
  else ;
  
#line 3240 
  props = & octeon_dev->props[(int)i];
  
#line 3241 
  props->netdev = netdev;
  
#line 3243 
  if (num_iqueues > 1) 
#line 3244 
                       lionetdevops.ndo_select_queue = & select_q; else ;
  
#line 3249 
  netdev->netdev_ops = (struct net_device_ops const *)(& lionetdevops);
  
#line 3251 
  lio = (struct lio *)netdev_priv((struct net_device const *)netdev);
  
#line 3253 
  memset((void *)lio,0,696UL);
  
#line 3255 
  lio->linfo.ifidx = (unsigned char)resp->cfg_info.ifidx;
  
#line 3256 
  lio->ifidx = (int)resp->cfg_info.ifidx;
  
#line 3258 
  lio->linfo.num_rxpciq = (unsigned char)num_oqueues;
  
#line 3259 
  lio->linfo.num_txpciq = (unsigned char)num_iqueues;
  
#line 3260 
  q_mask = resp->cfg_info.oqmask;
  
#line 3262 
  j = (unsigned char)0U;
  
#line 3262 
  goto ldv_55916;
  ldv_55915: 
#line 3263 
  ;
  
#line 3263 
  tmp_8 = __ffs64(q_mask);
  
#line 3263 
  q_no = (int)tmp_8;
  
#line 3264 
  q_mask = (unsigned long long)(~ (1UL << q_no)) & q_mask;
  
#line 3265 
  lio->linfo.rxpciq[(int)j] = (unsigned char)q_no;
  
#line 3262 
  j = (u8)((int)j + 1);
  ldv_55916: 
#line 3263 
  ;
  
#line 3262 
  if ((int)j < num_oqueues) 
#line 3264 
                            goto ldv_55915; else 
#line 3267 
                                                 goto ldv_55917;
  ldv_55917: 
#line 3268 
  ;
  
#line 3267 
  q_mask = resp->cfg_info.iqmask;
  
#line 3268 
  j = (unsigned char)0U;
  
#line 3268 
  goto ldv_55919;
  ldv_55918: 
#line 3269 
  ;
  
#line 3269 
  tmp_9 = __ffs64(q_mask);
  
#line 3269 
  q_no = (int)tmp_9;
  
#line 3270 
  q_mask = (unsigned long long)(~ (1UL << q_no)) & q_mask;
  
#line 3271 
  lio->linfo.txpciq[(int)j] = (unsigned char)q_no;
  
#line 3268 
  j = (u8)((int)j + 1);
  ldv_55919: 
#line 3269 
  ;
  
#line 3268 
  if ((int)j < num_iqueues) 
#line 3270 
                            goto ldv_55918; else 
#line 3273 
                                                 goto ldv_55920;
  ldv_55920: 
#line 3274 
  ;
  
#line 3273 
  lio->linfo.hw_addr = resp->cfg_info.linfo.hw_addr;
  
#line 3274 
  lio->linfo.gmxport = resp->cfg_info.linfo.gmxport;
  
#line 3275 
  lio->linfo.link.u64 = resp->cfg_info.linfo.link.u64;
  
#line 3277 
  lio->msg_enable = netif_msg_init(debug,7);
  
#line 3279 
  lio->dev_capability = 17181016115ULL;
  
#line 3284 
  netif_set_gso_max_size(netdev,65408U);
  
#line 3286 
  netdev->features = lio->dev_capability;
  
#line 3287 
  netdev->vlan_features = lio->dev_capability;
  
#line 3289 
  netdev->hw_features = lio->dev_capability;
  
#line 3294 
  lio->oct_dev = octeon_dev;
  
#line 3295 
  lio->octprops = props;
  
#line 3296 
  lio->netdev = netdev;
  
#line 3297 
  spinlock_check(& lio->lock);
  {
    struct lock_class_key __key_0;
    
#line 3297 
    __raw_spin_lock_init(& lio->lock.__anonCompField_spinlock_18.rlock,"&(&lio->lock)->rlock",& __key_0);
  }
  {
    
#line 3299 
    struct _ddebug descriptor_1 = {.modname = "liquidio", .function = "setup_nic_devices", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c", .format = "if%d gmx: %d hw_addr: 0x%llx\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3301U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 3299 
    if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) 
#line 3299 
                                                          __dynamic_dev_dbg(& descriptor_1,(struct device const *)(& (octeon_dev->pci_dev)->dev),"if%d gmx: %d hw_addr: 0x%llx\n",(int)i,(int)lio->linfo.gmxport,(long long)lio->linfo.hw_addr); else ;
  }
  
#line 3304 
  octeon_swap_8B_data_2(& lio->linfo.hw_addr,1U);
  
#line 3305 
  j = (unsigned char)0U;
  
#line 3305 
  goto ldv_55924;
  ldv_55923: 
#line 3306 
  ;
  
#line 3306 
  mac[(int)j] = *((u8 *)(& lio->linfo.hw_addr) + ((unsigned int)j + 2U));
  
#line 3305 
  j = (u8)((int)j + 1);
  ldv_55924: 
#line 3306 
  ;
  
#line 3305 
  if ((unsigned int)j <= 5U) 
#line 3307 
                             goto ldv_55923; else 
#line 3310 
                                                  goto ldv_55925;
  ldv_55925: 
#line 3311 
  ;
  
#line 3310 
  ether_addr_copy(netdev->dev_addr,(u8 const *)(& mac));
  
#line 3312 
  tmp_10 = setup_io_queues(octeon_dev,netdev);
  
#line 3312 
  if (tmp_10 != 0) {
    
#line 3313 
    dev_err((struct device const *)(& (octeon_dev->pci_dev)->dev),"I/O queues creation failed\n");
    
#line 3314 
    goto setup_nic_dev_fail;
  }
  else ;
  
#line 3317 
  ifstate_set(lio,1);
  
#line 3322 
  lio->txq = (int)lio->linfo.txpciq[0];
  
#line 3323 
  lio->rxq = (int)lio->linfo.rxpciq[0];
  
#line 3325 
  tmp_11 = octeon_get_tx_qsize(octeon_dev,(unsigned int)lio->txq);
  
#line 3325 
  lio->tx_qsize = (unsigned int)tmp_11;
  
#line 3326 
  tmp_12 = octeon_get_rx_qsize(octeon_dev,(unsigned int)lio->rxq);
  
#line 3326 
  lio->rx_qsize = (unsigned int)tmp_12;
  
#line 3328 
  tmp_13 = setup_glist(lio);
  
#line 3328 
  if (tmp_13 != 0) {
    
#line 3329 
    dev_err((struct device const *)(& (octeon_dev->pci_dev)->dev),"Gather list allocation failed\n");
    
#line 3331 
    goto setup_nic_dev_fail;
  }
  else ;
  
#line 3335 
  liquidio_set_ethtool_ops(netdev);
  
#line 3337 
  liquidio_set_feature(netdev,11);
  
#line 3339 
  if (debug != -1 && (debug & 8192) != 0) 
#line 3340 
                                          liquidio_set_feature(netdev,20); else ;
  
#line 3343 
  tmp_14 = ldv_register_netdev_103(netdev);
  
#line 3343 
  if (tmp_14 != 0) {
    
#line 3344 
    dev_err((struct device const *)(& (octeon_dev->pci_dev)->dev),"Device registration failed\n");
    
#line 3345 
    goto setup_nic_dev_fail;
  }
  else ;
  {
    
#line 3348 
    struct _ddebug descriptor_2 = {.modname = "liquidio", .function = "setup_nic_devices", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c", .format = "Setup NIC ifidx:%d mac:%02x%02x%02x%02x%02x%02x\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3350U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 3348 
    if ((long)(((int)descriptor_2.flags & 1) != 0) != 0L) 
#line 3348 
                                                          __dynamic_dev_dbg(& descriptor_2,(struct device const *)(& (octeon_dev->pci_dev)->dev),"Setup NIC ifidx:%d mac:%02x%02x%02x%02x%02x%02x\n",(int)i,(int)mac[0],(int)mac[1],(int)mac[2],(int)mac[3],(int)mac[4],(int)mac[5]); else ;
  }
  
#line 3351 
  netif_carrier_off(netdev);
  
#line 3353 
  if ((unsigned int)lio->linfo.link.s.status != 0U) {
    
#line 3354 
    netif_carrier_on(netdev);
    
#line 3355 
    start_txq(netdev);
  }
  else 
#line 3357 
       netif_carrier_off(netdev);
  
#line 3360 
  ifstate_set(lio,2);
  {
    
#line 3362 
    struct _ddebug descriptor_3 = {.modname = "liquidio", .function = "setup_nic_devices", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c", .format = "NIC ifidx:%d Setup successful\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3363U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 3362 
    if ((long)(((int)descriptor_3.flags & 1) != 0) != 0L) 
#line 3362 
                                                          __dynamic_dev_dbg(& descriptor_3,(struct device const *)(& (octeon_dev->pci_dev)->dev),"NIC ifidx:%d Setup successful\n",(int)i); else ;
  }
  
#line 3365 
  octeon_free_soft_command(octeon_dev,sc);
  
#line 3156 
  i = (u8)((int)i + 1);
  ldv_55929: 
#line 3157 
  ;
  
#line 3156 
  if ((unsigned int)i < octeon_dev->ifcount) 
#line 3158 
                                             goto ldv_55928; else 
#line 3161 
                                                                  goto ldv_55930;
  ldv_55930: 
#line 3162 
  ;
  
#line 3368 
  __retres = 0;
  
#line 3368 
  goto return_label;
  setup_nic_dev_fail: 
#line 3370 
  ;
  
#line 3372 
  octeon_free_soft_command(octeon_dev,sc);
  
#line 3374 
  goto ldv_55932;
  ldv_55931: 
#line 3375 
  ;
  
#line 3375 
  dev_err((struct device const *)(& (octeon_dev->pci_dev)->dev),"NIC ifidx:%d Setup failed\n",(int)i);
  
#line 3377 
  liquidio_destroy_nic_device(octeon_dev,(int)i);
  ldv_55932: 
#line 3378 
  ;
  
#line 3374 
  tmp_15 = i;
  
#line 3374 
  i = (u8)((int)i - 1);
  
#line 3374 
  ;
  
#line 3374 
  if ((unsigned int)tmp_15 != 0U) 
#line 3376 
                                  goto ldv_55931; else 
#line 3379 
                                                       goto ldv_55933;
  ldv_55933: 
#line 3380 
  ;
  
#line 3379 
  __retres = -19;
  return_label: 
#line 3379 
                return __retres;
}


#line 3389  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int liquidio_init_nic_module(struct octeon_device *oct)
{
  int __retres;
  struct oct_intrmod_cfg *intrmod_cfg;
  struct octeon_config *tmp;
  
#line 3392 
  int retval = 0;
  
#line 3393 
  tmp = octeon_get_conf(oct);
  
#line 3393 
  int num_nic_ports = tmp->num_nic_ports;
  {
    
#line 3395 
    struct _ddebug descriptor = {.modname = "liquidio", .function = "liquidio_init_nic_module", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c", .format = "Initializing network interfaces\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3395U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 3395 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 3395 
                                                        __dynamic_dev_dbg(& descriptor,(struct device const *)(& (oct->pci_dev)->dev),"Initializing network interfaces\n"); else ;
  }
  
#line 3401 
  oct->ifcount = (unsigned int)num_nic_ports;
  
#line 3403 
  memset((void *)(& oct->props),0,(unsigned long)num_nic_ports * 8UL);
  
#line 3406 
  retval = setup_nic_devices(oct);
  
#line 3407 
  if (retval != 0) {
    
#line 3408 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Setup NIC devices failed\n");
    
#line 3409 
    goto octnet_init_failure;
  }
  else ;
  
#line 3412 
  liquidio_ptp_init(oct);
  
#line 3415 
  intrmod_cfg = & oct->intrmod;
  
#line 3416 
  intrmod_cfg->intrmod_enable = 1ULL;
  
#line 3417 
  intrmod_cfg->intrmod_check_intrvl = 1ULL;
  
#line 3418 
  intrmod_cfg->intrmod_maxpkt_ratethr = 196608ULL;
  
#line 3419 
  intrmod_cfg->intrmod_minpkt_ratethr = 9216ULL;
  
#line 3420 
  intrmod_cfg->intrmod_maxcnt_trigger = 384ULL;
  
#line 3421 
  intrmod_cfg->intrmod_maxtmr_trigger = 128ULL;
  
#line 3422 
  intrmod_cfg->intrmod_mintmr_trigger = 32ULL;
  
#line 3423 
  intrmod_cfg->intrmod_mincnt_trigger = 1ULL;
  {
    
#line 3425 
    struct _ddebug descriptor_0 = {.modname = "liquidio", .function = "liquidio_init_nic_module", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c", .format = "Network interfaces ready\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3425U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 3425 
    if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 3425 
                                                          __dynamic_dev_dbg(& descriptor_0,(struct device const *)(& (oct->pci_dev)->dev),"Network interfaces ready\n"); else ;
  }
  
#line 3427 
  __retres = retval;
  
#line 3427 
  goto return_label;
  octnet_init_failure: 
#line 3429 
  ;
  
#line 3431 
  oct->ifcount = 0U;
  
#line 3433 
  __retres = retval;
  return_label: 
#line 3433 
                return __retres;
}


#line 3441  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static void nic_starter(struct work_struct *work)
{
  struct octeon_device *oct;
  int tmp;
  int tmp_0;
  
#line 3444 
  struct cavium_wk *wk = (struct cavium_wk *)work;
  
#line 3446 
  oct = (struct octeon_device *)wk->ctxptr;
  
#line 3448 
  tmp = atomic_read((atomic_t const *)(& oct->status));
  
#line 3448 
  if (tmp == 11) 
#line 3449 
                 goto return_label; else ;
  
#line 3456 
  tmp_0 = atomic_read((atomic_t const *)(& oct->status));
  
#line 3456 
  if (tmp_0 != 10) {
    
#line 3457 
    ldv_schedule_delayed_work_104(& oct->nic_poll_work.work,100UL);
    
#line 3459 
    goto return_label;
  }
  else ;
  
#line 3462 
  atomic_set(& oct->status,11);
  
#line 3464 
  if (oct->app_mode == 1U) {
    int tmp_1;
    {
      
#line 3465 
      struct _ddebug descriptor = {.modname = "liquidio", .function = "nic_starter", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c", .format = "Starting NIC module\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3465U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 3465 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 3465 
                                                          __dynamic_dev_dbg(& descriptor,(struct device const *)(& (oct->pci_dev)->dev),"Starting NIC module\n"); else ;
    }
    
#line 3467 
    tmp_1 = liquidio_init_nic_module(oct);
    
#line 3467 
    if (tmp_1 != 0) 
#line 3468 
                    dev_err((struct device const *)(& (oct->pci_dev)->dev),"NIC initialization failed\n"); else 
                                                                    
#line 3470 
                                                                    handshake[oct->octeon_id].started_ok = 1;
  }
  else 
#line 3472 
       dev_err((struct device const *)(& (oct->pci_dev)->dev),"Unexpected application running on NIC (%d). Check firmware.\n",oct->app_mode);
  
#line 3477 
  complete(& handshake[oct->octeon_id].started);
  return_label: 
#line 3478 
                return;
}


#line 3484  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static int octeon_device_init(struct octeon_device *octeon_dev)
{
  int __retres;
  int j;
  int ret;
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  int tmp_4;
  int tmp_5;
  int tmp_6;
  int tmp_7;
  
#line 3487 
  struct octeon_device_priv *oct_priv = (struct octeon_device_priv *)octeon_dev->priv;
  
#line 3489 
  atomic_set(& octeon_dev->status,0);
  
#line 3494 
  tmp = octeon_pci_os_setup(octeon_dev);
  
#line 3494 
  if (tmp != 0) {
    
#line 3495 
    __retres = 1;
    
#line 3495 
    goto return_label;
  }
  else ;
  
#line 3498 
  tmp_0 = octeon_chip_specific_setup(octeon_dev);
  
#line 3498 
  if (tmp_0 != 0) {
    
#line 3499 
    dev_err((struct device const *)(& (octeon_dev->pci_dev)->dev),"Chip specific setup failed\n");
    
#line 3500 
    __retres = 1;
    
#line 3500 
    goto return_label;
  }
  else ;
  
#line 3503 
  atomic_set(& octeon_dev->status,1);
  
#line 3505 
  octeon_dev->app_mode = 2U;
  
#line 3508 
  tmp_1 = (*(octeon_dev->fn_list.soft_reset))(octeon_dev);
  
#line 3508 
  if (tmp_1 != 0) {
    
#line 3509 
    __retres = 1;
    
#line 3509 
    goto return_label;
  }
  else ;
  
#line 3514 
  tmp_2 = octeon_init_dispatch_list(octeon_dev);
  
#line 3514 
  if (tmp_2 != 0) {
    
#line 3515 
    __retres = 1;
    
#line 3515 
    goto return_label;
  }
  else ;
  
#line 3517 
  octeon_register_dispatch_fn(octeon_dev,(unsigned short)1,(unsigned short)1,& octeon_core_drv_init,(void *)octeon_dev);
  {
    struct lock_class_key __key;
    
#line 3522 
    __init_work(& octeon_dev->nic_poll_work.work.work,0);
    
#line 3522 
    atomic_long_t __constr_expr_38 = {.counter = WORK_STRUCT_NO_POOL_0};
    
#line 3522 
    octeon_dev->nic_poll_work.work.work.data = __constr_expr_38;
    
#line 3522 
    lockdep_init_map(& octeon_dev->nic_poll_work.work.work.lockdep_map,"(&(&octeon_dev->nic_poll_work.work)->work)",& __key,0);
    
#line 3522 
    INIT_LIST_HEAD(& octeon_dev->nic_poll_work.work.work.entry);
    
#line 3522 
    octeon_dev->nic_poll_work.work.work.func = & nic_starter;
  }
  {
    struct lock_class_key __key_0;
    
#line 3522 
    init_timer_key(& octeon_dev->nic_poll_work.work.timer,2097152U,"(&(&octeon_dev->nic_poll_work.work)->timer)",& __key_0);
  }
  
#line 3522 
  octeon_dev->nic_poll_work.work.timer.function = & delayed_work_timer_fn;
  
#line 3522 
  octeon_dev->nic_poll_work.work.timer.data = (unsigned long)(& octeon_dev->nic_poll_work.work);
  
#line 3523 
  octeon_dev->nic_poll_work.ctxptr = (void *)octeon_dev;
  
#line 3524 
  ldv_schedule_delayed_work_105(& octeon_dev->nic_poll_work.work,100UL);
  
#line 3527 
  atomic_set(& octeon_dev->status,2);
  
#line 3529 
  octeon_set_io_queues_off(octeon_dev);
  
#line 3532 
  tmp_3 = octeon_setup_instr_queues(octeon_dev);
  
#line 3532 
  if (tmp_3 != 0) {
    
#line 3533 
    dev_err((struct device const *)(& (octeon_dev->pci_dev)->dev),"instruction queue initialization failed\n");
    
#line 3536 
    j = 0;
    
#line 3536 
    goto ldv_55961;
    ldv_55960: 
#line 3537 
    ;
    
#line 3537 
    octeon_delete_instr_queue(octeon_dev,(unsigned int)j);
    
#line 3536 
    j += 1;
    ldv_55961: 
#line 3537 
    ;
    
#line 3536 
    if (octeon_dev->num_iqs > (unsigned int)j) 
#line 3538 
                                               goto ldv_55960; else 
#line 3541 
                                                                    goto ldv_55962;
    ldv_55962: 
#line 3542 
    ;
    
#line 3538 
    __retres = 1;
    
#line 3538 
    goto return_label;
  }
  else ;
  
#line 3540 
  atomic_set(& octeon_dev->status,3);
  
#line 3544 
  tmp_4 = octeon_setup_sc_buffer_pool(octeon_dev);
  
#line 3544 
  if (tmp_4 != 0) {
    
#line 3545 
    dev_err((struct device const *)(& (octeon_dev->pci_dev)->dev),"sc buffer pool allocation failed\n");
    
#line 3546 
    __retres = 1;
    
#line 3546 
    goto return_label;
  }
  else ;
  
#line 3548 
  atomic_set(& octeon_dev->status,4);
  
#line 3553 
  tmp_5 = octeon_setup_response_list(octeon_dev);
  
#line 3553 
  if (tmp_5 != 0) {
    
#line 3554 
    dev_err((struct device const *)(& (octeon_dev->pci_dev)->dev),"Response list allocation failed\n");
    
#line 3555 
    __retres = 1;
    
#line 3555 
    goto return_label;
  }
  else ;
  
#line 3557 
  atomic_set(& octeon_dev->status,5);
  
#line 3559 
  tmp_6 = octeon_setup_output_queues(octeon_dev);
  
#line 3559 
  if (tmp_6 != 0) {
    
#line 3560 
    dev_err((struct device const *)(& (octeon_dev->pci_dev)->dev),"Output queue initialization failed\n");
    
#line 3562 
    j = 0;
    
#line 3562 
    goto ldv_55964;
    ldv_55963: 
#line 3563 
    ;
    
#line 3563 
    octeon_delete_droq(octeon_dev,(unsigned int)j);
    
#line 3562 
    j += 1;
    ldv_55964: 
#line 3563 
    ;
    
#line 3562 
    if (octeon_dev->num_oqs > (unsigned int)j) 
#line 3564 
                                               goto ldv_55963; else 
#line 3567 
                                                                    goto ldv_55965;
    ldv_55965: 
#line 3568 
    ;
  }
  else ;
  
#line 3566 
  atomic_set(& octeon_dev->status,6);
  
#line 3572 
  ret = (*(octeon_dev->fn_list.setup_device_regs))(octeon_dev);
  
#line 3573 
  if (ret != 0) {
    
#line 3574 
    dev_err((struct device const *)(& (octeon_dev->pci_dev)->dev),"Failed to configure device registers\n");
    
#line 3576 
    __retres = ret;
    
#line 3576 
    goto return_label;
  }
  else ;
  {
    
#line 3580 
    struct _ddebug descriptor = {.modname = "liquidio", .function = "octeon_device_init", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c", .format = "Initializing droq tasklet\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3580U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 3580 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 3580 
                                                        __dynamic_dev_dbg(& descriptor,(struct device const *)(& (octeon_dev->pci_dev)->dev),"Initializing droq tasklet\n"); else ;
  }
  
#line 3581 
  ldv_tasklet_init_106(& oct_priv->droq_tasklet,& octeon_droq_bh,(unsigned long)octeon_dev);
  
#line 3586 
  octeon_setup_interrupt(octeon_dev);
  
#line 3589 
  (*(octeon_dev->fn_list.enable_interrupt))(octeon_dev->chip);
  
#line 3592 
  (*(octeon_dev->fn_list.enable_io_queues))(octeon_dev);
  
#line 3594 
  atomic_set(& octeon_dev->status,7);
  {
    
#line 3596 
    struct _ddebug descriptor_0 = {.modname = "liquidio", .function = "octeon_device_init", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c", .format = "Waiting for DDR initialization...\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3596U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 3596 
    if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 3596 
                                                          __dynamic_dev_dbg(& descriptor_0,(struct device const *)(& (octeon_dev->pci_dev)->dev),"Waiting for DDR initialization...\n"); else ;
  }
  
#line 3598 
  if (ddr_timeout == 0) 
#line 3599 
                        _dev_info((struct device const *)(& (octeon_dev->pci_dev)->dev),"WAITING. Set ddr_timeout to non-zero value to proceed with initialization.\n"); else ;
  
#line 3603 
  schedule_timeout_uninterruptible(750L);
  
#line 3606 
  ret = octeon_wait_for_ddr_init(octeon_dev,(u32 *)(& ddr_timeout));
  
#line 3607 
  if (ret != 0) {
    
#line 3608 
    dev_err((struct device const *)(& (octeon_dev->pci_dev)->dev),"DDR not initialized. Please confirm that board is configured to boot from Flash, ret: %d\n",ret);
    
#line 3611 
    __retres = 1;
    
#line 3611 
    goto return_label;
  }
  else ;
  
#line 3614 
  tmp_7 = octeon_wait_for_bootloader(octeon_dev,1000U);
  
#line 3614 
  if (tmp_7 != 0) {
    
#line 3615 
    dev_err((struct device const *)(& (octeon_dev->pci_dev)->dev),"Board not responding\n");
    
#line 3616 
    __retres = 1;
    
#line 3616 
    goto return_label;
  }
  else ;
  {
    
#line 3619 
    struct _ddebug descriptor_1 = {.modname = "liquidio", .function = "octeon_device_init", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c", .format = "Initializing consoles\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3619U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 3619 
    if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) 
#line 3619 
                                                          __dynamic_dev_dbg(& descriptor_1,(struct device const *)(& (octeon_dev->pci_dev)->dev),"Initializing consoles\n"); else ;
  }
  
#line 3620 
  ret = octeon_init_consoles(octeon_dev);
  
#line 3621 
  if (ret != 0) {
    
#line 3622 
    dev_err((struct device const *)(& (octeon_dev->pci_dev)->dev),"Could not access board consoles\n");
    
#line 3623 
    __retres = 1;
    
#line 3623 
    goto return_label;
  }
  else ;
  
#line 3625 
  ret = octeon_add_console(octeon_dev,0U);
  
#line 3626 
  if (ret != 0) {
    
#line 3627 
    dev_err((struct device const *)(& (octeon_dev->pci_dev)->dev),"Could not access board console\n");
    
#line 3628 
    __retres = 1;
    
#line 3628 
    goto return_label;
  }
  else ;
  
#line 3631 
  atomic_set(& octeon_dev->status,8);
  {
    
#line 3633 
    struct _ddebug descriptor_2 = {.modname = "liquidio", .function = "octeon_device_init", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c", .format = "Loading firmware\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3633U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 3633 
    if ((long)(((int)descriptor_2.flags & 1) != 0) != 0L) 
#line 3633 
                                                          __dynamic_dev_dbg(& descriptor_2,(struct device const *)(& (octeon_dev->pci_dev)->dev),"Loading firmware\n"); else ;
  }
  
#line 3634 
  ret = load_firmware(octeon_dev);
  
#line 3635 
  if (ret != 0) {
    
#line 3636 
    dev_err((struct device const *)(& (octeon_dev->pci_dev)->dev),"Could not load firmware to board\n");
    
#line 3637 
    __retres = 1;
    
#line 3637 
    goto return_label;
  }
  else ;
  
#line 3640 
  handshake[octeon_dev->octeon_id].init_ok = 1;
  
#line 3641 
  complete(& handshake[octeon_dev->octeon_id].init);
  
#line 3643 
  atomic_set(& octeon_dev->status,9);
  
#line 3648 
  j = 0;
  
#line 3648 
  goto ldv_55972;
  ldv_55971: 
#line 3649 
  ;
  
#line 3649 
  writel((octeon_dev->droq[j])->max_count,(void volatile *)(octeon_dev->droq[j])->pkts_credit_reg);
  
#line 3648 
  j += 1;
  ldv_55972: 
#line 3649 
  ;
  
#line 3648 
  if (octeon_dev->num_oqs > (unsigned int)j) 
#line 3650 
                                             goto ldv_55971; else 
#line 3653 
                                                                  goto ldv_55973;
  ldv_55973: 
#line 3654 
  ;
  
#line 3654 
  __retres = 0;
  return_label: 
#line 3654 
                return __retres;
}


#line 3660  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/lio_main.c"
static void liquidio_exit(void)
{
  
#line 3662 
  liquidio_deinit_pci();
  
#line 3664 
  printk("\001");
  
#line 3665 
  return;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
struct pci_driver *ldv_emg_alias_liquidio_pci_driver_2 = & liquidio_pci_driver;

#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
void (*ldv_emg_alias_None_2)(unsigned long ) = & octeon_droq_bh;

#line 60 
void ldv_emg_tasklet_init(struct tasklet_struct *arg0, void (*arg1)(unsigned long ), unsigned long arg2);


#line 61 
int ldv_emg___pci_register_driver(struct pci_driver *arg0, struct module *arg1, char *arg2);


#line 62 
_Bool ldv_emg_schedule_delayed_work(struct delayed_work *arg0, unsigned long arg1);


#line 63 
void ldv_emg_tasklet_schedule(struct tasklet_struct *arg0);


#line 64 
void ldv_emg_pci_unregister_driver(struct pci_driver *arg0);


#line 65 
struct net_device *ldv_emg_alloc_etherdev_mqs(int arg0, unsigned int arg1, unsigned int arg2);


#line 66 
void ldv_emg_unregister_netdev(struct net_device *arg0);


#line 67 
void ldv_emg_free_irq(unsigned int arg0, void *arg1);


#line 69 
int ldv_emg_request_irq(unsigned int arg0, enum irqreturn (*arg1)(int , void *), unsigned long arg2, char *arg3, void *arg4);


#line 70 
void ldv_emg_free_netdev(struct net_device *arg0);


#line 71 
int ldv_emg_register_netdev(struct net_device *arg0);


#line 75  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
int ldv_emg_wrapper_liquidio_suspend_3(struct pci_dev *arg0, struct pm_message arg1)
{
  int tmp;
  
#line 76 
  tmp = liquidio_suspend(arg0,arg1);
  
#line 76 
  return tmp;
}


#line 80  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
void ldv_emg_wrapper_liquidio_tx_timeout_19(struct net_device *arg0)
{
  
#line 81 
  liquidio_tx_timeout(arg0);
  
#line 82 
  return;
}


#line 85  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
int ldv_emg_wrapper_liquidio_set_mac_17(struct net_device *arg0, void *arg1)
{
  int tmp;
  
#line 86 
  tmp = liquidio_set_mac(arg0,arg1);
  
#line 86 
  return tmp;
}


#line 90  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
int ldv_emg_wrapper_liquidio_stop_2(struct net_device *arg0)
{
  int tmp;
  
#line 91 
  tmp = liquidio_stop(arg0);
  
#line 91 
  return tmp;
}


#line 95  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
unsigned long long ldv_emg_wrapper_liquidio_fix_features_14(struct net_device *arg0, unsigned long long arg1)
{
  unsigned long long tmp;
  
#line 96 
  tmp = liquidio_fix_features(arg0,arg1);
  
#line 96 
  return tmp;
}


#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
int ldv_emg_wrapper_liquidio_set_features_12(struct net_device *arg0, unsigned long long arg1)
{
  int tmp;
  
#line 101 
  tmp = liquidio_set_features(arg0,arg1);
  
#line 101 
  return tmp;
}


#line 105  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
void ldv_emg_wrapper_liquidio_set_mcast_list_7(struct net_device *arg0)
{
  
#line 106 
  liquidio_set_mcast_list(arg0);
  
#line 107 
  return;
}


#line 110  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
void ldv_emg_liquidio_exit(void)
{
  
#line 111 
  liquidio_exit();
  
#line 112 
  return;
}


#line 114  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
int ldv_emg_wrapper_liquidio_probe_2(struct pci_dev *arg0, struct pci_device_id *arg1)
{
  int tmp;
  
#line 115 
  tmp = liquidio_probe(arg0,(struct pci_device_id const *)arg1);
  
#line 115 
  return tmp;
}


#line 119  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
int ldv_emg_wrapper_liquidio_open_2(struct net_device *arg0)
{
  int tmp;
  
#line 120 
  tmp = liquidio_open(arg0);
  
#line 120 
  return tmp;
}


#line 124  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
int ldv_emg_wrapper_liquidio_xmit_16(struct sk_buff *arg0, struct net_device *arg1)
{
  int tmp;
  
#line 125 
  tmp = liquidio_xmit(arg0,arg1);
  
#line 125 
  return tmp;
}


#line 129  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
void ldv_emg_wrapper_liquidio_remove_4(struct pci_dev *arg0)
{
  
#line 130 
  liquidio_remove(arg0);
  
#line 131 
  return;
}


#line 134  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
int ldv_emg_wrapper_liquidio_resume_5(struct pci_dev *arg0)
{
  int tmp;
  
#line 135 
  tmp = liquidio_resume(arg0);
  
#line 135 
  return tmp;
}


#line 139  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
struct net_device_stats *ldv_emg_wrapper_liquidio_get_stats_23(struct net_device *arg0)
{
  struct net_device_stats *tmp;
  
#line 140 
  tmp = liquidio_get_stats(arg0);
  
#line 140 
  return tmp;
}


#line 144  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
enum irqreturn ldv_emg_wrapper_liquidio_intr_handler_2(int arg0, void *arg1)
{
  enum irqreturn tmp;
  
#line 145 
  tmp = liquidio_intr_handler(arg0,arg1);
  
#line 145 
  return tmp;
}


#line 149  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
int ldv_emg_wrapper_liquidio_change_mtu_10(struct net_device *arg0, int arg1)
{
  int tmp;
  
#line 150 
  tmp = liquidio_change_mtu(arg0,arg1);
  
#line 150 
  return tmp;
}


#line 154  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
int ldv_emg_wrapper_liquidio_ioctl_20(struct net_device *arg0, struct ifreq *arg1, int arg2)
{
  int tmp;
  
#line 155 
  tmp = liquidio_ioctl(arg0,arg1,arg2);
  
#line 155 
  return tmp;
}


#line 159  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
int ldv_emg_liquidio_init(void)
{
  int tmp;
  
#line 160 
  tmp = liquidio_init();
  
#line 160 
  return tmp;
}


#line 178  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static bool IS_ERR(void const *ptr)
{
  bool __retres;
  long ret;
  
#line 182 
  ret = ldv_is_err(ptr);
  
#line 183 
  __retres = (_Bool)(ret != 0L);
  
#line 183 
  return __retres;
}


#line 585  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static void *kmalloc_1(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 588 
  tmp = ldv_kmalloc(size,flags);
  
#line 588 
  return tmp;
}


#line 852  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static void ldv_tasklet_schedule_74(struct tasklet_struct *t)
{
  
#line 856 
  ldv_emg_tasklet_schedule(t);
  
#line 857 
  return;
}


#line 860  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static void ldv_tasklet_schedule_75(struct tasklet_struct *t)
{
  
#line 864 
  ldv_emg_tasklet_schedule(t);
  
#line 865 
  return;
}


#line 868  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static void ldv_spin_lock_bh_76_0(spinlock_t *lock)
{
  
#line 872 
  ldv_spin_model_lock((char *)"lock_of_octeon_instr_queue");
  
#line 874 
  spin_lock_bh_2(lock);
  
#line 875 
  return;
}


#line 878  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static void ldv_spin_unlock_bh_77_1(spinlock_t *lock)
{
  
#line 882 
  ldv_spin_model_unlock((char *)"lock_of_octeon_instr_queue");
  
#line 884 
  spin_unlock_bh_2(lock);
  
#line 885 
  return;
}


#line 888  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static void ldv_free_irq_78(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  
#line 892 
  ldv_emg_free_irq(ldv_func_arg1,ldv_func_arg2);
  
#line 893 
  return;
}


#line 896  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static int ldv___pci_register_driver_79(struct pci_driver *ldv_func_arg1, struct module *ldv_func_arg2, char const *ldv_func_arg3)
{
  int tmp;
  
#line 900 
  tmp = ldv_emg___pci_register_driver(ldv_func_arg1,ldv_func_arg2,(char *)ldv_func_arg3);
  
#line 900 
  return tmp;
}


#line 904  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static void ldv_pci_unregister_driver_80(struct pci_driver *ldv_func_arg1)
{
  
#line 908 
  ldv_emg_pci_unregister_driver(ldv_func_arg1);
  
#line 909 
  return;
}


#line 912  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static void ldv_tasklet_schedule_81(struct tasklet_struct *t)
{
  
#line 916 
  ldv_emg_tasklet_schedule(t);
  
#line 917 
  return;
}


#line 920  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static int ldv_request_irq_82(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev)
{
  int tmp;
  
#line 924 
  tmp = ldv_emg_request_irq(irq,handler,flags,(char *)name,dev);
  
#line 924 
  return tmp;
}


#line 928  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static void ldv_free_irq_83(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  
#line 932 
  ldv_emg_free_irq(ldv_func_arg1,ldv_func_arg2);
  
#line 933 
  return;
}


#line 936  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static void ldv_unregister_netdev_84(struct net_device *ldv_func_arg1)
{
  
#line 940 
  ldv_emg_unregister_netdev(ldv_func_arg1);
  
#line 941 
  return;
}


#line 944  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static void ldv_free_netdev_85(struct net_device *ldv_func_arg1)
{
  
#line 948 
  ldv_emg_free_netdev(ldv_func_arg1);
  
#line 949 
  return;
}


#line 952  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static void ldv_spin_lock_86(spinlock_t *lock)
{
  
#line 956 
  ldv_spin_model_lock((char *)"lock_of_lio");
  
#line 958 
  spin_lock_1(lock);
  
#line 959 
  return;
}


#line 962  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static void ldv_spin_unlock_87_0(spinlock_t *lock)
{
  
#line 966 
  ldv_spin_model_unlock((char *)"lock_of_lio");
  
#line 968 
  spin_unlock_1(lock);
  
#line 969 
  return;
}


#line 972  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static void ldv_spin_lock_88_0(spinlock_t *lock)
{
  
#line 976 
  ldv_spin_model_lock((char *)"lock_of_lio");
  
#line 978 
  spin_lock_1(lock);
  
#line 979 
  return;
}


#line 982  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static void ldv_spin_unlock_89_0(spinlock_t *lock)
{
  
#line 986 
  ldv_spin_model_unlock((char *)"lock_of_lio");
  
#line 988 
  spin_unlock_1(lock);
  
#line 989 
  return;
}


#line 992  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static void ldv___ldv_spin_lock_90(spinlock_t *ldv_func_arg1)
{
  
#line 996 
  ldv_spin_model_lock((char *)"ptp_lock_of_lio");
  
#line 998 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 999 
  return;
}


#line 1002  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static void ldv_spin_unlock_irqrestore_91(spinlock_t *lock, unsigned long flags)
{
  
#line 1006 
  ldv_spin_model_unlock((char *)"ptp_lock_of_lio");
  
#line 1008 
  spin_unlock_irqrestore_1(lock,flags);
  
#line 1009 
  return;
}


#line 1012  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static void ldv___ldv_spin_lock_92(spinlock_t *ldv_func_arg1)
{
  
#line 1016 
  ldv_spin_model_lock((char *)"ptp_lock_of_lio");
  
#line 1018 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 1019 
  return;
}


#line 1022  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static void ldv_spin_unlock_irqrestore_93(spinlock_t *lock, unsigned long flags)
{
  
#line 1026 
  ldv_spin_model_unlock((char *)"ptp_lock_of_lio");
  
#line 1028 
  spin_unlock_irqrestore_1(lock,flags);
  
#line 1029 
  return;
}


#line 1032  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static void ldv___ldv_spin_lock_94(spinlock_t *ldv_func_arg1)
{
  
#line 1036 
  ldv_spin_model_lock((char *)"ptp_lock_of_lio");
  
#line 1038 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 1039 
  return;
}


#line 1042  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static void ldv_spin_unlock_irqrestore_95(spinlock_t *lock, unsigned long flags)
{
  
#line 1046 
  ldv_spin_model_unlock((char *)"ptp_lock_of_lio");
  
#line 1048 
  spin_unlock_irqrestore_1(lock,flags);
  
#line 1049 
  return;
}


#line 1052  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static void ldv___ldv_spin_lock_96(spinlock_t *ldv_func_arg1)
{
  
#line 1056 
  ldv_spin_model_lock((char *)"ptp_lock_of_lio");
  
#line 1058 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 1059 
  return;
}


#line 1062  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static void ldv_spin_unlock_irqrestore_97(spinlock_t *lock, unsigned long flags)
{
  
#line 1066 
  ldv_spin_model_unlock((char *)"ptp_lock_of_lio");
  
#line 1068 
  spin_unlock_irqrestore_1(lock,flags);
  
#line 1069 
  return;
}


#line 1072  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static bool ldv_queue_delayed_work_98(struct workqueue_struct *wq, struct delayed_work *dwork, unsigned long delay)
{
  bool __retres;
  bool tmp;
  
#line 1076 
  tmp = ldv_emg_queue_delayed_work(wq,dwork,delay);
  
#line 1076 
  __retres = tmp != 0;
  
#line 1076 
  return __retres;
}


#line 1080  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static bool ldv_queue_delayed_work_99(struct workqueue_struct *wq, struct delayed_work *dwork, unsigned long delay)
{
  bool __retres;
  bool tmp;
  
#line 1084 
  tmp = ldv_emg_queue_delayed_work(wq,dwork,delay);
  
#line 1084 
  __retres = tmp != 0;
  
#line 1084 
  return __retres;
}


#line 1088  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static void ldv_spin_lock_100(spinlock_t *lock)
{
  
#line 1092 
  ldv_spin_model_lock((char *)"lock_of_lio");
  
#line 1094 
  spin_lock_1(lock);
  
#line 1095 
  return;
}


#line 1098  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static void ldv_spin_unlock_101(spinlock_t *lock)
{
  
#line 1102 
  ldv_spin_model_unlock((char *)"lock_of_lio");
  
#line 1104 
  spin_unlock_1(lock);
  
#line 1105 
  return;
}


#line 1108  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static struct net_device *ldv_alloc_etherdev_mqs_102(int ldv_func_arg1, unsigned int ldv_func_arg2, unsigned int ldv_func_arg3)
{
  struct net_device *tmp;
  
#line 1112 
  tmp = ldv_emg_alloc_etherdev_mqs(ldv_func_arg1,ldv_func_arg2,ldv_func_arg3);
  
#line 1112 
  return tmp;
}


#line 1116  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static int ldv_register_netdev_103(struct net_device *ldv_func_arg1)
{
  int tmp;
  
#line 1120 
  tmp = ldv_emg_register_netdev(ldv_func_arg1);
  
#line 1120 
  return tmp;
}


#line 1124  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static bool ldv_schedule_delayed_work_104(struct delayed_work *dwork, unsigned long delay)
{
  bool __retres;
  bool tmp;
  
#line 1128 
  tmp = ldv_emg_schedule_delayed_work(dwork,delay);
  
#line 1128 
  __retres = tmp != 0;
  
#line 1128 
  return __retres;
}


#line 1132  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static bool ldv_schedule_delayed_work_105(struct delayed_work *dwork, unsigned long delay)
{
  bool __retres;
  bool tmp;
  
#line 1136 
  tmp = ldv_emg_schedule_delayed_work(dwork,delay);
  
#line 1136 
  __retres = tmp != 0;
  
#line 1136 
  return __retres;
}


#line 1140  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_lio_main.c.aux"
static void ldv_tasklet_init_106(struct tasklet_struct *ldv_func_arg1, void (*ldv_func_arg2)(unsigned long ), unsigned long ldv_func_arg3)
{
  
#line 1144 
  ldv_emg_tasklet_init(ldv_func_arg1,ldv_func_arg2,ldv_func_arg3);
  
#line 1145 
  return;
}


#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_main.h"
__inline static void octeon_swap_8B_data_3(u64 *data, u32 blocks)
{
  
#line 59 
  goto ldv_45849;
  ldv_45848: 
#line 60 
  ;
  
#line 60 
  __swab64s(data);
  
#line 61 
  blocks -= 1U;
  
#line 62 
  data += 1;
  ldv_45849: 
#line 63 
  ;
  
#line 59 
  if (blocks != 0U) 
#line 61 
                    goto ldv_45848; else 
#line 64 
                                         goto ldv_45850;
  ldv_45850: 
#line 65 
  ;
  
#line 66 
  return;
}


#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_nic.c"
void *octeon_alloc_soft_command_resp(struct octeon_device *oct, struct octeon_instr_64B *cmd, size_t rdatasize)
{
  void *__retres;
  struct octeon_soft_command *sc;
  struct octeon_instr_ih *ih;
  struct octeon_instr_irh *irh;
  struct octeon_instr_rdp *rdp;
  
#line 55 
  sc = octeon_alloc_soft_command(oct,0U,(unsigned int)rdatasize,0U);
  
#line 58 
  if (sc == (struct octeon_soft_command *)0) {
    
#line 59 
    __retres = (void *)0;
    
#line 59 
    goto return_label;
  }
  else ;
  
#line 62 
  memcpy((void *)(& sc->cmd),(void const *)cmd,64UL);
  
#line 67 
  ih = (struct octeon_instr_ih *)(& sc->cmd.ih);
  
#line 68 
  ih->fsz = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))))40U;
  
#line 70 
  irh = (struct octeon_instr_irh *)(& sc->cmd.irh);
  
#line 71 
  irh->rflag = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U;
  
#line 72 
  irh->len = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U;
  
#line 74 
  rdp = (struct octeon_instr_rdp *)(& sc->cmd.rdp);
  
#line 75 
  rdp->pcie_port = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))oct->pcie_port;
  
#line 76 
  rdp->rlen = (unsigned long long __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))))rdatasize;
  
#line 78 
  *(sc->status_word) = 18446744073709551615ULL;
  
#line 80 
  sc->wait_time = 1000UL;
  
#line 81 
  sc->timeout = sc->wait_time + jiffies;
  
#line 83 
  __retres = (void *)sc;
  return_label: 
#line 83 
                return __retres;
}


#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_nic.c"
int octnet_send_nic_data_pkt(struct octeon_device *oct, struct octnic_data_pkt *ndata, u32 xmit_more)
{
  int ring_doorbell_0;
  int tmp;
  
#line 92 
  ring_doorbell_0 = xmit_more == 0U;
  
#line 94 
  tmp = octeon_send_command(oct,ndata->q_no,(unsigned int)ring_doorbell_0,(void *)(& ndata->cmd),ndata->buf,ndata->datasize,ndata->reqtype);
  
#line 94 
  return tmp;
}


#line 99  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_nic.c"
static void octnet_link_ctrl_callback(struct octeon_device *oct, u32 status, void *sc_ptr)
{
  struct octnic_ctrl_pkt *nctrl;
  
#line 103 
  struct octeon_soft_command *sc = (struct octeon_soft_command *)sc_ptr;
  
#line 106 
  nctrl = (struct octnic_ctrl_pkt *)sc->ctxptr;
  
#line 114 
  if (status == 0U && nctrl->cb_fn != (void (*)(void *))0) 
#line 115 
                                                           (*(nctrl->cb_fn))((void *)nctrl); else ;
  
#line 117 
  octeon_free_soft_command(oct,sc);
  
#line 118 
  return;
}


#line 121  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_nic.c"
__inline static struct octeon_soft_command *octnic_alloc_ctrl_pkt_sc(struct octeon_device *oct, struct octnic_ctrl_pkt *nctrl, struct octnic_ctrl_params nparams)
{
  struct octeon_soft_command *__retres;
  u8 *data;
  size_t rdatasize;
  int tmp;
  
#line 125 
  struct octeon_soft_command *sc = (struct octeon_soft_command *)0;
  
#line 128 
  u32 uddsize = 0U;
  
#line 128 
  u32 datasize = 0U;
  
#line 130 
  uddsize = (unsigned int)((int)nctrl->ncmd.s.more * 8);
  
#line 132 
  datasize = uddsize + 8U;
  
#line 133 
  if (nctrl->wait_time != 0UL) 
#line 133 
                               tmp = 16; else 
#line 133 
                                              tmp = 0;
  
#line 133 
  rdatasize = (unsigned long)tmp;
  
#line 135 
  sc = octeon_alloc_soft_command(oct,datasize,(unsigned int)rdatasize,320U);
  
#line 139 
  if (sc == (struct octeon_soft_command *)0) {
    
#line 140 
    __retres = (struct octeon_soft_command *)0;
    
#line 140 
    goto return_label;
  }
  else ;
  
#line 142 
  memcpy(sc->ctxptr,(void const *)nctrl,320UL);
  
#line 144 
  data = (u8 *)sc->virtdptr;
  
#line 146 
  memcpy((void *)data,(void const *)(& nctrl->ncmd),8UL);
  
#line 148 
  octeon_swap_8B_data_3((u64 *)data,1U);
  
#line 150 
  if (uddsize != 0U) 
#line 152 
                     memcpy((void *)(data + 8U),(void const *)(& nctrl->udd),(unsigned long)uddsize); else ;
  
#line 155 
  octeon_prepare_soft_command(oct,sc,(unsigned char)1,(unsigned char)3,0U,0ULL,0ULL);
  
#line 158 
  sc->callback = & octnet_link_ctrl_callback;
  
#line 159 
  sc->callback_arg = (void *)sc;
  
#line 160 
  sc->wait_time = nctrl->wait_time;
  
#line 162 
  __retres = sc;
  return_label: 
#line 162 
                return __retres;
}


#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_nic.c"
int octnet_send_nic_ctrl_pkt(struct octeon_device *oct, struct octnic_ctrl_pkt *nctrl, struct octnic_ctrl_params nparams)
{
  int __retres;
  int retval;
  
#line 171 
  struct octeon_soft_command *sc = (struct octeon_soft_command *)0;
  
#line 173 
  sc = octnic_alloc_ctrl_pkt_sc(oct,nctrl,nparams);
  
#line 174 
  if (sc == (struct octeon_soft_command *)0) {
    
#line 175 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"%s soft command alloc failed\n","octnet_send_nic_ctrl_pkt");
    
#line 177 
    __retres = -1;
    
#line 177 
    goto return_label;
  }
  else ;
  
#line 180 
  retval = octeon_send_soft_command(oct,sc);
  
#line 181 
  if (retval != 0) {
    
#line 182 
    octeon_free_soft_command(oct,sc);
    
#line 183 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"%s soft command send failed status: %x\n","octnet_send_nic_ctrl_pkt",retval);
    
#line 185 
    __retres = -1;
    
#line 185 
    goto return_label;
  }
  else ;
  
#line 188 
  __retres = retval;
  return_label: 
#line 188 
                return __retres;
}


#line 597  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
static bool ldv_schedule_delayed_work_73(struct delayed_work *dwork, unsigned long delay);


#line 601 
static bool ldv_schedule_delayed_work_74(struct delayed_work *dwork, unsigned long delay);


#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kmalloc_2(size_t size, gfp_t flags);


#line 572  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_device.h"
int octeon_console_read(struct octeon_device *oct, u32 console_num, char *buffer, u32 buf_size, u32 flags);


#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_mem_ops.h"
u64 octeon_read_device_mem64(struct octeon_device *oct, u64 coreaddr);


#line 47 
u32 octeon_read_device_mem32(struct octeon_device *oct, u64 coreaddr);


#line 55 
void octeon_write_device_mem32(struct octeon_device *oct, u64 coreaddr, u32 val);


#line 62 
void octeon_pci_read_core_mem(struct octeon_device *oct, u64 coreaddr, u8 *buf, u32 len);


#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_console.c"
static void octeon_remote_lock(void);


#line 50 
static void octeon_remote_unlock(void);


#line 51 
static u64 cvmx_bootmem_phy_named_block_find(struct octeon_device *oct, char const *name, u32 flags);


#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_console.c"
__inline static u64 __cvmx_bootmem_desc_get(struct octeon_device *oct, u64 base, u32 offset, u32 size)
{
  u64 __retres;
  
#line 210 
  base = ((unsigned long long)offset + base) | 9223372036854775808ULL;
  
#line 211 
  switch (size) {
    u32 tmp;
    u64 tmp_0;
    case (u32)4: 
#line 212 
    ;
    
#line 213 
    tmp = octeon_read_device_mem32(oct,base);
    
#line 213 
    __retres = (unsigned long long)tmp;
    
#line 213 
    goto return_label;
    case (u32)8: 
#line 214 
    ;
    
#line 215 
    tmp_0 = octeon_read_device_mem64(oct,base);
    
#line 215 
    __retres = tmp_0;
    
#line 215 
    goto return_label;
    default: 
#line 216 
    ;
    
#line 217 
    __retres = 0ULL;
    
#line 217 
    goto return_label;
  }
  return_label: 
#line 211 
                return __retres;
}


#line 231  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_console.c"
static void CVMX_BOOTMEM_NAMED_GET_NAME(struct octeon_device *oct, u64 addr, char *str, u32 len)
{
  
#line 236 
  addr += 16ULL;
  
#line 237 
  octeon_pci_read_core_mem(oct,addr,(u8 *)str,len);
  
#line 238 
  *(str + len) = (char)0;
  
#line 239 
  return;
}


#line 253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_console.c"
static int __cvmx_bootmem_check_version(struct octeon_device *oct, u32 exact_match)
{
  int __retres;
  u32 major_version;
  u32 minor_version;
  u64 tmp;
  u64 tmp_0;
  
#line 259 
  if (oct->bootmem_desc_addr == 0ULL) 
#line 260 
                                      oct->bootmem_desc_addr = octeon_read_device_mem64(oct,442624ULL); else ;
  
#line 264 
  tmp = __cvmx_bootmem_desc_get(oct,oct->bootmem_desc_addr,16U,4U);
  
#line 263 
  major_version = (unsigned int)tmp;
  
#line 266 
  tmp_0 = __cvmx_bootmem_desc_get(oct,oct->bootmem_desc_addr,20U,4U);
  
#line 265 
  minor_version = (unsigned int)tmp_0;
  {
    
#line 267 
    struct _ddebug descriptor = {.modname = "liquidio", .function = "__cvmx_bootmem_check_version", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_console.c", .format = "%s: major_version=%d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))268U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 267 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 267 
                                                        __dynamic_dev_dbg(& descriptor,(struct device const *)(& (oct->pci_dev)->dev),"%s: major_version=%d\n","__cvmx_bootmem_check_version",major_version); else ;
  }
  
#line 269 
  if (major_version > 3U || (exact_match != 0U && major_version != exact_match)) {
    
#line 271 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"bootmem ver mismatch %d.%d addr:0x%llx\n",major_version,minor_version,oct->bootmem_desc_addr);
    
#line 274 
    __retres = -1;
    
#line 274 
    goto return_label;
  }
  else {
    
#line 276 
    __retres = 0;
    
#line 276 
    goto return_label;
  }
  return_label: 
#line 269 
                return __retres;
}


#line 281  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_console.c"
static struct cvmx_bootmem_named_block_desc const *__cvmx_bootmem_find_named_block_flags(struct octeon_device *oct, char const *name, u32 flags)
{
  struct cvmx_bootmem_named_block_desc const *__retres;
  
#line 284 
  struct cvmx_bootmem_named_block_desc *desc = & oct->bootmem_named_block_desc;
  
#line 286 
  u64 named_addr = cvmx_bootmem_phy_named_block_find(oct,name,flags);
  
#line 288 
  if (named_addr != 0ULL) {
    
#line 289 
    desc->base_addr = __cvmx_bootmem_desc_get(oct,named_addr,0U,8U);
    
#line 291 
    desc->size = __cvmx_bootmem_desc_get(oct,named_addr,8U,8U);
    
#line 293 
    strncpy((char *)(& desc->name),name,128UL);
    
#line 294 
    desc->name[127UL] = (char)0;
    
#line 295 
    __retres = (struct cvmx_bootmem_named_block_desc const *)(& oct->bootmem_named_block_desc);
    
#line 295 
    goto return_label;
  }
  else {
    
#line 297 
    __retres = (struct cvmx_bootmem_named_block_desc const *)0;
    
#line 297 
    goto return_label;
  }
  return_label: 
#line 288 
                return __retres;
}


#line 301  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_console.c"
static u64 cvmx_bootmem_phy_named_block_find(struct octeon_device *oct, char const *name, u32 flags)
{
  int tmp_5;
  
#line 305 
  u64 result = 0ULL;
  
#line 308 
  tmp_5 = __cvmx_bootmem_check_version(oct,3U);
  
#line 308 
  if (tmp_5 == 0) {
    u32 i;
    u64 tmp_0;
    u64 tmp_1;
    
#line 310 
    u64 named_block_array_addr = __cvmx_bootmem_desc_get(oct,oct->bootmem_desc_addr,48U,8U);
    
#line 313 
    tmp_0 = __cvmx_bootmem_desc_get(oct,oct->bootmem_desc_addr,40U,4U);
    
#line 313 
    u32 num_blocks = (unsigned int)tmp_0;
    
#line 315 
    tmp_1 = __cvmx_bootmem_desc_get(oct,oct->bootmem_desc_addr,44U,4U);
    
#line 315 
    u32 name_length = (unsigned int)tmp_1;
    
#line 317 
    u64 named_addr = named_block_array_addr;
    
#line 319 
    i = 0U;
    
#line 319 
    goto ldv_46465;
    ldv_46464: 
#line 320 
    ;
    {
      
#line 320 
      u64 named_size = __cvmx_bootmem_desc_get(oct,named_addr,8U,8U);
      
#line 323 
      if (name != (char const *)0 && named_size != 0ULL) {
        int tmp_4;
        
#line 325 
        char *name_tmp = kmalloc_2((unsigned long)(name_length + 1U),208U);
        
#line 326 
        CVMX_BOOTMEM_NAMED_GET_NAME(oct,named_addr,name_tmp,name_length);
        
#line 329 
        tmp_4 = strncmp(name,(char const *)name_tmp,(unsigned long)name_length);
        
#line 329 
        if (tmp_4 == 0) {
          
#line 330 
          result = named_addr;
          
#line 331 
          kfree((void const *)name_tmp);
          
#line 332 
          goto ldv_46463;
        }
        else ;
        
#line 334 
        kfree((void const *)name_tmp);
      }
      else 
        
#line 335 
        if (name == (char const *)0 && named_size == 0ULL) {
          
#line 336 
          result = named_addr;
          
#line 337 
          goto ldv_46463;
        }
        else ;
      
#line 340 
      named_addr += 144ULL;
    }
    
#line 319 
    i += 1U;
    ldv_46465: 
#line 320 
    ;
    
#line 319 
    if (i < num_blocks) 
#line 321 
                        goto ldv_46464; else 
#line 324 
                                             goto ldv_46463;
    ldv_46463: 
#line 325 
    ;
  }
  else ;
  
#line 345 
  return result;
}


#line 357  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_console.c"
static int octeon_named_block_find(struct octeon_device *oct, char const *name, u64 *base_addr, u64 *size)
{
  int __retres;
  struct cvmx_bootmem_named_block_desc const *named_block;
  
#line 362 
  octeon_remote_lock();
  
#line 363 
  named_block = __cvmx_bootmem_find_named_block_flags(oct,name,0U);
  
#line 364 
  octeon_remote_unlock();
  
#line 365 
  if (named_block != (struct cvmx_bootmem_named_block_desc const *)0) {
    
#line 366 
    *base_addr = named_block->base_addr;
    
#line 367 
    *size = named_block->size;
    
#line 368 
    __retres = 0;
    
#line 368 
    goto return_label;
  }
  else ;
  
#line 370 
  __retres = 1;
  return_label: 
#line 370 
                return __retres;
}


#line 373  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_console.c"
static void octeon_remote_lock(void)
{
  
#line 375 
  return;
}


#line 378  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_console.c"
static void octeon_remote_unlock(void)
{
  
#line 380 
  return;
}


#line 383  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_console.c"
int octeon_console_send_cmd(struct octeon_device *oct, char *cmd_str, u32 wait_hundredths)
{
  int __retres;
  size_t tmp;
  int tmp_0;
  int tmp_1;
  
#line 386 
  tmp = strlen((char const *)cmd_str);
  
#line 386 
  u32 len = (unsigned int)tmp;
  {
    
#line 388 
    struct _ddebug descriptor = {.modname = "liquidio", .function = "octeon_console_send_cmd", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_console.c", .format = "sending \"%s\" to bootloader\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))388U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 388 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 388 
                                                        __dynamic_dev_dbg(& descriptor,(struct device const *)(& (oct->pci_dev)->dev),"sending \"%s\" to bootloader\n",cmd_str); else ;
  }
  
#line 390 
  if (len > 247U) {
    
#line 391 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Command string too long, max length is: %d\n",247);
    
#line 393 
    __retres = -1;
    
#line 393 
    goto return_label;
  }
  else ;
  
#line 396 
  tmp_0 = octeon_wait_for_bootloader(oct,wait_hundredths);
  
#line 396 
  if (tmp_0 != 0) {
    
#line 397 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Bootloader not ready for command.\n");
    
#line 398 
    __retres = -1;
    
#line 398 
    goto return_label;
  }
  else ;
  
#line 402 
  octeon_remote_lock();
  
#line 403 
  octeon_pci_write_core_mem(oct,442376ULL,(u8 *)cmd_str,len);
  
#line 405 
  octeon_write_device_mem32(oct,442372ULL,len);
  
#line 407 
  octeon_write_device_mem32(oct,442368ULL,1U);
  
#line 413 
  tmp_1 = octeon_wait_for_bootloader(oct,200U);
  
#line 413 
  if (tmp_1 != 0) {
    
#line 414 
    octeon_remote_unlock();
    
#line 415 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Bootloader did not accept command.\n");
    
#line 416 
    __retres = -1;
    
#line 416 
    goto return_label;
  }
  else ;
  
#line 418 
  octeon_remote_unlock();
  
#line 419 
  __retres = 0;
  return_label: 
#line 419 
                return __retres;
}


#line 422  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_console.c"
int octeon_wait_for_bootloader(struct octeon_device *oct, u32 wait_time_hundredths)
{
  int __retres;
  int tmp;
  {
    
#line 425 
    struct _ddebug descriptor = {.modname = "liquidio", .function = "octeon_wait_for_bootloader", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_console.c", .format = "waiting %d0 ms for bootloader\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))426U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 425 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 425 
                                                        __dynamic_dev_dbg(& descriptor,(struct device const *)(& (oct->pci_dev)->dev),"waiting %d0 ms for bootloader\n",wait_time_hundredths); else ;
  }
  
#line 428 
  tmp = octeon_mem_access_ok(oct);
  
#line 428 
  if (tmp != 0) {
    
#line 429 
    __retres = -1;
    
#line 429 
    goto return_label;
  }
  else ;
  
#line 431 
  goto ldv_46494;
  ldv_46493: 
#line 432 
  ;
  
#line 435 
  wait_time_hundredths -= 1U;
  
#line 435 
  if (wait_time_hundredths == 0U) {
    
#line 436 
    __retres = -1;
    
#line 436 
    goto return_label;
  }
  else ;
  
#line 437 
  schedule_timeout_uninterruptible(2L);
  ldv_46494: 
#line 438 
  ;
  
#line 431 
  if (wait_time_hundredths != 0U) {
    u32 tmp_0;
    
#line 431 
    tmp_0 = octeon_read_device_mem32(oct,442368ULL);
    
#line 431 
    if (tmp_0 != 2U) 
#line 436 
                     goto ldv_46493; else 
#line 439 
                                          goto ldv_46495;
  }
  else 
#line 439 
       goto ldv_46495;
  ldv_46495: 
#line 440 
  ;
  
#line 439 
  __retres = 0;
  return_label: 
#line 439 
                return __retres;
}


#line 442  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_console.c"
static void octeon_console_handle_result(struct octeon_device *oct, size_t console_num, char *buffer, s32 bytes_read)
{
  struct octeon_console *console;
  
#line 448 
  console = & oct->console[console_num];
  
#line 450 
  console->waiting = 0U;
  
#line 451 
  return;
}


#line 453  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_console.c"
static char console_buffer[512U];

#line 455  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_console.c"
static void output_console_line(struct octeon_device *oct, struct octeon_console *console, size_t console_num, char *console_buffer_0, s32 bytes_read)
{
  char *line;
  s32 i;
  
#line 464 
  line = console_buffer_0;
  
#line 465 
  i = 0;
  
#line 465 
  goto ldv_46514;
  ldv_46513: 
#line 466 
  ;
  
#line 467 
  if ((int)*(console_buffer_0 + i) == 10) {
    
#line 468 
    *(console_buffer_0 + i) = (char)0;
    
#line 469 
    if ((int)console->leftover[0] != 0) {
      
#line 470 
      _dev_info((struct device const *)(& (oct->pci_dev)->dev),"%lu: %s%s\n",console_num,(char *)(& console->leftover),line);
      
#line 473 
      console->leftover[0] = (char)0;
    }
    else 
#line 475 
         _dev_info((struct device const *)(& (oct->pci_dev)->dev),"%lu: %s\n",console_num,line);
    
#line 478 
    line = console_buffer_0 + ((unsigned int)i + 1U);
  }
  else ;
  
#line 465 
  i += 1;
  ldv_46514: 
#line 466 
  ;
  
#line 465 
  if (i < bytes_read) 
#line 467 
                      goto ldv_46513; else 
#line 470 
                                           goto ldv_46515;
  ldv_46515: 
#line 471 
  ;
  
#line 483 
  if (console_buffer_0 + bytes_read != line) {
    
#line 484 
    *(console_buffer_0 + bytes_read) = (char)0;
    
#line 485 
    strcpy((char *)(& console->leftover),(char const *)line);
  }
  else ;
  
#line 487 
  return;
}


#line 489  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_console.c"
static void check_console(struct work_struct *work)
{
  s32 bytes_read;
  s32 tries;
  s32 total_read;
  struct octeon_console *console;
  u32 delay;
  int tmp_0;
  unsigned long tmp_1;
  
#line 493 
  struct cavium_wk *wk = (struct cavium_wk *)work;
  
#line 494 
  struct octeon_device *oct = (struct octeon_device *)wk->ctxptr;
  
#line 495 
  size_t console_num = wk->ctxul;
  
#line 498 
  console = & oct->console[console_num];
  
#line 499 
  tries = 0;
  
#line 500 
  total_read = 0;
  ldv_46527: 
#line 501 
  ;
  
#line 506 
  bytes_read = octeon_console_read(oct,(unsigned int)console_num,(char *)(& console_buffer),511U,0U);
  
#line 509 
  if (bytes_read > 0) {
    int tmp;
    
#line 510 
    total_read += bytes_read;
    
#line 511 
    if (console->waiting != 0U) 
#line 512 
                                octeon_console_handle_result(oct,console_num,(char *)(& console_buffer),bytes_read); else ;
    
#line 516 
    tmp = octeon_console_debug_enabled((unsigned int)console_num);
    
#line 516 
    if (tmp != 0) 
#line 517 
                  output_console_line(oct,console,console_num,(char *)(& console_buffer),bytes_read); else ;
  }
  else 
    
#line 520 
    if (bytes_read < 0) 
#line 521 
                        dev_err((struct device const *)(& (oct->pci_dev)->dev),"Error reading console %lu, ret=%d\n",console_num,bytes_read); else ;
  
#line 525 
  tries += 1;
  
#line 526 
  if (bytes_read > 0 && tries <= 15) 
#line 528 
                                     goto ldv_46527; else 
#line 531 
                                                          goto ldv_46528;
  ldv_46528: 
#line 532 
  ;
  
#line 531 
  tmp_0 = octeon_console_debug_enabled((unsigned int)console_num);
  
#line 531 
  if (tmp_0 != 0) {
    
#line 531 
    if (total_read == 0) {
      
#line 532 
      if ((int)console->leftover[0] != 0) {
        
#line 533 
        _dev_info((struct device const *)(& (oct->pci_dev)->dev),"%lu: %s\n",console_num,(char *)(& console->leftover));
        
#line 535 
        console->leftover[0] = (char)0;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 538 
  delay = 100U;
  
#line 540 
  tmp_1 = msecs_to_jiffies(delay);
  
#line 540 
  ;
  
#line 540 
  ldv_schedule_delayed_work_73(& wk->work,tmp_1);
  
#line 541 
  return;
}


#line 543  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_console.c"
int octeon_init_consoles(struct octeon_device *oct)
{
  int __retres;
  u64 addr;
  u64 size;
  
#line 545 
  int ret = 0;
  
#line 548 
  ret = octeon_mem_access_ok(oct);
  
#line 549 
  if (ret != 0) {
    
#line 550 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Memory access not okay\'\n");
    
#line 551 
    __retres = ret;
    
#line 551 
    goto return_label;
  }
  else ;
  
#line 554 
  ret = octeon_named_block_find(oct,"__pci_console",& addr,& size);
  
#line 556 
  if (ret != 0) {
    
#line 557 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Could not find console \'%s\'\n",(char *)"__pci_console");
    
#line 559 
    __retres = ret;
    
#line 559 
    goto return_label;
  }
  else ;
  
#line 565 
  oct->num_consoles = octeon_read_device_mem32(oct,addr + 16ULL);
  
#line 568 
  oct->console_desc_addr = addr;
  {
    
#line 570 
    struct _ddebug descriptor = {.modname = "liquidio", .function = "octeon_init_consoles", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_console.c", .format = "Initialized consoles. %d available\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))571U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 570 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 570 
                                                        __dynamic_dev_dbg(& descriptor,(struct device const *)(& (oct->pci_dev)->dev),"Initialized consoles. %d available\n",oct->num_consoles); else ;
  }
  
#line 573 
  __retres = ret;
  return_label: 
#line 573 
                return __retres;
}


#line 576  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_console.c"
int octeon_add_console(struct octeon_device *oct, u32 console_num)
{
  u32 delay;
  u64 coreaddr;
  struct delayed_work *work;
  struct octeon_console *console;
  
#line 578 
  int ret = 0;
  
#line 584 
  if (oct->num_consoles <= console_num) 
#line 585 
                                        dev_err((struct device const *)(& (oct->pci_dev)->dev),"trying to read from console number %d when only 0 to %d exist\n",console_num,oct->num_consoles);
  else {
    unsigned long tmp;
    int tmp_0;
    
#line 589 
    console = & oct->console[console_num];
    
#line 591 
    console->waiting = 0U;
    
#line 593 
    coreaddr = (oct->console_desc_addr + (unsigned long long)(console_num * 8U)) + 24ULL;
    
#line 596 
    console->addr = octeon_read_device_mem64(oct,coreaddr);
    
#line 597 
    coreaddr = console->addr + 36ULL;
    
#line 599 
    console->buffer_size = octeon_read_device_mem32(oct,coreaddr);
    
#line 600 
    coreaddr = console->addr;
    
#line 602 
    console->input_base_addr = octeon_read_device_mem64(oct,coreaddr);
    
#line 604 
    coreaddr = console->addr + 16ULL;
    
#line 606 
    console->output_base_addr = octeon_read_device_mem64(oct,coreaddr);
    
#line 608 
    console->leftover[0] = (char)0;
    
#line 610 
    work = & oct->console_poll_work[console_num].work;
    {
      struct lock_class_key __key;
      
#line 612 
      __init_work(& work->work,0);
      
#line 612 
      atomic_long_t __constr_expr_37 = {.counter = WORK_STRUCT_NO_POOL_1};
      
#line 612 
      work->work.data = __constr_expr_37;
      
#line 612 
      lockdep_init_map(& work->work.lockdep_map,"(&(work)->work)",& __key,0);
      
#line 612 
      INIT_LIST_HEAD(& work->work.entry);
      
#line 612 
      work->work.func = & check_console;
    }
    {
      struct lock_class_key __key_0;
      
#line 612 
      init_timer_key(& work->timer,2097152U,"(&(work)->timer)",& __key_0);
    }
    
#line 612 
    work->timer.function = & delayed_work_timer_fn;
    
#line 612 
    work->timer.data = (unsigned long)work;
    
#line 613 
    oct->console_poll_work[console_num].ctxptr = (void *)oct;
    
#line 614 
    oct->console_poll_work[console_num].ctxul = (unsigned long)console_num;
    
#line 615 
    delay = 100U;
    
#line 616 
    tmp = msecs_to_jiffies(delay);
    
#line 616 
    ;
    
#line 616 
    ldv_schedule_delayed_work_74(work,tmp);
    
#line 618 
    tmp_0 = octeon_console_debug_enabled(console_num);
    
#line 618 
    if (tmp_0 != 0) 
#line 619 
                    ret = octeon_console_send_cmd(oct,(char *)"setenv pci_console_active 1",2000U); else ;
    
#line 624 
    console->active = 1U;
  }
  
#line 627 
  return ret;
}


#line 635  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_console.c"
void octeon_remove_consoles(struct octeon_device *oct)
{
  u32 i;
  struct octeon_console *console;
  
#line 640 
  i = 0U;
  
#line 640 
  goto ldv_46556;
  ldv_46555: 
#line 641 
  ;
  
#line 641 
  console = & oct->console[i];
  
#line 643 
  if (console->active == 0U) 
#line 644 
                             goto ldv_46554; else ;
  
#line 646 
  cancel_delayed_work_sync(& oct->console_poll_work[i].work);
  
#line 648 
  console->addr = 0ULL;
  
#line 649 
  console->buffer_size = 0U;
  
#line 650 
  console->input_base_addr = 0ULL;
  
#line 651 
  console->output_base_addr = 0ULL;
  ldv_46554: 
#line 652 
  ;
  
#line 640 
  i += 1U;
  ldv_46556: 
#line 641 
  ;
  
#line 640 
  if (oct->num_consoles > i) 
#line 642 
                             goto ldv_46555; else 
#line 645 
                                                  goto ldv_46557;
  ldv_46557: 
#line 646 
  ;
  
#line 654 
  oct->num_consoles = 0U;
  
#line 655 
  return;
}


#line 657  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_console.c"
__inline static int octeon_console_free_bytes(u32 buffer_size, u32 wr_idx, u32 rd_idx)
{
  int __retres;
  
#line 661 
  if (rd_idx >= buffer_size || wr_idx >= buffer_size) {
    
#line 662 
    __retres = -1;
    
#line 662 
    goto return_label;
  }
  else ;
  
#line 664 
  __retres = (int)(((buffer_size + (rd_idx - wr_idx)) + 4294967295U) % buffer_size);
  return_label: 
#line 664 
                return __retres;
}


#line 667  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_console.c"
__inline static int octeon_console_avail_bytes(u32 buffer_size, u32 wr_idx, u32 rd_idx)
{
  int __retres;
  int tmp;
  
#line 671 
  if (rd_idx >= buffer_size || wr_idx >= buffer_size) {
    
#line 672 
    __retres = -1;
    
#line 672 
    goto return_label;
  }
  else ;
  
#line 674 
  tmp = octeon_console_free_bytes(buffer_size,wr_idx,rd_idx);
  
#line 674 
  ;
  
#line 674 
  __retres = (int)((buffer_size - (unsigned int)tmp) + 4294967295U);
  return_label: 
#line 674 
                return __retres;
}


#line 678  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_console.c"
int octeon_console_read(struct octeon_device *oct, u32 console_num, char *buffer, u32 buf_size, u32 flags)
{
  int __retres;
  int bytes_to_read;
  u32 rd_idx;
  u32 wr_idx;
  struct octeon_console *console;
  int tmp_0;
  
#line 685 
  if (oct->num_consoles <= console_num) {
    
#line 686 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Attempted to read from disabled console %d\n",console_num);
    
#line 688 
    __retres = 0;
    
#line 688 
    goto return_label;
  }
  else ;
  
#line 691 
  console = & oct->console[console_num];
  
#line 696 
  rd_idx = octeon_read_device_mem32(oct,console->addr + 24ULL);
  
#line 698 
  wr_idx = octeon_read_device_mem32(oct,console->addr + 28ULL);
  
#line 701 
  bytes_to_read = octeon_console_avail_bytes(console->buffer_size,wr_idx,rd_idx);
  
#line 703 
  if (bytes_to_read <= 0) {
    
#line 704 
    __retres = bytes_to_read;
    
#line 704 
    goto return_label;
  }
  else ;
  {
    int tmp;
    
#line 706 
    int _min1 = bytes_to_read;
    
#line 706 
    int _min2 = (int)buf_size;
    
#line 706 
    if (_min1 < _min2) 
#line 706 
                       tmp = _min1; else 
#line 706 
                                         tmp = _min2;
    
#line 706 
    tmp_0 = tmp;
  }
  
#line 706 
  bytes_to_read = tmp_0;
  
#line 711 
  if (rd_idx + (unsigned int)bytes_to_read >= console->buffer_size) 
#line 712 
                                                                    bytes_to_read = (int)(console->buffer_size - rd_idx); else ;
  
#line 714 
  octeon_pci_read_core_mem(oct,console->output_base_addr + (unsigned long long)rd_idx,(u8 *)buffer,(unsigned int)bytes_to_read);
  
#line 716 
  octeon_write_device_mem32(oct,console->addr + 24ULL,(rd_idx + (unsigned int)bytes_to_read) % console->buffer_size);
  
#line 722 
  __retres = bytes_to_read;
  return_label: 
#line 722 
                return __retres;
}


#line 480  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_console.c.aux"
static void *kmalloc_2(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 483 
  tmp = ldv_kmalloc(size,flags);
  
#line 483 
  return tmp;
}


#line 747  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_console.c.aux"
static bool ldv_schedule_delayed_work_73(struct delayed_work *dwork, unsigned long delay)
{
  bool __retres;
  bool tmp;
  
#line 751 
  tmp = ldv_emg_schedule_delayed_work(dwork,delay);
  
#line 751 
  __retres = tmp != 0;
  
#line 751 
  return __retres;
}


#line 755  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_console.c.aux"
static bool ldv_schedule_delayed_work_74(struct delayed_work *dwork, unsigned long delay)
{
  bool __retres;
  bool tmp;
  
#line 759 
  tmp = ldv_emg_schedule_delayed_work(dwork,delay);
  
#line 759 
  __retres = tmp != 0;
  
#line 759 
  return __retres;
}


#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_2(spinlock_t *lock)
{
  
#line 312 
  _raw_spin_lock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 313 
  return;
}


#line 358 
static void ldv_spin_lock_73(spinlock_t *lock);


#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_2(spinlock_t *lock)
{
  
#line 365 
  _raw_spin_unlock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 366 
  return;
}


#line 407 
static void ldv_spin_unlock_74(spinlock_t *lock);


#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.h"
void lio_cn6xxx_process_pcie_error_intr(struct octeon_device *oct, u64 intr64);


#line 86 
int lio_cn6xxx_process_droq_intr_regs(struct octeon_device *oct);


#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c"
int lio_cn6xxx_soft_reset(struct octeon_device *oct)
{
  int __retres;
  unsigned long tmp_0;
  
#line 45 
  writeq(255UL,(void volatile *)(oct->mmio[0].hw_addr + 48U));
  {
    
#line 47 
    struct _ddebug descriptor = {.modname = "liquidio", .function = "lio_cn6xxx_soft_reset", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c", .format = "BIST enabled for soft reset\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))47U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 47 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 47 
                                                        __dynamic_dev_dbg(& descriptor,(struct device const *)(& (oct->pci_dev)->dev),"BIST enabled for soft reset\n"); else ;
  }
  
#line 49 
  lio_pci_writeq(oct,1ULL,289171558106936ULL);
  
#line 50 
  writeq(4660UL,(void volatile *)(oct->mmio[0].hw_addr + 960U));
  
#line 52 
  lio_pci_readq(oct,289171558106944ULL);
  
#line 53 
  lio_pci_writeq(oct,1ULL,289171558106944ULL);
  
#line 54 
  ldv_inline_asm();
  {
    
#line 59 
    unsigned long __ms = 100UL;
    {
      unsigned long tmp;
      
#line 59 
      goto ldv_46381;
      ldv_46380: 
#line 60 
      ;
      
#line 59 
      __const_udelay(4295000UL);
      ldv_46381: 
#line 61 
      ;
      
#line 59 
      tmp = __ms;
      
#line 59 
      __ms -= 1UL;
      
#line 59 
      ;
      
#line 59 
      if (tmp != 0UL) 
#line 61 
                      goto ldv_46380; else 
#line 64 
                                           goto ldv_46382;
      ldv_46382: 
#line 65 
      ;
    }
  }
  
#line 61 
  tmp_0 = readq((void const volatile *)(oct->mmio[0].hw_addr + 960U));
  
#line 61 
  if (tmp_0 == 4660UL) {
    
#line 62 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"Soft reset failed\n");
    
#line 63 
    __retres = 1;
    
#line 63 
    goto return_label;
  }
  else ;
  {
    
#line 66 
    struct _ddebug descriptor_0 = {.modname = "liquidio", .function = "lio_cn6xxx_soft_reset", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c", .format = "Reset completed\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))66U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 66 
    if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 66 
                                                          __dynamic_dev_dbg(& descriptor_0,(struct device const *)(& (oct->pci_dev)->dev),"Reset completed\n"); else ;
  }
  
#line 67 
  writeq(255UL,(void volatile *)(oct->mmio[0].hw_addr + 48U));
  
#line 69 
  __retres = 0;
  return_label: 
#line 69 
                return __retres;
}


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c"
void lio_cn6xxx_enable_error_reporting(struct octeon_device *oct)
{
  u32 val;
  
#line 76 
  pci_read_config_dword((struct pci_dev const *)oct->pci_dev,120,& val);
  
#line 77 
  if ((val & 983040U) != 0U) 
#line 78 
                             dev_err((struct device const *)(& (oct->pci_dev)->dev),"PCI-E Link error detected: 0x%08x\n",val & 983040U); else ;
  
#line 82 
  val |= 15U;
  {
    
#line 84 
    struct _ddebug descriptor = {.modname = "liquidio", .function = "lio_cn6xxx_enable_error_reporting", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c", .format = "Enabling PCI-E error reporting..\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))84U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 84 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 84 
                                                        __dynamic_dev_dbg(& descriptor,(struct device const *)(& (oct->pci_dev)->dev),"Enabling PCI-E error reporting..\n"); else ;
  }
  
#line 85 
  pci_write_config_dword((struct pci_dev const *)oct->pci_dev,120,val);
  
#line 86 
  return;
}


#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c"
void lio_cn6xxx_setup_pcie_mps(struct octeon_device *oct, enum octeon_pcie_mps mps)
{
  u32 val;
  u64 r64;
  
#line 95 
  pci_read_config_dword((struct pci_dev const *)oct->pci_dev,120,& val);
  
#line 97 
  if (mps == PCIE_MPS_DEFAULT) 
#line 98 
                               mps = (enum octeon_pcie_mps)((val >> 5) & 7U);
  else {
    
#line 100 
    val &= 4294967071U;
    
#line 101 
    val = (unsigned int)((int)mps << 5) | val;
    
#line 102 
    pci_write_config_dword((struct pci_dev const *)oct->pci_dev,120,val);
  }
  
#line 106 
  r64 = lio_pci_readq(oct,(unsigned long long)((int)oct->pcie_port * 16) + 526666069707008ULL);
  
#line 107 
  r64 = (unsigned long long)((int)mps << 4) | r64;
  
#line 108 
  lio_pci_writeq(oct,r64,(unsigned long long)((int)oct->pcie_port * 16) + 526666069707008ULL);
  
#line 109 
  return;
}


#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c"
void lio_cn6xxx_setup_pcie_mrrs(struct octeon_device *oct, enum octeon_pcie_mrrs mrrs)
{
  u32 val;
  u64 r64;
  
#line 118 
  pci_read_config_dword((struct pci_dev const *)oct->pci_dev,120,& val);
  
#line 120 
  if (mrrs == PCIE_MRRS_DEFAULT) 
#line 121 
                                 mrrs = (enum octeon_pcie_mrrs)((val >> 12) & 7U);
  else {
    
#line 123 
    val &= 4294938623U;
    
#line 124 
    val = (unsigned int)((int)mrrs << 12) | val;
    
#line 125 
    pci_write_config_dword((struct pci_dev const *)oct->pci_dev,120,val);
  }
  
#line 129 
  r64 = (u64)readq((void const volatile *)(oct->mmio[0].hw_addr + ((int)oct->pcie_port + 984) * 16));
  
#line 130 
  r64 = (unsigned long long)mrrs | r64;
  
#line 131 
  writeq((unsigned long)r64,(void volatile *)(oct->mmio[0].hw_addr + ((int)oct->pcie_port + 984) * 16));
  
#line 134 
  r64 = lio_pci_readq(oct,(unsigned long long)((int)oct->pcie_port * 16) + 526666069707008ULL);
  
#line 135 
  r64 = (unsigned long long)mrrs | r64;
  
#line 136 
  lio_pci_writeq(oct,r64,(unsigned long long)((int)oct->pcie_port * 16) + 526666069707008ULL);
  
#line 137 
  return;
}


#line 139  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c"
u32 lio_cn6xxx_coprocessor_clock(struct octeon_device *oct)
{
  u32 __retres;
  u64 tmp;
  
#line 144 
  tmp = lio_pci_readq(oct,307863255782912ULL);
  
#line 144 
  __retres = ((unsigned int)(tmp >> 24) & 63U) * 50U;
  
#line 144 
  return __retres;
}


#line 147  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c"
u32 lio_cn6xxx_get_oq_ticks(struct octeon_device *oct, u32 time_intr_in_us)
{
  
#line 151 
  u32 oqticks_per_us = lio_cn6xxx_coprocessor_clock(oct);
  
#line 158 
  oqticks_per_us *= 1000U;
  
#line 161 
  oqticks_per_us /= 1024U;
  
#line 166 
  oqticks_per_us *= time_intr_in_us;
  
#line 167 
  oqticks_per_us /= 1000U;
  
#line 169 
  return oqticks_per_us;
}


#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c"
void lio_cn6xxx_setup_global_input_regs(struct octeon_device *oct)
{
  
#line 175 
  writel(80U,(void volatile *)(oct->mmio[0].hw_addr + 4464U));
  
#line 179 
  writeq(18446744073709551615UL,(void volatile *)(oct->mmio[0].hw_addr + 4512U));
  
#line 183 
  writeq((unsigned long)((unsigned long long)oct->pcie_port * 6148914691236517205ULL),(void volatile *)(oct->mmio[0].hw_addr + 4528U));
  
#line 184 
  return;
}


#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c"
static void lio_cn66xx_setup_pkt_ctl_regs(struct octeon_device *oct)
{
  u64 pktctl;
  
#line 191 
  struct octeon_cn6xxx *cn6xxx = (struct octeon_cn6xxx *)oct->chip;
  
#line 193 
  pktctl = (u64)readq((void const volatile *)(oct->mmio[0].hw_addr + 4640U));
  
#line 196 
  if ((unsigned int)(cn6xxx->conf)->oq.max_oqs <= 4U) 
#line 198 
                                                      pktctl &= 18446744073709551599ULL; else 
                                                                    
#line 200 
                                                                    pktctl |= 16ULL;
  
#line 202 
  if ((unsigned int)*((unsigned char *)(& (cn6xxx->conf)->misc) + 0UL) != 0U) 
    
#line 203 
    pktctl |= 15ULL; else 
#line 206 
                          pktctl &= 18446744073709551600ULL;
  
#line 207 
  writeq((unsigned long)pktctl,(void volatile *)(oct->mmio[0].hw_addr + 4640U));
  
#line 208 
  return;
}


#line 210  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c"
void lio_cn6xxx_setup_global_output_regs(struct octeon_device *oct)
{
  u32 time_threshold;
  
#line 213 
  struct octeon_cn6xxx *cn6xxx = (struct octeon_cn6xxx *)oct->chip;
  
#line 216 
  writeq((unsigned long)((unsigned long long)oct->pcie_port * 6148914691236517205ULL),(void volatile *)(oct->mmio[0].hw_addr + 4320U));
  
#line 219 
  if ((unsigned int)*((unsigned char *)(& (cn6xxx->conf)->misc) + 0UL) != 0U) 
    
#line 220 
    writeq(32UL,(void volatile *)(oct->mmio[0].hw_addr + 4480U)); else 
                                                                    
#line 223 
                                                                    writeq(0UL,(void volatile *)(oct->mmio[0].hw_addr + 4480U));
  
#line 227 
  writel(4294967295U,(void volatile *)(oct->mmio[0].hw_addr + 4208U));
  
#line 230 
  writel(0U,(void volatile *)(oct->mmio[0].hw_addr + 4304U));
  
#line 235 
  writel(4294967295U,(void volatile *)(oct->mmio[0].hw_addr + 4224U));
  
#line 240 
  writel(0U,(void volatile *)(oct->mmio[0].hw_addr + 4144U));
  
#line 241 
  writel(0U,(void volatile *)(oct->mmio[0].hw_addr + 4160U));
  
#line 248 
  writeq(0UL,(void volatile *)(oct->mmio[0].hw_addr + 4176U));
  
#line 252 
  writel(0U,(void volatile *)(oct->mmio[0].hw_addr + 4240U));
  
#line 253 
  writel(0U,(void volatile *)(oct->mmio[0].hw_addr + 4256U));
  
#line 254 
  writeq(6148914691236517205UL,(void volatile *)(oct->mmio[0].hw_addr + 4272U));
  
#line 258 
  writel((unsigned int)(cn6xxx->conf)->oq.oq_intr_pkt,(void volatile *)(oct->mmio[0].hw_addr + 4384U));
  
#line 260 
  time_threshold = lio_cn6xxx_get_oq_ticks(oct,(unsigned int)(cn6xxx->conf)->oq.oq_intr_time);
  
#line 264 
  writel(time_threshold,(void volatile *)(oct->mmio[0].hw_addr + 4388U));
  
#line 265 
  return;
}


#line 267  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c"
static int lio_cn6xxx_setup_device_regs(struct octeon_device *oct)
{
  int __retres;
  
#line 269 
  lio_cn6xxx_setup_pcie_mps(oct,(enum octeon_pcie_mps)PCIE_MPS_DEFAULT);
  
#line 270 
  lio_cn6xxx_setup_pcie_mrrs(oct,(enum octeon_pcie_mrrs)PCIE_MRRS_512B);
  
#line 271 
  lio_cn6xxx_enable_error_reporting(oct);
  
#line 273 
  lio_cn6xxx_setup_global_input_regs(oct);
  
#line 274 
  lio_cn66xx_setup_pkt_ctl_regs(oct);
  
#line 275 
  lio_cn6xxx_setup_global_output_regs(oct);
  
#line 280 
  writeq(2097152UL,(void volatile *)(oct->mmio[0].hw_addr + 736U));
  
#line 281 
  __retres = 0;
  
#line 281 
  return __retres;
}


#line 284  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c"
void lio_cn6xxx_setup_iq_regs(struct octeon_device *oct, u32 iq_no)
{
  
#line 286 
  struct octeon_instr_queue *iq = oct->instr_queue[iq_no];
  
#line 289 
  writeq(0UL,(void volatile *)(oct->mmio[0].hw_addr + (iq_no + 832U) * 16U));
  
#line 292 
  writeq((unsigned long)iq->base_addr_dma,(void volatile *)(oct->mmio[0].hw_addr + (iq_no + 640U) * 16U));
  
#line 294 
  writel(iq->max_count,(void volatile *)(oct->mmio[0].hw_addr + (iq_no + 768U) * 16U));
  
#line 299 
  iq->doorbell_reg = (void *)(oct->mmio[0].hw_addr + (iq_no + 704U) * 16U);
  
#line 300 
  iq->inst_cnt_reg = (void *)(oct->mmio[0].hw_addr + (iq_no + 512U) * 16U);
  {
    
#line 302 
    struct _ddebug descriptor = {.modname = "liquidio", .function = "lio_cn6xxx_setup_iq_regs", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c", .format = "InstQ[%d]:dbell reg @ 0x%p instcnt_reg @ 0x%p\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))303U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 302 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 302 
                                                        __dynamic_dev_dbg(& descriptor,(struct device const *)(& (oct->pci_dev)->dev),"InstQ[%d]:dbell reg @ 0x%p instcnt_reg @ 0x%p\n",iq_no,iq->doorbell_reg,iq->inst_cnt_reg); else ;
  }
  
#line 308 
  iq->reset_instr_cnt = readl((void const volatile *)iq->inst_cnt_reg);
  
#line 309 
  return;
}


#line 311  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c"
static void lio_cn66xx_setup_iq_regs(struct octeon_device *oct, u32 iq_no)
{
  
#line 313 
  lio_cn6xxx_setup_iq_regs(oct,iq_no);
  
#line 318 
  writeq(18446744069414584320UL,(void volatile *)(oct->mmio[0].hw_addr + (iq_no + 896U) * 16U));
  
#line 319 
  return;
}


#line 322  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c"
void lio_cn6xxx_setup_oq_regs(struct octeon_device *oct, u32 oq_no)
{
  u32 intr;
  
#line 325 
  struct octeon_droq *droq = oct->droq[oq_no];
  
#line 327 
  writeq(droq->desc_ring_dma,(void volatile *)(oct->mmio[0].hw_addr + (oq_no + 320U) * 16U));
  
#line 329 
  writel(droq->max_count,(void volatile *)(oct->mmio[0].hw_addr + (oq_no + 448U) * 16U));
  
#line 331 
  writel(droq->buffer_size | 524288U,(void volatile *)(oct->mmio[0].hw_addr + (oq_no + 192U) * 16U));
  
#line 335 
  droq->pkts_sent_reg = (void *)(oct->mmio[0].hw_addr + (oq_no + 576U) * 16U);
  
#line 337 
  droq->pkts_credit_reg = (void *)(oct->mmio[0].hw_addr + (oq_no + 384U) * 16U);
  
#line 341 
  intr = readl((void const volatile *)(oct->mmio[0].hw_addr + 4448U));
  
#line 342 
  intr = (unsigned int)(1 << oq_no) | intr;
  
#line 343 
  writel(intr,(void volatile *)(oct->mmio[0].hw_addr + 4448U));
  
#line 346 
  intr = readl((void const volatile *)(oct->mmio[0].hw_addr + 4432U));
  
#line 347 
  intr = (unsigned int)(1 << oq_no) | intr;
  
#line 348 
  writel(intr,(void volatile *)(oct->mmio[0].hw_addr + 4432U));
  
#line 349 
  return;
}


#line 351  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c"
void lio_cn6xxx_enable_io_queues(struct octeon_device *oct)
{
  u32 mask;
  
#line 355 
  mask = readl((void const volatile *)(oct->mmio[0].hw_addr + 4128U));
  
#line 356 
  mask = oct->io_qmask.iq64B | mask;
  
#line 357 
  writel(mask,(void volatile *)(oct->mmio[0].hw_addr + 4128U));
  
#line 359 
  mask = readl((void const volatile *)(oct->mmio[0].hw_addr + 4096U));
  
#line 360 
  mask = oct->io_qmask.iq | mask;
  
#line 361 
  writel(mask,(void volatile *)(oct->mmio[0].hw_addr + 4096U));
  
#line 363 
  mask = readl((void const volatile *)(oct->mmio[0].hw_addr + 4112U));
  
#line 364 
  mask = oct->io_qmask.oq | mask;
  
#line 365 
  writel(mask,(void volatile *)(oct->mmio[0].hw_addr + 4112U));
  
#line 366 
  return;
}


#line 368  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c"
void lio_cn6xxx_disable_io_queues(struct octeon_device *oct)
{
  u32 mask;
  u32 i;
  u32 d32;
  
#line 370 
  u32 loop = 250U;
  
#line 374 
  mask = readl((void const volatile *)(oct->mmio[0].hw_addr + 4096U));
  
#line 375 
  mask = oct->io_qmask.iq ^ mask;
  
#line 376 
  writel(mask,(void volatile *)(oct->mmio[0].hw_addr + 4096U));
  
#line 379 
  mask = oct->io_qmask.iq;
  
#line 380 
  d32 = readl((void const volatile *)(oct->mmio[0].hw_addr + 4596U));
  
#line 381 
  goto ldv_46455;
  ldv_46454: 
#line 382 
  ;
  
#line 382 
  d32 = readl((void const volatile *)(oct->mmio[0].hw_addr + 4596U));
  
#line 383 
  schedule_timeout_uninterruptible(1L);
  ldv_46455: 
#line 384 
  ;
  
#line 381 
  if ((d32 & mask) != mask) {
    u32 tmp;
    
#line 381 
    tmp = loop;
    
#line 381 
    loop -= 1U;
    
#line 381 
    ;
    
#line 381 
    if (tmp != 0U) 
#line 383 
                   goto ldv_46454; else 
#line 386 
                                        goto ldv_46456;
  }
  else 
#line 386 
       goto ldv_46456;
  ldv_46456: 
#line 387 
  ;
  
#line 387 
  i = 0U;
  
#line 387 
  goto ldv_46459;
  ldv_46458: 
#line 388 
  ;
  
#line 388 
  if ((((unsigned long)oct->io_qmask.iq >> i) & 1UL) == 0UL) 
#line 389 
                                                             goto ldv_46457; else ;
  
#line 390 
  writel(4294967295U,(void volatile *)(oct->mmio[0].hw_addr + (i + 704U) * 16U));
  
#line 391 
  d32 = readl((void const volatile *)(oct->mmio[0].hw_addr + (i + 704U) * 16U));
  ldv_46457: 
#line 392 
  ;
  
#line 387 
  i += 1U;
  ldv_46459: 
#line 388 
  ;
  
#line 387 
  if (i <= 31U) 
#line 389 
                goto ldv_46458; else 
#line 392 
                                     goto ldv_46460;
  ldv_46460: 
#line 393 
  ;
  
#line 395 
  mask = readl((void const volatile *)(oct->mmio[0].hw_addr + 4112U));
  
#line 396 
  mask = oct->io_qmask.oq ^ mask;
  
#line 397 
  writel(mask,(void volatile *)(oct->mmio[0].hw_addr + 4112U));
  
#line 400 
  loop = 250U;
  
#line 401 
  mask = oct->io_qmask.oq;
  
#line 402 
  d32 = readl((void const volatile *)(oct->mmio[0].hw_addr + 4592U));
  
#line 403 
  goto ldv_46462;
  ldv_46461: 
#line 404 
  ;
  
#line 404 
  d32 = readl((void const volatile *)(oct->mmio[0].hw_addr + 4592U));
  
#line 405 
  schedule_timeout_uninterruptible(1L);
  ldv_46462: 
#line 406 
  ;
  
#line 403 
  if ((d32 & mask) != mask) {
    u32 tmp_0;
    
#line 403 
    tmp_0 = loop;
    
#line 403 
    loop -= 1U;
    
#line 403 
    ;
    
#line 403 
    if (tmp_0 != 0U) 
#line 405 
                     goto ldv_46461; else 
#line 408 
                                          goto ldv_46463;
  }
  else 
#line 408 
       goto ldv_46463;
  ldv_46463: 
#line 409 
  ;
  
#line 411 
  i = 0U;
  
#line 411 
  goto ldv_46466;
  ldv_46465: 
#line 412 
  ;
  
#line 412 
  if ((((unsigned long)oct->io_qmask.oq >> i) & 1UL) == 0UL) 
#line 413 
                                                             goto ldv_46464; else ;
  
#line 414 
  writel(4294967295U,(void volatile *)(oct->mmio[0].hw_addr + (i + 384U) * 16U));
  
#line 415 
  d32 = readl((void const volatile *)(oct->mmio[0].hw_addr + (i + 384U) * 16U));
  
#line 417 
  d32 = readl((void const volatile *)(oct->mmio[0].hw_addr + (i + 576U) * 16U));
  
#line 418 
  writel(d32,(void volatile *)(oct->mmio[0].hw_addr + (i + 576U) * 16U));
  ldv_46464: 
#line 419 
  ;
  
#line 411 
  i += 1U;
  ldv_46466: 
#line 412 
  ;
  
#line 411 
  if (i <= 31U) 
#line 413 
                goto ldv_46465; else 
#line 416 
                                     goto ldv_46467;
  ldv_46467: 
#line 417 
  ;
  
#line 421 
  d32 = readl((void const volatile *)(oct->mmio[0].hw_addr + 4400U));
  
#line 422 
  if (d32 != 0U) 
#line 423 
                 writel(d32,(void volatile *)(oct->mmio[0].hw_addr + 4400U)); else ;
  
#line 425 
  d32 = readl((void const volatile *)(oct->mmio[0].hw_addr + 4416U));
  
#line 426 
  if (d32 != 0U) 
#line 427 
                 writel(d32,(void volatile *)(oct->mmio[0].hw_addr + 4416U)); else ;
  
#line 428 
  return;
}


#line 430  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c"
void lio_cn6xxx_reinit_regs(struct octeon_device *oct)
{
  u32 i;
  
#line 434 
  i = 0U;
  
#line 434 
  goto ldv_46474;
  ldv_46473: 
#line 435 
  ;
  
#line 435 
  if ((((unsigned long)oct->io_qmask.iq >> i) & 1UL) == 0UL) 
#line 436 
                                                             goto ldv_46472; else ;
  
#line 437 
  (*(oct->fn_list.setup_iq_regs))(oct,i);
  ldv_46472: 
#line 438 
  ;
  
#line 434 
  i += 1U;
  ldv_46474: 
#line 435 
  ;
  
#line 434 
  if (i <= 31U) 
#line 436 
                goto ldv_46473; else 
#line 439 
                                     goto ldv_46475;
  ldv_46475: 
#line 440 
  ;
  
#line 440 
  i = 0U;
  
#line 440 
  goto ldv_46478;
  ldv_46477: 
#line 441 
  ;
  
#line 441 
  if ((((unsigned long)oct->io_qmask.oq >> i) & 1UL) == 0UL) 
#line 442 
                                                             goto ldv_46476; else ;
  
#line 443 
  (*(oct->fn_list.setup_oq_regs))(oct,i);
  ldv_46476: 
#line 444 
  ;
  
#line 440 
  i += 1U;
  ldv_46478: 
#line 441 
  ;
  
#line 440 
  if (i <= 31U) 
#line 442 
                goto ldv_46477; else 
#line 445 
                                     goto ldv_46479;
  ldv_46479: 
#line 446 
  ;
  
#line 446 
  (*(oct->fn_list.setup_device_regs))(oct);
  
#line 448 
  (*(oct->fn_list.enable_interrupt))(oct->chip);
  
#line 450 
  (*(oct->fn_list.enable_io_queues))(oct);
  
#line 453 
  i = 0U;
  
#line 453 
  goto ldv_46482;
  ldv_46481: 
#line 454 
  ;
  
#line 454 
  if ((((unsigned long)oct->io_qmask.oq >> i) & 1UL) == 0UL) 
#line 455 
                                                             goto ldv_46480; else ;
  
#line 456 
  writel((oct->droq[i])->max_count,(void volatile *)(oct->droq[i])->pkts_credit_reg);
  ldv_46480: 
#line 457 
  ;
  
#line 453 
  i += 1U;
  ldv_46482: 
#line 454 
  ;
  
#line 453 
  if (i <= 31U) 
#line 455 
                goto ldv_46481; else 
#line 458 
                                     goto ldv_46483;
  ldv_46483: 
#line 459 
  ;
  
#line 460 
  return;
}


#line 461  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c"
void lio_cn6xxx_bar1_idx_setup(struct octeon_device *oct, u64 core_addr, u32 idx, int valid)
{
  u64 bar1;
  
#line 468 
  if (valid == 0) {
    
#line 469 
    bar1 = lio_pci_readq(oct,((unsigned long long)oct->pcie_port * 16777216ULL + (unsigned long long)(idx * 8U)) + 307866477002920ULL);
    
#line 470 
    lio_pci_writeq(oct,bar1 & 4294967294ULL,((unsigned long long)oct->pcie_port * 16777216ULL + (unsigned long long)(idx * 8U)) + 307866477002920ULL);
    
#line 472 
    bar1 = lio_pci_readq(oct,((unsigned long long)oct->pcie_port * 16777216ULL + (unsigned long long)(idx * 8U)) + 307866477002920ULL);
    
#line 473 
    goto return_label;
  }
  else ;
  
#line 479 
  lio_pci_writeq(oct,((core_addr >> 22) << 4) | 11ULL,((unsigned long long)oct->pcie_port * 16777216ULL + (unsigned long long)(idx * 8U)) + 307866477002920ULL);
  
#line 482 
  bar1 = lio_pci_readq(oct,((unsigned long long)oct->pcie_port * 16777216ULL + (unsigned long long)(idx * 8U)) + 307866477002920ULL);
  return_label: 
#line 483 
                return;
}


#line 485  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c"
void lio_cn6xxx_bar1_idx_write(struct octeon_device *oct, u32 idx, u32 mask)
{
  
#line 489 
  lio_pci_writeq(oct,(unsigned long long)mask,((unsigned long long)oct->pcie_port * 16777216ULL + (unsigned long long)(idx * 8U)) + 307866477002920ULL);
  
#line 490 
  return;
}


#line 492  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c"
u32 lio_cn6xxx_bar1_idx_read(struct octeon_device *oct, u32 idx)
{
  u32 __retres;
  u64 tmp;
  
#line 494 
  tmp = lio_pci_readq(oct,((unsigned long long)oct->pcie_port * 16777216ULL + (unsigned long long)(idx * 8U)) + 307866477002920ULL);
  
#line 494 
  __retres = (unsigned int)tmp;
  
#line 494 
  return __retres;
}


#line 498  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c"
u32 lio_cn6xxx_update_read_index(struct octeon_device *oct, struct octeon_instr_queue *iq)
{
  
#line 501 
  u32 new_idx = readl((void const volatile *)iq->inst_cnt_reg);
  
#line 507 
  if (iq->reset_instr_cnt < new_idx) 
#line 508 
                                     new_idx -= iq->reset_instr_cnt; else 
                                                                    
#line 510 
                                                                    new_idx -= iq->reset_instr_cnt;
  
#line 515 
  new_idx %= iq->max_count;
  
#line 517 
  return new_idx;
}


#line 520  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c"
void lio_cn6xxx_enable_interrupt(void *chip)
{
  
#line 522 
  struct octeon_cn6xxx *cn6xxx = (struct octeon_cn6xxx *)chip;
  
#line 523 
  u64 mask = cn6xxx->intr_mask64 | 4294967296ULL;
  
#line 526 
  writeq((unsigned long)mask,(void volatile *)cn6xxx->intr_enb_reg64);
  
#line 527 
  return;
}


#line 529  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c"
void lio_cn6xxx_disable_interrupt(void *chip)
{
  
#line 531 
  struct octeon_cn6xxx *cn6xxx = (struct octeon_cn6xxx *)chip;
  
#line 534 
  writeq(0UL,(void volatile *)cn6xxx->intr_enb_reg64);
  
#line 535 
  ldv_inline_asm();
  
#line 536 
  return;
}


#line 540  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c"
static void lio_cn6xxx_get_pcie_qlmport(struct octeon_device *oct)
{
  unsigned int tmp;
  
#line 545 
  tmp = readl((void const volatile *)(oct->mmio[0].hw_addr + 15872U));
  
#line 545 
  oct->pcie_port = (unsigned short)((unsigned int)((unsigned short)tmp) & 255U);
  {
    
#line 547 
    struct _ddebug descriptor = {.modname = "liquidio", .function = "lio_cn6xxx_get_pcie_qlmport", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c", .format = "Using PCIE Port %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))547U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 547 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 547 
                                                        __dynamic_dev_dbg(& descriptor,(struct device const *)(& (oct->pci_dev)->dev),"Using PCIE Port %d\n",(int)oct->pcie_port); else ;
  }
  
#line 549 
  return;
}


#line 551  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c"
void lio_cn6xxx_process_pcie_error_intr(struct octeon_device *oct, u64 intr64)
{
  
#line 553 
  dev_err((struct device const *)(& (oct->pci_dev)->dev),"Error Intr: 0x%016llx\n",(long long)intr64);
  
#line 555 
  return;
}


#line 557  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c"
int lio_cn6xxx_process_droq_intr_regs(struct octeon_device *oct)
{
  int __retres;
  struct octeon_droq *droq;
  u32 oq_no;
  u32 pkt_count;
  u32 droq_time_mask;
  u32 droq_mask;
  u32 droq_int_enb;
  u32 droq_cnt_enb;
  u32 droq_cnt_mask;
  
#line 563 
  droq_cnt_enb = readl((void const volatile *)(oct->mmio[0].hw_addr + 4432U));
  
#line 564 
  droq_cnt_mask = readl((void const volatile *)(oct->mmio[0].hw_addr + 4400U));
  
#line 565 
  droq_mask = droq_cnt_mask & droq_cnt_enb;
  
#line 567 
  droq_time_mask = readl((void const volatile *)(oct->mmio[0].hw_addr + 4416U));
  
#line 568 
  droq_int_enb = readl((void const volatile *)(oct->mmio[0].hw_addr + 4448U));
  
#line 569 
  droq_mask = (droq_time_mask & droq_int_enb) | droq_mask;
  
#line 571 
  droq_mask = oct->io_qmask.oq & droq_mask;
  
#line 573 
  oct->droq_intr = 0ULL;
  
#line 576 
  oq_no = 0U;
  
#line 576 
  goto ldv_46539;
  ldv_46538: 
#line 577 
  ;
  
#line 577 
  if (((unsigned int)(1 << oq_no) & droq_mask) == 0U) 
#line 578 
                                                      goto ldv_46534; else ;
  
#line 580 
  droq = oct->droq[oq_no];
  
#line 581 
  pkt_count = octeon_droq_check_hw_for_pkts(oct,droq);
  
#line 582 
  if (pkt_count != 0U) {
    
#line 583 
    oct->droq_intr |= 1ULL << oq_no;
    
#line 584 
    if (droq->ops.poll_mode != 0U) {
      u32 value;
      u32 reg;
      
#line 588 
      struct octeon_cn6xxx *cn6xxx = (struct octeon_cn6xxx *)oct->chip;
      
#line 592 
      ldv_spin_lock_73(& cn6xxx->lock_for_droq_int_enb_reg);
      
#line 594 
      reg = 4448U;
      
#line 595 
      value = readl((void const volatile *)(oct->mmio[0].hw_addr + reg));
      
#line 596 
      value = (unsigned int)(~ (1 << oq_no)) & value;
      
#line 597 
      writel(value,(void volatile *)(oct->mmio[0].hw_addr + reg));
      
#line 598 
      reg = 4432U;
      
#line 599 
      value = readl((void const volatile *)(oct->mmio[0].hw_addr + reg));
      
#line 600 
      value = (unsigned int)(~ (1 << oq_no)) & value;
      
#line 601 
      writel(value,(void volatile *)(oct->mmio[0].hw_addr + reg));
      
#line 602 
      ldv_inline_asm();
      
#line 607 
      ldv_spin_unlock_74(& cn6xxx->lock_for_droq_int_enb_reg);
    }
    else ;
  }
  else ;
  ldv_46534: 
#line 610 
  ;
  
#line 576 
  oq_no += 1U;
  ldv_46539: 
#line 577 
  ;
  
#line 576 
  if (oq_no <= 31U) 
#line 578 
                    goto ldv_46538; else 
#line 581 
                                         goto ldv_46540;
  ldv_46540: 
#line 582 
  ;
  
#line 612 
  droq_time_mask = oct->io_qmask.oq & droq_time_mask;
  
#line 613 
  droq_cnt_mask = oct->io_qmask.oq & droq_cnt_mask;
  
#line 616 
  if (droq_time_mask != 0U) 
#line 617 
                            writel(droq_time_mask,(void volatile *)(oct->mmio[0].hw_addr + 4416U)); else ;
  
#line 619 
  if (droq_cnt_mask != 0U) 
#line 620 
                           writel(droq_cnt_mask,(void volatile *)(oct->mmio[0].hw_addr + 4400U)); else ;
  
#line 622 
  __retres = 0;
  
#line 622 
  return __retres;
}


#line 625  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c"
irqreturn_t lio_cn6xxx_process_interrupt_regs(void *dev)
{
  irqreturn_t __retres;
  u64 intr64;
  
#line 627 
  struct octeon_device *oct = (struct octeon_device *)dev;
  
#line 628 
  struct octeon_cn6xxx *cn6xxx = (struct octeon_cn6xxx *)oct->chip;
  
#line 631 
  intr64 = (u64)readq((void const volatile *)cn6xxx->intr_sum_reg64);
  
#line 637 
  if (intr64 + 18446744073709551615ULL > 18446744073709551613ULL) {
    
#line 638 
    __retres = IRQ_NONE;
    
#line 638 
    goto return_label;
  }
  else ;
  
#line 640 
  oct->int_status = 0U;
  
#line 642 
  if ((intr64 & 1440870405781896972ULL) != 0ULL) 
#line 643 
                                                 lio_cn6xxx_process_pcie_error_intr(oct,intr64); else ;
  
#line 645 
  if ((intr64 & 48ULL) != 0ULL) {
    
#line 646 
    lio_cn6xxx_process_droq_intr_regs(oct);
    
#line 647 
    oct->int_status |= 4U;
  }
  else ;
  
#line 650 
  if ((intr64 & 4294967296ULL) != 0ULL) 
#line 651 
                                        oct->int_status |= 1U; else ;
  
#line 653 
  if ((intr64 & 8589934592ULL) != 0ULL) 
#line 654 
                                        oct->int_status |= 2U; else ;
  
#line 657 
  writeq((unsigned long)intr64,(void volatile *)cn6xxx->intr_sum_reg64);
  
#line 659 
  __retres = IRQ_HANDLED;
  return_label: 
#line 659 
                return __retres;
}


#line 662  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c"
void lio_cn6xxx_setup_reg_address(struct octeon_device *oct, void *chip, struct octeon_reg_list *reg_list)
{
  
#line 666 
  u8 *bar0_pciaddr = oct->mmio[0].hw_addr;
  
#line 667 
  struct octeon_cn6xxx *cn6xxx = (struct octeon_cn6xxx *)chip;
  
#line 669 
  reg_list->pci_win_wr_addr_hi = (u32 *)(bar0_pciaddr + 4U);
  
#line 671 
  reg_list->pci_win_wr_addr_lo = (u32 *)bar0_pciaddr;
  
#line 673 
  reg_list->pci_win_wr_addr = (u64 *)bar0_pciaddr;
  
#line 676 
  reg_list->pci_win_rd_addr_hi = (u32 *)(bar0_pciaddr + 20U);
  
#line 678 
  reg_list->pci_win_rd_addr_lo = (u32 *)(bar0_pciaddr + 16U);
  
#line 680 
  reg_list->pci_win_rd_addr = (u64 *)(bar0_pciaddr + 16U);
  
#line 683 
  reg_list->pci_win_wr_data_hi = (u32 *)(bar0_pciaddr + 36U);
  
#line 685 
  reg_list->pci_win_wr_data_lo = (u32 *)(bar0_pciaddr + 32U);
  
#line 687 
  reg_list->pci_win_wr_data = (u64 *)(bar0_pciaddr + 32U);
  
#line 690 
  reg_list->pci_win_rd_data_hi = (u32 *)(bar0_pciaddr + 68U);
  
#line 692 
  reg_list->pci_win_rd_data_lo = (u32 *)(bar0_pciaddr + 64U);
  
#line 694 
  reg_list->pci_win_rd_data = (u64 *)(bar0_pciaddr + 64U);
  
#line 697 
  lio_cn6xxx_get_pcie_qlmport(oct);
  
#line 699 
  cn6xxx->intr_sum_reg64 = bar0_pciaddr + 816U;
  
#line 700 
  cn6xxx->intr_mask64 = 1440870624826212156ULL;
  
#line 701 
  cn6xxx->intr_enb_reg64 = bar0_pciaddr + ((int)oct->pcie_port + 52) * 16;
  
#line 703 
  return;
}


#line 705  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c"
int lio_setup_cn66xx_octeon_device(struct octeon_device *oct)
{
  int __retres;
  int tmp;
  int tmp_0;
  u32 tmp_2;
  
#line 707 
  struct octeon_cn6xxx *cn6xxx = (struct octeon_cn6xxx *)oct->chip;
  
#line 709 
  tmp = octeon_map_pci_barx(oct,0,0);
  
#line 709 
  if (tmp != 0) {
    
#line 710 
    __retres = 1;
    
#line 710 
    goto return_label;
  }
  else ;
  
#line 712 
  tmp_0 = octeon_map_pci_barx(oct,1,12582912);
  
#line 712 
  if (tmp_0 != 0) {
    
#line 713 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"%s CN66XX BAR1 map failed\n","lio_setup_cn66xx_octeon_device");
    
#line 715 
    octeon_unmap_pci_barx(oct,0);
    
#line 716 
    __retres = 1;
    
#line 716 
    goto return_label;
  }
  else ;
  
#line 719 
  spinlock_check(& cn6xxx->lock_for_droq_int_enb_reg);
  {
    struct lock_class_key __key;
    
#line 719 
    __raw_spin_lock_init(& cn6xxx->lock_for_droq_int_enb_reg.__anonCompField_spinlock_18.rlock,"&(&cn6xxx->lock_for_droq_int_enb_reg)->rlock",& __key);
  }
  
#line 721 
  oct->fn_list.setup_iq_regs = & lio_cn66xx_setup_iq_regs;
  
#line 722 
  oct->fn_list.setup_oq_regs = & lio_cn6xxx_setup_oq_regs;
  
#line 724 
  oct->fn_list.soft_reset = & lio_cn6xxx_soft_reset;
  
#line 725 
  oct->fn_list.setup_device_regs = & lio_cn6xxx_setup_device_regs;
  
#line 726 
  oct->fn_list.reinit_regs = & lio_cn6xxx_reinit_regs;
  
#line 727 
  oct->fn_list.update_iq_read_idx = & lio_cn6xxx_update_read_index;
  
#line 729 
  oct->fn_list.bar1_idx_setup = & lio_cn6xxx_bar1_idx_setup;
  
#line 730 
  oct->fn_list.bar1_idx_write = & lio_cn6xxx_bar1_idx_write;
  
#line 731 
  oct->fn_list.bar1_idx_read = & lio_cn6xxx_bar1_idx_read;
  
#line 733 
  oct->fn_list.process_interrupt_regs = & lio_cn6xxx_process_interrupt_regs;
  
#line 734 
  oct->fn_list.enable_interrupt = & lio_cn6xxx_enable_interrupt;
  
#line 735 
  oct->fn_list.disable_interrupt = & lio_cn6xxx_disable_interrupt;
  
#line 737 
  oct->fn_list.enable_io_queues = & lio_cn6xxx_enable_io_queues;
  
#line 738 
  oct->fn_list.disable_io_queues = & lio_cn6xxx_disable_io_queues;
  
#line 740 
  lio_cn6xxx_setup_reg_address(oct,oct->chip,& oct->reg_list);
  
#line 742 
  cn6xxx->conf = (struct octeon_config *)oct_get_config_info(oct,(unsigned short)0);
  
#line 744 
  if (cn6xxx->conf == (struct octeon_config *)0) {
    
#line 745 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"%s No Config found for CN66XX\n","lio_setup_cn66xx_octeon_device");
    
#line 747 
    octeon_unmap_pci_barx(oct,0);
    
#line 748 
    octeon_unmap_pci_barx(oct,1);
    
#line 749 
    __retres = 1;
    
#line 749 
    goto return_label;
  }
  else ;
  
#line 752 
  tmp_2 = lio_cn6xxx_coprocessor_clock(oct);
  
#line 752 
  oct->coproc_clock_rate = (unsigned long long)tmp_2 * 1000000ULL;
  
#line 754 
  __retres = 0;
  return_label: 
#line 754 
                return __retres;
}


#line 757  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/cn66xx_device.c"
int lio_validate_cn6xxx_config_info(struct octeon_device *oct, struct octeon_config *conf6xxx)
{
  int __retres;
  
#line 762 
  if ((unsigned int)conf6xxx->iq.max_iqs > 32U) {
    
#line 763 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"%s: Num IQ (%d) exceeds Max (%d)\n","lio_validate_cn6xxx_config_info",(int)conf6xxx->iq.max_iqs,32);
    
#line 766 
    __retres = 1;
    
#line 766 
    goto return_label;
  }
  else ;
  
#line 769 
  if ((unsigned int)conf6xxx->oq.max_oqs > 32U) {
    
#line 770 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"%s: Num OQ (%d) exceeds Max (%d)\n","lio_validate_cn6xxx_config_info",(int)conf6xxx->oq.max_oqs,32);
    
#line 773 
    __retres = 1;
    
#line 773 
    goto return_label;
  }
  else ;
  
#line 776 
  if ((unsigned int)conf6xxx->iq.instr_type != 32U && (unsigned int)conf6xxx->iq.instr_type != 64U) {
    
#line 778 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"%s: Invalid instr type for IQ\n","lio_validate_cn6xxx_config_info");
    
#line 780 
    __retres = 1;
    
#line 780 
    goto return_label;
  }
  else ;
  
#line 782 
  if (*((unsigned long *)(& conf6xxx->oq) + 0UL) == 0UL || *((unsigned int *)(& conf6xxx->oq) + 1UL) == 0U) {
    
#line 784 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"%s: Invalid parameter for OQ\n","lio_validate_cn6xxx_config_info");
    
#line 786 
    __retres = 1;
    
#line 786 
    goto return_label;
  }
  else ;
  
#line 789 
  if ((unsigned int)conf6xxx->oq.oq_intr_time == 0U) {
    
#line 790 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"%s: No Time Interrupt for OQ\n","lio_validate_cn6xxx_config_info");
    
#line 792 
    __retres = 1;
    
#line 792 
    goto return_label;
  }
  else ;
  
#line 795 
  __retres = 0;
  return_label: 
#line 795 
                return __retres;
}


#line 747  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_cn66xx_device.c.aux"
static void ldv_spin_lock_73(spinlock_t *lock)
{
  
#line 751 
  ldv_spin_model_lock((char *)"lock_for_droq_int_enb_reg_of_octeon_cn6xxx");
  
#line 753 
  spin_lock_2(lock);
  
#line 754 
  return;
}


#line 757  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_cn66xx_device.c.aux"
static void ldv_spin_unlock_74(spinlock_t *lock)
{
  
#line 761 
  ldv_spin_model_unlock((char *)"lock_for_droq_int_enb_reg_of_octeon_cn6xxx");
  
#line 763 
  spin_unlock_2(lock);
  
#line 764 
  return;
}


#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/atomic.h"
static void atomic_dec_0(atomic_t *v);


#line 355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_bh_3(spinlock_t *lock)
{
  
#line 357 
  _raw_spin_lock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 358 
  return;
}


#line 383 
static void ldv_spin_lock_bh_74_0(spinlock_t *lock);


#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_bh_3(spinlock_t *lock)
{
  
#line 406 
  _raw_spin_unlock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 407 
  return;
}


#line 432 
static void ldv_spin_unlock_bh_75_1(spinlock_t *lock);


#line 436 
static void ldv_spin_unlock_bh_76_0(spinlock_t *lock);


#line 440 
static void ldv_spin_unlock_bh_77_2(spinlock_t *lock);


#line 505  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
static bool ldv_queue_delayed_work_73_0(struct workqueue_struct *wq, struct delayed_work *dwork, unsigned long delay);


#line 509 
static bool ldv_queue_delayed_work_78(struct workqueue_struct *wq, struct delayed_work *dwork, unsigned long delay);


#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-debug.h"
void debug_dma_sync_single_for_cpu(struct device *, dma_addr_t, size_t, int);


#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_cpu(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir)
{
  int tmp_0;
  
#line 106 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 108 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 108 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 110 
    ldv_inline_asm();
    
#line 108 
    ;
  }
  else ;
  
#line 109 
  if (ops->sync_single_for_cpu != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction ))0) 
    
#line 110 
    (*(ops->sync_single_for_cpu))(dev,addr,size,dir); else ;
  
#line 111 
  debug_dma_sync_single_for_cpu(dev,addr,size,(int)dir);
  
#line 112 
  return;
}


#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_main.h"
__inline static void octeon_swap_8B_data_4(u64 *data, u32 blocks)
{
  
#line 59 
  goto ldv_45891;
  ldv_45890: 
#line 60 
  ;
  
#line 60 
  __swab64s(data);
  
#line 61 
  blocks -= 1U;
  
#line 62 
  data += 1;
  ldv_45891: 
#line 63 
  ;
  
#line 59 
  if (blocks != 0U) 
#line 61 
                    goto ldv_45890; else 
#line 64 
                                         goto ldv_45892;
  ldv_45892: 
#line 65 
  ;
  
#line 66 
  return;
}


#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/response_manager.c"
static void oct_poll_req_completion(struct work_struct *work);


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/response_manager.c"
int octeon_setup_response_list(struct octeon_device *oct)
{
  int __retres;
  int i;
  struct cavium_wq *cwq;
  struct workqueue_struct *tmp_0;
  unsigned long tmp_1;
  
#line 49 
  int ret = 0;
  
#line 52 
  i = 0;
  
#line 52 
  goto ldv_46400;
  ldv_46399: 
#line 53 
  ;
  
#line 53 
  INIT_LIST_HEAD(& oct->response_list[i].head);
  
#line 54 
  spinlock_check(& oct->response_list[i].lock);
  {
    struct lock_class_key __key;
    
#line 54 
    __raw_spin_lock_init(& oct->response_list[i].lock.__anonCompField_spinlock_18.rlock,"&(&oct->response_list[i].lock)->rlock",& __key);
  }
  
#line 55 
  atomic_set(& oct->response_list[i].pending_req_count,0);
  
#line 52 
  i += 1;
  ldv_46400: 
#line 53 
  ;
  
#line 52 
  if (i <= 3) 
#line 54 
              goto ldv_46399; else 
#line 57 
                                   goto ldv_46401;
  ldv_46401: 
#line 58 
  ;
  {
    struct lock_class_key __key_0;
    char const *__lock_name;
    
#line 58 
    __lock_name = "\"%s\"";
    
#line 58 
    tmp_0 = __alloc_workqueue_key("%s",8U,1,& __key_0,__lock_name,(char *)"dma-comp");
  }
  
#line 58 
  oct->dma_comp_wq.wq = tmp_0;
  
#line 59 
  if (oct->dma_comp_wq.wq == (struct workqueue_struct *)0) {
    
#line 60 
    dev_err((struct device const *)(& (oct->pci_dev)->dev),"failed to create wq thread\n");
    
#line 61 
    __retres = -12;
    
#line 61 
    goto return_label;
  }
  else ;
  
#line 64 
  cwq = & oct->dma_comp_wq;
  {
    struct lock_class_key __key_1;
    
#line 65 
    __init_work(& cwq->wk.work.work,0);
    
#line 65 
    atomic_long_t __constr_expr_37 = {.counter = WORK_STRUCT_NO_POOL_2};
    
#line 65 
    cwq->wk.work.work.data = __constr_expr_37;
    
#line 65 
    lockdep_init_map(& cwq->wk.work.work.lockdep_map,"(&(&cwq->wk.work)->work)",& __key_1,0);
    
#line 65 
    INIT_LIST_HEAD(& cwq->wk.work.work.entry);
    
#line 65 
    cwq->wk.work.work.func = & oct_poll_req_completion;
  }
  {
    struct lock_class_key __key_2;
    
#line 65 
    init_timer_key(& cwq->wk.work.timer,2097152U,"(&(&cwq->wk.work)->timer)",& __key_2);
  }
  
#line 65 
  cwq->wk.work.timer.function = & delayed_work_timer_fn;
  
#line 65 
  cwq->wk.work.timer.data = (unsigned long)(& cwq->wk.work);
  
#line 66 
  cwq->wk.ctxptr = (void *)oct;
  
#line 67 
  tmp_1 = msecs_to_jiffies(100U);
  
#line 67 
  ;
  
#line 67 
  ;
  
#line 67 
  ldv_queue_delayed_work_73_0(cwq->wq,& cwq->wk.work,tmp_1);
  
#line 69 
  __retres = ret;
  return_label: 
#line 69 
                return __retres;
}


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/response_manager.c"
void octeon_delete_response_list(struct octeon_device *oct)
{
  
#line 74 
  cancel_delayed_work_sync(& oct->dma_comp_wq.wk.work);
  
#line 75 
  flush_workqueue(oct->dma_comp_wq.wq);
  
#line 76 
  destroy_workqueue(oct->dma_comp_wq.wq);
  
#line 77 
  return;
}


#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/response_manager.c"
int lio_process_ordered_list(struct octeon_device *octeon_dev, u32 force_quit)
{
  int __retres;
  struct octeon_response_list *ordered_sc_list;
  struct octeon_soft_command *sc;
  u32 status;
  u64 status64;
  struct octeon_instr_rdp *rdp;
  
#line 84 
  int request_complete = 0;
  
#line 85 
  int resp_to_process = 4096;
  
#line 90 
  ordered_sc_list = & octeon_dev->response_list[3];
  ldv_46429: 
#line 91 
  ;
  
#line 93 
  ldv_spin_lock_bh_74_0(& ordered_sc_list->lock);
  
#line 95 
  if (ordered_sc_list->head.next == & ordered_sc_list->head) {
    
#line 99 
    ldv_spin_unlock_bh_75_1(& ordered_sc_list->lock);
    
#line 101 
    __retres = 1;
    
#line 101 
    goto return_label;
  }
  else ;
  
#line 104 
  sc = (struct octeon_soft_command *)ordered_sc_list->head.next;
  
#line 106 
  rdp = (struct octeon_instr_rdp *)(& sc->cmd.rdp);
  
#line 108 
  status = 1U;
  
#line 113 
  dma_sync_single_for_cpu(& (octeon_dev->pci_dev)->dev,sc->cmd.rptr,(unsigned long)rdp->rlen,(enum dma_data_direction)DMA_FROM_DEVICE);
  
#line 116 
  status64 = *(sc->status_word);
  
#line 118 
  if (status64 != 18446744073709551615ULL) {
    
#line 119 
    if ((status64 & 255ULL) != 255ULL) {
      
#line 120 
      octeon_swap_8B_data_4(& status64,1U);
      
#line 121 
      if ((status64 & 255ULL) != 255ULL) 
#line 122 
                                         status = (unsigned int)status64; else ;
    }
    else ;
  }
  else 
    
#line 126 
    if (force_quit != 0U) 
#line 128 
                          status = 3U;
    else 
      
#line 126 
      if (sc->timeout != 0UL) {
        int tmp;
        {
          unsigned long __dummy;
          unsigned long volatile __dummy2;
          
#line 127 
          tmp = 1;
        }
        
#line 126 
        if (tmp != 0) {
          int tmp_0;
          {
            unsigned long __dummy_0;
            unsigned long __dummy2_0;
            
#line 127 
            tmp_0 = 1;
          }
          
#line 127 
          if (tmp_0 != 0) {
            
#line 127 
            if ((long)(sc->timeout - jiffies) < 0L) 
#line 128 
                                                    status = 3U; else ;
          }
          else ;
        }
        else ;
      }
      else ;
  
#line 131 
  if (status != 1U) {
    
#line 134 
    list_del(& sc->node);
    
#line 135 
    atomic_dec_0(& octeon_dev->response_list[3].pending_req_count);
    
#line 138 
    ldv_spin_unlock_bh_76_0(& ordered_sc_list->lock);
    
#line 141 
    if (sc->callback != (void (*)(struct octeon_device *, u32 , void *))0) 
      
#line 142 
      (*(sc->callback))(octeon_dev,status,sc->callback_arg); else ;
    
#line 145 
    request_complete += 1;
  }
  else {
    
#line 149 
    request_complete = 0;
    
#line 150 
    ldv_spin_unlock_bh_77_2(& ordered_sc_list->lock);
  }
  
#line 162 
  if (request_complete >= resp_to_process) 
#line 163 
                                           goto ldv_46428; else ;
  
#line 164 
  if (request_complete != 0) 
#line 166 
                             goto ldv_46429; else 
#line 169 
                                                  goto ldv_46428;
  ldv_46428: 
#line 170 
  ;
  
#line 166 
  __retres = 0;
  return_label: 
#line 166 
                return __retres;
}


#line 169  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/response_manager.c"
static void oct_poll_req_completion(struct work_struct *work)
{
  unsigned long tmp;
  
#line 171 
  struct cavium_wk *wk = (struct cavium_wk *)work;
  
#line 172 
  struct octeon_device *oct = (struct octeon_device *)wk->ctxptr;
  
#line 173 
  struct cavium_wq *cwq = & oct->dma_comp_wq;
  
#line 175 
  lio_process_ordered_list(oct,0U);
  
#line 177 
  tmp = msecs_to_jiffies(100U);
  
#line 177 
  ;
  
#line 177 
  ;
  
#line 177 
  ldv_queue_delayed_work_78(cwq->wq,& cwq->wk.work,tmp);
  
#line 178 
  return;
}


#line 129  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_response_manager.c.aux"
static void atomic_dec_0(atomic_t *v)
{
  
#line 132 
  ldv_atomic_dec(v);
  
#line 133 
  return;
}


#line 747  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_response_manager.c.aux"
static bool ldv_queue_delayed_work_73_0(struct workqueue_struct *wq, struct delayed_work *dwork, unsigned long delay)
{
  bool __retres;
  bool tmp;
  
#line 751 
  tmp = ldv_emg_queue_delayed_work(wq,dwork,delay);
  
#line 751 
  __retres = tmp != 0;
  
#line 751 
  return __retres;
}


#line 755  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_response_manager.c.aux"
static void ldv_spin_lock_bh_74_0(spinlock_t *lock)
{
  
#line 759 
  ldv_spin_model_lock((char *)"lock_of_octeon_response_list");
  
#line 761 
  spin_lock_bh_3(lock);
  
#line 762 
  return;
}


#line 765  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_response_manager.c.aux"
static void ldv_spin_unlock_bh_75_1(spinlock_t *lock)
{
  
#line 769 
  ldv_spin_model_unlock((char *)"lock_of_octeon_response_list");
  
#line 771 
  spin_unlock_bh_3(lock);
  
#line 772 
  return;
}


#line 775  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_response_manager.c.aux"
static void ldv_spin_unlock_bh_76_0(spinlock_t *lock)
{
  
#line 779 
  ldv_spin_model_unlock((char *)"lock_of_octeon_response_list");
  
#line 781 
  spin_unlock_bh_3(lock);
  
#line 782 
  return;
}


#line 785  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_response_manager.c.aux"
static void ldv_spin_unlock_bh_77_2(spinlock_t *lock)
{
  
#line 789 
  ldv_spin_model_unlock((char *)"lock_of_octeon_response_list");
  
#line 791 
  spin_unlock_bh_3(lock);
  
#line 792 
  return;
}


#line 795  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_response_manager.c.aux"
static bool ldv_queue_delayed_work_78(struct workqueue_struct *wq, struct delayed_work *dwork, unsigned long delay)
{
  bool __retres;
  bool tmp;
  
#line 799 
  tmp = ldv_emg_queue_delayed_work(wq,dwork,delay);
  
#line 799 
  __retres = tmp != 0;
  
#line 799 
  return __retres;
}


#line 442  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_irqrestore_2(spinlock_t *lock, unsigned long flags)
{
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
  }
  
#line 444 
  _raw_spin_unlock_irqrestore(& lock->__anonCompField_spinlock_18.rlock,flags);
  
#line 445 
  return;
}


#line 474 
static void ldv_spin_unlock_irqrestore_74(spinlock_t *lock, unsigned long flags);


#line 70  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_mem_ops.c.aux"
static void ldv___ldv_spin_lock_73(spinlock_t *ldv_func_arg1);


#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static unsigned char readb(void const volatile *addr)
{
  unsigned char ret;
  
#line 57 
  ldv_inline_asm();
  
#line 56 
  return ret;
}


#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static void writeb(unsigned char val, void volatile *addr)
{
  
#line 66 
  ldv_inline_asm();
  
#line 67 
  return;
}


#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_mem_ops.c"
__inline static void octeon_toggle_bar1_swapmode(struct octeon_device *oct, u32 idx)
{
  
#line 50 
  return;
}


#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_mem_ops.c"
static void octeon_pci_fastwrite(struct octeon_device *oct, u8 *mapped_addr, u8 *hostbuf, u32 len)
{
  u8 *tmp;
  u8 *tmp_0;
  u8 *tmp_1;
  u8 *tmp_2;
  u32 tmp_3;
  
#line 64 
  goto ldv_46391;
  ldv_46390: 
#line 65 
  ;
  
#line 65 
  tmp = mapped_addr;
  
#line 65 
  mapped_addr += 1;
  
#line 65 
  ;
  
#line 65 
  tmp_0 = hostbuf;
  
#line 65 
  hostbuf += 1;
  
#line 65 
  ;
  
#line 65 
  writeb((unsigned char)((int)*tmp_0),(void volatile *)tmp);
  
#line 66 
  len -= 1U;
  ldv_46391: 
#line 67 
  ;
  
#line 64 
  if (len != 0U && ((unsigned long)mapped_addr & 7UL) != 0UL) 
#line 66 
                                                              goto ldv_46390; else 
                                                                    
#line 69 
                                                                    goto ldv_46392;
  ldv_46392: 
#line 70 
  ;
  
#line 69 
  octeon_toggle_bar1_swapmode(oct,2U);
  
#line 71 
  goto ldv_46394;
  ldv_46393: 
#line 72 
  ;
  
#line 72 
  writeq((unsigned long)*((u64 *)hostbuf),(void volatile *)mapped_addr);
  
#line 73 
  mapped_addr += 8U;
  
#line 74 
  hostbuf += 8U;
  
#line 75 
  len += 4294967288U;
  ldv_46394: 
#line 76 
  ;
  
#line 71 
  if (len > 7U) 
#line 73 
                goto ldv_46393; else 
#line 76 
                                     goto ldv_46395;
  ldv_46395: 
#line 77 
  ;
  
#line 78 
  octeon_toggle_bar1_swapmode(oct,2U);
  
#line 80 
  goto ldv_46397;
  ldv_46396: 
#line 81 
  ;
  
#line 81 
  tmp_1 = mapped_addr;
  
#line 81 
  mapped_addr += 1;
  
#line 81 
  ;
  
#line 81 
  tmp_2 = hostbuf;
  
#line 81 
  hostbuf += 1;
  
#line 81 
  ;
  
#line 81 
  writeb((unsigned char)((int)*tmp_2),(void volatile *)tmp_1);
  ldv_46397: 
#line 82 
  ;
  
#line 80 
  tmp_3 = len;
  
#line 80 
  len -= 1U;
  
#line 80 
  ;
  
#line 80 
  if (tmp_3 != 0U) 
#line 82 
                   goto ldv_46396; else 
#line 85 
                                        goto ldv_46398;
  ldv_46398: 
#line 86 
  ;
  
#line 87 
  return;
}


#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_mem_ops.c"
static void octeon_pci_fastread(struct octeon_device *oct, u8 *mapped_addr, u8 *hostbuf, u32 len)
{
  u8 *tmp;
  u8 *tmp_0;
  u8 *tmp_2;
  u8 *tmp_3;
  u32 tmp_4;
  
#line 88 
  goto ldv_46406;
  ldv_46405: 
#line 89 
  ;
  
#line 89 
  tmp = hostbuf;
  
#line 89 
  hostbuf += 1;
  
#line 89 
  tmp_0 = mapped_addr;
  
#line 89 
  mapped_addr += 1;
  
#line 89 
  ;
  
#line 89 
  *tmp = readb((void const volatile *)tmp_0);
  
#line 90 
  len -= 1U;
  ldv_46406: 
#line 91 
  ;
  
#line 88 
  if (len != 0U && ((unsigned long)mapped_addr & 7UL) != 0UL) 
#line 90 
                                                              goto ldv_46405; else 
                                                                    
#line 93 
                                                                    goto ldv_46407;
  ldv_46407: 
#line 94 
  ;
  
#line 93 
  octeon_toggle_bar1_swapmode(oct,2U);
  
#line 95 
  goto ldv_46409;
  ldv_46408: 
#line 96 
  ;
  
#line 96 
  *((u64 *)hostbuf) = (u64)readq((void const volatile *)mapped_addr);
  
#line 97 
  mapped_addr += 8U;
  
#line 98 
  hostbuf += 8U;
  
#line 99 
  len += 4294967288U;
  ldv_46409: 
#line 100 
  ;
  
#line 95 
  if (len > 7U) 
#line 97 
                goto ldv_46408; else 
#line 100 
                                     goto ldv_46410;
  ldv_46410: 
#line 101 
  ;
  
#line 102 
  octeon_toggle_bar1_swapmode(oct,2U);
  
#line 104 
  goto ldv_46412;
  ldv_46411: 
#line 105 
  ;
  
#line 105 
  tmp_2 = hostbuf;
  
#line 105 
  hostbuf += 1;
  
#line 105 
  tmp_3 = mapped_addr;
  
#line 105 
  mapped_addr += 1;
  
#line 105 
  ;
  
#line 105 
  *tmp_2 = readb((void const volatile *)tmp_3);
  ldv_46412: 
#line 106 
  ;
  
#line 104 
  tmp_4 = len;
  
#line 104 
  len -= 1U;
  
#line 104 
  ;
  
#line 104 
  if (tmp_4 != 0U) 
#line 106 
                   goto ldv_46411; else 
#line 109 
                                        goto ldv_46413;
  ldv_46413: 
#line 110 
  ;
  
#line 111 
  return;
}


#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_mem_ops.c"
static void __octeon_pci_rw_core_mem(struct octeon_device *oct, u64 addr, u8 *hostbuf, u32 len, u32 op)
{
  unsigned long flags;
  u8 *mapped_addr;
  
#line 114 
  u32 copy_len = 0U;
  
#line 114 
  u32 index_reg_val = 0U;
  
#line 118 
  ldv___ldv_spin_lock_73(& oct->mem_access_lock);
  
#line 121 
  index_reg_val = (*(oct->fn_list.bar1_idx_read))(oct,2U);
  ldv_46425: 
#line 122 
  ;
  
#line 123 
  (*(oct->fn_list.bar1_idx_setup))(oct,addr,2U,1);
  
#line 124 
  mapped_addr = oct->mmio[1].hw_addr + ((addr & (unsigned long long)4194303U) + (unsigned long long)8388608U);
  
#line 131 
  if ((((((unsigned long long)len + addr) + 18446744073709551615ULL) ^ addr) & 18446744073705357312ULL) != 0ULL) 
    
#line 132 
    copy_len = (((unsigned int)addr & 4290772992U) - (unsigned int)addr) + 8388608U; else 
                                                                    
#line 135 
                                                                    copy_len = len;
  
#line 138 
  if (op != 0U) 
#line 139 
                octeon_pci_fastread(oct,mapped_addr,hostbuf,copy_len); else 
                                                                    
#line 142 
                                                                    octeon_pci_fastwrite(oct,mapped_addr,hostbuf,copy_len);
  
#line 146 
  len -= copy_len;
  
#line 147 
  addr = (unsigned long long)copy_len + addr;
  
#line 148 
  hostbuf += copy_len;
  
#line 150 
  if (len != 0U) 
#line 152 
                 goto ldv_46425; else 
#line 155 
                                      goto ldv_46426;
  ldv_46426: 
#line 156 
  ;
  
#line 152 
  (*(oct->fn_list.bar1_idx_write))(oct,2U,index_reg_val);
  
#line 154 
  ldv_spin_unlock_irqrestore_74(& oct->mem_access_lock,flags);
  
#line 155 
  return;
}


#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_mem_ops.c"
void octeon_pci_read_core_mem(struct octeon_device *oct, u64 coreaddr, u8 *buf, u32 len)
{
  
#line 163 
  __octeon_pci_rw_core_mem(oct,coreaddr,buf,len,1U);
  
#line 164 
  return;
}


#line 167  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_mem_ops.c"
void octeon_pci_write_core_mem(struct octeon_device *oct, u64 coreaddr, u8 *buf, u32 len)
{
  
#line 172 
  __octeon_pci_rw_core_mem(oct,coreaddr,buf,len,0U);
  
#line 173 
  return;
}


#line 175  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_mem_ops.c"
u64 octeon_read_device_mem64(struct octeon_device *oct, u64 coreaddr)
{
  __be64 ret;
  unsigned long long tmp_0;
  
#line 179 
  __octeon_pci_rw_core_mem(oct,coreaddr,(u8 *)(& ret),8U,1U);
  
#line 181 
  if (0 != 0) 
#line 181 
              tmp_0 = (((((((ret << 56) | ((ret << 40) & 71776119061217280ULL)) | ((ret << 24) & 280375465082880ULL)) | ((ret << 8) & 1095216660480ULL)) | ((ret >> 8) & 4278190080ULL)) | ((ret >> 24) & 16711680ULL)) | ((ret >> 40) & 65280ULL)) | (ret >> 56); else 
                                                                    
#line 181 
                                                                    tmp_0 = __fswab64(ret);
  
#line 181 
  return tmp_0;
}


#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_mem_ops.c"
u32 octeon_read_device_mem32(struct octeon_device *oct, u64 coreaddr)
{
  __be32 ret;
  unsigned int tmp_0;
  
#line 188 
  __octeon_pci_rw_core_mem(oct,coreaddr,(u8 *)(& ret),4U,1U);
  
#line 190 
  if (0 != 0) 
#line 190 
              tmp_0 = (((ret << 24) | ((ret << 8) & 16711680U)) | ((ret >> 8) & 65280U)) | (ret >> 24); else 
                                                                    
#line 190 
                                                                    tmp_0 = __fswab32(ret);
  
#line 190 
  return tmp_0;
}


#line 193  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/cavium/liquidio/octeon_mem_ops.c"
void octeon_write_device_mem32(struct octeon_device *oct, u64 coreaddr, u32 val)
{
  unsigned int tmp_0;
  
#line 196 
  if (0 != 0) 
#line 196 
              tmp_0 = (((val << 24) | ((val << 8) & 16711680U)) | ((val >> 8) & 65280U)) | (val >> 24); else 
                                                                    
#line 196 
                                                                    tmp_0 = __fswab32(val);
  
#line 196 
  __be32 t = tmp_0;
  
#line 198 
  __octeon_pci_rw_core_mem(oct,coreaddr,(u8 *)(& t),4U,0U);
  
#line 199 
  return;
}


#line 747  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_mem_ops.c.aux"
static void ldv___ldv_spin_lock_73(spinlock_t *ldv_func_arg1)
{
  
#line 751 
  ldv_spin_model_lock((char *)"mem_access_lock_of_octeon_device");
  
#line 753 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 754 
  return;
}


#line 757  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/weaver/.tmp_octeon_mem_ops.c.aux"
static void ldv_spin_unlock_irqrestore_74(spinlock_t *lock, unsigned long flags)
{
  
#line 761 
  ldv_spin_model_unlock((char *)"mem_access_lock_of_octeon_device");
  
#line 763 
  spin_unlock_irqrestore_2(lock,flags);
  
#line 764 
  return;
}


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_add(int i, atomic_t *v)
{
  
#line 23 
  v->counter += i;
  
#line 24 
  return;
}


#line 27  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_sub(int i, atomic_t *v)
{
  
#line 29 
  v->counter -= i;
  
#line 30 
  return;
}


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_sub_and_test(int i, atomic_t *v)
{
  int __retres;
  
#line 35 
  v->counter -= i;
  
#line 36 
  if (v->counter != 0) {
    
#line 37 
    __retres = 0;
    
#line 37 
    goto return_label;
  }
  else ;
  
#line 39 
  __retres = 1;
  return_label: 
#line 39 
                return __retres;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_inc(atomic_t *v)
{
  
#line 45 
  v->counter += 1;
  
#line 46 
  return;
}


#line 49  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_dec(atomic_t *v)
{
  
#line 51 
  v->counter -= 1;
  
#line 52 
  return;
}


#line 55  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_dec_and_test(atomic_t *v)
{
  int __retres;
  
#line 57 
  v->counter -= 1;
  
#line 58 
  if (v->counter != 0) {
    
#line 59 
    __retres = 0;
    
#line 59 
    goto return_label;
  }
  else ;
  
#line 61 
  __retres = 1;
  return_label: 
#line 61 
                return __retres;
}


#line 65  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_inc_and_test(atomic_t *v)
{
  int __retres;
  
#line 67 
  v->counter += 1;
  
#line 68 
  if (v->counter != 0) {
    
#line 69 
    __retres = 0;
    
#line 69 
    goto return_label;
  }
  else ;
  
#line 71 
  __retres = 1;
  return_label: 
#line 71 
                return __retres;
}


#line 75  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_add_return(int i, atomic_t *v)
{
  int __retres;
  
#line 77 
  v->counter += i;
  
#line 78 
  __retres = v->counter;
  
#line 78 
  return __retres;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_add_negative(int i, atomic_t *v)
{
  int __retres;
  
#line 84 
  v->counter += i;
  
#line 85 
  __retres = v->counter < 0;
  
#line 85 
  return __retres;
}


#line 89  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_inc_short(short *v)
{
  int __retres;
  
#line 91 
  *v = (short)((unsigned int)*v + 1U);
  
#line 92 
  __retres = (int)*v;
  
#line 92 
  return __retres;
}


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/device.h"
void *ldv_dev_get_drvdata(struct device const *dev);


#line 24 
int ldv_dev_set_drvdata(struct device *dev, void *data);


#line 30  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_xmalloc(size_t size);


#line 31 
void *ldv_xzalloc(size_t size);


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
struct ldv_list_element global_list = {.data = (void *)0, .next = (struct ldv_list_element *)0};

#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
__inline static ldv_list_ptr ldv_list_create(void *data)
{
  
#line 35 
  ldv_list_ptr list = (struct ldv_list_element *)0;
  
#line 37 
  list = (ldv_list_ptr)ldv_xmalloc(16UL);
  
#line 39 
  list->data = data;
  
#line 40 
  list->next = (struct ldv_list_element *)0;
  
#line 42 
  return list;
}


#line 45  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
__inline static void ldv_save_pointer(void *data)
{
  ldv_list_ptr element;
  ldv_list_ptr cached;
  
#line 50 
  if (global_list.data == (void *)0) {
    
#line 51 
    element = & global_list;
    
#line 52 
    element->data = data;
  }
  else {
    
#line 54 
    element = ldv_list_create(data);
    
#line 55 
    cached = global_list.next;
    
#line 56 
    global_list.next = element;
    
#line 57 
    element->next = cached;
  }
  
#line 60 
  return;
}


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
void *ldv_dev_get_drvdata(struct device const *dev)
{
  void *__retres;
  
#line 30 
  if (dev != (struct device const *)0 && dev->p != (struct device_private *)0) {
    
#line 31 
    __retres = (dev->p)->driver_data;
    
#line 31 
    goto return_label;
  }
  else ;
  
#line 33 
  __retres = (void *)0;
  return_label: 
#line 33 
                return __retres;
}


#line 42  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
int ldv_dev_set_drvdata(struct device *dev, void *data)
{
  int __retres;
  
#line 44 
  dev->p = (struct device_private *)ldv_xzalloc(8UL);
  
#line 45 
  ldv_save_pointer((void *)dev->p);
  
#line 46 
  (dev->p)->driver_data = data;
  
#line 48 
  __retres = 0;
  
#line 48 
  return __retres;
}


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_zalloc(size_t size);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/spi.c"
struct spi_master *ldv_spi_alloc_master(struct device *host, unsigned int size)
{
  struct spi_master *__retres;
  struct spi_master *master;
  
#line 27 
  master = (struct spi_master *)ldv_zalloc((unsigned long)size + 2192UL);
  
#line 29 
  if (master == (struct spi_master *)0) {
    
#line 30 
    __retres = (struct spi_master *)0;
    
#line 30 
    goto return_label;
  }
  else ;
  
#line 32 
  ldv_dev_set_drvdata(& master->dev,(void *)(master + 1U));
  
#line 34 
  __retres = master;
  return_label: 
#line 34 
                return __retres;
}


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/err.h"
long ldv_is_err_or_null(void const *ptr);


#line 29 
void *ldv_err_ptr(long error);


#line 30 
long ldv_ptr_err(void const *ptr);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/common.h"
void __VERIFIER_assume(int);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_is_err(void const *ptr)
{
  long __retres;
  
#line 23 
  __retres = (long)((unsigned long)ptr > 4294967295UL);
  
#line 23 
  return __retres;
}


#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
void *ldv_err_ptr(long error)
{
  void *__retres;
  
#line 28 
  __VERIFIER_assume(error < 0L);
  
#line 29 
  __retres = (void *)(4294967295L - error);
  
#line 29 
  return __retres;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_ptr_err(void const *ptr)
{
  long __retres;
  
#line 34 
  __VERIFIER_assume((unsigned long)ptr > 4294967295UL);
  
#line 35 
  __retres = (long)(4294967295UL - (unsigned long)ptr);
  
#line 35 
  return __retres;
}


#line 38  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_is_err_or_null(void const *ptr)
{
  long __retres;
  int tmp_0;
  
#line 40 
  if (ptr == (void const *)0) 
#line 40 
                              tmp_0 = 1;
  else {
    long tmp;
    
#line 40 
    tmp = ldv_is_err(ptr);
    
#line 40 
    if (tmp != 0L) 
#line 40 
                   tmp_0 = 1; else 
#line 40 
                                   tmp_0 = 0;
  }
  
#line 40 
  __retres = (long)tmp_0;
  
#line 40 
  return __retres;
}


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/panic.h"
void ldv_panic(void);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/kernel/panic.c"
void ldv_panic(void)
{
  
#line 23 
  __VERIFIER_assume(0);
  
#line 24 
  return;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.h"
void ldv_switch_to_interrupt_context(void);


#line 42 
void ldv_switch_to_process_context(void);


#line 50 
bool ldv_in_interrupt_context(void);


#line 112 
int ldv_post_init(int init_ret_val);


#line 132 
int ldv_post_probe(int probe_ret_val);


#line 133 
void ldv_check_return_value_probe(int);


#line 141 
int ldv_filter_err_code(int ret_val);


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
static bool __ldv_in_interrupt_context = (_Bool)0;

#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
void ldv_switch_to_interrupt_context(void)
{
  
#line 30 
  __ldv_in_interrupt_context = (_Bool)1;
  
#line 31 
  return;
}


#line 34  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
void ldv_switch_to_process_context(void)
{
  
#line 36 
  __ldv_in_interrupt_context = (_Bool)0;
  
#line 37 
  return;
}


#line 39  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
bool ldv_in_interrupt_context(void)
{
  
#line 41 
  return __ldv_in_interrupt_context;
}


#line 44  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
static int ldv_filter_positive_int(int val)
{
  
#line 46 
  __VERIFIER_assume(val <= 0);
  
#line 47 
  return val;
}


#line 54  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_post_init(int init_ret_val)
{
  int tmp;
  
#line 56 
  tmp = ldv_filter_positive_int(init_ret_val);
  
#line 56 
  return tmp;
}


#line 60  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_post_probe(int probe_ret_val)
{
  int tmp;
  
#line 62 
  ldv_check_return_value_probe(probe_ret_val);
  
#line 63 
  tmp = ldv_filter_positive_int(probe_ret_val);
  
#line 63 
  return tmp;
}


#line 67  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_filter_err_code(int ret_val)
{
  int tmp;
  
#line 69 
  tmp = ldv_filter_positive_int(ret_val);
  
#line 69 
  return tmp;
}


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kzalloc(size_t size, gfp_t flags);


#line 25 
void *ldv_kcalloc(size_t n, size_t size, gfp_t flags);


#line 26 
void *ldv_kmalloc_array(size_t n, size_t size, gfp_t flags);


#line 28 
void ldv_check_alloc_flags(gfp_t);


#line 29 
void ldv_after_alloc(void *);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_malloc(size_t size);


#line 24 
void *ldv_calloc(size_t nmemb, size_t size);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc(size_t size, gfp_t flags)
{
  void *res;
  
#line 25 
  ldv_check_alloc_flags(flags);
  
#line 26 
  res = ldv_malloc(size);
  
#line 27 
  ldv_after_alloc(res);
  
#line 29 
  return res;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kcalloc(size_t n, size_t size, gfp_t flags)
{
  void *res;
  
#line 36 
  ldv_check_alloc_flags(flags);
  
#line 37 
  res = ldv_calloc(n,size);
  
#line 38 
  ldv_after_alloc(res);
  
#line 40 
  return res;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kzalloc(size_t size, gfp_t flags)
{
  void *res;
  
#line 47 
  ldv_check_alloc_flags(flags);
  
#line 48 
  res = ldv_zalloc(size);
  
#line 49 
  ldv_after_alloc(res);
  
#line 51 
  return res;
}


#line 54  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc_array(size_t n, size_t size, gfp_t flags)
{
  void *res;
  
#line 58 
  ldv_check_alloc_flags(flags);
  
#line 59 
  res = ldv_malloc(n * size);
  
#line 60 
  ldv_after_alloc(res);
  
#line 62 
  return res;
}


#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void ldv_free(void *s);


#line 35 
void *ldv_malloc_unknown_size(void);


#line 36 
void *ldv_calloc_unknown_size(void);


#line 37 
void *ldv_zalloc_unknown_size(void);


#line 40 
void *ldv_reference_malloc(size_t size);


#line 41 
void *ldv_reference_calloc(size_t nmemb, size_t size);


#line 42 
void *ldv_reference_zalloc(size_t size);


#line 43 
void ldv_reference_free(void *s);


#line 47 
void *ldv_reference_xmalloc(size_t size);


#line 48 
void *ldv_reference_xzalloc(size_t size);


#line 52 
void *ldv_reference_malloc_unknown_size(void);


#line 53 
void *ldv_reference_calloc_unknown_size(void);


#line 54 
void *ldv_reference_zalloc_unknown_size(void);


#line 61 
void *ldv_xmalloc_unknown_size(size_t size);


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_reference_xmalloc_unknown_size(size_t size);


#line 34  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_malloc(size_t size)
{
  void *res;
  
#line 37 
  res = ldv_reference_malloc(size);
  
#line 38 
  if (res != (void *)0) {
    long tmp;
    
#line 39 
    tmp = ldv_is_err((void const *)res);
    
#line 39 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 40 
  return res;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc(size_t nmemb, size_t size)
{
  void *res;
  
#line 46 
  res = ldv_reference_calloc(nmemb,size);
  
#line 47 
  if (res != (void *)0) {
    long tmp;
    
#line 48 
    tmp = ldv_is_err((void const *)res);
    
#line 48 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 49 
  return res;
}


#line 52  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc(size_t size)
{
  void *res;
  
#line 55 
  res = ldv_reference_zalloc(size);
  
#line 56 
  if (res != (void *)0) {
    long tmp;
    
#line 57 
    tmp = ldv_is_err((void const *)res);
    
#line 57 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 58 
  return res;
}


#line 61  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void ldv_free(void *s)
{
  
#line 63 
  ldv_reference_free(s);
  
#line 64 
  return;
}


#line 66  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc(size_t size)
{
  void *res;
  long tmp;
  
#line 69 
  res = ldv_reference_xmalloc(size);
  
#line 70 
  tmp = ldv_is_err((void const *)res);
  
#line 70 
  __VERIFIER_assume(tmp == 0L);
  
#line 71 
  return res;
}


#line 74  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xzalloc(size_t size)
{
  void *res;
  long tmp;
  
#line 77 
  res = ldv_reference_xzalloc(size);
  
#line 78 
  tmp = ldv_is_err((void const *)res);
  
#line 78 
  __VERIFIER_assume(tmp == 0L);
  
#line 79 
  return res;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_malloc_unknown_size(void)
{
  void *res;
  
#line 85 
  res = ldv_reference_malloc_unknown_size();
  
#line 86 
  if (res != (void *)0) {
    long tmp;
    
#line 87 
    tmp = ldv_is_err((void const *)res);
    
#line 87 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 88 
  return res;
}


#line 91  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc_unknown_size(void)
{
  void *res;
  
#line 94 
  res = ldv_reference_calloc_unknown_size();
  
#line 95 
  if (res != (void *)0) {
    long tmp;
    
#line 96 
    tmp = ldv_is_err((void const *)res);
    
#line 96 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 97 
  return res;
}


#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc_unknown_size(void)
{
  void *res;
  
#line 103 
  res = ldv_reference_zalloc_unknown_size();
  
#line 104 
  if (res != (void *)0) {
    long tmp;
    
#line 105 
    tmp = ldv_is_err((void const *)res);
    
#line 105 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 106 
  return res;
}


#line 109  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc_unknown_size(size_t size)
{
  void *res;
  long tmp;
  
#line 112 
  res = ldv_reference_xmalloc_unknown_size(size);
  
#line 113 
  tmp = ldv_is_err((void const *)res);
  
#line 113 
  __VERIFIER_assume(tmp == 0L);
  
#line 114 
  return res;
}

long __builtin_expect(long exp, long c);


#line 22  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/common.h"
void __VERIFIER_error(void);


#line 24  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/gcc.c"
long __builtin_expect(long exp, long c)
{
  
#line 26 
  return exp;
}


#line 35  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/gcc.c"
void __builtin_trap(void)
{
  
#line 37 
  __VERIFIER_error();
  
#line 38 
  return;
}


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
int ldv_undef_int(void);


#line 24 
int ldv_undef_long(void);


#line 25 
unsigned int ldv_undef_uint(void);


#line 26 
unsigned long ldv_undef_ulong(void);


#line 27 
unsigned long long ldv_undef_ulonglong(void);


#line 28 
void *ldv_undef_ptr(void);


#line 31 
int ldv_undef_int_positive(void);


#line 34 
int ldv_undef_int_negative(void);


#line 37 
int ldv_undef_int_nonpositive(void);


#line 40 
void *ldv_undef_ptr_non_null(void);


#line 29  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int __VERIFIER_nondet_int(void);


#line 31 
long __VERIFIER_nondet_long(void);


#line 38 
unsigned int __VERIFIER_nondet_uint(void);


#line 41 
unsigned long __VERIFIER_nondet_ulong(void);


#line 42 
unsigned long long __VERIFIER_nondet_ulonglong(void);


#line 43 
void *__VERIFIER_nondet_pointer(void);


#line 46  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int(void)
{
  int tmp;
  
#line 48 
  tmp = __VERIFIER_nondet_int();
  
#line 48 
  return tmp;
}


#line 51  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_long(void)
{
  int __retres;
  long tmp;
  
#line 53 
  tmp = __VERIFIER_nondet_long();
  
#line 53 
  __retres = (int)tmp;
  
#line 53 
  return __retres;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned int ldv_undef_uint(void)
{
  unsigned int tmp;
  
#line 58 
  tmp = __VERIFIER_nondet_uint();
  
#line 58 
  return tmp;
}


#line 61  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr(void)
{
  void *tmp;
  
#line 63 
  tmp = __VERIFIER_nondet_pointer();
  
#line 63 
  return tmp;
}


#line 66  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long ldv_undef_ulong(void)
{
  unsigned long tmp;
  
#line 68 
  tmp = __VERIFIER_nondet_ulong();
  
#line 68 
  return tmp;
}


#line 71  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long long ldv_undef_ulonglong(void)
{
  unsigned long long tmp;
  
#line 73 
  tmp = __VERIFIER_nondet_ulonglong();
  
#line 73 
  return tmp;
}


#line 76  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_positive(void)
{
  
#line 78 
  int ret = ldv_undef_int();
  
#line 80 
  __VERIFIER_assume(ret > 0);
  
#line 82 
  return ret;
}


#line 85  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_negative(void)
{
  
#line 87 
  int ret = ldv_undef_int();
  
#line 89 
  __VERIFIER_assume(ret < 0);
  
#line 91 
  return ret;
}


#line 94  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_nonpositive(void)
{
  
#line 96 
  int ret = ldv_undef_int();
  
#line 98 
  __VERIFIER_assume(ret <= 0);
  
#line 100 
  return ret;
}


#line 103  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr_non_null(void)
{
  
#line 105 
  void *ret = ldv_undef_ptr();
  
#line 107 
  __VERIFIER_assume(ret != (void *)0);
  
#line 109 
  return ret;
}


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *external_allocated_data(void);


#line 45 
void *ldv_reference_realloc(void *ptr, size_t size);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *malloc(size_t);


#line 24 
void *calloc(size_t, size_t);


#line 25 
void free(void *);


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc(size_t size)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 37 
  tmp = ldv_undef_int();
  
#line 37 
  if (tmp != 0) {
    
#line 39 
    res = malloc(size);
    
#line 40 
    __VERIFIER_assume(res != (void *)0);
    
#line 41 
    __retres = res;
    
#line 41 
    goto return_label;
  }
  else {
    
#line 44 
    __retres = (void *)0;
    
#line 44 
    goto return_label;
  }
  return_label: 
#line 37 
                return __retres;
}


#line 47  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc(size_t nmemb, size_t size)
{
  void *tmp;
  
#line 49 
  tmp = calloc(nmemb,size);
  
#line 49 
  return tmp;
}


#line 52  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc(size_t size)
{
  void *tmp;
  
#line 54 
  tmp = calloc(1UL,size);
  
#line 54 
  return tmp;
}


#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void ldv_reference_free(void *s)
{
  
#line 59 
  free(s);
  
#line 60 
  return;
}


#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_realloc(void *ptr, size_t size)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 66 
  if (ptr != (void *)0 && size == 0UL) {
    
#line 67 
    free(ptr);
    
#line 68 
    __retres = (void *)0;
    
#line 68 
    goto return_label;
  }
  else ;
  
#line 71 
  if (ptr == (void *)0) {
    
#line 72 
    res = malloc(size);
    
#line 73 
    __retres = res;
    
#line 73 
    goto return_label;
  }
  else ;
  
#line 76 
  tmp = ldv_undef_int();
  
#line 76 
  if (tmp != 0) {
    
#line 78 
    res = malloc(size);
    
#line 79 
    __VERIFIER_assume(res != (void *)0);
    
#line 81 
    memcpy(res,(void const *)ptr,size);
    
#line 82 
    free(ptr);
    
#line 84 
    __retres = res;
    
#line 84 
    goto return_label;
  }
  else {
    
#line 87 
    __retres = (void *)0;
    
#line 87 
    goto return_label;
  }
  return_label: 
#line 76 
                return __retres;
}


#line 90  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc(size_t size)
{
  void *res;
  
#line 94 
  res = malloc(size);
  
#line 95 
  __VERIFIER_assume(res != (void *)0);
  
#line 97 
  return res;
}


#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xzalloc(size_t size)
{
  void *res;
  
#line 104 
  res = calloc(1UL,size);
  
#line 105 
  __VERIFIER_assume(res != (void *)0);
  
#line 107 
  return res;
}


#line 110  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc_unknown_size(void)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 114 
  tmp = ldv_undef_int();
  
#line 114 
  if (tmp != 0) {
    
#line 115 
    res = external_allocated_data();
    
#line 116 
    __VERIFIER_assume(res != (void *)0);
    
#line 117 
    __retres = res;
    
#line 117 
    goto return_label;
  }
  else {
    
#line 120 
    __retres = (void *)0;
    
#line 120 
    goto return_label;
  }
  return_label: 
#line 114 
                return __retres;
}


#line 123  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc_unknown_size(void)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 127 
  tmp = ldv_undef_int();
  
#line 127 
  if (tmp != 0) {
    
#line 128 
    res = external_allocated_data();
    
#line 129 
    memset(res,0,8UL);
    
#line 130 
    __VERIFIER_assume(res != (void *)0);
    
#line 131 
    __retres = res;
    
#line 131 
    goto return_label;
  }
  else {
    
#line 134 
    __retres = (void *)0;
    
#line 134 
    goto return_label;
  }
  return_label: 
#line 127 
                return __retres;
}


#line 137  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc_unknown_size(void)
{
  void *tmp;
  
#line 139 
  tmp = ldv_reference_calloc_unknown_size();
  
#line 139 
  return tmp;
}


#line 142  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc_unknown_size(size_t size)
{
  void *res;
  
#line 146 
  res = external_allocated_data();
  
#line 147 
  __VERIFIER_assume(res != (void *)0);
  
#line 149 
  return res;
}


#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.h"
void ldv_initialize(void);


#line 97 
void ldv_failed_register_netdev(void);


#line 123 
void ldv_pre_probe(void);


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
int pthread_create(pthread_t *, pthread_attr_t const *, void *(*)(void *), void *);


#line 37 
int pthread_join(pthread_t, void **);


#line 86  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_register_10_4(struct net_device *arg0);


#line 87 
void ldv_dispatch_irq_register_12_3(int arg0, enum irqreturn (*arg1)(int , void *), enum irqreturn (*arg2)(int , void *), void *arg3);


#line 89 
void ldv_dispatch_register_11_3(struct pci_driver *arg0);


#line 91 
void *ldv_pci_scenario_14(void *arg0);


#line 92 
void ldv_dispatch_deregister_9_1(struct pci_driver *arg0);


#line 93 
void *ldv_initialization_1(void *arg0);


#line 94 
int main(void);


#line 95 
void ldv_dispatch_deregister_4_1(struct net_device *arg0);


#line 97 
void ldv_dispatch_irq_deregister_7_1(int arg0);


#line 102 
void *ldv_random_allocationless_scenario_16(void *arg0);


#line 103 
void *ldv_interrupt_scenario_15(void *arg0);


#line 107  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_14;

#line 108  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_15;

#line 109  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_16;

#line 113  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_tasklet_init(struct tasklet_struct *arg0, void (*arg1)(unsigned long ), unsigned long arg2)
{
  
#line 118 
  arg0->func = arg1;
  
#line 119 
  arg0->data = arg2;
  
#line 120 
  arg0->count.counter = 0;
  
#line 124 
  goto return_label;
  return_label: 
#line 126 
                return;
}


#line 131  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg___pci_register_driver(struct pci_driver *arg0, struct module *arg1, char *arg2)
{
  int __retres;
  int tmp_0;
  
#line 134 
  struct pci_driver *ldv_11_pci_driver = ldv_emg_alias_liquidio_pci_driver_2;
  
#line 138 
  tmp_0 = ldv_undef_int();
  
#line 138 
  if (tmp_0 != 0) {
    
#line 140 
    ldv_11_pci_driver = arg0;
    
#line 144 
    ldv_dispatch_register_11_3(ldv_11_pci_driver);
    
#line 148 
    __retres = 0;
    
#line 148 
    goto return_label;
  }
  else {
    int tmp;
    
#line 155 
    tmp = ldv_undef_int_negative();
    
#line 155 
    __retres = tmp;
    
#line 155 
    goto return_label;
  }
  return_label: 
#line 138 
                return __retres;
}


#line 165  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/emg/environment_model.c"
_Bool ldv_emg_schedule_delayed_work(struct delayed_work *arg0, unsigned long arg1)
{
  _Bool __retres;
  struct work_struct *ldv_8_ldv_param_0_2;
  struct delayed_work *ldv_8_delayed_work;
  int tmp_0;
  
#line 173 
  tmp_0 = ldv_undef_int();
  
#line 173 
  if (tmp_0 != 0) {
    
#line 175 
    ldv_8_delayed_work = arg0;
    
#line 179 
    ldv_8_ldv_param_0_2 = (struct work_struct *)ldv_xmalloc_unknown_size(0UL);
    
#line 183 
    if (ldv_8_delayed_work->work.func != (void (*)(struct work_struct *))0) 
      
#line 185 
      (*(ldv_8_delayed_work->work.func))(ldv_8_ldv_param_0_2); else ;
    
#line 190 
    ldv_free((void *)ldv_8_ldv_param_0_2);
    
#line 194 
    __retres = (_Bool)1;
    
#line 194 
    goto return_label;
  }
  else {
    
#line 201 
    __retres = (_Bool)0;
    
#line 201 
    goto return_label;
  }
  return_label: 
#line 173 
                return __retres;
}


#line 211  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_tasklet_schedule(struct tasklet_struct *arg0)
{
  unsigned long ldv_13_ldv_param_0_2;
  struct tasklet_struct *ldv_13_tasklet_struct;
  
#line 218 
  ldv_13_tasklet_struct = arg0;
  
#line 225 
  if (ldv_13_tasklet_struct->count.counter == 0) 
#line 227 
                                                 (*ldv_emg_alias_None_2)(ldv_13_ldv_param_0_2); else ;
  
#line 235 
  goto return_label;
  return_label: 
#line 237 
                return;
}


#line 242  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_irq_deregister_7_1(int arg0)
{
  int ret;
  struct ldv_struct_free_irq_7 *cf_arg_15;
  int tmp;
  
#line 245 
  tmp = ldv_undef_int();
  
#line 245 
  switch (tmp) {
    case 0: 
#line 246 
    ;
    
#line 247 
    ret = pthread_join(ldv_thread_15,(void **)0);
    
#line 248 
    __VERIFIER_assume(ret == 0);
    
#line 249 
    goto ldv_44764;
    default: 
#line 251 
    ;
    
#line 251 
    __VERIFIER_assume(0);
  }
  ldv_44764: 
#line 252 
  ;
  
#line 253 
  return;
}


#line 257  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_irq_register_12_3(int arg0, enum irqreturn (*arg1)(int , void *), enum irqreturn (*arg2)(int , void *), void *arg3)
{
  int ret;
  struct ldv_struct_interrupt_scenario_15 *cf_arg_15;
  int tmp;
  
#line 260 
  tmp = ldv_undef_int();
  
#line 260 
  switch (tmp) {
    case 0: 
#line 261 
    ;
    
#line 262 
    cf_arg_15 = (struct ldv_struct_interrupt_scenario_15 *)ldv_xmalloc(32UL);
    
#line 263 
    cf_arg_15->arg0 = arg0;
    
#line 264 
    cf_arg_15->arg1 = arg1;
    
#line 265 
    cf_arg_15->arg2 = arg2;
    
#line 266 
    cf_arg_15->arg3 = arg3;
    
#line 267 
    ret = pthread_create(& ldv_thread_15,(pthread_attr_t const *)0,& ldv_interrupt_scenario_15,(void *)cf_arg_15);
    
#line 268 
    __VERIFIER_assume(ret == 0);
    
#line 269 
    goto ldv_44779;
    default: 
#line 271 
    ;
    
#line 271 
    __VERIFIER_assume(0);
  }
  ldv_44779: 
#line 272 
  ;
  
#line 273 
  return;
}


#line 277  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/emg/environment_model.c"
struct net_device *ldv_emg_alloc_etherdev_mqs(int arg0, unsigned int arg1, unsigned int arg2)
{
  struct net_device *__retres;
  struct net_device *ldv_3_netdev;
  int tmp_0;
  
#line 284 
  tmp_0 = ldv_undef_int();
  
#line 284 
  if (tmp_0 != 0) {
    
#line 286 
    ldv_3_netdev = (struct net_device *)ldv_xmalloc_unknown_size(0UL);
    
#line 290 
    __retres = ldv_3_netdev;
    
#line 290 
    goto return_label;
  }
  else {
    
#line 297 
    __retres = (struct net_device *)0;
    
#line 297 
    goto return_label;
  }
  return_label: 
#line 284 
                return __retres;
}


#line 307  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_register_11_3(struct pci_driver *arg0)
{
  int ret;
  struct ldv_struct_pci_scenario_14 *cf_arg_14;
  int tmp;
  
#line 310 
  tmp = ldv_undef_int();
  
#line 310 
  switch (tmp) {
    case 0: 
#line 311 
    ;
    
#line 312 
    cf_arg_14 = (struct ldv_struct_pci_scenario_14 *)ldv_xmalloc(16UL);
    
#line 313 
    cf_arg_14->arg0 = arg0;
    
#line 314 
    ret = pthread_create(& ldv_thread_14,(pthread_attr_t const *)0,& ldv_pci_scenario_14,(void *)cf_arg_14);
    
#line 315 
    __VERIFIER_assume(ret == 0);
    
#line 316 
    goto ldv_44793;
    default: 
#line 318 
    ;
    
#line 318 
    __VERIFIER_assume(0);
  }
  ldv_44793: 
#line 319 
  ;
  
#line 320 
  return;
}


#line 324  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_request_irq(unsigned int arg0, enum irqreturn (*arg1)(int , void *), unsigned long arg2, char *arg3, void *arg4)
{
  int __retres;
  int ldv_12_line;
  void *ldv_12_data;
  enum irqreturn (*ldv_12_thread)(int , void *);
  int tmp_0;
  
#line 329 
  enum irqreturn (*ldv_12_callback)(int , void *) = & ldv_emg_wrapper_liquidio_intr_handler_2;
  
#line 334 
  tmp_0 = ldv_undef_int();
  
#line 334 
  if (tmp_0 != 0) {
    
#line 336 
    ldv_12_line = (int)arg0;
    
#line 337 
    ldv_12_callback = arg1;
    
#line 338 
    ldv_12_thread = (enum irqreturn (*)(int , void *))0;
    
#line 339 
    ldv_12_data = arg4;
    
#line 343 
    ldv_dispatch_irq_register_12_3(ldv_12_line,ldv_12_callback,ldv_12_thread,ldv_12_data);
    
#line 347 
    __retres = 0;
    
#line 347 
    goto return_label;
  }
  else {
    int tmp;
    
#line 354 
    tmp = ldv_undef_int_negative();
    
#line 354 
    __retres = tmp;
    
#line 354 
    goto return_label;
  }
  return_label: 
#line 334 
                return __retres;
}


#line 364  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_pci_scenario_14(void *arg0)
{
  void *__retres;
  struct pci_dev *ldv_14_resource_1;
  struct pci_device_id *ldv_14_ldv_param_1_2;
  struct pm_message ldv_14_resource_0;
  int tmp_2;
  int tmp_3;
  
#line 369 
  struct pci_driver *ldv_14_container = ldv_emg_alias_liquidio_pci_driver_2;
  
#line 370 
  int ldv_14_ret = ldv_undef_int();
  
#line 373 
  struct ldv_struct_pci_scenario_14 *data = (struct ldv_struct_pci_scenario_14 *)arg0;
  
#line 377 
  ldv_14_ret = ldv_undef_int();
  
#line 380 
  if (data != (struct ldv_struct_pci_scenario_14 *)0) {
    
#line 381 
    ldv_14_container = data->arg0;
    
#line 382 
    ldv_free((void *)data);
  }
  else ;
  
#line 393 
  goto ldv_main_14;
  
#line 395 
  __retres = (void *)0;
  
#line 395 
  goto return_label;
  ldv_main_14: 
#line 398 
  ;
  
#line 401 
  tmp_2 = ldv_undef_int();
  
#line 401 
  if (tmp_2 != 0) {
    int tmp_1;
    
#line 403 
    ldv_14_ldv_param_1_2 = (struct pci_device_id *)ldv_xmalloc_unknown_size(0UL);
    
#line 408 
    ldv_pre_probe();
    
#line 410 
    ldv_14_ret = ldv_emg_wrapper_liquidio_probe_2(ldv_14_resource_1,ldv_14_ldv_param_1_2);
    
#line 412 
    ldv_14_ret = ldv_post_probe(ldv_14_ret);
    
#line 416 
    ldv_free((void *)ldv_14_ldv_param_1_2);
    
#line 419 
    tmp_1 = ldv_undef_int();
    
#line 419 
    if (tmp_1 != 0) {
      
#line 421 
      __VERIFIER_assume(ldv_14_ret == 0);
      
#line 428 
      goto ldv_call_14;
    }
    else {
      
#line 432 
      __VERIFIER_assume(ldv_14_ret != 0);
      
#line 439 
      goto ldv_main_14;
    }
  }
  else {
    
#line 451 
    __retres = (void *)0;
    
#line 451 
    goto return_label;
  }
  
#line 454 
  __retres = (void *)0;
  
#line 454 
  goto return_label;
  ldv_call_14: 
#line 457 
  ;
  
#line 460 
  tmp_3 = ldv_undef_int();
  
#line 460 
  switch (tmp_3) {
    case 1: 
#line 461 
    ;
    
#line 470 
    goto ldv_call_14;
    case 2: 
#line 473 
    ;
    
#line 476 
    ldv_14_ret = ldv_emg_wrapper_liquidio_suspend_3(ldv_14_resource_1,ldv_14_resource_0);
    
#line 478 
    ldv_14_ret = ldv_filter_err_code(ldv_14_ret);
    
#line 482 
    if (ldv_14_container->suspend_late != (int (*)(struct pci_dev *, pm_message_t ))0) {
      
#line 484 
      ldv_14_ret = (*(ldv_14_container->suspend_late))(ldv_14_resource_1,ldv_14_resource_0);
      
#line 486 
      ldv_14_ret = ldv_filter_err_code(ldv_14_ret);
    }
    else 
#line 488 
         ldv_14_ret = ldv_undef_int();
    
#line 493 
    if (ldv_14_container->resume_early != (int (*)(struct pci_dev *))0) 
      
#line 495 
      (*(ldv_14_container->resume_early))(ldv_14_resource_1); else ;
    
#line 501 
    ldv_emg_wrapper_liquidio_resume_5(ldv_14_resource_1);
    
#line 508 
    goto ldv_call_14;
    case 3: 
#line 511 
    ;
    
#line 513 
    if (ldv_14_container->shutdown != (void (*)(struct pci_dev *))0) 
      
#line 515 
      (*(ldv_14_container->shutdown))(ldv_14_resource_1); else ;
    
#line 521 
    ldv_emg_wrapper_liquidio_remove_4(ldv_14_resource_1);
    
#line 528 
    goto ldv_main_14;
    default: 
#line 531 
    ;
    
#line 531 
    __VERIFIER_assume(0);
  }
  
#line 534 
  __retres = (void *)0;
  return_label: 
#line 534 
                return __retres;
}


#line 539  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_deregister_9_1(struct pci_driver *arg0)
{
  int ret;
  struct ldv_struct_pci_scenario_14 *cf_arg_14;
  int tmp;
  
#line 542 
  tmp = ldv_undef_int();
  
#line 542 
  switch (tmp) {
    case 0: 
#line 543 
    ;
    
#line 544 
    ret = pthread_join(ldv_thread_14,(void **)0);
    
#line 545 
    __VERIFIER_assume(ret == 0);
    
#line 546 
    goto ldv_44833;
    default: 
#line 548 
    ;
    
#line 548 
    __VERIFIER_assume(0);
  }
  ldv_44833: 
#line 549 
  ;
  
#line 550 
  return;
}


#line 554  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_initialization_1(void *arg0)
{
  void *__retres;
  int ldv_1_ret;
  int tmp;
  
#line 561 
  ldv_1_ret = ldv_emg_liquidio_init();
  
#line 562 
  ldv_1_ret = ldv_post_init(ldv_1_ret);
  
#line 565 
  tmp = ldv_undef_int();
  
#line 565 
  if (tmp != 0) {
    
#line 567 
    __VERIFIER_assume(ldv_1_ret != 0);
    
#line 571 
    __retres = (void *)0;
    
#line 571 
    goto return_label;
  }
  else {
    
#line 575 
    __VERIFIER_assume(ldv_1_ret == 0);
    
#line 580 
    ldv_emg_liquidio_exit();
    
#line 584 
    __retres = (void *)0;
    
#line 584 
    goto return_label;
  }
  
#line 587 
  __retres = (void *)0;
  return_label: 
#line 587 
                return __retres;
}


#line 592  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/emg/environment_model.c"
int main(void)
{
  int __retres;
  
#line 595 
  ldv_initialize();
  
#line 598 
  ldv_initialization_1((void *)0);
  
#line 600 
  __retres = 0;
  
#line 600 
  return __retres;
}


#line 605  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_deregister_4_1(struct net_device *arg0)
{
  int ret;
  struct ldv_struct_random_allocationless_scenario_16 *cf_arg_16;
  int tmp;
  
#line 608 
  tmp = ldv_undef_int();
  
#line 608 
  switch (tmp) {
    case 0: 
#line 609 
    ;
    
#line 610 
    ret = pthread_join(ldv_thread_16,(void **)0);
    
#line 611 
    __VERIFIER_assume(ret == 0);
    
#line 612 
    goto ldv_44848;
    default: 
#line 614 
    ;
    
#line 614 
    __VERIFIER_assume(0);
  }
  ldv_44848: 
#line 615 
  ;
  
#line 616 
  return;
}


#line 620  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_pci_unregister_driver(struct pci_driver *arg0)
{
  
#line 623 
  struct pci_driver *ldv_9_pci_driver = ldv_emg_alias_liquidio_pci_driver_2;
  
#line 626 
  ldv_9_pci_driver = arg0;
  
#line 630 
  ldv_dispatch_deregister_9_1(ldv_9_pci_driver);
  
#line 634 
  goto return_label;
  return_label: 
#line 636 
                return;
}


#line 641  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_register_10_4(struct net_device *arg0)
{
  int ret;
  struct ldv_struct_random_allocationless_scenario_16 *cf_arg_16;
  int tmp;
  
#line 644 
  tmp = ldv_undef_int();
  
#line 644 
  switch (tmp) {
    case 0: 
#line 645 
    ;
    
#line 646 
    cf_arg_16 = (struct ldv_struct_random_allocationless_scenario_16 *)ldv_xmalloc(16UL);
    
#line 647 
    cf_arg_16->arg0 = arg0;
    
#line 648 
    ret = pthread_create(& ldv_thread_16,(pthread_attr_t const *)0,& ldv_random_allocationless_scenario_16,(void *)cf_arg_16);
    
#line 649 
    __VERIFIER_assume(ret == 0);
    
#line 650 
    goto ldv_44860;
    default: 
#line 652 
    ;
    
#line 652 
    __VERIFIER_assume(0);
  }
  ldv_44860: 
#line 653 
  ;
  
#line 654 
  return;
}


#line 658  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_unregister_netdev(struct net_device *arg0)
{
  struct net_device *ldv_4_netdev;
  
#line 664 
  ldv_4_netdev = arg0;
  
#line 669 
  ldv_emg_wrapper_liquidio_stop_2(ldv_4_netdev);
  
#line 673 
  ldv_dispatch_deregister_4_1(ldv_4_netdev);
  
#line 677 
  goto return_label;
  return_label: 
#line 679 
                return;
}


#line 684  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_free_irq(unsigned int arg0, void *arg1)
{
  int ldv_7_line;
  
#line 690 
  ldv_7_line = (int)arg0;
  
#line 694 
  ldv_dispatch_irq_deregister_7_1(ldv_7_line);
  
#line 698 
  goto return_label;
  return_label: 
#line 700 
                return;
}


#line 705  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/emg/environment_model.c"
_Bool ldv_emg_queue_delayed_work(struct workqueue_struct *arg0, struct delayed_work *arg1, unsigned long arg2)
{
  _Bool __retres;
  struct work_struct *ldv_5_ldv_param_0_2;
  struct delayed_work *ldv_5_delayed_work;
  int tmp_0;
  
#line 713 
  tmp_0 = ldv_undef_int();
  
#line 713 
  if (tmp_0 != 0) {
    
#line 715 
    ldv_5_delayed_work = arg1;
    
#line 719 
    ldv_5_ldv_param_0_2 = (struct work_struct *)ldv_xmalloc_unknown_size(0UL);
    
#line 723 
    if (ldv_5_delayed_work->work.func != (void (*)(struct work_struct *))0) 
      
#line 725 
      (*(ldv_5_delayed_work->work.func))(ldv_5_ldv_param_0_2); else ;
    
#line 730 
    ldv_free((void *)ldv_5_ldv_param_0_2);
    
#line 734 
    __retres = (_Bool)1;
    
#line 734 
    goto return_label;
  }
  else {
    
#line 741 
    __retres = (_Bool)0;
    
#line 741 
    goto return_label;
  }
  return_label: 
#line 713 
                return __retres;
}


#line 751  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_free_netdev(struct net_device *arg0)
{
  struct net_device *ldv_2_netdev;
  
#line 757 
  ldv_2_netdev = arg0;
  
#line 758 
  ldv_free((void *)ldv_2_netdev);
  
#line 762 
  goto return_label;
  return_label: 
#line 764 
                return;
}


#line 769  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_random_allocationless_scenario_16(void *arg0)
{
  void *__retres;
  unsigned int ldv_16_ldv_param_1_28;
  struct ethtool_eeprom *ldv_16_ldv_param_1_3;
  unsigned long long ldv_16_ldv_param_1_13;
  unsigned long long *ldv_16_ldv_param_2_10;
  unsigned long long ldv_16_ldv_param_1_15;
  void *ldv_16_ldv_param_2_23;
  struct ethtool_drvinfo *ldv_16_ldv_param_1_14;
  struct ethtool_pauseparam *ldv_16_ldv_param_1_2;
  int ldv_16_ldv_param_1_19;
  unsigned char *ldv_16_ldv_param_2_25;
  int ldv_16_ldv_param_1_11;
  struct sk_buff *ldv_16_ldv_param_0_16;
  struct ethtool_coalesce *ldv_16_ldv_param_1_26;
  struct ethtool_channels *ldv_16_ldv_param_1_8;
  struct net_device *ldv_16_container;
  int ldv_16_ldv_param_2_21;
  struct ethtool_ringparam *ldv_16_ldv_param_1_12;
  struct ethtool_cmd *ldv_16_ldv_param_1_18;
  struct ifreq *ldv_16_ldv_param_1_20;
  unsigned char *ldv_16_ldv_param_2_4;
  struct ethtool_ts_info *ldv_16_ldv_param_1_7;
  enum ethtool_phys_id_state *ldv_16_ldv_param_1_6;
  struct ethtool_stats *ldv_16_ldv_param_1_9;
  void *ldv_16_ldv_param_1_17;
  unsigned int ldv_16_ldv_param_1_24;
  struct ethtool_cmd *ldv_16_ldv_param_1_5;
  struct ethtool_regs *ldv_16_ldv_param_1_22;
  struct ethtool_coalesce *ldv_16_ldv_param_1_27;
  int tmp_18;
  
#line 801 
  struct ldv_struct_random_allocationless_scenario_16 *data = (struct ldv_struct_random_allocationless_scenario_16 *)arg0;
  
#line 806 
  if (data != (struct ldv_struct_random_allocationless_scenario_16 *)0) {
    
#line 807 
    ldv_16_container = data->arg0;
    
#line 808 
    ldv_free((void *)data);
  }
  else ;
  
#line 816 
  goto ldv_call_16;
  
#line 818 
  __retres = (void *)0;
  
#line 818 
  goto return_label;
  ldv_call_16: 
#line 821 
  ;
  
#line 824 
  tmp_18 = ldv_undef_int();
  
#line 824 
  if (tmp_18 != 0) {
    int tmp_0;
    
#line 826 
    ldv_16_ldv_param_1_2 = (struct ethtool_pauseparam *)ldv_xmalloc_unknown_size(0UL);
    
#line 829 
    tmp_0 = ldv_undef_int();
    
#line 829 
    switch (tmp_0) {
      case 1: 
#line 830 
      ;
      
#line 833 
      ldv_emg_wrapper_lio_get_pauseparam_2(ldv_16_container,ldv_16_ldv_param_1_2);
      
#line 836 
      goto ldv_44916;
      case 2: 
#line 838 
      ;
      
#line 841 
      ldv_emg_wrapper_liquidio_set_mcast_list_7(ldv_16_container);
      
#line 844 
      goto ldv_44916;
      case 3: 
#line 846 
      ;
      
#line 849 
      ldv_emg_wrapper_lio_nway_reset_30(ldv_16_container);
      
#line 852 
      goto ldv_44916;
      case 4: 
#line 854 
      ;
      
#line 860 
      ldv_emg_wrapper_lio_set_msglevel_29(ldv_16_container,ldv_16_ldv_param_1_28);
      
#line 866 
      goto ldv_44916;
      case 5: 
#line 868 
      ;
      
#line 870 
      ldv_16_ldv_param_1_27 = (struct ethtool_coalesce *)ldv_xmalloc_unknown_size(0UL);
      
#line 875 
      ldv_emg_wrapper_lio_set_intr_coalesce_28(ldv_16_container,ldv_16_ldv_param_1_27);
      
#line 879 
      ldv_free((void *)ldv_16_ldv_param_1_27);
      
#line 882 
      goto ldv_44916;
      case 6: 
#line 884 
      ;
      
#line 887 
      ldv_emg_wrapper_lio_get_regs_len_27(ldv_16_container);
      
#line 890 
      goto ldv_44916;
      case 7: 
#line 892 
      ;
      
#line 894 
      ldv_16_ldv_param_1_26 = (struct ethtool_coalesce *)ldv_xmalloc_unknown_size(0UL);
      
#line 899 
      ldv_emg_wrapper_lio_get_intr_coalesce_26(ldv_16_container,ldv_16_ldv_param_1_26);
      
#line 903 
      ldv_free((void *)ldv_16_ldv_param_1_26);
      
#line 906 
      goto ldv_44916;
      case 8: 
#line 908 
      ;
      
#line 910 
      ldv_16_ldv_param_2_25 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
      
#line 915 
      ldv_emg_wrapper_lio_get_strings_6(ldv_16_container,ldv_16_ldv_param_1_24,ldv_16_ldv_param_2_25);
      
#line 919 
      ldv_free((void *)ldv_16_ldv_param_2_25);
      
#line 922 
      goto ldv_44916;
      case 9: 
#line 924 
      ;
      
#line 927 
      ldv_emg_wrapper_liquidio_get_stats_23(ldv_16_container);
      
#line 930 
      goto ldv_44916;
      case 10: 
#line 932 
      ;
      
#line 935 
      ldv_emg_wrapper_liquidio_tx_timeout_19(ldv_16_container);
      
#line 938 
      goto ldv_44916;
      case 11: 
#line 940 
      ;
      
#line 942 
      ldv_16_ldv_param_2_23 = ldv_xmalloc_unknown_size(0UL);
      
#line 943 
      ldv_16_ldv_param_1_22 = (struct ethtool_regs *)ldv_xmalloc_unknown_size(0UL);
      
#line 948 
      ldv_emg_wrapper_lio_get_regs_21(ldv_16_container,ldv_16_ldv_param_1_22,ldv_16_ldv_param_2_23);
      
#line 952 
      ldv_free(ldv_16_ldv_param_2_23);
      
#line 953 
      ldv_free((void *)ldv_16_ldv_param_1_22);
      
#line 956 
      goto ldv_44916;
      case 12: 
#line 958 
      ;
      
#line 960 
      ldv_16_ldv_param_1_20 = (struct ifreq *)ldv_xmalloc_unknown_size(0UL);
      
#line 965 
      ldv_emg_wrapper_liquidio_ioctl_20(ldv_16_container,ldv_16_ldv_param_1_20,ldv_16_ldv_param_2_21);
      
#line 969 
      ldv_free((void *)ldv_16_ldv_param_1_20);
      
#line 972 
      goto ldv_44916;
      case 13: 
#line 974 
      ;
      
#line 980 
      ldv_emg_wrapper_lio_get_sset_count_22(ldv_16_container,ldv_16_ldv_param_1_19);
      
#line 986 
      goto ldv_44916;
      case 14: 
#line 988 
      ;
      
#line 990 
      ldv_16_ldv_param_1_18 = (struct ethtool_cmd *)ldv_xmalloc_unknown_size(0UL);
      
#line 995 
      ldv_emg_wrapper_lio_get_settings_3(ldv_16_container,ldv_16_ldv_param_1_18);
      
#line 999 
      ldv_free((void *)ldv_16_ldv_param_1_18);
      
#line 1002 
      goto ldv_44916;
      case 15: 
#line 1004 
      ;
      
#line 1006 
      ldv_16_ldv_param_1_17 = ldv_xmalloc_unknown_size(0UL);
      
#line 1011 
      ldv_emg_wrapper_liquidio_set_mac_17(ldv_16_container,ldv_16_ldv_param_1_17);
      
#line 1015 
      ldv_free(ldv_16_ldv_param_1_17);
      
#line 1018 
      goto ldv_44916;
      case 16: 
#line 1020 
      ;
      
#line 1022 
      ldv_16_ldv_param_0_16 = (struct sk_buff *)ldv_xmalloc_unknown_size(0UL);
      
#line 1027 
      ldv_emg_wrapper_liquidio_xmit_16(ldv_16_ldv_param_0_16,ldv_16_container);
      
#line 1031 
      ldv_free((void *)ldv_16_ldv_param_0_16);
      
#line 1034 
      goto ldv_44916;
      case 17: 
#line 1036 
      ;
      
#line 1039 
      ldv_emg_wrapper_lio_get_msglevel_15(ldv_16_container);
      
#line 1042 
      goto ldv_44916;
      case 18: 
#line 1044 
      ;
      
#line 1047 
      ldv_emg_wrapper_lio_get_eeprom_len_31(ldv_16_container);
      
#line 1050 
      goto ldv_44916;
      case 19: 
#line 1052 
      ;
      
#line 1058 
      ldv_emg_wrapper_liquidio_fix_features_14(ldv_16_container,ldv_16_ldv_param_1_15);
      
#line 1064 
      goto ldv_44916;
      case 20: 
#line 1066 
      ;
      
#line 1068 
      ldv_16_ldv_param_1_14 = (struct ethtool_drvinfo *)ldv_xmalloc_unknown_size(0UL);
      
#line 1073 
      ldv_emg_wrapper_lio_get_drvinfo_13(ldv_16_container,ldv_16_ldv_param_1_14);
      
#line 1077 
      ldv_free((void *)ldv_16_ldv_param_1_14);
      
#line 1080 
      goto ldv_44916;
      case 21: 
#line 1082 
      ;
      
#line 1088 
      ldv_emg_wrapper_liquidio_set_features_12(ldv_16_container,ldv_16_ldv_param_1_13);
      
#line 1094 
      goto ldv_44916;
      case 22: 
#line 1096 
      ;
      
#line 1098 
      ldv_16_ldv_param_1_12 = (struct ethtool_ringparam *)ldv_xmalloc_unknown_size(0UL);
      
#line 1103 
      ldv_emg_wrapper_lio_ethtool_get_ringparam_8(ldv_16_container,ldv_16_ldv_param_1_12);
      
#line 1107 
      ldv_free((void *)ldv_16_ldv_param_1_12);
      
#line 1110 
      goto ldv_44916;
      case 23: 
#line 1112 
      ;
      
#line 1115 
      (*ldv_emg_alias_ethtool_op_get_link_11)(ldv_16_container);
      
#line 1118 
      goto ldv_44916;
      case 24: 
#line 1120 
      ;
      
#line 1126 
      ldv_emg_wrapper_liquidio_change_mtu_10(ldv_16_container,ldv_16_ldv_param_1_11);
      
#line 1132 
      goto ldv_44916;
      case 25: 
#line 1134 
      ;
      
#line 1136 
      ldv_16_ldv_param_2_10 = (unsigned long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 1137 
      ldv_16_ldv_param_1_9 = (struct ethtool_stats *)ldv_xmalloc_unknown_size(0UL);
      
#line 1142 
      ldv_emg_wrapper_lio_get_ethtool_stats_9(ldv_16_container,ldv_16_ldv_param_1_9,ldv_16_ldv_param_2_10);
      
#line 1146 
      ldv_free((void *)ldv_16_ldv_param_2_10);
      
#line 1147 
      ldv_free((void *)ldv_16_ldv_param_1_9);
      
#line 1150 
      goto ldv_44916;
      case 26: 
#line 1152 
      ;
      
#line 1154 
      ldv_16_ldv_param_1_8 = (struct ethtool_channels *)ldv_xmalloc_unknown_size(0UL);
      
#line 1159 
      ldv_emg_wrapper_lio_ethtool_get_channels_24(ldv_16_container,ldv_16_ldv_param_1_8);
      
#line 1163 
      ldv_free((void *)ldv_16_ldv_param_1_8);
      
#line 1166 
      goto ldv_44916;
      case 27: 
#line 1168 
      ;
      
#line 1170 
      ldv_16_ldv_param_1_7 = (struct ethtool_ts_info *)ldv_xmalloc_unknown_size(0UL);
      
#line 1175 
      ldv_emg_wrapper_lio_get_ts_info_25(ldv_16_container,ldv_16_ldv_param_1_7);
      
#line 1179 
      ldv_free((void *)ldv_16_ldv_param_1_7);
      
#line 1182 
      goto ldv_44916;
      case 28: 
#line 1184 
      ;
      
#line 1186 
      ldv_16_ldv_param_1_6 = (enum ethtool_phys_id_state *)ldv_xmalloc_unknown_size(0UL);
      
#line 1191 
      ldv_emg_wrapper_lio_set_phys_id_5(ldv_16_container,*ldv_16_ldv_param_1_6);
      
#line 1195 
      ldv_free((void *)ldv_16_ldv_param_1_6);
      
#line 1198 
      goto ldv_44916;
      case 29: 
#line 1200 
      ;
      
#line 1202 
      ldv_16_ldv_param_1_5 = (struct ethtool_cmd *)ldv_xmalloc_unknown_size(0UL);
      
#line 1207 
      ldv_emg_wrapper_lio_set_settings_4(ldv_16_container,ldv_16_ldv_param_1_5);
      
#line 1211 
      ldv_free((void *)ldv_16_ldv_param_1_5);
      
#line 1214 
      goto ldv_44916;
      case 30: 
#line 1216 
      ;
      
#line 1218 
      ldv_16_ldv_param_1_3 = (struct ethtool_eeprom *)ldv_xmalloc_unknown_size(0UL);
      
#line 1219 
      ldv_16_ldv_param_2_4 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
      
#line 1224 
      ldv_emg_wrapper_lio_get_eeprom_18(ldv_16_container,ldv_16_ldv_param_1_3,ldv_16_ldv_param_2_4);
      
#line 1228 
      ldv_free((void *)ldv_16_ldv_param_1_3);
      
#line 1229 
      ldv_free((void *)ldv_16_ldv_param_2_4);
      
#line 1232 
      goto ldv_44916;
      default: 
#line 1234 
      ;
      
#line 1234 
      __VERIFIER_assume(0);
    }
    ldv_44916: 
#line 1237 
    ;
    
#line 1237 
    ldv_free((void *)ldv_16_ldv_param_1_2);
    
#line 1244 
    goto ldv_call_16;
  }
  else {
    
#line 1252 
    __retres = (void *)0;
    
#line 1252 
    goto return_label;
  }
  
#line 1255 
  __retres = (void *)0;
  return_label: 
#line 1255 
                return __retres;
}


#line 1260  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_interrupt_scenario_15(void *arg0)
{
  void *__retres;
  enum irqreturn ldv_15_ret_val;
  int ldv_15_line;
  void *ldv_15_data;
  enum irqreturn (*ldv_15_thread)(int , void *);
  int tmp;
  
#line 1266 
  enum irqreturn (*ldv_15_callback)(int , void *) = & ldv_emg_wrapper_liquidio_intr_handler_2;
  
#line 1269 
  struct ldv_struct_interrupt_scenario_15 *data = (struct ldv_struct_interrupt_scenario_15 *)arg0;
  
#line 1274 
  if (data != (struct ldv_struct_interrupt_scenario_15 *)0) {
    
#line 1275 
    ldv_15_line = data->arg0;
    
#line 1276 
    ldv_15_callback = data->arg1;
    
#line 1277 
    ldv_15_thread = data->arg2;
    
#line 1278 
    ldv_15_data = data->arg3;
    
#line 1279 
    ldv_free((void *)data);
  }
  else ;
  
#line 1285 
  ldv_switch_to_interrupt_context();
  
#line 1287 
  ldv_15_ret_val = ldv_emg_wrapper_liquidio_intr_handler_2(ldv_15_line,ldv_15_data);
  
#line 1289 
  ldv_switch_to_process_context();
  
#line 1292 
  tmp = ldv_undef_int();
  
#line 1292 
  if (tmp != 0) {
    
#line 1294 
    __VERIFIER_assume(ldv_15_ret_val == (unsigned int)IRQ_WAKE_THREAD);
    
#line 1298 
    if (ldv_15_thread != (enum irqreturn (*)(int , void *))0) 
#line 1300 
                                                              (*ldv_15_thread)(ldv_15_line,ldv_15_data); else ;
  }
  else 
#line 1307 
       __VERIFIER_assume(ldv_15_ret_val != (unsigned int)IRQ_WAKE_THREAD);
  
#line 1316 
  __retres = (void *)0;
  
#line 1316 
  goto return_label;
  
#line 1318 
  __retres = (void *)0;
  return_label: 
#line 1318 
                return __retres;
}


#line 1323  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/cavium/liquidio/liquidio.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_register_netdev(struct net_device *arg0)
{
  int __retres;
  struct net_device *ldv_10_netdev;
  int tmp_3;
  
#line 1327 
  int ldv_10_ret = ldv_undef_int();
  
#line 1330 
  ldv_10_ret = ldv_undef_int();
  
#line 1333 
  tmp_3 = ldv_undef_int();
  
#line 1333 
  if (tmp_3 != 0) {
    int tmp_1;
    
#line 1335 
    ldv_10_netdev = arg0;
    
#line 1340 
    ldv_10_ret = ldv_emg_wrapper_liquidio_open_2(ldv_10_netdev);
    
#line 1343 
    tmp_1 = ldv_undef_int();
    
#line 1343 
    if (tmp_1 != 0) {
      
#line 1345 
      __VERIFIER_assume(ldv_10_ret == 0);
      
#line 1349 
      ldv_dispatch_register_10_4(ldv_10_netdev);
      
#line 1353 
      __retres = 0;
      
#line 1353 
      goto return_label;
    }
    else {
      int tmp_0;
      
#line 1360 
      __VERIFIER_assume(ldv_10_ret != 0);
      
#line 1361 
      ldv_failed_register_netdev();
      
#line 1362 
      tmp_0 = ldv_undef_int_negative();
      
#line 1362 
      __retres = tmp_0;
      
#line 1362 
      goto return_label;
    }
  }
  else {
    int tmp_2;
    
#line 1370 
    ldv_failed_register_netdev();
    
#line 1371 
    tmp_2 = ldv_undef_int_negative();
    
#line 1371 
    __retres = tmp_2;
    
#line 1371 
    goto return_label;
  }
  return_label: 
#line 1333 
                return __retres;
}


