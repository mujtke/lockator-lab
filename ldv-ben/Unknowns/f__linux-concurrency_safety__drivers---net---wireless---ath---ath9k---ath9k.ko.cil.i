/* Generated by Frama-C */

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef signed char __s8;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef short __s16;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef int __s32;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef signed char s8;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned char u8;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef short s16;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned short u16;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef int s32;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned int u32;

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef long long s64;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned long long u64;

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;

#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;

#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u16 __le16;

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u16 __be16;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __le32;

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __be32;

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u64 __le64;

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __wsum;

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u32 __kernel_dev_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_dev_t dev_t;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned short umode_t;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_pid_t pid_t;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_clockid_t clockid_t;

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef _Bool bool;

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_uid32_t uid_t;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_gid32_t gid_t;

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_loff_t loff_t;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_size_t size_t;

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_time_t time_t;

#line 98  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __s8 int8_t;

#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __s16 int16_t;

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __s32 int32_t;

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u8 uint8_t;

#line 108  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u32 uint32_t;

#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u64 uint64_t;

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned long sector_t;

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned long blkcnt_t;

#line 152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef u64 dma_addr_t;

#line 157  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int gfp_t;

#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int fmode_t;

#line 159  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int oom_flags_t;

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;

#line 183  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};

#line 188 
struct hlist_node;

#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};

#line 192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};

#line 203  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head *) ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct __anonstruct_9 {
   unsigned int a ;
   unsigned int b ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct __anonstruct_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) base1 : 8 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) type : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) s : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) dpl : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) p : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) limit : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) avl : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) l : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) g : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) base2 : 8 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
union __anonunion_8 {
   struct __anonstruct_9 __anonCompField___anonunion_8_4 ;
   struct __anonstruct_10 __anonCompField___anonunion_8_5 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion_8 __anonCompField_desc_struct_6 ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;

#line 361 
struct page;

#line 361  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;

#line 372 
struct file;

#line 385 
struct seq_file;

#line 423 
struct thread_struct;

#line 425 
struct mm_struct;

#line 426 
struct task_struct;

#line 427 
struct cpumask;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_debug.h"
struct device;

#line 54 
struct net_device;

#line 420  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
struct file_operations;

#line 432 
struct completion;

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct timespec;

#line 103 
struct compat_timespec;

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_futex_16 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_nanosleep_17 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_poll_18 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
union __anonunion_15 {
   struct __anonstruct_futex_16 futex ;
   struct __anonstruct_nanosleep_17 nanosleep ;
   struct __anonstruct_poll_18 poll ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct restart_block {
   long (*fn)(struct restart_block *) ;
   union __anonunion_15 __anonCompField_restart_block_7 ;
};

#line 127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/vm86.h"
union __anonunion_19 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_19 __anonCompField_math_emu_info_8 ;
};

#line 328  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[128U] ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
typedef struct cpumask cpumask_t;

#line 652  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;

#line 260  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct __anonstruct_29 {
   u64 rip ;
   u64 rdp ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct __anonstruct_30 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union __anonunion_28 {
   struct __anonstruct_29 __anonCompField___anonunion_28_12 ;
   struct __anonstruct_30 __anonCompField___anonunion_28_13 ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union __anonunion_31 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_28 __anonCompField_fxregs_state_14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_31 __anonCompField_fxregs_state_15 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};

#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};

#line 179  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
   u8 __padding[4096U] ;
};

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
   union fpregs_state state ;
};

#line 170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
struct seq_operations;

#line 369 
struct perf_event;

#line 370  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   struct fpu fpu ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bottom_half.h"
struct lockdep_map;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};

#line 28  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};

#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const *name ;
   int cpu ;
   unsigned long ip ;
};

#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(13))) class_idx : 13 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) irq_context : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) trylock : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) read : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) check : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hardirqs_off : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))) references : 12 ;
   unsigned int pin_count ;
};

#line 546  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
struct __anonstruct_35 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
union __anonunion_34 {
   struct raw_spinlock rlock ;
   struct __anonstruct_35 __anonCompField___anonunion_34_17 ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_34 __anonCompField_spinlock_18 ;
};

#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_36 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_36 rwlock_t;

#line 41  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
struct mutex;

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};

#line 193  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
typedef struct seqcount seqcount_t;

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;

#line 1170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debugobjects.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};

#line 437  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ktime.h"
typedef union ktime ktime_t;

#line 296  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
struct notifier_block;

#line 1120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
union __anonunion_46 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};

#line 1120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion_46 __anonCompField_idr_layer_19 ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};

#line 153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};

#line 185  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};

#line 97 
struct dentry;

#line 98 
struct iattr;

#line 99 
struct vm_area_struct;

#line 100 
struct super_block;

#line 101 
struct file_system_type;

#line 102 
struct kernfs_open_node;

#line 103 
struct kernfs_iattrs;

#line 126 
struct kernfs_root;

#line 126  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rbtree.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_node;

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};

#line 89 
struct kernfs_ops;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops const *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
union __anonunion_51 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const *name ;
   struct rb_node rb ;
   void const *ns ;
   unsigned int hash ;
   union __anonunion_51 __anonCompField_kernfs_node_20 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};

#line 138  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root *, int *, char *) ;
   int (*show_options)(struct seq_file *, struct kernfs_root *) ;
   int (*mkdir)(struct kernfs_node *, char const *, umode_t ) ;
   int (*rmdir)(struct kernfs_node *) ;
   int (*rename)(struct kernfs_node *, struct kernfs_node *, char const *) ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};

#line 171 
struct vm_operations_struct;

#line 171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct const *vm_ops ;
};

#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file *, void *) ;
   void *(*seq_start)(struct seq_file *, loff_t *) ;
   void *(*seq_next)(struct seq_file *, void *, loff_t *) ;
   void (*seq_stop)(struct seq_file *, void *) ;
   ssize_t (*read)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   int (*mmap)(struct kernfs_open_file *, struct vm_area_struct *) ;
   struct lock_class_key lockdep_key ;
};

#line 281 
struct inode;

#line 477 
struct sock;

#line 478 
struct kobject;

#line 479 
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
};

#line 485  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const *(*netlink_ns)(struct sock *) ;
   void const *(*initial_ns)(void) ;
   void (*drop_ns)(void *) ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/highuid.h"
struct user_namespace;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct __anonstruct_kuid_t_52 {
   uid_t val ;
};

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_52 kuid_t;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct __anonstruct_kgid_t_53 {
   gid_t val ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_53 kgid_t;

#line 139  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/stat.h"
struct bin_attribute;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/stat.h"
struct attribute {
   char const *name ;
   umode_t mode ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_lockdep : 1 ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct attribute_group {
   char const *name ;
   umode_t (*is_visible)(struct kobject *, struct attribute *, int ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};

#line 82  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t , size_t ) ;
   ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t , size_t ) ;
   int (*mmap)(struct file *, struct kobject *, struct bin_attribute *, struct vm_area_struct *) ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject *, struct attribute *, char *) ;
   ssize_t (*store)(struct kobject *, struct attribute *, char const *, size_t ) ;
};

#line 509  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kref.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};

#line 238  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
struct hrtimer;

#line 239 
enum hrtimer_restart;

#line 837  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/sysctl.h"
struct ctl_table;

#line 838 
struct nsproxy;

#line 839 
struct ctl_table_root;

#line 840 
struct ctl_table_header;

#line 841 
struct ctl_dir;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table *, int , void *, size_t *, loff_t *);

#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table {
   char const *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};

#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct __anonstruct_55 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
union __anonunion_54 {
   struct __anonstruct_55 __anonCompField___anonunion_54_21 ;
   struct callback_head rcu ;
};

#line 122 
struct ctl_table_set;

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion_54 __anonCompField_ctl_table_header_22 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};

#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};

#line 149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set *) ;
   struct ctl_dir dir ;
};

#line 154  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root *, struct nsproxy *) ;
   int (*permissions)(struct ctl_table_header *, struct ctl_table *) ;
};

#line 259  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
struct workqueue_struct;

#line 260 
struct work_struct;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct *) ;
   struct lockdep_map lockdep_map ;
};

#line 107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset;

#line 52 
struct kobj_type;

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobject {
   char const *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_initialized : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_in_sysfs : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_add_uevent_sent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_remove_uevent_sent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) uevent_suppress : 1 ;
};

#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject *) ;
   struct sysfs_ops const *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations const *(*child_ns_type)(struct kobject *) ;
   void const *(*namespace)(struct kobject *) ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const filter)(struct kset *, struct kobject *) ;
   char const *(* const name)(struct kset *, struct kobject *) ;
   int (* const uevent)(struct kset *, struct kobject *, struct kobj_uevent_env *) ;
};

#line 148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops const *uevent_ops ;
};

#line 223 
struct klist_node;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nodemask.h"
struct __anonstruct_nodemask_t_56 {
   unsigned long bits[16U] ;
};

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_56 nodemask_t;

#line 520 
struct path;

#line 521  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nodemask.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations const *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file *, loff_t *) ;
   void (*stop)(struct seq_file *, void *) ;
   void *(*next)(struct seq_file *, void *, loff_t *) ;
   int (*show)(struct seq_file *, void *) ;
};

#line 222 
struct pinctrl;

#line 223 
struct pinctrl_state;

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct pm_message {
   int event ;
};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
typedef struct pm_message pm_message_t;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device *) ;
   void (*complete)(struct device *) ;
   int (*suspend)(struct device *) ;
   int (*resume)(struct device *) ;
   int (*freeze)(struct device *) ;
   int (*thaw)(struct device *) ;
   int (*poweroff)(struct device *) ;
   int (*restore)(struct device *) ;
   int (*suspend_late)(struct device *) ;
   int (*resume_early)(struct device *) ;
   int (*freeze_late)(struct device *) ;
   int (*thaw_early)(struct device *) ;
   int (*poweroff_late)(struct device *) ;
   int (*restore_early)(struct device *) ;
   int (*suspend_noirq)(struct device *) ;
   int (*resume_noirq)(struct device *) ;
   int (*freeze_noirq)(struct device *) ;
   int (*thaw_noirq)(struct device *) ;
   int (*poweroff_noirq)(struct device *) ;
   int (*restore_noirq)(struct device *) ;
   int (*runtime_suspend)(struct device *) ;
   int (*runtime_resume)(struct device *) ;
   int (*runtime_idle)(struct device *) ;
};

#line 320 
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
};

#line 327 
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
};

#line 335 
struct wakeup_source;

#line 336 
struct wake_irq;

#line 338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};

#line 553 
struct dev_pm_qos;

#line 553  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) can_wakeup : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) async_suspend : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_prepared : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_noirq_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_late_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_children : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) early_init : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) direct_complete : 1 ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wakeup_path : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) syscore : 1 ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) disable_depth : 3 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) idle_notification : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) request_pending : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) deferred_resume : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) run_wake : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) runtime_auto : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_callbacks : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) irq_safe : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) use_autosuspend : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) timer_autosuspends : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device *, s32 ) ;
   struct dev_pm_qos *qos ;
};

#line 615  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device *, bool ) ;
   int (*activate)(struct device *) ;
   void (*sync)(struct device *) ;
   void (*dismiss)(struct device *) ;
};

#line 796  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
struct rw_semaphore;

#line 797  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block *, unsigned long , void *) ;
   struct notifier_block *next ;
   int priority ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
struct ldt_struct;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_121 {
   struct ldt_struct *ldt ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_121 mm_context_t;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/xen/features.h"
struct bio_vec;

#line 1281  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
struct llist_node;

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};

#line 428  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/gfp.h"
struct dma_map_ops;

#line 428  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/gfp.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/device.h"
struct device_driver;

#line 16 
struct driver_private;

#line 17 
struct class;

#line 18 
struct subsys_private;

#line 19 
struct bus_type;

#line 20 
struct device_node;

#line 21 
struct fwnode_handle;

#line 22 
struct iommu_ops;

#line 23 
struct iommu_group;

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_attribute;

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct bus_type {
   char const *name ;
   char const *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group const **bus_groups ;
   struct attribute_group const **dev_groups ;
   struct attribute_group const **drv_groups ;
   int (*match)(struct device *, struct device_driver *) ;
   int (*uevent)(struct device *, struct kobj_uevent_env *) ;
   int (*probe)(struct device *) ;
   int (*remove)(struct device *) ;
   void (*shutdown)(struct device *) ;
   int (*online)(struct device *) ;
   int (*offline)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct dev_pm_ops const *pm ;
   struct iommu_ops const *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};

#line 139 
struct device_type;

#line 197 
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
};

#line 203 
struct of_device_id;

#line 203 
struct acpi_device_id;

#line 203  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_driver {
   char const *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id const *of_match_table ;
   struct acpi_device_id const *acpi_match_table ;
   int (*probe)(struct device *) ;
   int (*remove)(struct device *) ;
   void (*shutdown)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct attribute_group const **groups ;
   struct dev_pm_ops const *pm ;
   struct driver_private *p ;
};

#line 353 
struct class_attribute;

#line 353  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct class {
   char const *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group const **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *, struct kobj_uevent_env *) ;
   char *(*devnode)(struct device *, umode_t *) ;
   void (*class_release)(struct class *) ;
   void (*dev_release)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct kobj_ns_type_operations const *ns_type ;
   void const *(*namespace)(struct device *) ;
   struct dev_pm_ops const *pm ;
   struct subsys_private *p ;
};

#line 446  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *, struct class_attribute *, char *) ;
   ssize_t (*store)(struct class *, struct class_attribute *, char const *, size_t ) ;
};

#line 514  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_type {
   char const *name ;
   struct attribute_group const **groups ;
   int (*uevent)(struct device *, struct kobj_uevent_env *) ;
   char *(*devnode)(struct device *, umode_t *, kuid_t *, kgid_t *) ;
   void (*release)(struct device *) ;
   struct dev_pm_ops const *pm ;
};

#line 542  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *, struct device_attribute *, char *) ;
   ssize_t (*store)(struct device *, struct device_attribute *, char const *, size_t ) ;
};

#line 675  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};

#line 684 
struct dma_coherent_mem;

#line 684 
struct cma;

#line 684  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const *init_name ;
   struct device_type const *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group const **groups ;
   void (*release)(struct device *) ;
   struct iommu_group *iommu_group ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) offline_disabled : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) offline : 1 ;
};

#line 830  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct wakeup_source {
   char const *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) active : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) autosleep_enabled : 1 ;
};

#line 1283  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};

#line 66 
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct __anonstruct_153 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct __anonstruct_154 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
union __anonunion_152 {
   struct __anonstruct_153 __anonCompField___anonunion_152_35 ;
   struct __anonstruct_154 __anonCompField___anonunion_152_36 ;
};

#line 73 
struct uprobe;

#line 73 
struct return_instance;

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion_152 __anonCompField_uprobe_task_37 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};

#line 94  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uprobes.h"
struct xol_area;

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};

#line 133 
struct address_space;

#line 134 
struct mem_cgroup;

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
typedef void compound_page_dtor(struct page *);

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_155 {
   struct address_space *mapping ;
   void *s_mem ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_157 {
   unsigned long index ;
   void *freelist ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_161 {
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) inuse : 16 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(15))) objects : 15 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) frozen : 1 ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_160 {
   atomic_t _mapcount ;
   struct __anonstruct_161 __anonCompField___anonunion_160_40 ;
   int units ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_159 {
   union __anonunion_160 __anonCompField___anonstruct_159_41 ;
   atomic_t _count ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_158 {
   unsigned long counters ;
   struct __anonstruct_159 __anonCompField___anonunion_158_42 ;
   unsigned int active ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_156 {
   union __anonunion_157 __anonCompField___anonstruct_156_39 ;
   union __anonunion_158 __anonCompField___anonstruct_156_43 ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_163 {
   struct page *next ;
   int pages ;
   int pobjects ;
};

#line 32 
struct slab;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_164 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_162 {
   struct list_head lru ;
   struct __anonstruct_163 __anonCompField___anonunion_162_45 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct_164 __anonCompField___anonunion_162_46 ;
   pgtable_t pmd_huge_pte ;
};

#line 32 
struct kmem_cache;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_165 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion_155 __anonCompField_page_38 ;
   struct __anonstruct_156 __anonCompField_page_44 ;
   union __anonunion_162 __anonCompField_page_47 ;
   union __anonunion_165 __anonCompField_page_48 ;
   struct mem_cgroup *mem_cgroup ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_shared_166 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};

#line 257 
struct anon_vma;

#line 257 
struct mempolicy;

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_166 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct const *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};

#line 331  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};

#line 344  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};

#line 352  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};

#line 357 
struct kioctx_table;

#line 358 
struct linux_binfmt;

#line 358 
struct mmu_notifier_mm;

#line 358  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker *, struct shrink_control *) ;
   unsigned long (*scan_objects)(struct shrinker *, struct shrink_control *) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/page_ext.h"
struct file_ra_state;

#line 65 
struct user_struct;

#line 66 
struct writeback_control;

#line 67 
struct bdi_writeback;

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};

#line 239  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *) ;
   void (*close)(struct vm_area_struct *) ;
   int (*fault)(struct vm_area_struct *, struct vm_fault *) ;
   void (*map_pages)(struct vm_area_struct *, struct vm_fault *) ;
   int (*page_mkwrite)(struct vm_area_struct *, struct vm_fault *) ;
   int (*pfn_mkwrite)(struct vm_area_struct *, struct vm_fault *) ;
   int (*access)(struct vm_area_struct *, unsigned long , void *, int , int ) ;
   char const *(*name)(struct vm_area_struct *) ;
   int (*set_policy)(struct vm_area_struct *, struct mempolicy *) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct *, unsigned long ) ;
   struct page *(*find_special_page)(struct vm_area_struct *, unsigned long ) ;
};

#line 1249 
struct kvec;

#line 2291  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};

#line 380  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct dma_map_ops {
   void *(*alloc)(struct device *, size_t , dma_addr_t *, gfp_t , struct dma_attrs *) ;
   void (*free)(struct device *, size_t , void *, dma_addr_t , struct dma_attrs *) ;
   int (*mmap)(struct device *, struct vm_area_struct *, void *, dma_addr_t , size_t , struct dma_attrs *) ;
   int (*get_sgtable)(struct device *, struct sg_table *, void *, dma_addr_t , size_t , struct dma_attrs *) ;
   dma_addr_t (*map_page)(struct device *, struct page *, unsigned long , size_t , enum dma_data_direction , struct dma_attrs *) ;
   void (*unmap_page)(struct device *, dma_addr_t , size_t , enum dma_data_direction , struct dma_attrs *) ;
   int (*map_sg)(struct device *, struct scatterlist *, int , enum dma_data_direction , struct dma_attrs *) ;
   void (*unmap_sg)(struct device *, struct scatterlist *, int , enum dma_data_direction , struct dma_attrs *) ;
   void (*sync_single_for_cpu)(struct device *, dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_single_for_device)(struct device *, dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_sg_for_cpu)(struct device *, struct scatterlist *, int , enum dma_data_direction ) ;
   void (*sync_sg_for_device)(struct device *, struct scatterlist *, int , enum dma_data_direction ) ;
   int (*mapping_error)(struct device *, dma_addr_t ) ;
   int (*dma_supported)(struct device *, u64 ) ;
   int (*set_dma_mask)(struct device *, u64 ) ;
   int is_phys ;
};

#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uio.h"
union __anonunion_168 {
   struct iovec const *iov ;
   struct kvec const *kvec ;
   struct bio_vec const *bvec ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion_168 __anonCompField_iov_iter_49 ;
   unsigned long nr_segs ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;

#line 18 
struct pid;

#line 19 
struct cred;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};

#line 38 
struct kiocb;

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iov_iter msg_iter ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
   struct kiocb *msg_iocb ;
};

#line 217  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/fcntl.h"
enum ldv_18816 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/net.h"
typedef enum ldv_18816 socket_state;

#line 55 
struct pipe_inode_info;

#line 56 
struct net;

#line 73 
struct fasync_struct;

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/net.h"
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   struct callback_head rcu ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct proto_ops;

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct socket_wq *wq ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops const *ops ;
};

#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket *) ;
   int (*bind)(struct socket *, struct sockaddr *, int ) ;
   int (*connect)(struct socket *, struct sockaddr *, int , int ) ;
   int (*socketpair)(struct socket *, struct socket *) ;
   int (*accept)(struct socket *, struct socket *, int ) ;
   int (*getname)(struct socket *, struct sockaddr *, int *, int ) ;
   unsigned int (*poll)(struct file *, struct socket *, struct poll_table_struct *) ;
   int (*ioctl)(struct socket *, unsigned int , unsigned long ) ;
   int (*compat_ioctl)(struct socket *, unsigned int , unsigned long ) ;
   int (*listen)(struct socket *, int ) ;
   int (*shutdown)(struct socket *, int ) ;
   int (*setsockopt)(struct socket *, int , int , char *, unsigned int ) ;
   int (*getsockopt)(struct socket *, int , int , char *, int *) ;
   int (*compat_setsockopt)(struct socket *, int , int , char *, unsigned int ) ;
   int (*compat_getsockopt)(struct socket *, int , int , char *, int *) ;
   int (*sendmsg)(struct socket *, struct msghdr *, size_t ) ;
   int (*recvmsg)(struct socket *, struct msghdr *, size_t , int ) ;
   int (*mmap)(struct file *, struct socket *, struct vm_area_struct *) ;
   ssize_t (*sendpage)(struct socket *, struct page *, int , size_t , int ) ;
   ssize_t (*splice_read)(struct socket *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ) ;
   int (*set_peek_off)(struct sock *, int ) ;
};

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;

#line 84  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};

#line 4  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sem.h"
struct sem_undo_list;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_170 {
   unsigned long sig[1U] ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_170 sigset_t;

#line 25 
struct siginfo;

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int );

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};

#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_172 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_173 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_174 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_175 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_177 {
   void *_lower ;
   void *_upper ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_176 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_177 _addr_bnd ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_178 {
   long _band ;
   int _fd ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_179 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_171 {
   int _pad[28U] ;
   struct __anonstruct__kill_172 _kill ;
   struct __anonstruct__timer_173 _timer ;
   struct __anonstruct__rt_174 _rt ;
   struct __anonstruct__sigchld_175 _sigchld ;
   struct __anonstruct__sigfault_176 _sigfault ;
   struct __anonstruct__sigpoll_178 _sigpoll ;
   struct __anonstruct__sigsys_179 _sigsys ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_171 _sifields ;
};

#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};

#line 243  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};

#line 443 
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
};

#line 450 
struct pid_namespace;

#line 450  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/seccomp.h"
struct seccomp_filter;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rtmutex.h"
struct rt_mutex_waiter;

#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rtmutex.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};

#line 50 
struct hrtimer_clock_base;

#line 51 
struct hrtimer_cpu_base;

#line 60 
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer *) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};

#line 156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_hrtirq : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hres_active : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};

#line 466  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/latencytop.h"
struct assoc_array_ptr;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
typedef int32_t key_serial_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
typedef uint32_t key_perm_t;

#line 35 
struct key;

#line 36 
struct signal_struct;

#line 37 
struct key_type;

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const *description ;
   size_t desc_len ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_186 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};

#line 123 
struct key_user;

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_187 {
   time_t expiry ;
   time_t revoked_at ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct __anonstruct_189 {
   struct key_type *type ;
   char *description ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_188 {
   struct keyring_index_key index_key ;
   struct __anonstruct_189 __anonCompField___anonunion_188_52 ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_type_data_190 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_payload_192 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_191 {
   union __anonunion_payload_192 payload ;
   struct assoc_array keys ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_186 __anonCompField_key_50 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_187 __anonCompField_key_51 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion_188 __anonCompField_key_53 ;
   union __anonunion_type_data_190 type_data ;
   union __anonunion_191 __anonCompField_key_54 ;
};

#line 358 
struct audit_context;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};

#line 369 
struct percpu_ref;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref *);

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) force_atomic : 1 ;
   struct callback_head rcu ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-rwsem.h"
struct cgroup;

#line 28 
struct cgroup_root;

#line 29 
struct cgroup_subsys;

#line 30 
struct cgroup_taskset;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-rwsem.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};

#line 197  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};

#line 270  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};

#line 306  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state *, struct cftype *) ;
   s64 (*read_s64)(struct cgroup_subsys_state *, struct cftype *) ;
   int (*seq_show)(struct seq_file *, void *) ;
   void *(*seq_start)(struct seq_file *, loff_t *) ;
   void *(*seq_next)(struct seq_file *, void *, loff_t *) ;
   void (*seq_stop)(struct seq_file *, void *) ;
   int (*write_u64)(struct cgroup_subsys_state *, struct cftype *, u64 ) ;
   int (*write_s64)(struct cgroup_subsys_state *, struct cftype *, s64 ) ;
   ssize_t (*write)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   struct lock_class_key lockdep_key ;
};

#line 388  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state *) ;
   int (*css_online)(struct cgroup_subsys_state *) ;
   void (*css_offline)(struct cgroup_subsys_state *) ;
   void (*css_released)(struct cgroup_subsys_state *) ;
   void (*css_free)(struct cgroup_subsys_state *) ;
   void (*css_reset)(struct cgroup_subsys_state *) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state *) ;
   int (*can_attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*cancel_attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*fork)(struct task_struct *) ;
   void (*exit)(struct cgroup_subsys_state *, struct cgroup_subsys_state *, struct task_struct *) ;
   void (*bind)(struct cgroup_subsys_state *) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};

#line 128  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct futex_pi_state;

#line 129 
struct robust_list_head;

#line 130 
struct bio_list;

#line 131 
struct fs_struct;

#line 132 
struct perf_event_context;

#line 133 
struct blk_plug;

#line 135 
struct nameidata;

#line 188 
struct cfs_rq;

#line 189 
struct task_group;

#line 477  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};

#line 516  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};

#line 524  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};

#line 531  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};

#line 543  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};

#line 563  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};

#line 584  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};

#line 620 
struct autogroup;

#line 621 
struct tty_struct;

#line 621 
struct taskstats;

#line 621 
struct tty_audit_buf;

#line 621  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_child_subreaper : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};

#line 802  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};

#line 845 
struct backing_dev_info;

#line 846 
struct reclaim_state;

#line 847  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};

#line 861  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};

#line 909  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};

#line 1138 
struct io_context;

#line 1172 
struct uts_namespace;

#line 1173  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};

#line 1181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};

#line 1206  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};

#line 1241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};

#line 1273 
struct rt_rq;

#line 1273  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};

#line 1289  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};

#line 1355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) may_oom : 1 ;
};

#line 1779 
struct sched_class;

#line 1779 
struct files_struct;

#line 1779 
struct compat_robust_list_head;

#line 1779 
struct numa_group;

#line 1779 
struct ftrace_ret_stack;

#line 1779  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_struct {
   long volatile state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class const *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_execve : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_iowait : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_reset_on_fork : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_contributes_to_load : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_migrated : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) memcg_kmem_skip_account : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred const *real_cred ;
   struct cred const *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void *) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
   struct thread_struct thread ;
};

#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/checksum_64.h"
struct in6_addr;

#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/checksum.h"
struct sk_buff;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
typedef u64 netdev_features_t;

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
union __anonunion_in6_u_207 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
struct in6_addr {
   union __anonunion_in6_u_207 in6_u ;
};

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/in6.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow_dissector.h"
struct pipe_buf_operations;

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow_dissector.h"
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
   struct pipe_buf_operations const *ops ;
   unsigned int flags ;
   unsigned long private ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pipe_fs_i.h"
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int nrbufs ;
   unsigned int curbuf ;
   unsigned int buffers ;
   unsigned int readers ;
   unsigned int writers ;
   unsigned int files ;
   unsigned int waiting_writers ;
   unsigned int r_counter ;
   unsigned int w_counter ;
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pipe_fs_i.h"
struct pipe_buf_operations {
   int can_merge ;
   int (*confirm)(struct pipe_inode_info *, struct pipe_buffer *) ;
   void (*release)(struct pipe_inode_info *, struct pipe_buffer *) ;
   int (*steal)(struct pipe_inode_info *, struct pipe_buffer *) ;
   void (*get)(struct pipe_inode_info *, struct pipe_buffer *) ;
};

#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/splice.h"
struct napi_struct;

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/splice.h"
struct nf_conntrack {
   atomic_t use ;
};

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
enum ldv_22378 {
    BRNF_PROTO_UNCHANGED = 0,
    BRNF_PROTO_8021Q = 1,
    BRNF_PROTO_PPPOE = 2
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_212 {
   struct net_device *physoutdev ;
   char neigh_header[8U] ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_213 {
   __be32 ipv4_daddr ;
   struct in6_addr ipv6_daddr ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   enum ldv_22378 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) orig_proto : 8 ;
   bool pkt_otherhost ;
   __u16 frag_max_size ;
   unsigned int mask ;
   struct net_device *physindev ;
   union __anonunion_212 __anonCompField_nf_bridge_info_61 ;
   union __anonunion_213 __anonCompField_nf_bridge_info_62 ;
};

#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};

#line 403  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_216 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_215 {
   u64 v64 ;
   struct __anonstruct_216 __anonCompField___anonunion_215_63 ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_mstamp {
   union __anonunion_215 __anonCompField_skb_mstamp_64 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_219 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_218 {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion_219 __anonCompField___anonstruct_218_65 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_217 {
   struct __anonstruct_218 __anonCompField___anonunion_217_66 ;
   struct rb_node rbnode ;
};

#line 457 
struct sec_path;

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_221 {
   __u16 csum_start ;
   __u16 csum_offset ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_220 {
   __wsum csum ;
   struct __anonstruct_221 __anonCompField___anonunion_220_68 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_222 {
   unsigned int napi_id ;
   unsigned int sender_cpu ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_223 {
   __u32 mark ;
   __u32 reserved_tailroom ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_224 {
   __be16 inner_protocol ;
   __u8 inner_ipproto ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct sk_buff {
   union __anonunion_217 __anonCompField_sk_buff_67 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   void (*destructor)(struct sk_buff *) ;
   struct sec_path *sp ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   __u16 queue_mapping ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cloned : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) nohdr : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) fclone : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) peeked : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) head_frag : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) xmit_more : 1 ;
   __u32 headers_start[0U] ;
   __u8 __pkt_type_offset[0U] ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) pkt_type : 3 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pfmemalloc : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_df : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) nfctinfo : 3 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) nf_trace : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) ip_summed : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ooo_okay : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) l4_hash : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sw_hash : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wifi_acked_valid : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wifi_acked : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_fcs : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) encapsulation : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) encap_hdr_csum : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_valid : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_complete_sw : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) csum_level : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_bad : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) ndisc_nodetype : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ipvs_property : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) inner_protocol_type : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) remcsum_offload : 1 ;
   __u16 tc_index ;
   __u16 tc_verd ;
   union __anonunion_220 __anonCompField_sk_buff_69 ;
   __u32 priority ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   union __anonunion_222 __anonCompField_sk_buff_70 ;
   __u32 secmark ;
   union __anonunion_223 __anonCompField_sk_buff_71 ;
   union __anonunion_224 __anonCompField_sk_buff_72 ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __be16 protocol ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   __u32 headers_end[0U] ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};

#line 718 
struct dst_entry;

#line 1182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dmaengine.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_226 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_226 sync_serial_settings;

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_227 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_227 te1_settings;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_228 {
   unsigned short encoding ;
   unsigned short parity ;
};

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_228 raw_hdlc_proto;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_229 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_229 fr_proto;

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_230 {
   unsigned int dlci ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_230 fr_proto_pvc;

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_231 {
   unsigned int dlci ;
   char master[16U] ;
};

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_231 fr_proto_pvc_info;

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_232 {
   unsigned int interval ;
   unsigned int timeout ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_232 cisco_proto;

#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_233 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_233 ifs_ifsu ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_234 {
   char ifrn_name[16U] ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifr_ifru_235 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_234 ifr_ifrn ;
   union __anonunion_ifr_ifru_235 ifr_ifru ;
};

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kdev_t.h"
struct hlist_bl_node;

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kdev_t.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
struct __anonstruct_240 {
   spinlock_t lock ;
   int count ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
union __anonunion_239 {
   struct __anonstruct_240 __anonCompField___anonunion_239_73 ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
struct lockref {
   union __anonunion_239 __anonCompField_lockref_74 ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct vfsmount;

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct __anonstruct_242 {
   u32 hash ;
   u32 len ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
union __anonunion_241 {
   struct __anonstruct_242 __anonCompField___anonunion_241_75 ;
   u64 hash_len ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct qstr {
   union __anonunion_241 __anonCompField_qstr_76 ;
   unsigned char const *name ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry_operations;

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
union __anonunion_d_u_243 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations const *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_243 d_u ;
};

#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry *, unsigned int ) ;
   int (*d_weak_revalidate)(struct dentry *, unsigned int ) ;
   int (*d_hash)(struct dentry const *, struct qstr *) ;
   int (*d_compare)(struct dentry const *, struct dentry const *, unsigned int , char const *, struct qstr const *) ;
   int (*d_delete)(struct dentry const *) ;
   void (*d_release)(struct dentry *) ;
   void (*d_prune)(struct dentry *) ;
   void (*d_iput)(struct dentry *, struct inode *) ;
   char *(*d_dname)(struct dentry *, char *, int ) ;
   struct vfsmount *(*d_automount)(struct path *) ;
   int (*d_manage)(struct dentry *, bool ) ;
   struct inode *(*d_select_inode)(struct dentry *, unsigned int ) ;
};

#line 586  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/path.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};

#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct __anonstruct_247 {
   struct radix_tree_node *parent ;
   void *private_data ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
union __anonunion_246 {
   struct __anonstruct_247 __anonCompField___anonunion_246_77 ;
   struct callback_head callback_head ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion_246 __anonCompField_radix_tree_node_78 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
};

#line 47 
struct block_device;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/fs.h"
struct export_operations;

#line 62 
struct kstatfs;

#line 63 
struct swap_info_struct;

#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};

#line 212  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dqblk_xfs.h"
struct dquot;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
typedef __kernel_uid32_t projid_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
struct __anonstruct_kprojid_t_251 {
   projid_t val ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_251 kprojid_t;

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
typedef long long qsize_t;

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
union __anonunion_252 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct kqid {
   union __anonunion_252 __anonCompField_kqid_80 ;
   enum quota_type type ;
};

#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};

#line 206 
struct quota_format_type;

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};

#line 272  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};

#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *, int ) ;
   int (*read_file_info)(struct super_block *, int ) ;
   int (*write_file_info)(struct super_block *, int ) ;
   int (*free_file_info)(struct super_block *, int ) ;
   int (*read_dqblk)(struct dquot *) ;
   int (*commit_dqblk)(struct dquot *) ;
   int (*release_dqblk)(struct dquot *) ;
};

#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot *) ;
   struct dquot *(*alloc_dquot)(struct super_block *, int ) ;
   void (*destroy_dquot)(struct dquot *) ;
   int (*acquire_dquot)(struct dquot *) ;
   int (*release_dquot)(struct dquot *) ;
   int (*mark_dirty)(struct dquot *) ;
   int (*write_info)(struct super_block *, int ) ;
   qsize_t *(*get_reserved_space)(struct inode *) ;
   int (*get_projid)(struct inode *, kprojid_t *) ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};

#line 348  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};

#line 394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};

#line 405  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};

#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block *, int , int , struct path *) ;
   int (*quota_off)(struct super_block *, int ) ;
   int (*quota_enable)(struct super_block *, unsigned int ) ;
   int (*quota_disable)(struct super_block *, unsigned int ) ;
   int (*quota_sync)(struct super_block *, int ) ;
   int (*set_info)(struct super_block *, int , struct qc_info *) ;
   int (*get_dqblk)(struct super_block *, struct kqid , struct qc_dqblk *) ;
   int (*set_dqblk)(struct super_block *, struct kqid , struct qc_dqblk *) ;
   int (*get_state)(struct super_block *, struct qc_state *) ;
   int (*rm_xquota)(struct super_block *, unsigned int ) ;
};

#line 432  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops const *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};

#line 496  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops const *ops[3U] ;
};

#line 526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb *, long , long ) ;
   void *private ;
   int ki_flags ;
};

#line 366  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page *, struct writeback_control *) ;
   int (*readpage)(struct file *, struct page *) ;
   int (*writepages)(struct address_space *, struct writeback_control *) ;
   int (*set_page_dirty)(struct page *) ;
   int (*readpages)(struct file *, struct address_space *, struct list_head *, unsigned int ) ;
   int (*write_begin)(struct file *, struct address_space *, loff_t , unsigned int , unsigned int , struct page **, void **) ;
   int (*write_end)(struct file *, struct address_space *, loff_t , unsigned int , unsigned int , struct page *, void *) ;
   sector_t (*bmap)(struct address_space *, sector_t ) ;
   void (*invalidatepage)(struct page *, unsigned int , unsigned int ) ;
   int (*releasepage)(struct page *, gfp_t ) ;
   void (*freepage)(struct page *) ;
   ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *, loff_t ) ;
   int (*migratepage)(struct address_space *, struct page *, struct page *, enum migrate_mode ) ;
   int (*launder_page)(struct page *) ;
   int (*is_partially_uptodate)(struct page *, unsigned long , unsigned long ) ;
   void (*is_dirty_writeback)(struct page *, bool *, bool *) ;
   int (*error_remove_page)(struct address_space *, struct page *) ;
   int (*swap_activate)(struct swap_info_struct *, struct file *, sector_t *) ;
   void (*swap_deactivate)(struct file *) ;
};

#line 423  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations const *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};

#line 443 
struct request_queue;

#line 444 
struct hd_struct;

#line 444 
struct gendisk;

#line 444  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};

#line 560 
struct posix_acl;

#line 561 
struct inode_operations;

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_255 {
   unsigned int const i_nlink ;
   unsigned int __i_nlink ;
};

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_256 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};

#line 561 
struct file_lock_context;

#line 561 
struct cdev;

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_257 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations const *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_255 __anonCompField_inode_81 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_256 __anonCompField_inode_82 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations const *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion_257 __anonCompField_inode_83 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};

#line 807  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};

#line 815  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};

#line 838  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_f_u_258 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};

#line 838  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file {
   union __anonunion_f_u_258 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations const *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred const *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};

#line 923  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
typedef void *fl_owner_t;

#line 924 
struct file_lock;

#line 925  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock *, struct file_lock *) ;
   void (*fl_release_private)(struct file_lock *) ;
};

#line 931  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock *, struct file_lock *) ;
   unsigned long (*lm_owner_key)(struct file_lock *) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t ) ;
   void (*lm_put_owner)(fl_owner_t ) ;
   void (*lm_notify)(struct file_lock *) ;
   int (*lm_grant)(struct file_lock *, int ) ;
   bool (*lm_break)(struct file_lock *) ;
   int (*lm_change)(struct file_lock *, int , struct list_head *) ;
   void (*lm_setup)(struct file_lock *, void **) ;
};

#line 952 
struct nlm_lockowner;

#line 953  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct nfs4_lock_state;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct __anonstruct_afs_260 {
   struct list_head link ;
   int state ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
union __anonunion_fl_u_259 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_260 afs ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations const *fl_ops ;
   struct lock_manager_operations const *fl_lmops ;
   union __anonunion_fl_u_259 fl_u ;
};

#line 1005  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};

#line 1221  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};

#line 1256  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};

#line 1287 
struct super_operations;

#line 1287 
struct xattr_handler;

#line 1287 
struct mtd_info;

#line 1287  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations const *s_op ;
   struct dquot_operations const *dq_op ;
   struct quotactl_ops const *s_qcop ;
   struct export_operations const *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler const **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations const *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};

#line 1526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};

#line 1540 
struct dir_context;

#line 1565  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context *, char const *, int , loff_t , u64 , unsigned int ) ;
   loff_t pos ;
};

#line 1572  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file *, loff_t , int ) ;
   ssize_t (*read)(struct file *, char *, size_t , loff_t *) ;
   ssize_t (*write)(struct file *, char const *, size_t , loff_t *) ;
   ssize_t (*read_iter)(struct kiocb *, struct iov_iter *) ;
   ssize_t (*write_iter)(struct kiocb *, struct iov_iter *) ;
   int (*iterate)(struct file *, struct dir_context *) ;
   unsigned int (*poll)(struct file *, struct poll_table_struct *) ;
   long (*unlocked_ioctl)(struct file *, unsigned int , unsigned long ) ;
   long (*compat_ioctl)(struct file *, unsigned int , unsigned long ) ;
   int (*mmap)(struct file *, struct vm_area_struct *) ;
   int (*mremap)(struct file *, struct vm_area_struct *) ;
   int (*open)(struct inode *, struct file *) ;
   int (*flush)(struct file *, fl_owner_t ) ;
   int (*release)(struct inode *, struct file *) ;
   int (*fsync)(struct file *, loff_t , loff_t , int ) ;
   int (*aio_fsync)(struct kiocb *, int ) ;
   int (*fasync)(int , struct file *, int ) ;
   int (*lock)(struct file *, int , struct file_lock *) ;
   ssize_t (*sendpage)(struct file *, struct page *, int , size_t , loff_t *, int ) ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   int (*check_flags)(int ) ;
   int (*flock)(struct file *, int , struct file_lock *) ;
   ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ) ;
   ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ) ;
   int (*setlease)(struct file *, long , struct file_lock **, void **) ;
   long (*fallocate)(struct file *, int , loff_t , loff_t ) ;
   void (*show_fdinfo)(struct seq_file *, struct file *) ;
};

#line 1633  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode *, struct dentry *, unsigned int ) ;
   char const *(*follow_link)(struct dentry *, void **) ;
   int (*permission)(struct inode *, int ) ;
   struct posix_acl *(*get_acl)(struct inode *, int ) ;
   int (*readlink)(struct dentry *, char *, int ) ;
   void (*put_link)(struct inode *, void *) ;
   int (*create)(struct inode *, struct dentry *, umode_t , bool ) ;
   int (*link)(struct dentry *, struct inode *, struct dentry *) ;
   int (*unlink)(struct inode *, struct dentry *) ;
   int (*symlink)(struct inode *, struct dentry *, char const *) ;
   int (*mkdir)(struct inode *, struct dentry *, umode_t ) ;
   int (*rmdir)(struct inode *, struct dentry *) ;
   int (*mknod)(struct inode *, struct dentry *, umode_t , dev_t ) ;
   int (*rename)(struct inode *, struct dentry *, struct inode *, struct dentry *) ;
   int (*rename2)(struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int ) ;
   int (*setattr)(struct dentry *, struct iattr *) ;
   int (*getattr)(struct vfsmount *, struct dentry *, struct kstat *) ;
   int (*setxattr)(struct dentry *, char const *, void const *, size_t , int ) ;
   ssize_t (*getxattr)(struct dentry *, char const *, void *, size_t ) ;
   ssize_t (*listxattr)(struct dentry *, char *, size_t ) ;
   int (*removexattr)(struct dentry *, char const *) ;
   int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 , u64 ) ;
   int (*update_time)(struct inode *, struct timespec *, int ) ;
   int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned int , umode_t , int *) ;
   int (*tmpfile)(struct inode *, struct dentry *, umode_t ) ;
   int (*set_acl)(struct inode *, struct posix_acl *, int ) ;
};

#line 1687  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *) ;
   void (*destroy_inode)(struct inode *) ;
   void (*dirty_inode)(struct inode *, int ) ;
   int (*write_inode)(struct inode *, struct writeback_control *) ;
   int (*drop_inode)(struct inode *) ;
   void (*evict_inode)(struct inode *) ;
   void (*put_super)(struct super_block *) ;
   int (*sync_fs)(struct super_block *, int ) ;
   int (*freeze_super)(struct super_block *) ;
   int (*freeze_fs)(struct super_block *) ;
   int (*thaw_super)(struct super_block *) ;
   int (*unfreeze_fs)(struct super_block *) ;
   int (*statfs)(struct dentry *, struct kstatfs *) ;
   int (*remount_fs)(struct super_block *, int *, char *) ;
   void (*umount_begin)(struct super_block *) ;
   int (*show_options)(struct seq_file *, struct dentry *) ;
   int (*show_devname)(struct seq_file *, struct dentry *) ;
   int (*show_path)(struct seq_file *, struct dentry *) ;
   int (*show_stats)(struct seq_file *, struct dentry *) ;
   ssize_t (*quota_read)(struct super_block *, int , char *, size_t , loff_t ) ;
   ssize_t (*quota_write)(struct super_block *, int , char const *, size_t , loff_t ) ;
   struct dquot **(*get_dquots)(struct inode *) ;
   int (*bdev_try_to_free_page)(struct super_block *, struct page *, gfp_t ) ;
   long (*nr_cached_objects)(struct super_block *, struct shrink_control *) ;
   long (*free_cached_objects)(struct super_block *, struct shrink_control *) ;
};

#line 1926  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_system_type {
   char const *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type *, int , char const *, void *) ;
   void (*kill_sb)(struct super_block *) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};

#line 276  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};

#line 280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};

#line 715  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compat.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};

#line 125  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char erom_version[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};

#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};

#line 233  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_tunable {
   __u32 cmd ;
   __u32 id ;
   __u32 type_id ;
   __u32 len ;
   void *data[0U] ;
};

#line 245  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 267  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 293  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};

#line 322  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};

#line 438  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};

#line 475  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};

#line 503  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};

#line 605  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};

#line 637  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};

#line 679  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};

#line 712  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};

#line 728  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};

#line 748  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};

#line 759  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};

#line 778  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};

#line 828  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};

#line 999  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};

#line 1007  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 1083  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
};

#line 99  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device *, struct ethtool_cmd *) ;
   int (*set_settings)(struct net_device *, struct ethtool_cmd *) ;
   void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *) ;
   int (*get_regs_len)(struct net_device *) ;
   void (*get_regs)(struct net_device *, struct ethtool_regs *, void *) ;
   void (*get_wol)(struct net_device *, struct ethtool_wolinfo *) ;
   int (*set_wol)(struct net_device *, struct ethtool_wolinfo *) ;
   u32 (*get_msglevel)(struct net_device *) ;
   void (*set_msglevel)(struct net_device *, u32 ) ;
   int (*nway_reset)(struct net_device *) ;
   u32 (*get_link)(struct net_device *) ;
   int (*get_eeprom_len)(struct net_device *) ;
   int (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_coalesce)(struct net_device *, struct ethtool_coalesce *) ;
   int (*set_coalesce)(struct net_device *, struct ethtool_coalesce *) ;
   void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *) ;
   int (*set_ringparam)(struct net_device *, struct ethtool_ringparam *) ;
   void (*get_pauseparam)(struct net_device *, struct ethtool_pauseparam *) ;
   int (*set_pauseparam)(struct net_device *, struct ethtool_pauseparam *) ;
   void (*self_test)(struct net_device *, struct ethtool_test *, u64 *) ;
   void (*get_strings)(struct net_device *, u32 , u8 *) ;
   int (*set_phys_id)(struct net_device *, enum ethtool_phys_id_state ) ;
   void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *, u64 *) ;
   int (*begin)(struct net_device *) ;
   void (*complete)(struct net_device *) ;
   u32 (*get_priv_flags)(struct net_device *) ;
   int (*set_priv_flags)(struct net_device *, u32 ) ;
   int (*get_sset_count)(struct net_device *, int ) ;
   int (*get_rxnfc)(struct net_device *, struct ethtool_rxnfc *, u32 *) ;
   int (*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *) ;
   int (*flash_device)(struct net_device *, struct ethtool_flash *) ;
   int (*reset)(struct net_device *, u32 *) ;
   u32 (*get_rxfh_key_size)(struct net_device *) ;
   u32 (*get_rxfh_indir_size)(struct net_device *) ;
   int (*get_rxfh)(struct net_device *, u32 *, u8 *, u8 *) ;
   int (*set_rxfh)(struct net_device *, u32 const *, u8 const *, u8 const ) ;
   void (*get_channels)(struct net_device *, struct ethtool_channels *) ;
   int (*set_channels)(struct net_device *, struct ethtool_channels *) ;
   int (*get_dump_flag)(struct net_device *, struct ethtool_dump *) ;
   int (*get_dump_data)(struct net_device *, struct ethtool_dump *, void *) ;
   int (*set_dump)(struct net_device *, struct ethtool_dump *) ;
   int (*get_ts_info)(struct net_device *, struct ethtool_ts_info *) ;
   int (*get_module_info)(struct net_device *, struct ethtool_modinfo *) ;
   int (*get_module_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_eee)(struct net_device *, struct ethtool_eee *) ;
   int (*set_eee)(struct net_device *, struct ethtool_eee *) ;
   int (*get_tunable)(struct net_device *, struct ethtool_tunable const *, void *) ;
   int (*set_tunable)(struct net_device *, struct ethtool_tunable const *, void const *) ;
};

#line 235  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow.h"
struct prot_inuse;

#line 236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct u64_stats_sync {
   
};

#line 146  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};

#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[9U] ;
};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[115U] ;
};

#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};

#line 118 
struct proc_dir_entry;

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/packet.h"
struct netns_frags {
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};

#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_frag.h"
struct ipv4_devconf;

#line 185 
struct fib_rules_ops;

#line 186 
struct fib_table;

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
   bool warned ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};

#line 29 
struct inet_peer_base;

#line 29 
struct xt_table;

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   bool fib_offload_disabled ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct inet_peer_base *peers ;
   struct sock **tcp_sk ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_tcp_ecn_fallback ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_ip_nonlocal_bind ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   int sysctl_tcp_mtu_probing ;
   int sysctl_tcp_base_mss ;
   int sysctl_tcp_probe_threshold ;
   u32 sysctl_tcp_probe_interval ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};

#line 113 
struct neighbour;

#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops *) ;
   struct dst_entry *(*check)(struct dst_entry *, __u32 ) ;
   unsigned int (*default_advmss)(struct dst_entry const *) ;
   unsigned int (*mtu)(struct dst_entry const *) ;
   u32 *(*cow_metrics)(struct dst_entry *, unsigned long ) ;
   void (*destroy)(struct dst_entry *) ;
   void (*ifdown)(struct dst_entry *, struct net_device *, int ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry *) ;
   void (*link_failure)(struct sk_buff *) ;
   void (*update_pmtu)(struct dst_entry *, struct sock *, struct sk_buff *, u32 ) ;
   void (*redirect)(struct dst_entry *, struct sock *, struct sk_buff *) ;
   int (*local_out)(struct sk_buff *) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry const *, struct sk_buff *, void const *) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int auto_flowlabels ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
   int idgen_retries ;
   int idgen_delay ;
   int flowlabel_state_ranges ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct ipv6_devconf;

#line 39 
struct rt6_info;

#line 39 
struct rt6_statistics;

#line 39 
struct fib6_table;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t fib6_sernum ;
};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
};

#line 20 
struct sctp_mib;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ieee802154_6lowpan.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netfilter.h"
struct nf_logger;

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger const *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/netfilter.h"
struct ebt_table;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   bool clusterip_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_node;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
};

#line 72 
struct ip_conntrack_stat;

#line 72 
struct nf_ct_event_notifier;

#line 72 
struct nf_exp_event_notifier;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct delayed_work ecache_dwork ;
   bool ecache_dwork_pending ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};

#line 114 
struct nft_af_info;

#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   struct nft_af_info *netdev ;
   unsigned int base_seq ;
   u8 gencursor ;
};

#line 465  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long ) ;
   unsigned long data ;
};

#line 672  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flowcache.h"
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flowcache.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
   u8 dbits4 ;
   u8 sbits4 ;
   u8 dbits6 ;
   u8 sbits6 ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct xfrm_policy_hthresh {
   struct work_struct work ;
   seqlock_t lock ;
   u8 lbits4 ;
   u8 rbits4 ;
   u8 lbits6 ;
   u8 rbits6 ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[3U] ;
   struct xfrm_policy_hash policy_bydst[3U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct xfrm_policy_hthresh policy_hthresh ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};

#line 88 
struct mpls_route;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct netns_mpls {
   size_t platform_labels ;
   struct mpls_route **platform_label ;
   struct ctl_table_header *ctl ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mpls.h"
struct proc_ns_operations;

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mpls.h"
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations const *ops ;
   unsigned int inum ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ns_common.h"
struct net_generic;

#line 12 
struct netns_ipvs;

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ns_common.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   atomic64_t cookie_gen ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   spinlock_t nsid_lock ;
   struct idr netns_ids ;
   struct ns_common ns ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct netns_mpls mpls ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};

#line 241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
struct __anonstruct_possible_net_t_291 {
   struct net *net ;
};

#line 241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
typedef struct __anonstruct_possible_net_t_291 possible_net_t;

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;

#line 186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
   __u32 cls ;
   __u32 cls_msk ;
};

#line 221  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const *data ;
};

#line 652 
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2,
    FWNODE_PDATA = 3
};

#line 659  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct fwnode_handle {
   enum fwnode_type type ;
   struct fwnode_handle *secondary ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
typedef u32 phandle;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
struct device_node {
   char const *name ;
   char const *type ;
   phandle phandle ;
   char const *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};

#line 338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mii.h"
enum ldv_27944 {
    PHY_INTERFACE_MODE_NA = 0,
    PHY_INTERFACE_MODE_MII = 1,
    PHY_INTERFACE_MODE_GMII = 2,
    PHY_INTERFACE_MODE_SGMII = 3,
    PHY_INTERFACE_MODE_TBI = 4,
    PHY_INTERFACE_MODE_REVMII = 5,
    PHY_INTERFACE_MODE_RMII = 6,
    PHY_INTERFACE_MODE_RGMII = 7,
    PHY_INTERFACE_MODE_RGMII_ID = 8,
    PHY_INTERFACE_MODE_RGMII_RXID = 9,
    PHY_INTERFACE_MODE_RGMII_TXID = 10,
    PHY_INTERFACE_MODE_RTBI = 11,
    PHY_INTERFACE_MODE_SMII = 12,
    PHY_INTERFACE_MODE_XGMII = 13,
    PHY_INTERFACE_MODE_MOCA = 14,
    PHY_INTERFACE_MODE_QSGMII = 15,
    PHY_INTERFACE_MODE_MAX = 16
};

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
typedef enum ldv_27944 phy_interface_t;

#line 126 
enum ldv_27997 {
    MDIOBUS_ALLOCATED = 1,
    MDIOBUS_REGISTERED = 2,
    MDIOBUS_UNREGISTERED = 3,
    MDIOBUS_RELEASED = 4
};

#line 133 
struct phy_device;

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct mii_bus {
   char const *name ;
   char id[17U] ;
   void *priv ;
   int (*read)(struct mii_bus *, int , int ) ;
   int (*write)(struct mii_bus *, int , int , u16 ) ;
   int (*reset)(struct mii_bus *) ;
   struct mutex mdio_lock ;
   struct device *parent ;
   enum ldv_27997 state ;
   struct device dev ;
   struct phy_device *phy_map[32U] ;
   u32 phy_mask ;
   u32 phy_ignore_ta_mask ;
   int *irq ;
};

#line 214 
enum phy_state {
    PHY_DOWN = 0,
    PHY_STARTING = 1,
    PHY_READY = 2,
    PHY_PENDING = 3,
    PHY_UP = 4,
    PHY_AN = 5,
    PHY_RUNNING = 6,
    PHY_NOLINK = 7,
    PHY_FORCING = 8,
    PHY_CHANGELINK = 9,
    PHY_HALTED = 10,
    PHY_RESUMING = 11
};

#line 229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_c45_device_ids {
   u32 devices_in_package ;
   u32 device_ids[8U] ;
};

#line 323 
struct phy_driver;

#line 323  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_device {
   struct phy_driver *drv ;
   struct mii_bus *bus ;
   struct device dev ;
   u32 phy_id ;
   struct phy_c45_device_ids c45_ids ;
   bool is_c45 ;
   bool is_internal ;
   bool has_fixups ;
   bool suspended ;
   enum phy_state state ;
   u32 dev_flags ;
   phy_interface_t interface ;
   int addr ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
   int link ;
   u32 interrupts ;
   u32 supported ;
   u32 advertising ;
   u32 lp_advertising ;
   int autoneg ;
   int link_timeout ;
   int irq ;
   void *priv ;
   struct work_struct phy_queue ;
   struct delayed_work state_queue ;
   atomic_t irq_disable ;
   struct mutex lock ;
   struct net_device *attached_dev ;
   void (*adjust_link)(struct net_device *) ;
};

#line 429  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_driver {
   u32 phy_id ;
   char *name ;
   unsigned int phy_id_mask ;
   u32 features ;
   u32 flags ;
   void const *driver_data ;
   int (*soft_reset)(struct phy_device *) ;
   int (*config_init)(struct phy_device *) ;
   int (*probe)(struct phy_device *) ;
   int (*suspend)(struct phy_device *) ;
   int (*resume)(struct phy_device *) ;
   int (*config_aneg)(struct phy_device *) ;
   int (*aneg_done)(struct phy_device *) ;
   int (*read_status)(struct phy_device *) ;
   int (*ack_interrupt)(struct phy_device *) ;
   int (*config_intr)(struct phy_device *) ;
   int (*did_interrupt)(struct phy_device *) ;
   void (*remove)(struct phy_device *) ;
   int (*match_phy_device)(struct phy_device *) ;
   int (*ts_info)(struct phy_device *, struct ethtool_ts_info *) ;
   int (*hwtstamp)(struct phy_device *, struct ifreq *) ;
   bool (*rxtstamp)(struct phy_device *, struct sk_buff *, int ) ;
   void (*txtstamp)(struct phy_device *, struct sk_buff *, int ) ;
   int (*set_wol)(struct phy_device *, struct ethtool_wolinfo *) ;
   void (*get_wol)(struct phy_device *, struct ethtool_wolinfo *) ;
   void (*link_change_notify)(struct phy_device *) ;
   int (*read_mmd_indirect)(struct phy_device *, int , int , int ) ;
   void (*write_mmd_indirect)(struct phy_device *, int , int , int , u32 ) ;
   int (*module_info)(struct phy_device *, struct ethtool_modinfo *) ;
   int (*module_eeprom)(struct phy_device *, struct ethtool_eeprom *, u8 *) ;
   struct device_driver driver ;
};

#line 803  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct fixed_phy_status {
   int link ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy_fixed.h"
enum dsa_tag_protocol {
    DSA_TAG_PROTO_NONE = 0,
    DSA_TAG_PROTO_DSA = 1,
    DSA_TAG_PROTO_TRAILER = 2,
    DSA_TAG_PROTO_EDSA = 3,
    DSA_TAG_PROTO_BRCM = 4
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy_fixed.h"
struct dsa_chip_data {
   struct device *host_dev ;
   int sw_addr ;
   int eeprom_len ;
   struct device_node *of_node ;
   char *port_names[12U] ;
   struct device_node *port_dn[12U] ;
   s8 *rtable ;
};

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   struct net_device *of_netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};

#line 84 
struct packet_type;

#line 85 
struct dsa_switch;

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   int (*rcv)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *) ;
   enum dsa_tag_protocol tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};

#line 123 
struct dsa_switch_driver;

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   enum dsa_tag_protocol tag_protocol ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct device *master_dev ;
   char hwmon_name[24U] ;
   struct device *hwmon_dev ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   u32 phys_mii_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   enum dsa_tag_protocol tag_protocol ;
   int priv_size ;
   char *(*probe)(struct device *, int ) ;
   int (*setup)(struct dsa_switch *) ;
   int (*set_addr)(struct dsa_switch *, u8 *) ;
   u32 (*get_phy_flags)(struct dsa_switch *, int ) ;
   int (*phy_read)(struct dsa_switch *, int , int ) ;
   int (*phy_write)(struct dsa_switch *, int , int , u16 ) ;
   void (*poll_link)(struct dsa_switch *) ;
   void (*adjust_link)(struct dsa_switch *, int , struct phy_device *) ;
   void (*fixed_link_update)(struct dsa_switch *, int , struct fixed_phy_status *) ;
   void (*get_strings)(struct dsa_switch *, int , uint8_t *) ;
   void (*get_ethtool_stats)(struct dsa_switch *, int , uint64_t *) ;
   int (*get_sset_count)(struct dsa_switch *) ;
   void (*get_wol)(struct dsa_switch *, int , struct ethtool_wolinfo *) ;
   int (*set_wol)(struct dsa_switch *, int , struct ethtool_wolinfo *) ;
   int (*suspend)(struct dsa_switch *) ;
   int (*resume)(struct dsa_switch *) ;
   int (*port_enable)(struct dsa_switch *, int , struct phy_device *) ;
   void (*port_disable)(struct dsa_switch *, int , struct phy_device *) ;
   int (*set_eee)(struct dsa_switch *, int , struct phy_device *, struct ethtool_eee *) ;
   int (*get_eee)(struct dsa_switch *, int , struct ethtool_eee *) ;
   int (*get_temp)(struct dsa_switch *, int *) ;
   int (*get_temp_limit)(struct dsa_switch *, int *) ;
   int (*set_temp_limit)(struct dsa_switch *, int ) ;
   int (*get_temp_alarm)(struct dsa_switch *, bool *) ;
   int (*get_eeprom_len)(struct dsa_switch *) ;
   int (*get_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *) ;
   int (*set_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *) ;
   int (*get_regs_len)(struct dsa_switch *, int ) ;
   void (*get_regs)(struct dsa_switch *, int , struct ethtool_regs *, void *) ;
   int (*port_join_bridge)(struct dsa_switch *, int , u32 ) ;
   int (*port_leave_bridge)(struct dsa_switch *, int , u32 ) ;
   int (*port_stp_update)(struct dsa_switch *, int , u8 ) ;
   int (*fdb_add)(struct dsa_switch *, int , unsigned char const *, u16 ) ;
   int (*fdb_del)(struct dsa_switch *, int , unsigned char const *, u16 ) ;
   int (*fdb_getnext)(struct dsa_switch *, int , unsigned char *, bool *) ;
};

#line 320  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_qcn {
   __u8 rpg_enable[8U] ;
   __u32 rppp_max_rps[8U] ;
   __u32 rpg_time_reset[8U] ;
   __u32 rpg_byte_reset[8U] ;
   __u32 rpg_threshold[8U] ;
   __u32 rpg_max_rate[8U] ;
   __u32 rpg_ai_rate[8U] ;
   __u32 rpg_hai_rate[8U] ;
   __u32 rpg_gd[8U] ;
   __u32 rpg_min_dec_fac[8U] ;
   __u32 rpg_min_rate[8U] ;
   __u32 cndd_state_machine[8U] ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_qcn_stats {
   __u64 rppp_rp_centiseconds[8U] ;
   __u32 rppp_created_rps[8U] ;
};

#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};

#line 164  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};

#line 202  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};

#line 236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_setets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_getmaxrate)(struct net_device *, struct ieee_maxrate *) ;
   int (*ieee_setmaxrate)(struct net_device *, struct ieee_maxrate *) ;
   int (*ieee_getqcn)(struct net_device *, struct ieee_qcn *) ;
   int (*ieee_setqcn)(struct net_device *, struct ieee_qcn *) ;
   int (*ieee_getqcnstats)(struct net_device *, struct ieee_qcn_stats *) ;
   int (*ieee_getpfc)(struct net_device *, struct ieee_pfc *) ;
   int (*ieee_setpfc)(struct net_device *, struct ieee_pfc *) ;
   int (*ieee_getapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_setapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_delapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_peer_getets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_peer_getpfc)(struct net_device *, struct ieee_pfc *) ;
   u8 (*getstate)(struct net_device *) ;
   u8 (*setstate)(struct net_device *, u8 ) ;
   void (*getpermhwaddr)(struct net_device *, u8 *) ;
   void (*setpgtccfgtx)(struct net_device *, int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgtx)(struct net_device *, int , u8 ) ;
   void (*setpgtccfgrx)(struct net_device *, int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgrx)(struct net_device *, int , u8 ) ;
   void (*getpgtccfgtx)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *) ;
   void (*getpgbwgcfgtx)(struct net_device *, int , u8 *) ;
   void (*getpgtccfgrx)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *) ;
   void (*getpgbwgcfgrx)(struct net_device *, int , u8 *) ;
   void (*setpfccfg)(struct net_device *, int , u8 ) ;
   void (*getpfccfg)(struct net_device *, int , u8 *) ;
   u8 (*setall)(struct net_device *) ;
   u8 (*getcap)(struct net_device *, int , u8 *) ;
   int (*getnumtcs)(struct net_device *, int , u8 *) ;
   int (*setnumtcs)(struct net_device *, int , u8 ) ;
   u8 (*getpfcstate)(struct net_device *) ;
   void (*setpfcstate)(struct net_device *, u8 ) ;
   void (*getbcncfg)(struct net_device *, int , u32 *) ;
   void (*setbcncfg)(struct net_device *, int , u32 ) ;
   void (*getbcnrp)(struct net_device *, int , u8 *) ;
   void (*setbcnrp)(struct net_device *, int , u8 ) ;
   int (*setapp)(struct net_device *, u8 , u16 , u8 ) ;
   int (*getapp)(struct net_device *, u8 , u16 ) ;
   u8 (*getfeatcfg)(struct net_device *, int , u8 *) ;
   u8 (*setfeatcfg)(struct net_device *, int , u8 ) ;
   u8 (*getdcbx)(struct net_device *) ;
   u8 (*setdcbx)(struct net_device *, u8 ) ;
   int (*peer_getappinfo)(struct net_device *, struct dcb_peer_app_info *, u16 *) ;
   int (*peer_getapptable)(struct net_device *, struct dcb_app *) ;
   int (*cee_peer_getpg)(struct net_device *, struct cee_pg *) ;
   int (*cee_peer_getpfc)(struct net_device *, struct cee_pfc *) ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};

#line 515  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};

#line 1628  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/security.h"
struct mnt_namespace;

#line 1629 
struct ipc_namespace;

#line 1630  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};

#line 147  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr const *nlh ;
   int (*dump)(struct sk_buff *, struct netlink_callback *) ;
   int (*done)(struct netlink_callback *) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netlink.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};

#line 643  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_link.h"
struct ifla_vf_stats {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 broadcast ;
   __u64 multicast ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
   __u32 rss_query_en ;
};

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_bonding.h"
struct netpoll_info;

#line 119 
struct wireless_dev;

#line 120 
struct wpan_dev;

#line 121 
struct mpls_dev;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = -2147483648,
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;

#line 129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};

#line 190 
struct neigh_parms;

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};

#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};

#line 245  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff *, struct net_device *, unsigned short , void const *, void const *, unsigned int ) ;
   int (*parse)(struct sk_buff const *, unsigned char *) ;
   int (*cache)(struct neighbour const *, struct hh_cache *, __be16 ) ;
   void (*cache_update)(struct hh_cache *, struct net_device const *, unsigned char const *) ;
};

#line 295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct *, int ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct hrtimer timer ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};

#line 340 
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
};

#line 388  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;

#line 389  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff **);

#line 537 
struct Qdisc;

#line 537  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
   unsigned long tx_maxrate ;
};

#line 607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};

#line 619  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};

#line 631  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};

#line 683  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};

#line 706  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};

#line 719  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};

#line 730  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};

#line 741  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};

#line 757  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_phys_item_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};

#line 770  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device *) ;
   void (*ndo_uninit)(struct net_device *) ;
   int (*ndo_open)(struct net_device *) ;
   int (*ndo_stop)(struct net_device *) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff *, struct net_device *) ;
   u16 (*ndo_select_queue)(struct net_device *, struct sk_buff *, void *, u16 (*)(struct net_device *, struct sk_buff *)) ;
   void (*ndo_change_rx_flags)(struct net_device *, int ) ;
   void (*ndo_set_rx_mode)(struct net_device *) ;
   int (*ndo_set_mac_address)(struct net_device *, void *) ;
   int (*ndo_validate_addr)(struct net_device *) ;
   int (*ndo_do_ioctl)(struct net_device *, struct ifreq *, int ) ;
   int (*ndo_set_config)(struct net_device *, struct ifmap *) ;
   int (*ndo_change_mtu)(struct net_device *, int ) ;
   int (*ndo_neigh_setup)(struct net_device *, struct neigh_parms *) ;
   void (*ndo_tx_timeout)(struct net_device *) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device *, struct rtnl_link_stats64 *) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device *) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device *, __be16 , u16 ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device *, __be16 , u16 ) ;
   void (*ndo_poll_controller)(struct net_device *) ;
   int (*ndo_netpoll_setup)(struct net_device *, struct netpoll_info *) ;
   void (*ndo_netpoll_cleanup)(struct net_device *) ;
   int (*ndo_busy_poll)(struct napi_struct *) ;
   int (*ndo_set_vf_mac)(struct net_device *, int , u8 *) ;
   int (*ndo_set_vf_vlan)(struct net_device *, int , u16 , u8 ) ;
   int (*ndo_set_vf_rate)(struct net_device *, int , int , int ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device *, int , bool ) ;
   int (*ndo_get_vf_config)(struct net_device *, int , struct ifla_vf_info *) ;
   int (*ndo_set_vf_link_state)(struct net_device *, int , int ) ;
   int (*ndo_get_vf_stats)(struct net_device *, int , struct ifla_vf_stats *) ;
   int (*ndo_set_vf_port)(struct net_device *, int , struct nlattr **) ;
   int (*ndo_get_vf_port)(struct net_device *, int , struct sk_buff *) ;
   int (*ndo_set_vf_rss_query_en)(struct net_device *, int , bool ) ;
   int (*ndo_setup_tc)(struct net_device *, u8 ) ;
   int (*ndo_fcoe_enable)(struct net_device *) ;
   int (*ndo_fcoe_disable)(struct net_device *) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device *, u16 , struct scatterlist *, unsigned int ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device *, u16 ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device *, u16 , struct scatterlist *, unsigned int ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device *, struct netdev_fcoe_hbainfo *) ;
   int (*ndo_fcoe_get_wwn)(struct net_device *, u64 *, int ) ;
   int (*ndo_rx_flow_steer)(struct net_device *, struct sk_buff const *, u16 , u32 ) ;
   int (*ndo_add_slave)(struct net_device *, struct net_device *) ;
   int (*ndo_del_slave)(struct net_device *, struct net_device *) ;
   netdev_features_t (*ndo_fix_features)(struct net_device *, netdev_features_t ) ;
   int (*ndo_set_features)(struct net_device *, netdev_features_t ) ;
   int (*ndo_neigh_construct)(struct neighbour *) ;
   void (*ndo_neigh_destroy)(struct neighbour *) ;
   int (*ndo_fdb_add)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 , u16 ) ;
   int (*ndo_fdb_del)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 ) ;
   int (*ndo_fdb_dump)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int ) ;
   int (*ndo_bridge_setlink)(struct net_device *, struct nlmsghdr *, u16 ) ;
   int (*ndo_bridge_getlink)(struct sk_buff *, u32 , u32 , struct net_device *, u32 , int ) ;
   int (*ndo_bridge_dellink)(struct net_device *, struct nlmsghdr *, u16 ) ;
   int (*ndo_change_carrier)(struct net_device *, bool ) ;
   int (*ndo_get_phys_port_id)(struct net_device *, struct netdev_phys_item_id *) ;
   int (*ndo_get_phys_port_name)(struct net_device *, char *, size_t ) ;
   void (*ndo_add_vxlan_port)(struct net_device *, sa_family_t , __be16 ) ;
   void (*ndo_del_vxlan_port)(struct net_device *, sa_family_t , __be16 ) ;
   void *(*ndo_dfwd_add_station)(struct net_device *, struct net_device *) ;
   void (*ndo_dfwd_del_station)(struct net_device *, void *) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff *, struct net_device *, void *) ;
   int (*ndo_get_lock_subclass)(struct net_device *) ;
   netdev_features_t (*ndo_features_check)(struct sk_buff *, struct net_device *, netdev_features_t ) ;
   int (*ndo_set_tx_maxrate)(struct net_device *, int , u32 ) ;
   int (*ndo_get_iflink)(struct net_device const *) ;
};

#line 1243 
enum ldv_29709 {
    NETREG_UNINITIALIZED = 0,
    NETREG_REGISTERED = 1,
    NETREG_UNREGISTERING = 2,
    NETREG_UNREGISTERED = 3,
    NETREG_RELEASED = 4,
    NETREG_DUMMY = 5
};

#line 1252 
enum ldv_29710 {
    RTNL_LINK_INITIALIZED = 0,
    RTNL_LINK_INITIALIZING = 1
};

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct __anonstruct_adj_list_304 {
   struct list_head upper ;
   struct list_head lower ;
};

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct __anonstruct_all_adj_list_305 {
   struct list_head upper ;
   struct list_head lower ;
};

#line 1257 
struct iw_handler_def;

#line 1257 
struct iw_public_data;

#line 1257 
struct switchdev_ops;

#line 1257 
struct vlan_info;

#line 1257 
struct tipc_bearer;

#line 1257 
struct in_device;

#line 1257 
struct dn_dev;

#line 1257 
struct inet6_dev;

#line 1257 
struct tcf_proto;

#line 1257 
struct cpu_rmap;

#line 1257 
struct pcpu_lstats;

#line 1257 
struct pcpu_sw_netstats;

#line 1257 
struct pcpu_dstats;

#line 1257 
struct pcpu_vstats;

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
union __anonunion_306 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};

#line 1257 
struct garp_port;

#line 1257 
struct mrp_port;

#line 1257 
struct rtnl_link_ops;

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   atomic_t carrier_changes ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct list_head ptype_all ;
   struct list_head ptype_specific ;
   struct __anonstruct_adj_list_304 adj_list ;
   struct __anonstruct_all_adj_list_305 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int group ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   struct iw_handler_def const *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops const *netdev_ops ;
   struct ethtool_ops const *ethtool_ops ;
   struct switchdev_ops const *switchdev_ops ;
   struct header_ops const *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   unsigned char name_assign_type ;
   bool uc_promisc ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   struct wpan_dev *ieee802154_ptr ;
   struct mpls_dev *mpls_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   unsigned long gro_flush_timeout ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct tcf_proto *ingress_cl_list ;
   struct netdev_queue *ingress_queue ;
   struct list_head nf_hooks_ingress ;
   unsigned char broadcast[32U] ;
   struct cpu_rmap *rx_cpu_rmap ;
   struct hlist_node index_hlist ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   int watchdog_timeo ;
   struct xps_dev_maps *xps_maps ;
   unsigned long trans_start ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct list_head link_watch_list ;
   enum ldv_29709 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) reg_state : 8 ;
   bool dismantle ;
   enum ldv_29710 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) rtnl_link_state : 16 ;
   void (*destructor)(struct net_device *) ;
   struct netpoll_info *npinfo ;
   possible_net_t nd_net ;
   union __anonunion_306 __anonCompField_net_device_93 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group const *sysfs_groups[4U] ;
   struct attribute_group const *sysfs_rx_queue_group ;
   struct rtnl_link_ops const *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   u16 gso_min_segs ;
   struct dcbnl_rtnl_ops const *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
};

#line 1978  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct packet_type {
   __be16 type ;
   struct net_device *dev ;
   int (*func)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *) ;
   bool (*id_match)(struct packet_type *, struct sock *) ;
   void *af_packet_priv ;
   struct list_head list ;
};

#line 2025  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};

#line 2893 
enum skb_free_reason {
    SKB_REASON_CONSUMED = 0,
    SKB_REASON_DROPPED = 1
};

#line 449  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
enum led_brightness {
    LED_OFF = 0,
    LED_HALF = 127,
    LED_FULL = 255
};

#line 455 
struct led_trigger;

#line 455  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
struct led_classdev {
   char const *name ;
   enum led_brightness brightness ;
   enum led_brightness max_brightness ;
   int flags ;
   void (*brightness_set)(struct led_classdev *, enum led_brightness ) ;
   int (*brightness_set_sync)(struct led_classdev *, enum led_brightness ) ;
   enum led_brightness (*brightness_get)(struct led_classdev *) ;
   int (*blink_set)(struct led_classdev *, unsigned long *, unsigned long *) ;
   struct device *dev ;
   struct attribute_group const **groups ;
   struct list_head node ;
   char const *default_trigger ;
   unsigned long blink_delay_on ;
   unsigned long blink_delay_off ;
   struct timer_list blink_timer ;
   int blink_brightness ;
   void (*flash_resume)(struct led_classdev *) ;
   struct work_struct set_brightness_work ;
   int delayed_set_value ;
   struct rw_semaphore trigger_lock ;
   struct led_trigger *trigger ;
   struct list_head trig_list ;
   void *trigger_data ;
   bool activated ;
   struct mutex led_access ;
};

#line 200  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/leds.h"
struct led_trigger {
   char const *name ;
   void (*activate)(struct led_classdev *) ;
   void (*deactivate)(struct led_classdev *) ;
   rwlock_t leddev_list_lock ;
   struct list_head led_cdevs ;
   struct list_head next_trig ;
};

#line 677  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct ieee80211_msrment_ie {
   u8 token ;
   u8 mode ;
   u8 type ;
   u8 request[0U] ;
};

#line 700  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct ieee80211_ext_chansw_ie {
   u8 mode ;
   u8 new_operating_class ;
   u8 new_ch_num ;
   u8 count ;
};

#line 831  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct ieee80211_tpc_report_ie {
   u8 tx_power ;
   u8 link_margin ;
};

#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct __anonstruct_auth_316 {
   __le16 auth_alg ;
   __le16 auth_transaction ;
   __le16 status_code ;
   u8 variable[0U] ;
};

#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct __anonstruct_deauth_317 {
   __le16 reason_code ;
};

#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct __anonstruct_assoc_req_318 {
   __le16 capab_info ;
   __le16 listen_interval ;
   u8 variable[0U] ;
};

#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct __anonstruct_assoc_resp_319 {
   __le16 capab_info ;
   __le16 status_code ;
   __le16 aid ;
   u8 variable[0U] ;
};

#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct __anonstruct_reassoc_resp_320 {
   __le16 capab_info ;
   __le16 status_code ;
   __le16 aid ;
   u8 variable[0U] ;
};

#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct __anonstruct_reassoc_req_321 {
   __le16 capab_info ;
   __le16 listen_interval ;
   u8 current_ap[6U] ;
   u8 variable[0U] ;
};

#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct __anonstruct_disassoc_322 {
   __le16 reason_code ;
};

#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct __anonstruct_beacon_323 {
   __le64 timestamp ;
   __le16 beacon_int ;
   __le16 capab_info ;
   u8 variable[0U] ;
};

#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct __anonstruct_probe_req_324 {
   u8 variable[0U] ;
};

#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct __anonstruct_probe_resp_325 {
   __le64 timestamp ;
   __le16 beacon_int ;
   __le16 capab_info ;
   u8 variable[0U] ;
};

#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct __anonstruct_wme_action_328 {
   u8 action_code ;
   u8 dialog_token ;
   u8 status_code ;
   u8 variable[0U] ;
};

#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct __anonstruct_chan_switch_329 {
   u8 action_code ;
   u8 variable[0U] ;
};

#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct __anonstruct_ext_chan_switch_330 {
   u8 action_code ;
   struct ieee80211_ext_chansw_ie data ;
   u8 variable[0U] ;
};

#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct __anonstruct_measurement_331 {
   u8 action_code ;
   u8 dialog_token ;
   u8 element_id ;
   u8 length ;
   struct ieee80211_msrment_ie msr_elem ;
};

#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct __anonstruct_addba_req_332 {
   u8 action_code ;
   u8 dialog_token ;
   __le16 capab ;
   __le16 timeout ;
   __le16 start_seq_num ;
};

#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct __anonstruct_addba_resp_333 {
   u8 action_code ;
   u8 dialog_token ;
   __le16 status ;
   __le16 capab ;
   __le16 timeout ;
};

#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct __anonstruct_delba_334 {
   u8 action_code ;
   __le16 params ;
   __le16 reason_code ;
};

#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct __anonstruct_self_prot_335 {
   u8 action_code ;
   u8 variable[0U] ;
};

#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct __anonstruct_mesh_action_336 {
   u8 action_code ;
   u8 variable[0U] ;
};

#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct __anonstruct_sa_query_337 {
   u8 action ;
   u8 trans_id[2U] ;
};

#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct __anonstruct_ht_smps_338 {
   u8 action ;
   u8 smps_control ;
};

#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct __anonstruct_ht_notify_cw_339 {
   u8 action_code ;
   u8 chanwidth ;
};

#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct __anonstruct_tdls_discover_resp_340 {
   u8 action_code ;
   u8 dialog_token ;
   __le16 capability ;
   u8 variable[0U] ;
};

#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct __anonstruct_vht_opmode_notif_341 {
   u8 action_code ;
   u8 operating_mode ;
};

#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct __anonstruct_tpc_report_342 {
   u8 action_code ;
   u8 dialog_token ;
   u8 tpc_elem_id ;
   u8 tpc_elem_length ;
   struct ieee80211_tpc_report_ie tpc ;
};

#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
union __anonunion_u_327 {
   struct __anonstruct_wme_action_328 wme_action ;
   struct __anonstruct_chan_switch_329 chan_switch ;
   struct __anonstruct_ext_chan_switch_330 ext_chan_switch ;
   struct __anonstruct_measurement_331 measurement ;
   struct __anonstruct_addba_req_332 addba_req ;
   struct __anonstruct_addba_resp_333 addba_resp ;
   struct __anonstruct_delba_334 delba ;
   struct __anonstruct_self_prot_335 self_prot ;
   struct __anonstruct_mesh_action_336 mesh_action ;
   struct __anonstruct_sa_query_337 sa_query ;
   struct __anonstruct_ht_smps_338 ht_smps ;
   struct __anonstruct_ht_notify_cw_339 ht_notify_cw ;
   struct __anonstruct_tdls_discover_resp_340 tdls_discover_resp ;
   struct __anonstruct_vht_opmode_notif_341 vht_opmode_notif ;
   struct __anonstruct_tpc_report_342 tpc_report ;
};

#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct __anonstruct_action_326 {
   u8 category ;
   union __anonunion_u_327 u ;
};

#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
union __anonunion_u_315 {
   struct __anonstruct_auth_316 auth ;
   struct __anonstruct_deauth_317 deauth ;
   struct __anonstruct_assoc_req_318 assoc_req ;
   struct __anonstruct_assoc_resp_319 assoc_resp ;
   struct __anonstruct_reassoc_resp_320 reassoc_resp ;
   struct __anonstruct_reassoc_req_321 reassoc_req ;
   struct __anonstruct_disassoc_322 disassoc ;
   struct __anonstruct_beacon_323 beacon ;
   struct __anonstruct_probe_req_324 probe_req ;
   struct __anonstruct_probe_resp_325 probe_resp ;
   struct __anonstruct_action_326 action ;
};

#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct ieee80211_mgmt {
   __le16 frame_control ;
   __le16 duration ;
   u8 da[6U] ;
   u8 sa[6U] ;
   u8 bssid[6U] ;
   __le16 seq_ctrl ;
   union __anonunion_u_315 u ;
};

#line 1161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct ieee80211_p2p_noa_desc {
   u8 count ;
   __le32 duration ;
   __le32 interval ;
   __le32 start_time ;
};

#line 1180  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct ieee80211_p2p_noa_attr {
   u8 index ;
   u8 oppps_ctwindow ;
   struct ieee80211_p2p_noa_desc desc[4U] ;
};

#line 1204  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct ieee80211_mcs_info {
   u8 rx_mask[10U] ;
   __le16 rx_highest ;
   u8 tx_params ;
   u8 reserved[3U] ;
};

#line 1229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct ieee80211_ht_cap {
   __le16 cap_info ;
   u8 ampdu_params_info ;
   struct ieee80211_mcs_info mcs ;
   __le16 extended_ht_cap_info ;
   __le32 tx_BF_cap_info ;
   u8 antenna_selection_info ;
};

#line 1354  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct ieee80211_vht_mcs_info {
   __le16 rx_mcs_map ;
   __le16 rx_highest ;
   __le16 tx_mcs_map ;
   __le16 tx_highest ;
};

#line 1435  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct ieee80211_vht_cap {
   __le32 vht_cap_info ;
   struct ieee80211_vht_mcs_info supp_mcs ;
};

#line 470  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debugfs.h"
enum nl80211_iftype {
    NL80211_IFTYPE_UNSPECIFIED = 0,
    NL80211_IFTYPE_ADHOC = 1,
    NL80211_IFTYPE_STATION = 2,
    NL80211_IFTYPE_AP = 3,
    NL80211_IFTYPE_AP_VLAN = 4,
    NL80211_IFTYPE_WDS = 5,
    NL80211_IFTYPE_MONITOR = 6,
    NL80211_IFTYPE_MESH_POINT = 7,
    NL80211_IFTYPE_P2P_CLIENT = 8,
    NL80211_IFTYPE_P2P_GO = 9,
    NL80211_IFTYPE_P2P_DEVICE = 10,
    NL80211_IFTYPE_OCB = 11,
    NUM_NL80211_IFTYPES = 12,
    NL80211_IFTYPE_MAX = 11
};

#line 2431  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/nl80211.h"
enum nl80211_reg_initiator {
    NL80211_REGDOM_SET_BY_CORE = 0,
    NL80211_REGDOM_SET_BY_USER = 1,
    NL80211_REGDOM_SET_BY_DRIVER = 2,
    NL80211_REGDOM_SET_BY_COUNTRY_IE = 3
};

#line 2484 
enum nl80211_dfs_regions {
    NL80211_DFS_UNSET = 0,
    NL80211_DFS_FCC = 1,
    NL80211_DFS_ETSI = 2,
    NL80211_DFS_JP = 3
};

#line 2491 
enum nl80211_user_reg_hint_type {
    NL80211_USER_REG_HINT_USER = 0,
    NL80211_USER_REG_HINT_CELL_BASE = 1,
    NL80211_USER_REG_HINT_INDOOR = 2
};

#line 2607 
enum nl80211_chan_width {
    NL80211_CHAN_WIDTH_20_NOHT = 0,
    NL80211_CHAN_WIDTH_20 = 1,
    NL80211_CHAN_WIDTH_40 = 2,
    NL80211_CHAN_WIDTH_80 = 3,
    NL80211_CHAN_WIDTH_80P80 = 4,
    NL80211_CHAN_WIDTH_160 = 5,
    NL80211_CHAN_WIDTH_5 = 6,
    NL80211_CHAN_WIDTH_10 = 7
};

#line 2618 
enum nl80211_bss_scan_width {
    NL80211_BSS_CHAN_WIDTH_20 = 0,
    NL80211_BSS_CHAN_WIDTH_10 = 1,
    NL80211_BSS_CHAN_WIDTH_5 = 2
};

#line 2650 
enum nl80211_auth_type {
    NL80211_AUTHTYPE_OPEN_SYSTEM = 0,
    NL80211_AUTHTYPE_SHARED_KEY = 1,
    NL80211_AUTHTYPE_FT = 2,
    NL80211_AUTHTYPE_NETWORK_EAP = 3,
    NL80211_AUTHTYPE_SAE = 4,
    __NL80211_AUTHTYPE_NUM = 5,
    NL80211_AUTHTYPE_MAX = 4,
    NL80211_AUTHTYPE_AUTOMATIC = 5
};

#line 2668 
enum nl80211_mfp {
    NL80211_MFP_NO = 0,
    NL80211_MFP_REQUIRED = 1
};

#line 3596 
enum nl80211_tx_power_setting {
    NL80211_TX_POWER_AUTOMATIC = 0,
    NL80211_TX_POWER_LIMITED = 1,
    NL80211_TX_POWER_FIXED = 2
};

#line 3734  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/nl80211.h"
struct nl80211_wowlan_tcp_data_seq {
   __u32 start ;
   __u32 offset ;
   __u32 len ;
};

#line 3871  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/nl80211.h"
struct nl80211_wowlan_tcp_data_token {
   __u32 offset ;
   __u32 len ;
   __u8 token_stream[] ;
};

#line 3883  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/nl80211.h"
struct nl80211_wowlan_tcp_data_token_feature {
   __u32 min_len ;
   __u32 max_len ;
   __u32 bufsize ;
};

#line 4131 
enum nl80211_dfs_state {
    NL80211_DFS_USABLE = 0,
    NL80211_DFS_UNAVAILABLE = 1,
    NL80211_DFS_AVAILABLE = 2
};

#line 4153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/nl80211.h"
struct nl80211_vendor_cmd_info {
   __u32 vendor_id ;
   __u32 subcmd ;
};

#line 4581 
enum environment_cap {
    ENVIRON_ANY = 0,
    ENVIRON_INDOOR = 1,
    ENVIRON_OUTDOOR = 2
};

#line 4587  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/nl80211.h"
struct regulatory_request {
   struct callback_head callback_head ;
   int wiphy_idx ;
   enum nl80211_reg_initiator initiator ;
   enum nl80211_user_reg_hint_type user_reg_hint_type ;
   char alpha2[2U] ;
   enum nl80211_dfs_regions dfs_region ;
   bool intersect ;
   bool processed ;
   enum environment_cap country_ie_env ;
   struct list_head list ;
};

#line 99  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/regulatory.h"
struct ieee80211_freq_range {
   u32 start_freq_khz ;
   u32 end_freq_khz ;
   u32 max_bandwidth_khz ;
};

#line 185  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/regulatory.h"
struct ieee80211_power_rule {
   u32 max_antenna_gain ;
   u32 max_eirp ;
};

#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/regulatory.h"
struct ieee80211_reg_rule {
   struct ieee80211_freq_range freq_range ;
   struct ieee80211_power_rule power_rule ;
   u32 flags ;
   u32 dfs_cac_ms ;
};

#line 197  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/regulatory.h"
struct ieee80211_regdomain {
   struct callback_head callback_head ;
   u32 n_reg_rules ;
   char alpha2[3U] ;
   enum nl80211_dfs_regions dfs_region ;
   struct ieee80211_reg_rule reg_rules[] ;
};

#line 205 
struct wiphy;

#line 206 
enum ieee80211_band {
    IEEE80211_BAND_2GHZ = 0,
    IEEE80211_BAND_5GHZ = 1,
    IEEE80211_BAND_60GHZ = 2,
    IEEE80211_NUM_BANDS = 3
};

#line 228  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/regulatory.h"
struct ieee80211_channel {
   enum ieee80211_band band ;
   u16 center_freq ;
   u16 hw_value ;
   u32 flags ;
   int max_antenna_gain ;
   int max_power ;
   int max_reg_power ;
   bool beacon_found ;
   u32 orig_flags ;
   int orig_mag ;
   int orig_mpwr ;
   enum nl80211_dfs_state dfs_state ;
   unsigned long dfs_state_entered ;
   unsigned int dfs_cac_ms ;
};

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct ieee80211_rate {
   u32 flags ;
   u16 bitrate ;
   u16 hw_value ;
   u16 hw_value_short ;
};

#line 269  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct ieee80211_sta_ht_cap {
   u16 cap ;
   bool ht_supported ;
   u8 ampdu_factor ;
   u8 ampdu_density ;
   struct ieee80211_mcs_info mcs ;
};

#line 289  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct ieee80211_sta_vht_cap {
   bool vht_supported ;
   u32 cap ;
   struct ieee80211_vht_mcs_info vht_mcs ;
};

#line 305  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct ieee80211_supported_band {
   struct ieee80211_channel *channels ;
   struct ieee80211_rate *bitrates ;
   enum ieee80211_band band ;
   int n_channels ;
   int n_bitrates ;
   struct ieee80211_sta_ht_cap ht_cap ;
   struct ieee80211_sta_vht_cap vht_cap ;
};

#line 387  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_chan_def {
   struct ieee80211_channel *chan ;
   enum nl80211_chan_width width ;
   u32 center_freq1 ;
   u32 center_freq2 ;
};

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct survey_info {
   struct ieee80211_channel *channel ;
   u64 time ;
   u64 time_busy ;
   u64 time_ext_busy ;
   u64 time_rx ;
   u64 time_tx ;
   u64 time_scan ;
   u32 filled ;
   s8 noise ;
};

#line 608  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_crypto_settings {
   u32 wpa_versions ;
   u32 cipher_group ;
   int n_ciphers_pairwise ;
   u32 ciphers_pairwise[5U] ;
   int n_akm_suites ;
   u32 akm_suites[2U] ;
   bool control_port ;
   __be16 control_port_ethertype ;
   bool control_port_no_encrypt ;
};

#line 671  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct mac_address {
   u8 addr[6U] ;
};

#line 1395  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_ssid {
   u8 ssid[32U] ;
   u8 ssid_len ;
};

#line 1428  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_scan_request {
   struct cfg80211_ssid *ssids ;
   int n_ssids ;
   u32 n_channels ;
   enum nl80211_bss_scan_width scan_width ;
   u8 const *ie ;
   size_t ie_len ;
   u32 flags ;
   u32 rates[3U] ;
   struct wireless_dev *wdev ;
   u8 mac_addr[6U] ;
   u8 mac_addr_mask[6U] ;
   struct wiphy *wiphy ;
   unsigned long scan_start ;
   bool aborted ;
   bool notified ;
   bool no_cck ;
   struct ieee80211_channel *channels[0U] ;
};

#line 1491  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_match_set {
   struct cfg80211_ssid ssid ;
   s32 rssi_thold ;
};

#line 1499  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_sched_scan_request {
   struct cfg80211_ssid *ssids ;
   int n_ssids ;
   u32 n_channels ;
   enum nl80211_bss_scan_width scan_width ;
   u32 interval ;
   u8 const *ie ;
   size_t ie_len ;
   u32 flags ;
   struct cfg80211_match_set *match_sets ;
   int n_match_sets ;
   s32 min_rssi_thold ;
   u32 delay ;
   u8 mac_addr[6U] ;
   u8 mac_addr_mask[6U] ;
   struct wiphy *wiphy ;
   struct net_device *dev ;
   unsigned long scan_start ;
   struct callback_head callback_head ;
   u32 owner_nlportid ;
   struct ieee80211_channel *channels[0U] ;
};

#line 1561 
enum cfg80211_signal_type {
    CFG80211_SIGNAL_TYPE_NONE = 0,
    CFG80211_SIGNAL_TYPE_MBM = 1,
    CFG80211_SIGNAL_TYPE_UNSPEC = 2
};

#line 1766  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_ibss_params {
   u8 const *ssid ;
   u8 const *bssid ;
   struct cfg80211_chan_def chandef ;
   u8 const *ie ;
   u8 ssid_len ;
   u8 ie_len ;
   u16 beacon_interval ;
   u32 basic_rates ;
   bool channel_fixed ;
   bool privacy ;
   bool control_port ;
   bool userspace_handles_dfs ;
   int mcast_rate[3U] ;
   struct ieee80211_ht_cap ht_capa ;
   struct ieee80211_ht_cap ht_capa_mask ;
};

#line 1814  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_connect_params {
   struct ieee80211_channel *channel ;
   struct ieee80211_channel *channel_hint ;
   u8 const *bssid ;
   u8 const *bssid_hint ;
   u8 const *ssid ;
   size_t ssid_len ;
   enum nl80211_auth_type auth_type ;
   u8 const *ie ;
   size_t ie_len ;
   bool privacy ;
   enum nl80211_mfp mfp ;
   struct cfg80211_crypto_settings crypto ;
   u8 const *key ;
   u8 key_len ;
   u8 key_idx ;
   u32 flags ;
   int bg_scan_period ;
   struct ieee80211_ht_cap ht_capa ;
   struct ieee80211_ht_cap ht_capa_mask ;
   struct ieee80211_vht_cap vht_capa ;
   struct ieee80211_vht_cap vht_capa_mask ;
};

#line 1916  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_pkt_pattern {
   u8 const *mask ;
   u8 const *pattern ;
   int pattern_len ;
   int pkt_offset ;
};

#line 1933  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_wowlan_tcp {
   struct socket *sock ;
   __be32 src ;
   __be32 dst ;
   u16 src_port ;
   u16 dst_port ;
   u8 dst_mac[6U] ;
   int payload_len ;
   u8 const *payload ;
   struct nl80211_wowlan_tcp_data_seq payload_seq ;
   u32 data_interval ;
   u32 wake_len ;
   u8 const *wake_data ;
   u8 const *wake_mask ;
   u32 tokens_size ;
   struct nl80211_wowlan_tcp_data_token payload_tok ;
};

#line 1968  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_wowlan {
   bool any ;
   bool disconnect ;
   bool magic_pkt ;
   bool gtk_rekey_failure ;
   bool eap_identity_req ;
   bool four_way_handshake ;
   bool rfkill_release ;
   struct cfg80211_pkt_pattern *patterns ;
   struct cfg80211_wowlan_tcp *tcp ;
   int n_patterns ;
   struct cfg80211_sched_scan_request *nd_config ;
};

#line 2736  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct ieee80211_iface_limit {
   u16 max ;
   u16 types ;
};

#line 2797  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct ieee80211_iface_combination {
   struct ieee80211_iface_limit const *limits ;
   u32 num_different_channels ;
   u16 max_interfaces ;
   u8 n_limits ;
   bool beacon_int_infra_match ;
   u8 radar_detect_widths ;
   u8 radar_detect_regions ;
};

#line 2869  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct ieee80211_txrx_stypes {
   u16 tx ;
   u16 rx ;
};

#line 2885  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct wiphy_wowlan_tcp_support {
   struct nl80211_wowlan_tcp_data_token_feature const *tok ;
   u32 data_payload_max ;
   u32 data_interval_max ;
   u32 wake_payload_max ;
   bool seq ;
};

#line 2910  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct wiphy_wowlan_support {
   u32 flags ;
   int n_patterns ;
   int pattern_max_len ;
   int pattern_min_len ;
   int max_pkt_offset ;
   int max_nd_match_sets ;
   struct wiphy_wowlan_tcp_support const *tcp ;
};

#line 2935  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct wiphy_coalesce_support {
   int n_rules ;
   int max_delay ;
   int n_patterns ;
   int pattern_max_len ;
   int pattern_min_len ;
   int max_pkt_offset ;
};

#line 2960  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct wiphy_vendor_command {
   struct nl80211_vendor_cmd_info info ;
   u32 flags ;
   int (*doit)(struct wiphy *, struct wireless_dev *, void const *, int ) ;
};

#line 2981  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct wiphy {
   u8 perm_addr[6U] ;
   u8 addr_mask[6U] ;
   struct mac_address *addresses ;
   struct ieee80211_txrx_stypes const *mgmt_stypes ;
   struct ieee80211_iface_combination const *iface_combinations ;
   int n_iface_combinations ;
   u16 software_iftypes ;
   u16 n_addresses ;
   u16 interface_modes ;
   u16 max_acl_mac_addrs ;
   u32 flags ;
   u32 regulatory_flags ;
   u32 features ;
   u8 ext_features[1U] ;
   u32 ap_sme_capa ;
   enum cfg80211_signal_type signal_type ;
   int bss_priv_size ;
   u8 max_scan_ssids ;
   u8 max_sched_scan_ssids ;
   u8 max_match_sets ;
   u16 max_scan_ie_len ;
   u16 max_sched_scan_ie_len ;
   int n_cipher_suites ;
   u32 const *cipher_suites ;
   u8 retry_short ;
   u8 retry_long ;
   u32 frag_threshold ;
   u32 rts_threshold ;
   u8 coverage_class ;
   char fw_version[32U] ;
   u32 hw_version ;
   struct wiphy_wowlan_support const *wowlan ;
   struct cfg80211_wowlan *wowlan_config ;
   u16 max_remain_on_channel_duration ;
   u8 max_num_pmkids ;
   u32 available_antennas_tx ;
   u32 available_antennas_rx ;
   u32 probe_resp_offload ;
   u8 const *extended_capabilities ;
   u8 const *extended_capabilities_mask ;
   u8 extended_capabilities_len ;
   void const *privid ;
   struct ieee80211_supported_band *bands[3U] ;
   void (*reg_notifier)(struct wiphy *, struct regulatory_request *) ;
   struct ieee80211_regdomain const *regd ;
   struct device dev ;
   bool registered ;
   struct dentry *debugfsdir ;
   struct ieee80211_ht_cap const *ht_capa_mod_mask ;
   struct ieee80211_vht_cap const *vht_capa_mod_mask ;
   possible_net_t _net ;
   struct iw_handler_def const *wext ;
   struct wiphy_coalesce_support const *coalesce ;
   struct wiphy_vendor_command const *vendor_commands ;
   struct nl80211_vendor_cmd_info const *vendor_events ;
   int n_vendor_commands ;
   int n_vendor_events ;
   u16 max_ap_assoc_sta ;
   u8 max_num_csa_counters ;
   u8 max_adj_channel_rssi_comp ;
   char priv[0U] ;
};

#line 3369 
struct cfg80211_conn;

#line 3370 
struct cfg80211_internal_bss;

#line 3371 
struct cfg80211_cached_keys;

#line 3372  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct __anonstruct_wext_355 {
   struct cfg80211_ibss_params ibss ;
   struct cfg80211_connect_params connect ;
   struct cfg80211_cached_keys *keys ;
   u8 const *ie ;
   size_t ie_len ;
   u8 bssid[6U] ;
   u8 prev_bssid[6U] ;
   u8 ssid[32U] ;
   s8 default_key ;
   s8 default_mgmt_key ;
   bool prev_bssid_valid ;
};

#line 3372  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct wireless_dev {
   struct wiphy *wiphy ;
   enum nl80211_iftype iftype ;
   struct list_head list ;
   struct net_device *netdev ;
   u32 identifier ;
   struct list_head mgmt_registrations ;
   spinlock_t mgmt_registrations_lock ;
   struct mutex mtx ;
   bool use_4addr ;
   bool p2p_started ;
   u8 address[6U] ;
   u8 ssid[32U] ;
   u8 ssid_len ;
   u8 mesh_id_len ;
   u8 mesh_id_up_len ;
   struct cfg80211_conn *conn ;
   struct cfg80211_cached_keys *connect_keys ;
   struct list_head event_list ;
   spinlock_t event_lock ;
   struct cfg80211_internal_bss *current_bss ;
   struct cfg80211_chan_def preset_chandef ;
   struct cfg80211_chan_def chandef ;
   bool ibss_fixed ;
   bool ibss_dfs_possible ;
   bool ps ;
   int ps_timeout ;
   int beacon_interval ;
   u32 ap_unexpected_nlportid ;
   bool cac_started ;
   unsigned long cac_start_time ;
   unsigned int cac_time_ms ;
   u32 owner_nlportid ;
   struct __anonstruct_wext_355 wext ;
};

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_chanctx_conf {
   struct cfg80211_chan_def def ;
   struct cfg80211_chan_def min_def ;
   u8 rx_chains_static ;
   u8 rx_chains_dynamic ;
   bool radar_enabled ;
   u8 drv_priv[0U] ;
};

#line 229 
struct ieee80211_vif;

#line 407 
struct ieee80211_sta;

#line 436  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_bss_conf {
   u8 const *bssid ;
   bool assoc ;
   bool ibss_joined ;
   bool ibss_creator ;
   u16 aid ;
   bool use_cts_prot ;
   bool use_short_preamble ;
   bool use_short_slot ;
   bool enable_beacon ;
   u8 dtim_period ;
   u16 beacon_int ;
   u16 assoc_capability ;
   u64 sync_tsf ;
   u32 sync_device_ts ;
   u8 sync_dtim_count ;
   u32 basic_rates ;
   struct ieee80211_rate *beacon_rate ;
   int mcast_rate[3U] ;
   u16 ht_operation_mode ;
   s32 cqm_rssi_thold ;
   u32 cqm_rssi_hyst ;
   struct cfg80211_chan_def chandef ;
   __be32 arp_addr_list[4U] ;
   int arp_addr_cnt ;
   bool qos ;
   bool idle ;
   bool ps ;
   u8 ssid[32U] ;
   size_t ssid_len ;
   bool hidden_ssid ;
   int txpower ;
   enum nl80211_tx_power_setting txpower_type ;
   struct ieee80211_p2p_noa_attr p2p_noa_attr ;
};

#line 598  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_tx_rate {
   s8 idx ;
   u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(5))) count : 5 ;
   u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(11))) flags : 11 ;
};

#line 819  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct __anonstruct_360 {
   struct ieee80211_tx_rate rates[4U] ;
   s8 rts_cts_rate_idx ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) use_rts : 1 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) use_cts_prot : 1 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) short_preamble : 1 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) skip_table : 1 ;
};

#line 819  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
union __anonunion_359 {
   struct __anonstruct_360 __anonCompField___anonunion_359_95 ;
   unsigned long jiffies ;
};

#line 819 
struct ieee80211_key_conf;

#line 819  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct __anonstruct_control_358 {
   union __anonunion_359 __anonCompField___anonstruct_control_358_96 ;
   struct ieee80211_vif *vif ;
   struct ieee80211_key_conf *hw_key ;
   u32 flags ;
};

#line 819  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct __anonstruct_ack_361 {
   u64 cookie ;
};

#line 819  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct __anonstruct_status_362 {
   struct ieee80211_tx_rate rates[4U] ;
   s32 ack_signal ;
   u8 ampdu_ack_len ;
   u8 ampdu_len ;
   u8 antenna ;
   u16 tx_time ;
   void *status_driver_data[2U] ;
};

#line 819  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct __anonstruct_363 {
   struct ieee80211_tx_rate driver_rates[4U] ;
   u8 pad[4U] ;
   void *rate_driver_data[3U] ;
};

#line 819  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
union __anonunion_357 {
   struct __anonstruct_control_358 control ;
   struct __anonstruct_ack_361 ack ;
   struct __anonstruct_status_362 status ;
   struct __anonstruct_363 __anonCompField___anonunion_357_97 ;
   void *driver_data[5U] ;
};

#line 819  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_tx_info {
   u32 flags ;
   u8 band ;
   u8 hw_queue ;
   u16 ack_frame_id ;
   union __anonunion_357 __anonCompField_ieee80211_tx_info_98 ;
};

#line 1174 
enum ieee80211_smps_mode {
    IEEE80211_SMPS_AUTOMATIC = 0,
    IEEE80211_SMPS_OFF = 1,
    IEEE80211_SMPS_STATIC = 2,
    IEEE80211_SMPS_DYNAMIC = 3,
    IEEE80211_SMPS_NUM_MODES = 4
};

#line 1182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_conf {
   u32 flags ;
   int power_level ;
   int dynamic_ps_timeout ;
   int max_sleep_period ;
   u16 listen_interval ;
   u8 ps_dtim_period ;
   u8 long_frame_max_tx_count ;
   u8 short_frame_max_tx_count ;
   struct cfg80211_chan_def chandef ;
   bool radar_enabled ;
   enum ieee80211_smps_mode smps_mode ;
};

#line 1316 
struct ieee80211_txq;

#line 1316  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_vif {
   enum nl80211_iftype type ;
   struct ieee80211_bss_conf bss_conf ;
   u8 addr[6U] ;
   bool p2p ;
   bool csa_active ;
   u8 cab_queue ;
   u8 hw_queue[4U] ;
   struct ieee80211_txq *txq ;
   struct ieee80211_chanctx_conf *chanctx_conf ;
   u32 driver_flags ;
   struct dentry *debugfs_dir ;
   u8 drv_priv[0U] ;
};

#line 1432  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_key_conf {
   atomic64_t tx_pn ;
   u32 cipher ;
   u8 icv_len ;
   u8 iv_len ;
   u8 hw_key_idx ;
   u8 flags ;
   s8 keyidx ;
   u8 keylen ;
   u8 key[0U] ;
};

#line 1547  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_cipher_scheme {
   u32 cipher ;
   u16 iftype ;
   u8 hdr_len ;
   u8 pn_len ;
   u8 pn_off ;
   u8 key_idx_off ;
   u8 key_idx_mask ;
   u8 key_idx_shift ;
   u8 mic_len ;
};

#line 1590 
enum ieee80211_sta_rx_bandwidth {
    IEEE80211_STA_RX_BW_20 = 0,
    IEEE80211_STA_RX_BW_40 = 1,
    IEEE80211_STA_RX_BW_80 = 2,
    IEEE80211_STA_RX_BW_160 = 3
};

#line 1597  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct __anonstruct_rate_371 {
   s8 idx ;
   u8 count ;
   u8 count_cts ;
   u8 count_rts ;
   u16 flags ;
};

#line 1597  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_sta_rates {
   struct callback_head callback_head ;
   struct __anonstruct_rate_371 rate[4U] ;
};

#line 1645  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_sta {
   u32 supp_rates[3U] ;
   u8 addr[6U] ;
   u16 aid ;
   struct ieee80211_sta_ht_cap ht_cap ;
   struct ieee80211_sta_vht_cap vht_cap ;
   bool wme ;
   u8 uapsd_queues ;
   u8 max_sp ;
   u8 rx_nss ;
   enum ieee80211_sta_rx_bandwidth bandwidth ;
   enum ieee80211_smps_mode smps_mode ;
   struct ieee80211_sta_rates *rates ;
   bool tdls ;
   bool tdls_initiator ;
   bool mfp ;
   struct ieee80211_txq *txq[16U] ;
   u8 drv_priv[0U] ;
};

#line 1726  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_txq {
   struct ieee80211_vif *vif ;
   struct ieee80211_sta *sta ;
   u8 tid ;
   u8 ac ;
   u8 drv_priv[0U] ;
};

#line 1781  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_hw {
   struct ieee80211_conf conf ;
   struct wiphy *wiphy ;
   char const *rate_control_algorithm ;
   void *priv ;
   unsigned long flags[1U] ;
   unsigned int extra_tx_headroom ;
   unsigned int extra_beacon_tailroom ;
   int vif_data_size ;
   int sta_data_size ;
   int chanctx_data_size ;
   int txq_data_size ;
   u16 queues ;
   u16 max_listen_interval ;
   s8 max_signal ;
   u8 max_rates ;
   u8 max_report_rates ;
   u8 max_rate_tries ;
   u8 max_rx_aggregation_subframes ;
   u8 max_tx_aggregation_subframes ;
   u8 offchannel_tx_hw_queue ;
   u8 radiotap_mcs_details ;
   u16 radiotap_vht_details ;
   netdev_features_t netdev_features ;
   u8 uapsd_queues ;
   u8 uapsd_max_sp_len ;
   u8 n_cipher_schemes ;
   struct ieee80211_cipher_scheme const *cipher_schemes ;
   int txq_ac_max_pending ;
};

#line 5323  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct __anonstruct_desc_372 {
   u32 start ;
   u32 duration ;
   u32 interval ;
};

#line 5323  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_noa_data {
   u32 next_tsf ;
   bool has_next_tsf ;
   u8 absent ;
   u8 count[4U] ;
   struct __anonstruct_desc_372 desc[4U] ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath.h"
struct ath_ani {
   bool caldone ;
   unsigned int longcal_timer ;
   unsigned int shortcal_timer ;
   unsigned int resetcal_timer ;
   unsigned int checkani_timer ;
   struct timer_list timer ;
};

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath.h"
struct ath_cycle_counters {
   u32 cycles ;
   u32 rx_busy ;
   u32 rx_frame ;
   u32 tx_frame ;
};

#line 53 
enum ath_device_state {
    ATH_HW_UNAVAILABLE = 0,
    ATH_HW_INITIALIZED = 1
};

#line 69 
enum ath_bus_type {
    ATH_PCI = 0,
    ATH_AHB = 1,
    ATH_USB = 2
};

#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath.h"
struct reg_dmn_pair_mapping {
   u16 reg_domain ;
   u16 reg_5ghz_ctl ;
   u16 reg_2ghz_ctl ;
};

#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath.h"
struct ath_regulatory {
   char alpha2[2U] ;
   enum nl80211_dfs_regions region ;
   u16 country_code ;
   u16 max_power_level ;
   u16 current_rd ;
   int16_t power_limit ;
   struct reg_dmn_pair_mapping *regpair ;
};

#line 91 
enum ath_crypt_caps {
    ATH_CRYPT_CAP_CIPHER_AESCCM = 1,
    ATH_CRYPT_CAP_MIC_COMBINED = 2
};

#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath.h"
struct ath_ops {
   unsigned int (*read)(void *, u32 ) ;
   void (*multi_read)(void *, u32 *, u32 *, u16 ) ;
   void (*write)(void *, u32 , u32 ) ;
   void (*enable_write_buffer)(void *) ;
   void (*write_flush)(void *) ;
   u32 (*rmw)(void *, u32 , u32 , u32 ) ;
   void (*enable_rmw_buffer)(void *) ;
   void (*rmw_flush)(void *) ;
};

#line 137 
struct ath_common;

#line 138 
struct ath_bus_ops;

#line 139  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath.h"
struct ath_ps_ops {
   void (*wakeup)(struct ath_common *) ;
   void (*restore)(struct ath_common *) ;
};

#line 146  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath.h"
struct ath_common {
   void *ah ;
   void *priv ;
   struct ieee80211_hw *hw ;
   int debug_mask ;
   enum ath_device_state state ;
   unsigned long op_flags ;
   struct ath_ani ani ;
   u16 cachelsz ;
   u16 curaid ;
   u8 macaddr[6U] ;
   u8 curbssid[6U] ;
   u8 bssidmask[6U] ;
   u32 rx_bufsize ;
   u32 keymax ;
   unsigned long keymap[2U] ;
   unsigned long tkip_keymap[2U] ;
   unsigned long ccmp_keymap[2U] ;
   enum ath_crypt_caps crypt_caps ;
   unsigned int clockrate ;
   spinlock_t cc_lock ;
   struct ath_cycle_counters cc_ani ;
   struct ath_cycle_counters cc_survey ;
   struct ath_regulatory regulatory ;
   struct ath_regulatory reg_world_copy ;
   struct ath_ops const *ops ;
   struct ath_bus_ops const *bus_ops ;
   struct ath_ps_ops const *ps_ops ;
   bool btcoex_enabled ;
   bool disable_ani ;
   bool bt_ant_diversity ;
   int last_rssi ;
   struct ieee80211_supported_band sbands[3U] ;
};

#line 323  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath.h"
struct firmware {
   size_t size ;
   u8 const *data ;
   struct page **pages ;
   void *priv ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/firmware.h"
struct ath_tx_status {
   u32 ts_tstamp ;
   u16 ts_seqnum ;
   u8 ts_status ;
   u8 ts_rateindex ;
   int8_t ts_rssi ;
   u8 ts_shortretry ;
   u8 ts_longretry ;
   u8 ts_virtcol ;
   u8 ts_flags ;
   int8_t ts_rssi_ctl0 ;
   int8_t ts_rssi_ctl1 ;
   int8_t ts_rssi_ctl2 ;
   int8_t ts_rssi_ext0 ;
   int8_t ts_rssi_ext1 ;
   int8_t ts_rssi_ext2 ;
   u8 qid ;
   u16 desc_id ;
   u8 tid ;
   u32 ba_low ;
   u32 ba_high ;
   u32 evm0 ;
   u32 evm1 ;
   u32 evm2 ;
   u32 duration ;
};

#line 311  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mac.h"
enum ath9k_tx_queue {
    ATH9K_TX_QUEUE_INACTIVE = 0,
    ATH9K_TX_QUEUE_DATA = 1,
    ATH9K_TX_QUEUE_BEACON = 2,
    ATH9K_TX_QUEUE_CAB = 3,
    ATH9K_TX_QUEUE_UAPSD = 4,
    ATH9K_TX_QUEUE_PSPOLL = 5
};

#line 320 
enum ath9k_tx_queue_flags {
    TXQ_FLAG_TXINT_ENABLE = 1,
    TXQ_FLAG_TXDESCINT_ENABLE = 2,
    TXQ_FLAG_TXEOLINT_ENABLE = 4,
    TXQ_FLAG_TXURNINT_ENABLE = 8,
    TXQ_FLAG_BACKOFF_DISABLE = 16,
    TXQ_FLAG_COMPRESSION_ENABLE = 32,
    TXQ_FLAG_RDYTIME_EXP_POLICY_ENABLE = 64,
    TXQ_FLAG_FRAG_BURST_BACKOFF_ENABLE = 128
};

#line 331 
enum ath9k_pkt_type {
    ATH9K_PKT_TYPE_NORMAL = 0,
    ATH9K_PKT_TYPE_ATIM = 1,
    ATH9K_PKT_TYPE_PSPOLL = 2,
    ATH9K_PKT_TYPE_BEACON = 3,
    ATH9K_PKT_TYPE_PROBE_RESP = 4,
    ATH9K_PKT_TYPE_CHIRP = 5,
    ATH9K_PKT_TYPE_GRP_POLL = 6
};

#line 341  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mac.h"
struct ath9k_tx_queue_info {
   u32 tqi_ver ;
   enum ath9k_tx_queue tqi_type ;
   int tqi_subtype ;
   enum ath9k_tx_queue_flags tqi_qflags ;
   u32 tqi_priority ;
   u32 tqi_aifs ;
   u32 tqi_cwmin ;
   u32 tqi_cwmax ;
   u16 tqi_shretry ;
   u16 tqi_lgretry ;
   u32 tqi_cbrPeriod ;
   u32 tqi_cbrOverflowLimit ;
   u32 tqi_burstTime ;
   u32 tqi_readyTime ;
   u32 tqi_physCompBuf ;
   u32 tqi_intFlags ;
};

#line 655  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mac.h"
struct ath9k_11n_rate_series {
   u32 Tries ;
   u32 Rate ;
   u32 PktDuration ;
   u32 ChSel ;
   u32 RateFlags ;
};

#line 668 
enum aggr_type {
    AGGR_BUF_NONE = 0,
    AGGR_BUF_FIRST = 1,
    AGGR_BUF_MIDDLE = 2,
    AGGR_BUF_LAST = 3
};

#line 675 
enum ath9k_key_type {
    ATH9K_KEY_TYPE_CLEAR = 0,
    ATH9K_KEY_TYPE_WEP = 1,
    ATH9K_KEY_TYPE_AES = 2,
    ATH9K_KEY_TYPE_TKIP = 3
};

#line 682  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mac.h"
struct ath_tx_info {
   u8 qcu ;
   bool is_first ;
   bool is_last ;
   enum aggr_type aggr ;
   u8 ndelim ;
   u16 aggr_len ;
   dma_addr_t link ;
   int pkt_len ;
   u32 flags ;
   dma_addr_t buf_addr[4U] ;
   int buf_len[4U] ;
   struct ath9k_11n_rate_series rates[4U] ;
   u8 rtscts_rate ;
   bool dur_update ;
   enum ath9k_pkt_type type ;
   enum ath9k_key_type keytype ;
   u8 keyix ;
   u8 txpower[4U] ;
};

#line 709 
struct ath_hw;

#line 710 
struct ath9k_channel;

#line 711 
enum ath9k_int;

#line 711 
enum ath9k_int;

#line 749 
enum ath9k_ani_cmd {
    ATH9K_ANI_OFDM_WEAK_SIGNAL_DETECTION = 1,
    ATH9K_ANI_FIRSTEP_LEVEL = 2,
    ATH9K_ANI_SPUR_IMMUNITY_LEVEL = 4,
    ATH9K_ANI_MRC_CCK = 8,
    ATH9K_ANI_ALL = 4095
};

#line 757  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mac.h"
struct ath9k_mib_stats {
   u32 ackrcv_bad ;
   u32 rts_bad ;
   u32 rts_good ;
   u32 fcs_bad ;
   u32 beacons ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ani.h"
struct ath9k_ani_default {
   u16 m1ThreshLow ;
   u16 m2ThreshLow ;
   u16 m1Thresh ;
   u16 m2Thresh ;
   u16 m2CountThr ;
   u16 m2CountThrLow ;
   u16 m1ThreshLowExt ;
   u16 m2ThreshLowExt ;
   u16 m1ThreshExt ;
   u16 m2ThreshExt ;
   u16 firstep ;
   u16 firstepLow ;
   u16 cycpwrThr1 ;
   u16 cycpwrThr1Ext ;
};

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ani.h"
struct ar5416AniState {
   u8 noiseImmunityLevel ;
   u8 ofdmNoiseImmunityLevel ;
   u8 cckNoiseImmunityLevel ;
   bool ofdmsTurn ;
   u8 mrcCCK ;
   u8 spurImmunityLevel ;
   u8 firstepLevel ;
   bool ofdmWeakSigDetect ;
   u32 listenTime ;
   u32 ofdmPhyErrCount ;
   u32 cckPhyErrCount ;
   struct ath9k_ani_default iniDef ;
};

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ani.h"
struct ar5416Stats {
   u32 ast_ani_spurup ;
   u32 ast_ani_spurdown ;
   u32 ast_ani_ofdmon ;
   u32 ast_ani_ofdmoff ;
   u32 ast_ani_cckhigh ;
   u32 ast_ani_ccklow ;
   u32 ast_ani_stepup ;
   u32 ast_ani_stepdown ;
   u32 ast_ani_ofdmerrs ;
   u32 ast_ani_cckerrs ;
   u32 ast_ani_reset ;
   u32 ast_ani_lneg_or_lzero ;
   u32 avgbrssi ;
   struct ath9k_mib_stats ast_mibstats ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ani.h"
struct eepFlags {
   u8 opFlags ;
   u8 eepMisc ;
};

#line 171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ar9003_eeprom.h"
struct ar9300_base_eep_hdr {
   __le16 regDmn[2U] ;
   u8 txrxMask ;
   struct eepFlags opCapFlags ;
   u8 rfSilent ;
   u8 blueToothOptions ;
   u8 deviceCap ;
   u8 deviceType ;
   int8_t pwrTableOffset ;
   u8 params_for_tuning_caps[2U] ;
   u8 featureEnable ;
   u8 miscConfiguration ;
   u8 eepromWriteEnableGpio ;
   u8 wlanDisableGpio ;
   u8 wlanLedGpio ;
   u8 rxBandSelectGpio ;
   u8 txrxgain ;
   __le32 swreg ;
};

#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ar9003_eeprom.h"
struct ar9300_modal_eep_header {
   __le32 antCtrlCommon ;
   __le32 antCtrlCommon2 ;
   __le16 antCtrlChain[3U] ;
   u8 xatten1DB[3U] ;
   u8 xatten1Margin[3U] ;
   int8_t tempSlope ;
   int8_t voltSlope ;
   u8 spurChans[5U] ;
   int8_t noiseFloorThreshCh[3U] ;
   u8 reserved[11U] ;
   int8_t quick_drop ;
   u8 xpaBiasLvl ;
   u8 txFrameToDataStart ;
   u8 txFrameToPaOn ;
   u8 txClip ;
   int8_t antennaGain ;
   u8 switchSettling ;
   int8_t adcDesiredSize ;
   u8 txEndToXpaOff ;
   u8 txEndToRxOn ;
   u8 txFrameToXpaOn ;
   u8 thresh62 ;
   __le32 papdRateMaskHt20 ;
   __le32 papdRateMaskHt40 ;
   __le16 switchcomspdt ;
   u8 xlna_bias_strength ;
   u8 futureModal[7U] ;
};

#line 242  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ar9003_eeprom.h"
struct ar9300_cal_data_per_freq_op_loop {
   int8_t refPower ;
   u8 voltMeas ;
   u8 tempMeas ;
   int8_t rxNoisefloorCal ;
   int8_t rxNoisefloorPower ;
   u8 rxTempMeas ;
};

#line 256  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ar9003_eeprom.h"
struct cal_tgt_pow_legacy {
   u8 tPow2x[4U] ;
};

#line 260  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ar9003_eeprom.h"
struct cal_tgt_pow_ht {
   u8 tPow2x[14U] ;
};

#line 264  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ar9003_eeprom.h"
struct cal_ctl_data_2g {
   u8 ctlEdges[4U] ;
};

#line 268  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ar9003_eeprom.h"
struct cal_ctl_data_5g {
   u8 ctlEdges[8U] ;
};

#line 272  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ar9003_eeprom.h"
struct ar9300_BaseExtension_1 {
   u8 ant_div_control ;
   u8 future[2U] ;
   u8 misc_enable ;
   int8_t tempslopextension[8U] ;
   int8_t quick_drop_low ;
   int8_t quick_drop_high ;
};

#line 290  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ar9003_eeprom.h"
struct ar9300_BaseExtension_2 {
   int8_t tempSlopeLow ;
   int8_t tempSlopeHigh ;
   u8 xatten1DBLow[3U] ;
   u8 xatten1MarginLow[3U] ;
   u8 xatten1DBHigh[3U] ;
   u8 xatten1MarginHigh[3U] ;
};

#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ar9003_eeprom.h"
struct ar9300_eeprom {
   u8 eepromVersion ;
   u8 templateVersion ;
   u8 macAddr[6U] ;
   u8 custData[20U] ;
   struct ar9300_base_eep_hdr baseEepHeader ;
   struct ar9300_modal_eep_header modalHeader2G ;
   struct ar9300_BaseExtension_1 base_ext1 ;
   u8 calFreqPier2G[3U] ;
   struct ar9300_cal_data_per_freq_op_loop calPierData2G[3U][3U] ;
   u8 calTarget_freqbin_Cck[2U] ;
   u8 calTarget_freqbin_2G[3U] ;
   u8 calTarget_freqbin_2GHT20[3U] ;
   u8 calTarget_freqbin_2GHT40[3U] ;
   struct cal_tgt_pow_legacy calTargetPowerCck[2U] ;
   struct cal_tgt_pow_legacy calTargetPower2G[3U] ;
   struct cal_tgt_pow_ht calTargetPower2GHT20[3U] ;
   struct cal_tgt_pow_ht calTargetPower2GHT40[3U] ;
   u8 ctlIndex_2G[12U] ;
   u8 ctl_freqbin_2G[12U][4U] ;
   struct cal_ctl_data_2g ctlPowerData_2G[12U] ;
   struct ar9300_modal_eep_header modalHeader5G ;
   struct ar9300_BaseExtension_2 base_ext2 ;
   u8 calFreqPier5G[8U] ;
   struct ar9300_cal_data_per_freq_op_loop calPierData5G[3U][8U] ;
   u8 calTarget_freqbin_5G[8U] ;
   u8 calTarget_freqbin_5GHT20[8U] ;
   u8 calTarget_freqbin_5GHT40[8U] ;
   struct cal_tgt_pow_legacy calTargetPower5G[8U] ;
   struct cal_tgt_pow_ht calTargetPower5GHT20[8U] ;
   struct cal_tgt_pow_ht calTargetPower5GHT40[8U] ;
   u8 ctlIndex_5G[9U] ;
   u8 ctl_freqbin_5G[9U][8U] ;
   struct cal_ctl_data_5g ctlPowerData_5G[9U] ;
};

#line 358 
enum eeprom_param {
    EEP_NFTHRESH_5 = 0,
    EEP_NFTHRESH_2 = 1,
    EEP_MAC_MSW = 2,
    EEP_MAC_MID = 3,
    EEP_MAC_LSW = 4,
    EEP_REG_0 = 5,
    EEP_OP_CAP = 6,
    EEP_OP_MODE = 7,
    EEP_RF_SILENT = 8,
    EEP_OB_5 = 9,
    EEP_DB_5 = 10,
    EEP_OB_2 = 11,
    EEP_DB_2 = 12,
    EEP_MINOR_REV = 13,
    EEP_TX_MASK = 14,
    EEP_RX_MASK = 15,
    EEP_FSTCLK_5G = 16,
    EEP_RXGAIN_TYPE = 17,
    EEP_OL_PWRCTRL = 18,
    EEP_TXGAIN_TYPE = 19,
    EEP_RC_CHAIN_MASK = 20,
    EEP_DAC_HPWR_5G = 21,
    EEP_FRAC_N_5G = 22,
    EEP_DEV_TYPE = 23,
    EEP_TEMPSENSE_SLOPE = 24,
    EEP_TEMPSENSE_SLOPE_PAL_ON = 25,
    EEP_PWR_TABLE_OFFSET = 26,
    EEP_PAPRD = 27,
    EEP_MODAL_VER = 28,
    EEP_ANT_DIV_CTL1 = 29,
    EEP_CHAIN_MASK_REDUCE = 30,
    EEP_ANTENNA_GAIN_2G = 31,
    EEP_ANTENNA_GAIN_5G = 32
};

#line 439  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ar9003_eeprom.h"
struct base_eep_header {
   u16 length ;
   u16 checksum ;
   u16 version ;
   u8 opCapFlags ;
   u8 eepMisc ;
   u16 regDmn[2U] ;
   u8 macAddr[6U] ;
   u8 rxMask ;
   u8 txMask ;
   u16 rfSilent ;
   u16 blueToothOptions ;
   u16 deviceCap ;
   u32 binBuildNumber ;
   u8 deviceType ;
   u8 pwdclkind ;
   u8 fastClk5g ;
   u8 divChain ;
   u8 rxGainType ;
   u8 dacHiPwrMode_5G ;
   u8 openLoopPwrCntl ;
   u8 dacLpMode ;
   u8 txGainType ;
   u8 rcChainMask ;
   u8 desiredScaleCCK ;
   u8 pwr_table_offset ;
   u8 frac_n_5g ;
   u8 futureBase_3[21U] ;
};

#line 300  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/eeprom.h"
struct base_eep_header_4k {
   u16 length ;
   u16 checksum ;
   u16 version ;
   u8 opCapFlags ;
   u8 eepMisc ;
   u16 regDmn[2U] ;
   u8 macAddr[6U] ;
   u8 rxMask ;
   u8 txMask ;
   u16 rfSilent ;
   u16 blueToothOptions ;
   u16 deviceCap ;
   u32 binBuildNumber ;
   u8 deviceType ;
   u8 txGainType ;
};

#line 318  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/eeprom.h"
struct spur_chan {
   u16 spurChan ;
   u8 spurRangeLow ;
   u8 spurRangeHigh ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/eeprom.h"
struct modal_eep_header {
   u32 antCtrlChain[3U] ;
   u32 antCtrlCommon ;
   u8 antennaGainCh[3U] ;
   u8 switchSettling ;
   u8 txRxAttenCh[3U] ;
   u8 rxTxMarginCh[3U] ;
   u8 adcDesiredSize ;
   u8 pgaDesiredSize ;
   u8 xlnaGainCh[3U] ;
   u8 txEndToXpaOff ;
   u8 txEndToRxOn ;
   u8 txFrameToXpaOn ;
   u8 thresh62 ;
   u8 noiseFloorThreshCh[3U] ;
   u8 xpdGain ;
   u8 xpd ;
   u8 iqCalICh[3U] ;
   u8 iqCalQCh[3U] ;
   u8 pdGainOverlap ;
   u8 ob ;
   u8 db ;
   u8 xpaBiasLvl ;
   u8 pwrDecreaseFor2Chain ;
   u8 pwrDecreaseFor3Chain ;
   u8 txFrameToDataStart ;
   u8 txFrameToPaOn ;
   u8 ht40PowerIncForPdadc ;
   u8 bswAtten[3U] ;
   u8 bswMargin[3U] ;
   u8 swSettleHt40 ;
   u8 xatten2Db[3U] ;
   u8 xatten2Margin[3U] ;
   u8 ob_ch1 ;
   u8 db_ch1 ;
   u8 lna_ctl ;
   u8 miscBits ;
   u16 xpaBiasLvlFreq[3U] ;
   u8 futureModal[6U] ;
   struct spur_chan spurChans[5U] ;
};

#line 375  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/eeprom.h"
struct modal_eep_4k_header {
   u32 antCtrlChain[1U] ;
   u32 antCtrlCommon ;
   u8 antennaGainCh[1U] ;
   u8 switchSettling ;
   u8 txRxAttenCh[1U] ;
   u8 rxTxMarginCh[1U] ;
   u8 adcDesiredSize ;
   u8 pgaDesiredSize ;
   u8 xlnaGainCh[1U] ;
   u8 txEndToXpaOff ;
   u8 txEndToRxOn ;
   u8 txFrameToXpaOn ;
   u8 thresh62 ;
   u8 noiseFloorThreshCh[1U] ;
   u8 xpdGain ;
   u8 xpd ;
   u8 iqCalICh[1U] ;
   u8 iqCalQCh[1U] ;
   u8 pdGainOverlap ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) ob_0 : 4 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) ob_1 : 4 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) db1_0 : 4 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) db1_1 : 4 ;
   u8 xpaBiasLvl ;
   u8 txFrameToDataStart ;
   u8 txFrameToPaOn ;
   u8 ht40PowerIncForPdadc ;
   u8 bswAtten[1U] ;
   u8 bswMargin[1U] ;
   u8 swSettleHt40 ;
   u8 xatten2Db[1U] ;
   u8 xatten2Margin[1U] ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) db2_0 : 4 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) db2_1 : 4 ;
   u8 version ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) ob_2 : 4 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) ob_3 : 4 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) ob_4 : 4 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) antdiv_ctl1 : 4 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) db1_2 : 4 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) db1_3 : 4 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) db1_4 : 4 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) antdiv_ctl2 : 4 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) db2_2 : 4 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) db2_3 : 4 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) db2_4 : 4 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) reserved : 4 ;
   u8 tx_diversity ;
   u8 flc_pwr_thresh ;
   u8 bb_scale_smrt_antenna ;
   u8 futureModal[1U] ;
   struct spur_chan spurChans[5U] ;
};

#line 440  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/eeprom.h"
struct base_eep_ar9287_header {
   u16 length ;
   u16 checksum ;
   u16 version ;
   u8 opCapFlags ;
   u8 eepMisc ;
   u16 regDmn[2U] ;
   u8 macAddr[6U] ;
   u8 rxMask ;
   u8 txMask ;
   u16 rfSilent ;
   u16 blueToothOptions ;
   u16 deviceCap ;
   u32 binBuildNumber ;
   u8 deviceType ;
   u8 openLoopPwrCntl ;
   int8_t pwrTableOffset ;
   int8_t tempSensSlope ;
   int8_t tempSensSlopePalOn ;
   u8 futureBase[29U] ;
};

#line 462  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/eeprom.h"
struct modal_eep_ar9287_header {
   u32 antCtrlChain[2U] ;
   u32 antCtrlCommon ;
   int8_t antennaGainCh[2U] ;
   u8 switchSettling ;
   u8 txRxAttenCh[2U] ;
   u8 rxTxMarginCh[2U] ;
   int8_t adcDesiredSize ;
   u8 txEndToXpaOff ;
   u8 txEndToRxOn ;
   u8 txFrameToXpaOn ;
   u8 thresh62 ;
   int8_t noiseFloorThreshCh[2U] ;
   u8 xpdGain ;
   u8 xpd ;
   int8_t iqCalICh[2U] ;
   int8_t iqCalQCh[2U] ;
   u8 pdGainOverlap ;
   u8 xpaBiasLvl ;
   u8 txFrameToDataStart ;
   u8 txFrameToPaOn ;
   u8 ht40PowerIncForPdadc ;
   u8 bswAtten[2U] ;
   u8 bswMargin[2U] ;
   u8 swSettleHt40 ;
   u8 version ;
   u8 db1 ;
   u8 db2 ;
   u8 ob_cck ;
   u8 ob_psk ;
   u8 ob_qam ;
   u8 ob_pal_off ;
   u8 futureModal[30U] ;
   struct spur_chan spurChans[5U] ;
};

#line 498  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/eeprom.h"
struct cal_data_per_freq {
   u8 pwrPdg[4U][5U] ;
   u8 vpdPdg[4U][5U] ;
};

#line 503  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/eeprom.h"
struct cal_data_per_freq_4k {
   u8 pwrPdg[2U][5U] ;
   u8 vpdPdg[2U][5U] ;
};

#line 508  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/eeprom.h"
struct cal_target_power_leg {
   u8 bChannel ;
   u8 tPow2x[4U] ;
};

#line 513  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/eeprom.h"
struct cal_target_power_ht {
   u8 bChannel ;
   u8 tPow2x[8U] ;
};

#line 518  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/eeprom.h"
struct cal_ctl_edges {
   u8 bChannel ;
   u8 ctl ;
};

#line 523  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/eeprom.h"
struct cal_data_op_loop_ar9287 {
   u8 pwrPdg[2U][5U] ;
   u8 vpdPdg[2U][5U] ;
   u8 pcdac[2U][5U] ;
   u8 empty[2U][5U] ;
};

#line 530  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/eeprom.h"
struct cal_data_per_freq_ar9287 {
   u8 pwrPdg[4U][1U] ;
   u8 vpdPdg[4U][1U] ;
};

#line 535  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/eeprom.h"
union cal_data_per_freq_ar9287_u {
   struct cal_data_op_loop_ar9287 calDataOpen ;
   struct cal_data_per_freq_ar9287 calDataClose ;
};

#line 540  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/eeprom.h"
struct cal_ctl_data_ar9287 {
   struct cal_ctl_edges ctlEdges[2U][4U] ;
};

#line 545  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/eeprom.h"
struct cal_ctl_data {
   struct cal_ctl_edges ctlEdges[3U][8U] ;
};

#line 550  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/eeprom.h"
struct cal_ctl_data_4k {
   struct cal_ctl_edges ctlEdges[1U][4U] ;
};

#line 555  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/eeprom.h"
struct ar5416_eeprom_def {
   struct base_eep_header baseEepHeader ;
   u8 custData[64U] ;
   struct modal_eep_header modalHeader[2U] ;
   u8 calFreqPier5G[8U] ;
   u8 calFreqPier2G[4U] ;
   struct cal_data_per_freq calPierData5G[3U][8U] ;
   struct cal_data_per_freq calPierData2G[3U][4U] ;
   struct cal_target_power_leg calTargetPower5G[8U] ;
   struct cal_target_power_ht calTargetPower5GHT20[8U] ;
   struct cal_target_power_ht calTargetPower5GHT40[8U] ;
   struct cal_target_power_leg calTargetPowerCck[3U] ;
   struct cal_target_power_leg calTargetPower2G[4U] ;
   struct cal_target_power_ht calTargetPower2GHT20[4U] ;
   struct cal_target_power_ht calTargetPower2GHT40[4U] ;
   u8 ctlIndex[24U] ;
   struct cal_ctl_data ctlData[24U] ;
   u8 padding ;
};

#line 584  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/eeprom.h"
struct ar5416_eeprom_4k {
   struct base_eep_header_4k baseEepHeader ;
   u8 custData[20U] ;
   struct modal_eep_4k_header modalHeader ;
   u8 calFreqPier2G[3U] ;
   struct cal_data_per_freq_4k calPierData2G[1U][3U] ;
   struct cal_target_power_leg calTargetPowerCck[3U] ;
   struct cal_target_power_leg calTargetPower2G[3U] ;
   struct cal_target_power_ht calTargetPower2GHT20[3U] ;
   struct cal_target_power_ht calTargetPower2GHT40[3U] ;
   u8 ctlIndex[12U] ;
   struct cal_ctl_data_4k ctlData[12U] ;
   u8 padding ;
};

#line 604  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/eeprom.h"
struct ar9287_eeprom {
   struct base_eep_ar9287_header baseEepHeader ;
   u8 custData[32U] ;
   struct modal_eep_ar9287_header modalHeader ;
   u8 calFreqPier2G[3U] ;
   union cal_data_per_freq_ar9287_u calPierData2G[2U][3U] ;
   struct cal_target_power_leg calTargetPowerCck[3U] ;
   struct cal_target_power_leg calTargetPower2G[3U] ;
   struct cal_target_power_ht calTargetPower2GHT20[3U] ;
   struct cal_target_power_ht calTargetPower2GHT40[3U] ;
   u8 ctlIndex[12U] ;
   struct cal_ctl_data_ar9287 ctlData[12U] ;
   u8 padding ;
};

#line 641  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/eeprom.h"
struct eeprom_ops {
   int (*check_eeprom)(struct ath_hw *) ;
   u32 (*get_eeprom)(struct ath_hw *, enum eeprom_param ) ;
   bool (*fill_eeprom)(struct ath_hw *) ;
   u32 (*dump_eeprom)(struct ath_hw *, bool , u8 *, u32 , u32 ) ;
   int (*get_eeprom_ver)(struct ath_hw *) ;
   int (*get_eeprom_rev)(struct ath_hw *) ;
   void (*set_board_values)(struct ath_hw *, struct ath9k_channel *) ;
   void (*set_addac)(struct ath_hw *, struct ath9k_channel *) ;
   void (*set_txpower)(struct ath_hw *, struct ath9k_channel *, u16 , u8 , u8 , bool ) ;
   u16 (*get_spur_channel)(struct ath_hw *, u16 , bool ) ;
};

#line 716  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/eeprom.h"
struct ar5416IniArray {
   u32 *ia_array ;
   u32 ia_rows ;
   u32 ia_columns ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/calib.h"
enum ath9k_cal_state {
    CAL_INACTIVE = 0,
    CAL_WAITING = 1,
    CAL_RUNNING = 2,
    CAL_DONE = 3
};

#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/calib.h"
struct ath9k_percal_data {
   u32 calType ;
   u32 calNumSamples ;
   u32 calCountMax ;
   void (*calCollect)(struct ath_hw *) ;
   void (*calPostProc)(struct ath_hw *, u8 ) ;
};

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/calib.h"
struct ath9k_cal_list {
   struct ath9k_percal_data const *calData ;
   enum ath9k_cal_state calState ;
   struct ath9k_cal_list *calNext ;
};

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/calib.h"
struct ath9k_nfcal_hist {
   int16_t nfCalBuffer[5U] ;
   u8 currIndex ;
   int16_t privNF ;
   u8 invalidNFcount ;
};

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/calib.h"
struct ath9k_pacal_info {
   int32_t prev_offset ;
   int8_t max_skipcount ;
   int8_t skipcount ;
};

#line 120 
enum ath_usb_dev {
    AR9280_USB = 1,
    AR9287_USB = 2,
    STORAGE_DEVICE = 3
};

#line 151 
enum ath9k_ant_div_comb_lna_conf {
    ATH_ANT_DIV_COMB_LNA1_MINUS_LNA2 = 0,
    ATH_ANT_DIV_COMB_LNA2 = 1,
    ATH_ANT_DIV_COMB_LNA1 = 2,
    ATH_ANT_DIV_COMB_LNA1_PLUS_LNA2 = 3
};

#line 167 
enum ath_btcoex_scheme {
    ATH_BTCOEX_CFG_NONE = 0,
    ATH_BTCOEX_CFG_2WIRE = 1,
    ATH_BTCOEX_CFG_3WIRE = 2,
    ATH_BTCOEX_CFG_MCI = 3
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/calib.h"
struct ath9k_hw_mci {
   u32 raw_intr ;
   u32 rx_msg_intr ;
   u32 cont_status ;
   u32 gpm_addr ;
   u32 gpm_len ;
   u32 gpm_idx ;
   u32 sched_addr ;
   u32 wlan_channels[4U] ;
   u32 wlan_cal_seq ;
   u32 wlan_cal_done ;
   u32 config ;
   u8 *gpm_buf ;
   bool ready ;
   bool update_2g5g ;
   bool is_2g ;
   bool query_bt ;
   bool unhalt_bt_gpm ;
   bool halted_bt_gpm ;
   bool need_flush_btinfo ;
   bool bt_version_known ;
   bool wlan_channels_update ;
   u8 wlan_ver_major ;
   u8 wlan_ver_minor ;
   u8 bt_ver_major ;
   u8 bt_ver_minor ;
   u8 bt_state ;
   u8 stomp_ftp ;
   bool concur_tx ;
   u32 last_recovery ;
};

#line 98  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/btcoex.h"
struct ath9k_hw_aic {
   bool aic_enabled ;
   u8 aic_cal_state ;
   u8 aic_caled_chan ;
   u32 aic_sram[79U] ;
   u32 aic_cal_start_time ;
};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/btcoex.h"
struct ath_btcoex_hw {
   enum ath_btcoex_scheme scheme ;
   struct ath9k_hw_mci mci ;
   struct ath9k_hw_aic aic ;
   bool enabled ;
   u8 wlanactive_gpio ;
   u8 btactive_gpio ;
   u8 btpriority_gpio ;
   u32 bt_coex_mode ;
   u32 bt_coex_weights ;
   u32 bt_coex_mode2 ;
   u32 bt_weight[4U] ;
   u32 wlan_weight[4U] ;
   u8 tx_prio[5U] ;
};

#line 136 
struct ath_node;

#line 137  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/btcoex.h"
struct ath_dyn_rxbuf {
   u16 h_rb ;
   u16 t_rb ;
   u32 tstamp[64U] ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/dynack.h"
struct ts_info {
   u32 tstamp ;
   u32 dur ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/dynack.h"
struct haddr_pair {
   u8 h_dest[6U] ;
   u8 h_src[6U] ;
};

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/dynack.h"
struct ath_dyn_txbuf {
   u16 h_rb ;
   u16 t_rb ;
   struct haddr_pair addr[64U] ;
   struct ts_info ts[64U] ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/dynack.h"
struct ath_dynack {
   bool enabled ;
   int ackto ;
   unsigned long lto ;
   struct list_head nodes ;
   spinlock_t qlock ;
   struct ath_dyn_rxbuf ack_rbf ;
   struct ath_dyn_txbuf st_rbf ;
};

#line 296  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/regd.h"
struct ath9k_hw_wow {
   u32 wow_event_mask ;
   u32 wow_event_mask2 ;
   u8 max_patterns ;
};

#line 294  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
struct ath9k_hw_capabilities {
   u32 hw_caps ;
   u16 rts_aggr_limit ;
   u8 tx_chainmask ;
   u8 rx_chainmask ;
   u8 chip_chainmask ;
   u8 max_txchains ;
   u8 max_rxchains ;
   u8 num_gpio_pins ;
   u8 rx_hp_qdepth ;
   u8 rx_lp_qdepth ;
   u8 rx_status_len ;
   u8 tx_desc_len ;
   u8 txs_len ;
};

#line 319  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
struct ath9k_ops_config {
   int dma_beacon_response_time ;
   int sw_beacon_response_time ;
   u32 cwm_ignore_extcca ;
   u32 pcie_waen ;
   u8 analog_shiftreg ;
   u32 ofdm_trig_low ;
   u32 ofdm_trig_high ;
   u32 cck_trig_high ;
   u32 cck_trig_low ;
   u32 enable_paprd ;
   int serialize_regmode ;
   bool rx_intr_mitigation ;
   bool tx_intr_mitigation ;
   u8 max_txtrig_level ;
   u16 ani_poll_interval ;
   u16 hw_hang_checks ;
   u16 rimt_first ;
   u16 rimt_last ;
   u32 aspm_l1_fix ;
   u32 xlna_gpio ;
   u32 ant_ctrl_comm2g_switch_enable ;
   bool xatten_margin_cfg ;
   bool alt_mingainidx ;
   u8 pll_pwrsave ;
   bool tx_gain_buffalo ;
   bool led_active_high ;
};

#line 362 
enum ath9k_int {
    ATH9K_INT_RX = 1,
    ATH9K_INT_RXDESC = 2,
    ATH9K_INT_RXHP = 1,
    ATH9K_INT_RXLP = 2,
    ATH9K_INT_RXNOFRM = 8,
    ATH9K_INT_RXEOL = 16,
    ATH9K_INT_RXORN = 32,
    ATH9K_INT_TX = 64,
    ATH9K_INT_TXDESC = 128,
    ATH9K_INT_TIM_TIMER = 256,
    ATH9K_INT_MCI = 512,
    ATH9K_INT_BB_WATCHDOG = 1024,
    ATH9K_INT_TXURN = 2048,
    ATH9K_INT_MIB = 4096,
    ATH9K_INT_RXPHY = 16384,
    ATH9K_INT_RXKCM = 32768,
    ATH9K_INT_SWBA = 65536,
    ATH9K_INT_BMISS = 262144,
    ATH9K_INT_BNR = 1048576,
    ATH9K_INT_TIM = 2097152,
    ATH9K_INT_DTIM = 4194304,
    ATH9K_INT_DTIMSYNC = 8388608,
    ATH9K_INT_GPIO = 16777216,
    ATH9K_INT_CABEND = 33554432,
    ATH9K_INT_TSFOOR = 67108864,
    ATH9K_INT_GENTIMER = 134217728,
    ATH9K_INT_CST = 268435456,
    ATH9K_INT_GTT = 536870912,
    ATH9K_INT_FATAL = 1073741824,
    ATH9K_INT_GLOBAL = 2147483648,
    ATH9K_INT_BMISC = 115343360,
    ATH9K_INT_COMMON = 17160378,
    ATH9K_INT_NOCARD = 4294967295
};

#line 409  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
struct ath9k_hw_cal_data {
   u16 channel ;
   u16 channelFlags ;
   unsigned long cal_flags ;
   int32_t CalValid ;
   int8_t iCoff ;
   int8_t qCoff ;
   u8 caldac[2U] ;
   u16 small_signal_gain[3U] ;
   u32 pa_table[3U][24U] ;
   u32 num_measures[3U] ;
   int tx_corr_coeff[8U][3U] ;
   u32 tx_clcal[3U][16U] ;
   u32 rtt_table[3U][6U] ;
   struct ath9k_nfcal_hist nfCalHist[6U] ;
};

#line 446  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
struct ath9k_channel {
   struct ieee80211_channel *chan ;
   u16 channel ;
   u16 channelFlags ;
   s16 noisefloor ;
};

#line 453 
enum ath9k_power_mode {
    ATH9K_PM_AWAKE = 0,
    ATH9K_PM_FULL_SLEEP = 1,
    ATH9K_PM_NETWORK_SLEEP = 2,
    ATH9K_PM_UNDEFINED = 3
};

#line 472  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
struct ath9k_beacon_state {
   u32 bs_nexttbtt ;
   u32 bs_nextdtim ;
   u32 bs_intval ;
   u32 bs_dtimperiod ;
   u16 bs_bmissthreshold ;
   u32 bs_sleepduration ;
   u32 bs_tsfoor_threshold ;
};

#line 520  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
struct ath9k_hw_version {
   u32 magic ;
   u16 devid ;
   u16 subvendorid ;
   u32 macVersion ;
   u16 macRev ;
   u16 phyRev ;
   u16 analog5GhzRev ;
   u16 analog2GhzRev ;
   enum ath_usb_dev usbdev ;
};

#line 545  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
struct ath_gen_timer {
   void (*trigger)(void *) ;
   void (*overflow)(void *) ;
   void *arg ;
   u8 index ;
};

#line 552  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
struct ath_gen_timer_table {
   struct ath_gen_timer *timers[16U] ;
   u16 timer_mask ;
   bool tsf2_enabled ;
};

#line 558  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
struct ath_hw_antcomb_conf {
   u8 main_lna_conf ;
   u8 alt_lna_conf ;
   u8 fast_div_bias ;
   u8 main_gaintb ;
   u8 alt_gaintb ;
   int lna1_lna2_delta ;
   int lna1_lna2_switch_delta ;
   u8 div_group ;
};

#line 569  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
struct ath_hw_radar_conf {
   unsigned int pulse_inband ;
   unsigned int pulse_inband_step ;
   unsigned int pulse_height ;
   unsigned int pulse_rssi ;
   unsigned int pulse_maxlen ;
   unsigned int radar_rssi ;
   unsigned int radar_inband ;
   int fir_power ;
   bool ext_channel ;
};

#line 603  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
struct ath_hw_private_ops {
   void (*init_hang_checks)(struct ath_hw *) ;
   bool (*detect_mac_hang)(struct ath_hw *) ;
   bool (*detect_bb_hang)(struct ath_hw *) ;
   void (*init_cal_settings)(struct ath_hw *) ;
   bool (*init_cal)(struct ath_hw *, struct ath9k_channel *) ;
   void (*init_mode_gain_regs)(struct ath_hw *) ;
   void (*setup_calibration)(struct ath_hw *, struct ath9k_cal_list *) ;
   int (*rf_set_freq)(struct ath_hw *, struct ath9k_channel *) ;
   void (*spur_mitigate_freq)(struct ath_hw *, struct ath9k_channel *) ;
   bool (*set_rf_regs)(struct ath_hw *, struct ath9k_channel *, u16 ) ;
   void (*set_channel_regs)(struct ath_hw *, struct ath9k_channel *) ;
   void (*init_bb)(struct ath_hw *, struct ath9k_channel *) ;
   int (*process_ini)(struct ath_hw *, struct ath9k_channel *) ;
   void (*olc_init)(struct ath_hw *) ;
   void (*set_rfmode)(struct ath_hw *, struct ath9k_channel *) ;
   void (*mark_phy_inactive)(struct ath_hw *) ;
   void (*set_delta_slope)(struct ath_hw *, struct ath9k_channel *) ;
   bool (*rfbus_req)(struct ath_hw *) ;
   void (*rfbus_done)(struct ath_hw *) ;
   void (*restore_chainmask)(struct ath_hw *) ;
   u32 (*compute_pll_control)(struct ath_hw *, struct ath9k_channel *) ;
   bool (*ani_control)(struct ath_hw *, enum ath9k_ani_cmd , int ) ;
   void (*do_getnf)(struct ath_hw *, int16_t *) ;
   void (*set_radar_params)(struct ath_hw *, struct ath_hw_radar_conf *) ;
   int (*fast_chan_change)(struct ath_hw *, struct ath9k_channel *, u8 *) ;
   void (*ani_cache_ini_regs)(struct ath_hw *) ;
   bool (*is_aic_enabled)(struct ath_hw *) ;
};

#line 674  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
struct ath_spec_scan {
   bool enabled ;
   bool short_repeat ;
   bool endless ;
   u8 count ;
   u8 period ;
   u8 fft_period ;
};

#line 706  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
struct ath_hw_ops {
   void (*config_pci_powersave)(struct ath_hw *, bool ) ;
   void (*rx_enable)(struct ath_hw *) ;
   void (*set_desc_link)(void *, u32 ) ;
   int (*calibrate)(struct ath_hw *, struct ath9k_channel *, u8 , bool ) ;
   bool (*get_isr)(struct ath_hw *, enum ath9k_int *, u32 *) ;
   void (*set_txdesc)(struct ath_hw *, void *, struct ath_tx_info *) ;
   int (*proc_txdesc)(struct ath_hw *, void *, struct ath_tx_status *) ;
   int (*get_duration)(struct ath_hw *, void const *, int ) ;
   void (*antdiv_comb_conf_get)(struct ath_hw *, struct ath_hw_antcomb_conf *) ;
   void (*antdiv_comb_conf_set)(struct ath_hw *, struct ath_hw_antcomb_conf *) ;
   void (*spectral_scan_config)(struct ath_hw *, struct ath_spec_scan *) ;
   void (*spectral_scan_trigger)(struct ath_hw *) ;
   void (*spectral_scan_wait)(struct ath_hw *) ;
   void (*tx99_start)(struct ath_hw *, u32 ) ;
   void (*tx99_stop)(struct ath_hw *) ;
   void (*tx99_set_txpower)(struct ath_hw *, u8 ) ;
   void (*set_bt_ant_diversity)(struct ath_hw *, bool ) ;
};

#line 750  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
struct ath_nf_limits {
   s16 max ;
   s16 min ;
   s16 nominal ;
};

#line 763  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
union __anonunion_eeprom_376 {
   struct ar5416_eeprom_def def ;
   struct ar5416_eeprom_4k map4k ;
   struct ar9287_eeprom map9287 ;
   struct ar9300_eeprom ar9300_eep ;
};

#line 763  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
union __anonunion_meas0_377 {
   u32 unsign[3U] ;
   int32_t sign[3U] ;
};

#line 763  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
union __anonunion_meas1_378 {
   u32 unsign[3U] ;
   int32_t sign[3U] ;
};

#line 763  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
union __anonunion_meas2_379 {
   u32 unsign[3U] ;
   int32_t sign[3U] ;
};

#line 763  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
union __anonunion_meas3_380 {
   u32 unsign[3U] ;
   int32_t sign[3U] ;
};

#line 763  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
struct ath_hw {
   struct ath_ops reg_ops ;
   struct device *dev ;
   struct ieee80211_hw *hw ;
   struct ath_common common ;
   struct ath9k_hw_version hw_version ;
   struct ath9k_ops_config config ;
   struct ath9k_hw_capabilities caps ;
   struct ath9k_channel channels[38U] ;
   struct ath9k_channel *curchan ;
   union __anonunion_eeprom_376 eeprom ;
   struct eeprom_ops const *eep_ops ;
   bool sw_mgmt_crypto_tx ;
   bool sw_mgmt_crypto_rx ;
   bool is_pciexpress ;
   bool aspm_enabled ;
   bool is_monitoring ;
   bool need_an_top2_fixup ;
   u16 tx_trig_level ;
   u32 nf_regs[6U] ;
   struct ath_nf_limits nf_2g ;
   struct ath_nf_limits nf_5g ;
   u16 rfsilent ;
   u32 rfkill_gpio ;
   u32 rfkill_polarity ;
   u32 ah_flags ;
   bool reset_power_on ;
   bool htc_reset_init ;
   enum nl80211_iftype opmode ;
   enum ath9k_power_mode power_mode ;
   s8 noise ;
   struct ath9k_hw_cal_data *caldata ;
   struct ath9k_pacal_info pacal_info ;
   struct ar5416Stats stats ;
   struct ath9k_tx_queue_info txq[10U] ;
   enum ath9k_int imask ;
   u32 imrs2_reg ;
   u32 txok_interrupt_mask ;
   u32 txerr_interrupt_mask ;
   u32 txdesc_interrupt_mask ;
   u32 txeol_interrupt_mask ;
   u32 txurn_interrupt_mask ;
   atomic_t intr_ref_cnt ;
   bool chip_fullsleep ;
   u32 modes_index ;
   u32 supp_cals ;
   struct ath9k_cal_list iq_caldata ;
   struct ath9k_cal_list adcgain_caldata ;
   struct ath9k_cal_list adcdc_caldata ;
   struct ath9k_cal_list *cal_list ;
   struct ath9k_cal_list *cal_list_last ;
   struct ath9k_cal_list *cal_list_curr ;
   union __anonunion_meas0_377 meas0 ;
   union __anonunion_meas1_378 meas1 ;
   union __anonunion_meas2_379 meas2 ;
   union __anonunion_meas3_380 meas3 ;
   u16 cal_samples ;
   u8 enabled_cals ;
   u32 sta_id1_defaults ;
   u32 misc_mode ;
   struct ath_hw_private_ops private_ops ;
   struct ath_hw_ops ops ;
   u32 *analogBank6Data ;
   int coverage_class ;
   u32 slottime ;
   u32 globaltxtimeout ;
   u32 aniperiod ;
   enum ath9k_ani_cmd ani_function ;
   u32 ani_skip_count ;
   struct ar5416AniState ani ;
   struct ath_btcoex_hw btcoex_hw ;
   u32 intr_txqs ;
   u8 txchainmask ;
   u8 rxchainmask ;
   struct ath_hw_radar_conf radar_conf ;
   u32 originalGain[22U] ;
   int initPDADC ;
   int PDADCdelta ;
   int led_pin ;
   u32 gpio_mask ;
   u32 gpio_val ;
   struct ar5416IniArray ini_dfs ;
   struct ar5416IniArray iniModes ;
   struct ar5416IniArray iniCommon ;
   struct ar5416IniArray iniBB_RfGain ;
   struct ar5416IniArray iniBank6 ;
   struct ar5416IniArray iniAddac ;
   struct ar5416IniArray iniPcieSerdes ;
   struct ar5416IniArray iniPcieSerdesLowPower ;
   struct ar5416IniArray iniModesFastClock ;
   struct ar5416IniArray iniAdditional ;
   struct ar5416IniArray iniModesRxGain ;
   struct ar5416IniArray ini_modes_rx_gain_bounds ;
   struct ar5416IniArray iniModesTxGain ;
   struct ar5416IniArray iniCckfirNormal ;
   struct ar5416IniArray iniCckfirJapan2484 ;
   struct ar5416IniArray iniModes_9271_ANI_reg ;
   struct ar5416IniArray ini_radio_post_sys2ant ;
   struct ar5416IniArray ini_modes_rxgain_5g_xlna ;
   struct ar5416IniArray ini_modes_rxgain_bb_core ;
   struct ar5416IniArray ini_modes_rxgain_bb_postamble ;
   struct ar5416IniArray iniMac[3U] ;
   struct ar5416IniArray iniBB[3U] ;
   struct ar5416IniArray iniRadio[3U] ;
   struct ar5416IniArray iniSOC[3U] ;
   u32 intr_gen_timer_trigger ;
   u32 intr_gen_timer_thresh ;
   struct ath_gen_timer_table hw_gen_timers ;
   struct ar9003_txs *ts_ring ;
   u32 ts_paddr_start ;
   u32 ts_paddr_end ;
   u16 ts_tail ;
   u16 ts_size ;
   u32 bb_watchdog_last_status ;
   u32 bb_watchdog_timeout_ms ;
   u8 bb_hang_rx_ofdm ;
   unsigned int paprd_target_power ;
   unsigned int paprd_training_power ;
   unsigned int paprd_ratemask ;
   unsigned int paprd_ratemask_ht40 ;
   bool paprd_table_write_done ;
   u32 paprd_gain_table_entries[32U] ;
   u8 paprd_gain_table_index[32U] ;
   u32 WARegVal ;
   u32 ent_mode ;
   struct ath9k_hw_wow wow ;
   bool is_clk_25mhz ;
   int (*get_mac_revision)(void) ;
   int (*external_reset)(void) ;
   bool disable_2ghz ;
   bool disable_5ghz ;
   struct firmware const *eeprom_blob ;
   struct ath_dynack dynack ;
   bool tpc_enabled ;
   u8 tx_power[36U] ;
   u8 tx_power_stbc[36U] ;
};

#line 979  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
struct ath_bus_ops {
   enum ath_bus_type ath_bus_type ;
   void (*read_cachesize)(struct ath_common *, int *) ;
   bool (*eeprom_read)(struct ath_common *, u32 , u16 *) ;
   void (*bt_coex_prep)(struct ath_common *) ;
   void (*aspm_init)(struct ath_common *) ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/common-init.h"
struct ath_beacon_config;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/common-beacon.h"
struct ath_rx_stats {
   u32 rx_pkts_all ;
   u32 rx_bytes_all ;
   u32 crc_err ;
   u32 decrypt_crc_err ;
   u32 phy_err ;
   u32 mic_err ;
   u32 pre_delim_crc_err ;
   u32 post_delim_crc_err ;
   u32 decrypt_busy_err ;
   u32 phy_err_stats[39U] ;
   u32 rx_len_err ;
   u32 rx_oom_err ;
   u32 rx_rate_err ;
   u32 rx_too_many_frags_err ;
   u32 rx_beacons ;
   u32 rx_frags ;
   u32 rx_spectral ;
};

#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/spectral_common.h"
enum spectral_mode {
    SPECTRAL_DISABLED = 0,
    SPECTRAL_BACKGROUND = 1,
    SPECTRAL_MANUAL = 2,
    SPECTRAL_CHANSCAN = 3
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/common-spectral.h"
struct ath_spec_scan_priv {
   struct ath_hw *ah ;
   struct rchan *rfs_chan_spec_scan ;
   enum spectral_mode spectral_mode ;
   struct ath_spec_scan spec_config ;
};

#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/common-spectral.h"
struct ath_beacon_config {
   int beacon_interval ;
   u16 dtim_period ;
   u16 bmiss_timeout ;
   u8 dtim_count ;
   u8 enable_beacon ;
   bool ibss_creator ;
   u32 nexttbtt ;
   u32 intval ;
};

#line 92  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/common.h"
struct ath_softc;

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/common.h"
struct ath_dfs_stats {
   u32 pulses_total ;
   u32 pulses_no_dfs ;
   u32 pulses_detected ;
   u32 datalen_discards ;
   u32 rssi_discards ;
   u32 bwinfo_discards ;
   u32 pri_phy_errors ;
   u32 ext_phy_errors ;
   u32 dc_phy_errors ;
   u32 pulses_processed ;
   u32 radar_detected ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/dfs_debug.h"
struct ath_dfs_pool_stats;

#line 62 
struct ath_txq;

#line 63 
struct ath_buf;

#line 64 
enum ath_reset_type {
    RESET_TYPE_BB_HANG = 0,
    RESET_TYPE_BB_WATCHDOG = 1,
    RESET_TYPE_FATAL_INT = 2,
    RESET_TYPE_TX_ERROR = 3,
    RESET_TYPE_TX_GTT = 4,
    RESET_TYPE_TX_HANG = 5,
    RESET_TYPE_PLL_HANG = 6,
    RESET_TYPE_MAC_HANG = 7,
    RESET_TYPE_BEACON_STUCK = 8,
    RESET_TYPE_MCI = 9,
    RESET_TYPE_CALIBRATION = 10,
    __RESET_TYPE_MAX = 11
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/dfs_debug.h"
struct ath_interrupt_stats {
   u32 total ;
   u32 rxok ;
   u32 rxlp ;
   u32 rxhp ;
   u32 rxeol ;
   u32 rxorn ;
   u32 txok ;
   u32 txeol ;
   u32 txurn ;
   u32 mib ;
   u32 rxphyerr ;
   u32 rx_keycache_miss ;
   u32 swba ;
   u32 bmiss ;
   u32 bnr ;
   u32 cst ;
   u32 gtt ;
   u32 tim ;
   u32 cabend ;
   u32 dtimsync ;
   u32 dtim ;
   u32 bb_watchdog ;
   u32 tsfoor ;
   u32 mci ;
   u32 gen_timer ;
   u32 sync_cause_all ;
   u32 sync_rtc_irq ;
   u32 sync_mac_irq ;
   u32 eeprom_illegal_access ;
   u32 apb_timeout ;
   u32 pci_mode_conflict ;
   u32 host1_fatal ;
   u32 host1_perr ;
   u32 trcv_fifo_perr ;
   u32 radm_cpl_ep ;
   u32 radm_cpl_dllp_abort ;
   u32 radm_cpl_tlp_abort ;
   u32 radm_cpl_ecrc_err ;
   u32 radm_cpl_timeout ;
   u32 local_timeout ;
   u32 pm_access ;
   u32 mac_awake ;
   u32 mac_asleep ;
   u32 mac_sleep_access ;
};

#line 136  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.h"
struct ath_tx_stats {
   u32 tx_pkts_all ;
   u32 tx_bytes_all ;
   u32 queued ;
   u32 completed ;
   u32 xretries ;
   u32 a_aggr ;
   u32 a_queued_hw ;
   u32 a_queued_sw ;
   u32 a_completed ;
   u32 a_retries ;
   u32 a_xretries ;
   u32 txerr_filtered ;
   u32 fifo_underrun ;
   u32 xtxop ;
   u32 timer_exp ;
   u32 desc_cfg_err ;
   u32 data_underrun ;
   u32 delim_underrun ;
   u32 puttxbuf ;
   u32 txstart ;
   u32 txprocdesc ;
   u32 txfailed ;
};

#line 191  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.h"
struct __anonstruct_ht_stats_381 {
   u32 ht20_cnt ;
   u32 ht40_cnt ;
   u32 sgi_cnt ;
   u32 lgi_cnt ;
};

#line 191  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.h"
struct __anonstruct_ofdm_stats_382 {
   u32 ofdm_cnt ;
};

#line 191  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.h"
struct __anonstruct_cck_stats_383 {
   u32 cck_lp_cnt ;
   u32 cck_sp_cnt ;
};

#line 191  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.h"
struct ath_rx_rate_stats {
   struct __anonstruct_ht_stats_381 ht_stats[24U] ;
   struct __anonstruct_ofdm_stats_382 ofdm_stats[8U] ;
   struct __anonstruct_cck_stats_383 cck_stats[4U] ;
};

#line 223  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.h"
struct ath_antenna_stats {
   u32 recv_cnt ;
   u32 rssi_avg ;
   u32 lna_recv_cnt[4U] ;
   u32 lna_attempt_cnt[4U] ;
};

#line 233  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.h"
struct ath_stats {
   struct ath_interrupt_stats istats ;
   struct ath_tx_stats txstats[10U] ;
   struct ath_rx_stats rxstats ;
   struct ath_dfs_stats dfs_stats ;
   struct ath_antenna_stats ant_stats[2U] ;
   u32 reset[11U] ;
};

#line 242  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.h"
struct ath9k_debug {
   struct dentry *debugfs_phy ;
   u32 regidx ;
   struct ath_stats stats ;
};

#line 127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mci.h"
struct ath_mci_profile {
   struct list_head info ;
   unsigned long status[1U] ;
   u16 aggr_limit ;
   u8 num_mgmt ;
   u8 num_sco ;
   u8 num_a2dp ;
   u8 num_hid ;
   u8 num_pan ;
   u8 num_other_acl ;
   u8 num_bdr ;
   u8 voice_priority ;
};

#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mci.h"
struct ath_mci_buf {
   void *bf_addr ;
   dma_addr_t bf_paddr ;
   u32 bf_len ;
};

#line 147  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mci.h"
struct ath_mci_coex {
   struct ath_mci_buf sched_buf ;
   struct ath_mci_buf gpm_buf ;
};

#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mci.h"
struct ath_dfs_pool_stats {
   u32 pool_reference ;
   u32 pulse_allocated ;
   u32 pulse_alloc_error ;
   u32 pulse_used ;
   u32 pseq_allocated ;
   u32 pseq_alloc_error ;
   u32 pseq_used ;
};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/dfs_pattern_detector.h"
struct pulse_event {
   u64 ts ;
   u16 freq ;
   u8 width ;
   u8 rssi ;
   bool chirp ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/dfs_pattern_detector.h"
struct radar_detector_specs {
   u8 type_id ;
   u8 width_min ;
   u8 width_max ;
   u16 pri_min ;
   u16 pri_max ;
   u8 num_pri ;
   u8 ppb ;
   u8 ppb_thresh ;
   u8 max_pri_tolerance ;
   bool chirp ;
};

#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/dfs_pattern_detector.h"
struct dfs_pattern_detector {
   void (*exit)(struct dfs_pattern_detector *) ;
   bool (*set_dfs_domain)(struct dfs_pattern_detector *, enum nl80211_dfs_regions ) ;
   bool (*add_pulse)(struct dfs_pattern_detector *, struct pulse_event *) ;
   struct ath_dfs_pool_stats (*get_stats)(struct dfs_pattern_detector *) ;
   enum nl80211_dfs_regions region ;
   u8 num_radar_types ;
   u64 last_pulse_ts ;
   struct ath_common *common ;
   struct radar_detector_specs const *radar_spec ;
   struct list_head channel_detectors ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/dfs.h"
struct ath_vif;

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
struct ath_descdma {
   void *dd_desc ;
   dma_addr_t dd_desc_paddr ;
   u32 dd_desc_len ;
};

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
struct ath_txq {
   int mac80211_qnum ;
   u32 axq_qnum ;
   void *axq_link ;
   struct list_head axq_q ;
   spinlock_t axq_lock ;
   u32 axq_depth ;
   u32 axq_ampdu_depth ;
   bool stopped ;
   bool axq_tx_inprogress ;
   struct list_head txq_fifo[8U] ;
   u8 txq_headidx ;
   u8 txq_tailidx ;
   int pending_frames ;
   struct sk_buff_head complete_q ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
struct ath_atx_ac {
   struct ath_txq *txq ;
   struct list_head list ;
   struct list_head tid_q ;
   bool clear_ps_filter ;
   bool sched ;
};

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
struct ath_rxbuf {
   struct list_head list ;
   struct sk_buff *bf_mpdu ;
   void *bf_desc ;
   dma_addr_t bf_daddr ;
   dma_addr_t bf_buf_addr ;
};

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
struct ath_buf_state {
   u8 bf_type ;
   u8 bfs_paprd ;
   u8 ndelim ;
   bool stale ;
   u16 seqno ;
   unsigned long bfs_paprd_timestamp ;
};

#line 226  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
struct ath_buf {
   struct list_head list ;
   struct ath_buf *bf_lastbf ;
   struct ath_buf *bf_next ;
   struct sk_buff *bf_mpdu ;
   void *bf_desc ;
   dma_addr_t bf_daddr ;
   dma_addr_t bf_buf_addr ;
   struct ieee80211_tx_rate rates[4U] ;
   struct ath_buf_state bf_state ;
};

#line 239  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
struct ath_atx_tid {
   struct list_head list ;
   struct sk_buff_head buf_q ;
   struct sk_buff_head retry_q ;
   struct ath_node *an ;
   struct ath_atx_ac *ac ;
   unsigned long tx_buf[2U] ;
   u16 seq_start ;
   u16 seq_next ;
   u16 baw_size ;
   u8 tidno ;
   int baw_head ;
   int baw_tail ;
   s8 bar_index ;
   bool sched ;
   bool active ;
};

#line 258  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
struct ath_node {
   struct ath_softc *sc ;
   struct ieee80211_sta *sta ;
   struct ieee80211_vif *vif ;
   struct ath_atx_tid tid[16U] ;
   struct ath_atx_ac ac[4U] ;
   u16 maxampdu ;
   u8 mpdudensity ;
   s8 ps_key ;
   bool sleeping ;
   bool no_ps_filter ;
   struct ath_rx_rate_stats rx_rate_stats ;
   u8 key_idx[4U] ;
   u32 ackto ;
   struct list_head list ;
};

#line 289  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
struct ath_tx {
   u32 txqsetup ;
   spinlock_t txbuflock ;
   struct list_head txbuf ;
   struct ath_txq txq[10U] ;
   struct ath_descdma txdma ;
   struct ath_txq *txq_map[4U] ;
   struct ath_txq *uapsdq ;
   u32 txq_max_pending[4U] ;
   u16 max_aggr_framelen[4U][4U][32U] ;
};

#line 307  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
struct ath_rx_edma {
   struct sk_buff_head rx_fifo ;
   u32 rx_fifo_hwsize ;
};

#line 312  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
struct ath_rx {
   u8 defant ;
   u8 rxotherant ;
   bool discard_next ;
   u32 *rxlink ;
   u32 num_pkts ;
   struct list_head rxbuf ;
   struct ath_descdma rxdma ;
   struct ath_rx_edma rx_edma[2U] ;
   struct ath_rxbuf *buf_hold ;
   struct sk_buff *frag ;
   u32 ampdu_ref ;
};

#line 328  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
struct ath_chanctx {
   struct cfg80211_chan_def chandef ;
   struct list_head vifs ;
   struct list_head acq[4U] ;
   int hw_queue_base ;
   struct ieee80211_vif *primary_sta ;
   struct ath_beacon_config beacon ;
   struct ath9k_hw_cal_data caldata ;
   struct timespec tsf_ts ;
   u64 tsf_val ;
   u32 last_beacon ;
   int flush_timeout ;
   u16 txpower ;
   u16 cur_txpower ;
   bool offchannel ;
   bool stopped ;
   bool active ;
   bool assigned ;
   bool switch_after_beacon ;
   short nvifs ;
   short nvifs_assigned ;
   unsigned int rxfilter ;
};

#line 361 
enum ath_chanctx_event {
    ATH_CHANCTX_EVENT_BEACON_PREPARE = 0,
    ATH_CHANCTX_EVENT_BEACON_SENT = 1,
    ATH_CHANCTX_EVENT_TSF_TIMER = 2,
    ATH_CHANCTX_EVENT_BEACON_RECEIVED = 3,
    ATH_CHANCTX_EVENT_AUTHORIZED = 4,
    ATH_CHANCTX_EVENT_SWITCH = 5,
    ATH_CHANCTX_EVENT_ASSIGN = 6,
    ATH_CHANCTX_EVENT_UNASSIGN = 7,
    ATH_CHANCTX_EVENT_CHANGE = 8,
    ATH_CHANCTX_EVENT_ENABLE_MULTICHANNEL = 9
};

#line 374 
enum ath_chanctx_state {
    ATH_CHANCTX_STATE_IDLE = 0,
    ATH_CHANCTX_STATE_WAIT_FOR_BEACON = 1,
    ATH_CHANCTX_STATE_WAIT_FOR_TIMER = 2,
    ATH_CHANCTX_STATE_SWITCH = 3,
    ATH_CHANCTX_STATE_FORCE_ACTIVE = 4
};

#line 382  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
struct ath_chanctx_sched {
   bool beacon_pending ;
   bool beacon_adjust ;
   bool offchannel_pending ;
   bool wait_switch ;
   bool force_noa_update ;
   bool extend_absence ;
   bool mgd_prepare_tx ;
   enum ath_chanctx_state state ;
   u8 beacon_miss ;
   u32 next_tbtt ;
   u32 switch_start_time ;
   unsigned int offchannel_duration ;
   unsigned int channel_switch_time ;
   struct timer_list timer ;
};

#line 402 
enum ath_offchannel_state {
    ATH_OFFCHANNEL_IDLE = 0,
    ATH_OFFCHANNEL_PROBE_SEND = 1,
    ATH_OFFCHANNEL_PROBE_WAIT = 2,
    ATH_OFFCHANNEL_SUSPEND = 3,
    ATH_OFFCHANNEL_ROC_START = 4,
    ATH_OFFCHANNEL_ROC_WAIT = 5,
    ATH_OFFCHANNEL_ROC_DONE = 6
};

#line 412  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
struct ath_offchannel {
   struct ath_chanctx chan ;
   struct timer_list timer ;
   struct cfg80211_scan_request *scan_req ;
   struct ieee80211_vif *scan_vif ;
   int scan_idx ;
   enum ath_offchannel_state state ;
   struct ieee80211_channel *roc_chan ;
   struct ieee80211_vif *roc_vif ;
   int roc_duration ;
   int duration ;
};

#line 585  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
struct ath_vif {
   struct list_head list ;
   u16 seq_no ;
   u8 bssid[6U] ;
   u16 aid ;
   bool assoc ;
   struct ieee80211_vif *vif ;
   struct ath_node mcast_node ;
   int av_bslot ;
   __le64 tsf_adjust ;
   struct ath_buf *av_bcbuf ;
   struct ath_chanctx *chanctx ;
   struct ieee80211_noa_data noa ;
   u8 noa_index ;
   u32 offchannel_start ;
   u32 offchannel_duration ;
   u32 noa_start ;
   u32 noa_duration ;
   bool periodic_noa ;
   bool oneshot_noa ;
};

#line 649 
enum ldv_35186 {
    OK = 0,
    UPDATE = 1,
    COMMIT = 2
};

#line 655  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
struct ath_beacon {
   enum ldv_35186 updateslot ;
   u32 beaconq ;
   u32 bmisscnt ;
   struct ieee80211_vif *bslot[8U] ;
   int slottime ;
   int slotupdate ;
   struct ath_descdma bdma ;
   struct ath_txq *cabq ;
   struct list_head bbuf ;
   bool tx_processed ;
   bool tx_last ;
};

#line 730  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
struct ath_btcoex {
   spinlock_t btcoex_lock ;
   struct timer_list period_timer ;
   struct timer_list no_stomp_timer ;
   u32 bt_priority_cnt ;
   unsigned long bt_priority_time ;
   unsigned long op_flags ;
   int bt_stomp_type ;
   u32 btcoex_no_stomp ;
   u32 btcoex_period ;
   u32 btscan_no_stomp ;
   u32 duty_cycle ;
   u32 bt_wait_time ;
   int rssi_count ;
   struct ath_mci_profile mci ;
   u8 stomp_audio ;
};

#line 841  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
struct ath_ant_comb {
   u16 count ;
   u16 total_pkt_count ;
   bool scan ;
   bool scan_not_start ;
   int main_total_rssi ;
   int alt_total_rssi ;
   int alt_recv_cnt ;
   int main_recv_cnt ;
   int rssi_lna1 ;
   int rssi_lna2 ;
   int rssi_add ;
   int rssi_sub ;
   int rssi_first ;
   int rssi_second ;
   int rssi_third ;
   int ant_ratio ;
   int ant_ratio2 ;
   bool alt_good ;
   int quick_scan_cnt ;
   enum ath9k_ant_div_comb_lna_conf main_conf ;
   enum ath9k_ant_div_comb_lna_conf first_quick_scan_conf ;
   enum ath9k_ant_div_comb_lna_conf second_quick_scan_conf ;
   bool first_ratio ;
   bool second_ratio ;
   unsigned long scan_start_time ;
   int low_rssi_thresh ;
   int fast_div_bias ;
};

#line 919  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
struct ath_softc {
   struct ieee80211_hw *hw ;
   struct device *dev ;
   struct survey_info *cur_survey ;
   struct survey_info survey[38U] ;
   struct tasklet_struct intr_tq ;
   struct tasklet_struct bcon_tasklet ;
   struct ath_hw *sc_ah ;
   void *mem ;
   int irq ;
   spinlock_t sc_serial_rw ;
   spinlock_t sc_pm_lock ;
   spinlock_t sc_pcu_lock ;
   struct mutex mutex ;
   struct work_struct paprd_work ;
   struct work_struct hw_reset_work ;
   struct completion paprd_complete ;
   wait_queue_head_t tx_wait ;
   struct work_struct chanctx_work ;
   struct ath_gen_timer *p2p_ps_timer ;
   struct ath_vif *p2p_ps_vif ;
   struct ath_chanctx_sched sched ;
   struct ath_offchannel offchannel ;
   struct ath_chanctx *next_chan ;
   struct completion go_beacon ;
   unsigned long driver_data ;
   u8 gtt_cnt ;
   u32 intrstatus ;
   u16 ps_flags ;
   bool ps_enabled ;
   bool ps_idle ;
   short nbcnvifs ;
   unsigned long ps_usecount ;
   struct ath_rx rx ;
   struct ath_tx tx ;
   struct ath_beacon beacon ;
   struct cfg80211_chan_def cur_chandef ;
   struct ath_chanctx chanctx[2U] ;
   struct ath_chanctx *cur_chan ;
   spinlock_t chan_lock ;
   bool led_registered ;
   char led_name[32U] ;
   struct led_classdev led_cdev ;
   struct ath9k_debug debug ;
   struct delayed_work tx_complete_work ;
   struct delayed_work hw_pll_work ;
   struct timer_list sleep_timer ;
   struct ath_btcoex btcoex ;
   struct ath_mci_coex mci_coex ;
   struct work_struct mci_work ;
   struct ath_descdma txsdma ;
   struct ath_ant_comb ant_comb ;
   u8 ant_tx ;
   u8 ant_rx ;
   struct dfs_pattern_detector *dfs_detector ;
   u64 dfs_prev_pulse_ts ;
   u32 wow_enabled ;
   struct ath_spec_scan_priv spec_priv ;
   struct ieee80211_vif *tx99_vif ;
   struct sk_buff *tx99_skb ;
   bool tx99_state ;
   s16 tx99_power ;
   u32 wow_intr_before_sleep ;
   bool force_wow ;
};

#line 126  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mac.h"
struct ath_rx_status {
   u32 rs_tstamp ;
   u16 rs_datalen ;
   u8 rs_status ;
   u8 rs_phyerr ;
   int8_t rs_rssi ;
   u8 rs_keyix ;
   u8 rs_rate ;
   u8 rs_antenna ;
   u8 rs_more ;
   int8_t rs_rssi_ctl[3U] ;
   int8_t rs_rssi_ext[3U] ;
   u8 rs_isaggr ;
   u8 rs_firstaggr ;
   u8 rs_moreaggr ;
   u8 rs_num_delims ;
   u8 rs_flags ;
   bool is_mybeacon ;
   u32 evm0 ;
   u32 evm1 ;
   u32 evm2 ;
   u32 evm3 ;
   u32 evm4 ;
   u32 flag ;
};

#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef u64 phys_addr_t;

#line 167  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef phys_addr_t resource_size_t;

#line 14  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_ahb.c.aux"
struct kernel_symbol {
   unsigned long value ;
   char const *name ;
};

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/init.h"
typedef void (*ctor_fn_t)(void);

#line 555  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/percpu.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jump_label.h"
struct jump_entry;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/jump_label.h"
typedef u64 jump_label_t;

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/jump_label.h"
struct jump_entry {
   jump_label_t code ;
   jump_label_t target ;
   jump_label_t key ;
};

#line 412  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
struct nl80211_sta_flag_update {
   __u32 mask ;
   __u32 set ;
};

#line 2524  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/nl80211.h"
enum nl80211_mesh_power_mode {
    NL80211_MESH_POWER_UNKNOWN = 0,
    NL80211_MESH_POWER_ACTIVE = 1,
    NL80211_MESH_POWER_LIGHT_SLEEP = 2,
    NL80211_MESH_POWER_DEEP_SLEEP = 3,
    __NL80211_MESH_POWER_AFTER_LAST = 4,
    NL80211_MESH_POWER_MAX = 3
};

#line 3559 
enum nl80211_txrate_gi {
    NL80211_TXRATE_DEFAULT_GI = 0,
    NL80211_TXRATE_FORCE_SGI = 1,
    NL80211_TXRATE_FORCE_LGI = 2
};

#line 4581  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/nl80211.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/device.h"
struct pdev_archdata {
   
};

#line 476  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct platform_device_id {
   char name[20U] ;
   kernel_ulong_t driver_data ;
};

#line 652 
struct mfd_cell;

#line 653  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct platform_device {
   char const *name ;
   int id ;
   bool id_auto ;
   struct device dev ;
   u32 num_resources ;
   struct resource *resource ;
   struct platform_device_id const *id_entry ;
   char *driver_override ;
   struct mfd_cell *mfd_cell ;
   struct pdev_archdata archdata ;
};

#line 173  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/platform_device.h"
struct platform_driver {
   int (*probe)(struct platform_device *) ;
   int (*remove)(struct platform_device *) ;
   void (*shutdown)(struct platform_device *) ;
   int (*suspend)(struct platform_device *, pm_message_t ) ;
   int (*resume)(struct platform_device *) ;
   struct device_driver driver ;
   struct platform_device_id const *id_table ;
   bool prevent_deferred_probe ;
};

#line 338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/platform_device.h"
struct ath9k_platform_data {
   char const *eeprom_name ;
   u16 eeprom_data[2048U] ;
   u8 *macaddr ;
   int led_pin ;
   u32 gpio_mask ;
   u32 gpio_val ;
   bool endian_check ;
   bool is_clk_25mhz ;
   bool tx_gain_buffalo ;
   bool disable_2ghz ;
   bool disable_5ghz ;
   int (*get_mac_revision)(void) ;
   int (*external_reset)(void) ;
   bool use_eeprom ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;

#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};

#line 198  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elf.h"
struct kernel_param;

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elf.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const *, struct kernel_param const *) ;
   int (*get)(char *, struct kernel_param const *) ;
   void (*free)(void *) ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_string;

#line 62 
struct kparam_array;

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
union __anonunion_941 {
   void *arg ;
   struct kparam_string const *str ;
   struct kparam_array const *arr ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kernel_param {
   char const *name ;
   struct module *mod ;
   struct kernel_param_ops const *ops ;
   u16 const perm ;
   s8 level ;
   u8 flags ;
   union __anonunion_941 __anonCompField_kernel_param_49 ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops const *ops ;
   void *elem ;
};

#line 469  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rbtree_latch.h"
struct mod_arch_specific {
   
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_param_attrs;

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute *, struct module_kobject *, char *) ;
   ssize_t (*store)(struct module_attribute *, struct module_kobject *, char const *, size_t ) ;
   void (*setup)(struct module *, char const *) ;
   int (*test)(struct module *) ;
   void (*free)(struct module *) ;
};

#line 74 
struct exception_table_entry;

#line 290 
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
};

#line 297  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};

#line 304 
struct module_sect_attrs;

#line 304 
struct module_notes_attrs;

#line 304 
struct tracepoint;

#line 304 
struct trace_event_call;

#line 304 
struct trace_enum_map;

#line 304  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const *version ;
   char const *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol const *syms ;
   unsigned long const *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol const *gpl_syms ;
   unsigned long const *gpl_crcs ;
   struct kernel_symbol const *unused_syms ;
   unsigned long const *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol const *unused_gpl_syms ;
   unsigned long const *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol const *gpl_future_syms ;
   unsigned long const *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const *tracepoints_ptrs ;
   struct jump_entry *jump_entries ;
   unsigned int num_jump_entries ;
   unsigned int num_trace_bprintk_fmt ;
   char const **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};

#line 508  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/xfrm.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;

#line 914  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct rate_info {
   u8 flags ;
   u8 mcs ;
   u16 legacy ;
   u8 nss ;
   u8 bw ;
};

#line 964  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct sta_bss_parameters {
   u8 flags ;
   u8 dtim_period ;
   u16 beacon_interval ;
};

#line 989  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_tid_stats {
   u32 filled ;
   u64 rx_msdu ;
   u64 tx_msdu ;
   u64 tx_msdu_retries ;
   u64 tx_msdu_failed ;
};

#line 1007  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct station_info {
   u32 filled ;
   u32 connected_time ;
   u32 inactive_time ;
   u64 rx_bytes ;
   u64 tx_bytes ;
   u16 llid ;
   u16 plid ;
   u8 plink_state ;
   s8 signal ;
   s8 signal_avg ;
   u8 chains ;
   s8 chain_signal[4U] ;
   s8 chain_signal_avg[4U] ;
   struct rate_info txrate ;
   struct rate_info rxrate ;
   u32 rx_packets ;
   u32 tx_packets ;
   u32 tx_retries ;
   u32 tx_failed ;
   u32 rx_dropped_misc ;
   struct sta_bss_parameters bss_param ;
   struct nl80211_sta_flag_update sta_flags ;
   int generation ;
   u8 const *assoc_req_ies ;
   size_t assoc_req_ies_len ;
   u32 beacon_loss_count ;
   s64 t_offset ;
   enum nl80211_mesh_power_mode local_pm ;
   enum nl80211_mesh_power_mode peer_pm ;
   enum nl80211_mesh_power_mode nonpeer_pm ;
   u32 expected_throughput ;
   u64 rx_beacon ;
   u8 rx_beacon_signal_avg ;
   struct cfg80211_tid_stats pertid[17U] ;
};

#line 1882  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct __anonstruct_control_1131 {
   u32 legacy ;
   u8 ht_mcs[10U] ;
   u16 vht_mcs[8U] ;
   enum nl80211_txrate_gi gi ;
};

#line 1882  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_bitrate_mask {
   struct __anonstruct_control_1131 control[3U] ;
};

#line 2086  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_gtk_rekey_data {
   u8 const *kek ;
   u8 const *kck ;
   u8 const *replay_ctr ;
};

#line 5244  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct ieee80211_tx_queue_params {
   u16 txop ;
   u16 cw_min ;
   u16 cw_max ;
   u8 aifs ;
   bool acm ;
   bool uapsd ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_low_level_stats {
   unsigned int dot11ACKFailureCount ;
   unsigned int dot11RTSFailureCount ;
   unsigned int dot11FCSErrorCount ;
   unsigned int dot11RTSSuccessCount ;
};

#line 224 
enum ieee80211_chanctx_switch_mode {
    CHANCTX_SWMODE_REASSIGN_VIF = 0,
    CHANCTX_SWMODE_SWAP_CONTEXTS = 1
};

#line 229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_vif_chanctx_switch {
   struct ieee80211_vif *vif ;
   struct ieee80211_chanctx_conf *old_ctx ;
   struct ieee80211_chanctx_conf *new_ctx ;
};

#line 287 
enum ieee80211_event_type {
    RSSI_EVENT = 0,
    MLME_EVENT = 1,
    BAR_RX_EVENT = 2,
    BA_FRAME_TIMEOUT = 3
};

#line 294 
enum ieee80211_rssi_event_data {
    RSSI_EVENT_HIGH = 0,
    RSSI_EVENT_LOW = 1
};

#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_rssi_event {
   enum ieee80211_rssi_event_data data ;
};

#line 369 
enum ieee80211_mlme_event_data {
    AUTH_EVENT = 0,
    ASSOC_EVENT = 1,
    DEAUTH_RX_EVENT = 2,
    DEAUTH_TX_EVENT = 3
};

#line 376 
enum ieee80211_mlme_event_status {
    MLME_SUCCESS = 0,
    MLME_DENIED = 1,
    MLME_TIMEOUT = 2
};

#line 382  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_mlme_event {
   enum ieee80211_mlme_event_data data ;
   enum ieee80211_mlme_event_status status ;
   u16 reason ;
};

#line 407  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_ba_event {
   struct ieee80211_sta *sta ;
   u16 tid ;
   u16 ssn ;
};

#line 419  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
union __anonunion_u_1133 {
   struct ieee80211_rssi_event rssi ;
   struct ieee80211_mlme_event mlme ;
   struct ieee80211_ba_event ba ;
};

#line 419  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_event {
   enum ieee80211_event_type type ;
   union __anonunion_u_1133 u ;
};

#line 896  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_scan_ies {
   u8 const *ies[3U] ;
   size_t len[3U] ;
   u8 const *common_ies ;
   size_t common_ie_len ;
};

#line 1285  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_channel_switch {
   u64 timestamp ;
   u32 device_timestamp ;
   bool block_tx ;
   struct cfg80211_chan_def chandef ;
   u8 count ;
};

#line 1506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct __anonstruct_tkip_1142 {
   u32 iv32 ;
   u16 iv16 ;
};

#line 1506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct __anonstruct_ccmp_1143 {
   u8 pn[6U] ;
};

#line 1506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct __anonstruct_aes_cmac_1144 {
   u8 pn[6U] ;
};

#line 1506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct __anonstruct_aes_gmac_1145 {
   u8 pn[6U] ;
};

#line 1506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct __anonstruct_gcmp_1146 {
   u8 pn[6U] ;
};

#line 1506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct __anonstruct_hw_1147 {
   u8 seq[16U] ;
   u8 seq_len ;
};

#line 1506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
union __anonunion_1141 {
   struct __anonstruct_tkip_1142 tkip ;
   struct __anonstruct_ccmp_1143 ccmp ;
   struct __anonstruct_aes_cmac_1144 aes_cmac ;
   struct __anonstruct_aes_gmac_1145 aes_gmac ;
   struct __anonstruct_gcmp_1146 gcmp ;
   struct __anonstruct_hw_1147 hw ;
};

#line 1506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_key_seq {
   union __anonunion_1141 __anonCompField_ieee80211_key_seq_100 ;
};

#line 1577 
enum set_key_cmd {
    SET_KEY = 0,
    DISABLE_KEY = 1
};

#line 1582 
enum ieee80211_sta_state {
    IEEE80211_STA_NOTEXIST = 0,
    IEEE80211_STA_NONE = 1,
    IEEE80211_STA_AUTH = 2,
    IEEE80211_STA_ASSOC = 3,
    IEEE80211_STA_AUTHORIZED = 4
};

#line 1703 
enum sta_notify_cmd {
    STA_NOTIFY_SLEEP = 0,
    STA_NOTIFY_AWAKE = 1
};

#line 1708  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_tx_control {
   struct ieee80211_sta *sta ;
};

#line 2070  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_scan_request {
   struct ieee80211_scan_ies ies ;
   struct cfg80211_scan_request req ;
};

#line 2084  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_tdls_ch_sw_params {
   struct ieee80211_sta *sta ;
   struct cfg80211_chan_def *chandef ;
   u8 action_code ;
   u32 status ;
   u32 timestamp ;
   u16 switch_time ;
   u16 switch_timeout ;
   struct sk_buff *tmpl_skb ;
   u32 ch_sw_tm_ie ;
};

#line 2194 
enum ieee80211_ampdu_mlme_action {
    IEEE80211_AMPDU_RX_START = 0,
    IEEE80211_AMPDU_RX_STOP = 1,
    IEEE80211_AMPDU_TX_START = 2,
    IEEE80211_AMPDU_TX_STOP_CONT = 3,
    IEEE80211_AMPDU_TX_STOP_FLUSH = 4,
    IEEE80211_AMPDU_TX_STOP_FLUSH_CONT = 5,
    IEEE80211_AMPDU_TX_OPERATIONAL = 6
};

#line 2204 
enum ieee80211_frame_release_type {
    IEEE80211_FRAME_RELEASE_PSPOLL = 0,
    IEEE80211_FRAME_RELEASE_UAPSD = 1
};

#line 2216 
enum ieee80211_roc_type {
    IEEE80211_ROC_TYPE_NORMAL = 0,
    IEEE80211_ROC_TYPE_MGMT_TX = 1
};

#line 2221 
enum ieee80211_reconfig_type {
    IEEE80211_RECONFIG_TYPE_RESTART = 0,
    IEEE80211_RECONFIG_TYPE_SUSPEND = 1
};

#line 2226  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_ops {
   void (*tx)(struct ieee80211_hw *, struct ieee80211_tx_control *, struct sk_buff *) ;
   int (*start)(struct ieee80211_hw *) ;
   void (*stop)(struct ieee80211_hw *) ;
   int (*suspend)(struct ieee80211_hw *, struct cfg80211_wowlan *) ;
   int (*resume)(struct ieee80211_hw *) ;
   void (*set_wakeup)(struct ieee80211_hw *, bool ) ;
   int (*add_interface)(struct ieee80211_hw *, struct ieee80211_vif *) ;
   int (*change_interface)(struct ieee80211_hw *, struct ieee80211_vif *, enum nl80211_iftype , bool ) ;
   void (*remove_interface)(struct ieee80211_hw *, struct ieee80211_vif *) ;
   int (*config)(struct ieee80211_hw *, u32 ) ;
   void (*bss_info_changed)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_bss_conf *, u32 ) ;
   int (*start_ap)(struct ieee80211_hw *, struct ieee80211_vif *) ;
   void (*stop_ap)(struct ieee80211_hw *, struct ieee80211_vif *) ;
   u64 (*prepare_multicast)(struct ieee80211_hw *, struct netdev_hw_addr_list *) ;
   void (*configure_filter)(struct ieee80211_hw *, unsigned int , unsigned int *, u64 ) ;
   int (*set_tim)(struct ieee80211_hw *, struct ieee80211_sta *, bool ) ;
   int (*set_key)(struct ieee80211_hw *, enum set_key_cmd , struct ieee80211_vif *, struct ieee80211_sta *, struct ieee80211_key_conf *) ;
   void (*update_tkip_key)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_key_conf *, struct ieee80211_sta *, u32 , u16 *) ;
   void (*set_rekey_data)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_gtk_rekey_data *) ;
   void (*set_default_unicast_key)(struct ieee80211_hw *, struct ieee80211_vif *, int ) ;
   int (*hw_scan)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_scan_request *) ;
   void (*cancel_hw_scan)(struct ieee80211_hw *, struct ieee80211_vif *) ;
   int (*sched_scan_start)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_sched_scan_request *, struct ieee80211_scan_ies *) ;
   int (*sched_scan_stop)(struct ieee80211_hw *, struct ieee80211_vif *) ;
   void (*sw_scan_start)(struct ieee80211_hw *, struct ieee80211_vif *, u8 const *) ;
   void (*sw_scan_complete)(struct ieee80211_hw *, struct ieee80211_vif *) ;
   int (*get_stats)(struct ieee80211_hw *, struct ieee80211_low_level_stats *) ;
   void (*get_key_seq)(struct ieee80211_hw *, struct ieee80211_key_conf *, struct ieee80211_key_seq *) ;
   int (*set_frag_threshold)(struct ieee80211_hw *, u32 ) ;
   int (*set_rts_threshold)(struct ieee80211_hw *, u32 ) ;
   int (*sta_add)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *) ;
   int (*sta_remove)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *) ;
   void (*sta_add_debugfs)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, struct dentry *) ;
   void (*sta_remove_debugfs)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, struct dentry *) ;
   void (*sta_notify)(struct ieee80211_hw *, struct ieee80211_vif *, enum sta_notify_cmd , struct ieee80211_sta *) ;
   int (*sta_state)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, enum ieee80211_sta_state , enum ieee80211_sta_state ) ;
   void (*sta_pre_rcu_remove)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *) ;
   void (*sta_rc_update)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, u32 ) ;
   void (*sta_rate_tbl_update)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *) ;
   void (*sta_statistics)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, struct station_info *) ;
   int (*conf_tx)(struct ieee80211_hw *, struct ieee80211_vif *, u16 , struct ieee80211_tx_queue_params const *) ;
   u64 (*get_tsf)(struct ieee80211_hw *, struct ieee80211_vif *) ;
   void (*set_tsf)(struct ieee80211_hw *, struct ieee80211_vif *, u64 ) ;
   void (*reset_tsf)(struct ieee80211_hw *, struct ieee80211_vif *) ;
   int (*tx_last_beacon)(struct ieee80211_hw *) ;
   int (*ampdu_action)(struct ieee80211_hw *, struct ieee80211_vif *, enum ieee80211_ampdu_mlme_action , struct ieee80211_sta *, u16 , u16 *, u8 ) ;
   int (*get_survey)(struct ieee80211_hw *, int , struct survey_info *) ;
   void (*rfkill_poll)(struct ieee80211_hw *) ;
   void (*set_coverage_class)(struct ieee80211_hw *, s16 ) ;
   int (*testmode_cmd)(struct ieee80211_hw *, struct ieee80211_vif *, void *, int ) ;
   int (*testmode_dump)(struct ieee80211_hw *, struct sk_buff *, struct netlink_callback *, void *, int ) ;
   void (*flush)(struct ieee80211_hw *, struct ieee80211_vif *, u32 , bool ) ;
   void (*channel_switch)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_channel_switch *) ;
   int (*set_antenna)(struct ieee80211_hw *, u32 , u32 ) ;
   int (*get_antenna)(struct ieee80211_hw *, u32 *, u32 *) ;
   int (*remain_on_channel)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_channel *, int , enum ieee80211_roc_type ) ;
   int (*cancel_remain_on_channel)(struct ieee80211_hw *) ;
   int (*set_ringparam)(struct ieee80211_hw *, u32 , u32 ) ;
   void (*get_ringparam)(struct ieee80211_hw *, u32 *, u32 *, u32 *, u32 *) ;
   bool (*tx_frames_pending)(struct ieee80211_hw *) ;
   int (*set_bitrate_mask)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_bitrate_mask const *) ;
   void (*event_callback)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_event const *) ;
   void (*allow_buffered_frames)(struct ieee80211_hw *, struct ieee80211_sta *, u16 , int , enum ieee80211_frame_release_type , bool ) ;
   void (*release_buffered_frames)(struct ieee80211_hw *, struct ieee80211_sta *, u16 , int , enum ieee80211_frame_release_type , bool ) ;
   int (*get_et_sset_count)(struct ieee80211_hw *, struct ieee80211_vif *, int ) ;
   void (*get_et_stats)(struct ieee80211_hw *, struct ieee80211_vif *, struct ethtool_stats *, u64 *) ;
   void (*get_et_strings)(struct ieee80211_hw *, struct ieee80211_vif *, u32 , u8 *) ;
   void (*mgd_prepare_tx)(struct ieee80211_hw *, struct ieee80211_vif *) ;
   void (*mgd_protect_tdls_discover)(struct ieee80211_hw *, struct ieee80211_vif *) ;
   int (*add_chanctx)(struct ieee80211_hw *, struct ieee80211_chanctx_conf *) ;
   void (*remove_chanctx)(struct ieee80211_hw *, struct ieee80211_chanctx_conf *) ;
   void (*change_chanctx)(struct ieee80211_hw *, struct ieee80211_chanctx_conf *, u32 ) ;
   int (*assign_vif_chanctx)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_chanctx_conf *) ;
   void (*unassign_vif_chanctx)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_chanctx_conf *) ;
   int (*switch_vif_chanctx)(struct ieee80211_hw *, struct ieee80211_vif_chanctx_switch *, int , enum ieee80211_chanctx_switch_mode ) ;
   void (*reconfig_complete)(struct ieee80211_hw *, enum ieee80211_reconfig_type ) ;
   void (*ipv6_addr_change)(struct ieee80211_hw *, struct ieee80211_vif *, struct inet6_dev *) ;
   void (*channel_switch_beacon)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_chan_def *) ;
   int (*pre_channel_switch)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_channel_switch *) ;
   int (*post_channel_switch)(struct ieee80211_hw *, struct ieee80211_vif *) ;
   int (*join_ibss)(struct ieee80211_hw *, struct ieee80211_vif *) ;
   void (*leave_ibss)(struct ieee80211_hw *, struct ieee80211_vif *) ;
   u32 (*get_expected_throughput)(struct ieee80211_sta *) ;
   int (*get_txpower)(struct ieee80211_hw *, struct ieee80211_vif *, int *) ;
   int (*tdls_channel_switch)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, u8 , struct cfg80211_chan_def *, struct sk_buff *, u32 ) ;
   void (*tdls_cancel_channel_switch)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *) ;
   void (*tdls_recv_channel_switch)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_tdls_ch_sw_params *) ;
   void (*wake_tx_queue)(struct ieee80211_hw *, struct ieee80211_txq *) ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
enum ldv_11808 {
    WORK_STRUCT_PENDING_BIT = 0,
    WORK_STRUCT_DELAYED_BIT = 1,
    WORK_STRUCT_PWQ_BIT = 2,
    WORK_STRUCT_LINKED_BIT = 3,
    WORK_STRUCT_STATIC_BIT = 4,
    WORK_STRUCT_COLOR_SHIFT = 5,
    WORK_STRUCT_COLOR_BITS = 4,
    WORK_STRUCT_PENDING = 1,
    WORK_STRUCT_DELAYED = 2,
    WORK_STRUCT_PWQ = 4,
    WORK_STRUCT_LINKED = 8,
    WORK_STRUCT_STATIC = 16,
    WORK_NR_COLORS = 15,
    WORK_NO_COLOR = 15,
    WORK_CPU_UNBOUND = 8192,
    WORK_STRUCT_FLAG_BITS = 9,
    WORK_OFFQ_FLAG_BASE = 5,
    __WORK_OFFQ_CANCELING = 5,
    WORK_OFFQ_CANCELING = 32,
    WORK_OFFQ_FLAG_BITS = 1,
    WORK_OFFQ_POOL_SHIFT = 6,
    WORK_OFFQ_LEFT = 58,
    WORK_OFFQ_POOL_BITS = 31,
    WORK_OFFQ_POOL_NONE = 2147483647,
    WORK_STRUCT_FLAG_MASK = 511,
    WORK_STRUCT_WQ_DATA_MASK = -512,
    WORK_STRUCT_NO_POOL = 137438953408,
    WORK_BUSY_PENDING = 1,
    WORK_BUSY_RUNNING = 2,
    WORKER_DESC_LEN = 24
};

#line 744  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file *, wait_queue_head_t *, struct poll_table_struct *) ;
   unsigned long _key ;
};

#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/poll.h"
struct rchan_buf {
   void *start ;
   void *data ;
   size_t offset ;
   size_t subbufs_produced ;
   size_t subbufs_consumed ;
   struct rchan *chan ;
   wait_queue_head_t read_wait ;
   struct timer_list timer ;
   struct dentry *dentry ;
   struct kref kref ;
   struct page **page_array ;
   unsigned int page_count ;
   unsigned int finalized ;
   size_t *padding ;
   size_t prev_padding ;
   size_t bytes_consumed ;
   size_t early_bytes ;
   unsigned int cpu ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/relay.h"
struct rchan_callbacks;

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/relay.h"
struct rchan {
   u32 version ;
   size_t subbuf_size ;
   size_t n_subbufs ;
   size_t alloc_size ;
   struct rchan_callbacks *cb ;
   struct kref kref ;
   void *private_data ;
   size_t last_toobig ;
   struct rchan_buf *buf[8192U] ;
   int is_global ;
   struct list_head list ;
   struct dentry *parent ;
   int has_base_filename ;
   char base_filename[255U] ;
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/relay.h"
struct rchan_callbacks {
   int (*subbuf_start)(struct rchan_buf *, void *, void *, size_t ) ;
   void (*buf_mapped)(struct rchan_buf *, struct file *) ;
   void (*buf_unmapped)(struct rchan_buf *, struct file *) ;
   struct dentry *(*create_buf_file)(char const *, struct dentry *, umode_t , struct rchan_buf *, int *) ;
   int (*remove_buf_file)(struct dentry *) ;
};

#line 2600  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/nl80211.h"
enum nl80211_channel_type {
    NL80211_CHAN_NO_HT = 0,
    NL80211_CHAN_HT20 = 1,
    NL80211_CHAN_HT40MINUS = 2,
    NL80211_CHAN_HT40PLUS = 3
};

#line 1748  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
enum ieee80211_hw_flags {
    IEEE80211_HW_HAS_RATE_CONTROL = 0,
    IEEE80211_HW_RX_INCLUDES_FCS = 1,
    IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING = 2,
    IEEE80211_HW_SIGNAL_UNSPEC = 3,
    IEEE80211_HW_SIGNAL_DBM = 4,
    IEEE80211_HW_NEED_DTIM_BEFORE_ASSOC = 5,
    IEEE80211_HW_SPECTRUM_MGMT = 6,
    IEEE80211_HW_AMPDU_AGGREGATION = 7,
    IEEE80211_HW_SUPPORTS_PS = 8,
    IEEE80211_HW_PS_NULLFUNC_STACK = 9,
    IEEE80211_HW_SUPPORTS_DYNAMIC_PS = 10,
    IEEE80211_HW_MFP_CAPABLE = 11,
    IEEE80211_HW_WANT_MONITOR_VIF = 12,
    IEEE80211_HW_NO_AUTO_VIF = 13,
    IEEE80211_HW_SW_CRYPTO_CONTROL = 14,
    IEEE80211_HW_SUPPORT_FAST_XMIT = 15,
    IEEE80211_HW_REPORTS_TX_ACK_STATUS = 16,
    IEEE80211_HW_CONNECTION_MONITOR = 17,
    IEEE80211_HW_QUEUE_CONTROL = 18,
    IEEE80211_HW_SUPPORTS_PER_STA_GTK = 19,
    IEEE80211_HW_AP_LINK_PS = 20,
    IEEE80211_HW_TX_AMPDU_SETUP_IN_HW = 21,
    IEEE80211_HW_SUPPORTS_RC_TABLE = 22,
    IEEE80211_HW_P2P_DEV_ADDR_FOR_INTF = 23,
    IEEE80211_HW_TIMING_BEACON_ONLY = 24,
    IEEE80211_HW_SUPPORTS_HT_CCK_RATES = 25,
    IEEE80211_HW_CHANCTX_STA_CSA = 26,
    IEEE80211_HW_SUPPORTS_CLONED_SKBS = 27,
    IEEE80211_HW_SINGLE_SCAN_ON_ALL_BANDS = 28,
    NUM_IEEE80211_HW_FLAGS = 29
};

#line 3518  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_tpt_blink {
   int throughput ;
   int blink_time ;
};

#line 1099  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
struct ath9k_eeprom_ctx {
   struct completion complete ;
   struct ath_hw *ah ;
};

#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct ieee80211_hdr {
   __le16 frame_control ;
   __le16 duration_id ;
   u8 addr1[6U] ;
   u8 addr2[6U] ;
   u8 addr3[6U] ;
   __le16 seq_ctrl ;
   u8 addr4[6U] ;
};

#line 742  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct ieee80211_tim_ie {
   u8 dtim_count ;
   u8 dtim_period ;
   u8 bitmap_ctrl ;
   u8 virtual_map[1U] ;
};

#line 923  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_rx_status;

#line 997  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_rx_status {
   u64 mactime ;
   u32 device_timestamp ;
   u32 ampdu_reference ;
   u32 flag ;
   u16 freq ;
   u8 vht_flag ;
   u8 rate_idx ;
   u8 vht_nss ;
   u8 rx_flags ;
   u8 band ;
   u8 antenna ;
   s8 signal ;
   u8 chains ;
   s8 chain_signal[4U] ;
   u8 ampdu_delimiter_crc ;
};

#line 206  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mac.h"
struct ath_desc {
   u32 ds_link ;
   u32 ds_data ;
   u32 ds_ctl0 ;
   u32 ds_ctl1 ;
   u32 ds_hw[20U] ;
   void *ds_vdata ;
};

#line 466  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
enum ath9k_rx_qtype {
    ATH9K_RX_QUEUE_HP = 0,
    ATH9K_RX_QUEUE_LP = 1,
    ATH9K_RX_QUEUE_MAX = 2
};

#line 98  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ar9003_mac.h"
struct ar9003_txs {
   u32 ds_info ;
   u32 status1 ;
   u32 status2 ;
   u32 status3 ;
   u32 status4 ;
   u32 status5 ;
   u32 status6 ;
   u32 status7 ;
   u32 status8 ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/preempt.h"
typedef int pao_T__;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
enum ldv_11850 {
    WORK_STRUCT_PENDING_BIT_0 = 0,
    WORK_STRUCT_DELAYED_BIT_0 = 1,
    WORK_STRUCT_PWQ_BIT_0 = 2,
    WORK_STRUCT_LINKED_BIT_0 = 3,
    WORK_STRUCT_STATIC_BIT_0 = 4,
    WORK_STRUCT_COLOR_SHIFT_0 = 5,
    WORK_STRUCT_COLOR_BITS_0 = 4,
    WORK_STRUCT_PENDING_0 = 1,
    WORK_STRUCT_DELAYED_0 = 2,
    WORK_STRUCT_PWQ_0 = 4,
    WORK_STRUCT_LINKED_0 = 8,
    WORK_STRUCT_STATIC_0 = 16,
    WORK_NR_COLORS_0 = 15,
    WORK_NO_COLOR_0 = 15,
    WORK_CPU_UNBOUND_0 = 8192,
    WORK_STRUCT_FLAG_BITS_0 = 9,
    WORK_OFFQ_FLAG_BASE_0 = 5,
    __WORK_OFFQ_CANCELING_0 = 5,
    WORK_OFFQ_CANCELING_0 = 32,
    WORK_OFFQ_FLAG_BITS_0 = 1,
    WORK_OFFQ_POOL_SHIFT_0 = 6,
    WORK_OFFQ_LEFT_0 = 58,
    WORK_OFFQ_POOL_BITS_0 = 31,
    WORK_OFFQ_POOL_NONE_0 = 2147483647,
    WORK_STRUCT_FLAG_MASK_0 = 511,
    WORK_STRUCT_WQ_DATA_MASK_0 = -512,
    WORK_STRUCT_NO_POOL_0 = 137438953408,
    WORK_BUSY_PENDING_0 = 1,
    WORK_BUSY_RUNNING_0 = 2,
    WORKER_DESC_LEN_0 = 24
};

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
struct ath_frame_info {
   struct ath_buf *bf ;
   u16 framelen ;
   s8 txq ;
   u8 keyix ;
   u8 rtscts_rate ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(7))) retries : 7 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) baw_tracked : 1 ;
   u8 tx_power ;
   enum ath9k_key_type __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) keytype : 2 ;
};

#line 281  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
struct ath_tx_control {
   struct ath_txq *txq ;
   struct ath_node *an ;
   struct ieee80211_sta *sta ;
   u8 paprd ;
   bool force_channel ;
};

#line 627  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
struct ath9k_vif_iter_data {
   u8 hw_macaddr[6U] ;
   u8 mask[6U] ;
   bool has_hw_macaddr ;
   u8 slottime ;
   bool beacons ;
   int naps ;
   int nmeshes ;
   int nstations ;
   int nwds ;
   int nadhocs ;
   struct ieee80211_vif *primary_sta ;
};

#line 146  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
struct __anonstruct_ani_info_3479 {
   char const *name ;
   unsigned int val ;
};

#line 1099  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
struct ath_radar_data {
   u8 pulse_bw_info ;
   u8 rssi ;
   u8 ext_rssi ;
   u8 pulse_length_ext ;
   u8 pulse_length_pri ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
enum ldv_11612 {
    WORK_STRUCT_PENDING_BIT_1 = 0,
    WORK_STRUCT_DELAYED_BIT_1 = 1,
    WORK_STRUCT_PWQ_BIT_1 = 2,
    WORK_STRUCT_LINKED_BIT_1 = 3,
    WORK_STRUCT_STATIC_BIT_1 = 4,
    WORK_STRUCT_COLOR_SHIFT_1 = 5,
    WORK_STRUCT_COLOR_BITS_1 = 4,
    WORK_STRUCT_PENDING_1 = 1,
    WORK_STRUCT_DELAYED_1 = 2,
    WORK_STRUCT_PWQ_1 = 4,
    WORK_STRUCT_LINKED_1 = 8,
    WORK_STRUCT_STATIC_1 = 16,
    WORK_NR_COLORS_1 = 15,
    WORK_NO_COLOR_1 = 15,
    WORK_CPU_UNBOUND_1 = 8192,
    WORK_STRUCT_FLAG_BITS_1 = 9,
    WORK_OFFQ_FLAG_BASE_1 = 5,
    __WORK_OFFQ_CANCELING_1 = 5,
    WORK_OFFQ_CANCELING_1 = 32,
    WORK_OFFQ_FLAG_BITS_1 = 1,
    WORK_OFFQ_POOL_SHIFT_1 = 6,
    WORK_OFFQ_LEFT_1 = 58,
    WORK_OFFQ_POOL_BITS_1 = 31,
    WORK_OFFQ_POOL_NONE_1 = 2147483647,
    WORK_STRUCT_FLAG_MASK_1 = 511,
    WORK_STRUCT_WQ_DATA_MASK_1 = -512,
    WORK_STRUCT_NO_POOL_1 = 137438953408,
    WORK_BUSY_PENDING_1 = 1,
    WORK_BUSY_RUNNING_1 = 2,
    WORKER_DESC_LEN_1 = 24
};

#line 229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct ieee80211_hdr_3addr {
   __le16 frame_control ;
   __le16 duration_id ;
   u8 addr1[6U] ;
   u8 addr2[6U] ;
   u8 addr3[6U] ;
   __le16 seq_ctrl ;
};

#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/calib.h"
enum ath_stomp_type {
    ATH_BTCOEX_STOMP_ALL = 0,
    ATH_BTCOEX_STOMP_LOW = 1,
    ATH_BTCOEX_STOMP_NONE = 2,
    ATH_BTCOEX_STOMP_LOW_FTP = 3,
    ATH_BTCOEX_STOMP_AUDIO = 4,
    ATH_BTCOEX_STOMP_MAX = 5
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/x86_init.h"
struct pci_dev;

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/topology.h"
struct pci_bus;

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/resource_ext.h"
struct hotplug_slot;

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/resource_ext.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef int pci_power_t;

#line 137  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned int pci_channel_state_t;

#line 138 
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
};

#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;

#line 192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;

#line 249 
struct pcie_link_state;

#line 250 
struct pci_vpd;

#line 251 
struct pci_sriov;

#line 252 
struct pci_ats;

#line 253 
struct pci_driver;

#line 253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
union __anonunion_5614 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};

#line 253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   u8 dma_alias_devfn ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(5))) pme_support : 5 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pme_interrupt : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pme_poll : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d1_support : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d2_support : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_d1d2 : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_d3cold : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d3cold_allowed : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) mmio_always_on : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wakeup_prepared : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) runtime_d3cold : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_hotplug : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) transparent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) multifunction : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_added : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_busmaster : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_msi : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_64bit_msi : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) block_cfg_access : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) broken_parity_status : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) irq_reroute_variant : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) msi_enabled : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) msix_enabled : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ari_enabled : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_managed : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) needs_freset : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_saved : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_physfn : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_virtfn : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) reset_fn : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_hotplug_bridge : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) __aer_firmware_first_valid : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) __aer_firmware_first : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) broken_intx_masking : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) io_window_1k : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) irq_managed : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) has_secondary_link : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct attribute_group const **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion_5614 __anonCompField_pci_dev_57 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
};

#line 442 
struct pci_ops;

#line 442 
struct msi_controller;

#line 442  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_controller *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_added : 1 ;
};

#line 565  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_ops {
   void *(*map_bus)(struct pci_bus *, unsigned int , int ) ;
   int (*read)(struct pci_bus *, unsigned int , int , int , u32 *) ;
   int (*write)(struct pci_bus *, unsigned int , int , int , u32 ) ;
};

#line 593  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};

#line 607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned int pci_ers_result_t;

#line 617  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev *, enum pci_channel_state ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev *) ;
   pci_ers_result_t (*link_reset)(struct pci_dev *) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev *) ;
   void (*reset_notify)(struct pci_dev *, bool ) ;
   void (*resume)(struct pci_dev *) ;
};

#line 650  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const *name ;
   struct pci_device_id const *id_table ;
   int (*probe)(struct pci_dev *, struct pci_device_id const *) ;
   void (*remove)(struct pci_dev *) ;
   int (*suspend)(struct pci_dev *, pm_message_t ) ;
   int (*suspend_late)(struct pci_dev *, pm_message_t ) ;
   int (*resume_early)(struct pci_dev *) ;
   int (*resume)(struct pci_dev *) ;
   void (*shutdown)(struct pci_dev *) ;
   int (*sriov_configure)(struct pci_dev *, int ) ;
   struct pci_error_handlers const *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
enum ldv_11782 {
    WORK_STRUCT_PENDING_BIT_2 = 0,
    WORK_STRUCT_DELAYED_BIT_2 = 1,
    WORK_STRUCT_PWQ_BIT_2 = 2,
    WORK_STRUCT_LINKED_BIT_2 = 3,
    WORK_STRUCT_STATIC_BIT_2 = 4,
    WORK_STRUCT_COLOR_SHIFT_2 = 5,
    WORK_STRUCT_COLOR_BITS_2 = 4,
    WORK_STRUCT_PENDING_2 = 1,
    WORK_STRUCT_DELAYED_2 = 2,
    WORK_STRUCT_PWQ_2 = 4,
    WORK_STRUCT_LINKED_2 = 8,
    WORK_STRUCT_STATIC_2 = 16,
    WORK_NR_COLORS_2 = 15,
    WORK_NO_COLOR_2 = 15,
    WORK_CPU_UNBOUND_2 = 8192,
    WORK_STRUCT_FLAG_BITS_2 = 9,
    WORK_OFFQ_FLAG_BASE_2 = 5,
    __WORK_OFFQ_CANCELING_2 = 5,
    WORK_OFFQ_CANCELING_2 = 32,
    WORK_OFFQ_FLAG_BITS_2 = 1,
    WORK_OFFQ_POOL_SHIFT_2 = 6,
    WORK_OFFQ_LEFT_2 = 58,
    WORK_OFFQ_POOL_BITS_2 = 31,
    WORK_OFFQ_POOL_NONE_2 = 2147483647,
    WORK_STRUCT_FLAG_MASK_2 = 511,
    WORK_STRUCT_WQ_DATA_MASK_2 = -512,
    WORK_STRUCT_NO_POOL_2 = 137438953408,
    WORK_BUSY_PENDING_2 = 1,
    WORK_BUSY_RUNNING_2 = 2,
    WORKER_DESC_LEN_2 = 24
};

#line 340  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ar9003_mci.h"
struct ath_mci_profile_info {
   u8 type ;
   u8 conn_handle ;
   bool start ;
   bool master ;
   bool edr ;
   u8 voice_type ;
   u16 T ;
   u8 W ;
   u8 A ;
   struct list_head list ;
};

#line 121  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mci.h"
struct ath_mci_profile_status {
   bool is_critical ;
   bool is_link ;
   u8 conn_handle ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
struct __wait_queue;

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t *, unsigned int , int , void *) ;
   struct list_head task_list ;
};

#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
struct ldv_list_element {
   void *data ;
   struct ldv_list_element *next ;
};

#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
typedef struct ldv_list_element *ldv_list_ptr;

#line 41  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
struct device_private {
   void *driver_data ;
};

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_work;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_worker {
   spinlock_t lock ;
   struct list_head work_list ;
   struct task_struct *task ;
   struct kthread_work *current_work ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_work {
   struct list_head node ;
   void (*func)(struct kthread_work *) ;
   struct kthread_worker *worker ;
};

#line 380  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct dma_chan;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_master;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_device {
   struct device dev ;
   struct spi_master *master ;
   u32 max_speed_hz ;
   u8 chip_select ;
   u8 bits_per_word ;
   u16 mode ;
   int irq ;
   void *controller_state ;
   void *controller_data ;
   char modalias[32U] ;
   int cs_gpio ;
};

#line 151 
struct spi_message;

#line 152 
struct spi_transfer;

#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_master {
   struct device dev ;
   struct list_head list ;
   s16 bus_num ;
   u16 num_chipselect ;
   u16 dma_alignment ;
   u16 mode_bits ;
   u32 bits_per_word_mask ;
   u32 min_speed_hz ;
   u32 max_speed_hz ;
   u16 flags ;
   spinlock_t bus_lock_spinlock ;
   struct mutex bus_lock_mutex ;
   bool bus_lock_flag ;
   int (*setup)(struct spi_device *) ;
   int (*transfer)(struct spi_device *, struct spi_message *) ;
   void (*cleanup)(struct spi_device *) ;
   bool (*can_dma)(struct spi_master *, struct spi_device *, struct spi_transfer *) ;
   bool queued ;
   struct kthread_worker kworker ;
   struct task_struct *kworker_task ;
   struct kthread_work pump_messages ;
   spinlock_t queue_lock ;
   struct list_head queue ;
   struct spi_message *cur_msg ;
   bool idling ;
   bool busy ;
   bool running ;
   bool rt ;
   bool auto_runtime_pm ;
   bool cur_msg_prepared ;
   bool cur_msg_mapped ;
   struct completion xfer_completion ;
   size_t max_dma_len ;
   int (*prepare_transfer_hardware)(struct spi_master *) ;
   int (*transfer_one_message)(struct spi_master *, struct spi_message *) ;
   int (*unprepare_transfer_hardware)(struct spi_master *) ;
   int (*prepare_message)(struct spi_master *, struct spi_message *) ;
   int (*unprepare_message)(struct spi_master *, struct spi_message *) ;
   void (*set_cs)(struct spi_device *, bool ) ;
   int (*transfer_one)(struct spi_master *, struct spi_device *, struct spi_transfer *) ;
   void (*handle_err)(struct spi_master *, struct spi_message *) ;
   int *cs_gpios ;
   struct dma_chan *dma_tx ;
   struct dma_chan *dma_rx ;
   void *dummy_rx ;
   void *dummy_tx ;
};

#line 506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_transfer {
   void const *tx_buf ;
   void *rx_buf ;
   unsigned int len ;
   dma_addr_t tx_dma ;
   dma_addr_t rx_dma ;
   struct sg_table tx_sg ;
   struct sg_table rx_sg ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cs_change : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) tx_nbits : 3 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) rx_nbits : 3 ;
   u8 bits_per_word ;
   u16 delay_usecs ;
   u32 speed_hz ;
   struct list_head transfer_list ;
};

#line 630  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_message {
   struct list_head transfers ;
   struct spi_device *spi ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_dma_mapped : 1 ;
   void (*complete)(void *) ;
   void *context ;
   unsigned int frame_length ;
   unsigned int actual_length ;
   int status ;
   struct list_head queue ;
   void *state ;
};

#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
typedef unsigned long pthread_t;

#line 22  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
union pthread_attr_t {
   char __size[56U] ;
   long __align ;
};

#line 29  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
typedef union pthread_attr_t pthread_attr_t;

#line 338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/platform_device.h"
struct ldv_struct_character_driver_scenario_15 {
   struct file_operations *arg0 ;
   int signal_pending ;
};

#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_free_irq_5 {
   int arg0 ;
   int signal_pending ;
};

#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_ieee80211_scenario_19 {
   struct ieee80211_hw *arg0 ;
   int signal_pending ;
};

#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_interrupt_scenario_35 {
   enum irqreturn (*arg2)(int , void *) ;
   enum irqreturn (*arg1)(int , void *) ;
   void *arg3 ;
   int arg0 ;
   int signal_pending ;
};

#line 41  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_pci_scenario_17 {
   struct pci_driver *arg0 ;
   int signal_pending ;
};

#line 46  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_platform_instance_33 {
   struct platform_driver *arg0 ;
   int signal_pending ;
};

#line 51  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_timer_scenario_21 {
   struct timer_list *arg0 ;
   int signal_pending ;
};
void __builtin_unreachable(void);


#line 7  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/fvtp/.tmp_beacon.c"
void ldv_inline_asm(void);


#line 7  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_beacon.c.aux"
void ldv_atomic_inc(atomic_t *v);


#line 8 
void ldv_atomic_dec(atomic_t *v);


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr, unsigned long volatile *addr)
{
  
#line 74 
  if (0 != 0) 
#line 76 
              ldv_inline_asm(); else 
#line 79 
                                     ldv_inline_asm();
  
#line 80 
  return;
}


#line 308  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr, unsigned long const volatile *addr)
{
  int __retres;
  
#line 311 
  __retres = ((*(addr + (nr >> 6)) >> (nr & 63L)) & 1UL) != 0UL;
  
#line 311 
  return __retres;
}


#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
void __list_add(struct list_head *, struct list_head *, struct list_head *);


#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void list_add_tail(struct list_head *new, struct list_head *head)
{
  
#line 77 
  __list_add(new,head->prev,head);
  
#line 78 
  return;
}


#line 113 
void list_del(struct list_head *);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/page_64.h"
unsigned long __phys_addr(unsigned long);


#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
void *memset(void *, int, size_t);


#line 98  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/atomic.h"
static void atomic_inc(atomic_t *v);


#line 114 
static void atomic_dec(atomic_t *v);


#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_api_smp.h"
void _raw_spin_lock_bh(raw_spinlock_t *);


#line 42 
void _raw_spin_unlock_bh(raw_spinlock_t *);


#line 45 
void _raw_spin_unlock_irqrestore(raw_spinlock_t *, unsigned long);


#line 355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_bh(spinlock_t *lock)
{
  
#line 357 
  _raw_spin_lock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 358 
  return;
}


#line 383 
static void ldv_spin_lock_bh_72(spinlock_t *lock);


#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_bh(spinlock_t *lock)
{
  
#line 406 
  _raw_spin_unlock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 407 
  return;
}


#line 432 
static void ldv_spin_unlock_bh_73(spinlock_t *lock);


#line 446  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
{
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
  }
  
#line 448 
  _raw_spin_unlock_irqrestore(& lock->__anonCompField_spinlock_18.rlock,flags);
  
#line 449 
  return;
}


#line 478 
static void ldv_spin_unlock_irqrestore_75(spinlock_t *lock, unsigned long flags);


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_beacon.c.aux"
void __ldv_spin_lock(spinlock_t *);


#line 70 
static void ldv___ldv_spin_lock_74(spinlock_t *ldv_func_arg1);


#line 78 
void ldv_spin_model_lock(char *);


#line 79 
void ldv_spin_model_unlock(char *);


#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction)
{
  int __retres;
  
#line 76 
  __retres = (unsigned int)dma_direction <= 2U;
  
#line 76 
  return __retres;
}


#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address, unsigned int n)
{
  
#line 133 
  return;
}


#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-debug.h"
void debug_dma_map_page(struct device *, struct page *, size_t, size_t, int, dma_addr_t, bool);


#line 42 
void debug_dma_mapping_error(struct device *, dma_addr_t);


#line 44 
void debug_dma_unmap_page(struct device *, dma_addr_t, size_t, int, bool);


#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
extern struct dma_map_ops *dma_ops;


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev)
{
  struct dma_map_ops *__retres;
  
#line 37 
  if ((long)(dev == (struct device *)0) != 0L || dev->archdata.dma_ops == (struct dma_map_ops *)0) {
    
#line 38 
    __retres = dma_ops;
    
#line 38 
    goto return_label;
  }
  else {
    
#line 40 
    __retres = dev->archdata.dma_ops;
    
#line 40 
    goto return_label;
  }
  return_label: 
#line 37 
                return __retres;
}


#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_single_attrs(struct device *dev, void *ptr, size_t size, enum dma_data_direction dir, struct dma_attrs *attrs)
{
  dma_addr_t addr;
  int tmp_0;
  unsigned long tmp_1;
  unsigned long tmp_2;
  
#line 15 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 18 
  kmemcheck_mark_initialized(ptr,(unsigned int)size);
  
#line 19 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 19 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 21 
    ldv_inline_asm();
    
#line 19 
    ;
  }
  else ;
  
#line 20 
  ;
  
#line 20 
  ;
  
#line 20 
  ;
  
#line 20 
  ;
  
#line 20 
  tmp_1 = __phys_addr((unsigned long)ptr);
  
#line 20 
  ;
  
#line 20 
  addr = (*(ops->map_page))(dev,(struct page *)(-24189255811072) + (tmp_1 >> 12),(unsigned long)ptr & 4095UL,size,dir,attrs);
  
#line 23 
  ;
  
#line 23 
  ;
  
#line 23 
  ;
  
#line 23 
  ;
  
#line 23 
  tmp_2 = __phys_addr((unsigned long)ptr);
  
#line 23 
  ;
  
#line 23 
  debug_dma_map_page(dev,(struct page *)(-24189255811072) + (tmp_2 >> 12),(unsigned long)ptr & 4095UL,size,(int)dir,addr,(_Bool)1);
  
#line 26 
  return addr;
}


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_single_attrs(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir, struct dma_attrs *attrs)
{
  int tmp_0;
  
#line 34 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 36 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 36 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 38 
    ldv_inline_asm();
    
#line 36 
    ;
  }
  else ;
  
#line 37 
  if (ops->unmap_page != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction , struct dma_attrs *))0) 
    
#line 38 
    (*(ops->unmap_page))(dev,addr,size,dir,attrs); else ;
  
#line 39 
  debug_dma_unmap_page(dev,addr,size,(int)dir,(_Bool)1);
  
#line 40 
  return;
}


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
__inline static int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
  int __retres;
  
#line 49 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 50 
  debug_dma_mapping_error(dev,dma_addr);
  
#line 51 
  if (ops->mapping_error != (int (*)(struct device *, dma_addr_t ))0) {
    int tmp_0;
    
#line 52 
    tmp_0 = (*(ops->mapping_error))(dev,dma_addr);
    
#line 52 
    __retres = tmp_0;
    
#line 52 
    goto return_label;
  }
  else ;
  
#line 54 
  __retres = dma_addr == 0ULL;
  return_label: 
#line 54 
                return __retres;
}


#line 519  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
__inline static void tasklet_unlock_wait(struct tasklet_struct *t)
{
  int tmp;
  
#line 521 
  goto ldv_36552;
  ldv_36551: 
#line 522 
  ;
  
#line 523 
  ldv_inline_asm();
  ldv_36552: 
#line 524 
  ;
  
#line 521 
  tmp = constant_test_bit(1L,(unsigned long const volatile *)(& t->state));
  
#line 521 
  if (tmp != 0) 
#line 523 
                goto ldv_36551; else 
#line 526 
                                     goto ldv_36553;
  ldv_36553: 
#line 527 
  ;
  
#line 528 
  return;
}


#line 560  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
__inline static void tasklet_disable_nosync(struct tasklet_struct *t)
{
  
#line 562 
  atomic_inc(& t->count);
  
#line 563 
  ldv_inline_asm();
  
#line 564 
  return;
}


#line 566  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
__inline static void tasklet_disable(struct tasklet_struct *t)
{
  
#line 568 
  tasklet_disable_nosync(t);
  
#line 569 
  tasklet_unlock_wait(t);
  
#line 570 
  ldv_inline_asm();
  
#line 571 
  return;
}


#line 573  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
__inline static void tasklet_enable(struct tasklet_struct *t)
{
  
#line 575 
  ldv_inline_asm();
  
#line 576 
  atomic_dec(& t->count);
  
#line 577 
  return;
}


#line 2900  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
void __dev_kfree_skb_any(struct sk_buff *, enum skb_free_reason);


#line 2931  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void dev_kfree_skb_any(struct sk_buff *skb)
{
  
#line 2933 
  __dev_kfree_skb_any(skb,(enum skb_free_reason)SKB_REASON_DROPPED);
  
#line 2934 
  return;
}


#line 918  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
__inline static struct ieee80211_tx_info *IEEE80211_SKB_CB(struct sk_buff *skb)
{
  struct ieee80211_tx_info *__retres;
  
#line 920 
  __retres = (struct ieee80211_tx_info *)(& skb->cb);
  
#line 920 
  return __retres;
}


#line 4020 
struct sk_buff *ieee80211_beacon_get_tim(struct ieee80211_hw *, struct ieee80211_vif *, u16 *, u16 *);


#line 4033  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
__inline static struct sk_buff *ieee80211_beacon_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
{
  struct sk_buff *tmp;
  
#line 4036 
  tmp = ieee80211_beacon_get_tim(hw,vif,(u16 *)0U,(u16 *)0U);
  
#line 4036 
  return tmp;
}


#line 4061 
void ieee80211_csa_finish(struct ieee80211_vif *);


#line 4069 
bool ieee80211_csa_is_complete(struct ieee80211_vif *);


#line 4254 
struct sk_buff *ieee80211_get_buffered_bc(struct ieee80211_hw *, struct ieee80211_vif *);


#line 4615 
void ieee80211_iterate_active_interfaces_atomic(struct ieee80211_hw *, u32, void (*)(void *, u8 *, struct ieee80211_vif *), void *);


#line 212  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath.h"
void ath_printk(char const *, struct ath_common const *, char const * , ...);


#line 715  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mac.h"
void ath9k_hw_puttxbuf(struct ath_hw *, u32, u32);


#line 716 
void ath9k_hw_txstart(struct ath_hw *, u32);


#line 717 
u32 ath9k_hw_numtxpending(struct ath_hw *, u32);


#line 719 
bool ath9k_hw_stop_dma_queue(struct ath_hw *, u32);


#line 721 
bool ath9k_hw_set_txq_props(struct ath_hw *, int, struct ath9k_tx_queue_info const *);


#line 723 
bool ath9k_hw_get_txq_props(struct ath_hw *, int, struct ath9k_tx_queue_info *);


#line 728 
bool ath9k_hw_resettxqueue(struct ath_hw *, u32);


#line 743 
void ath9k_hw_set_interrupts(struct ath_hw *);


#line 744 
void ath9k_hw_enable_interrupts(struct ath_hw *);


#line 745 
void ath9k_hw_disable_interrupts(struct ath_hw *);


#line 116  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/calib.h"
void ath9k_hw_bstuck_nfcal(struct ath_hw *);


#line 988  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
__inline static struct ath_common *ath9k_hw_common(struct ath_hw *ah)
{
  struct ath_common *__retres;
  
#line 990 
  __retres = & ah->common;
  
#line 990 
  return __retres;
}


#line 1003  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
__inline static struct ath_hw_ops *ath9k_hw_ops(struct ath_hw *ah)
{
  struct ath_hw_ops *__retres;
  
#line 1005 
  __retres = & ah->ops;
  
#line 1005 
  return __retres;
}


#line 1053 
u64 ath9k_hw_gettsf64(struct ath_hw *);


#line 1055 
void ath9k_hw_reset_tsf(struct ath_hw *);


#line 1058 
void ath9k_hw_init_global_settings(struct ath_hw *);


#line 1061 
void ath9k_hw_beaconinit(struct ath_hw *, u32, u32);


#line 1062 
void ath9k_hw_set_sta_beacon_timers(struct ath_hw *, struct ath9k_beacon_state const *);


#line 1064 
void ath9k_hw_check_nav(struct ath_hw *);


#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw-ops.h"
__inline static void ath9k_hw_set_txdesc(struct ath_hw *ah, void *ds, struct ath_tx_info *i)
{
  struct ath_hw_ops *tmp_0;
  
#line 60 
  tmp_0 = ath9k_hw_ops(ah);
  
#line 60 
  (*(tmp_0->set_txdesc))(ah,ds,i);
  
#line 61 
  return;
}


#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/common-beacon.h"
int ath9k_cmn_beacon_config_sta(struct ath_hw *, struct ath_beacon_config *, struct ath9k_beacon_state *);


#line 22 
void ath9k_cmn_beacon_config_adhoc(struct ath_hw *, struct ath_beacon_config *);


#line 24 
void ath9k_cmn_beacon_config_ap(struct ath_hw *, struct ath_beacon_config *, unsigned int);


#line 446  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
bool ath9k_is_chanctx_enabled(void);


#line 458 
void ath9k_beacon_add_noa(struct ath_softc *sc, struct ath_vif *avp, struct sk_buff *skb);


#line 467 
void ath_chanctx_beacon_sent_ev(struct ath_softc *sc, enum ath_chanctx_event ev);


#line 469 
void ath_chanctx_event(struct ath_softc *sc, struct ieee80211_vif *vif, enum ath_chanctx_event ev);


#line 560 
void ath_draintxq(struct ath_softc *sc, struct ath_txq *txq);


#line 569 
void ath_assign_seq(struct ath_common *common, struct sk_buff *skb);


#line 572 
void ath_tx_cabq(struct ieee80211_hw *hw, struct ieee80211_vif *vif, struct sk_buff *skb);


#line 687 
void ath9k_beacon_tasklet(unsigned long data);


#line 688 
void ath9k_beacon_config(struct ath_softc *sc, struct ieee80211_vif *vif, u32 changed);


#line 690 
void ath9k_beacon_assign_slot(struct ath_softc *sc, struct ieee80211_vif *vif);


#line 691 
void ath9k_beacon_remove_slot(struct ath_softc *sc, struct ieee80211_vif *vif);


#line 692 
void ath9k_set_beacon(struct ath_softc *sc);


#line 693 
bool ath9k_csa_is_finished(struct ath_softc *sc, struct ieee80211_vif *vif);


#line 694 
void ath9k_csa_update(struct ath_softc *sc);


#line 713 
bool ath_hw_check(struct ath_softc *sc);


#line 722 
void ath9k_queue_reset(struct ath_softc *sc, enum ath_reset_type type);


#line 1082 
u8 ath_txchainmask_reduction(struct ath_softc *sc, u8 chainmask, u32 rate);


#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/beacon.c"
static void ath9k_reset_beacon_status(struct ath_softc *sc)
{
  
#line 24 
  sc->beacon.tx_processed = (_Bool)0;
  
#line 25 
  sc->beacon.tx_last = (_Bool)0;
  
#line 26 
  return;
}


#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/beacon.c"
static void ath9k_beaconq_config(struct ath_softc *sc)
{
  struct ath9k_tx_queue_info qi;
  struct ath9k_tx_queue_info qi_be;
  struct ath_txq *txq;
  int tmp_1;
  bool tmp_0;
  
#line 35 
  struct ath_hw *ah = sc->sc_ah;
  
#line 36 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 40 
  ath9k_hw_get_txq_props(ah,(int)sc->beacon.beaconq,& qi);
  
#line 42 
  if ((sc->sc_ah)->opmode == (unsigned int)NL80211_IFTYPE_AP || (sc->sc_ah)->opmode == (unsigned int)NL80211_IFTYPE_MESH_POINT) {
    
#line 45 
    qi.tqi_aifs = 1U;
    
#line 46 
    qi.tqi_cwmin = 0U;
    
#line 47 
    qi.tqi_cwmax = 0U;
  }
  else {
    
#line 50 
    txq = sc->tx.txq_map[2];
    
#line 51 
    ath9k_hw_get_txq_props(ah,(int)txq->axq_qnum,& qi_be);
    
#line 52 
    qi.tqi_aifs = qi_be.tqi_aifs;
    
#line 53 
    if (ah->slottime == 20U) 
#line 54 
                             qi.tqi_cwmin = qi_be.tqi_cwmin * 2U; else 
                                                                    
#line 56 
                                                                    qi.tqi_cwmin = qi_be.tqi_cwmin * 4U;
    
#line 57 
    qi.tqi_cwmax = qi_be.tqi_cwmax;
  }
  
#line 60 
  tmp_0 = ath9k_hw_set_txq_props(ah,(int)sc->beacon.beaconq,(struct ath9k_tx_queue_info const *)(& qi));
  
#line 60 
  if (tmp_0) 
#line 60 
             tmp_1 = 0; else 
#line 60 
                             tmp_1 = 1;
  
#line 60 
  if (tmp_1) 
#line 61 
             ath_printk("\001",(struct ath_common const *)common,"Unable to update h/w beacon queue parameters\n"); else 
                                                                    
#line 63 
                                                                    ath9k_hw_resettxqueue(ah,sc->beacon.beaconq);
  
#line 64 
  return;
}


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/beacon.c"
static void ath9k_beacon_setup(struct ath_softc *sc, struct ieee80211_vif *vif, struct ath_buf *bf, int rateidx)
{
  struct ath_tx_info info;
  struct ieee80211_supported_band *sband;
  u8 i;
  unsigned int tmp_0;
  u8 tmp_1;
  
#line 75 
  struct sk_buff *skb = bf->bf_mpdu;
  
#line 76 
  struct ath_hw *ah = sc->sc_ah;
  
#line 77 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 80 
  u8 chainmask = ah->txchainmask;
  
#line 81 
  u8 rate = (unsigned char)0U;
  
#line 83 
  sband = & common->sbands[(unsigned int)(sc->cur_chandef.chan)->band];
  
#line 84 
  rate = (unsigned char)(sband->bitrates + rateidx)->hw_value;
  
#line 85 
  if ((int)vif->bss_conf.use_short_preamble != 0) 
#line 86 
                                                  rate = (unsigned char)((int)((unsigned char)(sband->bitrates + rateidx)->hw_value_short) | (int)rate); else ;
  
#line 88 
  memset((void *)(& info),0,184UL);
  
#line 89 
  info.pkt_len = (int)(skb->len + 4U);
  
#line 90 
  info.type = ATH9K_PKT_TYPE_BEACON;
  
#line 91 
  i = (unsigned char)0U;
  
#line 91 
  goto ldv_53384;
  ldv_53383: 
#line 92 
  ;
  
#line 92 
  info.txpower[(int)i] = (unsigned char)63U;
  
#line 91 
  i = (u8)((int)i + 1);
  ldv_53384: 
#line 92 
  ;
  
#line 91 
  if ((unsigned int)i <= 3U) 
#line 93 
                             goto ldv_53383; else 
#line 96 
                                                  goto ldv_53385;
  ldv_53385: 
#line 97 
  ;
  
#line 93 
  info.keyix = (unsigned char)255U;
  
#line 94 
  info.keytype = ATH9K_KEY_TYPE_CLEAR;
  
#line 95 
  info.flags = 4098U;
  
#line 97 
  info.buf_addr[0] = bf->bf_buf_addr;
  {
    
#line 98 
    int const __y = 4;
    
#line 98 
    tmp_0 = (skb->len + 3U) & 4294967292U;
  }
  
#line 98 
  info.buf_len[0] = (int)tmp_0;
  
#line 100 
  info.is_first = (_Bool)1;
  
#line 101 
  info.is_last = (_Bool)1;
  
#line 103 
  info.qcu = (unsigned char)sc->beacon.beaconq;
  
#line 105 
  info.rates[0].Tries = 1U;
  
#line 106 
  info.rates[0].Rate = (unsigned int)rate;
  
#line 107 
  tmp_1 = ath_txchainmask_reduction(sc,(unsigned char)((int)chainmask),(unsigned int)rate);
  
#line 107 
  info.rates[0].ChSel = (unsigned int)tmp_1;
  
#line 109 
  ath9k_hw_set_txdesc(ah,bf->bf_desc,& info);
  
#line 110 
  return;
}


#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/beacon.c"
static struct ath_buf *ath9k_beacon_generate(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
{
  struct ath_buf *__retres;
  struct ath_buf *bf;
  struct sk_buff *skb;
  struct ieee80211_tx_info *info;
  struct ieee80211_mgmt *mgmt_hdr;
  int cabq_depth;
  int tmp_0;
  
#line 115 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 116 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 118 
  struct ath_vif *avp = (struct ath_vif *)(& vif->drv_priv);
  
#line 120 
  struct ath_txq *cabq = sc->beacon.cabq;
  
#line 125 
  if (avp->av_bcbuf == (struct ath_buf *)0) {
    
#line 126 
    __retres = (struct ath_buf *)0;
    
#line 126 
    goto return_label;
  }
  else ;
  
#line 128 
  bf = avp->av_bcbuf;
  
#line 129 
  skb = bf->bf_mpdu;
  
#line 130 
  if (skb != (struct sk_buff *)0) {
    
#line 131 
    dma_unmap_single_attrs(sc->dev,bf->bf_buf_addr,(unsigned long)skb->len,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
    
#line 133 
    dev_kfree_skb_any(skb);
    
#line 134 
    bf->bf_buf_addr = 0ULL;
    
#line 135 
    bf->bf_mpdu = (struct sk_buff *)0;
  }
  else ;
  
#line 138 
  skb = ieee80211_beacon_get(hw,vif);
  
#line 139 
  if (skb == (struct sk_buff *)0) {
    
#line 140 
    __retres = (struct ath_buf *)0;
    
#line 140 
    goto return_label;
  }
  else ;
  
#line 142 
  bf->bf_mpdu = skb;
  
#line 144 
  mgmt_hdr = (struct ieee80211_mgmt *)skb->data;
  
#line 145 
  mgmt_hdr->u.beacon.timestamp = avp->tsf_adjust;
  
#line 147 
  info = IEEE80211_SKB_CB(skb);
  
#line 149 
  ath_assign_seq(common,skb);
  
#line 151 
  if ((int)vif->p2p != 0) 
#line 152 
                          ath9k_beacon_add_noa(sc,avp,skb); else ;
  
#line 154 
  bf->bf_buf_addr = dma_map_single_attrs(sc->dev,(void *)skb->data,(unsigned long)skb->len,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
  
#line 156 
  tmp_0 = dma_mapping_error(sc->dev,bf->bf_buf_addr);
  
#line 156 
  if ((long)(tmp_0 != 0) != 0L) {
    
#line 157 
    dev_kfree_skb_any(skb);
    
#line 158 
    bf->bf_mpdu = (struct sk_buff *)0;
    
#line 159 
    bf->bf_buf_addr = 0ULL;
    
#line 160 
    ath_printk("\001",(struct ath_common const *)common,"dma_mapping_error on beaconing\n");
    
#line 161 
    __retres = (struct ath_buf *)0;
    
#line 161 
    goto return_label;
  }
  else ;
  
#line 164 
  skb = ieee80211_get_buffered_bc(hw,vif);
  
#line 174 
  ldv_spin_lock_bh_72(& cabq->axq_lock);
  
#line 175 
  cabq_depth = (int)cabq->axq_depth;
  
#line 176 
  ldv_spin_unlock_bh_73(& cabq->axq_lock);
  
#line 178 
  if (skb != (struct sk_buff *)0 && cabq_depth != 0) {
    
#line 179 
    if ((int)(sc->cur_chan)->nvifs > 1) {
      
#line 180 
      if ((common->debug_mask & 256) != 0) 
#line 180 
                                           ath_printk("\001",(struct ath_common const *)common,"Flushing previous cabq traffic\n"); else ;
      
#line 182 
      ath_draintxq(sc,cabq);
    }
    else ;
  }
  else ;
  
#line 186 
  ath9k_beacon_setup(sc,vif,bf,(int)info->__anonCompField_ieee80211_tx_info_98.control.__anonCompField___anonstruct_control_358_96.__anonCompField___anonunion_359_95.rates[0].idx);
  
#line 188 
  if (skb != (struct sk_buff *)0) 
#line 189 
                                  ath_tx_cabq(hw,vif,skb); else ;
  
#line 191 
  __retres = bf;
  return_label: 
#line 191 
                return __retres;
}


#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/beacon.c"
void ath9k_beacon_assign_slot(struct ath_softc *sc, struct ieee80211_vif *vif)
{
  int slot;
  struct ath_buf *tmp_0;
  
#line 196 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 197 
  struct ath_vif *avp = (struct ath_vif *)(& vif->drv_priv);
  {
    
#line 200 
    struct list_head const *__mptr = (struct list_head const *)sc->beacon.bbuf.next;
    
#line 200 
    tmp_0 = (struct ath_buf *)__mptr;
  }
  
#line 200 
  avp->av_bcbuf = tmp_0;
  
#line 201 
  list_del(& (avp->av_bcbuf)->list);
  
#line 203 
  slot = 0;
  
#line 203 
  goto ldv_53412;
  ldv_53411: 
#line 204 
  ;
  
#line 204 
  if (sc->beacon.bslot[slot] == (struct ieee80211_vif *)0) {
    
#line 205 
    avp->av_bslot = slot;
    
#line 206 
    goto ldv_53410;
  }
  else ;
  
#line 203 
  slot += 1;
  ldv_53412: 
#line 204 
  ;
  
#line 203 
  if (slot <= 7) 
#line 205 
                 goto ldv_53411; else 
#line 208 
                                      goto ldv_53410;
  ldv_53410: 
#line 209 
  ;
  
#line 210 
  sc->beacon.bslot[avp->av_bslot] = vif;
  
#line 211 
  sc->nbcnvifs = (short)((int)sc->nbcnvifs + 1);
  
#line 213 
  if ((common->debug_mask & 512) != 0) 
#line 213 
                                       ath_printk("\001",(struct ath_common const *)common,"Added interface at beacon slot: %d\n",avp->av_bslot); else ;
  
#line 214 
  return;
}


#line 217  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/beacon.c"
void ath9k_beacon_remove_slot(struct ath_softc *sc, struct ieee80211_vif *vif)
{
  
#line 219 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 220 
  struct ath_vif *avp = (struct ath_vif *)(& vif->drv_priv);
  
#line 221 
  struct ath_buf *bf = avp->av_bcbuf;
  
#line 222 
  struct ath_beacon_config *cur_conf = & (sc->cur_chan)->beacon;
  
#line 224 
  if ((common->debug_mask & 512) != 0) 
#line 224 
                                       ath_printk("\001",(struct ath_common const *)common,"Removing interface at beacon slot: %d\n",avp->av_bslot); else ;
  
#line 227 
  tasklet_disable(& sc->bcon_tasklet);
  
#line 229 
  cur_conf->enable_beacon = (unsigned char)((int)cur_conf->enable_beacon & ~ ((int)((unsigned char)(1UL << avp->av_bslot))));
  
#line 231 
  if (bf != (struct ath_buf *)0 && bf->bf_mpdu != (struct sk_buff *)0) {
    
#line 232 
    struct sk_buff *skb = bf->bf_mpdu;
    
#line 233 
    dma_unmap_single_attrs(sc->dev,bf->bf_buf_addr,(unsigned long)skb->len,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
    
#line 235 
    dev_kfree_skb_any(skb);
    
#line 236 
    bf->bf_mpdu = (struct sk_buff *)0;
    
#line 237 
    bf->bf_buf_addr = 0ULL;
  }
  else ;
  
#line 240 
  avp->av_bcbuf = (struct ath_buf *)0;
  
#line 241 
  sc->beacon.bslot[avp->av_bslot] = (struct ieee80211_vif *)0;
  
#line 242 
  sc->nbcnvifs = (short)((int)sc->nbcnvifs - 1);
  
#line 243 
  list_add_tail(& bf->list,& sc->beacon.bbuf);
  
#line 245 
  tasklet_enable(& sc->bcon_tasklet);
  
#line 246 
  return;
}


#line 248  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/beacon.c"
static int ath9k_beacon_choose_slot(struct ath_softc *sc)
{
  int __retres;
  u16 intval;
  u32 tsftu;
  u64 tsf;
  int slot;
  
#line 250 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 251 
  struct ath_beacon_config *cur_conf = & (sc->cur_chan)->beacon;
  
#line 257 
  if ((sc->sc_ah)->opmode != (unsigned int)NL80211_IFTYPE_AP && (sc->sc_ah)->opmode != (unsigned int)NL80211_IFTYPE_MESH_POINT) {
    
#line 259 
    if ((common->debug_mask & 256) != 0) {
      u64 tmp_0;
      
#line 259 
      tmp_0 = ath9k_hw_gettsf64(sc->sc_ah);
      
#line 259 
      ;
      
#line 259 
      ath_printk("\001",(struct ath_common const *)common,"slot 0, tsf: %llu\n",tmp_0);
    }
    else ;
    
#line 261 
    __retres = 0;
    
#line 261 
    goto return_label;
  }
  else ;
  
#line 264 
  if (cur_conf->beacon_interval != 0) 
#line 264 
                                      intval = (unsigned short)cur_conf->beacon_interval; else 
                                                                    
#line 264 
                                                                    intval = (unsigned short)100U;
  
#line 265 
  tsf = ath9k_hw_gettsf64(sc->sc_ah);
  
#line 266 
  tsf = (unsigned long long)((sc->sc_ah)->config.sw_beacon_response_time << 10) + tsf;
  
#line 267 
  tsftu = ((unsigned int)(tsf * 8ULL >> 32) << 22) | ((unsigned int)tsf * 8U >> 10);
  
#line 268 
  slot = (int)((tsftu % (unsigned int)((int)intval * 8)) / (unsigned int)intval);
  
#line 270 
  if ((common->debug_mask & 256) != 0) 
#line 270 
                                       ath_printk("\001",(struct ath_common const *)common,"slot: %d tsf: %llu tsftu: %u\n",slot,tsf,tsftu / 8U); else ;
  
#line 273 
  __retres = slot;
  return_label: 
#line 273 
                return __retres;
}


#line 276  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/beacon.c"
static void ath9k_set_tsfadjust(struct ath_softc *sc, struct ieee80211_vif *vif)
{
  u32 tsfadjust;
  
#line 278 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 279 
  struct ath_vif *avp = (struct ath_vif *)(& vif->drv_priv);
  
#line 280 
  struct ath_beacon_config *cur_conf = & (avp->chanctx)->beacon;
  
#line 283 
  if (avp->av_bslot == 0) 
#line 284 
                          goto return_label; else ;
  
#line 286 
  tsfadjust = (unsigned int)(cur_conf->beacon_interval * avp->av_bslot);
  
#line 287 
  tsfadjust = (tsfadjust << 10) / 8U;
  
#line 288 
  avp->tsf_adjust = (unsigned long long)tsfadjust;
  
#line 290 
  if ((common->debug_mask & 512) != 0) 
#line 290 
                                       ath_printk("\001",(struct ath_common const *)common,"tsfadjust is: %llu for bslot: %d\n",(unsigned long long)tsfadjust,avp->av_bslot); else ;
  return_label: 
#line 291 
                return;
}


#line 294  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/beacon.c"
bool ath9k_csa_is_finished(struct ath_softc *sc, struct ieee80211_vif *vif)
{
  bool __retres;
  int tmp_0;
  bool tmp;
  
#line 296 
  if (vif == (struct ieee80211_vif *)0 || ! vif->csa_active) {
    
#line 297 
    __retres = (_Bool)0;
    
#line 297 
    goto return_label;
  }
  else ;
  
#line 299 
  tmp = ieee80211_csa_is_complete(vif);
  
#line 299 
  if (tmp) 
#line 299 
           tmp_0 = 0; else 
#line 299 
                           tmp_0 = 1;
  
#line 299 
  if (tmp_0) {
    
#line 300 
    __retres = (_Bool)0;
    
#line 300 
    goto return_label;
  }
  else ;
  
#line 302 
  ieee80211_csa_finish(vif);
  
#line 303 
  __retres = (_Bool)1;
  return_label: 
#line 303 
                return __retres;
}


#line 306  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/beacon.c"
static void ath9k_csa_update_vif(void *data, u8 *mac, struct ieee80211_vif *vif)
{
  
#line 308 
  struct ath_softc *sc = (struct ath_softc *)data;
  
#line 309 
  ath9k_csa_is_finished(sc,vif);
  
#line 310 
  return;
}


#line 312  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/beacon.c"
void ath9k_csa_update(struct ath_softc *sc)
{
  
#line 314 
  ieee80211_iterate_active_interfaces_atomic(sc->hw,0U,& ath9k_csa_update_vif,(void *)sc);
  
#line 317 
  return;
}


#line 319  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/beacon.c"
void ath9k_beacon_tasklet(unsigned long data)
{
  struct ieee80211_vif *vif;
  int slot;
  int tmp_0;
  u32 tmp_3;
  bool tmp_6;
  
#line 321 
  struct ath_softc *sc = (struct ath_softc *)data;
  
#line 322 
  struct ath_hw *ah = sc->sc_ah;
  
#line 323 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 324 
  struct ath_buf *bf = (struct ath_buf *)0;
  
#line 326 
  bool edma = (_Bool)((ah->caps.hw_caps & 16U) != 0U);
  
#line 329 
  tmp_0 = constant_test_bit(4L,(unsigned long const volatile *)(& common->op_flags));
  
#line 329 
  if (tmp_0 != 0) {
    
#line 330 
    if ((common->debug_mask & 1) != 0) 
#line 330 
                                       ath_printk("\001",(struct ath_common const *)common,"reset work is pending, skip beaconing now\n"); else ;
    
#line 332 
    goto return_label;
  }
  else ;
  
#line 342 
  tmp_3 = ath9k_hw_numtxpending(ah,sc->beacon.beaconq);
  
#line 342 
  if (tmp_3 != 0U) {
    int tmp_2;
    bool tmp_1;
    
#line 343 
    sc->beacon.bmisscnt += 1U;
    
#line 345 
    ath9k_hw_check_nav(ah);
    
#line 353 
    tmp_1 = ath_hw_check(sc);
    
#line 353 
    if (tmp_1) 
#line 353 
               tmp_2 = 0; else 
#line 353 
                               tmp_2 = 1;
    
#line 353 
    if (tmp_2) 
#line 354 
               goto return_label; else ;
    
#line 356 
    if (sc->beacon.bmisscnt < (unsigned int)((int)sc->nbcnvifs * 9)) {
      
#line 357 
      if ((common->debug_mask & 16384) != 0) 
#line 357 
                                             ath_printk("\001",(struct ath_common const *)common,"missed %u consecutive beacons\n",sc->beacon.bmisscnt); else ;
      
#line 360 
      ath9k_hw_stop_dma_queue(ah,sc->beacon.beaconq);
      
#line 361 
      if (sc->beacon.bmisscnt > 3U) 
#line 362 
                                    ath9k_hw_bstuck_nfcal(ah); else ;
    }
    else 
      
#line 363 
      if (sc->beacon.bmisscnt > 8U) {
        
#line 364 
        if ((common->debug_mask & 16384) != 0) 
#line 364 
                                               ath_printk("\001",(struct ath_common const *)common,"beacon is officially stuck\n"); else ;
        
#line 365 
        sc->beacon.bmisscnt = 0U;
        
#line 366 
        ath9k_queue_reset(sc,(enum ath_reset_type)RESET_TYPE_BEACON_STUCK);
      }
      else ;
    
#line 369 
    goto return_label;
  }
  else ;
  
#line 372 
  slot = ath9k_beacon_choose_slot(sc);
  
#line 373 
  vif = sc->beacon.bslot[slot];
  
#line 376 
  if (! edma) {
    bool tmp_4;
    bool tmp_5;
    
#line 377 
    tmp_4 = ath9k_is_chanctx_enabled();
    
#line 377 
    if ((int)tmp_4 != 0) 
#line 378 
                         ath_chanctx_beacon_sent_ev(sc,(enum ath_chanctx_event)ATH_CHANCTX_EVENT_BEACON_SENT); else ;
    
#line 382 
    tmp_5 = ath9k_csa_is_finished(sc,vif);
    
#line 382 
    if ((int)tmp_5 != 0) 
#line 383 
                         goto return_label; else ;
  }
  else ;
  
#line 386 
  if (vif == (struct ieee80211_vif *)0 || ! vif->bss_conf.enable_beacon) 
    
#line 387 
    goto return_label; else ;
  
#line 389 
  tmp_6 = ath9k_is_chanctx_enabled();
  
#line 389 
  if ((int)tmp_6 != 0) 
#line 390 
                       ath_chanctx_event(sc,vif,(enum ath_chanctx_event)ATH_CHANCTX_EVENT_BEACON_PREPARE); else ;
  
#line 393 
  bf = ath9k_beacon_generate(sc->hw,vif);
  
#line 395 
  if (sc->beacon.bmisscnt != 0U) {
    
#line 396 
    if ((common->debug_mask & 16384) != 0) 
#line 396 
                                           ath_printk("\001",(struct ath_common const *)common,"resume beacon xmit after %u misses\n",sc->beacon.bmisscnt); else ;
    
#line 398 
    sc->beacon.bmisscnt = 0U;
  }
  else ;
  
#line 417 
  if (sc->beacon.updateslot == (unsigned int)UPDATE) {
    
#line 418 
    sc->beacon.updateslot = COMMIT;
    
#line 419 
    sc->beacon.slotupdate = slot;
  }
  else 
    
#line 420 
    if (sc->beacon.updateslot == (unsigned int)COMMIT && sc->beacon.slotupdate == slot) {
      
#line 422 
      ah->slottime = (unsigned int)sc->beacon.slottime;
      
#line 423 
      ath9k_hw_init_global_settings(ah);
      
#line 424 
      sc->beacon.updateslot = OK;
    }
    else ;
  
#line 427 
  if (bf != (struct ath_buf *)0) {
    
#line 428 
    ath9k_reset_beacon_status(sc);
    
#line 430 
    if ((common->debug_mask & 256) != 0) 
#line 430 
                                         ath_printk("\001",(struct ath_common const *)common,"Transmitting beacon for slot: %d\n",slot); else ;
    
#line 434 
    ath9k_hw_puttxbuf(ah,sc->beacon.beaconq,(unsigned int)bf->bf_daddr);
    
#line 436 
    if (! edma) 
#line 437 
                ath9k_hw_txstart(ah,sc->beacon.beaconq); else ;
  }
  else ;
  return_label: 
#line 439 
                return;
}


#line 444  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/beacon.c"
static void ath9k_beacon_init(struct ath_softc *sc, u32 nexttbtt, u32 intval, bool reset_tsf)
{
  
#line 447 
  struct ath_hw *ah = sc->sc_ah;
  
#line 449 
  ath9k_hw_disable_interrupts(ah);
  
#line 450 
  if ((int)reset_tsf != 0) 
#line 451 
                           ath9k_hw_reset_tsf(ah); else ;
  
#line 452 
  ath9k_beaconq_config(sc);
  
#line 453 
  ath9k_hw_beaconinit(ah,nexttbtt,intval);
  
#line 454 
  sc->beacon.bmisscnt = 0U;
  
#line 455 
  ath9k_hw_set_interrupts(ah);
  
#line 456 
  ath9k_hw_enable_interrupts(ah);
  
#line 457 
  return;
}


#line 464  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/beacon.c"
static void ath9k_beacon_config_ap(struct ath_softc *sc, struct ath_beacon_config *conf)
{
  
#line 467 
  struct ath_hw *ah = sc->sc_ah;
  
#line 469 
  ath9k_cmn_beacon_config_ap(ah,conf,8U);
  
#line 470 
  ath9k_beacon_init(sc,conf->nexttbtt,conf->intval,(_Bool)0);
  
#line 471 
  return;
}


#line 473  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/beacon.c"
static void ath9k_beacon_config_sta(struct ath_hw *ah, struct ath_beacon_config *conf)
{
  struct ath9k_beacon_state bs;
  int tmp;
  
#line 478 
  tmp = ath9k_cmn_beacon_config_sta(ah,conf,& bs);
  
#line 478 
  if (tmp == -1) 
#line 479 
                 goto return_label; else ;
  
#line 481 
  ath9k_hw_disable_interrupts(ah);
  
#line 482 
  ath9k_hw_set_sta_beacon_timers(ah,(struct ath9k_beacon_state const *)(& bs));
  
#line 483 
  ah->imask = (enum ath9k_int)((unsigned int)ah->imask | 262144U);
  
#line 485 
  ath9k_hw_set_interrupts(ah);
  
#line 486 
  ath9k_hw_enable_interrupts(ah);
  return_label: 
#line 487 
                return;
}


#line 489  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/beacon.c"
static void ath9k_beacon_config_adhoc(struct ath_softc *sc, struct ath_beacon_config *conf)
{
  
#line 492 
  struct ath_hw *ah = sc->sc_ah;
  
#line 493 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 495 
  ath9k_reset_beacon_status(sc);
  
#line 497 
  ath9k_cmn_beacon_config_adhoc(ah,conf);
  
#line 499 
  ath9k_beacon_init(sc,conf->nexttbtt,conf->intval,(_Bool)((bool)((int)conf->ibss_creator) != 0));
  
#line 505 
  if (! conf->ibss_creator && (unsigned int)conf->enable_beacon != 0U) 
    
#line 506 
    set_bit(1L,(unsigned long volatile *)(& common->op_flags)); else ;
  
#line 507 
  return;
}


#line 509  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/beacon.c"
static bool ath9k_allow_beacon_config(struct ath_softc *sc, struct ieee80211_vif *vif)
{
  bool __retres;
  bool tmp_0;
  
#line 512 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 513 
  struct ath_vif *avp = (struct ath_vif *)(& vif->drv_priv);
  
#line 515 
  tmp_0 = ath9k_is_chanctx_enabled();
  
#line 515 
  if ((int)tmp_0 != 0) {
    
#line 522 
    if (sc->cur_chan != avp->chanctx) {
      
#line 523 
      __retres = (_Bool)1;
      
#line 523 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 526 
  if ((sc->sc_ah)->opmode == (unsigned int)NL80211_IFTYPE_AP) {
    
#line 527 
    if (vif->type != (unsigned int)NL80211_IFTYPE_AP) {
      
#line 528 
      if ((common->debug_mask & 512) != 0) 
#line 528 
                                           ath_printk("\001",(struct ath_common const *)common,"An AP interface is already present !\n"); else ;
      
#line 530 
      __retres = (_Bool)0;
      
#line 530 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 534 
  if ((sc->sc_ah)->opmode == (unsigned int)NL80211_IFTYPE_STATION) {
    
#line 535 
    if (vif->type == (unsigned int)NL80211_IFTYPE_STATION) {
      int tmp_1;
      
#line 535 
      tmp_1 = constant_test_bit(1L,(unsigned long const volatile *)(& common->op_flags));
      
#line 535 
      if (tmp_1 != 0) {
        
#line 536 
        if ((sc->cur_chan)->primary_sta != vif) {
          
#line 538 
          if ((common->debug_mask & 512) != 0) 
#line 538 
                                               ath_printk("\001",(struct ath_common const *)common,"Beacon already configured for a station interface\n"); else ;
          
#line 540 
          __retres = (_Bool)0;
          
#line 540 
          goto return_label;
        }
        else ;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 544 
  __retres = (_Bool)1;
  return_label: 
#line 544 
                return __retres;
}


#line 547  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/beacon.c"
static void ath9k_cache_beacon_config(struct ath_softc *sc, struct ath_chanctx *ctx, struct ieee80211_bss_conf *bss_conf)
{
  
#line 551 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 552 
  struct ath_beacon_config *cur_conf = & ctx->beacon;
  
#line 554 
  if ((common->debug_mask & 256) != 0) 
#line 554 
                                       ath_printk("\001",(struct ath_common const *)common,"Caching beacon data for BSS: %pM\n",bss_conf->bssid); else ;
  
#line 557 
  cur_conf->beacon_interval = (int)bss_conf->beacon_int;
  
#line 558 
  cur_conf->dtim_period = (unsigned short)bss_conf->dtim_period;
  
#line 559 
  cur_conf->dtim_count = (unsigned char)1U;
  
#line 560 
  cur_conf->ibss_creator = bss_conf->ibss_creator;
  
#line 568 
  if (cur_conf->beacon_interval == 0) 
#line 569 
                                      cur_conf->beacon_interval = 100; else ;
  
#line 571 
  cur_conf->bmiss_timeout = (unsigned short)((unsigned int)((unsigned short)cur_conf->beacon_interval) * 10U);
  
#line 579 
  if ((unsigned int)cur_conf->dtim_period == 0U) 
#line 580 
                                                 cur_conf->dtim_period = (unsigned short)1U; else ;
  
#line 581 
  return;
}


#line 584  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/beacon.c"
void ath9k_beacon_config(struct ath_softc *sc, struct ieee80211_vif *vif, u32 changed)
{
  struct ath_beacon_config *cur_conf;
  unsigned long flags;
  int tmp_1;
  bool tmp_0;
  
#line 587 
  struct ieee80211_bss_conf *bss_conf = & vif->bss_conf;
  
#line 588 
  struct ath_hw *ah = sc->sc_ah;
  
#line 589 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 590 
  struct ath_vif *avp = (struct ath_vif *)(& vif->drv_priv);
  
#line 591 
  struct ath_chanctx *ctx = avp->chanctx;
  
#line 594 
  bool skip_beacon = (_Bool)0;
  
#line 596 
  if (ctx == (struct ath_chanctx *)0) 
#line 597 
                                      goto return_label; else ;
  
#line 599 
  cur_conf = & (avp->chanctx)->beacon;
  
#line 600 
  if (vif->type == (unsigned int)NL80211_IFTYPE_AP) 
#line 601 
                                                    ath9k_set_tsfadjust(sc,vif); else ;
  
#line 603 
  tmp_0 = ath9k_allow_beacon_config(sc,vif);
  
#line 603 
  if (tmp_0) 
#line 603 
             tmp_1 = 0; else 
#line 603 
                             tmp_1 = 1;
  
#line 603 
  if (tmp_1) 
#line 604 
             goto return_label; else ;
  
#line 606 
  if (vif->type == (unsigned int)NL80211_IFTYPE_STATION) {
    
#line 607 
    ath9k_cache_beacon_config(sc,ctx,bss_conf);
    
#line 608 
    if (sc->cur_chan != ctx) 
#line 609 
                             goto return_label; else ;
    
#line 611 
    ath9k_set_beacon(sc);
    
#line 612 
    set_bit(1L,(unsigned long volatile *)(& common->op_flags));
    
#line 613 
    goto return_label;
  }
  else ;
  
#line 620 
  if ((changed & 512U) != 0U) {
    
#line 621 
    bool enabled = (_Bool)((unsigned int)cur_conf->enable_beacon != 0U);
    
#line 623 
    if (! bss_conf->enable_beacon) 
#line 624 
                                   cur_conf->enable_beacon = (unsigned char)((int)cur_conf->enable_beacon & ~ ((int)((unsigned char)(1UL << avp->av_bslot))));
    else {
      
#line 626 
      cur_conf->enable_beacon = (unsigned char)((int)cur_conf->enable_beacon | (int)((unsigned char)(1UL << avp->av_bslot)));
      
#line 627 
      if (! enabled) 
#line 628 
                     ath9k_cache_beacon_config(sc,ctx,bss_conf); else ;
    }
  }
  else ;
  
#line 632 
  if (sc->cur_chan != ctx) 
#line 633 
                           goto return_label; else ;
  
#line 639 
  if (cur_conf->beacon_interval != 0) {
    
#line 645 
    if (((changed & 2048U) != 0U && ! bss_conf->ibss_creator) && (int)bss_conf->enable_beacon != 0) {
      
#line 647 
      ldv___ldv_spin_lock_74(& sc->sc_pm_lock);
      
#line 648 
      sc->ps_flags = (unsigned short)((unsigned int)sc->ps_flags | 17U);
      
#line 649 
      ldv_spin_unlock_irqrestore_75(& sc->sc_pm_lock,flags);
      
#line 650 
      skip_beacon = (_Bool)1;
    }
    else 
#line 652 
         ath9k_set_beacon(sc);
    
#line 659 
    if ((unsigned int)cur_conf->enable_beacon != 0U && ! skip_beacon) 
      
#line 660 
      set_bit(1L,(unsigned long volatile *)(& common->op_flags)); else 
                                                                    
#line 662 
                                                                    set_bit(1L,(unsigned long volatile *)(& common->op_flags));
  }
  else ;
  return_label: 
#line 664 
                return;
}


#line 666  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/beacon.c"
void ath9k_set_beacon(struct ath_softc *sc)
{
  
#line 668 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 669 
  struct ath_beacon_config *cur_conf = & (sc->cur_chan)->beacon;
  
#line 671 
  switch ((unsigned int)(sc->sc_ah)->opmode) {
    case (unsigned int)3: 
#line 672 
    ;
    case (unsigned int)7: 
#line 673 
    ;
    
#line 674 
    ath9k_beacon_config_ap(sc,cur_conf);
    
#line 675 
    goto ldv_53519;
    case (unsigned int)1: 
#line 676 
    ;
    
#line 677 
    ath9k_beacon_config_adhoc(sc,cur_conf);
    
#line 678 
    goto ldv_53519;
    case (unsigned int)2: 
#line 679 
    ;
    
#line 680 
    ath9k_beacon_config_sta(sc->sc_ah,cur_conf);
    
#line 681 
    goto ldv_53519;
    default: 
#line 682 
    ;
    
#line 683 
    if ((common->debug_mask & 512) != 0) 
#line 683 
                                         ath_printk("\001",(struct ath_common const *)common,"Unsupported beaconing mode\n"); else ;
    
#line 684 
    goto return_label;
  }
  ldv_53519: 
#line 686 
  ;
  return_label: 
#line 687 
                return;
}


#line 120  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_beacon.c.aux"
static void atomic_inc(atomic_t *v)
{
  
#line 123 
  ldv_atomic_inc(v);
  
#line 124 
  return;
}


#line 127  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_beacon.c.aux"
static void atomic_dec(atomic_t *v)
{
  
#line 130 
  ldv_atomic_dec(v);
  
#line 131 
  return;
}


#line 737  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_beacon.c.aux"
static void ldv_spin_lock_bh_72(spinlock_t *lock)
{
  
#line 741 
  ldv_spin_model_lock((char *)"axq_lock_of_ath_txq");
  
#line 743 
  spin_lock_bh(lock);
  
#line 744 
  return;
}


#line 747  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_beacon.c.aux"
static void ldv_spin_unlock_bh_73(spinlock_t *lock)
{
  
#line 751 
  ldv_spin_model_unlock((char *)"axq_lock_of_ath_txq");
  
#line 753 
  spin_unlock_bh(lock);
  
#line 754 
  return;
}


#line 757  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_beacon.c.aux"
static void ldv___ldv_spin_lock_74(spinlock_t *ldv_func_arg1)
{
  
#line 761 
  ldv_spin_model_lock((char *)"sc_pm_lock_of_ath_softc");
  
#line 763 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 764 
  return;
}


#line 767  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_beacon.c.aux"
static void ldv_spin_unlock_irqrestore_75(spinlock_t *lock, unsigned long flags)
{
  
#line 771 
  ldv_spin_model_unlock((char *)"sc_pm_lock_of_ath_softc");
  
#line 773 
  spin_unlock_irqrestore(lock,flags);
  
#line 774 
  return;
}


#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
extern unsigned long volatile jiffies;


#line 292 
unsigned long __msecs_to_jiffies(unsigned int const);


#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
__inline static unsigned long _msecs_to_jiffies(unsigned int const m)
{
  unsigned long __retres;
  
#line 301 
  __retres = (unsigned long)(((long)m + 3L) / 4L);
  
#line 301 
  return __retres;
}


#line 354  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
__inline static unsigned long msecs_to_jiffies(unsigned int const m)
{
  unsigned long __retres;
  
#line 356 
  if (0 != 0) {
    unsigned long tmp;
    
#line 357 
    if ((int)m < 0) {
      
#line 358 
      __retres = 4611686018427387902UL;
      
#line 358 
      goto return_label;
    }
    else ;
    
#line 359 
    tmp = _msecs_to_jiffies(m);
    
#line 359 
    __retres = tmp;
    
#line 359 
    goto return_label;
  }
  else {
    unsigned long tmp_0;
    
#line 361 
    tmp_0 = __msecs_to_jiffies(m);
    
#line 361 
    __retres = tmp_0;
    
#line 361 
    goto return_label;
  }
  return_label: 
#line 356 
                return __retres;
}


#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw-ops.h"
__inline static void ath9k_hw_antdiv_comb_conf_get(struct ath_hw *ah, struct ath_hw_antcomb_conf *antconf)
{
  struct ath_hw_ops *tmp;
  
#line 78 
  tmp = ath9k_hw_ops(ah);
  
#line 78 
  (*(tmp->antdiv_comb_conf_get))(ah,antconf);
  
#line 79 
  return;
}


#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw-ops.h"
__inline static void ath9k_hw_antdiv_comb_conf_set(struct ath_hw *ah, struct ath_hw_antcomb_conf *antconf)
{
  struct ath_hw_ops *tmp;
  
#line 84 
  tmp = ath9k_hw_ops(ah);
  
#line 84 
  (*(tmp->antdiv_comb_conf_set))(ah,antconf);
  
#line 85 
  return;
}


#line 269  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.h"
void ath9k_debug_stat_ant(struct ath_softc *sc, struct ath_hw_antcomb_conf *div_ant_conf, int main_rssi_avg, int alt_rssi_avg);


#line 918  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
void ath_ant_comb_scan(struct ath_softc *sc, struct ath_rx_status *rs);


#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/antenna.c"
__inline static bool ath_is_alt_ant_ratio_better(struct ath_ant_comb *antcomb, int alt_ratio, int maxdelta, int mindelta, int main_rssi_avg, int alt_rssi_avg, int pkt_count)
{
  bool __retres;
  
#line 76 
  if (pkt_count <= 50) {
    
#line 77 
    __retres = (_Bool)0;
    
#line 77 
    goto return_label;
  }
  else ;
  
#line 79 
  if (main_rssi_avg + mindelta < alt_rssi_avg) {
    
#line 80 
    __retres = (_Bool)1;
    
#line 80 
    goto return_label;
  }
  else ;
  
#line 82 
  if ((antcomb->ant_ratio2 <= alt_ratio && antcomb->low_rssi_thresh <= alt_rssi_avg) && main_rssi_avg + maxdelta < alt_rssi_avg) {
    
#line 85 
    __retres = (_Bool)1;
    
#line 85 
    goto return_label;
  }
  else ;
  
#line 87 
  __retres = (_Bool)0;
  return_label: 
#line 87 
                return __retres;
}


#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/antenna.c"
__inline static bool ath_ant_div_comb_alt_check(struct ath_hw_antcomb_conf *conf, struct ath_ant_comb *antcomb, int alt_ratio, int alt_rssi_avg, int main_rssi_avg)
{
  bool result;
  bool set1;
  bool set2;
  
#line 97 
  set2 = (_Bool)0;
  
#line 97 
  set1 = set2;
  
#line 97 
  result = set1;
  
#line 99 
  if ((unsigned int)conf->main_lna_conf == 1U && (unsigned int)conf->alt_lna_conf == 2U) 
    
#line 101 
    set1 = (_Bool)1; else ;
  
#line 103 
  if ((unsigned int)conf->main_lna_conf == 2U && (unsigned int)conf->alt_lna_conf == 1U) 
    
#line 105 
    set2 = (_Bool)1; else ;
  
#line 107 
  switch ((int)conf->div_group) {
    case 0: 
#line 108 
    ;
    
#line 109 
    if (alt_ratio > 30) 
#line 110 
                        result = (_Bool)1; else ;
    
#line 111 
    goto ldv_53356;
    case 1: 
#line 112 
    ;
    case 2: 
#line 113 
    ;
    
#line 114 
    if (alt_rssi_avg <= 3 || antcomb->low_rssi_thresh > alt_rssi_avg) 
      
#line 115 
      goto ldv_53356; else ;
    
#line 117 
    if ((((int)set1 != 0 && main_rssi_avg + -5 <= alt_rssi_avg) || ((int)set2 != 0 && main_rssi_avg + -2 <= alt_rssi_avg)) || antcomb->ant_ratio < alt_ratio) 
      
#line 120 
      result = (_Bool)1; else ;
    
#line 122 
    goto ldv_53356;
    case 3: 
#line 123 
    ;
    
#line 124 
    if (alt_rssi_avg <= 3 || antcomb->low_rssi_thresh > alt_rssi_avg) 
      
#line 125 
      goto ldv_53356; else ;
    
#line 127 
    if ((((int)set1 != 0 && main_rssi_avg + -3 <= alt_rssi_avg) || ((int)set2 != 0 && main_rssi_avg + 3 <= alt_rssi_avg)) || antcomb->ant_ratio < alt_ratio) 
      
#line 130 
      result = (_Bool)1; else ;
    
#line 132 
    goto ldv_53356;
  }
  ldv_53356: 
#line 135 
  ;
  
#line 135 
  return result;
}


#line 138  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/antenna.c"
static void ath_lnaconf_alt_good_scan(struct ath_ant_comb *antcomb, struct ath_hw_antcomb_conf ant_conf, int main_rssi_avg)
{
  
#line 142 
  antcomb->quick_scan_cnt = 0;
  
#line 144 
  if ((unsigned int)ant_conf.main_lna_conf == 1U) 
#line 145 
                                                  antcomb->rssi_lna2 = main_rssi_avg;
  else 
    
#line 146 
    if ((unsigned int)ant_conf.main_lna_conf == 2U) 
#line 147 
                                                    antcomb->rssi_lna1 = main_rssi_avg; else ;
  
#line 149 
  switch (((int)ant_conf.main_lna_conf << 4) | (int)ant_conf.alt_lna_conf) {
    case 16: 
#line 150 
    ;
    
#line 151 
    antcomb->main_conf = ATH_ANT_DIV_COMB_LNA1_MINUS_LNA2;
    
#line 152 
    antcomb->first_quick_scan_conf = ATH_ANT_DIV_COMB_LNA1_PLUS_LNA2;
    
#line 154 
    antcomb->second_quick_scan_conf = ATH_ANT_DIV_COMB_LNA1;
    
#line 155 
    goto ldv_53366;
    case 32: 
#line 156 
    ;
    
#line 157 
    antcomb->main_conf = ATH_ANT_DIV_COMB_LNA1_MINUS_LNA2;
    
#line 158 
    antcomb->first_quick_scan_conf = ATH_ANT_DIV_COMB_LNA1_PLUS_LNA2;
    
#line 160 
    antcomb->second_quick_scan_conf = ATH_ANT_DIV_COMB_LNA2;
    
#line 161 
    goto ldv_53366;
    case 33: 
#line 162 
    ;
    
#line 163 
    antcomb->main_conf = ATH_ANT_DIV_COMB_LNA2;
    
#line 164 
    antcomb->first_quick_scan_conf = ATH_ANT_DIV_COMB_LNA1_MINUS_LNA2;
    
#line 166 
    antcomb->second_quick_scan_conf = ATH_ANT_DIV_COMB_LNA1_PLUS_LNA2;
    
#line 168 
    goto ldv_53366;
    case 18: 
#line 169 
    ;
    
#line 170 
    antcomb->main_conf = ATH_ANT_DIV_COMB_LNA1;
    
#line 171 
    antcomb->first_quick_scan_conf = ATH_ANT_DIV_COMB_LNA1_MINUS_LNA2;
    
#line 173 
    antcomb->second_quick_scan_conf = ATH_ANT_DIV_COMB_LNA1_PLUS_LNA2;
    
#line 175 
    goto ldv_53366;
    case 19: 
#line 176 
    ;
    
#line 177 
    antcomb->main_conf = ATH_ANT_DIV_COMB_LNA1_PLUS_LNA2;
    
#line 178 
    antcomb->first_quick_scan_conf = ATH_ANT_DIV_COMB_LNA1_MINUS_LNA2;
    
#line 180 
    antcomb->second_quick_scan_conf = ATH_ANT_DIV_COMB_LNA1;
    
#line 181 
    goto ldv_53366;
    case 35: 
#line 182 
    ;
    
#line 183 
    antcomb->main_conf = ATH_ANT_DIV_COMB_LNA1_PLUS_LNA2;
    
#line 184 
    antcomb->first_quick_scan_conf = ATH_ANT_DIV_COMB_LNA1_MINUS_LNA2;
    
#line 186 
    antcomb->second_quick_scan_conf = ATH_ANT_DIV_COMB_LNA2;
    
#line 187 
    goto ldv_53366;
    default: 
#line 188 
    ;
    
#line 189 
    goto ldv_53366;
  }
  ldv_53366: 
#line 191 
  ;
  
#line 192 
  return;
}


#line 193  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/antenna.c"
static void ath_ant_set_alt_ratio(struct ath_ant_comb *antcomb, struct ath_hw_antcomb_conf *conf)
{
  
#line 197 
  if ((int)antcomb->first_ratio != 0 && (int)antcomb->second_ratio != 0) 
    
#line 198 
    if (antcomb->rssi_second > antcomb->rssi_third) 
      
#line 200 
      if ((unsigned int)antcomb->first_quick_scan_conf + 4294967295U <= 1U) 
        
#line 203 
        if ((unsigned int)conf->main_lna_conf == 1U) 
#line 204 
                                                     conf->alt_lna_conf = (unsigned char)2U; else 
                                                                    
#line 206 
                                                                    conf->alt_lna_conf = (unsigned char)1U;
      else 
#line 209 
           conf->alt_lna_conf = (unsigned char)antcomb->first_quick_scan_conf;
    else 
      
#line 211 
      if ((unsigned int)antcomb->second_quick_scan_conf + 4294967295U <= 1U) 
        
#line 214 
        if ((unsigned int)conf->main_lna_conf == 1U) 
#line 215 
                                                     conf->alt_lna_conf = (unsigned char)2U; else 
                                                                    
#line 217 
                                                                    conf->alt_lna_conf = (unsigned char)1U;
      else 
#line 220 
           conf->alt_lna_conf = (unsigned char)antcomb->second_quick_scan_conf;
  else 
    
#line 222 
    if ((int)antcomb->first_ratio != 0) 
      
#line 224 
      if ((unsigned int)antcomb->first_quick_scan_conf + 4294967295U <= 1U) 
        
#line 227 
        if ((unsigned int)conf->main_lna_conf == 1U) 
#line 228 
                                                     conf->alt_lna_conf = (unsigned char)2U; else 
                                                                    
#line 230 
                                                                    conf->alt_lna_conf = (unsigned char)1U;
      else 
#line 233 
           conf->alt_lna_conf = (unsigned char)antcomb->first_quick_scan_conf;
    else 
      
#line 234 
      if ((int)antcomb->second_ratio != 0) 
        
#line 236 
        if ((unsigned int)antcomb->second_quick_scan_conf + 4294967295U <= 1U) 
          
#line 239 
          if ((unsigned int)conf->main_lna_conf == 1U) 
#line 240 
                                                       conf->alt_lna_conf = (unsigned char)2U; else 
                                                                    
#line 242 
                                                                    conf->alt_lna_conf = (unsigned char)1U;
        else 
#line 245 
             conf->alt_lna_conf = (unsigned char)antcomb->second_quick_scan_conf;
      else 
        
#line 248 
        if ((unsigned int)antcomb->main_conf + 4294967295U <= 1U) 
          
#line 251 
          if ((unsigned int)conf->main_lna_conf == 1U) 
#line 252 
                                                       conf->alt_lna_conf = (unsigned char)2U; else 
                                                                    
#line 254 
                                                                    conf->alt_lna_conf = (unsigned char)1U;
        else 
#line 257 
             conf->alt_lna_conf = (unsigned char)antcomb->main_conf;
  
#line 258 
  return;
}


#line 261  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/antenna.c"
static void ath_select_ant_div_from_quick_scan(struct ath_ant_comb *antcomb, struct ath_hw_antcomb_conf *div_ant_conf, int main_rssi_avg, int alt_rssi_avg, int alt_ratio)
{
  
#line 267 
  switch (antcomb->quick_scan_cnt) {
    case 0: 
#line 268 
    ;
    
#line 270 
    div_ant_conf->main_lna_conf = (unsigned char)antcomb->main_conf;
    
#line 271 
    div_ant_conf->alt_lna_conf = (unsigned char)antcomb->first_quick_scan_conf;
    
#line 272 
    goto ldv_53385;
    case 1: 
#line 273 
    ;
    
#line 275 
    div_ant_conf->main_lna_conf = (unsigned char)antcomb->main_conf;
    
#line 276 
    div_ant_conf->alt_lna_conf = (unsigned char)antcomb->second_quick_scan_conf;
    
#line 277 
    antcomb->rssi_first = main_rssi_avg;
    
#line 278 
    antcomb->rssi_second = alt_rssi_avg;
    
#line 280 
    if (antcomb->main_conf == (unsigned int)ATH_ANT_DIV_COMB_LNA1) {
      bool tmp;
      
#line 282 
      tmp = ath_is_alt_ant_ratio_better(antcomb,alt_ratio,-4,2,main_rssi_avg,alt_rssi_avg,(int)antcomb->total_pkt_count);
      
#line 282 
      if ((int)tmp != 0) 
#line 287 
                         antcomb->first_ratio = (_Bool)1; else 
#line 289 
                                                               antcomb->first_ratio = (_Bool)0;
    }
    else 
      
#line 290 
      if (antcomb->main_conf == (unsigned int)ATH_ANT_DIV_COMB_LNA2) {
        bool tmp_0;
        
#line 291 
        tmp_0 = ath_is_alt_ant_ratio_better(antcomb,alt_ratio,-2,2,main_rssi_avg,alt_rssi_avg,(int)antcomb->total_pkt_count);
        
#line 291 
        if ((int)tmp_0 != 0) 
#line 296 
                             antcomb->first_ratio = (_Bool)1; else 
#line 298 
                                                                   antcomb->first_ratio = (_Bool)0;
      }
      else {
        bool tmp_1;
        
#line 300 
        tmp_1 = ath_is_alt_ant_ratio_better(antcomb,alt_ratio,-4,0,main_rssi_avg,alt_rssi_avg,(int)antcomb->total_pkt_count);
        
#line 300 
        if ((int)tmp_1 != 0) 
#line 305 
                             antcomb->first_ratio = (_Bool)1; else 
#line 307 
                                                                   antcomb->first_ratio = (_Bool)0;
      }
    
#line 309 
    goto ldv_53385;
    case 2: 
#line 310 
    ;
    
#line 311 
    antcomb->alt_good = (_Bool)0;
    
#line 312 
    antcomb->scan_not_start = (_Bool)0;
    
#line 313 
    antcomb->scan = (_Bool)0;
    
#line 314 
    antcomb->rssi_first = main_rssi_avg;
    
#line 315 
    antcomb->rssi_third = alt_rssi_avg;
    
#line 317 
    switch ((unsigned int)antcomb->second_quick_scan_conf) {
      case (unsigned int)2: 
#line 318 
      ;
      
#line 319 
      antcomb->rssi_lna1 = alt_rssi_avg;
      
#line 320 
      goto ldv_53389;
      case (unsigned int)1: 
#line 321 
      ;
      
#line 322 
      antcomb->rssi_lna2 = alt_rssi_avg;
      
#line 323 
      goto ldv_53389;
      case (unsigned int)3: 
#line 324 
      ;
      
#line 325 
      if (antcomb->main_conf == (unsigned int)ATH_ANT_DIV_COMB_LNA2) 
        
#line 326 
        antcomb->rssi_lna2 = main_rssi_avg;
      else 
        
#line 327 
        if (antcomb->main_conf == (unsigned int)ATH_ANT_DIV_COMB_LNA1) 
          
#line 328 
          antcomb->rssi_lna1 = main_rssi_avg; else ;
      
#line 329 
      goto ldv_53389;
      default: 
#line 330 
      ;
      
#line 331 
      goto ldv_53389;
    }
    ldv_53389: 
#line 334 
    ;
    
#line 334 
    if (antcomb->rssi_lna2 > antcomb->rssi_lna1 + div_ant_conf->lna1_lna2_switch_delta) 
      
#line 336 
      div_ant_conf->main_lna_conf = (unsigned char)1U; else 
#line 338 
                                                            div_ant_conf->main_lna_conf = (unsigned char)2U;
    
#line 340 
    if (antcomb->main_conf == (unsigned int)ATH_ANT_DIV_COMB_LNA1) {
      bool tmp_2;
      
#line 341 
      tmp_2 = ath_is_alt_ant_ratio_better(antcomb,alt_ratio,-4,2,main_rssi_avg,alt_rssi_avg,(int)antcomb->total_pkt_count);
      
#line 341 
      if ((int)tmp_2 != 0) 
#line 346 
                           antcomb->second_ratio = (_Bool)1; else 
#line 348 
                                                                  antcomb->second_ratio = (_Bool)0;
    }
    else 
      
#line 349 
      if (antcomb->main_conf == (unsigned int)ATH_ANT_DIV_COMB_LNA2) {
        bool tmp_3;
        
#line 350 
        tmp_3 = ath_is_alt_ant_ratio_better(antcomb,alt_ratio,-2,2,main_rssi_avg,alt_rssi_avg,(int)antcomb->total_pkt_count);
        
#line 350 
        if ((int)tmp_3 != 0) 
#line 355 
                             antcomb->second_ratio = (_Bool)1; else 
#line 357 
                                                                    antcomb->second_ratio = (_Bool)0;
      }
      else {
        bool tmp_4;
        
#line 359 
        tmp_4 = ath_is_alt_ant_ratio_better(antcomb,alt_ratio,-4,0,main_rssi_avg,alt_rssi_avg,(int)antcomb->total_pkt_count);
        
#line 359 
        if ((int)tmp_4 != 0) 
#line 364 
                             antcomb->second_ratio = (_Bool)1; else 
#line 366 
                                                                    antcomb->second_ratio = (_Bool)0;
      }
    
#line 369 
    ath_ant_set_alt_ratio(antcomb,div_ant_conf);
    
#line 371 
    goto ldv_53385;
    default: 
#line 372 
    ;
    
#line 373 
    goto ldv_53385;
  }
  ldv_53385: 
#line 375 
  ;
  
#line 376 
  return;
}


#line 377  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/antenna.c"
static void ath_ant_div_conf_fast_divbias(struct ath_hw_antcomb_conf *ant_conf, struct ath_ant_comb *antcomb, int alt_ratio)
{
  
#line 381 
  ant_conf->main_gaintb = (unsigned char)0U;
  
#line 382 
  ant_conf->alt_gaintb = (unsigned char)0U;
  
#line 384 
  if ((unsigned int)ant_conf->div_group == 0U) {
    
#line 386 
    switch (((int)ant_conf->main_lna_conf << 4) | (int)ant_conf->alt_lna_conf) {
      case 1: 
#line 388 
      ;
      
#line 389 
      ant_conf->fast_div_bias = (unsigned char)59U;
      
#line 390 
      goto ldv_53400;
      case 2: 
#line 391 
      ;
      
#line 392 
      ant_conf->fast_div_bias = (unsigned char)61U;
      
#line 393 
      goto ldv_53400;
      case 3: 
#line 394 
      ;
      
#line 395 
      ant_conf->fast_div_bias = (unsigned char)1U;
      
#line 396 
      goto ldv_53400;
      case 16: 
#line 397 
      ;
      
#line 398 
      ant_conf->fast_div_bias = (unsigned char)7U;
      
#line 399 
      goto ldv_53400;
      case 18: 
#line 400 
      ;
      
#line 401 
      ant_conf->fast_div_bias = (unsigned char)2U;
      
#line 402 
      goto ldv_53400;
      case 19: 
#line 403 
      ;
      
#line 404 
      ant_conf->fast_div_bias = (unsigned char)7U;
      
#line 405 
      goto ldv_53400;
      case 32: 
#line 406 
      ;
      
#line 407 
      ant_conf->fast_div_bias = (unsigned char)6U;
      
#line 408 
      goto ldv_53400;
      case 33: 
#line 409 
      ;
      
#line 410 
      ant_conf->fast_div_bias = (unsigned char)0U;
      
#line 411 
      goto ldv_53400;
      case 35: 
#line 412 
      ;
      
#line 413 
      ant_conf->fast_div_bias = (unsigned char)6U;
      
#line 414 
      goto ldv_53400;
      case 48: 
#line 415 
      ;
      
#line 416 
      ant_conf->fast_div_bias = (unsigned char)1U;
      
#line 417 
      goto ldv_53400;
      case 49: 
#line 418 
      ;
      
#line 419 
      ant_conf->fast_div_bias = (unsigned char)59U;
      
#line 420 
      goto ldv_53400;
      case 50: 
#line 421 
      ;
      
#line 422 
      ant_conf->fast_div_bias = (unsigned char)61U;
      
#line 423 
      goto ldv_53400;
      default: 
#line 424 
      ;
      
#line 425 
      goto ldv_53400;
    }
    ldv_53400: 
#line 427 
    ;
  }
  else 
    
#line 427 
    if ((unsigned int)ant_conf->div_group == 1U) {
      
#line 429 
      switch (((int)ant_conf->main_lna_conf << 4) | (int)ant_conf->alt_lna_conf) {
        case 1: 
#line 431 
        ;
        
#line 432 
        ant_conf->fast_div_bias = (unsigned char)1U;
        
#line 433 
        goto ldv_53414;
        case 2: 
#line 434 
        ;
        
#line 435 
        ant_conf->fast_div_bias = (unsigned char)1U;
        
#line 436 
        goto ldv_53414;
        case 3: 
#line 437 
        ;
        
#line 438 
        ant_conf->fast_div_bias = (unsigned char)1U;
        
#line 439 
        goto ldv_53414;
        case 16: 
#line 440 
        ;
        
#line 441 
        if (! antcomb->scan && alt_ratio > 30) 
#line 443 
                                               ant_conf->fast_div_bias = (unsigned char)63U; else 
                                                                    
#line 445 
                                                                    ant_conf->fast_div_bias = (unsigned char)1U;
        
#line 446 
        goto ldv_53414;
        case 18: 
#line 447 
        ;
        
#line 448 
        ant_conf->fast_div_bias = (unsigned char)1U;
        
#line 449 
        goto ldv_53414;
        case 19: 
#line 450 
        ;
        
#line 451 
        if (! antcomb->scan && alt_ratio > 30) 
#line 453 
                                               ant_conf->fast_div_bias = (unsigned char)63U; else 
                                                                    
#line 455 
                                                                    ant_conf->fast_div_bias = (unsigned char)1U;
        
#line 456 
        goto ldv_53414;
        case 32: 
#line 457 
        ;
        
#line 458 
        if (! antcomb->scan && alt_ratio > 30) 
#line 460 
                                               ant_conf->fast_div_bias = (unsigned char)63U; else 
                                                                    
#line 462 
                                                                    ant_conf->fast_div_bias = (unsigned char)1U;
        
#line 463 
        goto ldv_53414;
        case 33: 
#line 464 
        ;
        
#line 465 
        ant_conf->fast_div_bias = (unsigned char)1U;
        
#line 466 
        goto ldv_53414;
        case 35: 
#line 467 
        ;
        
#line 468 
        if (! antcomb->scan && alt_ratio > 30) 
#line 470 
                                               ant_conf->fast_div_bias = (unsigned char)63U; else 
                                                                    
#line 472 
                                                                    ant_conf->fast_div_bias = (unsigned char)1U;
        
#line 473 
        goto ldv_53414;
        case 48: 
#line 474 
        ;
        
#line 475 
        ant_conf->fast_div_bias = (unsigned char)1U;
        
#line 476 
        goto ldv_53414;
        case 49: 
#line 477 
        ;
        
#line 478 
        ant_conf->fast_div_bias = (unsigned char)1U;
        
#line 479 
        goto ldv_53414;
        case 50: 
#line 480 
        ;
        
#line 481 
        ant_conf->fast_div_bias = (unsigned char)1U;
        
#line 482 
        goto ldv_53414;
        default: 
#line 483 
        ;
        
#line 484 
        goto ldv_53414;
      }
      ldv_53414: 
#line 486 
      ;
    }
    else 
      
#line 486 
      if ((unsigned int)ant_conf->div_group == 2U) {
        
#line 488 
        switch (((int)ant_conf->main_lna_conf << 4) | (int)ant_conf->alt_lna_conf) {
          case 1: 
#line 490 
          ;
          
#line 491 
          ant_conf->fast_div_bias = (unsigned char)1U;
          
#line 492 
          goto ldv_53428;
          case 2: 
#line 493 
          ;
          
#line 494 
          ant_conf->fast_div_bias = (unsigned char)1U;
          
#line 495 
          goto ldv_53428;
          case 3: 
#line 496 
          ;
          
#line 497 
          ant_conf->fast_div_bias = (unsigned char)1U;
          
#line 498 
          goto ldv_53428;
          case 16: 
#line 499 
          ;
          
#line 500 
          if (! antcomb->scan && antcomb->ant_ratio < alt_ratio) 
#line 501 
                                                                 ant_conf->fast_div_bias = (unsigned char)1U; else 
                                                                    
#line 503 
                                                                    ant_conf->fast_div_bias = (unsigned char)2U;
          
#line 504 
          goto ldv_53428;
          case 18: 
#line 505 
          ;
          
#line 506 
          ant_conf->fast_div_bias = (unsigned char)1U;
          
#line 507 
          goto ldv_53428;
          case 19: 
#line 508 
          ;
          
#line 509 
          if (! antcomb->scan && antcomb->ant_ratio < alt_ratio) 
#line 510 
                                                                 ant_conf->fast_div_bias = (unsigned char)1U; else 
                                                                    
#line 512 
                                                                    ant_conf->fast_div_bias = (unsigned char)2U;
          
#line 513 
          goto ldv_53428;
          case 32: 
#line 514 
          ;
          
#line 515 
          if (! antcomb->scan && antcomb->ant_ratio < alt_ratio) 
#line 516 
                                                                 ant_conf->fast_div_bias = (unsigned char)1U; else 
                                                                    
#line 518 
                                                                    ant_conf->fast_div_bias = (unsigned char)2U;
          
#line 519 
          goto ldv_53428;
          case 33: 
#line 520 
          ;
          
#line 521 
          ant_conf->fast_div_bias = (unsigned char)1U;
          
#line 522 
          goto ldv_53428;
          case 35: 
#line 523 
          ;
          
#line 524 
          if (! antcomb->scan && antcomb->ant_ratio < alt_ratio) 
#line 525 
                                                                 ant_conf->fast_div_bias = (unsigned char)1U; else 
                                                                    
#line 527 
                                                                    ant_conf->fast_div_bias = (unsigned char)2U;
          
#line 528 
          goto ldv_53428;
          case 48: 
#line 529 
          ;
          
#line 530 
          ant_conf->fast_div_bias = (unsigned char)1U;
          
#line 531 
          goto ldv_53428;
          case 49: 
#line 532 
          ;
          
#line 533 
          ant_conf->fast_div_bias = (unsigned char)1U;
          
#line 534 
          goto ldv_53428;
          case 50: 
#line 535 
          ;
          
#line 536 
          ant_conf->fast_div_bias = (unsigned char)1U;
          
#line 537 
          goto ldv_53428;
          default: 
#line 538 
          ;
          
#line 539 
          goto ldv_53428;
        }
        ldv_53428: 
#line 542 
        ;
        
#line 542 
        if (antcomb->fast_div_bias != 0) 
#line 543 
                                         ant_conf->fast_div_bias = (unsigned char)antcomb->fast_div_bias; else ;
      }
      else 
        
#line 544 
        if ((unsigned int)ant_conf->div_group == 3U) {
          
#line 545 
          switch (((int)ant_conf->main_lna_conf << 4) | (int)ant_conf->alt_lna_conf) {
            case 1: 
#line 547 
            ;
            
#line 548 
            ant_conf->fast_div_bias = (unsigned char)1U;
            
#line 549 
            goto ldv_53442;
            case 2: 
#line 550 
            ;
            
#line 551 
            ant_conf->fast_div_bias = (unsigned char)57U;
            
#line 552 
            goto ldv_53442;
            case 3: 
#line 553 
            ;
            
#line 554 
            ant_conf->fast_div_bias = (unsigned char)1U;
            
#line 555 
            goto ldv_53442;
            case 16: 
#line 556 
            ;
            
#line 557 
            ant_conf->fast_div_bias = (unsigned char)2U;
            
#line 558 
            goto ldv_53442;
            case 18: 
#line 559 
            ;
            
#line 560 
            ant_conf->fast_div_bias = (unsigned char)63U;
            
#line 561 
            goto ldv_53442;
            case 19: 
#line 562 
            ;
            
#line 563 
            ant_conf->fast_div_bias = (unsigned char)2U;
            
#line 564 
            goto ldv_53442;
            case 32: 
#line 565 
            ;
            
#line 566 
            ant_conf->fast_div_bias = (unsigned char)3U;
            
#line 567 
            goto ldv_53442;
            case 33: 
#line 568 
            ;
            
#line 569 
            ant_conf->fast_div_bias = (unsigned char)3U;
            
#line 570 
            goto ldv_53442;
            case 35: 
#line 571 
            ;
            
#line 572 
            ant_conf->fast_div_bias = (unsigned char)3U;
            
#line 573 
            goto ldv_53442;
            case 48: 
#line 574 
            ;
            
#line 575 
            ant_conf->fast_div_bias = (unsigned char)1U;
            
#line 576 
            goto ldv_53442;
            case 49: 
#line 577 
            ;
            
#line 578 
            ant_conf->fast_div_bias = (unsigned char)6U;
            
#line 579 
            goto ldv_53442;
            case 50: 
#line 580 
            ;
            
#line 581 
            ant_conf->fast_div_bias = (unsigned char)1U;
            
#line 582 
            goto ldv_53442;
            default: 
#line 583 
            ;
            
#line 584 
            goto ldv_53442;
          }
          ldv_53442: 
#line 586 
          ;
        }
        else ;
  
#line 588 
  return;
}


#line 589  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/antenna.c"
static void ath_ant_try_scan(struct ath_ant_comb *antcomb, struct ath_hw_antcomb_conf *conf, int curr_alt_set, int alt_rssi_avg, int main_rssi_avg)
{
  
#line 594 
  switch (curr_alt_set) {
    case 1: 
#line 595 
    ;
    
#line 596 
    antcomb->rssi_lna2 = alt_rssi_avg;
    
#line 597 
    antcomb->rssi_lna1 = main_rssi_avg;
    
#line 598 
    antcomb->scan = (_Bool)1;
    
#line 600 
    conf->main_lna_conf = (unsigned char)2U;
    
#line 601 
    conf->alt_lna_conf = (unsigned char)3U;
    
#line 602 
    goto ldv_53463;
    case 2: 
#line 603 
    ;
    
#line 604 
    antcomb->rssi_lna1 = alt_rssi_avg;
    
#line 605 
    antcomb->rssi_lna2 = main_rssi_avg;
    
#line 606 
    antcomb->scan = (_Bool)1;
    
#line 608 
    conf->main_lna_conf = (unsigned char)1U;
    
#line 609 
    conf->alt_lna_conf = (unsigned char)3U;
    
#line 610 
    goto ldv_53463;
    case 3: 
#line 611 
    ;
    
#line 612 
    antcomb->rssi_add = alt_rssi_avg;
    
#line 613 
    antcomb->scan = (_Bool)1;
    
#line 615 
    conf->alt_lna_conf = (unsigned char)0U;
    
#line 616 
    goto ldv_53463;
    case 0: 
#line 617 
    ;
    
#line 618 
    antcomb->rssi_sub = alt_rssi_avg;
    
#line 619 
    antcomb->scan = (_Bool)0;
    
#line 620 
    if (antcomb->rssi_lna2 > antcomb->rssi_lna1 + conf->lna1_lna2_switch_delta) 
      
#line 623 
      if (antcomb->rssi_add > antcomb->rssi_lna1 && antcomb->rssi_add > antcomb->rssi_sub) {
        
#line 626 
        conf->main_lna_conf = (unsigned char)1U;
        
#line 627 
        conf->alt_lna_conf = (unsigned char)3U;
      }
      else 
        
#line 628 
        if (antcomb->rssi_sub > antcomb->rssi_lna1) {
          
#line 631 
          conf->main_lna_conf = (unsigned char)1U;
          
#line 632 
          conf->alt_lna_conf = (unsigned char)0U;
        }
        else {
          
#line 635 
          conf->main_lna_conf = (unsigned char)1U;
          
#line 636 
          conf->alt_lna_conf = (unsigned char)2U;
        }
    else 
      
#line 640 
      if (antcomb->rssi_add > antcomb->rssi_lna2 && antcomb->rssi_add > antcomb->rssi_sub) {
        
#line 643 
        conf->main_lna_conf = (unsigned char)2U;
        
#line 644 
        conf->alt_lna_conf = (unsigned char)3U;
      }
      else 
        
#line 645 
        if (antcomb->rssi_sub > antcomb->rssi_lna1) {
          
#line 648 
          conf->main_lna_conf = (unsigned char)2U;
          
#line 649 
          conf->alt_lna_conf = (unsigned char)0U;
        }
        else {
          
#line 652 
          conf->main_lna_conf = (unsigned char)2U;
          
#line 653 
          conf->alt_lna_conf = (unsigned char)1U;
        }
    
#line 656 
    goto ldv_53463;
    default: 
#line 657 
    ;
    
#line 658 
    goto ldv_53463;
  }
  ldv_53463: 
#line 660 
  ;
  
#line 661 
  return;
}


#line 662  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/antenna.c"
static bool ath_ant_try_switch(struct ath_hw_antcomb_conf *div_ant_conf, struct ath_ant_comb *antcomb, int alt_ratio, int alt_rssi_avg, int main_rssi_avg, int curr_main_set, int curr_alt_set)
{
  bool tmp;
  
#line 668 
  bool ret = (_Bool)0;
  
#line 670 
  tmp = ath_ant_div_comb_alt_check(div_ant_conf,antcomb,alt_ratio,alt_rssi_avg,main_rssi_avg);
  
#line 670 
  if ((int)tmp != 0) {
    
#line 672 
    if (curr_alt_set == 1) {
      
#line 676 
      div_ant_conf->main_lna_conf = (unsigned char)1U;
      
#line 677 
      div_ant_conf->alt_lna_conf = (unsigned char)2U;
    }
    else 
      
#line 678 
      if (curr_alt_set == 2) {
        
#line 679 
        div_ant_conf->main_lna_conf = (unsigned char)2U;
        
#line 680 
        div_ant_conf->alt_lna_conf = (unsigned char)1U;
      }
      else ;
    
#line 683 
    ret = (_Bool)1;
  }
  else 
    
#line 684 
    if ((unsigned int)curr_alt_set + 4294967295U > 1U) {
      
#line 689 
      if (curr_main_set == 1) 
#line 690 
                              div_ant_conf->alt_lna_conf = (unsigned char)2U;
      else 
        
#line 691 
        if (curr_main_set == 2) 
#line 692 
                                div_ant_conf->alt_lna_conf = (unsigned char)1U; else ;
      
#line 694 
      ret = (_Bool)1;
    }
    else ;
  
#line 697 
  return ret;
}


#line 700  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/antenna.c"
static bool ath_ant_short_scan_check(struct ath_ant_comb *antcomb)
{
  bool __retres;
  int alt_ratio;
  int tmp;
  
#line 704 
  if (! antcomb->scan || ! antcomb->alt_good) {
    
#line 705 
    __retres = (_Bool)0;
    
#line 705 
    goto return_label;
  }
  else ;
  {
    unsigned long __dummy;
    unsigned long volatile __dummy2;
    
#line 707 
    tmp = 1;
  }
  
#line 707 
  if (tmp != 0) {
    int tmp_0;
    {
      unsigned long __dummy_0;
      unsigned long __dummy2_0;
      
#line 707 
      tmp_0 = 1;
    }
    
#line 707 
    if (tmp_0 != 0) {
      unsigned long tmp_1;
      
#line 707 
      tmp_1 = msecs_to_jiffies(50U);
      
#line 707 
      ;
      
#line 707 
      if ((long)((antcomb->scan_start_time + tmp_1) - jiffies) < 0L) {
        
#line 709 
        __retres = (_Bool)1;
        
#line 709 
        goto return_label;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 711 
  if ((unsigned int)antcomb->total_pkt_count == 256U) {
    
#line 712 
    alt_ratio = (antcomb->alt_recv_cnt * 100) / (int)antcomb->total_pkt_count;
    
#line 714 
    if (antcomb->ant_ratio > alt_ratio) {
      
#line 715 
      __retres = (_Bool)1;
      
#line 715 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 718 
  __retres = (_Bool)0;
  return_label: 
#line 718 
                return __retres;
}


#line 721  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/antenna.c"
void ath_ant_comb_scan(struct ath_softc *sc, struct ath_rx_status *rs)
{
  struct ath_hw_antcomb_conf div_ant_conf;
  int curr_alt_set;
  int curr_main_set;
  int rx_ant_conf;
  int main_ant_conf;
  bool ret;
  
#line 724 
  struct ath_ant_comb *antcomb = & sc->ant_comb;
  
#line 725 
  int alt_ratio = 0;
  
#line 725 
  int alt_rssi_avg = 0;
  
#line 725 
  int main_rssi_avg = 0;
  
#line 727 
  int main_rssi = (int)rs->rs_rssi_ctl[0];
  
#line 728 
  int alt_rssi = (int)rs->rs_rssi_ctl[1];
  
#line 730 
  bool short_scan = (_Bool)0;
  
#line 732 
  rx_ant_conf = ((int)rs->rs_rssi_ctl[2] >> 4) & 3;
  
#line 734 
  main_ant_conf = ((int)rs->rs_rssi_ctl[2] >> 2) & 3;
  
#line 737 
  if (antcomb->low_rssi_thresh <= alt_rssi) {
    
#line 738 
    antcomb->ant_ratio = 30;
    
#line 739 
    antcomb->ant_ratio2 = 20;
  }
  else {
    
#line 741 
    antcomb->ant_ratio = 50;
    
#line 742 
    antcomb->ant_ratio2 = 50;
  }
  
#line 746 
  if (main_rssi > 0 && alt_rssi > 0) {
    
#line 747 
    antcomb->total_pkt_count = (u16)((int)antcomb->total_pkt_count + 1);
    
#line 748 
    antcomb->main_total_rssi += main_rssi;
    
#line 749 
    antcomb->alt_total_rssi += alt_rssi;
    
#line 751 
    if (main_ant_conf == rx_ant_conf) 
#line 752 
                                      antcomb->main_recv_cnt += 1; else 
                                                                    
#line 754 
                                                                    antcomb->alt_recv_cnt += 1;
  }
  else ;
  
#line 757 
  if (main_ant_conf == rx_ant_conf) {
    
#line 758 
    sc->debug.stats.ant_stats[0].recv_cnt += 1U;
    
#line 759 
    sc->debug.stats.ant_stats[0].lna_recv_cnt[rx_ant_conf] += 1U;
  }
  else {
    
#line 761 
    sc->debug.stats.ant_stats[1].recv_cnt += 1U;
    
#line 762 
    sc->debug.stats.ant_stats[1].lna_recv_cnt[rx_ant_conf] += 1U;
  }
  
#line 766 
  short_scan = ath_ant_short_scan_check(antcomb);
  
#line 768 
  if (((unsigned int)antcomb->total_pkt_count <= 511U || (unsigned int)rs->rs_moreaggr != 0U) && ! short_scan) 
    
#line 770 
    goto return_label; else ;
  
#line 772 
  if ((unsigned int)antcomb->total_pkt_count != 0U) {
    
#line 773 
    alt_ratio = (antcomb->alt_recv_cnt * 100) / (int)antcomb->total_pkt_count;
    
#line 775 
    main_rssi_avg = antcomb->main_total_rssi / (int)antcomb->total_pkt_count;
    
#line 777 
    alt_rssi_avg = antcomb->alt_total_rssi / (int)antcomb->total_pkt_count;
  }
  else ;
  
#line 781 
  ath9k_hw_antdiv_comb_conf_get(sc->sc_ah,& div_ant_conf);
  
#line 782 
  curr_alt_set = (int)div_ant_conf.alt_lna_conf;
  
#line 783 
  curr_main_set = (int)div_ant_conf.main_lna_conf;
  
#line 784 
  antcomb->count = (u16)((int)antcomb->count + 1);
  
#line 786 
  if ((unsigned int)antcomb->count == 100U) {
    
#line 787 
    if (antcomb->ant_ratio < alt_ratio) {
      
#line 788 
      ath_lnaconf_alt_good_scan(antcomb,div_ant_conf,main_rssi_avg);
      
#line 790 
      antcomb->alt_good = (_Bool)1;
    }
    else 
#line 792 
         antcomb->alt_good = (_Bool)0;
    
#line 795 
    antcomb->count = (unsigned short)0U;
    
#line 796 
    antcomb->scan = (_Bool)1;
    
#line 797 
    antcomb->scan_not_start = (_Bool)1;
  }
  else ;
  
#line 800 
  if (! antcomb->scan) {
    
#line 801 
    ret = ath_ant_try_switch(& div_ant_conf,antcomb,alt_ratio,alt_rssi_avg,main_rssi_avg,curr_main_set,curr_alt_set);
    
#line 804 
    if ((int)ret != 0) 
#line 805 
                       goto div_comb_done; else ;
  }
  else ;
  
#line 808 
  if (! antcomb->scan && div_ant_conf.lna1_lna2_delta + main_rssi_avg > alt_rssi_avg) 
    
#line 810 
    goto div_comb_done; else ;
  
#line 812 
  if (! antcomb->scan_not_start) 
#line 813 
                                 ath_ant_try_scan(antcomb,& div_ant_conf,curr_alt_set,alt_rssi_avg,main_rssi_avg);
  else {
    
#line 816 
    if (! antcomb->alt_good) {
      
#line 817 
      antcomb->scan_not_start = (_Bool)0;
      
#line 819 
      if (curr_main_set == 1) {
        
#line 820 
        div_ant_conf.main_lna_conf = (unsigned char)1U;
        
#line 822 
        div_ant_conf.alt_lna_conf = (unsigned char)2U;
      }
      else 
        
#line 824 
        if (curr_main_set == 2) {
          
#line 825 
          div_ant_conf.main_lna_conf = (unsigned char)2U;
          
#line 827 
          div_ant_conf.alt_lna_conf = (unsigned char)1U;
        }
        else ;
      
#line 830 
      goto div_comb_done;
    }
    else ;
    
#line 832 
    ath_select_ant_div_from_quick_scan(antcomb,& div_ant_conf,main_rssi_avg,alt_rssi_avg,alt_ratio);
    
#line 835 
    antcomb->quick_scan_cnt += 1;
  }
  div_comb_done: 
#line 838 
  ;
  
#line 839 
  ath_ant_div_conf_fast_divbias(& div_ant_conf,antcomb,alt_ratio);
  
#line 840 
  ath9k_hw_antdiv_comb_conf_set(sc->sc_ah,& div_ant_conf);
  
#line 841 
  ath9k_debug_stat_ant(sc,& div_ant_conf,main_rssi_avg,alt_rssi_avg);
  
#line 843 
  antcomb->scan_start_time = jiffies;
  
#line 844 
  antcomb->total_pkt_count = (unsigned short)0U;
  
#line 845 
  antcomb->main_total_rssi = 0;
  
#line 846 
  antcomb->alt_total_rssi = 0;
  
#line 847 
  antcomb->main_recv_cnt = 0;
  
#line 848 
  antcomb->alt_recv_cnt = 0;
  return_label: 
#line 849 
                return;
}


#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/export.h"
extern struct module __this_module;


#line 164  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ioport.h"
__inline static resource_size_t resource_size(struct resource const *res)
{
  resource_size_t __retres;
  
#line 166 
  __retres = (res->end - res->start) + 1ULL;
  
#line 166 
  return __retres;
}


#line 864  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static void *dev_get_drvdata(struct device const *dev)
{
  void *__retres;
  
#line 866 
  __retres = dev->driver_data;
  
#line 866 
  return __retres;
}


#line 869  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev, void *data)
{
  
#line 871 
  dev->driver_data = data;
  
#line 872 
  return;
}


#line 996  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static void *dev_get_platdata(struct device const *dev)
{
  void *__retres;
  
#line 998 
  __retres = dev->platform_data;
  
#line 998 
  return __retres;
}


#line 1083 
void dev_err(struct device const *, char const * , ...);


#line 1089 
void _dev_info(struct device const *, char const * , ...);


#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/platform_device.h"
struct resource *platform_get_resource(struct platform_device *, unsigned int, unsigned int);


#line 197 
static int ldv___platform_driver_register_78(struct platform_driver *ldv_func_arg1, struct module *ldv_func_arg2);


#line 202 
static void ldv_platform_driver_unregister_79(struct platform_driver *ldv_func_arg1);


#line 213  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/platform_device.h"
__inline static void *platform_get_drvdata(struct platform_device const *pdev)
{
  void *tmp;
  
#line 215 
  tmp = dev_get_drvdata(& pdev->dev);
  
#line 215 
  return tmp;
}


#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/platform_device.h"
__inline static void platform_set_drvdata(struct platform_device *pdev, void *data)
{
  
#line 221 
  dev_set_drvdata(& pdev->dev,data);
  
#line 222 
  return;
}


#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/io.h"
void *devm_ioremap_nocache(struct device *, resource_size_t, resource_size_t);


#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
static int ldv_request_irq_73(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev);


#line 153 
static void ldv_free_irq_74(unsigned int ldv_func_arg1, void *ldv_func_arg2);


#line 157 
static void ldv_free_irq_76(unsigned int ldv_func_arg1, void *ldv_func_arg2);


#line 3281  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
__inline static void set_wiphy_dev(struct wiphy *wiphy, struct device *dev)
{
  
#line 3283 
  wiphy->dev.parent = dev;
  
#line 3284 
  return;
}


#line 2131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
__inline static void SET_IEEE80211_DEV(struct ieee80211_hw *hw, struct device *dev)
{
  
#line 2133 
  set_wiphy_dev(hw->wiphy,dev);
  
#line 2134 
  return;
}


#line 3520 
static struct ieee80211_hw *ldv_ieee80211_alloc_hw_72(size_t priv_data_len, struct ieee80211_ops const *ops);


#line 3685 
static void ldv_ieee80211_free_hw_75(struct ieee80211_hw *ldv_func_arg1);


#line 3689 
static void ldv_ieee80211_free_hw_77(struct ieee80211_hw *ldv_func_arg1);


#line 1085  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
void ath9k_hw_name(struct ath_hw *, char *, size_t);


#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
struct ieee80211_ops ath9k_ops;


#line 447 
void ath9k_fill_chanctx_ops(void);


#line 1074 
irqreturn_t ath_isr(int irq, void *dev);


#line 1078 
int ath9k_init_device(u16 devid, struct ath_softc *sc, struct ath_bus_ops const *bus_ops);


#line 1080 
void ath9k_deinit_device(struct ath_softc *sc);


#line 1097 
int ath_ahb_init(void);


#line 1098 
void ath_ahb_exit(void);


#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ahb.c"
static struct platform_device_id const ath9k_platform_id_table[7U] = {{.name = {(char)'a', (char)'t', (char)'h', (char)'9', (char)'k', (char)'\000'}, .driver_data = 11UL}, {.name = {(char)'a', (char)'r', (char)'9', (char)'3', (char)'3', (char)'x', (char)'_', (char)'w', (char)'m', (char)'a', (char)'c', (char)'\000'}, .driver_data = 53UL}, {.name = {(char)'a', (char)'r', (char)'9', (char)'3', (char)'4', (char)'x', (char)'_', (char)'w', (char)'m', (char)'a', (char)'c', (char)'\000'}, .driver_data = 49UL}, {.name = {(char)'q', (char)'c', (char)'a', (char)'9', (char)'5', (char)'5', (char)'x', (char)'_', (char)'w', (char)'m', (char)'a', (char)'c', (char)'\000'}, .driver_data = 56UL}, {.name = {(char)'q', (char)'c', (char)'a', (char)'9', (char)'5', (char)'3', (char)'x', (char)'_', (char)'w', (char)'m', (char)'a', (char)'c', (char)'\000'}, .driver_data = 61UL}, {.name = {(char)'q', (char)'c', (char)'a', (char)'9', (char)'5', (char)'6', (char)'x', (char)'_', (char)'w', (char)'m', (char)'a', (char)'c', (char)'\000'}, .driver_data = 63UL}, {.name = {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0}, .driver_data = 0UL}};

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ahb.c"
static void ath_ahb_read_cachesize(struct ath_common *common, int *csz)
{
  
#line 56 
  *csz = 16;
  
#line 57 
  return;
}


#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ahb.c"
static bool ath_ahb_eeprom_read(struct ath_common *common, u32 off, u16 *data)
{
  bool __retres;
  struct platform_device *tmp;
  struct ath9k_platform_data *pdata;
  
#line 61 
  struct ath_softc *sc = (struct ath_softc *)common->priv;
  {
    
#line 62 
    struct device const *__mptr = (struct device const *)sc->dev;
    
#line 62 
    tmp = (struct platform_device *)__mptr + 18446744073709551600U;
  }
  
#line 62 
  struct platform_device *pdev = tmp;
  
#line 65 
  pdata = (struct ath9k_platform_data *)dev_get_platdata((struct device const *)(& pdev->dev));
  
#line 66 
  if (off > 2047U) {
    
#line 67 
    ath_printk("\001",(struct ath_common const *)common,"%s: flash read failed, offset %08x is out of range\n","ath_ahb_eeprom_read",off);
    
#line 70 
    __retres = (_Bool)0;
    
#line 70 
    goto return_label;
  }
  else ;
  
#line 73 
  *data = pdata->eeprom_data[off];
  
#line 74 
  __retres = (_Bool)1;
  return_label: 
#line 74 
                return __retres;
}


#line 77  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ahb.c"
static struct ath_bus_ops ath_ahb_bus_ops = {.ath_bus_type = ATH_AHB, .read_cachesize = & ath_ahb_read_cachesize, .eeprom_read = & ath_ahb_eeprom_read, .bt_coex_prep = (void (*)(struct ath_common *))0, .aspm_init = (void (*)(struct ath_common *))0};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ahb.c"
static int ath_ahb_probe(struct platform_device *pdev)
{
  int __retres;
  void *mem;
  struct ath_softc *sc;
  struct ieee80211_hw *hw;
  struct resource *res;
  int irq;
  struct ath_hw *ah;
  char hw_name[64U];
  void *tmp;
  resource_size_t tmp_0;
  
#line 89 
  struct platform_device_id const *id = pdev->id_entry;
  
#line 91 
  int ret = 0;
  
#line 95 
  tmp = dev_get_platdata((struct device const *)(& pdev->dev));
  
#line 95 
  if (tmp == (void *)0) {
    
#line 96 
    dev_err((struct device const *)(& pdev->dev),"no platform data specified\n");
    
#line 97 
    __retres = -22;
    
#line 97 
    goto return_label;
  }
  else ;
  
#line 100 
  res = platform_get_resource(pdev,512U,0U);
  
#line 101 
  if (res == (struct resource *)0) {
    
#line 102 
    dev_err((struct device const *)(& pdev->dev),"no memory resource found\n");
    
#line 103 
    __retres = -6;
    
#line 103 
    goto return_label;
  }
  else ;
  
#line 106 
  tmp_0 = resource_size((struct resource const *)res);
  
#line 106 
  ;
  
#line 106 
  ;
  
#line 106 
  mem = devm_ioremap_nocache(& pdev->dev,res->start,tmp_0);
  
#line 107 
  if (mem == (void *)0) {
    
#line 108 
    dev_err((struct device const *)(& pdev->dev),"ioremap failed\n");
    
#line 109 
    __retres = -12;
    
#line 109 
    goto return_label;
  }
  else ;
  
#line 112 
  res = platform_get_resource(pdev,1024U,0U);
  
#line 113 
  if (res == (struct resource *)0) {
    
#line 114 
    dev_err((struct device const *)(& pdev->dev),"no IRQ resource found\n");
    
#line 115 
    __retres = -6;
    
#line 115 
    goto return_label;
  }
  else ;
  
#line 118 
  irq = (int)res->start;
  
#line 120 
  ath9k_fill_chanctx_ops();
  
#line 121 
  hw = ldv_ieee80211_alloc_hw_72(15648UL,(struct ieee80211_ops const *)(& ath9k_ops));
  
#line 122 
  if (hw == (struct ieee80211_hw *)0) {
    
#line 123 
    dev_err((struct device const *)(& pdev->dev),"no memory for ieee80211_hw\n");
    
#line 124 
    __retres = -12;
    
#line 124 
    goto return_label;
  }
  else ;
  
#line 127 
  SET_IEEE80211_DEV(hw,& pdev->dev);
  
#line 128 
  platform_set_drvdata(pdev,(void *)hw);
  
#line 130 
  sc = (struct ath_softc *)hw->priv;
  
#line 131 
  sc->hw = hw;
  
#line 132 
  sc->dev = & pdev->dev;
  
#line 133 
  sc->mem = mem;
  
#line 134 
  sc->irq = irq;
  
#line 136 
  ret = ldv_request_irq_73((unsigned int)irq,& ath_isr,128UL,"ath9k",(void *)sc);
  
#line 137 
  if (ret != 0) {
    
#line 138 
    dev_err((struct device const *)(& pdev->dev),"request_irq failed\n");
    
#line 139 
    goto err_free_hw;
  }
  else ;
  
#line 142 
  ret = ath9k_init_device((unsigned short)((int)((unsigned short)id->driver_data)),sc,(struct ath_bus_ops const *)(& ath_ahb_bus_ops));
  
#line 143 
  if (ret != 0) {
    
#line 144 
    dev_err((struct device const *)(& pdev->dev),"failed to initialize device\n");
    
#line 145 
    goto err_irq;
  }
  else ;
  
#line 148 
  ah = sc->sc_ah;
  
#line 149 
  ath9k_hw_name(ah,(char *)(& hw_name),64UL);
  
#line 150 
  _dev_info((struct device const *)(& (hw->wiphy)->dev),"%s mem=0x%lx, irq=%d\n",(char *)(& hw_name),(unsigned long)mem,irq);
  
#line 153 
  __retres = 0;
  
#line 153 
  goto return_label;
  err_irq: 
#line 155 
  ;
  
#line 156 
  ldv_free_irq_74((unsigned int)irq,(void *)sc);
  err_free_hw: 
#line 157 
  ;
  
#line 158 
  ldv_ieee80211_free_hw_75(hw);
  
#line 159 
  __retres = ret;
  return_label: 
#line 159 
                return __retres;
}


#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ahb.c"
static int ath_ahb_remove(struct platform_device *pdev)
{
  int __retres;
  
#line 164 
  struct ieee80211_hw *hw = platform_get_drvdata((struct platform_device const *)pdev);
  
#line 166 
  if (hw != (struct ieee80211_hw *)0) {
    
#line 167 
    struct ath_softc *sc = (struct ath_softc *)hw->priv;
    
#line 169 
    ath9k_deinit_device(sc);
    
#line 170 
    ldv_free_irq_76((unsigned int)sc->irq,(void *)sc);
    
#line 171 
    ldv_ieee80211_free_hw_77(sc->hw);
  }
  else ;
  
#line 174 
  __retres = 0;
  
#line 174 
  return __retres;
}


#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ahb.c"
static struct platform_driver ath_ahb_driver = {.probe = & ath_ahb_probe, .remove = & ath_ahb_remove, .shutdown = (void (*)(struct platform_device *))0, .suspend = (int (*)(struct platform_device *, pm_message_t ))0, .resume = (int (*)(struct platform_device *))0, .driver = {.name = "ath9k", .bus = (struct bus_type *)0, .owner = (struct module *)0, .mod_name = (char const *)0, .suppress_bind_attrs = (_Bool)0, .probe_type = 0, .of_match_table = (struct of_device_id const *)0, .acpi_match_table = (struct acpi_device_id const *)0, .probe = (int (*)(struct device *))0, .remove = (int (*)(struct device *))0, .shutdown = (void (*)(struct device *))0, .suspend = (int (*)(struct device *, pm_message_t ))0, .resume = (int (*)(struct device *))0, .groups = (struct attribute_group const **)0, .pm = (struct dev_pm_ops const *)0, .p = (struct driver_private *)0}, .id_table = (struct platform_device_id const *)(& ath9k_platform_id_table), .prevent_deferred_probe = (_Bool)0};

#line 186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ahb.c"
struct platform_device_id const __mod_platform__ath9k_platform_id_table_device_table[7U];

#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ahb.c"
int ath_ahb_init(void)
{
  int tmp;
  
#line 190 
  tmp = ldv___platform_driver_register_78(& ath_ahb_driver,& __this_module);
  
#line 190 
  return tmp;
}


#line 193  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ahb.c"
void ath_ahb_exit(void)
{
  
#line 195 
  ldv_platform_driver_unregister_79(& ath_ahb_driver);
  
#line 196 
  return;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_ahb.c.aux"
struct platform_driver *ldv_emg_alias_ath_ahb_driver_2 = & ath_ahb_driver;

#line 60 
void ldv_emg_free_irq(unsigned int arg0, void *arg1);


#line 61 
void ldv_emg_ieee80211_free_hw(struct ieee80211_hw *arg0);


#line 62 
int ldv_emg_request_irq(unsigned int arg0, enum irqreturn (*arg1)(int , void *), unsigned long arg2, char *arg3, void *arg4);


#line 63 
void ldv_emg_platform_driver_unregister(struct platform_driver *arg0);


#line 66 
int ldv_emg___platform_driver_register(struct platform_driver *arg0, struct module *arg1);


#line 68 
struct ieee80211_hw *ldv_emg_ieee80211_alloc_hw(unsigned long arg0, struct ieee80211_ops *arg1);


#line 73  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_ahb.c.aux"
int ldv_emg_wrapper_ath_ahb_probe_2(struct platform_device *arg0)
{
  int tmp;
  
#line 74 
  tmp = ath_ahb_probe(arg0);
  
#line 74 
  return tmp;
}


#line 78  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_ahb.c.aux"
int ldv_emg_wrapper_ath_ahb_remove_3(struct platform_device *arg0)
{
  int tmp;
  
#line 79 
  tmp = ath_ahb_remove(arg0);
  
#line 79 
  return tmp;
}


#line 754  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_ahb.c.aux"
static struct ieee80211_hw *ldv_ieee80211_alloc_hw_72(size_t priv_data_len, struct ieee80211_ops const *ops)
{
  struct ieee80211_hw *tmp;
  
#line 758 
  tmp = ldv_emg_ieee80211_alloc_hw(priv_data_len,(struct ieee80211_ops *)ops);
  
#line 758 
  return tmp;
}


#line 762  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_ahb.c.aux"
static int ldv_request_irq_73(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev)
{
  int tmp;
  
#line 766 
  tmp = ldv_emg_request_irq(irq,handler,flags,(char *)name,dev);
  
#line 766 
  return tmp;
}


#line 770  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_ahb.c.aux"
static void ldv_free_irq_74(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  
#line 774 
  ldv_emg_free_irq(ldv_func_arg1,ldv_func_arg2);
  
#line 775 
  return;
}


#line 778  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_ahb.c.aux"
static void ldv_ieee80211_free_hw_75(struct ieee80211_hw *ldv_func_arg1)
{
  
#line 782 
  ldv_emg_ieee80211_free_hw(ldv_func_arg1);
  
#line 783 
  return;
}


#line 786  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_ahb.c.aux"
static void ldv_free_irq_76(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  
#line 790 
  ldv_emg_free_irq(ldv_func_arg1,ldv_func_arg2);
  
#line 791 
  return;
}


#line 794  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_ahb.c.aux"
static void ldv_ieee80211_free_hw_77(struct ieee80211_hw *ldv_func_arg1)
{
  
#line 798 
  ldv_emg_ieee80211_free_hw(ldv_func_arg1);
  
#line 799 
  return;
}


#line 802  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_ahb.c.aux"
static int ldv___platform_driver_register_78(struct platform_driver *ldv_func_arg1, struct module *ldv_func_arg2)
{
  int tmp;
  
#line 806 
  tmp = ldv_emg___platform_driver_register(ldv_func_arg1,ldv_func_arg2);
  
#line 806 
  return tmp;
}


#line 810  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_ahb.c.aux"
static void ldv_platform_driver_unregister_79(struct platform_driver *ldv_func_arg1)
{
  
#line 814 
  ldv_emg_platform_driver_unregister(ldv_func_arg1);
  
#line 815 
  return;
}


#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/bug.h"
void warn_slowpath_null(char const *, int const);


#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
void *memcpy(void *, void const *, size_t);


#line 355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_bh_0(spinlock_t *lock)
{
  
#line 357 
  _raw_spin_lock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 358 
  return;
}


#line 383 
static void ldv_spin_lock_bh_73(spinlock_t *lock);


#line 387 
static void ldv_spin_lock_bh_77(spinlock_t *lock);


#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_bh_0(spinlock_t *lock)
{
  
#line 406 
  _raw_spin_unlock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 407 
  return;
}


#line 432 
static void ldv_spin_unlock_bh_74(spinlock_t *lock);


#line 436 
static void ldv_spin_unlock_bh_78(spinlock_t *lock);


#line 37  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_wow.c.aux"
static void ldv_mutex_lock_72(struct mutex *ldv_func_arg1);


#line 41 
static void ldv_mutex_lock_76(struct mutex *ldv_func_arg1);


#line 45 
static void ldv_mutex_lock_80(struct mutex *ldv_func_arg1);


#line 51 
void ldv_mutex_model_lock(struct mutex *, char *);


#line 53 
void ldv_mutex_model_unlock(struct mutex *, char *);


#line 193  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
static void ldv_mutex_unlock_75(struct mutex *ldv_func_arg1);


#line 197 
static void ldv_mutex_unlock_79(struct mutex *ldv_func_arg1);


#line 201 
static void ldv_mutex_unlock_81(struct mutex *ldv_func_arg1);


#line 103  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm_wakeup.h"
int device_init_wakeup(struct device *, bool);


#line 104 
int device_set_wakeup_enable(struct device *, bool);


#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hardirq.h"
void synchronize_irq(unsigned int);


#line 579  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
void tasklet_kill(struct tasklet_struct *);


#line 1189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
int ath9k_hw_wow_apply_pattern(struct ath_hw *, u8 *, u8 *, int, int);


#line 1192 
u32 ath9k_hw_wow_wakeup(struct ath_hw *);


#line 1193 
void ath9k_hw_wow_enable(struct ath_hw *, u32);


#line 450  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
void ath9k_deinit_channel_context(struct ath_softc *sc);


#line 718 
void ath_stop_ani(struct ath_softc *sc);


#line 763 
void ath9k_start_btcoex(struct ath_softc *sc);


#line 764 
void ath9k_stop_btcoex(struct ath_softc *sc);


#line 835 
void ath9k_init_wow(struct ieee80211_hw *hw);


#line 836 
void ath9k_deinit_wow(struct ieee80211_hw *hw);


#line 837 
int ath9k_suspend(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan);


#line 839 
int ath9k_resume(struct ieee80211_hw *hw);


#line 840 
void ath9k_set_wakeup(struct ieee80211_hw *hw, bool enabled);


#line 1076 
void ath_cancel_work(struct ath_softc *sc);


#line 1077 
void ath_restart_work(struct ath_softc *sc);


#line 1085 
void ath9k_ps_wakeup(struct ath_softc *sc);


#line 1086 
void ath9k_ps_restore(struct ath_softc *sc);


#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/wow.c"
static struct wiphy_wowlan_support const ath9k_wowlan_support_legacy = {.flags = 6U, .n_patterns = 6, .pattern_max_len = 256, .pattern_min_len = 1, .max_pkt_offset = 0, .max_nd_match_sets = 0, .tcp = (struct wiphy_wowlan_tcp_support const *)0};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/wow.c"
static struct wiphy_wowlan_support const ath9k_wowlan_support = {.flags = 6U, .n_patterns = 14, .pattern_max_len = 256, .pattern_min_len = 1, .max_pkt_offset = 0, .max_nd_match_sets = 0, .tcp = (struct wiphy_wowlan_tcp_support const *)0};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/wow.c"
static u8 ath9k_wow_map_triggers(struct ath_softc *sc, struct cfg80211_wowlan *wowlan)
{
  
#line 36 
  u8 wow_triggers = (unsigned char)0U;
  
#line 38 
  if ((int)wowlan->disconnect != 0) 
#line 39 
                                    wow_triggers = (unsigned char)((unsigned int)wow_triggers | 12U); else ;
  
#line 41 
  if ((int)wowlan->magic_pkt != 0) 
#line 42 
                                   wow_triggers = (unsigned char)((unsigned int)wow_triggers | 2U); else ;
  
#line 44 
  if (wowlan->n_patterns != 0) 
#line 45 
                               wow_triggers = (unsigned char)((unsigned int)wow_triggers | 1U); else ;
  
#line 47 
  return wow_triggers;
}


#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/wow.c"
static int ath9k_wow_add_disassoc_deauth_pattern(struct ath_softc *sc)
{
  int ret;
  int i;
  u8 dis_deauth_pattern[256U];
  u8 dis_deauth_mask[256U];
  
#line 52 
  struct ath_hw *ah = sc->sc_ah;
  
#line 53 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 54 
  int pattern_count = 0;
  
#line 55 
  int byte_cnt = 0;
  
#line 59 
  memset((void *)(& dis_deauth_pattern),0,256UL);
  
#line 60 
  memset((void *)(& dis_deauth_mask),0,256UL);
  
#line 91 
  i = 0;
  
#line 91 
  goto ldv_53399;
  ldv_53398: 
#line 92 
  ;
  
#line 92 
  dis_deauth_mask[i] = (unsigned char)255U;
  
#line 91 
  i += 1;
  ldv_53399: 
#line 92 
  ;
  
#line 91 
  if (i <= 31) 
#line 93 
               goto ldv_53398; else 
#line 96 
                                    goto ldv_53400;
  ldv_53400: 
#line 97 
  ;
  
#line 95 
  dis_deauth_pattern[byte_cnt] = (unsigned char)160U;
  
#line 96 
  byte_cnt += 1;
  
#line 99 
  byte_cnt += 3;
  
#line 105 
  byte_cnt += 6;
  
#line 108 
  memcpy((void *)(& dis_deauth_pattern) + byte_cnt,(void const *)(& common->curbssid),6UL);
  
#line 110 
  byte_cnt += 6;
  
#line 113 
  memcpy((void *)(& dis_deauth_pattern) + byte_cnt,(void const *)(& common->curbssid),6UL);
  
#line 116 
  dis_deauth_mask[0] = (unsigned char)254U;
  
#line 117 
  dis_deauth_mask[1] = (unsigned char)3U;
  
#line 118 
  dis_deauth_mask[2] = (unsigned char)192U;
  
#line 120 
  ret = ath9k_hw_wow_apply_pattern(ah,(u8 *)(& dis_deauth_pattern),(u8 *)(& dis_deauth_mask),pattern_count,byte_cnt);
  
#line 122 
  if (ret != 0) 
#line 123 
                goto exit; else ;
  
#line 125 
  pattern_count += 1;
  
#line 130 
  dis_deauth_pattern[0] = (unsigned char)192U;
  
#line 132 
  ret = ath9k_hw_wow_apply_pattern(ah,(u8 *)(& dis_deauth_pattern),(u8 *)(& dis_deauth_mask),pattern_count,byte_cnt);
  exit: 
#line 134 
  ;
  
#line 135 
  return ret;
}


#line 138  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/wow.c"
static int ath9k_wow_add_pattern(struct ath_softc *sc, struct cfg80211_wowlan *wowlan)
{
  u8 wow_pattern[256U];
  u8 wow_mask[256U];
  int mask_len;
  
#line 141 
  struct ath_hw *ah = sc->sc_ah;
  
#line 142 
  struct cfg80211_pkt_pattern *patterns = wowlan->patterns;
  
#line 145 
  int ret = 0;
  
#line 146 
  s8 i = (signed char)0;
  
#line 148 
  i = (signed char)0;
  
#line 148 
  goto ldv_53415;
  ldv_53414: 
#line 149 
  ;
  
#line 149 
  mask_len = ((patterns + (int)i)->pattern_len + 7) / 8;
  
#line 150 
  memset((void *)(& wow_pattern),0,256UL);
  
#line 151 
  memset((void *)(& wow_mask),0,256UL);
  
#line 152 
  memcpy((void *)(& wow_pattern),(void const *)(patterns + (int)i)->pattern,(unsigned long)(patterns + (int)i)->pattern_len);
  
#line 153 
  memcpy((void *)(& wow_mask),(void const *)(patterns + (int)i)->mask,(unsigned long)mask_len);
  
#line 155 
  ret = ath9k_hw_wow_apply_pattern(ah,(u8 *)(& wow_pattern),(u8 *)(& wow_mask),(int)i + 2,(patterns + (int)i)->pattern_len);
  
#line 160 
  if (ret != 0) 
#line 161 
                goto ldv_53413; else ;
  
#line 148 
  i = (s8)((int)i + 1);
  ldv_53415: 
#line 149 
  ;
  
#line 148 
  if ((int)i < wowlan->n_patterns) 
#line 150 
                                   goto ldv_53414; else 
#line 153 
                                                        goto ldv_53413;
  ldv_53413: 
#line 154 
  ;
  
#line 164 
  return ret;
}


#line 167  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/wow.c"
int ath9k_suspend(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan)
{
  u8 triggers;
  int tmp_0;
  int tmp_1;
  bool tmp_3;
  int tmp_4;
  
#line 170 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 171 
  struct ath_hw *ah = sc->sc_ah;
  
#line 172 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 174 
  int ret = 0;
  
#line 176 
  ath9k_deinit_channel_context(sc);
  
#line 178 
  ldv_mutex_lock_72(& sc->mutex);
  
#line 180 
  tmp_0 = constant_test_bit(0L,(unsigned long const volatile *)(& common->op_flags));
  
#line 180 
  if (tmp_0 != 0) {
    
#line 181 
    ath_printk("\001",(struct ath_common const *)common,"Device not present\n");
    
#line 182 
    ret = -19;
    
#line 183 
    goto fail_wow;
  }
  else ;
  {
    
#line 186 
    int __ret_warn_on = wowlan == (struct cfg80211_wowlan *)0;
    
#line 186 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 186 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/wow.c",186); else ;
    
#line 186 
    tmp_1 = (long)(__ret_warn_on != 0);
  }
  
#line 186 
  if ((long)tmp_1 != 0L) {
    
#line 187 
    ath_printk("\001",(struct ath_common const *)common,"None of the WoW triggers enabled\n");
    
#line 188 
    ret = -22;
    
#line 189 
    goto fail_wow;
  }
  else ;
  
#line 192 
  if ((int)(sc->cur_chan)->nvifs > 1) {
    
#line 193 
    if ((common->debug_mask & 131072) != 0) 
#line 193 
                                            ath_printk("\001",(struct ath_common const *)common,"WoW for multivif is not yet supported\n"); else ;
    
#line 194 
    ret = 1;
    
#line 195 
    goto fail_wow;
  }
  else ;
  
#line 198 
  tmp_3 = ath9k_is_chanctx_enabled();
  
#line 198 
  if ((int)tmp_3 != 0) {
    int tmp_2;
    
#line 199 
    tmp_2 = constant_test_bit(6L,(unsigned long const volatile *)(& common->op_flags));
    
#line 199 
    if (tmp_2 != 0) {
      
#line 200 
      if ((common->debug_mask & 131072) != 0) 
#line 200 
                                              ath_printk("\001",(struct ath_common const *)common,"Multi-channel WOW is not supported\n"); else ;
      
#line 202 
      ret = 1;
      
#line 203 
      goto fail_wow;
    }
    else ;
  }
  else ;
  
#line 207 
  tmp_4 = constant_test_bit(3L,(unsigned long const volatile *)(& common->op_flags));
  
#line 207 
  if (tmp_4 == 0) {
    
#line 208 
    if ((common->debug_mask & 131072) != 0) 
#line 208 
                                            ath_printk("\001",(struct ath_common const *)common,"None of the STA vifs are associated\n"); else ;
    
#line 209 
    ret = 1;
    
#line 210 
    goto fail_wow;
  }
  else ;
  
#line 213 
  triggers = ath9k_wow_map_triggers(sc,wowlan);
  
#line 214 
  if ((unsigned int)triggers == 0U) {
    
#line 215 
    if ((common->debug_mask & 131072) != 0) 
#line 215 
                                            ath_printk("\001",(struct ath_common const *)common,"No valid WoW triggers\n"); else ;
    
#line 216 
    ret = 1;
    
#line 217 
    goto fail_wow;
  }
  else ;
  
#line 220 
  ath_cancel_work(sc);
  
#line 221 
  ath_stop_ani(sc);
  
#line 223 
  ath9k_ps_wakeup(sc);
  
#line 225 
  ath9k_stop_btcoex(sc);
  
#line 231 
  ret = ath9k_wow_add_disassoc_deauth_pattern(sc);
  
#line 232 
  if (ret != 0) {
    
#line 233 
    ath_printk("\001",(struct ath_common const *)common,"Unable to add disassoc/deauth pattern: %d\n",ret);
    
#line 235 
    goto fail_wow;
  }
  else ;
  
#line 238 
  if (((unsigned long)triggers & 1UL) != 0UL) {
    
#line 239 
    ret = ath9k_wow_add_pattern(sc,wowlan);
    
#line 240 
    if (ret != 0) {
      
#line 241 
      ath_printk("\001",(struct ath_common const *)common,"Unable to add user pattern: %d\n",ret);
      
#line 243 
      goto fail_wow;
    }
    else ;
  }
  else ;
  
#line 247 
  ldv_spin_lock_bh_73(& sc->sc_pcu_lock);
  
#line 253 
  sc->wow_intr_before_sleep = (unsigned int)ah->imask;
  
#line 254 
  ah->imask = (enum ath9k_int)((unsigned int)ah->imask & 2147483647U);
  
#line 255 
  ath9k_hw_disable_interrupts(ah);
  
#line 256 
  ah->imask = 2147745792;
  
#line 257 
  ath9k_hw_set_interrupts(ah);
  
#line 258 
  ath9k_hw_enable_interrupts(ah);
  
#line 260 
  ldv_spin_unlock_bh_74(& sc->sc_pcu_lock);
  
#line 266 
  synchronize_irq((unsigned int)sc->irq);
  
#line 267 
  tasklet_kill(& sc->intr_tq);
  
#line 269 
  ath9k_hw_wow_enable(ah,(unsigned int)triggers);
  
#line 271 
  ath9k_ps_restore(sc);
  
#line 272 
  if ((common->debug_mask & 131072) != 0) 
#line 272 
                                          ath_printk("\001",(struct ath_common const *)common,"Suspend with WoW triggers: 0x%x\n",(int)triggers); else ;
  
#line 274 
  set_bit(7L,(unsigned long volatile *)(& common->op_flags));
  fail_wow: 
#line 275 
  ;
  
#line 276 
  ldv_mutex_unlock_75(& sc->mutex);
  
#line 277 
  return ret;
}


#line 280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/wow.c"
int ath9k_resume(struct ieee80211_hw *hw)
{
  int __retres;
  u8 status;
  u32 tmp_0;
  
#line 282 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 283 
  struct ath_hw *ah = sc->sc_ah;
  
#line 284 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 287 
  ldv_mutex_lock_76(& sc->mutex);
  
#line 289 
  ath9k_ps_wakeup(sc);
  
#line 291 
  ldv_spin_lock_bh_77(& sc->sc_pcu_lock);
  
#line 293 
  ath9k_hw_disable_interrupts(ah);
  
#line 294 
  ah->imask = (enum ath9k_int)sc->wow_intr_before_sleep;
  
#line 295 
  ath9k_hw_set_interrupts(ah);
  
#line 296 
  ath9k_hw_enable_interrupts(ah);
  
#line 298 
  ldv_spin_unlock_bh_78(& sc->sc_pcu_lock);
  
#line 300 
  tmp_0 = ath9k_hw_wow_wakeup(ah);
  
#line 300 
  status = (unsigned char)tmp_0;
  
#line 301 
  if ((common->debug_mask & 131072) != 0) 
#line 301 
                                          ath_printk("\001",(struct ath_common const *)common,"Resume with WoW status: 0x%x\n",(int)status); else ;
  
#line 303 
  ath_restart_work(sc);
  
#line 304 
  ath9k_start_btcoex(sc);
  
#line 306 
  set_bit(7L,(unsigned long volatile *)(& common->op_flags));
  
#line 308 
  ath9k_ps_restore(sc);
  
#line 309 
  ldv_mutex_unlock_79(& sc->mutex);
  
#line 311 
  __retres = 0;
  
#line 311 
  return __retres;
}


#line 314  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/wow.c"
void ath9k_set_wakeup(struct ieee80211_hw *hw, bool enabled)
{
  
#line 316 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 317 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 319 
  ldv_mutex_lock_80(& sc->mutex);
  
#line 320 
  device_set_wakeup_enable(sc->dev,(_Bool)((bool)((int)enabled) != 0));
  
#line 321 
  ldv_mutex_unlock_81(& sc->mutex);
  
#line 323 
  if ((common->debug_mask & 131072) != 0) {
    char *tmp_0;
    
#line 323 
    if ((int)enabled != 0) 
#line 323 
                           tmp_0 = (char *)"enabled"; else 
#line 323 
                                                           tmp_0 = (char *)"disabled";
    
#line 323 
    ;
    
#line 323 
    ath_printk("\001",(struct ath_common const *)common,"WoW wakeup source is %s\n",tmp_0);
  }
  else ;
  
#line 324 
  return;
}


#line 327  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/wow.c"
void ath9k_init_wow(struct ieee80211_hw *hw)
{
  
#line 329 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 330 
  struct ath_hw *ah = sc->sc_ah;
  
#line 332 
  if ((sc->driver_data & 16UL) != 0UL || (int)sc->force_wow != 0) {
    
#line 333 
    if ((ah->hw_version.macVersion == 640U || ah->hw_version.macVersion == 704U) && (unsigned int)ah->hw_version.macRev > 1U) 
      
#line 334 
      (hw->wiphy)->wowlan = & ath9k_wowlan_support; else 
#line 336 
                                                         (hw->wiphy)->wowlan = & ath9k_wowlan_support_legacy;
    
#line 338 
    device_init_wakeup(sc->dev,(_Bool)1);
  }
  else ;
  
#line 340 
  return;
}


#line 342  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/wow.c"
void ath9k_deinit_wow(struct ieee80211_hw *hw)
{
  
#line 344 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 346 
  if ((sc->driver_data & 16UL) != 0UL || (int)sc->force_wow != 0) 
#line 347 
                                                                  device_init_wakeup(sc->dev,(_Bool)0); else ;
  
#line 348 
  return;
}


#line 737  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_wow.c.aux"
static void ldv_mutex_lock_72(struct mutex *ldv_func_arg1)
{
  
#line 741 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 742 
  return;
}


#line 745  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_wow.c.aux"
static void ldv_spin_lock_bh_73(spinlock_t *lock)
{
  
#line 749 
  ldv_spin_model_lock((char *)"sc_pcu_lock_of_ath_softc");
  
#line 751 
  spin_lock_bh_0(lock);
  
#line 752 
  return;
}


#line 755  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_wow.c.aux"
static void ldv_spin_unlock_bh_74(spinlock_t *lock)
{
  
#line 759 
  ldv_spin_model_unlock((char *)"sc_pcu_lock_of_ath_softc");
  
#line 761 
  spin_unlock_bh_0(lock);
  
#line 762 
  return;
}


#line 765  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_wow.c.aux"
static void ldv_mutex_unlock_75(struct mutex *ldv_func_arg1)
{
  
#line 769 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 770 
  return;
}


#line 773  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_wow.c.aux"
static void ldv_mutex_lock_76(struct mutex *ldv_func_arg1)
{
  
#line 777 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 778 
  return;
}


#line 781  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_wow.c.aux"
static void ldv_spin_lock_bh_77(spinlock_t *lock)
{
  
#line 785 
  ldv_spin_model_lock((char *)"sc_pcu_lock_of_ath_softc");
  
#line 787 
  spin_lock_bh_0(lock);
  
#line 788 
  return;
}


#line 791  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_wow.c.aux"
static void ldv_spin_unlock_bh_78(spinlock_t *lock)
{
  
#line 795 
  ldv_spin_model_unlock((char *)"sc_pcu_lock_of_ath_softc");
  
#line 797 
  spin_unlock_bh_0(lock);
  
#line 798 
  return;
}


#line 801  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_wow.c.aux"
static void ldv_mutex_unlock_79(struct mutex *ldv_func_arg1)
{
  
#line 805 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 806 
  return;
}


#line 809  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_wow.c.aux"
static void ldv_mutex_lock_80(struct mutex *ldv_func_arg1)
{
  
#line 813 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 814 
  return;
}


#line 817  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_wow.c.aux"
static void ldv_mutex_unlock_81(struct mutex *ldv_func_arg1)
{
  
#line 821 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 822 
  return;
}


#line 94  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static void __set_bit(long nr, unsigned long volatile *addr)
{
  
#line 96 
  ldv_inline_asm();
  
#line 97 
  return;
}


#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
int printk(char const * , ...);


#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list)
{
  
#line 27 
  list->next = list;
  
#line 28 
  list->prev = list;
  
#line 29 
  return;
}


#line 280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
void lockdep_init_map(struct lockdep_map *, char const *, struct lock_class_key *, int);


#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
void __raw_spin_lock_init(raw_spinlock_t *, char const *, struct lock_class_key *);


#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock)
{
  raw_spinlock_t *__retres;
  
#line 301 
  __retres = & lock->__anonCompField_spinlock_18.rlock;
  
#line 301 
  return __retres;
}


#line 442  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_irqrestore_0(spinlock_t *lock, unsigned long flags)
{
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
  }
  
#line 444 
  _raw_spin_unlock_irqrestore(& lock->__anonCompField_spinlock_18.rlock,flags);
  
#line 445 
  return;
}


#line 474 
static void ldv_spin_unlock_irqrestore_73(spinlock_t *lock, unsigned long flags);


#line 478 
static void ldv_spin_unlock_irqrestore_75_0(spinlock_t *lock, unsigned long flags);


#line 482 
static void ldv_spin_unlock_irqrestore_77(spinlock_t *lock, unsigned long flags);


#line 70  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_init.c.aux"
static void ldv___ldv_spin_lock_72(spinlock_t *ldv_func_arg1);


#line 74 
static void ldv___ldv_spin_lock_74_0(spinlock_t *ldv_func_arg1);


#line 78 
static void ldv___ldv_spin_lock_76(spinlock_t *ldv_func_arg1);


#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
void __mutex_init(struct mutex *, char const *, struct lock_class_key *);


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
void __init_waitqueue_head(wait_queue_head_t *, char const *, struct lock_class_key *);


#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/completion.h"
__inline static void init_completion(struct completion *x)
{
  
#line 75 
  x->done = 0U;
  {
    struct lock_class_key __key;
    
#line 76 
    __init_waitqueue_head(& x->wait,"&x->wait",& __key);
  }
  
#line 78 
  return;
}


#line 91 
void wait_for_completion(struct completion *);


#line 106 
void complete(struct completion *);


#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
void init_timer_key(struct timer_list *, unsigned int, char const *, struct lock_class_key *);


#line 232 
static int ldv_del_timer_sync_80(struct timer_list *ldv_func_arg1);


#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
void delayed_work_timer_fn(unsigned long);


#line 181 
void __init_work(struct work_struct *, int);


#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/iomap.h"
unsigned int ioread32(void *);


#line 37 
void iowrite32(u32, void *);


#line 639  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
void *devm_kmalloc(struct device *, size_t, gfp_t);


#line 645  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static void *devm_kzalloc(struct device *dev, size_t size, gfp_t gfp)
{
  void *tmp;
  
#line 647 
  tmp = devm_kmalloc(dev,size,gfp | 32768U);
  
#line 647 
  return tmp;
}


#line 231  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
void *dmam_alloc_coherent(struct device *, size_t, dma_addr_t *, gfp_t);


#line 585  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
static void ldv_tasklet_init_78(struct tasklet_struct *ldv_func_arg1, void (*ldv_func_arg2)(unsigned long ), unsigned long ldv_func_arg3);


#line 589 
static void ldv_tasklet_init_79(struct tasklet_struct *ldv_func_arg1, void (*ldv_func_arg2)(unsigned long ), unsigned long ldv_func_arg3);


#line 436  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
void cfg80211_chandef_create(struct cfg80211_chan_def *, struct ieee80211_channel *, enum nl80211_channel_type);


#line 3827 
int regulatory_hint(struct wiphy *, char const *);


#line 4269 
void wiphy_rfkill_stop_polling(struct wiphy *);


#line 2065  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
__inline static void _ieee80211_hw_set(struct ieee80211_hw *hw, enum ieee80211_hw_flags flg)
{
  
#line 2068 
  __set_bit((long)flg,(unsigned long volatile *)(& hw->flags));
  
#line 2069 
  return;
}


#line 2123 
struct ieee80211_hw *wiphy_to_ieee80211_hw(struct wiphy *);


#line 2142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
__inline static void SET_IEEE80211_PERM_ADDR(struct ieee80211_hw *hw, u8 *addr)
{
  
#line 2144 
  memcpy((void *)(& (hw->wiphy)->perm_addr),(void const *)addr,6UL);
  
#line 2145 
  return;
}


#line 3517 
int ieee80211_register_hw(struct ieee80211_hw *);


#line 3549 
char const *__ieee80211_create_tpt_led_trigger(struct ieee80211_hw *, unsigned int, struct ieee80211_tpt_blink const *, unsigned int);


#line 3651  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
__inline static char const *ieee80211_create_tpt_led_trigger(struct ieee80211_hw *hw, unsigned int flags, struct ieee80211_tpt_blink const *blink_table, unsigned int blink_table_len)
{
  char const *tmp;
  
#line 3656 
  tmp = __ieee80211_create_tpt_led_trigger(hw,flags,blink_table,blink_table_len);
  
#line 3656 
  return tmp;
}


#line 3671 
void ieee80211_unregister_hw(struct ieee80211_hw *);


#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath.h"
static u8 const ath_bcast_mac[6U] = {(unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/firmware.h"
int request_firmware_nowait(struct module *, bool, char const *, struct device *, gfp_t, void *, void (*)(struct firmware const *, void *));


#line 51 
void release_firmware(struct firmware const *);


#line 738  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mac.h"
int ath9k_hw_beaconq_setup(struct ath_hw *);


#line 252  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/regd.h"
bool ath_is_world_regd(struct ath_regulatory *);


#line 254 
int ath_regd_init(struct ath_regulatory *, struct wiphy *, void (*)(struct wiphy *, struct regulatory_request *));


#line 259 
void ath_reg_notifier_apply(struct wiphy *, struct regulatory_request *, struct ath_regulatory *);


#line 993  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
__inline static struct ath_regulatory *ath9k_hw_regulatory(struct ath_hw *ah)
{
  struct ath_regulatory *__retres;
  struct ath_common *tmp;
  
#line 995 
  tmp = ath9k_hw_common(ah);
  
#line 995 
  __retres = & tmp->regulatory;
  
#line 995 
  return __retres;
}


#line 1014 
void ath9k_hw_deinit(struct ath_hw *);


#line 1015 
int ath9k_hw_init(struct ath_hw *);


#line 1048 
void ath9k_hw_set_txpowerlimit(struct ath_hw *, u32, bool);


#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/common-init.h"
int ath9k_cmn_init_channels_rates(struct ath_common *);


#line 20 
void ath9k_cmn_reload_chainmask(struct ath_hw *);


#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/common.h"
struct ath9k_channel *ath9k_cmn_get_channel(struct ieee80211_hw *, struct ath_hw *, struct cfg80211_chan_def *);


#line 89 
void ath9k_cmn_update_txpow(struct ath_hw *, u16, u16, u16 *);


#line 91 
void ath9k_cmn_init_crypto(struct ath_hw *);


#line 249  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.h"
int ath9k_init_debug(struct ath_hw *ah);


#line 250 
void ath9k_deinit_debug(struct ath_softc *sc);


#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/dfs_pattern_detector.h"
struct dfs_pattern_detector *dfs_pattern_detector_init(struct ath_common *, enum nl80211_dfs_regions);


#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
int ath9k_modparam_nohwcrypt;

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
int ath9k_led_blink;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
bool is_ath9k_unloaded;

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
int ath9k_use_chanctx;

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
int ath_descdma_setup(struct ath_softc *sc, struct ath_descdma *dd, struct list_head *head, char const *name, int nbuf, int ndesc, bool is_tx);


#line 433 
void ath_chanctx_init(struct ath_softc *sc);


#line 448 
void ath9k_init_channel_context(struct ath_softc *sc);


#line 449 
void ath9k_offchannel_init(struct ath_softc *sc);


#line 451 
int ath9k_init_p2p(struct ath_softc *sc);


#line 452 
void ath9k_deinit_p2p(struct ath_softc *sc);


#line 551 
int ath_rx_init(struct ath_softc *sc, int nbufs);


#line 552 
void ath_rx_cleanup(struct ath_softc *sc);


#line 554 
struct ath_txq *ath_txq_setup(struct ath_softc *sc, int qtype, int subtype);


#line 558 
void ath_tx_cleanupq(struct ath_softc *sc, struct ath_txq *txq);


#line 565 
int ath_tx_init(struct ath_softc *sc, int nbufs);


#line 712 
void ath_reset_work(struct work_struct *work);


#line 714 
void ath_hw_pll_work(struct work_struct *work);


#line 715 
void ath_paprd_calibrate(struct work_struct *work);


#line 716 
void ath_ani_calibrate(unsigned long data);


#line 723 
void ath_ps_full_sleep(unsigned long data);


#line 761 
int ath9k_init_btcoex(struct ath_softc *sc);


#line 762 
void ath9k_deinit_btcoex(struct ath_softc *sc);


#line 814 
void ath_init_leds(struct ath_softc *sc);


#line 815 
void ath_deinit_leds(struct ath_softc *sc);


#line 816 
void ath_fill_led_pin(struct ath_softc *sc);


#line 1066  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
__inline static void ath_read_cachesize(struct ath_common *common, int *csz)
{
  
#line 1068 
  (*((common->bus_ops)->read_cachesize))(common,csz);
  
#line 1069 
  return;
}


#line 1071 
void ath9k_tasklet(unsigned long data);


#line 1072 
int ath_cabq_update(struct ath_softc *sc);


#line 1083 
void ath_start_rfkill_poll(struct ath_softc *sc);


#line 1089 
int ath_pci_init(void);


#line 1090 
void ath_pci_exit(void);


#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static char *dev_info = (char *)"ath9k";

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static unsigned int ath9k_debug = 1024U;

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static int ath9k_btcoex_enable;

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static int ath9k_bt_ant_diversity;

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static int ath9k_ps_enable;

#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static struct ieee80211_tpt_blink const ath9k_tpt_blink[10U] = {{.throughput = 0, .blink_time = 334}, {.throughput = 1024, .blink_time = 260}, {.throughput = 5120, .blink_time = 220}, {.throughput = 10240, .blink_time = 190}, {.throughput = 20480, .blink_time = 170}, {.throughput = 51200, .blink_time = 150}, {.throughput = 71680, .blink_time = 130}, {.throughput = 102400, .blink_time = 110}, {.throughput = 204800, .blink_time = 80}, {.throughput = 307200, .blink_time = 50}};

#line 89 
static void ath9k_deinit_softc(struct ath_softc *sc);


#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static void ath9k_op_ps_wakeup(struct ath_common *common)
{
  
#line 93 
  ath9k_ps_wakeup((struct ath_softc *)common->priv);
  
#line 94 
  return;
}


#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static void ath9k_op_ps_restore(struct ath_common *common)
{
  
#line 98 
  ath9k_ps_restore((struct ath_softc *)common->priv);
  
#line 99 
  return;
}


#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static struct ath_ps_ops ath9k_ps_ops = {.wakeup = & ath9k_op_ps_wakeup, .restore = & ath9k_op_ps_restore};

#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static void ath9k_iowrite32(void *hw_priv, u32 val, u32 reg_offset)
{
  
#line 114 
  struct ath_hw *ah = (struct ath_hw *)hw_priv;
  
#line 115 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 116 
  struct ath_softc *sc = (struct ath_softc *)common->priv;
  
#line 118 
  if (ah->config.serialize_regmode == 1) {
    unsigned long flags;
    
#line 120 
    ldv___ldv_spin_lock_72(& sc->sc_serial_rw);
    
#line 121 
    iowrite32(val,sc->mem + reg_offset);
    
#line 122 
    ldv_spin_unlock_irqrestore_73(& sc->sc_serial_rw,flags);
  }
  else 
#line 124 
       iowrite32(val,sc->mem + reg_offset);
  
#line 125 
  return;
}


#line 127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static unsigned int ath9k_ioread32(void *hw_priv, u32 reg_offset)
{
  u32 val;
  
#line 129 
  struct ath_hw *ah = (struct ath_hw *)hw_priv;
  
#line 130 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 131 
  struct ath_softc *sc = (struct ath_softc *)common->priv;
  
#line 134 
  if (ah->config.serialize_regmode == 1) {
    unsigned long flags;
    
#line 136 
    ldv___ldv_spin_lock_74_0(& sc->sc_serial_rw);
    
#line 137 
    val = ioread32(sc->mem + reg_offset);
    
#line 138 
    ldv_spin_unlock_irqrestore_75_0(& sc->sc_serial_rw,flags);
  }
  else 
#line 140 
       val = ioread32(sc->mem + reg_offset);
  
#line 141 
  return val;
}


#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static void ath9k_multi_ioread32(void *hw_priv, u32 *addr, u32 *val, u16 count)
{
  int i;
  
#line 149 
  i = 0;
  
#line 149 
  goto ldv_54906;
  ldv_54905: 
#line 150 
  ;
  
#line 150 
  *(val + i) = ath9k_ioread32(hw_priv,*(addr + i));
  
#line 149 
  i += 1;
  ldv_54906: 
#line 150 
  ;
  
#line 149 
  if ((int)count > i) 
#line 151 
                      goto ldv_54905; else 
#line 154 
                                           goto ldv_54907;
  ldv_54907: 
#line 155 
  ;
  
#line 156 
  return;
}


#line 154  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static unsigned int __ath9k_reg_rmw(struct ath_softc *sc, u32 reg_offset, u32 set, u32 clr)
{
  u32 val;
  
#line 159 
  val = ioread32(sc->mem + reg_offset);
  
#line 160 
  val = ~ clr & val;
  
#line 161 
  val |= set;
  
#line 162 
  iowrite32(val,sc->mem + reg_offset);
  
#line 164 
  return val;
}


#line 167  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static unsigned int ath9k_reg_rmw(void *hw_priv, u32 reg_offset, u32 set, u32 clr)
{
  u32 val;
  
#line 169 
  struct ath_hw *ah = (struct ath_hw *)hw_priv;
  
#line 170 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 171 
  struct ath_softc *sc = (struct ath_softc *)common->priv;
  
#line 172 
  unsigned long flags = flags;
  
#line 175 
  if (ah->config.serialize_regmode == 1) {
    
#line 176 
    ldv___ldv_spin_lock_76(& sc->sc_serial_rw);
    
#line 177 
    val = __ath9k_reg_rmw(sc,reg_offset,set,clr);
    
#line 178 
    ldv_spin_unlock_irqrestore_77(& sc->sc_serial_rw,flags);
  }
  else 
#line 180 
       val = __ath9k_reg_rmw(sc,reg_offset,set,clr);
  
#line 182 
  return val;
}


#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static void ath9k_reg_notifier(struct wiphy *wiphy, struct regulatory_request *request)
{
  
#line 192 
  struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
  
#line 193 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 194 
  struct ath_hw *ah = sc->sc_ah;
  
#line 195 
  struct ath_regulatory *reg = ath9k_hw_regulatory(ah);
  
#line 197 
  ath_reg_notifier_apply(wiphy,request,reg);
  
#line 200 
  if (ah->curchan == (struct ath9k_channel *)0) 
#line 201 
                                                goto return_label; else ;
  
#line 203 
  (sc->cur_chan)->txpower = (unsigned short)((unsigned int)((unsigned short)((ah->curchan)->chan)->max_power) * 2U);
  
#line 204 
  ath9k_ps_wakeup(sc);
  
#line 205 
  ath9k_hw_set_txpowerlimit(ah,(unsigned int)(sc->cur_chan)->txpower,(_Bool)0);
  
#line 206 
  ath9k_cmn_update_txpow(ah,(unsigned short)((int)(sc->cur_chan)->cur_txpower),(unsigned short)((int)(sc->cur_chan)->txpower),& (sc->cur_chan)->cur_txpower);
  
#line 210 
  if (sc->dfs_detector != (struct dfs_pattern_detector *)0) 
#line 211 
                                                            (*((sc->dfs_detector)->set_dfs_domain))(sc->dfs_detector,request->dfs_region); else ;
  
#line 213 
  ath9k_ps_restore(sc);
  return_label: 
#line 214 
                return;
}


#line 221  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
int ath_descdma_setup(struct ath_softc *sc, struct ath_descdma *dd, struct list_head *head, char const *name, int nbuf, int ndesc, bool is_tx)
{
  int __retres;
  u8 *ds;
  int i;
  int bsize;
  int desc_len;
  
#line 225 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 229 
  if ((common->debug_mask & 512) != 0) 
#line 229 
                                       ath_printk("\001",(struct ath_common const *)common,"%s DMA: %u buffers %u desc/buf\n",name,nbuf,ndesc); else ;
  
#line 232 
  INIT_LIST_HEAD(head);
  
#line 234 
  if ((int)is_tx != 0) 
#line 235 
                       desc_len = (int)(sc->sc_ah)->caps.tx_desc_len; else 
                                                                    
#line 237 
                                                                    desc_len = 104;
  
#line 240 
  if (((unsigned int)desc_len & 3U) != 0U) {
    
#line 241 
    ath_printk("\001",(struct ath_common const *)common,"ath_desc not DWORD aligned\n");
    
#line 242 
    if ((long)(((unsigned int)desc_len & 3U) != 0U) != 0L) {
      
#line 244 
      ldv_inline_asm();
      
#line 242 
      ;
    }
    else ;
    
#line 243 
    __retres = -12;
    
#line 243 
    goto return_label;
  }
  else ;
  
#line 246 
  dd->dd_desc_len = (unsigned int)((desc_len * nbuf) * ndesc);
  
#line 253 
  if (((sc->sc_ah)->caps.hw_caps & 8U) == 0U) {
    u32 dma_len;
    
#line 254 
    u32 ndesc_skipped = dd->dd_desc_len / 4096U;
    
#line 258 
    goto ldv_54951;
    ldv_54950: 
#line 259 
    ;
    
#line 259 
    dma_len = ndesc_skipped * (unsigned int)desc_len;
    
#line 260 
    dd->dd_desc_len += dma_len;
    
#line 262 
    ndesc_skipped = dma_len / 4096U;
    ldv_54951: 
#line 263 
    ;
    
#line 258 
    if (ndesc_skipped != 0U) 
#line 260 
                             goto ldv_54950; else 
#line 263 
                                                  goto ldv_54952;
    ldv_54952: 
#line 264 
    ;
  }
  else ;
  
#line 267 
  dd->dd_desc = dmam_alloc_coherent(sc->dev,(unsigned long)dd->dd_desc_len,& dd->dd_desc_paddr,208U);
  
#line 269 
  if (dd->dd_desc == (void *)0) {
    
#line 270 
    __retres = -12;
    
#line 270 
    goto return_label;
  }
  else ;
  
#line 272 
  ds = (u8 *)dd->dd_desc;
  
#line 273 
  if ((common->debug_mask & 512) != 0) 
#line 273 
                                       ath_printk("\001",(struct ath_common const *)common,"%s DMA map: %p (%u) -> %llx (%u)\n",name,ds,dd->dd_desc_len,dd->dd_desc_paddr,dd->dd_desc_len); else ;
  
#line 278 
  if ((int)is_tx != 0) {
    struct ath_buf *bf;
    
#line 281 
    bsize = (int)((unsigned long)nbuf * (unsigned long)96U);
    
#line 282 
    bf = (struct ath_buf *)devm_kzalloc(sc->dev,(unsigned long)bsize,208U);
    
#line 283 
    if (bf == (struct ath_buf *)0) {
      
#line 284 
      __retres = -12;
      
#line 284 
      goto return_label;
    }
    else ;
    
#line 286 
    i = 0;
    
#line 286 
    goto ldv_54958;
    ldv_54957: 
#line 287 
    ;
    
#line 287 
    bf->bf_desc = (void *)ds;
    
#line 288 
    bf->bf_daddr = dd->dd_desc_paddr + (unsigned long long)((long)ds - (long)dd->dd_desc);
    
#line 290 
    if (((sc->sc_ah)->caps.hw_caps & 8U) == 0U) {
      
#line 297 
      goto ldv_54955;
      ldv_54954: 
#line 298 
      ;
      
#line 298 
      if ((long)((char *)bf->bf_desc >= (char *)dd->dd_desc + dd->dd_desc_len) != 0L) {
        
#line 300 
        ldv_inline_asm();
        
#line 298 
        ;
      }
      else ;
      
#line 302 
      ds += desc_len * ndesc;
      
#line 303 
      bf->bf_desc = (void *)ds;
      
#line 304 
      bf->bf_daddr = dd->dd_desc_paddr + (unsigned long long)((long)ds - (long)dd->dd_desc);
      ldv_54955: 
#line 305 
      ;
      
#line 297 
      if ((bf->bf_daddr & 4095ULL) > 3967ULL) 
#line 299 
                                              goto ldv_54954; else 
#line 302 
                                                                   goto ldv_54956;
      ldv_54956: 
#line 303 
      ;
    }
    else ;
    
#line 307 
    list_add_tail(& bf->list,head);
    
#line 286 
    i += 1;
    
#line 286 
    bf += 1;
    
#line 286 
    ds += desc_len * ndesc;
    ldv_54958: 
#line 287 
    ;
    
#line 286 
    if (i < nbuf) 
#line 288 
                  goto ldv_54957; else 
#line 291 
                                       goto ldv_54959;
    ldv_54959: 
#line 292 
    ;
  }
  else {
    struct ath_rxbuf *bf_0;
    
#line 312 
    bsize = (int)((unsigned long)nbuf * (unsigned long)48U);
    
#line 313 
    bf_0 = (struct ath_rxbuf *)devm_kzalloc(sc->dev,(unsigned long)bsize,208U);
    
#line 314 
    if (bf_0 == (struct ath_rxbuf *)0) {
      
#line 315 
      __retres = -12;
      
#line 315 
      goto return_label;
    }
    else ;
    
#line 317 
    i = 0;
    
#line 317 
    goto ldv_54965;
    ldv_54964: 
#line 318 
    ;
    
#line 318 
    bf_0->bf_desc = (void *)ds;
    
#line 319 
    bf_0->bf_daddr = dd->dd_desc_paddr + (unsigned long long)((long)ds - (long)dd->dd_desc);
    
#line 321 
    if (((sc->sc_ah)->caps.hw_caps & 8U) == 0U) {
      
#line 328 
      goto ldv_54962;
      ldv_54961: 
#line 329 
      ;
      
#line 329 
      if ((long)((char *)bf_0->bf_desc >= (char *)dd->dd_desc + dd->dd_desc_len) != 0L) {
        
#line 331 
        ldv_inline_asm();
        
#line 329 
        ;
      }
      else ;
      
#line 333 
      ds += desc_len * ndesc;
      
#line 334 
      bf_0->bf_desc = (void *)ds;
      
#line 335 
      bf_0->bf_daddr = dd->dd_desc_paddr + (unsigned long long)((long)ds - (long)dd->dd_desc);
      ldv_54962: 
#line 336 
      ;
      
#line 328 
      if ((bf_0->bf_daddr & 4095ULL) > 3967ULL) 
#line 330 
                                                goto ldv_54961; else 
                                                                  
#line 333 
                                                                  goto ldv_54963;
      ldv_54963: 
#line 334 
      ;
    }
    else ;
    
#line 338 
    list_add_tail(& bf_0->list,head);
    
#line 317 
    i += 1;
    
#line 317 
    bf_0 += 1;
    
#line 317 
    ds += desc_len * ndesc;
    ldv_54965: 
#line 318 
    ;
    
#line 317 
    if (i < nbuf) 
#line 319 
                  goto ldv_54964; else 
#line 322 
                                       goto ldv_54966;
    ldv_54966: 
#line 323 
    ;
  }
  
#line 341 
  __retres = 0;
  return_label: 
#line 341 
                return __retres;
}


#line 344  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static int ath9k_init_queues(struct ath_softc *sc)
{
  int __retres;
  int tmp;
  
#line 346 
  int i = 0;
  
#line 348 
  tmp = ath9k_hw_beaconq_setup(sc->sc_ah);
  
#line 348 
  sc->beacon.beaconq = (unsigned int)tmp;
  
#line 349 
  sc->beacon.cabq = ath_txq_setup(sc,3,0);
  
#line 350 
  ath_cabq_update(sc);
  
#line 352 
  sc->tx.uapsdq = ath_txq_setup(sc,4,0);
  
#line 354 
  i = 0;
  
#line 354 
  goto ldv_54972;
  ldv_54971: 
#line 355 
  ;
  
#line 355 
  sc->tx.txq_map[i] = ath_txq_setup(sc,1,i);
  
#line 356 
  (sc->tx.txq_map[i])->mac80211_qnum = i;
  
#line 357 
  sc->tx.txq_max_pending[i] = 123U;
  
#line 354 
  i += 1;
  ldv_54972: 
#line 355 
  ;
  
#line 354 
  if (i <= 3) 
#line 356 
              goto ldv_54971; else 
#line 359 
                                   goto ldv_54973;
  ldv_54973: 
#line 360 
  ;
  
#line 359 
  __retres = 0;
  
#line 359 
  return __retres;
}


#line 362  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static void ath9k_init_misc(struct ath_softc *sc)
{
  
#line 364 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 365 
  int i = 0;
  {
    struct lock_class_key __key;
    
#line 367 
    init_timer_key(& common->ani.timer,0U,"((&common->ani.timer))",& __key);
  }
  
#line 367 
  common->ani.timer.function = & ath_ani_calibrate;
  
#line 367 
  common->ani.timer.data = (unsigned long)sc;
  
#line 369 
  common->last_rssi = 127;
  
#line 370 
  memcpy((void *)(& common->bssidmask),(void const *)(& ath_bcast_mac),6UL);
  
#line 371 
  sc->beacon.slottime = 9;
  
#line 373 
  i = 0;
  
#line 373 
  goto ldv_54984;
  ldv_54983: 
#line 374 
  ;
  
#line 374 
  sc->beacon.bslot[i] = (struct ieee80211_vif *)0;
  
#line 373 
  i += 1;
  ldv_54984: 
#line 374 
  ;
  
#line 373 
  if ((unsigned int)i <= 7U) 
#line 375 
                             goto ldv_54983; else 
#line 378 
                                                  goto ldv_54985;
  ldv_54985: 
#line 379 
  ;
  
#line 376 
  if (((sc->sc_ah)->caps.hw_caps & 1024U) != 0U) 
#line 377 
                                                 sc->ant_comb.count = (unsigned short)95U; else ;
  
#line 379 
  sc->spec_priv.ah = sc->sc_ah;
  
#line 380 
  sc->spec_priv.spec_config.enabled = (_Bool)0;
  
#line 381 
  sc->spec_priv.spec_config.short_repeat = (_Bool)1;
  
#line 382 
  sc->spec_priv.spec_config.count = (unsigned char)8U;
  
#line 383 
  sc->spec_priv.spec_config.endless = (_Bool)0;
  
#line 384 
  sc->spec_priv.spec_config.period = (unsigned char)255U;
  
#line 385 
  sc->spec_priv.spec_config.fft_period = (unsigned char)15U;
  
#line 386 
  return;
}


#line 388  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static void ath9k_init_pcoem_platform(struct ath_softc *sc)
{
  
#line 390 
  struct ath_hw *ah = sc->sc_ah;
  
#line 391 
  struct ath9k_hw_capabilities *pCap = & ah->caps;
  
#line 392 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 397 
  if ((common->bus_ops)->ath_bus_type != (unsigned int)ATH_PCI) 
#line 398 
                                                                goto return_label; else ;
  
#line 400 
  if ((sc->driver_data & 3UL) != 0UL) {
    char *tmp_0;
    
#line 402 
    ah->config.xlna_gpio = 9U;
    
#line 403 
    ah->config.xatten_margin_cfg = (_Bool)1;
    
#line 404 
    ah->config.alt_mingainidx = (_Bool)1;
    
#line 405 
    ah->config.ant_ctrl_comm2g_switch_enable = 768904U;
    
#line 406 
    sc->ant_comb.low_rssi_thresh = 20;
    
#line 407 
    sc->ant_comb.fast_div_bias = 3;
    
#line 409 
    if ((sc->driver_data & 1UL) != 0UL) 
#line 409 
                                        tmp_0 = (char *)"CUS198"; else 
                                                                    
#line 409 
                                                                    tmp_0 = (char *)"CUS230";
    
#line 409 
    ;
    
#line 409 
    ath_printk("\001",(struct ath_common const *)common,"Set parameters for %s\n",tmp_0);
  }
  else ;
  
#line 414 
  if ((sc->driver_data & 4UL) != 0UL) 
#line 415 
                                      ath_printk("\001",(struct ath_common const *)common,"CUS217 card detected\n"); else ;
  
#line 417 
  if ((sc->driver_data & 8UL) != 0UL) 
#line 418 
                                      ath_printk("\001",(struct ath_common const *)common,"CUS252 card detected\n"); else ;
  
#line 420 
  if ((sc->driver_data & 128UL) != 0UL) 
#line 421 
                                        ath_printk("\001",(struct ath_common const *)common,"WB335 1-ANT card detected\n"); else ;
  
#line 423 
  if ((sc->driver_data & 256UL) != 0UL) 
#line 424 
                                        ath_printk("\001",(struct ath_common const *)common,"WB335 2-ANT card detected\n"); else ;
  
#line 426 
  if ((sc->driver_data & 1024UL) != 0UL) 
#line 427 
                                         ath_printk("\001",(struct ath_common const *)common,"Killer Wireless card detected\n"); else ;
  
#line 435 
  if ((sc->driver_data & 384UL) != 0UL) {
    
#line 436 
    if ((sc->driver_data & 32UL) == 0UL) 
#line 437 
                                         pCap->hw_caps &= 4294966271U; else ;
  }
  else ;
  
#line 440 
  if ((sc->driver_data & 32UL) != 0UL) {
    
#line 441 
    pCap->hw_caps |= 131072U;
    
#line 442 
    ath_printk("\001",(struct ath_common const *)common,"Set BT/WLAN RX diversity capability\n");
  }
  else ;
  
#line 445 
  if ((sc->driver_data & 64UL) != 0UL) {
    
#line 446 
    ah->config.pcie_waen = 4212539U;
    
#line 447 
    ath_printk("\001",(struct ath_common const *)common,"Enable WAR for ASPM D3/L1\n");
  }
  else ;
  
#line 455 
  ah->config.pll_pwrsave = (unsigned char)1U;
  
#line 457 
  if ((sc->driver_data & 512UL) != 0UL) {
    
#line 458 
    ah->config.pll_pwrsave = (unsigned char)0U;
    
#line 459 
    ath_printk("\001",(struct ath_common const *)common,"Disable PLL PowerSave\n");
  }
  else ;
  
#line 462 
  if ((sc->driver_data & 2048UL) != 0UL) 
#line 463 
                                         ah->config.led_active_high = (_Bool)1; else ;
  return_label: 
#line 464 
                return;
}


#line 466  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static void ath9k_eeprom_request_cb(struct firmware const *eeprom_blob, void *ctx)
{
  
#line 469 
  struct ath9k_eeprom_ctx *ec = (struct ath9k_eeprom_ctx *)ctx;
  
#line 471 
  if (eeprom_blob != (struct firmware const *)0) 
#line 472 
                                                 (ec->ah)->eeprom_blob = eeprom_blob; else ;
  
#line 474 
  complete(& ec->complete);
  
#line 475 
  return;
}


#line 477  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static int ath9k_eeprom_request(struct ath_softc *sc, char const *name)
{
  int __retres;
  struct ath9k_eeprom_ctx ec;
  struct ath_hw *tmp;
  int err;
  
#line 480 
  tmp = sc->sc_ah;
  
#line 480 
  struct ath_hw *ah = ah;
  
#line 484 
  init_completion(& ec.complete);
  
#line 485 
  ec.ah = sc->sc_ah;
  
#line 487 
  err = request_firmware_nowait(& __this_module,(_Bool)1,name,sc->dev,208U,(void *)(& ec),& ath9k_eeprom_request_cb);
  
#line 489 
  if (err < 0) {
    struct ath_common *tmp_0;
    
#line 490 
    tmp_0 = ath9k_hw_common(ah);
    
#line 490 
    ath_printk("\001",(struct ath_common const *)tmp_0,"EEPROM request failed\n");
    
#line 492 
    __retres = err;
    
#line 492 
    goto return_label;
  }
  else ;
  
#line 495 
  wait_for_completion(& ec.complete);
  
#line 497 
  if (ah->eeprom_blob == (struct firmware const *)0) {
    struct ath_common *tmp_1;
    
#line 498 
    ;
    
#line 498 
    tmp_1 = ath9k_hw_common(ah);
    
#line 498 
    ath_printk("\001",(struct ath_common const *)tmp_1,"Unable to load EEPROM file %s\n",name);
    
#line 500 
    __retres = -22;
    
#line 500 
    goto return_label;
  }
  else ;
  
#line 503 
  __retres = 0;
  return_label: 
#line 503 
                return __retres;
}


#line 506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static void ath9k_eeprom_release(struct ath_softc *sc)
{
  
#line 508 
  release_firmware((sc->sc_ah)->eeprom_blob);
  
#line 509 
  return;
}


#line 511  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static int ath9k_init_soc_platform(struct ath_softc *sc)
{
  int __retres;
  
#line 513 
  struct ath9k_platform_data *pdata = (struct ath9k_platform_data *)(sc->dev)->platform_data;
  
#line 514 
  struct ath_hw *ah = sc->sc_ah;
  
#line 515 
  int ret = 0;
  
#line 517 
  if (pdata == (struct ath9k_platform_data *)0) {
    
#line 518 
    __retres = 0;
    
#line 518 
    goto return_label;
  }
  else ;
  
#line 520 
  if (pdata->eeprom_name != (char const *)0) {
    
#line 521 
    ret = ath9k_eeprom_request(sc,pdata->eeprom_name);
    
#line 522 
    if (ret != 0) {
      
#line 523 
      __retres = ret;
      
#line 523 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 526 
  if ((int)pdata->tx_gain_buffalo != 0) 
#line 527 
                                        ah->config.tx_gain_buffalo = (_Bool)1; else ;
  
#line 529 
  __retres = ret;
  return_label: 
#line 529 
                return __retres;
}


#line 532  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static int ath9k_init_softc(u16 devid, struct ath_softc *sc, struct ath_bus_ops const *bus_ops)
{
  int __retres;
  struct ath9k_hw_capabilities *pCap;
  struct ath_common *common;
  int i;
  int tmp_1;
  bool tmp_0;
  
#line 535 
  struct ath9k_platform_data *pdata = (struct ath9k_platform_data *)(sc->dev)->platform_data;
  
#line 536 
  struct ath_hw *ah = (struct ath_hw *)0;
  
#line 539 
  int ret = 0;
  
#line 540 
  int csz = 0;
  
#line 542 
  ah = (struct ath_hw *)devm_kzalloc(sc->dev,9456UL,208U);
  
#line 543 
  if (ah == (struct ath_hw *)0) {
    
#line 544 
    __retres = -12;
    
#line 544 
    goto return_label;
  }
  else ;
  
#line 546 
  ah->dev = sc->dev;
  
#line 547 
  ah->hw = sc->hw;
  
#line 548 
  ah->hw_version.devid = devid;
  
#line 549 
  ah->reg_ops.read = & ath9k_ioread32;
  
#line 550 
  ah->reg_ops.multi_read = & ath9k_multi_ioread32;
  
#line 551 
  ah->reg_ops.write = & ath9k_iowrite32;
  
#line 552 
  ah->reg_ops.rmw = & ath9k_reg_rmw;
  
#line 553 
  pCap = & ah->caps;
  
#line 555 
  common = ath9k_hw_common(ah);
  
#line 558 
  set_bit(0L,(unsigned long volatile *)(& common->op_flags));
  
#line 560 
  sc->sc_ah = ah;
  
#line 561 
  sc->dfs_detector = dfs_pattern_detector_init(common,(enum nl80211_dfs_regions)NL80211_DFS_UNSET);
  
#line 562 
  sc->tx99_power = (short)64;
  {
    struct lock_class_key __key;
    
#line 563 
    __init_waitqueue_head(& sc->tx_wait,"&sc->tx_wait",& __key);
  }
  
#line 564 
  sc->cur_chan = & sc->chanctx[0];
  
#line 565 
  tmp_0 = ath9k_is_chanctx_enabled();
  
#line 565 
  if (tmp_0) 
#line 565 
             tmp_1 = 0; else 
#line 565 
                             tmp_1 = 1;
  
#line 565 
  if (tmp_1) 
#line 566 
             (sc->cur_chan)->hw_queue_base = 0; else ;
  
#line 568 
  if (pdata == (struct ath9k_platform_data *)0 || (int)pdata->use_eeprom != 0) {
    
#line 569 
    ah->ah_flags |= 1U;
    
#line 570 
    (sc->sc_ah)->led_pin = -1;
  }
  else {
    
#line 572 
    (sc->sc_ah)->gpio_mask = pdata->gpio_mask;
    
#line 573 
    (sc->sc_ah)->gpio_val = pdata->gpio_val;
    
#line 574 
    (sc->sc_ah)->led_pin = pdata->led_pin;
    
#line 575 
    ah->is_clk_25mhz = pdata->is_clk_25mhz;
    
#line 576 
    ah->get_mac_revision = pdata->get_mac_revision;
    
#line 577 
    ah->external_reset = pdata->external_reset;
    
#line 578 
    ah->disable_2ghz = pdata->disable_2ghz;
    
#line 579 
    ah->disable_5ghz = pdata->disable_5ghz;
    
#line 580 
    if (! pdata->endian_check) 
#line 581 
                               ah->ah_flags |= 8U; else ;
  }
  
#line 584 
  common->ops = (struct ath_ops const *)(& ah->reg_ops);
  
#line 585 
  common->bus_ops = bus_ops;
  
#line 586 
  common->ps_ops = (struct ath_ps_ops const *)(& ath9k_ps_ops);
  
#line 587 
  common->ah = (void *)ah;
  
#line 588 
  common->hw = sc->hw;
  
#line 589 
  common->priv = (void *)sc;
  
#line 590 
  common->debug_mask = (int)ath9k_debug;
  
#line 591 
  common->btcoex_enabled = (_Bool)(ath9k_btcoex_enable == 1);
  
#line 592 
  common->disable_ani = (_Bool)0;
  
#line 597 
  ath9k_init_pcoem_platform(sc);
  
#line 599 
  ret = ath9k_init_soc_platform(sc);
  
#line 600 
  if (ret != 0) {
    
#line 601 
    __retres = ret;
    
#line 601 
    goto return_label;
  }
  else ;
  
#line 610 
  if ((! common->btcoex_enabled && ath9k_bt_ant_diversity != 0) && (pCap->hw_caps & 131072U) != 0U) 
    
#line 612 
    common->bt_ant_diversity = (_Bool)1; else ;
  
#line 614 
  spinlock_check(& common->cc_lock);
  {
    struct lock_class_key __key_0;
    
#line 614 
    __raw_spin_lock_init(& common->cc_lock.__anonCompField_spinlock_18.rlock,"&(&common->cc_lock)->rlock",& __key_0);
  }
  
#line 615 
  spinlock_check(& sc->sc_serial_rw);
  {
    struct lock_class_key __key_1;
    
#line 615 
    __raw_spin_lock_init(& sc->sc_serial_rw.__anonCompField_spinlock_18.rlock,"&(&sc->sc_serial_rw)->rlock",& __key_1);
  }
  
#line 616 
  spinlock_check(& sc->sc_pm_lock);
  {
    struct lock_class_key __key_2;
    
#line 616 
    __raw_spin_lock_init(& sc->sc_pm_lock.__anonCompField_spinlock_18.rlock,"&(&sc->sc_pm_lock)->rlock",& __key_2);
  }
  
#line 617 
  spinlock_check(& sc->chan_lock);
  {
    struct lock_class_key __key_3;
    
#line 617 
    __raw_spin_lock_init(& sc->chan_lock.__anonCompField_spinlock_18.rlock,"&(&sc->chan_lock)->rlock",& __key_3);
  }
  {
    struct lock_class_key __key_4;
    
#line 618 
    __mutex_init(& sc->mutex,"&sc->mutex",& __key_4);
  }
  
#line 619 
  ldv_tasklet_init_78(& sc->intr_tq,& ath9k_tasklet,(unsigned long)sc);
  
#line 620 
  ldv_tasklet_init_79(& sc->bcon_tasklet,& ath9k_beacon_tasklet,(unsigned long)sc);
  {
    struct lock_class_key __key_5;
    
#line 623 
    init_timer_key(& sc->sleep_timer,0U,"((&sc->sleep_timer))",& __key_5);
  }
  
#line 623 
  sc->sleep_timer.function = & ath_ps_full_sleep;
  
#line 623 
  sc->sleep_timer.data = (unsigned long)sc;
  {
    struct lock_class_key __key_6;
    
#line 624 
    __init_work(& sc->hw_reset_work,0);
    
#line 624 
    atomic_long_t __constr_expr_37 = {.counter = WORK_STRUCT_NO_POOL};
    
#line 624 
    sc->hw_reset_work.data = __constr_expr_37;
    
#line 624 
    lockdep_init_map(& sc->hw_reset_work.lockdep_map,"(&sc->hw_reset_work)",& __key_6,0);
    
#line 624 
    INIT_LIST_HEAD(& sc->hw_reset_work.entry);
    
#line 624 
    sc->hw_reset_work.func = & ath_reset_work;
  }
  {
    struct lock_class_key __key_7;
    
#line 625 
    __init_work(& sc->paprd_work,0);
    
#line 625 
    atomic_long_t __constr_expr_38 = {.counter = WORK_STRUCT_NO_POOL};
    
#line 625 
    sc->paprd_work.data = __constr_expr_38;
    
#line 625 
    lockdep_init_map(& sc->paprd_work.lockdep_map,"(&sc->paprd_work)",& __key_7,0);
    
#line 625 
    INIT_LIST_HEAD(& sc->paprd_work.entry);
    
#line 625 
    sc->paprd_work.func = & ath_paprd_calibrate;
  }
  {
    struct lock_class_key __key_8;
    
#line 626 
    __init_work(& sc->hw_pll_work.work,0);
    
#line 626 
    atomic_long_t __constr_expr_39 = {.counter = WORK_STRUCT_NO_POOL};
    
#line 626 
    sc->hw_pll_work.work.data = __constr_expr_39;
    
#line 626 
    lockdep_init_map(& sc->hw_pll_work.work.lockdep_map,"(&(&sc->hw_pll_work)->work)",& __key_8,0);
    
#line 626 
    INIT_LIST_HEAD(& sc->hw_pll_work.work.entry);
    
#line 626 
    sc->hw_pll_work.work.func = & ath_hw_pll_work;
  }
  {
    struct lock_class_key __key_9;
    
#line 626 
    init_timer_key(& sc->hw_pll_work.timer,2097152U,"(&(&sc->hw_pll_work)->timer)",& __key_9);
  }
  
#line 626 
  sc->hw_pll_work.timer.function = & delayed_work_timer_fn;
  
#line 626 
  sc->hw_pll_work.timer.data = (unsigned long)(& sc->hw_pll_work);
  
#line 628 
  ath9k_init_channel_context(sc);
  
#line 634 
  ath_read_cachesize(common,& csz);
  
#line 635 
  common->cachelsz = (unsigned short)((int)((unsigned short)csz) << 2U);
  
#line 638 
  ret = ath9k_hw_init(ah);
  
#line 639 
  if (ret != 0) 
#line 640 
                goto err_hw; else ;
  
#line 642 
  if (pdata != (struct ath9k_platform_data *)0 && pdata->macaddr != (u8 *)0U) 
    
#line 643 
    memcpy((void *)(& common->macaddr),(void const *)pdata->macaddr,6UL); else ;
  
#line 645 
  ret = ath9k_init_queues(sc);
  
#line 646 
  if (ret != 0) 
#line 647 
                goto err_queues; else ;
  
#line 649 
  ret = ath9k_init_btcoex(sc);
  
#line 650 
  if (ret != 0) 
#line 651 
                goto err_btcoex; else ;
  
#line 653 
  ret = ath9k_cmn_init_channels_rates(common);
  
#line 654 
  if (ret != 0) 
#line 655 
                goto err_btcoex; else ;
  
#line 657 
  ret = ath9k_init_p2p(sc);
  
#line 658 
  if (ret != 0) 
#line 659 
                goto err_btcoex; else ;
  
#line 661 
  ath9k_cmn_init_crypto(sc->sc_ah);
  
#line 662 
  ath9k_init_misc(sc);
  
#line 663 
  ath_fill_led_pin(sc);
  
#line 664 
  ath_chanctx_init(sc);
  
#line 665 
  ath9k_offchannel_init(sc);
  
#line 667 
  if ((common->bus_ops)->aspm_init != (void (*)(struct ath_common *))0) 
    
#line 668 
    (*((common->bus_ops)->aspm_init))(common); else ;
  
#line 670 
  __retres = 0;
  
#line 670 
  goto return_label;
  err_btcoex: 
#line 672 
  ;
  
#line 673 
  i = 0;
  
#line 673 
  goto ldv_55043;
  ldv_55042: 
#line 674 
  ;
  
#line 674 
  if ((sc->tx.txqsetup & (unsigned int)(1 << i)) != 0U) 
#line 675 
                                                        ath_tx_cleanupq(sc,& sc->tx.txq[i]); else ;
  
#line 673 
  i += 1;
  ldv_55043: 
#line 674 
  ;
  
#line 673 
  if (i <= 9) 
#line 675 
              goto ldv_55042; else 
#line 678 
                                   goto ldv_55044;
  ldv_55044: 
#line 679 
  ;
  err_queues: 
#line 676 
  ;
  
#line 677 
  ath9k_hw_deinit(ah);
  err_hw: 
#line 678 
  ;
  
#line 679 
  ath9k_eeprom_release(sc);
  
#line 680 
  dev_kfree_skb_any(sc->tx99_skb);
  
#line 681 
  __retres = ret;
  return_label: 
#line 681 
                return __retres;
}


#line 684  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static void ath9k_init_band_txpower(struct ath_softc *sc, int band)
{
  struct ieee80211_supported_band *sband;
  struct ieee80211_channel *chan;
  struct cfg80211_chan_def chandef;
  int i;
  
#line 688 
  struct ath_hw *ah = sc->sc_ah;
  
#line 689 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 693 
  sband = & common->sbands[band];
  
#line 694 
  i = 0;
  
#line 694 
  goto ldv_55056;
  ldv_55055: 
#line 695 
  ;
  
#line 695 
  chan = sband->channels + i;
  
#line 696 
  ah->curchan = & ah->channels[(int)chan->hw_value];
  
#line 697 
  cfg80211_chandef_create(& chandef,chan,(enum nl80211_channel_type)NL80211_CHAN_HT20);
  
#line 698 
  ath9k_cmn_get_channel(sc->hw,ah,& chandef);
  
#line 699 
  ath9k_hw_set_txpowerlimit(ah,63U,(_Bool)1);
  
#line 694 
  i += 1;
  ldv_55056: 
#line 695 
  ;
  
#line 694 
  if (sband->n_channels > i) 
#line 696 
                             goto ldv_55055; else 
#line 699 
                                                  goto ldv_55057;
  ldv_55057: 
#line 700 
  ;
  
#line 701 
  return;
}


#line 703  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static void ath9k_init_txpower_limits(struct ath_softc *sc)
{
  
#line 705 
  struct ath_hw *ah = sc->sc_ah;
  
#line 706 
  struct ath9k_channel *curchan = ah->curchan;
  
#line 708 
  if ((ah->caps.hw_caps & 2048U) != 0U) 
#line 709 
                                        ath9k_init_band_txpower(sc,0); else ;
  
#line 710 
  if ((ah->caps.hw_caps & 4096U) != 0U) 
#line 711 
                                        ath9k_init_band_txpower(sc,1); else ;
  
#line 713 
  ah->curchan = curchan;
  
#line 714 
  return;
}


#line 733  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static struct ieee80211_iface_limit const if_limits_multi[2U] = {{.max = (unsigned short)2U, .types = (unsigned short)780U}, {.max = (unsigned short)1U, .types = (unsigned short)2U}};

#line 741  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static struct ieee80211_iface_combination const if_comb_multi[1U] = {{.limits = (struct ieee80211_iface_limit const *)(& if_limits_multi), .num_different_channels = 2U, .max_interfaces = (unsigned short)2U, .n_limits = (unsigned char)2U, .beacon_int_infra_match = (_Bool)1, .radar_detect_widths = (unsigned char)0, .radar_detect_regions = (unsigned char)0}};

#line 791  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static void ath9k_set_mcc_capab(struct ath_softc *sc, struct ieee80211_hw *hw)
{
  int tmp_1;
  bool tmp_0;
  
#line 793 
  struct ath_hw *ah = sc->sc_ah;
  
#line 794 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 796 
  tmp_0 = ath9k_is_chanctx_enabled();
  
#line 796 
  if (tmp_0) 
#line 796 
             tmp_1 = 0; else 
#line 796 
                             tmp_1 = 1;
  
#line 796 
  if (tmp_1) 
#line 797 
             goto return_label; else ;
  
#line 799 
  _ieee80211_hw_set(hw,(enum ieee80211_hw_flags)IEEE80211_HW_QUEUE_CONTROL);
  
#line 800 
  hw->queues = (unsigned short)10U;
  
#line 801 
  hw->offchannel_tx_hw_queue = (unsigned char)((unsigned int)((unsigned char)hw->queues) + 255U);
  
#line 802 
  (hw->wiphy)->interface_modes = (unsigned short)((unsigned int)(hw->wiphy)->interface_modes & 65503U);
  
#line 803 
  (hw->wiphy)->iface_combinations = (struct ieee80211_iface_combination const *)(& if_comb_multi);
  
#line 804 
  (hw->wiphy)->n_iface_combinations = 1;
  
#line 805 
  (hw->wiphy)->max_scan_ssids = (unsigned char)255U;
  
#line 806 
  (hw->wiphy)->max_scan_ie_len = (unsigned short)2304U;
  
#line 807 
  (hw->wiphy)->max_remain_on_channel_duration = (unsigned short)10000U;
  
#line 808 
  hw->chanctx_data_size = 8;
  
#line 809 
  hw->extra_beacon_tailroom = 63U;
  
#line 812 
  if ((common->debug_mask & 262144) != 0) 
#line 812 
                                          ath_printk("\001",(struct ath_common const *)common,"Use channel contexts\n"); else ;
  return_label: 
#line 813 
                return;
}


#line 816  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static void ath9k_set_hw_capab(struct ath_softc *sc, struct ieee80211_hw *hw)
{
  
#line 818 
  struct ath_hw *ah = sc->sc_ah;
  
#line 819 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 821 
  _ieee80211_hw_set(hw,(enum ieee80211_hw_flags)IEEE80211_HW_SUPPORTS_HT_CCK_RATES);
  
#line 822 
  _ieee80211_hw_set(hw,(enum ieee80211_hw_flags)IEEE80211_HW_SUPPORTS_RC_TABLE);
  
#line 823 
  _ieee80211_hw_set(hw,(enum ieee80211_hw_flags)IEEE80211_HW_REPORTS_TX_ACK_STATUS);
  
#line 824 
  _ieee80211_hw_set(hw,(enum ieee80211_hw_flags)IEEE80211_HW_SPECTRUM_MGMT);
  
#line 825 
  _ieee80211_hw_set(hw,(enum ieee80211_hw_flags)IEEE80211_HW_PS_NULLFUNC_STACK);
  
#line 826 
  _ieee80211_hw_set(hw,(enum ieee80211_hw_flags)IEEE80211_HW_SIGNAL_DBM);
  
#line 827 
  _ieee80211_hw_set(hw,(enum ieee80211_hw_flags)IEEE80211_HW_RX_INCLUDES_FCS);
  
#line 828 
  _ieee80211_hw_set(hw,(enum ieee80211_hw_flags)IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING);
  
#line 830 
  if (ath9k_ps_enable != 0) 
#line 831 
                            _ieee80211_hw_set(hw,(enum ieee80211_hw_flags)IEEE80211_HW_SUPPORTS_PS); else ;
  
#line 833 
  if (((sc->sc_ah)->caps.hw_caps & 1U) != 0U) {
    
#line 834 
    _ieee80211_hw_set(hw,(enum ieee80211_hw_flags)IEEE80211_HW_AMPDU_AGGREGATION);
    
#line 836 
    if (ah->hw_version.macVersion > 127U) 
#line 837 
                                          hw->radiotap_mcs_details = (unsigned char)((unsigned int)hw->radiotap_mcs_details | 32U); else ;
  }
  else ;
  
#line 841 
  if ((sc->sc_ah)->hw_version.macVersion > 63U || ath9k_modparam_nohwcrypt != 0) 
    
#line 842 
    _ieee80211_hw_set(hw,(enum ieee80211_hw_flags)IEEE80211_HW_MFP_CAPABLE); else ;
  
#line 844 
  (hw->wiphy)->features |= 395264U;
  
#line 862 
  (hw->wiphy)->flags &= 4294967279U;
  
#line 864 
  (hw->wiphy)->flags |= 256U;
  
#line 865 
  (hw->wiphy)->flags |= 32768U;
  
#line 866 
  (hw->wiphy)->flags |= 2097152U;
  
#line 867 
  (hw->wiphy)->flags |= 4194304U;
  
#line 868 
  (hw->wiphy)->flags |= 8388608U;
  
#line 869 
  (hw->wiphy)->flags |= 16384U;
  
#line 871 
  hw->queues = (unsigned short)4U;
  
#line 872 
  hw->max_rates = (unsigned char)4U;
  
#line 873 
  hw->max_listen_interval = (unsigned short)10U;
  
#line 874 
  hw->max_rate_tries = (unsigned char)10U;
  
#line 875 
  hw->sta_data_size = 4920;
  
#line 876 
  hw->vif_data_size = 5080;
  
#line 877 
  hw->extra_tx_headroom = 4U;
  
#line 879 
  (hw->wiphy)->available_antennas_rx = (unsigned int)(1UL << (int)ah->caps.max_rxchains) + 4294967295U;
  
#line 880 
  (hw->wiphy)->available_antennas_tx = (unsigned int)(1UL << (int)ah->caps.max_txchains) + 4294967295U;
  
#line 883 
  if ((ah->caps.hw_caps & 1024U) != 0U) 
#line 884 
                                        (hw->wiphy)->available_antennas_rx = 3U; else ;
  
#line 886 
  sc->ant_rx = (unsigned char)(hw->wiphy)->available_antennas_rx;
  
#line 887 
  sc->ant_tx = (unsigned char)(hw->wiphy)->available_antennas_tx;
  
#line 889 
  if (((sc->sc_ah)->caps.hw_caps & 2048U) != 0U) 
#line 890 
                                                 (hw->wiphy)->bands[0] = & common->sbands[0]; else ;
  
#line 892 
  if (((sc->sc_ah)->caps.hw_caps & 4096U) != 0U) 
#line 893 
                                                 (hw->wiphy)->bands[1] = & common->sbands[1]; else ;
  
#line 897 
  ath9k_set_mcc_capab(sc,hw);
  
#line 899 
  ath9k_init_wow(hw);
  
#line 900 
  ath9k_cmn_reload_chainmask(ah);
  
#line 902 
  SET_IEEE80211_PERM_ADDR(hw,(u8 *)(& common->macaddr));
  
#line 903 
  return;
}


#line 905  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
int ath9k_init_device(u16 devid, struct ath_softc *sc, struct ath_bus_ops const *bus_ops)
{
  int __retres;
  struct ath_common *common;
  struct ath_hw *ah;
  struct ath_regulatory *reg;
  int tmp_0;
  bool tmp;
  
#line 908 
  struct ieee80211_hw *hw = sc->hw;
  
#line 911 
  int error = 0;
  
#line 915 
  error = ath9k_init_softc((unsigned short)((int)devid),sc,bus_ops);
  
#line 916 
  if (error != 0) {
    
#line 917 
    __retres = error;
    
#line 917 
    goto return_label;
  }
  else ;
  
#line 919 
  ah = sc->sc_ah;
  
#line 920 
  common = ath9k_hw_common(ah);
  
#line 921 
  ath9k_set_hw_capab(sc,hw);
  
#line 924 
  error = ath_regd_init(& common->regulatory,(sc->hw)->wiphy,& ath9k_reg_notifier);
  
#line 926 
  if (error != 0) 
#line 927 
                  goto deinit; else ;
  
#line 929 
  reg = & common->regulatory;
  
#line 932 
  error = ath_tx_init(sc,512);
  
#line 933 
  if (error != 0) 
#line 934 
                  goto deinit; else ;
  
#line 937 
  error = ath_rx_init(sc,512);
  
#line 938 
  if (error != 0) 
#line 939 
                  goto deinit; else ;
  
#line 941 
  ath9k_init_txpower_limits(sc);
  
#line 945 
  sc->led_cdev.default_trigger = ieee80211_create_tpt_led_trigger(sc->hw,1U,(struct ieee80211_tpt_blink const *)(& ath9k_tpt_blink),10U);
  
#line 951 
  error = ieee80211_register_hw(hw);
  
#line 952 
  if (error != 0) 
#line 953 
                  goto rx_cleanup; else ;
  
#line 955 
  error = ath9k_init_debug(ah);
  
#line 956 
  if (error != 0) {
    
#line 957 
    ath_printk("\001",(struct ath_common const *)common,"Unable to create debugfs files\n");
    
#line 958 
    goto unregister;
  }
  else ;
  
#line 962 
  tmp = ath_is_world_regd(reg);
  
#line 962 
  if (tmp) 
#line 962 
           tmp_0 = 0; else 
#line 962 
                           tmp_0 = 1;
  
#line 962 
  if (tmp_0) {
    
#line 963 
    error = regulatory_hint(hw->wiphy,(char const *)(& reg->alpha2));
    
#line 964 
    if (error != 0) 
#line 965 
                    goto debug_cleanup; else ;
  }
  else ;
  
#line 968 
  ath_init_leds(sc);
  
#line 969 
  ath_start_rfkill_poll(sc);
  
#line 971 
  __retres = 0;
  
#line 971 
  goto return_label;
  debug_cleanup: 
#line 973 
  ;
  
#line 974 
  ath9k_deinit_debug(sc);
  unregister: 
#line 975 
  ;
  
#line 976 
  ieee80211_unregister_hw(hw);
  rx_cleanup: 
#line 977 
  ;
  
#line 978 
  ath_rx_cleanup(sc);
  deinit: 
#line 979 
  ;
  
#line 980 
  ath9k_deinit_softc(sc);
  
#line 981 
  __retres = error;
  return_label: 
#line 981 
                return __retres;
}


#line 988  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static void ath9k_deinit_softc(struct ath_softc *sc)
{
  
#line 990 
  int i = 0;
  
#line 992 
  ath9k_deinit_p2p(sc);
  
#line 993 
  ath9k_deinit_btcoex(sc);
  
#line 995 
  i = 0;
  
#line 995 
  goto ldv_55121;
  ldv_55120: 
#line 996 
  ;
  
#line 996 
  if ((sc->tx.txqsetup & (unsigned int)(1 << i)) != 0U) 
#line 997 
                                                        ath_tx_cleanupq(sc,& sc->tx.txq[i]); else ;
  
#line 995 
  i += 1;
  ldv_55121: 
#line 996 
  ;
  
#line 995 
  if (i <= 9) 
#line 997 
              goto ldv_55120; else 
#line 1000 
                                   goto ldv_55122;
  ldv_55122: 
#line 1001 
  ;
  
#line 999 
  ldv_del_timer_sync_80(& sc->sleep_timer);
  
#line 1000 
  ath9k_hw_deinit(sc->sc_ah);
  
#line 1001 
  if (sc->dfs_detector != (struct dfs_pattern_detector *)0) 
#line 1002 
                                                            (*((sc->dfs_detector)->exit))(sc->dfs_detector); else ;
  
#line 1004 
  ath9k_eeprom_release(sc);
  
#line 1005 
  return;
}


#line 1007  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
void ath9k_deinit_device(struct ath_softc *sc)
{
  
#line 1009 
  struct ieee80211_hw *hw = sc->hw;
  
#line 1011 
  ath9k_ps_wakeup(sc);
  
#line 1013 
  wiphy_rfkill_stop_polling((sc->hw)->wiphy);
  
#line 1014 
  ath_deinit_leds(sc);
  
#line 1016 
  ath9k_ps_restore(sc);
  
#line 1018 
  ath9k_deinit_debug(sc);
  
#line 1019 
  ath9k_deinit_wow(hw);
  
#line 1020 
  ieee80211_unregister_hw(hw);
  
#line 1021 
  ath_rx_cleanup(sc);
  
#line 1022 
  ath9k_deinit_softc(sc);
  
#line 1023 
  return;
}


#line 1029  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static int ath9k_init(void)
{
  int __retres;
  int error;
  
#line 1033 
  error = ath_pci_init();
  
#line 1034 
  if (error < 0) {
    
#line 1035 
    printk("\001");
    
#line 1036 
    error = -19;
    
#line 1037 
    goto err_out;
  }
  else ;
  
#line 1040 
  error = ath_ahb_init();
  
#line 1041 
  if (error < 0) {
    
#line 1042 
    error = -19;
    
#line 1043 
    goto err_pci_exit;
  }
  else ;
  
#line 1046 
  __retres = 0;
  
#line 1046 
  goto return_label;
  err_pci_exit: 
#line 1048 
  ;
  
#line 1049 
  ath_pci_exit();
  err_out: 
#line 1050 
  ;
  
#line 1051 
  __retres = error;
  return_label: 
#line 1051 
                return __retres;
}


#line 1055  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/init.c"
static void ath9k_exit(void)
{
  
#line 1057 
  is_ath9k_unloaded = (_Bool)1;
  
#line 1058 
  ath_ahb_exit();
  
#line 1059 
  ath_pci_exit();
  
#line 1060 
  printk("\001",dev_info);
  
#line 1061 
  return;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_init.c.aux"
int ldv_emg_del_timer_sync(struct timer_list *arg0);


#line 60 
void ldv_emg_tasklet_init(struct tasklet_struct *arg0, void (*arg1)(unsigned long ), unsigned long arg2);


#line 68  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_init.c.aux"
void ldv_emg_ath9k_exit(void)
{
  
#line 69 
  ath9k_exit();
  
#line 70 
  return;
}


#line 72  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_init.c.aux"
int ldv_emg_ath9k_init(void)
{
  int tmp;
  
#line 73 
  tmp = ath9k_init();
  
#line 73 
  return tmp;
}


#line 747  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_init.c.aux"
static void ldv___ldv_spin_lock_72(spinlock_t *ldv_func_arg1)
{
  
#line 751 
  ldv_spin_model_lock((char *)"sc_serial_rw_of_ath_softc");
  
#line 753 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 754 
  return;
}


#line 757  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_init.c.aux"
static void ldv_spin_unlock_irqrestore_73(spinlock_t *lock, unsigned long flags)
{
  
#line 761 
  ldv_spin_model_unlock((char *)"sc_serial_rw_of_ath_softc");
  
#line 763 
  spin_unlock_irqrestore_0(lock,flags);
  
#line 764 
  return;
}


#line 767  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_init.c.aux"
static void ldv___ldv_spin_lock_74_0(spinlock_t *ldv_func_arg1)
{
  
#line 771 
  ldv_spin_model_lock((char *)"sc_serial_rw_of_ath_softc");
  
#line 773 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 774 
  return;
}


#line 777  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_init.c.aux"
static void ldv_spin_unlock_irqrestore_75_0(spinlock_t *lock, unsigned long flags)
{
  
#line 781 
  ldv_spin_model_unlock((char *)"sc_serial_rw_of_ath_softc");
  
#line 783 
  spin_unlock_irqrestore_0(lock,flags);
  
#line 784 
  return;
}


#line 787  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_init.c.aux"
static void ldv___ldv_spin_lock_76(spinlock_t *ldv_func_arg1)
{
  
#line 791 
  ldv_spin_model_lock((char *)"sc_serial_rw_of_ath_softc");
  
#line 793 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 794 
  return;
}


#line 797  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_init.c.aux"
static void ldv_spin_unlock_irqrestore_77(spinlock_t *lock, unsigned long flags)
{
  
#line 801 
  ldv_spin_model_unlock((char *)"sc_serial_rw_of_ath_softc");
  
#line 803 
  spin_unlock_irqrestore_0(lock,flags);
  
#line 804 
  return;
}


#line 807  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_init.c.aux"
static void ldv_tasklet_init_78(struct tasklet_struct *ldv_func_arg1, void (*ldv_func_arg2)(unsigned long ), unsigned long ldv_func_arg3)
{
  
#line 811 
  ldv_emg_tasklet_init(ldv_func_arg1,ldv_func_arg2,ldv_func_arg3);
  
#line 812 
  return;
}


#line 815  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_init.c.aux"
static void ldv_tasklet_init_79(struct tasklet_struct *ldv_func_arg1, void (*ldv_func_arg2)(unsigned long ), unsigned long ldv_func_arg3)
{
  
#line 819 
  ldv_emg_tasklet_init(ldv_func_arg1,ldv_func_arg2,ldv_func_arg3);
  
#line 820 
  return;
}


#line 823  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_init.c.aux"
static int ldv_del_timer_sync_80(struct timer_list *ldv_func_arg1)
{
  int tmp;
  
#line 827 
  tmp = ldv_emg_del_timer_sync(ldv_func_arg1);
  
#line 827 
  return tmp;
}


#line 248  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
void __might_fault(char const *, int);


#line 271 
int kstrtoull(char const *, unsigned int, unsigned long long *);


#line 290  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
__inline static int kstrtoul(char const *s, unsigned int base, unsigned long *res)
{
  int tmp;
  
#line 298 
  tmp = kstrtoull(s,base,(unsigned long long *)res);
  
#line 298 
  return tmp;
}


#line 409 
int scnprintf(char *, size_t, char const * , ...);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kzalloc(size_t size, gfp_t flags);


#line 2547  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
loff_t default_llseek(struct file *, loff_t, int);


#line 2812 
int simple_open(struct inode *, struct file *);


#line 2843 
ssize_t simple_read_from_buffer(void *, size_t, loff_t *, void const *, size_t);


#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debugfs.h"
static struct dentry *ldv_debugfs_create_file_72(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 58 
static struct dentry *ldv_debugfs_create_file_73(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
void kfree(void const *);


#line 581 
static void *kzalloc(size_t size, gfp_t flags);


#line 650  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
unsigned long _copy_from_user(void *, void const *, unsigned int);


#line 662 
void copy_from_user_overflow(void);


#line 672 
void __copy_from_user_overflow(void);


#line 693  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_from_user(void *to, void const *from, unsigned long n)
{
  
#line 695 
  int sz = -1;
  
#line 697 
  __might_fault("./arch/x86/include/asm/uaccess.h",697);
  
#line 717 
  if ((long)(sz < 0) != 0L || (long)((unsigned long)sz >= n) != 0L) 
#line 718 
                                                                    n = _copy_from_user(to,from,(unsigned int)n);
  else 
    
#line 719 
    if (0 != 0) 
#line 720 
                copy_from_user_overflow(); else 
#line 722 
                                                __copy_from_user_overflow();
  
#line 724 
  return n;
}


#line 4978  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
void ieee80211_radar_detected(struct ieee80211_hw *);


#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/dfs_debug.h"
void ath9k_dfs_init_debug(struct ath_softc *sc);


#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/dfs_debug.c"
static struct ath_dfs_pool_stats dfs_pool_stats = {.pool_reference = 0U, .pulse_allocated = 0U, .pulse_alloc_error = 0U, .pulse_used = 0U, .pseq_allocated = 0U, .pseq_alloc_error = 0U, .pseq_used = 0U};

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/dfs_debug.c"
static ssize_t read_file_dfs(struct file *file, char *user_buf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  char *buf;
  int tmp_1;
  char *tmp_0;
  int tmp_3;
  int tmp_4;
  int tmp_5;
  int tmp_6;
  int tmp_7;
  int tmp_8;
  int tmp_9;
  int tmp_10;
  int tmp_11;
  int tmp_12;
  int tmp_13;
  int tmp_14;
  int tmp_15;
  int tmp_16;
  int tmp_17;
  int tmp_18;
  int tmp_19;
  int tmp_20;
  int tmp_21;
  int tmp_22;
  int tmp_23;
  
#line 37 
  struct ath_softc *sc = (struct ath_softc *)file->private_data;
  
#line 38 
  struct ath9k_hw_version *hw_ver = & (sc->sc_ah)->hw_version;
  
#line 40 
  unsigned int len = 0U;
  
#line 40 
  unsigned int size = 8000U;
  
#line 41 
  ssize_t retval = 0L;
  
#line 43 
  buf = (char *)kzalloc((unsigned long)size,208U);
  
#line 44 
  if (buf == (char *)0) {
    
#line 45 
    __retres = -12L;
    
#line 45 
    goto return_label;
  }
  else ;
  
#line 49 
  if (((sc->sc_ah)->caps.hw_caps & 262144U) != 0U) 
#line 49 
                                                   tmp_0 = (char *)"enabled"; else 
                                                                    
#line 49 
                                                                    tmp_0 = (char *)"disabled";
  
#line 47 
  ;
  
#line 47 
  ;
  
#line 47 
  ;
  
#line 47 
  ;
  
#line 47 
  tmp_1 = scnprintf(buf + len,(unsigned long)(size - len),"DFS support for ",hw_ver->macVersion,(int)hw_ver->macRev,tmp_0);
  
#line 51 
  len = (unsigned int)tmp_1 + len;
  
#line 53 
  if (sc->dfs_detector == (struct dfs_pattern_detector *)0) {
    int tmp_2;
    
#line 54 
    tmp_2 = scnprintf(buf + len,(unsigned long)(size - len),"DFS detector not enabled\n");
    
#line 55 
    len = (unsigned int)tmp_2 + len;
    
#line 56 
    goto exit;
  }
  else ;
  
#line 59 
  dfs_pool_stats = (*((sc->dfs_detector)->get_stats))(sc->dfs_detector);
  
#line 61 
  tmp_3 = scnprintf(buf + len,(unsigned long)(size - len),"Pulse detector statistics:\n");
  
#line 61 
  len = (unsigned int)tmp_3 + len;
  
#line 62 
  tmp_4 = scnprintf(buf + len,(unsigned long)(size - len),"%28s : %10u\n",(char *)"pulse events reported   ",sc->debug.stats.dfs_stats.pulses_total);
  
#line 62 
  len = (unsigned int)tmp_4 + len;
  
#line 63 
  tmp_5 = scnprintf(buf + len,(unsigned long)(size - len),"%28s : %10u\n",(char *)"invalid pulse events    ",sc->debug.stats.dfs_stats.pulses_no_dfs);
  
#line 63 
  len = (unsigned int)tmp_5 + len;
  
#line 64 
  tmp_6 = scnprintf(buf + len,(unsigned long)(size - len),"%28s : %10u\n",(char *)"DFS pulses detected     ",sc->debug.stats.dfs_stats.pulses_detected);
  
#line 64 
  len = (unsigned int)tmp_6 + len;
  
#line 65 
  tmp_7 = scnprintf(buf + len,(unsigned long)(size - len),"%28s : %10u\n",(char *)"Datalen discards        ",sc->debug.stats.dfs_stats.datalen_discards);
  
#line 65 
  len = (unsigned int)tmp_7 + len;
  
#line 66 
  tmp_8 = scnprintf(buf + len,(unsigned long)(size - len),"%28s : %10u\n",(char *)"RSSI discards           ",sc->debug.stats.dfs_stats.rssi_discards);
  
#line 66 
  len = (unsigned int)tmp_8 + len;
  
#line 67 
  tmp_9 = scnprintf(buf + len,(unsigned long)(size - len),"%28s : %10u\n",(char *)"BW info discards        ",sc->debug.stats.dfs_stats.bwinfo_discards);
  
#line 67 
  len = (unsigned int)tmp_9 + len;
  
#line 68 
  tmp_10 = scnprintf(buf + len,(unsigned long)(size - len),"%28s : %10u\n",(char *)"Primary channel pulses  ",sc->debug.stats.dfs_stats.pri_phy_errors);
  
#line 68 
  len = (unsigned int)tmp_10 + len;
  
#line 69 
  tmp_11 = scnprintf(buf + len,(unsigned long)(size - len),"%28s : %10u\n",(char *)"Secondary channel pulses",sc->debug.stats.dfs_stats.ext_phy_errors);
  
#line 69 
  len = (unsigned int)tmp_11 + len;
  
#line 70 
  tmp_12 = scnprintf(buf + len,(unsigned long)(size - len),"%28s : %10u\n",(char *)"Dual channel pulses     ",sc->debug.stats.dfs_stats.dc_phy_errors);
  
#line 70 
  len = (unsigned int)tmp_12 + len;
  
#line 71 
  tmp_13 = scnprintf(buf + len,(unsigned long)(size - len),"Radar detector statistics ",(unsigned int)(sc->dfs_detector)->region);
  
#line 73 
  len = (unsigned int)tmp_13 + len;
  
#line 74 
  tmp_14 = scnprintf(buf + len,(unsigned long)(size - len),"%28s : %10u\n",(char *)"Pulse events processed  ",sc->debug.stats.dfs_stats.pulses_processed);
  
#line 74 
  len = (unsigned int)tmp_14 + len;
  
#line 75 
  tmp_15 = scnprintf(buf + len,(unsigned long)(size - len),"%28s : %10u\n",(char *)"Radars detected         ",sc->debug.stats.dfs_stats.radar_detected);
  
#line 75 
  len = (unsigned int)tmp_15 + len;
  
#line 76 
  tmp_16 = scnprintf(buf + len,(unsigned long)(size - len),"Global Pool statistics:\n");
  
#line 76 
  len = (unsigned int)tmp_16 + len;
  
#line 77 
  tmp_17 = scnprintf(buf + len,(unsigned long)(size - len),"%28s : %10u\n",(char *)"Pool references         ",dfs_pool_stats.pool_reference);
  
#line 77 
  len = (unsigned int)tmp_17 + len;
  
#line 78 
  tmp_18 = scnprintf(buf + len,(unsigned long)(size - len),"%28s : %10u\n",(char *)"Pulses allocated        ",dfs_pool_stats.pulse_allocated);
  
#line 78 
  len = (unsigned int)tmp_18 + len;
  
#line 79 
  tmp_19 = scnprintf(buf + len,(unsigned long)(size - len),"%28s : %10u\n",(char *)"Pulses alloc error      ",dfs_pool_stats.pulse_alloc_error);
  
#line 79 
  len = (unsigned int)tmp_19 + len;
  
#line 80 
  tmp_20 = scnprintf(buf + len,(unsigned long)(size - len),"%28s : %10u\n",(char *)"Pulses in use           ",dfs_pool_stats.pulse_used);
  
#line 80 
  len = (unsigned int)tmp_20 + len;
  
#line 81 
  tmp_21 = scnprintf(buf + len,(unsigned long)(size - len),"%28s : %10u\n",(char *)"Seqs. allocated         ",dfs_pool_stats.pseq_allocated);
  
#line 81 
  len = (unsigned int)tmp_21 + len;
  
#line 82 
  tmp_22 = scnprintf(buf + len,(unsigned long)(size - len),"%28s : %10u\n",(char *)"Seqs. alloc error       ",dfs_pool_stats.pseq_alloc_error);
  
#line 82 
  len = (unsigned int)tmp_22 + len;
  
#line 83 
  tmp_23 = scnprintf(buf + len,(unsigned long)(size - len),"%28s : %10u\n",(char *)"Seqs. in use            ",dfs_pool_stats.pseq_used);
  
#line 83 
  len = (unsigned int)tmp_23 + len;
  exit: 
#line 85 
  ;
  
#line 86 
  if (len > size) 
#line 87 
                  len = size; else ;
  
#line 89 
  retval = simple_read_from_buffer((void *)user_buf,count,ppos,(void const *)buf,(unsigned long)len);
  
#line 90 
  kfree((void const *)buf);
  
#line 92 
  __retres = retval;
  return_label: 
#line 92 
                return __retres;
}


#line 97  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/dfs_debug.c"
static ssize_t write_file_dfs(struct file *file, char const *user_buf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  unsigned long val;
  char buf[32U];
  ssize_t len;
  unsigned long tmp_0;
  unsigned long tmp_1;
  int tmp_2;
  
#line 100 
  struct ath_softc *sc = (struct ath_softc *)file->private_data;
  {
    unsigned long tmp;
    
#line 105 
    size_t _min1 = count;
    
#line 105 
    unsigned long _min2 = 31UL;
    
#line 105 
    if (_min1 < _min2) 
#line 105 
                       tmp = _min1; else 
#line 105 
                                         tmp = _min2;
    
#line 105 
    tmp_0 = tmp;
  }
  
#line 105 
  len = (long)tmp_0;
  
#line 106 
  tmp_1 = copy_from_user((void *)(& buf),(void const *)user_buf,(unsigned long)len);
  
#line 106 
  if (tmp_1 != 0UL) {
    
#line 107 
    __retres = -14L;
    
#line 107 
    goto return_label;
  }
  else ;
  
#line 109 
  buf[len] = (char)0;
  
#line 110 
  tmp_2 = kstrtoul((char const *)(& buf),0U,& val);
  
#line 110 
  if (tmp_2 != 0) {
    
#line 111 
    __retres = -22L;
    
#line 111 
    goto return_label;
  }
  else ;
  
#line 113 
  if (val == 2147483648UL) 
#line 114 
                           memset((void *)(& sc->debug.stats.dfs_stats),0,44UL); else ;
  
#line 116 
  __retres = (long)count;
  return_label: 
#line 116 
                return __retres;
}


#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/dfs_debug.c"
static ssize_t write_file_simulate_radar(struct file *file, char const *user_buf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  
#line 123 
  struct ath_softc *sc = (struct ath_softc *)file->private_data;
  
#line 125 
  ieee80211_radar_detected(sc->hw);
  
#line 127 
  __retres = (long)count;
  
#line 127 
  return __retres;
}


#line 130  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/dfs_debug.c"
static struct file_operations const fops_simulate_radar = {.owner = & __this_module, .llseek = & default_llseek, .read = (ssize_t (*)(struct file *, char *, size_t , loff_t *))0, .write = & write_file_simulate_radar, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 137  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/dfs_debug.c"
static struct file_operations const fops_dfs_stats = {.owner = & __this_module, .llseek = & default_llseek, .read = & read_file_dfs, .write = & write_file_dfs, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 145  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/dfs_debug.c"
void ath9k_dfs_init_debug(struct ath_softc *sc)
{
  
#line 147 
  ldv_debugfs_create_file_72("dfs_stats",(unsigned short)256,sc->debug.debugfs_phy,(void *)sc,& fops_dfs_stats);
  
#line 149 
  ldv_debugfs_create_file_73("dfs_simulate_radar",(unsigned short)128,sc->debug.debugfs_phy,(void *)sc,& fops_simulate_radar);
  
#line 151 
  return;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_dfs_debug.c.aux"
struct file_operations *ldv_emg_alias_fops_dfs_stats_2 = (struct file_operations *)(& fops_dfs_stats);

#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_dfs_debug.c.aux"
struct file_operations *ldv_emg_alias_fops_simulate_radar_2 = (struct file_operations *)(& fops_simulate_radar);

#line 58  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_dfs_debug.c.aux"
long long (*ldv_emg_alias_default_llseek_3)(struct file *, long long , int ) = & default_llseek;

#line 59  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_dfs_debug.c.aux"
int (*ldv_emg_alias_simple_open_5)(struct inode *, struct file *) = & simple_open;

#line 68 
struct dentry *ldv_emg_debugfs_create_file(char *arg0, unsigned short arg1, struct dentry *arg2, void *arg3, struct file_operations *arg4);


#line 74  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_dfs_debug.c.aux"
long ldv_emg_wrapper_read_file_dfs_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 75 
  tmp = read_file_dfs(arg0,arg1,arg2,arg3);
  
#line 75 
  return tmp;
}


#line 79  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_dfs_debug.c.aux"
long ldv_emg_wrapper_write_file_dfs_4(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 80 
  tmp = write_file_dfs(arg0,(char const *)arg1,arg2,arg3);
  
#line 80 
  return tmp;
}


#line 84  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_dfs_debug.c.aux"
long ldv_emg_wrapper_write_file_simulate_radar_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 85 
  tmp = write_file_simulate_radar(arg0,(char const *)arg1,arg2,arg3);
  
#line 85 
  return tmp;
}


#line 519  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_dfs_debug.c.aux"
static void *kzalloc(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 522 
  tmp = ldv_kzalloc(size,flags);
  
#line 522 
  return tmp;
}


#line 760  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_dfs_debug.c.aux"
static struct dentry *ldv_debugfs_create_file_72(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 764 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 764 
  return tmp;
}


#line 768  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_dfs_debug.c.aux"
static struct dentry *ldv_debugfs_create_file_73(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 772 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 772 
  return tmp;
}


#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
void __list_del_entry(struct list_head *);


#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void list_del_init(struct list_head *entry)
{
  
#line 145 
  __list_del_entry(entry);
  
#line 146 
  INIT_LIST_HEAD(entry);
  
#line 147 
  return;
}


#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static int list_is_last(struct list_head const *list, struct list_head const *head)
{
  int __retres;
  
#line 180 
  __retres = (struct list_head const *)list->next == head;
  
#line 180 
  return __retres;
}


#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static int list_empty(struct list_head const *head)
{
  int __retres;
  
#line 189 
  __retres = (struct list_head const *)head->next == head;
  
#line 189 
  return __retres;
}


#line 355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_bh_1(spinlock_t *lock)
{
  
#line 357 
  _raw_spin_lock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 358 
  return;
}


#line 383 
static void ldv_spin_lock_bh_72_0(spinlock_t *lock);


#line 387 
static void ldv_spin_lock_bh_74(spinlock_t *lock);


#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_bh_1(spinlock_t *lock)
{
  
#line 406 
  _raw_spin_unlock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 407 
  return;
}


#line 432 
static void ldv_spin_unlock_bh_73_0(spinlock_t *lock);


#line 436 
static void ldv_spin_unlock_bh_75(spinlock_t *lock);


#line 440 
static void ldv_spin_unlock_bh_76(spinlock_t *lock);


#line 454  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_irqrestore_1(spinlock_t *lock, unsigned long flags)
{
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
  }
  
#line 456 
  _raw_spin_unlock_irqrestore(& lock->__anonCompField_spinlock_18.rlock,flags);
  
#line 457 
  return;
}


#line 486 
static void ldv_spin_unlock_irqrestore_78(spinlock_t *lock, unsigned long flags);


#line 70  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_recv.c.aux"
static void ldv___ldv_spin_lock_77(spinlock_t *ldv_func_arg1);


#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-debug.h"
void debug_dma_sync_single_for_cpu(struct device *, dma_addr_t, size_t, int);


#line 63 
void debug_dma_sync_single_for_device(struct device *, dma_addr_t, size_t, int);


#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_cpu(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir)
{
  int tmp_0;
  
#line 106 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 108 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 108 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 110 
    ldv_inline_asm();
    
#line 108 
    ;
  }
  else ;
  
#line 109 
  if (ops->sync_single_for_cpu != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction ))0) 
    
#line 110 
    (*(ops->sync_single_for_cpu))(dev,addr,size,dir); else ;
  
#line 111 
  debug_dma_sync_single_for_cpu(dev,addr,size,(int)dir);
  
#line 112 
  return;
}


#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_device(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir)
{
  int tmp_0;
  
#line 118 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 120 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 120 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 122 
    ldv_inline_asm();
    
#line 120 
    ;
  }
  else ;
  
#line 121 
  if (ops->sync_single_for_device != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction ))0) 
    
#line 122 
    (*(ops->sync_single_for_device))(dev,addr,size,dir); else ;
  
#line 123 
  debug_dma_sync_single_for_device(dev,addr,size,(int)dir);
  
#line 124 
  return;
}


#line 775  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
void consume_skb(struct sk_buff *);


#line 852 
int pskb_expand_head(struct sk_buff *, int, int, gfp_t);


#line 1259  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct sk_buff *skb_peek(struct sk_buff_head const *list_)
{
  
#line 1261 
  struct sk_buff *skb = list_->next;
  
#line 1263 
  if (skb == (struct sk_buff *)list_) 
#line 1264 
                                      skb = (struct sk_buff *)0; else ;
  
#line 1265 
  return skb;
}


#line 1316  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static __u32 skb_queue_len(struct sk_buff_head const *list_)
{
  __u32 __retres;
  
#line 1318 
  __retres = list_->qlen;
  
#line 1318 
  return __retres;
}


#line 1331  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void __skb_queue_head_init(struct sk_buff_head *list)
{
  struct sk_buff *tmp;
  
#line 1333 
  tmp = (struct sk_buff *)list;
  
#line 1333 
  list->next = tmp;
  
#line 1333 
  list->prev = tmp;
  
#line 1334 
  list->qlen = 0U;
  
#line 1335 
  return;
}


#line 1366  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void __skb_insert(struct sk_buff *newsk, struct sk_buff *prev, struct sk_buff *next, struct sk_buff_head *list)
{
  struct sk_buff *tmp;
  
#line 1370 
  newsk->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.next = next;
  
#line 1371 
  newsk->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.prev = prev;
  
#line 1372 
  tmp = newsk;
  
#line 1372 
  prev->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.next = tmp;
  
#line 1372 
  next->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.prev = tmp;
  
#line 1373 
  list->qlen += 1U;
  
#line 1374 
  return;
}


#line 1474  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void __skb_queue_before(struct sk_buff_head *list, struct sk_buff *next, struct sk_buff *newsk)
{
  
#line 1478 
  __skb_insert(newsk,next->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.prev,next,list);
  
#line 1479 
  return;
}


#line 1509  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void __skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
{
  
#line 1512 
  __skb_queue_before(list,(struct sk_buff *)list,newsk);
  
#line 1513 
  return;
}


#line 1520  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void __skb_unlink(struct sk_buff *skb, struct sk_buff_head *list)
{
  struct sk_buff *next;
  struct sk_buff *prev;
  struct sk_buff *tmp;
  
#line 1524 
  list->qlen -= 1U;
  
#line 1525 
  next = skb->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.next;
  
#line 1526 
  prev = skb->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.prev;
  
#line 1527 
  tmp = (struct sk_buff *)0;
  
#line 1527 
  skb->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.prev = tmp;
  
#line 1527 
  skb->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.next = tmp;
  
#line 1528 
  next->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.prev = prev;
  
#line 1529 
  prev->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.next = next;
  
#line 1530 
  return;
}


#line 1541  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct sk_buff *__skb_dequeue(struct sk_buff_head *list)
{
  
#line 1543 
  struct sk_buff *skb = skb_peek((struct sk_buff_head const *)list);
  
#line 1544 
  if (skb != (struct sk_buff *)0) 
#line 1545 
                                  __skb_unlink(skb,list); else ;
  
#line 1546 
  return skb;
}


#line 1567  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static bool skb_is_nonlinear(struct sk_buff const *skb)
{
  bool __retres;
  
#line 1569 
  __retres = (_Bool)(skb->data_len != 0U);
  
#line 1569 
  return __retres;
}


#line 1688 
unsigned char *skb_put(struct sk_buff *, unsigned int);


#line 1706 
unsigned char *skb_pull(struct sk_buff *, unsigned int);


#line 1761  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int skb_tailroom(struct sk_buff const *skb)
{
  int __retres;
  unsigned int tmp_0;
  bool tmp;
  
#line 1763 
  tmp = skb_is_nonlinear(skb);
  
#line 1763 
  if ((int)tmp == 0) 
#line 1763 
                     tmp_0 = skb->end - skb->tail; else 
#line 1763 
                                                        tmp_0 = 0U;
  
#line 1763 
  __retres = (int)tmp_0;
  
#line 1763 
  return __retres;
}


#line 2057 
void skb_trim(struct sk_buff *, unsigned int);


#line 2789  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_copy_from_linear_data(struct sk_buff const *skb, void *to, unsigned int const len)
{
  
#line 2793 
  memcpy(to,(void const *)skb->data,(unsigned long)len);
  
#line 2794 
  return;
}


#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool is_multicast_ether_addr(u8 const *addr)
{
  bool __retres;
  
#line 114 
  u32 a = *((u32 const *)addr);
  
#line 121 
  __retres = (_Bool)((a & 1U) != 0U);
  
#line 121 
  return __retres;
}


#line 281  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
__inline static int ieee80211_has_morefrags(__le16 fc)
{
  int __retres;
  
#line 283 
  __retres = ((int)fc & 1024) != 0;
  
#line 283 
  return __retres;
}


#line 308  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
__inline static int ieee80211_has_moredata(__le16 fc)
{
  int __retres;
  
#line 310 
  __retres = ((int)fc & 8192) != 0;
  
#line 310 
  return __retres;
}


#line 355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
__inline static int ieee80211_is_data(__le16 fc)
{
  int __retres;
  
#line 357 
  __retres = ((int)fc & 12) == 8;
  
#line 357 
  return __retres;
}


#line 379  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
__inline static int ieee80211_is_data_present(__le16 fc)
{
  int __retres;
  
#line 385 
  __retres = ((int)fc & 76) == 8;
  
#line 385 
  return __retres;
}


#line 503  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
__inline static int ieee80211_is_action(__le16 fc)
{
  int __retres;
  
#line 505 
  __retres = ((int)fc & 252) == 208;
  
#line 505 
  return __retres;
}


#line 563  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
__inline static int ieee80211_is_ack(__le16 fc)
{
  int __retres;
  
#line 565 
  __retres = ((int)fc & 252) == 212;
  
#line 565 
  return __retres;
}


#line 603  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
__inline static int ieee80211_is_qos_nullfunc(__le16 fc)
{
  int __retres;
  
#line 605 
  __retres = ((int)fc & 252) == 200;
  
#line 605 
  return __retres;
}


#line 923  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
__inline static struct ieee80211_rx_status *IEEE80211_SKB_RXCB(struct sk_buff *skb)
{
  struct ieee80211_rx_status *__retres;
  
#line 925 
  __retres = (struct ieee80211_rx_status *)(& skb->cb);
  
#line 925 
  return __retres;
}


#line 3734 
void ieee80211_rx(struct ieee80211_hw *, struct sk_buff *);


#line 196  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath.h"
struct sk_buff *ath_rxbuf_alloc(struct ath_common *, u32, gfp_t);


#line 199 
bool ath_is_mybeacon(struct ath_common *, struct ieee80211_hdr *);


#line 201 
void ath_hw_setbssidmask(struct ath_common *);


#line 729  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mac.h"
int ath9k_hw_rxprocdesc(struct ath_hw *, struct ath_desc *, struct ath_rx_status *);


#line 731 
void ath9k_hw_setuprxdesc(struct ath_hw *, struct ath_desc *, u32, u32);


#line 734 
void ath9k_hw_putrxbuf(struct ath_hw *, u32);


#line 735 
void ath9k_hw_startpcureceive(struct ath_hw *, bool);


#line 736 
void ath9k_hw_abortpcurecv(struct ath_hw *);


#line 737 
bool ath9k_hw_stopdmarecv(struct ath_hw *, bool *);


#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/dynack.h"
void ath_dynack_sample_ack_ts(struct ath_hw *, struct sk_buff *, u32);


#line 1028  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
void ath9k_hw_setantenna(struct ath_hw *, u32);


#line 1045 
void ath9k_hw_setrxfilter(struct ath_hw *, u32);


#line 1049 
void ath9k_hw_setopmode(struct ath_hw *);


#line 1050 
void ath9k_hw_setmcastfilter(struct ath_hw *, u32, u32);


#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw-ops.h"
__inline static void ath9k_hw_rxena(struct ath_hw *ah)
{
  struct ath_hw_ops *tmp;
  
#line 35 
  tmp = ath9k_hw_ops(ah);
  
#line 35 
  (*(tmp->rx_enable))(ah);
  
#line 36 
  return;
}


#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/common-spectral.h"
int ath_cmn_process_fft(struct ath_spec_scan_priv *, struct ieee80211_hdr *, struct ath_rx_status *, u64);


#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/common.h"
bool ath9k_cmn_rx_accept(struct ath_common *, struct ieee80211_hdr *, struct ieee80211_rx_status *, struct ath_rx_status *, bool *, unsigned int);


#line 69 
void ath9k_cmn_rx_skb_postprocess(struct ath_common *, struct sk_buff *, struct ath_rx_status *, struct ieee80211_rx_status *, bool);


#line 74 
int ath9k_cmn_process_rate(struct ath_common *, struct ieee80211_hw *, struct ath_rx_status *, struct ieee80211_rx_status *);


#line 78 
void ath9k_cmn_process_rssi(struct ath_common *, struct ieee80211_hw *, struct ath_rx_status *, struct ieee80211_rx_status *);


#line 256  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.h"
void ath_debug_stat_rx(struct ath_softc *sc, struct ath_rx_status *rs);


#line 314 
void ath_debug_rate_stats(struct ath_softc *sc, struct ath_rx_status *rs, struct sk_buff *skb);


#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/dfs.h"
void ath9k_dfs_process_phyerr(struct ath_softc *sc, void *data, struct ath_rx_status *rs, u64 mactime);


#line 455  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
void ath9k_p2p_beacon_sync(struct ath_softc *sc);


#line 465 
void ath_chanctx_beacon_recv_ev(struct ath_softc *sc, enum ath_chanctx_event ev);


#line 548 
void ath_startrecv(struct ath_softc *sc);


#line 549 
bool ath_stoprecv(struct ath_softc *sc);


#line 550 
u32 ath_calcrxfilter(struct ath_softc *sc);


#line 553 
int ath_rx_tasklet(struct ath_softc *sc, int flush, bool hp);


#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ar9003_mac.h"
void ath9k_hw_set_rx_bufsize(struct ath_hw *, u16);


#line 113 
void ath9k_hw_addrxbuf_edma(struct ath_hw *, u32, enum ath9k_rx_qtype);


#line 116 
int ath9k_hw_process_rxdesc_edma(struct ath_hw *, struct ath_rx_status *, void *);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c"
__inline static bool ath9k_check_auto_sleep(struct ath_softc *sc)
{
  bool __retres;
  
#line 25 
  __retres = (_Bool)(((int)sc->ps_enabled != 0 && ((sc->sc_ah)->caps.hw_caps & 4U) != 0U) != 0);
  
#line 25 
  return __retres;
}


#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c"
static void ath_rx_buf_link(struct ath_softc *sc, struct ath_rxbuf *bf, bool flush)
{
  struct ath_desc *ds;
  struct sk_buff *skb;
  
#line 40 
  struct ath_hw *ah = sc->sc_ah;
  
#line 41 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 45 
  ds = (struct ath_desc *)bf->bf_desc;
  
#line 46 
  ds->ds_link = 0U;
  
#line 47 
  ds->ds_data = (unsigned int)bf->bf_buf_addr;
  
#line 50 
  skb = bf->bf_mpdu;
  
#line 51 
  if ((long)(skb == (struct sk_buff *)0) != 0L) {
    
#line 53 
    ldv_inline_asm();
    
#line 51 
    ;
  }
  else ;
  
#line 52 
  ds->ds_vdata = (void *)skb->data;
  
#line 59 
  ath9k_hw_setuprxdesc(ah,ds,common->rx_bufsize,0U);
  
#line 63 
  if (sc->rx.rxlink != (u32 *)0U) 
#line 64 
                                  *(sc->rx.rxlink) = (unsigned int)bf->bf_daddr;
  else 
    
#line 65 
    if (! flush) 
#line 66 
                 ath9k_hw_putrxbuf(ah,(unsigned int)bf->bf_daddr); else ;
  
#line 68 
  sc->rx.rxlink = & ds->ds_link;
  
#line 69 
  return;
}


#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c"
static void ath_rx_buf_relink(struct ath_softc *sc, struct ath_rxbuf *bf, bool flush)
{
  
#line 74 
  if (sc->rx.buf_hold != (struct ath_rxbuf *)0) 
#line 75 
                                                ath_rx_buf_link(sc,sc->rx.buf_hold,(_Bool)((bool)((int)flush) != 0)); else ;
  
#line 77 
  sc->rx.buf_hold = bf;
  
#line 78 
  return;
}


#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c"
static void ath_setdefantenna(struct ath_softc *sc, u32 antenna)
{
  
#line 83 
  ath9k_hw_setantenna(sc->sc_ah,antenna);
  
#line 84 
  sc->rx.defant = (unsigned char)antenna;
  
#line 85 
  sc->rx.rxotherant = (unsigned char)0U;
  
#line 86 
  return;
}


#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c"
static void ath_opmode_init(struct ath_softc *sc)
{
  u32 rfilt;
  u32 mfilt[2U];
  
#line 90 
  struct ath_hw *ah = sc->sc_ah;
  
#line 91 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 96 
  rfilt = ath_calcrxfilter(sc);
  
#line 97 
  ath9k_hw_setrxfilter(ah,rfilt);
  
#line 100 
  ath_hw_setbssidmask(common);
  
#line 103 
  ath9k_hw_setopmode(ah);
  
#line 106 
  mfilt[1] = 4294967295U;
  
#line 106 
  mfilt[0] = mfilt[1];
  
#line 107 
  ath9k_hw_setmcastfilter(ah,mfilt[0],mfilt[1]);
  
#line 108 
  return;
}


#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c"
static bool ath_rx_edma_buf_link(struct ath_softc *sc, enum ath9k_rx_qtype qtype)
{
  bool __retres;
  struct ath_rx_edma *rx_edma;
  struct sk_buff *skb;
  struct ath_rxbuf *bf;
  __u32 tmp;
  struct ath_rxbuf *tmp_0;
  
#line 113 
  struct ath_hw *ah = sc->sc_ah;
  
#line 118 
  rx_edma = & sc->rx.rx_edma[(unsigned int)qtype];
  
#line 119 
  tmp = skb_queue_len((struct sk_buff_head const *)(& rx_edma->rx_fifo));
  
#line 119 
  ;
  
#line 119 
  if (tmp >= rx_edma->rx_fifo_hwsize) {
    
#line 120 
    __retres = (_Bool)0;
    
#line 120 
    goto return_label;
  }
  else ;
  {
    
#line 122 
    struct list_head const *__mptr = (struct list_head const *)sc->rx.rxbuf.next;
    
#line 122 
    tmp_0 = (struct ath_rxbuf *)__mptr;
  }
  
#line 122 
  bf = tmp_0;
  
#line 123 
  list_del_init(& bf->list);
  
#line 125 
  skb = bf->bf_mpdu;
  
#line 127 
  memset((void *)skb->data,0,(unsigned long)ah->caps.rx_status_len);
  
#line 128 
  dma_sync_single_for_device(sc->dev,bf->bf_buf_addr,(unsigned long)ah->caps.rx_status_len,(enum dma_data_direction)DMA_TO_DEVICE);
  
#line 131 
  *((struct ath_rxbuf **)(& skb->cb)) = bf;
  
#line 132 
  ath9k_hw_addrxbuf_edma(ah,(unsigned int)bf->bf_buf_addr,qtype);
  
#line 133 
  __skb_queue_tail(& rx_edma->rx_fifo,skb);
  
#line 135 
  __retres = (_Bool)1;
  return_label: 
#line 135 
                return __retres;
}


#line 138  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c"
static void ath_rx_addbuffer_edma(struct ath_softc *sc, enum ath9k_rx_qtype qtype)
{
  struct ath_rxbuf *bf;
  struct ath_rxbuf *tbf;
  int tmp_0;
  struct ath_rxbuf *tmp_1;
  struct ath_rxbuf *tmp_2;
  int tmp_4;
  bool tmp_3;
  struct ath_rxbuf *tmp_5;
  
#line 141 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 144 
  tmp_0 = list_empty((struct list_head const *)(& sc->rx.rxbuf));
  
#line 144 
  if (tmp_0 != 0) {
    
#line 145 
    if ((common->debug_mask & 2) != 0) 
#line 145 
                                       ath_printk("\001",(struct ath_common const *)common,"No free rx buf available\n"); else ;
    
#line 146 
    goto return_label;
  }
  else ;
  {
    
#line 149 
    struct list_head const *__mptr = (struct list_head const *)sc->rx.rxbuf.next;
    
#line 149 
    tmp_1 = (struct ath_rxbuf *)__mptr;
  }
  
#line 149 
  bf = tmp_1;
  {
    
#line 149 
    struct list_head const *__mptr_0 = (struct list_head const *)bf->list.next;
    
#line 149 
    tmp_2 = (struct ath_rxbuf *)__mptr_0;
  }
  
#line 150 
  tbf = tmp_2;
  
#line 149 
  goto ldv_53494;
  ldv_53493: 
#line 150 
  ;
  
#line 150 
  tmp_3 = ath_rx_edma_buf_link(sc,qtype);
  
#line 150 
  if (tmp_3) 
#line 150 
             tmp_4 = 0; else 
#line 150 
                             tmp_4 = 1;
  
#line 150 
  if (tmp_4) 
#line 151 
             goto ldv_53492; else ;
  
#line 149 
  bf = tbf;
  {
    
#line 149 
    struct list_head const *__mptr_1 = (struct list_head const *)tbf->list.next;
    
#line 149 
    tmp_5 = (struct ath_rxbuf *)__mptr_1;
  }
  
#line 149 
  tbf = tmp_5;
  ldv_53494: 
#line 151 
  ;
  
#line 149 
  if (& bf->list != & sc->rx.rxbuf) 
#line 151 
                                    goto ldv_53493; else 
#line 154 
                                                         goto ldv_53492;
  ldv_53492: 
#line 155 
  ;
  return_label: 
#line 156 
                return;
}


#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c"
static void ath_rx_remove_buffer(struct ath_softc *sc, enum ath9k_rx_qtype qtype)
{
  struct ath_rxbuf *bf;
  struct ath_rx_edma *rx_edma;
  struct sk_buff *skb;
  
#line 162 
  rx_edma = & sc->rx.rx_edma[(unsigned int)qtype];
  
#line 164 
  goto ldv_53503;
  ldv_53502: 
#line 165 
  ;
  
#line 165 
  bf = *((struct ath_rxbuf **)(& skb->cb));
  
#line 166 
  if ((long)(bf == (struct ath_rxbuf *)0) != 0L) {
    
#line 168 
    ldv_inline_asm();
    
#line 166 
    ;
  }
  else ;
  
#line 167 
  list_add_tail(& bf->list,& sc->rx.rxbuf);
  ldv_53503: 
#line 168 
  ;
  
#line 164 
  skb = __skb_dequeue(& rx_edma->rx_fifo);
  
#line 164 
  if (skb != (struct sk_buff *)0) 
#line 166 
                                  goto ldv_53502; else 
#line 169 
                                                       goto ldv_53504;
  ldv_53504: 
#line 170 
  ;
  
#line 171 
  return;
}


#line 171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c"
static void ath_rx_edma_cleanup(struct ath_softc *sc)
{
  struct ath_rxbuf *bf;
  struct ath_rxbuf *tmp_0;
  struct ath_rxbuf *tmp_1;
  
#line 173 
  struct ath_hw *ah = sc->sc_ah;
  
#line 174 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 177 
  ath_rx_remove_buffer(sc,(enum ath9k_rx_qtype)ATH9K_RX_QUEUE_LP);
  
#line 178 
  ath_rx_remove_buffer(sc,(enum ath9k_rx_qtype)ATH9K_RX_QUEUE_HP);
  {
    
#line 180 
    struct list_head const *__mptr = (struct list_head const *)sc->rx.rxbuf.next;
    
#line 180 
    tmp_0 = (struct ath_rxbuf *)__mptr;
  }
  
#line 180 
  bf = tmp_0;
  
#line 180 
  goto ldv_53516;
  ldv_53515: 
#line 181 
  ;
  
#line 181 
  if (bf->bf_mpdu != (struct sk_buff *)0) {
    
#line 182 
    dma_unmap_single_attrs(sc->dev,bf->bf_buf_addr,(unsigned long)common->rx_bufsize,(enum dma_data_direction)DMA_BIDIRECTIONAL,(struct dma_attrs *)0);
    
#line 185 
    dev_kfree_skb_any(bf->bf_mpdu);
    
#line 186 
    bf->bf_buf_addr = 0ULL;
    
#line 187 
    bf->bf_mpdu = (struct sk_buff *)0;
  }
  else ;
  {
    
#line 180 
    struct list_head const *__mptr_0 = (struct list_head const *)bf->list.next;
    
#line 180 
    tmp_1 = (struct ath_rxbuf *)__mptr_0;
  }
  
#line 180 
  bf = tmp_1;
  ldv_53516: 
#line 182 
  ;
  
#line 180 
  if (& bf->list != & sc->rx.rxbuf) 
#line 182 
                                    goto ldv_53515; else 
#line 185 
                                                         goto ldv_53517;
  ldv_53517: 
#line 186 
  ;
  
#line 187 
  return;
}


#line 192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c"
static void ath_rx_edma_init_queue(struct ath_rx_edma *rx_edma, int size)
{
  
#line 194 
  __skb_queue_head_init(& rx_edma->rx_fifo);
  
#line 195 
  rx_edma->rx_fifo_hwsize = (unsigned int)size;
  
#line 196 
  return;
}


#line 198  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c"
static int ath_rx_edma_init(struct ath_softc *sc, int nbufs)
{
  int __retres;
  struct sk_buff *skb;
  struct ath_rxbuf *bf;
  int i;
  u32 size;
  int tmp_1;
  
#line 200 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 201 
  struct ath_hw *ah = sc->sc_ah;
  
#line 204 
  int error = 0;
  
#line 207 
  ath9k_hw_set_rx_bufsize(ah,(unsigned short)((int)((unsigned short)common->rx_bufsize) - (int)((unsigned short)ah->caps.rx_status_len)));
  
#line 210 
  ath_rx_edma_init_queue(& sc->rx.rx_edma[1],(int)ah->caps.rx_lp_qdepth);
  
#line 212 
  ath_rx_edma_init_queue(& sc->rx.rx_edma[0],(int)ah->caps.rx_hp_qdepth);
  
#line 215 
  size = (unsigned int)((unsigned long)nbufs) * 48U;
  
#line 216 
  bf = (struct ath_rxbuf *)devm_kzalloc(sc->dev,(unsigned long)size,208U);
  
#line 217 
  if (bf == (struct ath_rxbuf *)0) {
    
#line 218 
    __retres = -12;
    
#line 218 
    goto return_label;
  }
  else ;
  
#line 220 
  INIT_LIST_HEAD(& sc->rx.rxbuf);
  
#line 222 
  i = 0;
  
#line 222 
  goto ldv_53535;
  ldv_53534: 
#line 223 
  ;
  
#line 223 
  skb = ath_rxbuf_alloc(common,common->rx_bufsize,208U);
  
#line 224 
  if (skb == (struct sk_buff *)0) {
    
#line 225 
    error = -12;
    
#line 226 
    goto rx_init_fail;
  }
  else ;
  
#line 229 
  memset((void *)skb->data,0,(unsigned long)common->rx_bufsize);
  
#line 230 
  bf->bf_mpdu = skb;
  
#line 232 
  bf->bf_buf_addr = dma_map_single_attrs(sc->dev,(void *)skb->data,(unsigned long)common->rx_bufsize,(enum dma_data_direction)DMA_BIDIRECTIONAL,(struct dma_attrs *)0);
  
#line 235 
  tmp_1 = dma_mapping_error(sc->dev,bf->bf_buf_addr);
  
#line 235 
  if ((long)(tmp_1 != 0) != 0L) {
    
#line 237 
    dev_kfree_skb_any(skb);
    
#line 238 
    bf->bf_mpdu = (struct sk_buff *)0;
    
#line 239 
    bf->bf_buf_addr = 0ULL;
    
#line 240 
    ath_printk("\001",(struct ath_common const *)common,"dma_mapping_error() on RX init\n");
    
#line 242 
    error = -12;
    
#line 243 
    goto rx_init_fail;
  }
  else ;
  
#line 246 
  list_add_tail(& bf->list,& sc->rx.rxbuf);
  
#line 222 
  i += 1;
  
#line 222 
  bf += 1;
  ldv_53535: 
#line 223 
  ;
  
#line 222 
  if (i < nbufs) 
#line 224 
                 goto ldv_53534; else 
#line 227 
                                      goto ldv_53536;
  ldv_53536: 
#line 228 
  ;
  
#line 249 
  __retres = 0;
  
#line 249 
  goto return_label;
  rx_init_fail: 
#line 251 
  ;
  
#line 252 
  ath_rx_edma_cleanup(sc);
  
#line 253 
  __retres = error;
  return_label: 
#line 253 
                return __retres;
}


#line 256  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c"
static void ath_edma_start_recv(struct ath_softc *sc)
{
  
#line 258 
  ath9k_hw_rxena(sc->sc_ah);
  
#line 259 
  ath_rx_addbuffer_edma(sc,(enum ath9k_rx_qtype)ATH9K_RX_QUEUE_HP);
  
#line 260 
  ath_rx_addbuffer_edma(sc,(enum ath9k_rx_qtype)ATH9K_RX_QUEUE_LP);
  
#line 261 
  ath_opmode_init(sc);
  
#line 262 
  ath9k_hw_startpcureceive(sc->sc_ah,(_Bool)((bool)((int)(sc->cur_chan)->offchannel) != 0));
  
#line 263 
  return;
}


#line 265  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c"
static void ath_edma_stop_recv(struct ath_softc *sc)
{
  
#line 267 
  ath_rx_remove_buffer(sc,(enum ath9k_rx_qtype)ATH9K_RX_QUEUE_HP);
  
#line 268 
  ath_rx_remove_buffer(sc,(enum ath9k_rx_qtype)ATH9K_RX_QUEUE_LP);
  
#line 269 
  return;
}


#line 271  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c"
int ath_rx_init(struct ath_softc *sc, int nbufs)
{
  int __retres;
  struct sk_buff *skb;
  struct ath_rxbuf *bf;
  struct ath_rxbuf *tmp_1;
  int tmp_2;
  struct ath_rxbuf *tmp_3;
  
#line 273 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 276 
  int error = 0;
  
#line 278 
  spinlock_check(& sc->sc_pcu_lock);
  {
    struct lock_class_key __key;
    
#line 278 
    __raw_spin_lock_init(& sc->sc_pcu_lock.__anonCompField_spinlock_18.rlock,"&(&sc->sc_pcu_lock)->rlock",& __key);
  }
  
#line 280 
  common->rx_bufsize = (unsigned int)((int)(sc->sc_ah)->caps.rx_status_len + 1926);
  
#line 283 
  if (((sc->sc_ah)->caps.hw_caps & 16U) != 0U) {
    int tmp_0;
    
#line 284 
    tmp_0 = ath_rx_edma_init(sc,nbufs);
    
#line 284 
    __retres = tmp_0;
    
#line 284 
    goto return_label;
  }
  else ;
  
#line 286 
  if ((common->debug_mask & 512) != 0) 
#line 286 
                                       ath_printk("\001",(struct ath_common const *)common,"cachelsz %u rxbufsize %u\n",(int)common->cachelsz,common->rx_bufsize); else ;
  
#line 291 
  error = ath_descdma_setup(sc,& sc->rx.rxdma,& sc->rx.rxbuf,"rx",nbufs,1,(_Bool)0);
  
#line 293 
  if (error != 0) {
    
#line 294 
    ath_printk("\001",(struct ath_common const *)common,"failed to allocate rx descriptors: %d\n",error);
    
#line 297 
    goto err;
  }
  else ;
  {
    
#line 300 
    struct list_head const *__mptr = (struct list_head const *)sc->rx.rxbuf.next;
    
#line 300 
    tmp_1 = (struct ath_rxbuf *)__mptr;
  }
  
#line 300 
  bf = tmp_1;
  
#line 300 
  goto ldv_53558;
  ldv_53557: 
#line 301 
  ;
  
#line 301 
  skb = ath_rxbuf_alloc(common,common->rx_bufsize,208U);
  
#line 303 
  if (skb == (struct sk_buff *)0) {
    
#line 304 
    error = -12;
    
#line 305 
    goto err;
  }
  else ;
  
#line 308 
  bf->bf_mpdu = skb;
  
#line 309 
  bf->bf_buf_addr = dma_map_single_attrs(sc->dev,(void *)skb->data,(unsigned long)common->rx_bufsize,(enum dma_data_direction)DMA_FROM_DEVICE,(struct dma_attrs *)0);
  
#line 312 
  tmp_2 = dma_mapping_error(sc->dev,bf->bf_buf_addr);
  
#line 312 
  if ((long)(tmp_2 != 0) != 0L) {
    
#line 314 
    dev_kfree_skb_any(skb);
    
#line 315 
    bf->bf_mpdu = (struct sk_buff *)0;
    
#line 316 
    bf->bf_buf_addr = 0ULL;
    
#line 317 
    ath_printk("\001",(struct ath_common const *)common,"dma_mapping_error() on RX init\n");
    
#line 319 
    error = -12;
    
#line 320 
    goto err;
  }
  else ;
  {
    
#line 300 
    struct list_head const *__mptr_0 = (struct list_head const *)bf->list.next;
    
#line 300 
    tmp_3 = (struct ath_rxbuf *)__mptr_0;
  }
  
#line 300 
  bf = tmp_3;
  ldv_53558: 
#line 302 
  ;
  
#line 300 
  if (& bf->list != & sc->rx.rxbuf) 
#line 302 
                                    goto ldv_53557; else 
#line 305 
                                                         goto ldv_53559;
  ldv_53559: 
#line 306 
  ;
  
#line 323 
  sc->rx.rxlink = (u32 *)0U;
  err: 
#line 324 
  ;
  
#line 325 
  if (error != 0) 
#line 326 
                  ath_rx_cleanup(sc); else ;
  
#line 328 
  __retres = error;
  return_label: 
#line 328 
                return __retres;
}


#line 331  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c"
void ath_rx_cleanup(struct ath_softc *sc)
{
  struct sk_buff *skb;
  struct ath_rxbuf *bf;
  struct ath_rxbuf *tmp_0;
  struct ath_rxbuf *tmp_1;
  
#line 333 
  struct ath_hw *ah = sc->sc_ah;
  
#line 334 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 338 
  if (((sc->sc_ah)->caps.hw_caps & 16U) != 0U) {
    
#line 339 
    ath_rx_edma_cleanup(sc);
    
#line 340 
    goto return_label;
  }
  else ;
  {
    
#line 343 
    struct list_head const *__mptr = (struct list_head const *)sc->rx.rxbuf.next;
    
#line 343 
    tmp_0 = (struct ath_rxbuf *)__mptr;
  }
  
#line 343 
  bf = tmp_0;
  
#line 343 
  goto ldv_53572;
  ldv_53571: 
#line 344 
  ;
  
#line 344 
  skb = bf->bf_mpdu;
  
#line 345 
  if (skb != (struct sk_buff *)0) {
    
#line 346 
    dma_unmap_single_attrs(sc->dev,bf->bf_buf_addr,(unsigned long)common->rx_bufsize,(enum dma_data_direction)DMA_FROM_DEVICE,(struct dma_attrs *)0);
    
#line 349 
    consume_skb(skb);
    
#line 350 
    bf->bf_buf_addr = 0ULL;
    
#line 351 
    bf->bf_mpdu = (struct sk_buff *)0;
  }
  else ;
  {
    
#line 343 
    struct list_head const *__mptr_0 = (struct list_head const *)bf->list.next;
    
#line 343 
    tmp_1 = (struct ath_rxbuf *)__mptr_0;
  }
  
#line 343 
  bf = tmp_1;
  ldv_53572: 
#line 345 
  ;
  
#line 343 
  if (& bf->list != & sc->rx.rxbuf) 
#line 345 
                                    goto ldv_53571; else 
#line 348 
                                                         goto ldv_53573;
  ldv_53573: 
#line 349 
  ;
  return_label: 
#line 350 
                return;
}


#line 375  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c"
u32 ath_calcrxfilter(struct ath_softc *sc)
{
  u32 __retres;
  u32 rfilt;
  bool tmp_0;
  
#line 377 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 381 
  __retres = 0U;
  
#line 381 
  goto return_label;
  
#line 383 
  rfilt = 7U;
  
#line 387 
  if ((int)(sc->hw)->conf.radar_enabled != 0) 
#line 388 
                                              rfilt |= 8448U; else ;
  
#line 390 
  ldv_spin_lock_bh_72_0(& sc->chan_lock);
  
#line 392 
  if (((sc->cur_chan)->rxfilter & 256U) != 0U) 
#line 393 
                                               rfilt |= 128U; else ;
  
#line 395 
  if ((int)(sc->sc_ah)->is_monitoring != 0) 
#line 396 
                                            rfilt |= 32U; else ;
  
#line 398 
  if (((sc->cur_chan)->rxfilter & 32U) != 0U || (int)(sc->sc_ah)->dynack.enabled != 0) 
    
#line 400 
    rfilt |= 8U; else ;
  
#line 402 
  if (((sc->sc_ah)->opmode == (unsigned int)NL80211_IFTYPE_STATION && (int)(sc->cur_chan)->nvifs <= 1) && ((sc->cur_chan)->rxfilter & 16U) == 0U) 
    
#line 405 
    rfilt |= 512U; else 
#line 407 
                        rfilt |= 16U;
  
#line 409 
  if ((sc->sc_ah)->opmode == (unsigned int)NL80211_IFTYPE_AP || ((sc->cur_chan)->rxfilter & 128U) != 0U) 
    
#line 411 
    rfilt |= 16384U; else ;
  
#line 413 
  if (sc->cur_chandef.width != (unsigned int)NL80211_CHAN_WIDTH_20_NOHT) 
    
#line 414 
    rfilt |= 1024U; else ;
  
#line 416 
  if ((int)(sc->cur_chan)->nvifs > 1 || ((sc->cur_chan)->rxfilter & 64U) != 0U) {
    
#line 418 
    if ((sc->sc_ah)->hw_version.macVersion <= 64U) 
#line 419 
                                                   rfilt |= 32U; else ;
    
#line 420 
    rfilt |= 32768U;
  }
  else ;
  
#line 423 
  if (((sc->sc_ah)->hw_version.macVersion == 1024U || (sc->sc_ah)->hw_version.macVersion == 1280U) || (sc->sc_ah)->hw_version.macVersion == 1536U) 
    
#line 425 
    rfilt |= 1048576U; else ;
  
#line 427 
  tmp_0 = ath9k_is_chanctx_enabled();
  
#line 427 
  if ((int)tmp_0 != 0) {
    int tmp_1;
    
#line 427 
    tmp_1 = constant_test_bit(5L,(unsigned long const volatile *)(& common->op_flags));
    
#line 427 
    if (tmp_1 != 0) 
#line 429 
                    rfilt |= 16U; else ;
  }
  else ;
  
#line 431 
  ldv_spin_unlock_bh_73_0(& sc->chan_lock);
  
#line 433 
  __retres = rfilt;
  return_label: 
#line 433 
                return __retres;
}


#line 437  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c"
void ath_startrecv(struct ath_softc *sc)
{
  struct ath_rxbuf *bf;
  struct ath_rxbuf *tbf;
  int tmp;
  struct ath_rxbuf *tmp_0;
  struct ath_rxbuf *tmp_1;
  struct ath_rxbuf *tmp_2;
  int tmp_3;
  struct ath_rxbuf *tmp_4;
  
#line 439 
  struct ath_hw *ah = sc->sc_ah;
  
#line 442 
  if ((ah->caps.hw_caps & 16U) != 0U) {
    
#line 443 
    ath_edma_start_recv(sc);
    
#line 444 
    goto return_label;
  }
  else ;
  
#line 447 
  tmp = list_empty((struct list_head const *)(& sc->rx.rxbuf));
  
#line 447 
  if (tmp != 0) 
#line 448 
                goto start_recv; else ;
  
#line 450 
  sc->rx.buf_hold = (struct ath_rxbuf *)0;
  
#line 451 
  sc->rx.rxlink = (u32 *)0U;
  {
    
#line 452 
    struct list_head const *__mptr = (struct list_head const *)sc->rx.rxbuf.next;
    
#line 452 
    tmp_0 = (struct ath_rxbuf *)__mptr;
  }
  
#line 452 
  bf = tmp_0;
  {
    
#line 452 
    struct list_head const *__mptr_0 = (struct list_head const *)bf->list.next;
    
#line 452 
    tmp_1 = (struct ath_rxbuf *)__mptr_0;
  }
  
#line 453 
  tbf = tmp_1;
  
#line 452 
  goto ldv_53593;
  ldv_53592: 
#line 453 
  ;
  
#line 453 
  ath_rx_buf_link(sc,bf,(_Bool)0);
  
#line 452 
  bf = tbf;
  {
    
#line 452 
    struct list_head const *__mptr_1 = (struct list_head const *)tbf->list.next;
    
#line 452 
    tmp_2 = (struct ath_rxbuf *)__mptr_1;
  }
  
#line 452 
  tbf = tmp_2;
  ldv_53593: 
#line 454 
  ;
  
#line 452 
  if (& bf->list != & sc->rx.rxbuf) 
#line 454 
                                    goto ldv_53592; else 
#line 457 
                                                         goto ldv_53594;
  ldv_53594: 
#line 458 
  ;
  
#line 457 
  tmp_3 = list_empty((struct list_head const *)(& sc->rx.rxbuf));
  
#line 457 
  if (tmp_3 != 0) 
#line 458 
                  goto start_recv; else ;
  {
    
#line 460 
    struct list_head const *__mptr_2 = (struct list_head const *)sc->rx.rxbuf.next;
    
#line 460 
    tmp_4 = (struct ath_rxbuf *)__mptr_2;
  }
  
#line 460 
  bf = tmp_4;
  
#line 461 
  ath9k_hw_putrxbuf(ah,(unsigned int)bf->bf_daddr);
  
#line 462 
  ath9k_hw_rxena(ah);
  start_recv: 
#line 464 
  ;
  
#line 465 
  ath_opmode_init(sc);
  
#line 466 
  ath9k_hw_startpcureceive(ah,(_Bool)((bool)((int)(sc->cur_chan)->offchannel) != 0));
  return_label: 
#line 467 
                return;
}


#line 469  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c"
static void ath_flushrecv(struct ath_softc *sc)
{
  
#line 471 
  if (((sc->sc_ah)->caps.hw_caps & 16U) != 0U) 
#line 472 
                                               ath_rx_tasklet(sc,1,(_Bool)1); else ;
  
#line 473 
  ath_rx_tasklet(sc,1,(_Bool)0);
  
#line 474 
  return;
}


#line 476  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c"
bool ath_stoprecv(struct ath_softc *sc)
{
  bool __retres;
  bool stopped;
  
#line 478 
  struct ath_hw *ah = sc->sc_ah;
  
#line 479 
  bool reset = (_Bool)0;
  
#line 481 
  ath9k_hw_abortpcurecv(ah);
  
#line 482 
  ath9k_hw_setrxfilter(ah,0U);
  
#line 483 
  stopped = ath9k_hw_stopdmarecv(ah,& reset);
  
#line 485 
  ath_flushrecv(sc);
  
#line 487 
  if (((sc->sc_ah)->caps.hw_caps & 16U) != 0U) 
#line 488 
                                               ath_edma_stop_recv(sc); else 
                                                                    
#line 490 
                                                                    sc->rx.rxlink = (u32 *)0U;
  
#line 492 
  if ((ah->ah_flags & 2U) == 0U && (long)(! stopped) != 0L) {
    struct ath_common *tmp;
    
#line 494 
    tmp = ath9k_hw_common(sc->sc_ah);
    
#line 494 
    ath_printk("\001",(struct ath_common const *)tmp,"Could not stop RX, we could be ");
    {
      bool __warned;
      
#line 497 
      int __ret_warn_once = ! stopped;
      
#line 497 
      if ((long)(__ret_warn_once != 0) != 0L) {
        int tmp_0;
        {
          
#line 497 
          int __ret_warn_on = ! __warned;
          
#line 497 
          if ((long)(__ret_warn_on != 0) != 0L) 
#line 497 
                                                warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c",497); else ;
          
#line 497 
          tmp_0 = (long)(__ret_warn_on != 0);
        }
        
#line 497 
        if ((long)tmp_0 != 0L) 
#line 497 
                               __warned = (_Bool)1; else ;
      }
      else ;
      
#line 497 
      long tmp_2 = (long)(__ret_warn_once != 0);
    }
  }
  else ;
  
#line 499 
  __retres = (_Bool)(((int)stopped != 0 && ! reset) != 0);
  
#line 499 
  return __retres;
}


#line 502  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c"
static bool ath_beacon_dtim_pending_cab(struct sk_buff *skb)
{
  bool __retres;
  struct ieee80211_mgmt *mgmt;
  u8 *pos;
  u8 *end;
  u8 id;
  u8 elen;
  struct ieee80211_tim_ie *tim;
  u8 *tmp;
  u8 *tmp_0;
  
#line 509 
  mgmt = (struct ieee80211_mgmt *)skb->data;
  
#line 510 
  pos = (u8 *)(& mgmt->u.beacon.variable);
  
#line 511 
  end = skb->data + skb->len;
  
#line 513 
  goto ldv_53622;
  ldv_53621: 
#line 514 
  ;
  
#line 514 
  tmp = pos;
  
#line 514 
  pos += 1;
  
#line 514 
  id = *tmp;
  
#line 515 
  tmp_0 = pos;
  
#line 515 
  pos += 1;
  
#line 515 
  elen = *tmp_0;
  
#line 516 
  if (pos + (int)elen > end) 
#line 517 
                             goto ldv_53620; else ;
  
#line 519 
  if ((unsigned int)id == 5U) {
    
#line 520 
    if ((unsigned int)elen <= 3U) 
#line 521 
                                  goto ldv_53620; else ;
    
#line 522 
    tim = (struct ieee80211_tim_ie *)pos;
    
#line 523 
    if ((unsigned int)tim->dtim_count != 0U) 
#line 524 
                                             goto ldv_53620; else ;
    
#line 525 
    __retres = (_Bool)(((int)tim->bitmap_ctrl & 1) != 0);
    
#line 525 
    goto return_label;
  }
  else ;
  
#line 528 
  pos += (int)elen;
  ldv_53622: 
#line 529 
  ;
  
#line 513 
  if (pos + 2U < end) 
#line 515 
                      goto ldv_53621; else 
#line 518 
                                           goto ldv_53620;
  ldv_53620: 
#line 519 
  ;
  
#line 531 
  __retres = (_Bool)0;
  return_label: 
#line 531 
                return __retres;
}


#line 534  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c"
static void ath_rx_ps_beacon(struct ath_softc *sc, struct sk_buff *skb)
{
  bool tmp_3;
  
#line 536 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 537 
  bool skip_beacon = (_Bool)0;
  
#line 539 
  if (skb->len <= 35U) 
#line 540 
                       goto return_label; else ;
  
#line 542 
  sc->ps_flags = (unsigned short)((unsigned int)sc->ps_flags & 65534U);
  
#line 544 
  if (((unsigned long)sc->ps_flags & 16UL) != 0UL) {
    bool tmp_0;
    
#line 545 
    sc->ps_flags = (unsigned short)((unsigned int)sc->ps_flags & 65519U);
    
#line 546 
    if ((common->debug_mask & 2048) != 0) 
#line 546 
                                          ath_printk("\001",(struct ath_common const *)common,"Reconfigure beacon timers based on synchronized timestamp\n"); else ;
    
#line 550 
    tmp_0 = ath9k_is_chanctx_enabled();
    
#line 550 
    if ((int)tmp_0 != 0) {
      
#line 551 
      if (sc->cur_chan == & sc->offchannel.chan) 
#line 552 
                                                 skip_beacon = (_Bool)1; else ;
    }
    else ;
    
#line 556 
    if (! skip_beacon) {
      int tmp_2;
      {
        bool __warned;
        
#line 557 
        int __ret_warn_once = (sc->cur_chan)->beacon.beacon_interval == 0;
        
#line 557 
        if ((long)(__ret_warn_once != 0) != 0L) {
          int tmp_1;
          {
            
#line 557 
            int __ret_warn_on = ! __warned;
            
#line 557 
            if ((long)(__ret_warn_on != 0) != 0L) 
#line 557 
                                                  warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c",557); else ;
            
#line 557 
            tmp_1 = (long)(__ret_warn_on != 0);
          }
          
#line 557 
          if ((long)tmp_1 != 0L) 
#line 557 
                                 __warned = (_Bool)1; else ;
        }
        else ;
        
#line 557 
        tmp_2 = (long)(__ret_warn_once != 0);
      }
      
#line 556 
      if ((long)tmp_2 == 0L) 
#line 558 
                             ath9k_set_beacon(sc); else ;
    }
    else ;
    
#line 560 
    ath9k_p2p_beacon_sync(sc);
  }
  else ;
  
#line 563 
  tmp_3 = ath_beacon_dtim_pending_cab(skb);
  
#line 563 
  if ((int)tmp_3 != 0) {
    
#line 571 
    if ((common->debug_mask & 2048) != 0) 
#line 571 
                                          ath_printk("\001",(struct ath_common const *)common,"Received DTIM beacon indicating buffered broadcast/multicast frame(s)\n"); else ;
    
#line 573 
    sc->ps_flags = (unsigned short)((unsigned int)sc->ps_flags | 3U);
    
#line 574 
    goto return_label;
  }
  else ;
  
#line 577 
  if (((unsigned long)sc->ps_flags & 2UL) != 0UL) {
    
#line 583 
    sc->ps_flags = (unsigned short)((unsigned int)sc->ps_flags & 65533U);
    
#line 584 
    if ((common->debug_mask & 2048) != 0) 
#line 584 
                                          ath_printk("\001",(struct ath_common const *)common,"PS wait for CAB frames timed out\n"); else ;
  }
  else ;
  return_label: 
#line 586 
                return;
}


#line 588  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c"
static void ath_rx_ps(struct ath_softc *sc, struct sk_buff *skb, bool mybeacon)
{
  struct ieee80211_hdr *hdr;
  
#line 591 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 593 
  hdr = (struct ieee80211_hdr *)skb->data;
  
#line 596 
  if (((unsigned long)sc->ps_flags & 1UL) != 0UL) 
#line 596 
                                                  goto _LOR_0;
  else {
    bool tmp_7;
    
#line 596 
    tmp_7 = ath9k_check_auto_sleep(sc);
    
#line 596 
    if ((int)tmp_7 != 0) {
      _LOR_0: 
#line 597 
      ;
      
#line 597 
      if ((int)mybeacon != 0) 
#line 598 
                              ath_rx_ps_beacon(sc,skb); else 
#line 596 
                                                             goto _LAND_2;
    }
    else {
      _LAND_2: 
#line 599 
      ;
      
#line 599 
      if (((unsigned long)sc->ps_flags & 2UL) != 0UL) {
        int tmp_3;
        
#line 599 
        tmp_3 = ieee80211_is_data((unsigned short)((int)hdr->frame_control));
        
#line 599 
        if (tmp_3 != 0) 
#line 599 
                        goto _LOR;
        else {
          int tmp_4;
          
#line 600 
          tmp_4 = ieee80211_is_action((unsigned short)((int)hdr->frame_control));
          
#line 600 
          if (tmp_4 != 0) {
            bool tmp_5;
            _LOR: 
#line 601 
            tmp_5 = is_multicast_ether_addr((u8 const *)(& hdr->addr1));
            
#line 601 
            if ((int)tmp_5 != 0) {
              int tmp_6;
              
#line 602 
              tmp_6 = ieee80211_has_moredata((unsigned short)((int)hdr->frame_control));
              
#line 602 
              if (tmp_6 == 0) {
                
#line 608 
                sc->ps_flags = (unsigned short)((unsigned int)sc->ps_flags & 65532U);
                
#line 609 
                if ((common->debug_mask & 2048) != 0) 
#line 609 
                                                      ath_printk("\001",(struct ath_common const *)common,"All PS CAB frames received, back to sleep\n"); else ;
              }
              else 
#line 599 
                   goto _LAND_1;
            }
            else 
#line 599 
                 goto _LAND_1;
          }
          else 
#line 599 
               goto _LAND_1;
        }
      }
      else {
        _LAND_1: 
#line 611 
        ;
        
#line 611 
        if (((unsigned long)sc->ps_flags & 4UL) != 0UL) {
          int tmp_1;
          bool tmp_0;
          
#line 612 
          tmp_0 = is_multicast_ether_addr((u8 const *)(& hdr->addr1));
          
#line 612 
          if (tmp_0) 
#line 612 
                     tmp_1 = 0; else 
#line 612 
                                     tmp_1 = 1;
          
#line 612 
          if (tmp_1) {
            int tmp_2;
            
#line 612 
            tmp_2 = ieee80211_has_morefrags((unsigned short)((int)hdr->frame_control));
            
#line 612 
            if (tmp_2 == 0) {
              
#line 614 
              sc->ps_flags = (unsigned short)((unsigned int)sc->ps_flags & 65531U);
              
#line 615 
              if ((common->debug_mask & 2048) != 0) 
#line 615 
                                                    ath_printk("\001",(struct ath_common const *)common,"Going back to sleep after having received PS-Poll data (0x%lx)\n",(unsigned long)sc->ps_flags & 15UL); else ;
            }
            else ;
          }
          else ;
        }
        else ;
      }
    }
  }
  
#line 617 
  return;
}


#line 624  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c"
static bool ath_edma_get_buffers(struct ath_softc *sc, enum ath9k_rx_qtype qtype, struct ath_rx_status *rs, struct ath_rxbuf **dest)
{
  bool __retres;
  struct sk_buff *skb;
  struct ath_rxbuf *bf;
  int ret;
  
#line 629 
  struct ath_rx_edma *rx_edma = & sc->rx.rx_edma[(unsigned int)qtype];
  
#line 630 
  struct ath_hw *ah = sc->sc_ah;
  
#line 631 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 636 
  skb = skb_peek((struct sk_buff_head const *)(& rx_edma->rx_fifo));
  
#line 637 
  if (skb == (struct sk_buff *)0) {
    
#line 638 
    __retres = (_Bool)0;
    
#line 638 
    goto return_label;
  }
  else ;
  
#line 640 
  bf = *((struct ath_rxbuf **)(& skb->cb));
  
#line 641 
  if ((long)(bf == (struct ath_rxbuf *)0) != 0L) {
    
#line 643 
    ldv_inline_asm();
    
#line 641 
    ;
  }
  else ;
  
#line 643 
  dma_sync_single_for_cpu(sc->dev,bf->bf_buf_addr,(unsigned long)common->rx_bufsize,(enum dma_data_direction)DMA_FROM_DEVICE);
  
#line 646 
  ret = ath9k_hw_process_rxdesc_edma(ah,rs,(void *)skb->data);
  
#line 647 
  if (ret == -115) {
    
#line 649 
    dma_sync_single_for_device(sc->dev,bf->bf_buf_addr,(unsigned long)common->rx_bufsize,(enum dma_data_direction)DMA_FROM_DEVICE);
    
#line 651 
    __retres = (_Bool)0;
    
#line 651 
    goto return_label;
  }
  else ;
  
#line 654 
  __skb_unlink(skb,& rx_edma->rx_fifo);
  
#line 655 
  if (ret == -22) {
    
#line 657 
    list_add_tail(& bf->list,& sc->rx.rxbuf);
    
#line 658 
    ath_rx_edma_buf_link(sc,qtype);
    
#line 660 
    skb = skb_peek((struct sk_buff_head const *)(& rx_edma->rx_fifo));
    
#line 661 
    if (skb != (struct sk_buff *)0) {
      
#line 662 
      bf = *((struct ath_rxbuf **)(& skb->cb));
      
#line 663 
      if ((long)(bf == (struct ath_rxbuf *)0) != 0L) {
        
#line 665 
        ldv_inline_asm();
        
#line 663 
        ;
      }
      else ;
      
#line 665 
      __skb_unlink(skb,& rx_edma->rx_fifo);
      
#line 666 
      list_add_tail(& bf->list,& sc->rx.rxbuf);
      
#line 667 
      ath_rx_edma_buf_link(sc,qtype);
    }
    else ;
    
#line 670 
    bf = (struct ath_rxbuf *)0;
  }
  else ;
  
#line 673 
  *dest = bf;
  
#line 674 
  __retres = (_Bool)1;
  return_label: 
#line 674 
                return __retres;
}


#line 677  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c"
static struct ath_rxbuf *ath_edma_get_next_rx_buf(struct ath_softc *sc, struct ath_rx_status *rs, enum ath9k_rx_qtype qtype)
{
  struct ath_rxbuf *__retres;
  bool tmp;
  
#line 681 
  struct ath_rxbuf *bf = (struct ath_rxbuf *)0;
  
#line 683 
  goto ldv_53659;
  ldv_53660: 
#line 684 
  ;
  
#line 684 
  if (bf == (struct ath_rxbuf *)0) 
#line 685 
                                   goto ldv_53659; else ;
  
#line 687 
  __retres = bf;
  
#line 687 
  goto return_label;
  ldv_53659: 
#line 688 
  ;
  
#line 683 
  tmp = ath_edma_get_buffers(sc,qtype,rs,& bf);
  
#line 683 
  if ((int)tmp != 0) 
#line 685 
                     goto ldv_53660; else 
#line 688 
                                          goto ldv_53661;
  ldv_53661: 
#line 689 
  ;
  
#line 689 
  __retres = (struct ath_rxbuf *)0;
  return_label: 
#line 689 
                return __retres;
}


#line 692  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c"
static struct ath_rxbuf *ath_get_next_rx_buf(struct ath_softc *sc, struct ath_rx_status *rs)
{
  struct ath_rxbuf *__retres;
  struct ath_desc *ds;
  struct ath_rxbuf *bf;
  int ret;
  int tmp_0;
  struct ath_rxbuf *tmp_1;
  
#line 695 
  struct ath_hw *ah = sc->sc_ah;
  
#line 696 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 701 
  tmp_0 = list_empty((struct list_head const *)(& sc->rx.rxbuf));
  
#line 701 
  if (tmp_0 != 0) {
    
#line 702 
    sc->rx.rxlink = (u32 *)0U;
    
#line 703 
    __retres = (struct ath_rxbuf *)0;
    
#line 703 
    goto return_label;
  }
  else ;
  {
    
#line 706 
    struct list_head const *__mptr = (struct list_head const *)sc->rx.rxbuf.next;
    
#line 706 
    tmp_1 = (struct ath_rxbuf *)__mptr;
  }
  
#line 706 
  bf = tmp_1;
  
#line 707 
  if (sc->rx.buf_hold == bf) {
    
#line 708 
    __retres = (struct ath_rxbuf *)0;
    
#line 708 
    goto return_label;
  }
  else ;
  
#line 710 
  ds = (struct ath_desc *)bf->bf_desc;
  
#line 723 
  ret = ath9k_hw_rxprocdesc(ah,ds,rs);
  
#line 724 
  if (ret == -115) {
    struct ath_rx_status trs;
    struct ath_rxbuf *tbf;
    struct ath_desc *tds;
    int tmp_2;
    struct ath_rxbuf *tmp_3;
    
#line 729 
    memset((void *)(& trs),0,52UL);
    
#line 730 
    tmp_2 = list_is_last((struct list_head const *)(& bf->list),(struct list_head const *)(& sc->rx.rxbuf));
    
#line 730 
    if (tmp_2 != 0) {
      
#line 731 
      sc->rx.rxlink = (u32 *)0U;
      
#line 732 
      __retres = (struct ath_rxbuf *)0;
      
#line 732 
      goto return_label;
    }
    else ;
    {
      
#line 735 
      struct list_head const *__mptr_0 = (struct list_head const *)bf->list.next;
      
#line 735 
      tmp_3 = (struct ath_rxbuf *)__mptr_0;
    }
    
#line 735 
    tbf = tmp_3;
    
#line 748 
    tds = (struct ath_desc *)tbf->bf_desc;
    
#line 749 
    ret = ath9k_hw_rxprocdesc(ah,tds,& trs);
    
#line 750 
    if (ret == -115) {
      
#line 751 
      __retres = (struct ath_rxbuf *)0;
      
#line 751 
      goto return_label;
    }
    else ;
    
#line 757 
    ret = ath9k_hw_rxprocdesc(ah,ds,rs);
    
#line 758 
    if (ret == -115) {
      
#line 763 
      rs->rs_datalen = (unsigned short)0U;
      
#line 764 
      rs->rs_more = (unsigned char)1U;
    }
    else ;
  }
  else ;
  
#line 768 
  list_del(& bf->list);
  
#line 769 
  if (bf->bf_mpdu == (struct sk_buff *)0) {
    
#line 770 
    __retres = bf;
    
#line 770 
    goto return_label;
  }
  else ;
  
#line 777 
  dma_sync_single_for_cpu(sc->dev,bf->bf_buf_addr,(unsigned long)common->rx_bufsize,(enum dma_data_direction)DMA_FROM_DEVICE);
  
#line 781 
  __retres = bf;
  return_label: 
#line 781 
                return __retres;
}


#line 784  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c"
static void ath9k_process_tsf(struct ath_rx_status *rs, struct ieee80211_rx_status *rxs, u64 tsf)
{
  
#line 788 
  u32 tsf_lower = (unsigned int)tsf;
  
#line 790 
  rxs->mactime = (tsf & 18446744069414584320ULL) | (unsigned long long)rs->rs_tstamp;
  
#line 791 
  if (rs->rs_tstamp > tsf_lower && (long)(rs->rs_tstamp - tsf_lower > 268435456U) != 0L) 
    
#line 793 
    rxs->mactime += 18446744069414584320ULL; else ;
  
#line 795 
  if (rs->rs_tstamp < tsf_lower && (long)(tsf_lower - rs->rs_tstamp > 268435456U) != 0L) 
    
#line 797 
    rxs->mactime += 4294967296ULL; else ;
  
#line 798 
  return;
}


#line 805  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c"
static int ath9k_rx_skb_preprocess(struct ath_softc *sc, struct sk_buff *skb, struct ath_rx_status *rx_stats, struct ieee80211_rx_status *rx_status, bool *decrypt_error, u64 tsf)
{
  int __retres;
  struct ieee80211_hdr *hdr;
  int tmp_2;
  bool tmp_1;
  bool tmp_3;
  int tmp_4;
  int tmp_5;
  bool tmp_6;
  int tmp_7;
  
#line 811 
  struct ieee80211_hw *hw = sc->hw;
  
#line 812 
  struct ath_hw *ah = sc->sc_ah;
  
#line 813 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 815 
  bool discard_current = sc->rx.discard_next;
  
#line 821 
  if ((int)discard_current != 0) 
#line 822 
                                 goto corrupt; else ;
  
#line 824 
  sc->rx.discard_next = (_Bool)0;
  
#line 829 
  if ((unsigned int)rx_stats->rs_datalen == 0U) {
    
#line 830 
    sc->debug.stats.rxstats.rx_len_err += 1U;
    
#line 831 
    goto corrupt;
  }
  else ;
  
#line 839 
  if ((unsigned int)rx_stats->rs_datalen > common->rx_bufsize - (unsigned int)ah->caps.rx_status_len) {
    
#line 840 
    sc->debug.stats.rxstats.rx_len_err += 1U;
    
#line 841 
    goto corrupt;
  }
  else ;
  
#line 845 
  if ((unsigned int)rx_stats->rs_more != 0U) {
    
#line 846 
    __retres = 0;
    
#line 846 
    goto return_label;
  }
  else ;
  
#line 855 
  if (((int)rx_stats->rs_status & 64) != 0) 
#line 856 
                                            goto corrupt; else ;
  
#line 858 
  hdr = (struct ieee80211_hdr *)(skb->data + (int)ah->caps.rx_status_len);
  
#line 860 
  ath9k_process_tsf(rx_stats,rx_status,tsf);
  
#line 861 
  ath_debug_stat_rx(sc,rx_stats);
  
#line 867 
  if (((int)rx_stats->rs_status & 2) != 0) {
    int tmp_0;
    
#line 868 
    ath9k_dfs_process_phyerr(sc,(void *)hdr,rx_stats,rx_status->mactime);
    
#line 869 
    tmp_0 = ath_cmn_process_fft(& sc->spec_priv,hdr,rx_stats,rx_status->mactime);
    
#line 869 
    if (tmp_0 != 0) 
#line 870 
                    sc->debug.stats.rxstats.rx_spectral += 1U; else ;
    
#line 872 
    __retres = -22;
    
#line 872 
    goto return_label;
  }
  else ;
  
#line 879 
  ldv_spin_lock_bh_74(& sc->chan_lock);
  
#line 880 
  tmp_1 = ath9k_cmn_rx_accept(common,hdr,rx_status,rx_stats,decrypt_error,(sc->cur_chan)->rxfilter);
  
#line 880 
  if (tmp_1) 
#line 880 
             tmp_2 = 0; else 
#line 880 
                             tmp_2 = 1;
  
#line 880 
  if (tmp_2) {
    
#line 882 
    ldv_spin_unlock_bh_75(& sc->chan_lock);
    
#line 883 
    __retres = -22;
    
#line 883 
    goto return_label;
  }
  else ;
  
#line 885 
  ldv_spin_unlock_bh_76(& sc->chan_lock);
  
#line 887 
  tmp_3 = ath_is_mybeacon(common,hdr);
  
#line 887 
  if ((int)tmp_3 != 0) {
    
#line 888 
    sc->debug.stats.rxstats.rx_beacons += 1U;
    
#line 889 
    rx_stats->is_mybeacon = (_Bool)1;
  }
  else ;
  {
    
#line 895 
    int __ret_warn_on = ah->curchan == (struct ath9k_channel *)0;
    
#line 895 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 895 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c",895); else ;
    
#line 895 
    tmp_4 = (long)(__ret_warn_on != 0);
  }
  
#line 895 
  if ((long)tmp_4 != 0L) {
    
#line 896 
    __retres = -22;
    
#line 896 
    goto return_label;
  }
  else ;
  
#line 898 
  tmp_5 = ath9k_cmn_process_rate(common,hw,rx_stats,rx_status);
  
#line 898 
  if (tmp_5 != 0) {
    
#line 903 
    if (common->debug_mask != 0) 
#line 903 
                                 ath_printk("\001",(struct ath_common const *)common,"unsupported hw bitrate detected 0x%02x using 1 Mbit\n",(int)rx_stats->rs_rate); else ;
    
#line 905 
    sc->debug.stats.rxstats.rx_rate_err += 1U;
    
#line 906 
    __retres = -22;
    
#line 906 
    goto return_label;
  }
  else ;
  
#line 909 
  tmp_6 = ath9k_is_chanctx_enabled();
  
#line 909 
  if ((int)tmp_6 != 0) {
    
#line 910 
    if ((int)rx_stats->is_mybeacon != 0) 
#line 911 
                                         ath_chanctx_beacon_recv_ev(sc,(enum ath_chanctx_event)ATH_CHANCTX_EVENT_BEACON_RECEIVED); else ;
  }
  else ;
  
#line 915 
  ath9k_cmn_process_rssi(common,hw,rx_stats,rx_status);
  
#line 917 
  rx_status->band = (unsigned char)((ah->curchan)->chan)->band;
  
#line 918 
  rx_status->freq = ((ah->curchan)->chan)->center_freq;
  
#line 919 
  rx_status->antenna = rx_stats->rs_antenna;
  
#line 920 
  rx_status->flag |= 2097152U;
  
#line 923 
  tmp_7 = ieee80211_is_data_present((unsigned short)((int)hdr->frame_control));
  
#line 923 
  if (tmp_7 != 0) {
    int tmp_8;
    
#line 923 
    tmp_8 = ieee80211_is_qos_nullfunc((unsigned short)((int)hdr->frame_control));
    
#line 923 
    if (tmp_8 == 0) 
#line 925 
                    sc->rx.num_pkts += 1U; else ;
  }
  else ;
  
#line 928 
  __retres = 0;
  
#line 928 
  goto return_label;
  corrupt: 
#line 930 
  ;
  
#line 931 
  sc->rx.discard_next = (_Bool)((unsigned int)rx_stats->rs_more != 0U);
  
#line 932 
  __retres = -22;
  return_label: 
#line 932 
                return __retres;
}


#line 945  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c"
static void ath9k_antenna_check(struct ath_softc *sc, struct ath_rx_status *rs)
{
  
#line 948 
  struct ath_hw *ah = sc->sc_ah;
  
#line 949 
  struct ath9k_hw_capabilities *pCap = & ah->caps;
  
#line 950 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 952 
  if ((ah->caps.hw_caps & 1024U) == 0U) 
#line 953 
                                        goto return_label; else ;
  
#line 959 
  if ((int)sc->rx.defant != (int)rs->rs_antenna) {
    
#line 960 
    sc->rx.rxotherant = (u8)((int)sc->rx.rxotherant + 1);
    
#line 960 
    if ((unsigned int)sc->rx.rxotherant > 2U) 
#line 961 
                                              ath_setdefantenna(sc,(unsigned int)rs->rs_antenna); else ;
  }
  else 
#line 963 
       sc->rx.rxotherant = (unsigned char)0U;
  
#line 966 
  if ((pCap->hw_caps & 131072U) != 0U) {
    
#line 967 
    if ((int)common->bt_ant_diversity != 0) 
#line 968 
                                            ath_ant_comb_scan(sc,rs); else ;
  }
  else 
#line 970 
       ath_ant_comb_scan(sc,rs);
  return_label: 
#line 971 
                return;
}


#line 974  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c"
static void ath9k_apply_ampdu_details(struct ath_softc *sc, struct ath_rx_status *rs, struct ieee80211_rx_status *rxs)
{
  
#line 977 
  if ((unsigned int)rs->rs_isaggr != 0U) {
    
#line 978 
    rxs->flag |= 147456U;
    
#line 980 
    rxs->ampdu_reference = sc->rx.ampdu_ref;
    
#line 982 
    if ((unsigned int)rs->rs_moreaggr == 0U) {
      
#line 983 
      rxs->flag |= 262144U;
      
#line 984 
      sc->rx.ampdu_ref += 1U;
    }
    else ;
    
#line 987 
    if (((int)rs->rs_flags & 16) != 0) 
#line 988 
                                       rxs->flag |= 524288U; else ;
  }
  else ;
  
#line 990 
  return;
}


#line 992  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/recv.c"
int ath_rx_tasklet(struct ath_softc *sc, int flush, bool hp)
{
  int __retres;
  struct ath_rxbuf *bf;
  struct sk_buff *requeue_skb;
  struct sk_buff *hdr_skb;
  struct ieee80211_rx_status *rxs;
  int retval;
  struct ath_rx_status rs;
  enum ath9k_rx_qtype qtype;
  int dma_type;
  unsigned long flags;
  dma_addr_t new_buf_addr;
  struct ieee80211_hdr *hdr;
  
#line 995 
  struct sk_buff *skb = (struct sk_buff *)0;
  
#line 997 
  struct ath_hw *ah = sc->sc_ah;
  
#line 998 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 999 
  struct ieee80211_hw *hw = sc->hw;
  
#line 1003 
  bool edma = (_Bool)((ah->caps.hw_caps & 16U) != 0U);
  
#line 1005 
  u64 tsf = 0ULL;
  
#line 1008 
  unsigned int budget = 512U;
  
#line 1011 
  if ((int)edma != 0) 
#line 1012 
                      dma_type = 0; else 
#line 1014 
                                         dma_type = 2;
  
#line 1016 
  qtype = (enum ath9k_rx_qtype)(! hp);
  
#line 1018 
  tsf = ath9k_hw_gettsf64(ah);
  ldv_53741: 
#line 1019 
  ;
  {
    int tmp_0;
    int tmp_5;
    unsigned int tmp_6;
    
#line 1021 
    bool decrypt_error = (_Bool)0;
    
#line 1023 
    memset((void *)(& rs),0,52UL);
    
#line 1024 
    if ((int)edma != 0) 
#line 1025 
                        bf = ath_edma_get_next_rx_buf(sc,& rs,qtype); else 
                                                                    
#line 1027 
                                                                    bf = ath_get_next_rx_buf(sc,& rs);
    
#line 1029 
    if (bf == (struct ath_rxbuf *)0) 
#line 1030 
                                     goto ldv_53736; else ;
    
#line 1032 
    skb = bf->bf_mpdu;
    
#line 1033 
    if (skb == (struct sk_buff *)0) 
#line 1034 
                                    goto ldv_53737; else ;
    
#line 1040 
    if (sc->rx.frag != (struct sk_buff *)0) 
#line 1041 
                                            hdr_skb = sc->rx.frag; else 
                                                                    
#line 1043 
                                                                    hdr_skb = skb;
    
#line 1045 
    rxs = IEEE80211_SKB_RXCB(hdr_skb);
    
#line 1046 
    memset((void *)rxs,0,40UL);
    
#line 1048 
    retval = ath9k_rx_skb_preprocess(sc,hdr_skb,& rs,rxs,& decrypt_error,tsf);
    
#line 1050 
    if (retval != 0) 
#line 1051 
                     goto requeue_drop_frag; else ;
    
#line 1055 
    requeue_skb = ath_rxbuf_alloc(common,common->rx_bufsize,32U);
    
#line 1061 
    if (requeue_skb == (struct sk_buff *)0) {
      
#line 1062 
      sc->debug.stats.rxstats.rx_oom_err += 1U;
      
#line 1063 
      goto requeue_drop_frag;
    }
    else ;
    
#line 1067 
    new_buf_addr = dma_map_single_attrs(sc->dev,(void *)requeue_skb->data,(unsigned long)common->rx_bufsize,(enum dma_data_direction)dma_type,(struct dma_attrs *)0);
    
#line 1069 
    tmp_0 = dma_mapping_error(sc->dev,new_buf_addr);
    
#line 1069 
    if ((long)(tmp_0 != 0) != 0L) {
      
#line 1070 
      dev_kfree_skb_any(requeue_skb);
      
#line 1071 
      goto requeue_drop_frag;
    }
    else ;
    
#line 1075 
    dma_unmap_single_attrs(sc->dev,bf->bf_buf_addr,(unsigned long)common->rx_bufsize,(enum dma_data_direction)dma_type,(struct dma_attrs *)0);
    
#line 1078 
    bf->bf_mpdu = requeue_skb;
    
#line 1079 
    bf->bf_buf_addr = new_buf_addr;
    
#line 1081 
    skb_put(skb,(unsigned int)((int)rs.rs_datalen + (int)ah->caps.rx_status_len));
    
#line 1082 
    if ((unsigned int)ah->caps.rx_status_len != 0U) 
#line 1083 
                                                    skb_pull(skb,(unsigned int)ah->caps.rx_status_len); else ;
    
#line 1085 
    if ((unsigned int)rs.rs_more == 0U) 
#line 1086 
                                        ath9k_cmn_rx_skb_postprocess(common,hdr_skb,& rs,rxs,(_Bool)((bool)((int)decrypt_error) != 0)); else ;
    
#line 1089 
    if ((unsigned int)rs.rs_more != 0U) {
      
#line 1090 
      sc->debug.stats.rxstats.rx_frags += 1U;
      
#line 1096 
      if (sc->rx.frag != (struct sk_buff *)0) {
        
#line 1098 
        dev_kfree_skb_any(sc->rx.frag);
        
#line 1099 
        dev_kfree_skb_any(skb);
        
#line 1100 
        sc->debug.stats.rxstats.rx_too_many_frags_err += 1U;
        
#line 1101 
        skb = (struct sk_buff *)0;
      }
      else ;
      
#line 1103 
      sc->rx.frag = skb;
      
#line 1104 
      goto requeue;
    }
    else ;
    
#line 1107 
    if (sc->rx.frag != (struct sk_buff *)0) {
      int tmp_1;
      int tmp_2;
      unsigned char *tmp_3;
      
#line 1108 
      tmp_1 = skb_tailroom((struct sk_buff const *)hdr_skb);
      
#line 1108 
      int space = (int)(skb->len - (unsigned int)tmp_1);
      
#line 1110 
      tmp_2 = pskb_expand_head(hdr_skb,0,space,32U);
      
#line 1110 
      if (tmp_2 < 0) {
        
#line 1111 
        consume_skb(skb);
        
#line 1112 
        sc->debug.stats.rxstats.rx_oom_err += 1U;
        
#line 1113 
        goto requeue_drop_frag;
      }
      else ;
      
#line 1116 
      sc->rx.frag = (struct sk_buff *)0;
      
#line 1118 
      ;
      
#line 1118 
      tmp_3 = skb_put(hdr_skb,skb->len);
      
#line 1118 
      ;
      
#line 1118 
      skb_copy_from_linear_data((struct sk_buff const *)skb,(void *)tmp_3,skb->len);
      
#line 1120 
      dev_kfree_skb_any(skb);
      
#line 1121 
      skb = hdr_skb;
    }
    else ;
    
#line 1124 
    if ((rxs->flag & 8U) != 0U) 
#line 1125 
                                skb_trim(skb,skb->len + 4294967288U); else ;
    
#line 1127 
    ldv___ldv_spin_lock_77(& sc->sc_pm_lock);
    
#line 1128 
    if (((unsigned long)sc->ps_flags & 7UL) != 0UL) 
#line 1132 
                                                    ath_rx_ps(sc,skb,(_Bool)((bool)((int)rs.is_mybeacon) != 0));
    else {
      bool tmp_4;
      
#line 1130 
      tmp_4 = ath9k_check_auto_sleep(sc);
      
#line 1130 
      if ((int)tmp_4 != 0) 
#line 1132 
                           ath_rx_ps(sc,skb,(_Bool)((bool)((int)rs.is_mybeacon) != 0)); else ;
    }
    
#line 1133 
    ldv_spin_unlock_irqrestore_78(& sc->sc_pm_lock,flags);
    
#line 1135 
    ath9k_antenna_check(sc,& rs);
    
#line 1136 
    ath9k_apply_ampdu_details(sc,& rs,rxs);
    
#line 1137 
    ath_debug_rate_stats(sc,& rs,skb);
    
#line 1139 
    hdr = (struct ieee80211_hdr *)skb->data;
    
#line 1140 
    tmp_5 = ieee80211_is_ack((unsigned short)((int)hdr->frame_control));
    
#line 1140 
    if (tmp_5 != 0) 
#line 1141 
                    ath_dynack_sample_ack_ts(sc->sc_ah,skb,rs.rs_tstamp); else ;
    
#line 1143 
    ieee80211_rx(hw,skb);
    requeue_drop_frag: 
#line 1145 
    ;
    
#line 1146 
    if (sc->rx.frag != (struct sk_buff *)0) {
      
#line 1147 
      dev_kfree_skb_any(sc->rx.frag);
      
#line 1148 
      sc->rx.frag = (struct sk_buff *)0;
    }
    else ;
    requeue: 
#line 1150 
    ;
    
#line 1151 
    list_add_tail(& bf->list,& sc->rx.rxbuf);
    
#line 1153 
    if (! edma) {
      
#line 1154 
      ath_rx_buf_relink(sc,bf,(_Bool)(flush != 0));
      
#line 1155 
      if (flush == 0) 
#line 1156 
                      ath9k_hw_rxena(ah); else ;
    }
    else 
      
#line 1157 
      if (flush == 0) 
#line 1158 
                      ath_rx_edma_buf_link(sc,qtype); else ;
    
#line 1161 
    tmp_6 = budget;
    
#line 1161 
    budget -= 1U;
    
#line 1161 
    ;
    
#line 1161 
    if (tmp_6 == 0U) 
#line 1162 
                     goto ldv_53736; else ;
  }
  ldv_53737: 
#line 1164 
  ;
  
#line 1020 
  goto ldv_53741;
  ldv_53736: 
#line 1021 
  ;
  
#line 1165 
  if (((unsigned int)ah->imask & 16U) == 0U) {
    
#line 1166 
    ah->imask = (enum ath9k_int)((unsigned int)ah->imask | 48U);
    
#line 1167 
    ath9k_hw_set_interrupts(ah);
  }
  else ;
  
#line 1170 
  __retres = 0;
  
#line 1170 
  return __retres;
}


#line 737  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_recv.c.aux"
static void ldv_spin_lock_bh_72_0(spinlock_t *lock)
{
  
#line 741 
  ldv_spin_model_lock((char *)"chan_lock_of_ath_softc");
  
#line 743 
  spin_lock_bh_1(lock);
  
#line 744 
  return;
}


#line 747  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_recv.c.aux"
static void ldv_spin_unlock_bh_73_0(spinlock_t *lock)
{
  
#line 751 
  ldv_spin_model_unlock((char *)"chan_lock_of_ath_softc");
  
#line 753 
  spin_unlock_bh_1(lock);
  
#line 754 
  return;
}


#line 757  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_recv.c.aux"
static void ldv_spin_lock_bh_74(spinlock_t *lock)
{
  
#line 761 
  ldv_spin_model_lock((char *)"chan_lock_of_ath_softc");
  
#line 763 
  spin_lock_bh_1(lock);
  
#line 764 
  return;
}


#line 767  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_recv.c.aux"
static void ldv_spin_unlock_bh_75(spinlock_t *lock)
{
  
#line 771 
  ldv_spin_model_unlock((char *)"chan_lock_of_ath_softc");
  
#line 773 
  spin_unlock_bh_1(lock);
  
#line 774 
  return;
}


#line 777  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_recv.c.aux"
static void ldv_spin_unlock_bh_76(spinlock_t *lock)
{
  
#line 781 
  ldv_spin_model_unlock((char *)"chan_lock_of_ath_softc");
  
#line 783 
  spin_unlock_bh_1(lock);
  
#line 784 
  return;
}


#line 787  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_recv.c.aux"
static void ldv___ldv_spin_lock_77(spinlock_t *ldv_func_arg1)
{
  
#line 791 
  ldv_spin_model_lock((char *)"sc_pm_lock_of_ath_softc");
  
#line 793 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 794 
  return;
}


#line 797  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_recv.c.aux"
static void ldv_spin_unlock_irqrestore_78(spinlock_t *lock, unsigned long flags)
{
  
#line 801 
  ldv_spin_model_unlock((char *)"sc_pm_lock_of_ath_softc");
  
#line 803 
  spin_unlock_irqrestore_1(lock,flags);
  
#line 804 
  return;
}


#line 314  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(long nr, unsigned long const volatile *addr)
{
  int oldbit;
  
#line 317 
  ldv_inline_asm();
  
#line 323 
  return oldbit;
}


#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void list_add(struct list_head *new, struct list_head *head)
{
  
#line 63 
  __list_add(new,head,head->next);
  
#line 64 
  return;
}


#line 165  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void list_move_tail(struct list_head *list, struct list_head *head)
{
  
#line 168 
  __list_del_entry(list);
  
#line 169 
  list_add_tail(list,head);
  
#line 170 
  return;
}


#line 229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static int list_is_singular(struct list_head const *head)
{
  int tmp_0;
  int tmp;
  
#line 231 
  tmp = list_empty(head);
  
#line 231 
  if (tmp == 0) 
    
#line 231 
    if (head->next == head->prev) 
#line 231 
                                  tmp_0 = 1; else 
#line 231 
                                                  tmp_0 = 0;
  else 
#line 231 
       tmp_0 = 0;
  
#line 231 
  return tmp_0;
}


#line 234  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void __list_cut_position(struct list_head *list, struct list_head *head, struct list_head *entry)
{
  
#line 237 
  struct list_head *new_first = entry->next;
  
#line 238 
  list->next = head->next;
  
#line 239 
  (list->next)->prev = list;
  
#line 240 
  list->prev = entry;
  
#line 241 
  entry->next = list;
  
#line 242 
  head->next = new_first;
  
#line 243 
  new_first->prev = head;
  
#line 244 
  return;
}


#line 260  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void list_cut_position(struct list_head *list, struct list_head *head, struct list_head *entry)
{
  int tmp;
  int tmp_0;
  
#line 263 
  tmp = list_empty((struct list_head const *)head);
  
#line 263 
  if (tmp != 0) 
#line 264 
                goto return_label; else ;
  
#line 265 
  tmp_0 = list_is_singular((struct list_head const *)head);
  
#line 265 
  if (tmp_0 != 0) {
    
#line 265 
    if (head->next != entry && head != entry) 
#line 267 
                                              goto return_label; else ;
  }
  else ;
  
#line 268 
  if (entry == head) 
#line 269 
                     INIT_LIST_HEAD(list); else 
#line 271 
                                                __list_cut_position(list,head,entry);
  return_label: 
#line 272 
                return;
}


#line 274  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void __list_splice(struct list_head const *list, struct list_head *prev, struct list_head *next)
{
  
#line 278 
  struct list_head *first = list->next;
  
#line 279 
  struct list_head *last = list->prev;
  
#line 281 
  first->prev = prev;
  
#line 282 
  prev->next = first;
  
#line 284 
  last->next = next;
  
#line 285 
  next->prev = last;
  
#line 286 
  return;
}


#line 336  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void list_splice_tail_init(struct list_head *list, struct list_head *head)
{
  int tmp;
  
#line 339 
  tmp = list_empty((struct list_head const *)list);
  
#line 339 
  if (tmp == 0) {
    
#line 340 
    __list_splice((struct list_head const *)list,head->prev,head);
    
#line 341 
    INIT_LIST_HEAD(list);
  }
  else ;
  
#line 343 
  return;
}


#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/percpu.h"
void __bad_percpu_size(void);


#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
void *memmove(void *, void const *, size_t);


#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_add(int val)
{
  int tmp;
  
#line 72 
  if (0 != 0 && (val == 1 || val == -1)) 
#line 72 
                                         tmp = val; else 
#line 72 
                                                         tmp = 0;
  
#line 72 
  int const pao_ID__ = tmp;
  
#line 72 
  switch (4UL) {
    case (unsigned long)1: 
#line 72 
    ;
    
#line 72 
    if (pao_ID__ == 1) 
#line 74 
                       ldv_inline_asm();
    else 
      
#line 72 
      if (pao_ID__ == -1) 
#line 74 
                          ldv_inline_asm(); else 
#line 77 
                                                 ldv_inline_asm();
    
#line 72 
    goto ldv_6377;
    case (unsigned long)2: 
#line 72 
    ;
    
#line 72 
    if (pao_ID__ == 1) 
#line 74 
                       ldv_inline_asm();
    else 
      
#line 72 
      if (pao_ID__ == -1) 
#line 74 
                          ldv_inline_asm(); else 
#line 77 
                                                 ldv_inline_asm();
    
#line 72 
    goto ldv_6377;
    case (unsigned long)4: 
#line 72 
    ;
    
#line 72 
    if (pao_ID__ == 1) 
#line 74 
                       ldv_inline_asm();
    else 
      
#line 72 
      if (pao_ID__ == -1) 
#line 74 
                          ldv_inline_asm(); else 
#line 77 
                                                 ldv_inline_asm();
    
#line 72 
    goto ldv_6377;
    case (unsigned long)8: 
#line 72 
    ;
    
#line 72 
    if (pao_ID__ == 1) 
#line 74 
                       ldv_inline_asm();
    else 
      
#line 72 
      if (pao_ID__ == -1) 
#line 74 
                          ldv_inline_asm(); else 
#line 77 
                                                 ldv_inline_asm();
    
#line 72 
    goto ldv_6377;
    default: 
#line 72 
    ;
    
#line 72 
    __bad_percpu_size();
  }
  ldv_6377: 
#line 72 
  ;
  
#line 74 
  return;
}


#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_sub(int val)
{
  int tmp;
  
#line 77 
  if (0 != 0 && (- val == 1 || - val == -1)) 
#line 77 
                                             tmp = - val; else 
#line 77 
                                                               tmp = 0;
  
#line 77 
  int const pao_ID__ = tmp;
  
#line 77 
  switch (4UL) {
    case (unsigned long)1: 
#line 77 
    ;
    
#line 77 
    if (pao_ID__ == 1) 
#line 79 
                       ldv_inline_asm();
    else 
      
#line 77 
      if (pao_ID__ == -1) 
#line 79 
                          ldv_inline_asm(); else 
#line 82 
                                                 ldv_inline_asm();
    
#line 77 
    goto ldv_6389;
    case (unsigned long)2: 
#line 77 
    ;
    
#line 77 
    if (pao_ID__ == 1) 
#line 79 
                       ldv_inline_asm();
    else 
      
#line 77 
      if (pao_ID__ == -1) 
#line 79 
                          ldv_inline_asm(); else 
#line 82 
                                                 ldv_inline_asm();
    
#line 77 
    goto ldv_6389;
    case (unsigned long)4: 
#line 77 
    ;
    
#line 77 
    if (pao_ID__ == 1) 
#line 79 
                       ldv_inline_asm();
    else 
      
#line 77 
      if (pao_ID__ == -1) 
#line 79 
                          ldv_inline_asm(); else 
#line 82 
                                                 ldv_inline_asm();
    
#line 77 
    goto ldv_6389;
    case (unsigned long)8: 
#line 77 
    ;
    
#line 77 
    if (pao_ID__ == 1) 
#line 79 
                       ldv_inline_asm();
    else 
      
#line 77 
      if (pao_ID__ == -1) 
#line 79 
                          ldv_inline_asm(); else 
#line 82 
                                                 ldv_inline_asm();
    
#line 77 
    goto ldv_6389;
    default: 
#line 77 
    ;
    
#line 77 
    __bad_percpu_size();
  }
  ldv_6389: 
#line 77 
  ;
  
#line 79 
  return;
}


#line 333  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
void lock_acquire(struct lockdep_map *, unsigned int, int, int, int, struct lockdep_map *, unsigned long);


#line 337 
void lock_release(struct lockdep_map *, int, unsigned long);


#line 545 
void lockdep_rcu_suspicious(char const *, int const, char const *);


#line 355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_bh_2(spinlock_t *lock)
{
  
#line 357 
  _raw_spin_lock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 358 
  return;
}


#line 383 
static void ldv_spin_lock_bh_72_1(spinlock_t *lock);


#line 387 
static void ldv_spin_lock_bh_75(spinlock_t *lock);


#line 391 
static void ldv_spin_lock_bh_78(spinlock_t *lock);


#line 395 
static void ldv_spin_lock_bh_80(spinlock_t *lock);


#line 399 
static void ldv_spin_lock_bh_83(spinlock_t *lock);


#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_bh_2(spinlock_t *lock)
{
  
#line 406 
  _raw_spin_unlock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 407 
  return;
}


#line 432 
static void ldv_spin_unlock_bh_73_1(spinlock_t *lock);


#line 436 
static void ldv_spin_unlock_bh_74_0(spinlock_t *lock);


#line 440 
static void ldv_spin_unlock_bh_76_0(spinlock_t *lock);


#line 444 
static void ldv_spin_unlock_bh_77(spinlock_t *lock);


#line 448 
static void ldv_spin_unlock_bh_79(spinlock_t *lock);


#line 452 
static void ldv_spin_unlock_bh_81(spinlock_t *lock);


#line 456 
static void ldv_spin_unlock_bh_82(spinlock_t *lock);


#line 460 
static void ldv_spin_unlock_bh_84(spinlock_t *lock);


#line 474  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_irqrestore_2(spinlock_t *lock, unsigned long flags)
{
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
  }
  
#line 476 
  _raw_spin_unlock_irqrestore(& lock->__anonCompField_spinlock_18.rlock,flags);
  
#line 477 
  return;
}


#line 506 
static void ldv_spin_unlock_irqrestore_86(spinlock_t *lock, unsigned long flags);


#line 510 
static void ldv_spin_unlock_irqrestore_88(spinlock_t *lock, unsigned long flags);


#line 70  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_xmit.c.aux"
static void ldv___ldv_spin_lock_85(spinlock_t *ldv_func_arg1);


#line 74 
static void ldv___ldv_spin_lock_87(spinlock_t *ldv_func_arg1);


#line 268  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
__inline static void __rcu_read_lock(void)
{
  
#line 270 
  __preempt_count_add(1);
  
#line 271 
  ldv_inline_asm();
  
#line 272 
  return;
}


#line 273  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
__inline static void __rcu_read_unlock(void)
{
  
#line 275 
  ldv_inline_asm();
  
#line 275 
  __preempt_count_sub(1);
  
#line 276 
  return;
}


#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcutree.h"
bool rcu_is_watching(void);


#line 447  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
__inline static void rcu_lock_acquire(struct lockdep_map *map)
{
  __here_0: 
#line 449 
  ;
  
#line 449 
  ;
  
#line 449 
  lock_acquire(map,0U,0,2,0,(struct lockdep_map *)0,(unsigned long)((void *)0));
  
#line 451 
  return;
}


#line 452  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
__inline static void rcu_lock_release(struct lockdep_map *map)
{
  __here_0: 
#line 454 
  ;
  
#line 454 
  ;
  
#line 454 
  lock_release(map,1,(unsigned long)((void *)0));
  
#line 456 
  return;
}


#line 457 
extern struct lockdep_map rcu_lock_map;


#line 461 
int debug_lockdep_rcu_enabled(void);


#line 843  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
__inline static void rcu_read_lock(void)
{
  
#line 845 
  __rcu_read_lock();
  
#line 847 
  rcu_lock_acquire(& rcu_lock_map);
  {
    bool __warned;
    int tmp;
    
#line 848 
    tmp = debug_lockdep_rcu_enabled();
    
#line 848 
    if (tmp != 0) {
      
#line 848 
      if (! __warned) {
        int tmp_1;
        bool tmp_0;
        
#line 848 
        tmp_0 = rcu_is_watching();
        
#line 848 
        if (tmp_0) 
#line 848 
                   tmp_1 = 0; else 
#line 848 
                                   tmp_1 = 1;
        
#line 848 
        if (tmp_1) {
          
#line 848 
          __warned = (_Bool)1;
          
#line 848 
          lockdep_rcu_suspicious("include/linux/rcupdate.h",849,"rcu_read_lock() used illegally while idle");
        }
        else ;
      }
      else ;
    }
    else ;
  }
  
#line 851 
  return;
}


#line 897  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
__inline static void rcu_read_unlock(void)
{
  {
    bool __warned;
    int tmp;
    
#line 899 
    tmp = debug_lockdep_rcu_enabled();
    
#line 899 
    if (tmp != 0) {
      
#line 899 
      if (! __warned) {
        int tmp_1;
        bool tmp_0;
        
#line 899 
        tmp_0 = rcu_is_watching();
        
#line 899 
        if (tmp_0) 
#line 899 
                   tmp_1 = 0; else 
#line 899 
                                   tmp_1 = 1;
        
#line 899 
        if (tmp_1) {
          
#line 899 
          __warned = (_Bool)1;
          
#line 899 
          lockdep_rcu_suspicious("include/linux/rcupdate.h",900,"rcu_read_unlock() used illegally while idle");
        }
        else ;
      }
      else ;
    }
    else ;
  }
  
#line 902 
  __rcu_read_unlock();
  
#line 903 
  rcu_lock_release(& rcu_lock_map);
  
#line 904 
  return;
}


#line 1011  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int skb_queue_empty(struct sk_buff_head const *list)
{
  int __retres;
  
#line 1013 
  __retres = (struct sk_buff const *)list->next == (struct sk_buff const *)list;
  
#line 1013 
  return __retres;
}


#line 1376  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void __skb_queue_splice(struct sk_buff_head const *list, struct sk_buff *prev, struct sk_buff *next)
{
  
#line 1380 
  struct sk_buff *first = list->next;
  
#line 1381 
  struct sk_buff *last = list->prev;
  
#line 1383 
  first->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.prev = prev;
  
#line 1384 
  prev->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.next = first;
  
#line 1386 
  last->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.next = next;
  
#line 1387 
  next->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.prev = last;
  
#line 1388 
  return;
}


#line 1411  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_queue_splice_init(struct sk_buff_head *list, struct sk_buff_head *head)
{
  int tmp;
  
#line 1414 
  tmp = skb_queue_empty((struct sk_buff_head const *)list);
  
#line 1414 
  if (tmp == 0) {
    
#line 1415 
    __skb_queue_splice((struct sk_buff_head const *)list,(struct sk_buff *)head,head->next);
    
#line 1416 
    head->qlen += list->qlen;
    
#line 1417 
    __skb_queue_head_init(list);
  }
  else ;
  
#line 1419 
  return;
}


#line 1426  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_queue_splice_tail(struct sk_buff_head const *list, struct sk_buff_head *head)
{
  int tmp;
  
#line 1429 
  tmp = skb_queue_empty(list);
  
#line 1429 
  if (tmp == 0) {
    
#line 1430 
    __skb_queue_splice(list,head->prev,(struct sk_buff *)head);
    
#line 1431 
    head->qlen += list->qlen;
  }
  else ;
  
#line 1433 
  return;
}


#line 1698 
unsigned char *skb_push(struct sk_buff *, unsigned int);


#line 1750  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned int skb_headroom(struct sk_buff const *skb)
{
  unsigned int __retres;
  
#line 1752 
  __retres = (unsigned int)((long)skb->data - (long)skb->head);
  
#line 1752 
  return __retres;
}


#line 3295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static u16 skb_get_queue_mapping(struct sk_buff const *skb)
{
  u16 __retres;
  
#line 3297 
  __retres = skb->queue_mapping;
  
#line 3297 
  return __retres;
}


#line 443  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
__inline static int ieee80211_is_probe_resp(__le16 fc)
{
  int __retres;
  
#line 445 
  __retres = ((int)fc & 252) == 80;
  
#line 445 
  return __retres;
}


#line 453  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
__inline static int ieee80211_is_beacon(__le16 fc)
{
  int __retres;
  
#line 455 
  __retres = ((int)fc & 252) == 128;
  
#line 455 
  return __retres;
}


#line 463  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
__inline static int ieee80211_is_atim(__le16 fc)
{
  int __retres;
  
#line 465 
  __retres = ((int)fc & 252) == 144;
  
#line 465 
  return __retres;
}


#line 533  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
__inline static int ieee80211_is_pspoll(__le16 fc)
{
  int __retres;
  
#line 535 
  __retres = ((int)fc & 252) == 164;
  
#line 535 
  return __retres;
}


#line 3689  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
unsigned int ieee80211_hdrlen(__le16);


#line 2157  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
__inline static struct ieee80211_rate *ieee80211_get_rts_cts_rate(struct ieee80211_hw const *hw, struct ieee80211_tx_info const *c)
{
  struct ieee80211_rate *__retres;
  
#line 2160 
  if ((int)c->__anonCompField_ieee80211_tx_info_98.control.__anonCompField___anonstruct_control_358_96.__anonCompField___anonunion_359_95.rts_cts_rate_idx < 0) {
    
#line 2161 
    __retres = (struct ieee80211_rate *)0;
    
#line 2161 
    goto return_label;
  }
  else ;
  
#line 2162 
  __retres = ((hw->wiphy)->bands[(int)c->band])->bitrates + (int)c->__anonCompField_ieee80211_tx_info_98.control.__anonCompField___anonstruct_control_358_96.__anonCompField___anonunion_359_95.rts_cts_rate_idx;
  return_label: 
#line 2162 
                return __retres;
}


#line 2182 
void ieee80211_free_txskb(struct ieee80211_hw *, struct sk_buff *);


#line 3850 
void ieee80211_sta_set_buffered(struct ieee80211_sta *, u8, bool);


#line 3866 
void ieee80211_get_tx_rates(struct ieee80211_vif *, struct ieee80211_sta *, struct sk_buff *, struct ieee80211_tx_rate *, int);


#line 3888 
void ieee80211_tx_status(struct ieee80211_hw *, struct sk_buff *);


#line 4466 
void ieee80211_wake_queue(struct ieee80211_hw *, int);


#line 4475 
void ieee80211_stop_queue(struct ieee80211_hw *, int);


#line 4772 
struct ieee80211_sta *ieee80211_find_sta_by_ifaddr(struct ieee80211_hw *, u8 const *, u8 const *);


#line 4827 
void ieee80211_sta_eosp(struct ieee80211_sta *);


#line 5042 
void ieee80211_send_bar(struct ieee80211_vif *, u8 *, u16, u16);


#line 714  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mac.h"
u32 ath9k_hw_gettxbuf(struct ath_hw *, u32);


#line 720 
void ath9k_hw_abort_tx_dma(struct ath_hw *);


#line 725 
int ath9k_hw_setuptxqueue(struct ath_hw *, enum ath9k_tx_queue, struct ath9k_tx_queue_info const *);


#line 727 
bool ath9k_hw_releasetxqueue(struct ath_hw *, u32);


#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/dynack.h"
void ath_dynack_sample_tx_ts(struct ath_hw *, struct sk_buff *, struct ath_tx_status *);


#line 1038  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
u16 ath9k_hw_computetxtime(struct ath_hw *, u8, int, u32, u16, bool);


#line 1149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
__inline static bool ath9k_hw_btcoex_is_enabled(struct ath_hw *ah)
{
  bool __retres;
  
#line 1151 
  __retres = ah->btcoex_hw.enabled;
  
#line 1151 
  return __retres;
}


#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw-ops.h"
__inline static void ath9k_hw_set_desc_link(struct ath_hw *ah, void *ds, u32 link)
{
  struct ath_hw_ops *tmp;
  
#line 41 
  tmp = ath9k_hw_ops(ah);
  
#line 41 
  (*(tmp->set_desc_link))(ds,link);
  
#line 42 
  return;
}


#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw-ops.h"
__inline static int ath9k_hw_txprocdesc(struct ath_hw *ah, void *ds, struct ath_tx_status *ts)
{
  int tmp_0;
  struct ath_hw_ops *tmp;
  
#line 66 
  tmp = ath9k_hw_ops(ah);
  
#line 66 
  tmp_0 = (*(tmp->proc_txdesc))(ah,ds,ts);
  
#line 66 
  return tmp_0;
}


#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw-ops.h"
__inline static int ath9k_hw_get_duration(struct ath_hw *ah, void const *ds, int index)
{
  int tmp_0;
  struct ath_hw_ops *tmp;
  
#line 72 
  tmp = ath9k_hw_ops(ah);
  
#line 72 
  tmp_0 = (*(tmp->get_duration))(ah,ds,index);
  
#line 72 
  return tmp_0;
}


#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw-ops.h"
__inline static void ath9k_hw_tx99_start(struct ath_hw *ah, u32 qnum)
{
  struct ath_hw_ops *tmp;
  
#line 89 
  tmp = ath9k_hw_ops(ah);
  
#line 89 
  (*(tmp->tx99_start))(ah,qnum);
  
#line 90 
  return;
}


#line 82  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/common.h"
int ath9k_cmn_get_hw_crypto_keytype(struct sk_buff *);


#line 253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.h"
void ath_debug_stat_tx(struct ath_softc *sc, struct ath_buf *bf, struct ath_tx_status *ts, struct ath_txq *txq, unsigned int flags);


#line 555  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
void ath_txq_lock(struct ath_softc *sc, struct ath_txq *txq);


#line 556 
void ath_txq_unlock(struct ath_softc *sc, struct ath_txq *txq);


#line 557 
void ath_txq_unlock_complete(struct ath_softc *sc, struct ath_txq *txq);


#line 559 
bool ath_drain_all_txq(struct ath_softc *sc);


#line 561 
void ath_tx_node_init(struct ath_softc *sc, struct ath_node *an);


#line 562 
void ath_tx_node_cleanup(struct ath_softc *sc, struct ath_node *an);


#line 563 
void ath_txq_schedule(struct ath_softc *sc, struct ath_txq *txq);


#line 564 
void ath_txq_schedule_all(struct ath_softc *sc);


#line 566 
int ath_txq_update(struct ath_softc *sc, int qnum, struct ath9k_tx_queue_info *qinfo);


#line 568 
void ath_update_max_aggr_framelen(struct ath_softc *sc, int queue, int txop);


#line 570 
int ath_tx_start(struct ieee80211_hw *hw, struct sk_buff *skb, struct ath_tx_control *txctl);


#line 574 
void ath_tx_tasklet(struct ath_softc *sc);


#line 575 
void ath_tx_edma_tasklet(struct ath_softc *sc);


#line 576 
int ath_tx_aggr_start(struct ath_softc *sc, struct ieee80211_sta *sta, u16 tid, u16 *ssn);


#line 578 
void ath_tx_aggr_stop(struct ath_softc *sc, struct ieee80211_sta *sta, u16 tid);


#line 579 
void ath_tx_aggr_resume(struct ath_softc *sc, struct ieee80211_sta *sta, u16 tidno);


#line 581 
void ath_tx_aggr_wakeup(struct ath_softc *sc, struct ath_node *an);


#line 582 
void ath_tx_aggr_sleep(struct ieee80211_sta *sta, struct ath_softc *sc, struct ath_node *an);


#line 584 
void ath9k_release_buffered_frames(struct ieee80211_hw *hw, struct ieee80211_sta *sta, u16 tids, int nframes, enum ieee80211_frame_release_type reason, bool more_data);


#line 711 
void ath_tx_complete_poll_work(struct work_struct *work);


#line 768 
u16 ath9k_btcoex_aggr_limit(struct ath_softc *sc, u32 max_4ms_framelen);


#line 1052 
int ath9k_tx99_send(struct ath_softc *sc, struct sk_buff *skb, struct ath_tx_control *txctl);


#line 1073 
u8 ath9k_parse_mpdudensity(u8 mpdudensity);


#line 120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ar9003_mac.h"
void ath9k_hw_setup_statusring(struct ath_hw *, void *, u32, u16);


#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static u16 bits_per_symbol[8U][2U] = {{(unsigned short)26U, (unsigned short)54U}, {(unsigned short)52U, (unsigned short)108U}, {(unsigned short)78U, (unsigned short)162U}, {(unsigned short)104U, (unsigned short)216U}, {(unsigned short)156U, (unsigned short)324U}, {(unsigned short)208U, (unsigned short)432U}, {(unsigned short)234U, (unsigned short)486U}, {(unsigned short)260U, (unsigned short)540U}};

#line 50 
static void ath_tx_send_normal(struct ath_softc *sc, struct ath_txq *txq, struct ath_atx_tid *tid, struct sk_buff *skb);


#line 52 
static void ath_tx_complete(struct ath_softc *sc, struct sk_buff *skb, int tx_flags, struct ath_txq *txq);


#line 54 
static void ath_tx_complete_buf(struct ath_softc *sc, struct ath_buf *bf, struct ath_txq *txq, struct list_head *bf_q, struct ath_tx_status *ts, int txok);


#line 57 
static void ath_tx_txqaddbuf(struct ath_softc *sc, struct ath_txq *txq, struct list_head *head, bool internal);


#line 59 
static void ath_tx_rc_status(struct ath_softc *sc, struct ath_buf *bf, struct ath_tx_status *ts, int nframes, int nbad, int txok);


#line 62 
static void ath_tx_update_baw(struct ath_softc *sc, struct ath_atx_tid *tid, int seqno);


#line 64 
static struct ath_buf *ath_tx_setup_buffer(struct ath_softc *sc, struct ath_txq *txq, struct ath_atx_tid *tid, struct sk_buff *skb);


#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
void ath_txq_lock(struct ath_softc *sc, struct ath_txq *txq)
{
  
#line 83 
  ldv_spin_lock_bh_72_1(& txq->axq_lock);
  
#line 84 
  return;
}


#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
void ath_txq_unlock(struct ath_softc *sc, struct ath_txq *txq)
{
  
#line 89 
  ldv_spin_unlock_bh_73_1(& txq->axq_lock);
  
#line 90 
  return;
}


#line 92  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
void ath_txq_unlock_complete(struct ath_softc *sc, struct ath_txq *txq)
{
  struct sk_buff_head q;
  struct sk_buff *skb;
  
#line 98 
  __skb_queue_head_init(& q);
  
#line 99 
  skb_queue_splice_init(& txq->complete_q,& q);
  
#line 100 
  ldv_spin_unlock_bh_74_0(& txq->axq_lock);
  
#line 102 
  goto ldv_53552;
  ldv_53551: 
#line 103 
  ;
  
#line 103 
  ieee80211_tx_status(sc->hw,skb);
  ldv_53552: 
#line 104 
  ;
  
#line 102 
  skb = __skb_dequeue(& q);
  
#line 102 
  if (skb != (struct sk_buff *)0) 
#line 104 
                                  goto ldv_53551; else 
#line 107 
                                                       goto ldv_53553;
  ldv_53553: 
#line 108 
  ;
  
#line 109 
  return;
}


#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static void ath_tx_queue_tid(struct ath_softc *sc, struct ath_txq *txq, struct ath_atx_tid *tid)
{
  struct list_head *list;
  int tmp_0;
  
#line 109 
  struct ath_atx_ac *ac = tid->ac;
  
#line 111 
  struct ath_vif *avp = (struct ath_vif *)(& ((tid->an)->vif)->drv_priv);
  
#line 112 
  struct ath_chanctx *ctx = avp->chanctx;
  
#line 114 
  if (ctx == (struct ath_chanctx *)0) 
#line 115 
                                      goto return_label; else ;
  
#line 117 
  if ((int)tid->sched != 0) 
#line 118 
                            goto return_label; else ;
  
#line 120 
  tid->sched = (_Bool)1;
  
#line 121 
  list_add_tail(& tid->list,& ac->tid_q);
  
#line 123 
  if ((int)ac->sched != 0) 
#line 124 
                           goto return_label; else ;
  
#line 126 
  ac->sched = (_Bool)1;
  
#line 128 
  if ((unsigned int)tid->tidno != 0U && (unsigned int)tid->tidno != 3U) {
    int tmp;
    
#line 128 
    if ((unsigned int)tid->tidno + 255U > 1U) 
#line 128 
                                              tmp = (unsigned int)tid->tidno + 252U <= 1U; else 
                                                                    
#line 128 
                                                                    tmp = 3;
    
#line 128 
    tmp_0 = tmp;
  }
  else 
#line 128 
       tmp_0 = 2;
  
#line 128 
  list = & ctx->acq[tmp_0];
  
#line 129 
  list_add_tail(& ac->list,list);
  return_label: 
#line 130 
                return;
}


#line 135 
void __compiletime_assert_136(void);


#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static struct ath_frame_info *get_frame_info(struct sk_buff *skb)
{
  struct ath_frame_info *__retres;
  
#line 134 
  struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
  {
    
#line 135 
    bool __cond = (_Bool)0;
    
#line 135 
    if ((int)__cond != 0) 
#line 135 
                          __compiletime_assert_136(); else ;
  }
  
#line 137 
  __retres = (struct ath_frame_info *)(& tx_info->__anonCompField_ieee80211_tx_info_98.__anonCompField___anonunion_357_97.rate_driver_data[0]);
  
#line 137 
  return __retres;
}


#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static void ath_send_bar(struct ath_atx_tid *tid, u16 seqno)
{
  
#line 142 
  if ((tid->an)->sta == (struct ieee80211_sta *)0) 
#line 143 
                                                   goto return_label; else ;
  
#line 145 
  ieee80211_send_bar((tid->an)->vif,(u8 *)(& ((tid->an)->sta)->addr),(unsigned short)((int)tid->tidno),(unsigned short)((int)seqno << 4U));
  return_label: 
#line 147 
                return;
}


#line 149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static void ath_set_rates(struct ieee80211_vif *vif, struct ieee80211_sta *sta, struct ath_buf *bf)
{
  
#line 152 
  ieee80211_get_tx_rates(vif,sta,bf->bf_mpdu,(struct ieee80211_tx_rate *)(& bf->rates),4);
  
#line 153 
  return;
}


#line 156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static void ath_txq_skb_done(struct ath_softc *sc, struct ath_txq *txq, struct sk_buff *skb)
{
  int tmp_1;
  
#line 159 
  struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
  
#line 160 
  struct ath_frame_info *fi = get_frame_info(skb);
  
#line 161 
  int q = (int)fi->txq;
  
#line 163 
  if (q < 0) 
#line 164 
             goto return_label; else ;
  
#line 166 
  txq = sc->tx.txq_map[q];
  {
    
#line 167 
    txq->pending_frames -= 1;
    
#line 167 
    int __ret_warn_on = txq->pending_frames < 0;
    
#line 167 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 167 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c",167); else ;
    
#line 167 
    tmp_1 = (long)(__ret_warn_on != 0);
  }
  
#line 167 
  if ((long)tmp_1 != 0L) 
#line 168 
                         txq->pending_frames = 0; else ;
  
#line 170 
  if ((int)txq->stopped != 0 && (unsigned int)txq->pending_frames < sc->tx.txq_max_pending[q]) {
    bool tmp_2;
    
#line 172 
    tmp_2 = ath9k_is_chanctx_enabled();
    
#line 172 
    if ((int)tmp_2 != 0) 
#line 173 
                         ieee80211_wake_queue(sc->hw,(int)info->hw_queue); else 
                                                                    
#line 175 
                                                                    ieee80211_wake_queue(sc->hw,q);
    
#line 176 
    txq->stopped = (_Bool)0;
  }
  else ;
  return_label: 
#line 178 
                return;
}


#line 181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static struct ath_atx_tid *ath_get_skb_tid(struct ath_softc *sc, struct ath_node *an, struct sk_buff *skb)
{
  struct ath_atx_tid *__retres;
  
#line 183 
  u8 tidno = (unsigned char)((unsigned int)((unsigned char)skb->priority) & 15U);
  
#line 184 
  __retres = & an->tid[(int)tidno];
  
#line 184 
  return __retres;
}


#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static bool ath_tid_has_buffered(struct ath_atx_tid *tid)
{
  bool __retres;
  int tmp_1;
  int tmp;
  
#line 189 
  tmp = skb_queue_empty((struct sk_buff_head const *)(& tid->buf_q));
  
#line 189 
  if (tmp == 0) 
#line 189 
                tmp_1 = 1;
  else {
    int tmp_0;
    
#line 189 
    tmp_0 = skb_queue_empty((struct sk_buff_head const *)(& tid->retry_q));
    
#line 189 
    if (tmp_0 == 0) 
#line 189 
                    tmp_1 = 1; else 
#line 189 
                                    tmp_1 = 0;
  }
  
#line 189 
  __retres = (_Bool)(tmp_1 != 0);
  
#line 189 
  return __retres;
}


#line 192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static struct sk_buff *ath_tid_dequeue(struct ath_atx_tid *tid)
{
  struct sk_buff *skb;
  
#line 196 
  skb = __skb_dequeue(& tid->retry_q);
  
#line 197 
  if (skb == (struct sk_buff *)0) 
#line 198 
                                  skb = __skb_dequeue(& tid->buf_q); else ;
  
#line 200 
  return skb;
}


#line 209  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static void ath_tx_tid_change_state(struct ath_softc *sc, struct ath_atx_tid *tid)
{
  struct ieee80211_tx_info *tx_info;
  struct sk_buff *skb;
  struct sk_buff *tskb;
  struct ath_buf *bf;
  struct ath_frame_info *fi;
  
#line 211 
  struct ath_txq *txq = (tid->ac)->txq;
  
#line 217 
  skb = tid->buf_q.next;
  
#line 217 
  tskb = skb->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.next;
  
#line 217 
  goto ldv_53618;
  ldv_53617: 
#line 218 
  ;
  
#line 218 
  fi = get_frame_info(skb);
  
#line 219 
  bf = fi->bf;
  
#line 221 
  tx_info = IEEE80211_SKB_CB(skb);
  
#line 222 
  tx_info->flags &= 4294967231U;
  
#line 224 
  if (bf != (struct ath_buf *)0) 
#line 225 
                                 goto ldv_53616; else ;
  
#line 227 
  bf = ath_tx_setup_buffer(sc,txq,tid,skb);
  
#line 228 
  if (bf == (struct ath_buf *)0) {
    
#line 229 
    __skb_unlink(skb,& tid->buf_q);
    
#line 230 
    ath_txq_skb_done(sc,txq,skb);
    
#line 231 
    ieee80211_free_txskb(sc->hw,skb);
    
#line 232 
    goto ldv_53616;
  }
  else ;
  ldv_53616: 
#line 234 
  ;
  
#line 217 
  skb = tskb;
  
#line 217 
  tskb = skb->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.next;
  ldv_53618: 
#line 218 
  ;
  
#line 217 
  if ((struct sk_buff *)(& tid->buf_q) != skb) 
#line 219 
                                               goto ldv_53617; else 
#line 222 
                                                                    goto ldv_53619;
  ldv_53619: 
#line 223 
  ;
  
#line 224 
  return;
}


#line 238  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static void ath_tx_flush_tid(struct ath_softc *sc, struct ath_atx_tid *tid)
{
  struct sk_buff *skb;
  struct ath_buf *bf;
  struct list_head bf_head;
  struct ath_tx_status ts;
  struct ath_frame_info *fi;
  
#line 240 
  struct ath_txq *txq = (tid->ac)->txq;
  
#line 246 
  bool sendbar = (_Bool)0;
  
#line 248 
  INIT_LIST_HEAD(& bf_head);
  
#line 250 
  memset((void *)(& ts),0,48UL);
  
#line 252 
  goto ldv_53631;
  ldv_53632: 
#line 253 
  ;
  
#line 253 
  fi = get_frame_info(skb);
  
#line 254 
  bf = fi->bf;
  
#line 255 
  if (bf == (struct ath_buf *)0) {
    
#line 256 
    ath_txq_skb_done(sc,txq,skb);
    
#line 257 
    ieee80211_free_txskb(sc->hw,skb);
    
#line 258 
    goto ldv_53631;
  }
  else ;
  
#line 261 
  if ((unsigned int)*((unsigned char *)fi + 13UL) != 0U) {
    
#line 262 
    ath_tx_update_baw(sc,tid,(int)bf->bf_state.seqno);
    
#line 263 
    sendbar = (_Bool)1;
  }
  else ;
  
#line 266 
  list_add_tail(& bf->list,& bf_head);
  
#line 267 
  ath_tx_complete_buf(sc,bf,txq,& bf_head,& ts,0);
  ldv_53631: 
#line 268 
  ;
  
#line 252 
  skb = __skb_dequeue(& tid->retry_q);
  
#line 252 
  if (skb != (struct sk_buff *)0) 
#line 254 
                                  goto ldv_53632; else 
#line 257 
                                                       goto ldv_53633;
  ldv_53633: 
#line 258 
  ;
  
#line 270 
  if ((int)sendbar != 0) {
    
#line 271 
    ath_txq_unlock(sc,txq);
    
#line 272 
    ath_send_bar(tid,(unsigned short)((int)tid->seq_start));
    
#line 273 
    ath_txq_lock(sc,txq);
  }
  else ;
  
#line 275 
  return;
}


#line 277  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static void ath_tx_update_baw(struct ath_softc *sc, struct ath_atx_tid *tid, int seqno)
{
  int index;
  int cindex;
  
#line 282 
  index = (seqno - (int)tid->seq_start) & 4095;
  
#line 283 
  cindex = (tid->baw_head + index) & 127;
  
#line 285 
  __set_bit((long)cindex,(unsigned long volatile *)(& tid->tx_buf));
  
#line 287 
  goto ldv_53642;
  ldv_53641: 
#line 288 
  ;
  
#line 288 
  tid->seq_start = (u16)((int)tid->seq_start + 1);
  
#line 288 
  tid->seq_start = (unsigned short)((unsigned int)tid->seq_start & 4095U);
  
#line 289 
  tid->baw_head += 1;
  
#line 289 
  tid->baw_head &= 127;
  
#line 290 
  if ((int)tid->bar_index >= 0) 
#line 291 
                                tid->bar_index = (s8)((int)tid->bar_index - 1); else ;
  ldv_53642: 
#line 292 
  ;
  
#line 287 
  if (tid->baw_head != tid->baw_tail) {
    int tmp_1;
    
#line 287 
    if (0 != 0) {
      int tmp;
      
#line 287 
      tmp = constant_test_bit((long)tid->baw_head,(unsigned long const volatile *)(& tid->tx_buf));
      
#line 287 
      tmp_1 = tmp == 0;
    }
    else {
      int tmp_0;
      
#line 287 
      tmp_0 = variable_test_bit((long)tid->baw_head,(unsigned long const volatile *)(& tid->tx_buf));
      
#line 287 
      tmp_1 = tmp_0 == 0;
    }
    
#line 287 
    if (tmp_1) 
#line 289 
               goto ldv_53641; else 
#line 292 
                                    goto ldv_53643;
  }
  else 
#line 292 
       goto ldv_53643;
  ldv_53643: 
#line 293 
  ;
  
#line 294 
  return;
}


#line 295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static void ath_tx_addto_baw(struct ath_softc *sc, struct ath_atx_tid *tid, struct ath_buf *bf)
{
  int index;
  int cindex;
  
#line 298 
  struct ath_frame_info *fi = get_frame_info(bf->bf_mpdu);
  
#line 299 
  u16 seqno = bf->bf_state.seqno;
  
#line 302 
  index = ((int)seqno - (int)tid->seq_start) & 4095;
  
#line 303 
  cindex = (tid->baw_head + index) & 127;
  
#line 304 
  __set_bit((long)cindex,(unsigned long volatile *)(& tid->tx_buf));
  
#line 305 
  fi->baw_tracked = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U;
  
#line 307 
  if (((tid->baw_tail - tid->baw_head) & 127) <= index) {
    
#line 309 
    tid->baw_tail = cindex;
    
#line 310 
    tid->baw_tail += 1;
    
#line 310 
    tid->baw_tail &= 127;
  }
  else ;
  
#line 312 
  return;
}


#line 314  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static void ath_tid_drain(struct ath_softc *sc, struct ath_txq *txq, struct ath_atx_tid *tid)
{
  struct sk_buff *skb;
  struct ath_buf *bf;
  struct list_head bf_head;
  struct ath_tx_status ts;
  struct ath_frame_info *fi;
  
#line 324 
  memset((void *)(& ts),0,48UL);
  
#line 325 
  INIT_LIST_HEAD(& bf_head);
  
#line 327 
  goto ldv_53663;
  ldv_53664: 
#line 328 
  ;
  
#line 328 
  fi = get_frame_info(skb);
  
#line 329 
  bf = fi->bf;
  
#line 331 
  if (bf == (struct ath_buf *)0) {
    
#line 332 
    ath_tx_complete(sc,skb,1,txq);
    
#line 333 
    goto ldv_53663;
  }
  else ;
  
#line 336 
  list_add_tail(& bf->list,& bf_head);
  
#line 337 
  ath_tx_complete_buf(sc,bf,txq,& bf_head,& ts,0);
  ldv_53663: 
#line 338 
  ;
  
#line 327 
  skb = ath_tid_dequeue(tid);
  
#line 327 
  if (skb != (struct sk_buff *)0) 
#line 329 
                                  goto ldv_53664; else 
#line 332 
                                                       goto ldv_53665;
  ldv_53665: 
#line 333 
  ;
  
#line 334 
  return;
}


#line 341  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static void ath_tx_set_retry(struct ath_softc *sc, struct ath_txq *txq, struct sk_buff *skb, int count)
{
  struct ieee80211_hdr *hdr;
  
#line 344 
  struct ath_frame_info *fi = get_frame_info(skb);
  
#line 345 
  struct ath_buf *bf = fi->bf;
  
#line 347 
  int prev = (int)fi->retries;
  
#line 349 
  sc->debug.stats.txstats[txq->axq_qnum].a_retries += 1U;
  
#line 350 
  fi->retries = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(7))))((int)((unsigned char)fi->retries) + (int)((unsigned char)count));
  
#line 352 
  if (prev > 0) 
#line 353 
                goto return_label; else ;
  
#line 355 
  hdr = (struct ieee80211_hdr *)skb->data;
  
#line 356 
  hdr->frame_control = (unsigned short)((unsigned int)hdr->frame_control | 2048U);
  
#line 357 
  dma_sync_single_for_device(sc->dev,bf->bf_buf_addr,30UL,(enum dma_data_direction)DMA_TO_DEVICE);
  return_label: 
#line 358 
                return;
}


#line 361  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static struct ath_buf *ath_tx_get_buffer(struct ath_softc *sc)
{
  struct ath_buf *__retres;
  int tmp;
  struct ath_buf *tmp_0;
  
#line 363 
  struct ath_buf *bf = (struct ath_buf *)0;
  
#line 365 
  ldv_spin_lock_bh_75(& sc->tx.txbuflock);
  
#line 367 
  tmp = list_empty((struct list_head const *)(& sc->tx.txbuf));
  
#line 367 
  if ((long)(tmp != 0) != 0L) {
    
#line 368 
    ldv_spin_unlock_bh_76_0(& sc->tx.txbuflock);
    
#line 369 
    __retres = (struct ath_buf *)0;
    
#line 369 
    goto return_label;
  }
  else ;
  {
    
#line 372 
    struct list_head const *__mptr = (struct list_head const *)sc->tx.txbuf.next;
    
#line 372 
    tmp_0 = (struct ath_buf *)__mptr;
  }
  
#line 372 
  bf = tmp_0;
  
#line 373 
  list_del(& bf->list);
  
#line 375 
  ldv_spin_unlock_bh_77(& sc->tx.txbuflock);
  
#line 377 
  __retres = bf;
  return_label: 
#line 377 
                return __retres;
}


#line 380  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static void ath_tx_return_buffer(struct ath_softc *sc, struct ath_buf *bf)
{
  
#line 382 
  ldv_spin_lock_bh_78(& sc->tx.txbuflock);
  
#line 383 
  list_add_tail(& bf->list,& sc->tx.txbuf);
  
#line 384 
  ldv_spin_unlock_bh_79(& sc->tx.txbuflock);
  
#line 385 
  return;
}


#line 387  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static struct ath_buf *ath_clone_txbuf(struct ath_softc *sc, struct ath_buf *bf)
{
  struct ath_buf *__retres;
  struct ath_buf *tbf;
  int tmp;
  
#line 391 
  tbf = ath_tx_get_buffer(sc);
  {
    
#line 392 
    int __ret_warn_on = tbf == (struct ath_buf *)0;
    
#line 392 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 392 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c",392); else ;
    
#line 392 
    tmp = (long)(__ret_warn_on != 0);
  }
  
#line 392 
  if ((long)tmp != 0L) {
    
#line 393 
    __retres = (struct ath_buf *)0;
    
#line 393 
    goto return_label;
  }
  else ;
  
#line 395 
  tbf->bf_lastbf = (struct ath_buf *)0;
  
#line 395 
  tbf->bf_next = (struct ath_buf *)0;
  
#line 395 
  memset((void *)(& tbf->bf_state),0,16UL);
  
#line 397 
  tbf->bf_mpdu = bf->bf_mpdu;
  
#line 398 
  tbf->bf_buf_addr = bf->bf_buf_addr;
  
#line 399 
  memcpy(tbf->bf_desc,(void const *)bf->bf_desc,(unsigned long)(sc->sc_ah)->caps.tx_desc_len);
  
#line 400 
  tbf->bf_state = bf->bf_state;
  
#line 401 
  tbf->bf_state.stale = (_Bool)0;
  
#line 403 
  __retres = tbf;
  return_label: 
#line 403 
                return __retres;
}


#line 406  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static void ath_tx_count_frames(struct ath_softc *sc, struct ath_buf *bf, struct ath_tx_status *ts, int txok, int *nframes, int *nbad)
{
  struct ath_frame_info *fi;
  u32 ba[2U];
  int ba_index;
  
#line 411 
  u16 seq_st = (unsigned short)0U;
  
#line 414 
  int isaggr = 0;
  
#line 416 
  *nbad = 0;
  
#line 417 
  *nframes = 0;
  
#line 419 
  isaggr = (int)bf->bf_state.bf_type & 2;
  
#line 420 
  if (isaggr != 0) {
    
#line 421 
    seq_st = ts->ts_seqnum;
    
#line 422 
    memcpy((void *)(& ba),(void const *)(& ts->ba_low),8UL);
  }
  else ;
  
#line 425 
  goto ldv_53707;
  ldv_53706: 
#line 426 
  ;
  
#line 426 
  fi = get_frame_info(bf->bf_mpdu);
  
#line 427 
  ba_index = ((int)bf->bf_state.seqno - (int)seq_st) & 4095;
  
#line 429 
  *nframes += 1;
  
#line 430 
  if (txok == 0 || (isaggr != 0 && (ba_index > 63 || (ba[ba_index >> 5] & (unsigned int)(1 << (ba_index & 31))) == 0U))) 
    
#line 431 
    *nbad += 1; else ;
  
#line 433 
  bf = bf->bf_next;
  ldv_53707: 
#line 434 
  ;
  
#line 425 
  if (bf != (struct ath_buf *)0) 
#line 427 
                                 goto ldv_53706; else 
#line 430 
                                                      goto ldv_53708;
  ldv_53708: 
#line 431 
  ;
  
#line 432 
  return;
}


#line 438  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static void ath_tx_complete_aggr(struct ath_softc *sc, struct ath_txq *txq, struct ath_buf *bf, struct list_head *bf_q, struct ath_tx_status *ts, int txok)
{
  struct sk_buff *skb;
  struct ieee80211_sta *sta;
  struct ieee80211_hdr *hdr;
  struct ieee80211_tx_info *tx_info;
  struct ath_buf *bf_next;
  struct list_head bf_head;
  struct sk_buff_head bf_pending;
  u16 seq_first;
  u32 ba[2U];
  int isaggr;
  int txfail;
  int txpending;
  bool isba;
  struct ieee80211_tx_rate rates[4U];
  struct ath_frame_info *fi;
  int nframes;
  int i;
  int retries;
  int tmp_3;
  
#line 442 
  struct ath_node *an = (struct ath_node *)0;
  
#line 445 
  struct ieee80211_hw *hw = sc->hw;
  
#line 448 
  struct ath_atx_tid *tid = (struct ath_atx_tid *)0;
  
#line 449 
  struct ath_buf *bf_last = bf->bf_lastbf;
  
#line 452 
  u16 seq_st = (unsigned short)0U;
  
#line 452 
  u16 acked_cnt = (unsigned short)0U;
  
#line 452 
  u16 txfail_cnt = (unsigned short)0U;
  
#line 454 
  int sendbar = 0;
  
#line 454 
  int needreset = 0;
  
#line 454 
  int nbad = 0;
  
#line 455 
  bool rc_update = (_Bool)1;
  
#line 459 
  bool flush = (_Bool)(((int)ts->ts_status & 64) != 0);
  
#line 461 
  int bar_index = -1;
  
#line 463 
  skb = bf->bf_mpdu;
  
#line 464 
  hdr = (struct ieee80211_hdr *)skb->data;
  
#line 466 
  tx_info = IEEE80211_SKB_CB(skb);
  
#line 468 
  memcpy((void *)(& rates),(void const *)(& bf->rates),12UL);
  
#line 470 
  retries = (int)ts->ts_longretry + 1;
  
#line 471 
  i = 0;
  
#line 471 
  goto ldv_53749;
  ldv_53748: 
#line 472 
  ;
  
#line 472 
  retries = (int)rates[i].count + retries;
  
#line 471 
  i += 1;
  ldv_53749: 
#line 472 
  ;
  
#line 471 
  if ((int)ts->ts_rateindex > i) 
#line 473 
                                 goto ldv_53748; else 
#line 476 
                                                      goto ldv_53750;
  ldv_53750: 
#line 477 
  ;
  
#line 474 
  rcu_read_lock();
  
#line 476 
  sta = ieee80211_find_sta_by_ifaddr(hw,(u8 const *)(& hdr->addr1),(u8 const *)(& hdr->addr2));
  
#line 477 
  if (sta == (struct ieee80211_sta *)0) {
    
#line 478 
    rcu_read_unlock();
    
#line 480 
    INIT_LIST_HEAD(& bf_head);
    
#line 481 
    goto ldv_53752;
    ldv_53751: 
#line 482 
    ;
    
#line 482 
    bf_next = bf->bf_next;
    
#line 484 
    if (! bf->bf_state.stale || bf_next != (struct ath_buf *)0) 
#line 485 
                                                                list_move_tail(& bf->list,& bf_head); else ;
    
#line 487 
    ath_tx_complete_buf(sc,bf,txq,& bf_head,ts,0);
    
#line 489 
    bf = bf_next;
    ldv_53752: 
#line 490 
    ;
    
#line 481 
    if (bf != (struct ath_buf *)0) 
#line 483 
                                   goto ldv_53751; else 
#line 486 
                                                        goto ldv_53753;
    ldv_53753: 
#line 487 
    ;
    
#line 491 
    goto return_label;
  }
  else ;
  
#line 494 
  an = (struct ath_node *)(& sta->drv_priv);
  
#line 495 
  tid = ath_get_skb_tid(sc,an,skb);
  
#line 496 
  seq_first = tid->seq_start;
  
#line 497 
  isba = (_Bool)(((int)ts->ts_flags & 1) != 0);
  
#line 507 
  if ((int)isba != 0 && (int)tid->tidno != (int)ts->tid) 
#line 508 
                                                         txok = 0; else ;
  
#line 510 
  isaggr = (int)bf->bf_state.bf_type & 2;
  
#line 511 
  memset((void *)(& ba),0,8UL);
  
#line 513 
  if (isaggr != 0 && txok != 0) {
    
#line 514 
    if (((int)ts->ts_flags & 1) != 0) {
      
#line 515 
      seq_st = ts->ts_seqnum;
      
#line 516 
      memcpy((void *)(& ba),(void const *)(& ts->ba_low),8UL);
    }
    else 
      
#line 525 
      if ((sc->sc_ah)->opmode == (unsigned int)NL80211_IFTYPE_STATION) 
        
#line 526 
        needreset = 1; else ;
  }
  else ;
  
#line 530 
  __skb_queue_head_init(& bf_pending);
  
#line 532 
  ath_tx_count_frames(sc,bf,ts,txok,& nframes,& nbad);
  
#line 533 
  goto ldv_53764;
  ldv_53763: 
#line 534 
  ;
  {
    
#line 534 
    u16 seqno = bf->bf_state.seqno;
    
#line 536 
    sendbar = 0;
    
#line 536 
    txpending = sendbar;
    
#line 536 
    txfail = txpending;
    
#line 537 
    bf_next = bf->bf_next;
    
#line 539 
    skb = bf->bf_mpdu;
    
#line 540 
    tx_info = IEEE80211_SKB_CB(skb);
    
#line 541 
    fi = get_frame_info(skb);
    
#line 543 
    if ((((int)seqno - (int)tid->seq_start) & 4095) >= (int)tid->baw_size || ! tid->active) 
      
#line 549 
      txfail = 1;
    else 
      
#line 550 
      if ((((int)seqno - (int)seq_st) & 4095) <= 63 && (ba[(((int)seqno - (int)seq_st) >> 5) & 127] & (unsigned int)(1 << (((int)seqno - (int)seq_st) & 31))) != 0U) 
        
#line 553 
        acked_cnt = (u16)((int)acked_cnt + 1);
      else 
        
#line 554 
        if (isaggr == 0 && txok != 0) 
#line 556 
                                      acked_cnt = (u16)((int)acked_cnt + 1);
        else 
          
#line 557 
          if ((int)flush != 0) 
#line 558 
                               txpending = 1;
          else 
            
#line 559 
            if ((unsigned int)fi->retries <= 29U) {
              
#line 560 
              if (txok != 0 || ! an->sleeping) 
#line 561 
                                               ath_tx_set_retry(sc,txq,bf->bf_mpdu,retries); else ;
              
#line 564 
              txpending = 1;
            }
            else {
              int tmp_0;
              
#line 566 
              txfail = 1;
              
#line 567 
              txfail_cnt = (u16)((int)txfail_cnt + 1);
              {
                int tmp;
                
#line 568 
                int __max1 = bar_index;
                
#line 568 
                int __max2 = ((int)seqno - (int)seq_first) & 4095;
                
#line 568 
                if (__max1 > __max2) 
#line 568 
                                     tmp = __max1; else 
#line 568 
                                                        tmp = __max2;
                
#line 568 
                tmp_0 = tmp;
              }
              
#line 568 
              bar_index = tmp_0;
            }
    
#line 576 
    INIT_LIST_HEAD(& bf_head);
    
#line 577 
    if (bf_next != (struct ath_buf *)0 || ! bf_last->bf_state.stale) 
      
#line 578 
      list_move_tail(& bf->list,& bf_head); else ;
    
#line 580 
    if (txpending == 0) {
      
#line 585 
      ath_tx_update_baw(sc,tid,(int)seqno);
      
#line 587 
      if ((int)rc_update != 0 && ((unsigned int)acked_cnt == 1U || (unsigned int)txfail_cnt == 1U)) {
        
#line 588 
        memcpy((void *)(& tx_info->__anonCompField_ieee80211_tx_info_98.control.__anonCompField___anonstruct_control_358_96.__anonCompField___anonunion_359_95.rates),(void const *)(& rates),12UL);
        
#line 589 
        ath_tx_rc_status(sc,bf,ts,nframes,nbad,txok);
        
#line 590 
        rc_update = (_Bool)0;
        
#line 591 
        if (bf->bf_lastbf == bf) 
#line 592 
                                 ath_dynack_sample_tx_ts(sc->sc_ah,bf->bf_mpdu,ts); else ;
      }
      else ;
      
#line 597 
      ath_tx_complete_buf(sc,bf,txq,& bf_head,ts,txfail == 0);
    }
    else {
      
#line 600 
      if ((tx_info->flags & 268435456U) != 0U) {
        
#line 601 
        tx_info->flags &= 4026531839U;
        
#line 602 
        ieee80211_sta_eosp(sta);
      }
      else ;
      
#line 605 
      if (bf->bf_next == (struct ath_buf *)0 && (int)bf_last->bf_state.stale != 0) {
        struct ath_buf *tbf;
        
#line 608 
        tbf = ath_clone_txbuf(sc,bf_last);
        
#line 614 
        if (tbf == (struct ath_buf *)0) {
          int tmp_2;
          
#line 615 
          ath_tx_update_baw(sc,tid,(int)seqno);
          
#line 617 
          ath_tx_complete_buf(sc,bf,txq,& bf_head,ts,0);
          {
            int tmp_1;
            
#line 619 
            int __max1_0 = bar_index;
            
#line 619 
            int __max2_0 = ((int)seqno - (int)seq_first) & 4095;
            
#line 619 
            if (__max1_0 > __max2_0) 
#line 619 
                                     tmp_1 = __max1_0; else 
#line 619 
                                                            tmp_1 = __max2_0;
            
#line 619 
            tmp_2 = tmp_1;
          }
          
#line 619 
          bar_index = tmp_2;
          
#line 621 
          goto ldv_53762;
        }
        else ;
        
#line 624 
        fi->bf = tbf;
      }
      else ;
      
#line 631 
      __skb_queue_tail(& bf_pending,skb);
    }
    
#line 634 
    bf = bf_next;
  }
  ldv_53764: 
#line 636 
  ;
  
#line 533 
  if (bf != (struct ath_buf *)0) 
#line 535 
                                 goto ldv_53763; else 
#line 538 
                                                      goto ldv_53762;
  ldv_53762: 
#line 539 
  ;
  
#line 638 
  tmp_3 = skb_queue_empty((struct sk_buff_head const *)(& bf_pending));
  
#line 638 
  if (tmp_3 == 0) {
    
#line 639 
    if ((int)an->sleeping != 0) 
#line 640 
                                ieee80211_sta_set_buffered(sta,(unsigned char)((int)tid->tidno),(_Bool)1); else ;
    
#line 642 
    skb_queue_splice_tail((struct sk_buff_head const *)(& bf_pending),& tid->retry_q);
    
#line 643 
    if (! an->sleeping) {
      
#line 644 
      ath_tx_queue_tid(sc,txq,tid);
      
#line 646 
      if (((int)ts->ts_status & 3) != 0) 
#line 647 
                                         (tid->ac)->clear_ps_filter = (_Bool)1; else ;
    }
    else ;
  }
  else ;
  
#line 651 
  if (bar_index >= 0) {
    
#line 652 
    u16 bar_seq = (unsigned short)((unsigned int)((unsigned short)(bar_index + (int)seq_first)) & 4095U);
    
#line 654 
    if ((((int)bar_seq - (int)tid->seq_start) & 4095) < (int)tid->baw_size) 
      
#line 655 
      tid->bar_index = (signed char)((int)bar_seq - (int)tid->seq_start); else ;
    
#line 657 
    ath_txq_unlock(sc,txq);
    
#line 658 
    ath_send_bar(tid,(unsigned short)((int)((unsigned int)(bar_index + (int)seq_first) + 1U) & 4095));
    
#line 659 
    ath_txq_lock(sc,txq);
  }
  else ;
  
#line 662 
  rcu_read_unlock();
  
#line 664 
  if (needreset != 0) 
#line 665 
                      ath9k_queue_reset(sc,(enum ath_reset_type)RESET_TYPE_TX_ERROR); else ;
  return_label: 
#line 666 
                return;
}


#line 668  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static bool bf_is_ampdu_not_probing(struct ath_buf *bf)
{
  bool __retres;
  
#line 670 
  struct ieee80211_tx_info *info = IEEE80211_SKB_CB(bf->bf_mpdu);
  
#line 671 
  __retres = (_Bool)((((int)bf->bf_state.bf_type & 1) != 0 && (info->flags & 4096U) == 0U) != 0);
  
#line 671 
  return __retres;
}


#line 674  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static void ath_tx_process_buffer(struct ath_softc *sc, struct ath_txq *txq, struct ath_tx_status *ts, struct ath_buf *bf, struct list_head *bf_head)
{
  struct ieee80211_tx_info *info;
  bool txok;
  bool flush;
  bool tmp;
  int tmp_0;
  
#line 681 
  txok = (_Bool)(((int)ts->ts_status & 95) == 0);
  
#line 682 
  flush = (_Bool)(((int)ts->ts_status & 64) != 0);
  
#line 683 
  txq->axq_tx_inprogress = (_Bool)0;
  
#line 685 
  txq->axq_depth -= 1U;
  
#line 686 
  tmp = bf_is_ampdu_not_probing(bf);
  
#line 686 
  if ((int)tmp != 0) 
#line 687 
                     txq->axq_ampdu_depth -= 1U; else ;
  
#line 689 
  tmp_0 = ath9k_hw_get_duration(sc->sc_ah,(void const *)bf->bf_desc,(int)ts->ts_rateindex);
  
#line 689 
  ts->duration = (unsigned int)tmp_0;
  
#line 691 
  if (((int)bf->bf_state.bf_type & 1) == 0) {
    
#line 692 
    if (! flush) {
      
#line 693 
      info = IEEE80211_SKB_CB(bf->bf_mpdu);
      
#line 694 
      memcpy((void *)(& info->__anonCompField_ieee80211_tx_info_98.control.__anonCompField___anonstruct_control_358_96.__anonCompField___anonunion_359_95.rates),(void const *)(& bf->rates),12UL);
      
#line 696 
      ath_tx_rc_status(sc,bf,ts,1,(int)txok == 0,(int)txok);
      
#line 697 
      ath_dynack_sample_tx_ts(sc->sc_ah,bf->bf_mpdu,ts);
    }
    else ;
    
#line 699 
    ath_tx_complete_buf(sc,bf,txq,bf_head,ts,(int)txok);
  }
  else 
#line 701 
       ath_tx_complete_aggr(sc,txq,bf,bf_head,ts,(int)txok);
  
#line 703 
  if (! flush) 
#line 704 
               ath_txq_schedule(sc,txq); else ;
  
#line 705 
  return;
}


#line 707  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static bool ath_lookup_legacy(struct ath_buf *bf)
{
  bool __retres;
  struct sk_buff *skb;
  struct ieee80211_tx_info *tx_info;
  struct ieee80211_tx_rate *rates;
  int i;
  
#line 714 
  skb = bf->bf_mpdu;
  
#line 715 
  tx_info = IEEE80211_SKB_CB(skb);
  
#line 716 
  rates = (struct ieee80211_tx_rate *)(& tx_info->__anonCompField_ieee80211_tx_info_98.control.__anonCompField___anonstruct_control_358_96.__anonCompField___anonunion_359_95.rates);
  
#line 718 
  i = 0;
  
#line 718 
  goto ldv_53789;
  ldv_53788: 
#line 719 
  ;
  
#line 719 
  if ((unsigned int)*((unsigned char *)(rates + i) + 1UL) == 0U || (int)(rates + i)->idx < 0) 
    
#line 720 
    goto ldv_53787; else ;
  
#line 722 
  if (((int)(rates + i)->flags & 8) == 0) {
    
#line 723 
    __retres = (_Bool)1;
    
#line 723 
    goto return_label;
  }
  else ;
  
#line 718 
  i += 1;
  ldv_53789: 
#line 719 
  ;
  
#line 718 
  if (i <= 3) 
#line 720 
              goto ldv_53788; else 
#line 723 
                                   goto ldv_53787;
  ldv_53787: 
#line 724 
  ;
  
#line 726 
  __retres = (_Bool)0;
  return_label: 
#line 726 
                return __retres;
}


#line 729  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static u32 ath_lookup_rate(struct ath_softc *sc, struct ath_buf *bf, struct ath_atx_tid *tid)
{
  u32 __retres;
  struct sk_buff *skb;
  struct ieee80211_tx_info *tx_info;
  struct ieee80211_tx_rate *rates;
  u32 max_4ms_framelen;
  u32 frmlen;
  u16 aggr_limit;
  u16 bt_aggr_limit;
  int i;
  unsigned int tmp_2;
  
#line 736 
  u16 legacy = (unsigned short)0U;
  
#line 737 
  int q = ((tid->ac)->txq)->mac80211_qnum;
  
#line 740 
  skb = bf->bf_mpdu;
  
#line 741 
  tx_info = IEEE80211_SKB_CB(skb);
  
#line 742 
  rates = (struct ieee80211_tx_rate *)(& bf->rates);
  
#line 748 
  max_4ms_framelen = 65535U;
  
#line 750 
  i = 0;
  
#line 750 
  goto ldv_53812;
  ldv_53811: 
#line 751 
  ;
  {
    int modeidx;
    u32 tmp_0;
    
#line 753 
    if ((unsigned int)*((unsigned char *)(rates + i) + 1UL) == 0U) 
#line 754 
                                                                   goto ldv_53806; else ;
    
#line 756 
    if (((int)(rates + i)->flags & 8) == 0) {
      
#line 757 
      legacy = (unsigned short)1U;
      
#line 758 
      goto ldv_53807;
    }
    else ;
    
#line 761 
    if (((int)(rates + i)->flags & 32) != 0) 
#line 762 
                                             modeidx = 2; else 
#line 764 
                                                               modeidx = 0;
    
#line 766 
    if (((int)(rates + i)->flags & 128) != 0) 
#line 767 
                                              modeidx += 1; else ;
    
#line 769 
    frmlen = (unsigned int)sc->tx.max_aggr_framelen[q][modeidx][(int)(rates + i)->idx];
    {
      u32 tmp;
      
#line 770 
      u32 _min1 = max_4ms_framelen;
      
#line 770 
      u32 _min2 = frmlen;
      
#line 770 
      if (_min1 < _min2) 
#line 770 
                         tmp = _min1; else 
#line 770 
                                           tmp = _min2;
      
#line 770 
      tmp_0 = tmp;
    }
    
#line 770 
    max_4ms_framelen = tmp_0;
  }
  ldv_53806: 
#line 773 
  ;
  
#line 750 
  i += 1;
  ldv_53812: 
#line 751 
  ;
  
#line 750 
  if (i <= 3) 
#line 752 
              goto ldv_53811; else 
#line 755 
                                   goto ldv_53807;
  ldv_53807: 
#line 756 
  ;
  
#line 778 
  if ((tx_info->flags & 4096U) != 0U || (unsigned int)legacy != 0U) {
    
#line 779 
    __retres = 0U;
    
#line 779 
    goto return_label;
  }
  else ;
  {
    u32 tmp_1;
    
#line 781 
    u32 _min1_0 = max_4ms_framelen;
    
#line 781 
    unsigned int _min2_0 = 65535U;
    
#line 781 
    if (_min1_0 < _min2_0) 
#line 781 
                           tmp_1 = _min1_0; else 
#line 781 
                                                 tmp_1 = _min2_0;
    
#line 781 
    tmp_2 = tmp_1;
  }
  
#line 781 
  aggr_limit = (unsigned short)tmp_2;
  
#line 786 
  bt_aggr_limit = ath9k_btcoex_aggr_limit(sc,max_4ms_framelen);
  
#line 787 
  if ((unsigned int)bt_aggr_limit != 0U) 
#line 788 
                                         aggr_limit = bt_aggr_limit; else ;
  
#line 790 
  if ((unsigned int)(tid->an)->maxampdu != 0U) {
    int tmp_4;
    {
      int tmp_3;
      
#line 791 
      u16 _min1_1 = aggr_limit;
      
#line 791 
      u16 _min2_1 = (tid->an)->maxampdu;
      
#line 791 
      if ((int)_min1_1 < (int)_min2_1) 
#line 791 
                                       tmp_3 = (int)_min1_1; else 
#line 791 
                                                                  tmp_3 = (int)_min2_1;
      
#line 791 
      tmp_4 = tmp_3;
    }
    
#line 791 
    aggr_limit = (unsigned short)tmp_4;
  }
  else ;
  
#line 793 
  __retres = (unsigned int)aggr_limit;
  return_label: 
#line 793 
                return __retres;
}


#line 800  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static int ath_compute_num_delims(struct ath_softc *sc, struct ath_atx_tid *tid, struct ath_buf *bf, u16 frmlen, bool first_subfrm)
{
  int __retres;
  u32 nsymbits;
  u32 nsymbols;
  u16 minlen;
  u8 flags;
  u8 rix;
  int width;
  int streams;
  int half_gi;
  int ndelim;
  int mindelim;
  
#line 809 
  struct ath_frame_info *fi = get_frame_info(bf->bf_mpdu);
  
#line 812 
  if ((unsigned int)frmlen <= 255U) 
#line 812 
                                    ndelim = (259 - (int)frmlen) / 4; else 
                                                                    
#line 812 
                                                                    ndelim = 0;
  
#line 820 
  if ((unsigned int)fi->keyix != 255U && ((sc->sc_ah)->caps.hw_caps & 16U) == 0U) 
    
#line 822 
    ndelim += 10; else ;
  
#line 828 
  if (((int)first_subfrm != 0 && ((sc->sc_ah)->hw_version.macVersion != 448U || (unsigned int)(sc->sc_ah)->hw_version.macRev <= 3U)) && ((sc->sc_ah)->ent_mode & 8388608U) != 0U) {
    int tmp_1;
    {
      int tmp_0;
      
#line 830 
      int _max1 = ndelim;
      
#line 830 
      int _max2 = 60;
      
#line 830 
      if (_max1 > _max2) 
#line 830 
                         tmp_0 = _max1; else 
#line 830 
                                             tmp_0 = _max2;
      
#line 830 
      tmp_1 = tmp_0;
    }
    
#line 830 
    ndelim = tmp_1;
  }
  else ;
  
#line 842 
  if ((unsigned int)(tid->an)->mpdudensity == 0U) {
    
#line 843 
    __retres = ndelim;
    
#line 843 
    goto return_label;
  }
  else ;
  
#line 845 
  rix = (unsigned char)bf->rates[0].idx;
  
#line 846 
  flags = (unsigned char)bf->rates[0].flags;
  
#line 847 
  width = ((int)flags >> 5) & 1;
  
#line 848 
  half_gi = ((int)flags >> 7) & 1;
  
#line 850 
  if (half_gi != 0) 
#line 851 
                    nsymbols = (unsigned int)(((int)(tid->an)->mpdudensity * 5 + -4) / 18); else 
                                                                    
#line 853 
                                                                    nsymbols = (unsigned int)((int)(tid->an)->mpdudensity >> 2);
  
#line 855 
  if (nsymbols == 0U) 
#line 856 
                      nsymbols = 1U; else ;
  
#line 858 
  streams = (((int)rix >> 3) & 15) + 1;
  
#line 859 
  nsymbits = (unsigned int)((int)bits_per_symbol[(int)rix & 7][width] * streams);
  
#line 860 
  minlen = (unsigned short)((nsymbols * nsymbits) / 8U);
  
#line 862 
  if ((int)frmlen < (int)minlen) {
    int tmp_3;
    
#line 863 
    mindelim = ((int)minlen - (int)frmlen) / 4;
    {
      int tmp_2;
      
#line 864 
      int _max1_0 = mindelim;
      
#line 864 
      int _max2_0 = ndelim;
      
#line 864 
      if (_max1_0 > _max2_0) 
#line 864 
                             tmp_2 = _max1_0; else 
#line 864 
                                                   tmp_2 = _max2_0;
      
#line 864 
      tmp_3 = tmp_2;
    }
    
#line 864 
    ndelim = tmp_3;
  }
  else ;
  
#line 867 
  __retres = ndelim;
  return_label: 
#line 867 
                return __retres;
}


#line 871  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static struct ath_buf *ath_tx_get_tid_subframe(struct ath_softc *sc, struct ath_txq *txq, struct ath_atx_tid *tid, struct sk_buff_head **q)
{
  struct ath_buf *__retres;
  struct ieee80211_tx_info *tx_info;
  struct ath_frame_info *fi;
  struct sk_buff *skb;
  struct ath_buf *bf;
  u16 seqno;
  int tmp;
  ldv_53858: 
#line 879 
  ;
  
#line 881 
  *q = & tid->retry_q;
  
#line 882 
  tmp = skb_queue_empty((struct sk_buff_head const *)*q);
  
#line 882 
  if (tmp != 0) 
#line 883 
                *q = & tid->buf_q; else ;
  
#line 885 
  skb = skb_peek((struct sk_buff_head const *)*q);
  
#line 886 
  if (skb == (struct sk_buff *)0) 
#line 887 
                                  goto ldv_53854; else ;
  
#line 889 
  fi = get_frame_info(skb);
  
#line 890 
  bf = fi->bf;
  
#line 891 
  if (fi->bf == (struct ath_buf *)0) 
#line 892 
                                     bf = ath_tx_setup_buffer(sc,txq,tid,skb); else 
                                                                    
#line 894 
                                                                    bf->bf_state.stale = (_Bool)0;
  
#line 896 
  if (bf == (struct ath_buf *)0) {
    
#line 897 
    __skb_unlink(skb,*q);
    
#line 898 
    ath_txq_skb_done(sc,txq,skb);
    
#line 899 
    ieee80211_free_txskb(sc->hw,skb);
    
#line 900 
    goto ldv_53855;
  }
  else ;
  
#line 903 
  bf->bf_next = (struct ath_buf *)0;
  
#line 904 
  bf->bf_lastbf = bf;
  
#line 906 
  tx_info = IEEE80211_SKB_CB(skb);
  
#line 907 
  tx_info->flags &= 4294967287U;
  
#line 914 
  if (! tid->active) 
#line 915 
                     tx_info->flags &= 4294967231U; else ;
  
#line 917 
  if ((tx_info->flags & 64U) == 0U) {
    
#line 918 
    bf->bf_state.bf_type = (unsigned char)0U;
    
#line 919 
    __retres = bf;
    
#line 919 
    goto return_label;
  }
  else ;
  
#line 922 
  bf->bf_state.bf_type = (unsigned char)3U;
  
#line 923 
  seqno = bf->bf_state.seqno;
  
#line 926 
  if ((((int)seqno - (int)tid->seq_start) & 4095) >= (int)tid->baw_size) 
    
#line 927 
    goto ldv_53854; else ;
  
#line 929 
  if ((int)tid->bar_index > (((int)seqno - (int)tid->seq_start) & 4095)) {
    struct list_head bf_head;
    
#line 930 
    struct ath_tx_status ts = {.ts_tstamp = 0U, .ts_seqnum = (unsigned short)0, .ts_status = (unsigned char)0, .ts_rateindex = (unsigned char)0, .ts_rssi = (signed char)0, .ts_shortretry = (unsigned char)0, .ts_longretry = (unsigned char)0, .ts_virtcol = (unsigned char)0, .ts_flags = (unsigned char)0, .ts_rssi_ctl0 = (signed char)0, .ts_rssi_ctl1 = (signed char)0, .ts_rssi_ctl2 = (signed char)0, .ts_rssi_ext0 = (signed char)0, .ts_rssi_ext1 = (signed char)0, .ts_rssi_ext2 = (signed char)0, .qid = (unsigned char)0, .desc_id = (unsigned short)0, .tid = (unsigned char)0, .ba_low = 0U, .ba_high = 0U, .evm0 = 0U, .evm1 = 0U, .evm2 = 0U, .duration = 0U};
    
#line 933 
    INIT_LIST_HEAD(& bf_head);
    
#line 934 
    list_add(& bf->list,& bf_head);
    
#line 935 
    __skb_unlink(skb,*q);
    
#line 936 
    ath_tx_update_baw(sc,tid,(int)seqno);
    
#line 937 
    ath_tx_complete_buf(sc,bf,txq,& bf_head,& ts,0);
    
#line 938 
    goto ldv_53855;
  }
  else ;
  
#line 941 
  __retres = bf;
  
#line 941 
  goto return_label;
  ldv_53855: 
#line 942 
  ;
  
#line 881 
  goto ldv_53858;
  ldv_53854: 
#line 882 
  ;
  
#line 944 
  __retres = (struct ath_buf *)0;
  return_label: 
#line 944 
                return __retres;
}


#line 948  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static bool ath_tx_form_aggr(struct ath_softc *sc, struct ath_txq *txq, struct ath_atx_tid *tid, struct list_head *bf_q, struct ath_buf *bf_first, struct sk_buff_head *tid_q, int *aggr_len)
{
  int ndelim;
  u16 al_delta;
  struct ieee80211_tx_info *tx_info;
  struct ath_frame_info *fi;
  struct sk_buff *skb;
  u32 tmp;
  bool tmp_1;
  
#line 954 
  struct ath_buf *bf = bf_first;
  
#line 954 
  struct ath_buf *bf_prev = (struct ath_buf *)0;
  
#line 955 
  int nframes = 0;
  
#line 956 
  u16 aggr_limit = (unsigned short)0U;
  
#line 956 
  u16 al = (unsigned short)0U;
  
#line 956 
  u16 bpad = (unsigned short)0U;
  
#line 957 
  u16 h_baw = (unsigned short)((unsigned int)tid->baw_size / 2U);
  
#line 961 
  bool closed = (_Bool)0;
  
#line 963 
  bf = bf_first;
  
#line 964 
  tmp = ath_lookup_rate(sc,bf,tid);
  
#line 964 
  aggr_limit = (unsigned short)tmp;
  ldv_53882: 
#line 965 
  ;
  
#line 967 
  skb = bf->bf_mpdu;
  
#line 968 
  fi = get_frame_info(skb);
  
#line 971 
  al_delta = (unsigned short)((unsigned int)fi->framelen + 4U);
  
#line 972 
  if (nframes != 0) {
    
#line 973 
    if ((int)aggr_limit < ((int)al + (int)bpad) + (int)al_delta) 
#line 975 
                                                                 goto ldv_53881;
    else {
      bool tmp_0;
      
#line 973 
      tmp_0 = ath_lookup_legacy(bf);
      
#line 973 
      if ((int)tmp_0 != 0) 
#line 975 
                           goto ldv_53881;
      else 
        
#line 974 
        if ((int)h_baw <= nframes) 
#line 975 
                                   goto ldv_53881; else ;
    }
    
#line 977 
    tx_info = IEEE80211_SKB_CB(bf->bf_mpdu);
    
#line 978 
    if ((tx_info->flags & 4096U) != 0U || (tx_info->flags & 64U) == 0U) 
      
#line 980 
      goto ldv_53881; else ;
  }
  else ;
  
#line 984 
  al = (unsigned short)(((int)bpad + (int)al_delta) + (int)al);
  
#line 990 
  ndelim = ath_compute_num_delims(sc,tid,bf_first,(unsigned short)((int)fi->framelen),(_Bool)(nframes == 0));
  
#line 992 
  bpad = (unsigned short)((int)((unsigned short)((4 - ((int)al_delta & 3)) % 4)) + ((int)((unsigned short)ndelim) << 2U));
  
#line 994 
  nframes += 1;
  
#line 995 
  bf->bf_next = (struct ath_buf *)0;
  
#line 998 
  if ((unsigned int)*((unsigned char *)fi + 13UL) == 0U) 
#line 999 
                                                         ath_tx_addto_baw(sc,tid,bf); else ;
  
#line 1000 
  bf->bf_state.ndelim = (unsigned char)ndelim;
  
#line 1002 
  __skb_unlink(skb,tid_q);
  
#line 1003 
  list_add_tail(& bf->list,bf_q);
  
#line 1004 
  if (bf_prev != (struct ath_buf *)0) 
#line 1005 
                                      bf_prev->bf_next = bf; else ;
  
#line 1007 
  bf_prev = bf;
  
#line 1009 
  bf = ath_tx_get_tid_subframe(sc,txq,tid,& tid_q);
  
#line 1010 
  if (bf == (struct ath_buf *)0) {
    
#line 1011 
    closed = (_Bool)1;
    
#line 1012 
    goto ldv_53881;
  }
  else ;
  
#line 1014 
  tmp_1 = ath_tid_has_buffered(tid);
  
#line 1014 
  if ((int)tmp_1 != 0) 
#line 1016 
                       goto ldv_53882; else 
#line 1019 
                                            goto ldv_53881;
  ldv_53881: 
#line 1020 
  ;
  
#line 1016 
  bf = bf_first;
  
#line 1017 
  bf->bf_lastbf = bf_prev;
  
#line 1019 
  if (bf == bf_prev) {
    struct ath_frame_info *tmp_2;
    
#line 1020 
    tmp_2 = get_frame_info(bf->bf_mpdu);
    
#line 1020 
    al = tmp_2->framelen;
    
#line 1021 
    bf->bf_state.bf_type = (unsigned char)1U;
  }
  else 
#line 1023 
       sc->debug.stats.txstats[txq->axq_qnum].a_aggr += 1U;
  
#line 1026 
  *aggr_len = (int)al;
  
#line 1028 
  return closed;
}


#line 1038  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static u32 ath_pkt_duration(struct ath_softc *sc, u8 rix, int pktlen, int width, int half_gi, bool shortPreamble)
{
  u32 nbits;
  u32 nsymbits;
  u32 duration;
  u32 nsymbols;
  int streams;
  
#line 1045 
  streams = (((int)rix >> 3) & 15) + 1;
  
#line 1046 
  nbits = (unsigned int)((pktlen << 3) + 22);
  
#line 1047 
  nsymbits = (unsigned int)((int)bits_per_symbol[(int)rix & 7][width] * streams);
  
#line 1048 
  nsymbols = ((nbits + nsymbits) + 4294967295U) / nsymbits;
  
#line 1050 
  if (half_gi == 0) 
#line 1051 
                    duration = nsymbols << 2; else 
#line 1053 
                                                   duration = (nsymbols * 18U + 4U) / 5U;
  
#line 1056 
  duration = (unsigned int)((streams + 8) * 4) + duration;
  
#line 1058 
  return duration;
}


#line 1061  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static int ath_max_framelen(int usec, int mcs, bool ht40, bool sgi)
{
  int symbols;
  int bits;
  
#line 1063 
  int streams = ((mcs >> 3) & 15) + 1;
  
#line 1065 
  int bytes = 0;
  
#line 1067 
  usec -= (streams + 8) * 4;
  
#line 1068 
  if ((int)sgi != 0) 
#line 1068 
                     symbols = (usec * 5 + -4) / 18; else 
#line 1068 
                                                          symbols = usec >> 2;
  
#line 1069 
  bits = ((int)bits_per_symbol[mcs % 8][(int)ht40] * symbols) * streams;
  
#line 1070 
  bits += -22;
  
#line 1071 
  bytes = bits / 8;
  
#line 1072 
  if (bytes > 65532) 
#line 1073 
                     bytes = 65532; else ;
  
#line 1075 
  return bytes;
}


#line 1078  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
void ath_update_max_aggr_framelen(struct ath_softc *sc, int queue, int txop)
{
  u16 *cur_ht20;
  u16 *cur_ht20_sgi;
  u16 *cur_ht40;
  u16 *cur_ht40_sgi;
  int mcs;
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  
#line 1084 
  if (txop == 0 || txop > 4096) 
#line 1085 
                                txop = 4096; else ;
  
#line 1087 
  cur_ht20 = (u16 *)(& sc->tx.max_aggr_framelen[queue][0]);
  
#line 1088 
  cur_ht20_sgi = (u16 *)(& sc->tx.max_aggr_framelen[queue][1]);
  
#line 1089 
  cur_ht40 = (u16 *)(& sc->tx.max_aggr_framelen[queue][2]);
  
#line 1090 
  cur_ht40_sgi = (u16 *)(& sc->tx.max_aggr_framelen[queue][3]);
  
#line 1091 
  mcs = 0;
  
#line 1091 
  goto ldv_53917;
  ldv_53916: 
#line 1092 
  ;
  
#line 1092 
  tmp = ath_max_framelen(txop,mcs,(_Bool)0,(_Bool)0);
  
#line 1092 
  *(cur_ht20 + mcs) = (unsigned short)tmp;
  
#line 1093 
  tmp_0 = ath_max_framelen(txop,mcs,(_Bool)0,(_Bool)1);
  
#line 1093 
  *(cur_ht20_sgi + mcs) = (unsigned short)tmp_0;
  
#line 1094 
  tmp_1 = ath_max_framelen(txop,mcs,(_Bool)1,(_Bool)0);
  
#line 1094 
  *(cur_ht40 + mcs) = (unsigned short)tmp_1;
  
#line 1095 
  tmp_2 = ath_max_framelen(txop,mcs,(_Bool)1,(_Bool)1);
  
#line 1095 
  *(cur_ht40_sgi + mcs) = (unsigned short)tmp_2;
  
#line 1091 
  mcs += 1;
  ldv_53917: 
#line 1092 
  ;
  
#line 1091 
  if (mcs <= 31) 
#line 1093 
                 goto ldv_53916; else 
#line 1096 
                                      goto ldv_53918;
  ldv_53918: 
#line 1097 
  ;
  
#line 1098 
  return;
}


#line 1099  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static u8 ath_get_rate_txpower(struct ath_softc *sc, struct ath_buf *bf, u8 rateidx, bool is_40, bool is_cck)
{
  u8 __retres;
  u8 max_power;
  struct sk_buff *skb;
  struct ath_frame_info *fi;
  struct ieee80211_tx_info *info;
  
#line 1106 
  struct ath_hw *ah = sc->sc_ah;
  
#line 1108 
  if ((int)sc->tx99_state != 0 || ! ah->tpc_enabled) {
    
#line 1109 
    __retres = (unsigned char)63U;
    
#line 1109 
    goto return_label;
  }
  else ;
  
#line 1111 
  skb = bf->bf_mpdu;
  
#line 1112 
  fi = get_frame_info(skb);
  
#line 1113 
  info = IEEE80211_SKB_CB(skb);
  
#line 1115 
  if (ah->hw_version.macVersion <= 447U) {
    int tmp_2;
    int tmp_4;
    
#line 1116 
    int txpower = (int)fi->tx_power;
    
#line 1118 
    if ((int)is_40 != 0) {
      u8 power_ht40delta;
      
#line 1120 
      struct ar5416_eeprom_def *eep = & ah->eeprom.def;
      
#line 1122 
      if (((int)eep->baseEepHeader.version & 4095) > 1) {
        bool is_2ghz;
        struct modal_eep_header *pmodal;
        
#line 1126 
        is_2ghz = (_Bool)((unsigned int)info->band == 0U);
        
#line 1127 
        pmodal = & eep->modalHeader[(int)is_2ghz];
        
#line 1128 
        power_ht40delta = pmodal->ht40PowerIncForPdadc;
      }
      else 
#line 1130 
           power_ht40delta = (unsigned char)2U;
      
#line 1132 
      txpower = (int)power_ht40delta + txpower;
    }
    else ;
    
#line 1135 
    if ((ah->hw_version.macVersion == 384U || ah->hw_version.macVersion == 192U) || ah->hw_version.macVersion == 320U) 
      
#line 1137 
      txpower += 10;
    else 
      
#line 1138 
      if (ah->hw_version.macVersion > 127U) {
        s8 power_offset;
        u32 tmp;
        
#line 1141 
        tmp = (*((ah->eep_ops)->get_eeprom))(ah,(enum eeprom_param)EEP_PWR_TABLE_OFFSET);
        
#line 1141 
        power_offset = (signed char)tmp;
        
#line 1143 
        txpower -= (int)power_offset * 2;
      }
      else ;
    
#line 1146 
    if (ah->hw_version.macVersion > 127U) {
      u32 tmp_0;
      
#line 1146 
      tmp_0 = (*((ah->eep_ops)->get_eeprom))(ah,(enum eeprom_param)EEP_OL_PWRCTRL);
      
#line 1146 
      if (tmp_0 != 0U) {
        
#line 1146 
        if ((int)is_cck != 0) 
#line 1147 
                              txpower += -2; else ;
      }
      else ;
    }
    else ;
    {
      int tmp_1;
      
#line 1149 
      int _max1 = txpower;
      
#line 1149 
      int _max2 = 0;
      
#line 1149 
      if (_max1 > _max2) 
#line 1149 
                         tmp_1 = _max1; else 
#line 1149 
                                             tmp_1 = _max2;
      
#line 1149 
      tmp_2 = tmp_1;
    }
    
#line 1149 
    txpower = tmp_2;
    {
      int tmp_3;
      
#line 1150 
      u8 __min1 = ah->tx_power[(int)rateidx];
      
#line 1150 
      u8 __min2 = (unsigned char)txpower;
      
#line 1150 
      if ((int)__min1 < (int)__min2) 
#line 1150 
                                     tmp_3 = (int)__min1; else 
#line 1150 
                                                               tmp_3 = (int)__min2;
      
#line 1150 
      tmp_4 = tmp_3;
    }
    
#line 1150 
    max_power = (unsigned char)tmp_4;
    
#line 1156 
    if ((unsigned int)max_power == 0U && ah->hw_version.macVersion <= 127U) 
      
#line 1157 
      max_power = (unsigned char)1U; else ;
  }
  else 
    
#line 1158 
    if ((unsigned int)bf->bf_state.bfs_paprd == 0U) 
      
#line 1159 
      if ((unsigned int)rateidx <= 7U && (info->flags & 25165824U) != 0U) {
        int tmp_6;
        {
          int tmp_5;
          
#line 1160 
          u8 __min1_0 = ah->tx_power_stbc[(int)rateidx];
          
#line 1160 
          u8 __min2_0 = fi->tx_power;
          
#line 1160 
          if ((int)__min1_0 < (int)__min2_0) 
#line 1160 
                                             tmp_5 = (int)__min1_0; else 
                                                                    
#line 1160 
                                                                    tmp_5 = (int)__min2_0;
          
#line 1160 
          tmp_6 = tmp_5;
        }
        
#line 1160 
        max_power = (unsigned char)tmp_6;
      }
      else {
        int tmp_8;
        {
          int tmp_7;
          
#line 1163 
          u8 __min1_1 = ah->tx_power[(int)rateidx];
          
#line 1163 
          u8 __min2_1 = fi->tx_power;
          
#line 1163 
          if ((int)__min1_1 < (int)__min2_1) 
#line 1163 
                                             tmp_7 = (int)__min1_1; else 
                                                                    
#line 1163 
                                                                    tmp_7 = (int)__min2_1;
          
#line 1163 
          tmp_8 = tmp_7;
        }
        
#line 1163 
        max_power = (unsigned char)tmp_8;
      }
    else 
#line 1166 
         max_power = (unsigned char)ah->paprd_training_power;
  
#line 1169 
  __retres = max_power;
  return_label: 
#line 1169 
                return __retres;
}


#line 1172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static void ath_buf_set_rate(struct ath_softc *sc, struct ath_buf *bf, struct ath_tx_info *info, int len, bool rts)
{
  struct sk_buff *skb;
  struct ieee80211_tx_info *tx_info;
  struct ieee80211_tx_rate *rates;
  struct ieee80211_rate const *rate;
  struct ieee80211_hdr *hdr;
  int i;
  int tmp_1;
  
#line 1175 
  struct ath_hw *ah = sc->sc_ah;
  
#line 1176 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 1182 
  struct ath_frame_info *fi = get_frame_info(bf->bf_mpdu);
  
#line 1183 
  u32 rts_thresh = ((sc->hw)->wiphy)->rts_threshold;
  
#line 1185 
  u8 rix = (unsigned char)0U;
  
#line 1187 
  skb = bf->bf_mpdu;
  
#line 1188 
  tx_info = IEEE80211_SKB_CB(skb);
  
#line 1189 
  rates = (struct ieee80211_tx_rate *)(& bf->rates);
  
#line 1190 
  hdr = (struct ieee80211_hdr *)skb->data;
  
#line 1193 
  tmp_1 = ieee80211_is_pspoll((unsigned short)((int)hdr->frame_control));
  
#line 1193 
  info->dur_update = (_Bool)(tmp_1 == 0);
  
#line 1194 
  info->rtscts_rate = fi->rtscts_rate;
  
#line 1196 
  i = 0;
  
#line 1196 
  goto ldv_53977;
  ldv_53976: 
#line 1197 
  ;
  {
    bool is_40;
    bool is_sgi;
    bool is_sp;
    bool is_cck;
    int phy;
    u16 tmp_4;
    
#line 1200 
    if ((unsigned int)*((unsigned char *)(rates + i) + 1UL) == 0U || (int)(rates + i)->idx < 0) 
      
#line 1201 
      goto ldv_53975; else ;
    
#line 1203 
    rix = (unsigned char)(rates + i)->idx;
    
#line 1204 
    info->rates[i].Tries = (unsigned int)(rates + i)->count;
    
#line 1209 
    if (((((int)bf->bf_state.bf_type & 1) != 0 && ((int)bf->bf_state.bf_type & 2) == 0) && ((int)(rates + i)->flags & 8) != 0) && (long)(rts_thresh != 4294967295U) != 0L) {
      
#line 1212 
      if (rts_thresh == 0U || (unsigned int)len > rts_thresh) 
#line 1213 
                                                              rts = (_Bool)1; else ;
    }
    else ;
    
#line 1216 
    if ((int)rts != 0 || ((int)(rates + i)->flags & 1) != 0) {
      
#line 1217 
      info->rates[i].RateFlags |= 1U;
      
#line 1218 
      info->flags |= 4U;
    }
    else 
      
#line 1219 
      if (((int)(rates + i)->flags & 2) != 0) {
        
#line 1220 
        info->rates[i].RateFlags |= 1U;
        
#line 1221 
        info->flags |= 8U;
      }
      else ;
    
#line 1224 
    if (((int)(rates + i)->flags & 32) != 0) 
#line 1225 
                                             info->rates[i].RateFlags |= 2U; else ;
    
#line 1226 
    if (((int)(rates + i)->flags & 128) != 0) 
#line 1227 
                                              info->rates[i].RateFlags |= 4U; else ;
    
#line 1229 
    is_sgi = (_Bool)(((int)(rates + i)->flags & 128) != 0);
    
#line 1230 
    is_40 = (_Bool)(((int)(rates + i)->flags & 32) != 0);
    
#line 1231 
    is_sp = (_Bool)(((int)(rates + i)->flags & 4) != 0);
    
#line 1233 
    if (((int)(rates + i)->flags & 8) != 0) {
      u8 tmp_2;
      
#line 1235 
      info->rates[i].Rate = (unsigned int)rix | 128U;
      
#line 1236 
      tmp_2 = ath_txchainmask_reduction(sc,(unsigned char)((int)ah->txchainmask),info->rates[i].Rate);
      
#line 1236 
      info->rates[i].ChSel = (unsigned int)tmp_2;
      
#line 1238 
      info->rates[i].PktDuration = ath_pkt_duration(sc,(unsigned char)((int)rix),len,(int)is_40,(int)is_sgi,(_Bool)((bool)((int)is_sp) != 0));
      
#line 1240 
      if ((unsigned int)rix <= 7U && (tx_info->flags & 25165824U) != 0U) 
        
#line 1241 
        info->rates[i].RateFlags |= 8U; else ;
      
#line 1243 
      info->txpower[i] = ath_get_rate_txpower(sc,bf,(unsigned char)((int)rix),(_Bool)((bool)((int)is_40) != 0),(_Bool)0);
      
#line 1245 
      goto ldv_53975;
    }
    else ;
    
#line 1249 
    rate = (struct ieee80211_rate const *)(common->sbands[(int)tx_info->band].bitrates + (int)(rates + i)->idx);
    
#line 1250 
    if ((unsigned int)tx_info->band == 0U && (rate->flags & 16U) == 0U) 
      
#line 1252 
      phy = 1; else 
#line 1254 
                    phy = 0;
    
#line 1256 
    info->rates[i].Rate = (unsigned int)rate->hw_value;
    
#line 1257 
    if ((unsigned int)rate->hw_value_short != 0U) {
      
#line 1258 
      if (((int)(rates + i)->flags & 4) != 0) 
#line 1259 
                                              info->rates[i].Rate |= (unsigned int)rate->hw_value_short; else ;
    }
    else 
#line 1261 
         is_sp = (_Bool)0;
    
#line 1264 
    if ((unsigned int)bf->bf_state.bfs_paprd != 0U) 
#line 1265 
                                                    info->rates[i].ChSel = (unsigned int)ah->txchainmask;
    else {
      u8 tmp_3;
      
#line 1267 
      tmp_3 = ath_txchainmask_reduction(sc,(unsigned char)((int)ah->txchainmask),info->rates[i].Rate);
      
#line 1267 
      info->rates[i].ChSel = (unsigned int)tmp_3;
    }
    
#line 1270 
    tmp_4 = ath9k_hw_computetxtime(sc->sc_ah,(unsigned char)((int)((unsigned char)phy)),(int)rate->bitrate * 100,(unsigned int)len,(unsigned short)((int)rix),(_Bool)((bool)((int)is_sp) != 0));
    
#line 1270 
    info->rates[i].PktDuration = (unsigned int)tmp_4;
    
#line 1273 
    is_cck = (_Bool)(info->rates[i].Rate + 4294967272U <= 6U);
    
#line 1274 
    info->txpower[i] = ath_get_rate_txpower(sc,bf,(unsigned char)((int)rix),(_Bool)0,(_Bool)((bool)((int)is_cck) != 0));
  }
  ldv_53975: 
#line 1276 
  ;
  
#line 1196 
  i += 1;
  ldv_53977: 
#line 1197 
  ;
  
#line 1196 
  if ((unsigned int)i <= 3U) 
#line 1198 
                             goto ldv_53976; else 
#line 1201 
                                                  goto ldv_53978;
  ldv_53978: 
#line 1202 
  ;
  
#line 1279 
  if (((int)bf->bf_state.bf_type & 2) != 0 && (int)(sc->sc_ah)->caps.rts_aggr_limit < len) 
    
#line 1280 
    info->flags &= 4294967291U; else ;
  
#line 1283 
  if ((info->flags & 4U) != 0U) 
#line 1284 
                                info->flags &= 4294967287U; else ;
  
#line 1285 
  return;
}


#line 1287  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static enum ath9k_pkt_type get_hw_packet_type(struct sk_buff *skb)
{
  struct ieee80211_hdr *hdr;
  enum ath9k_pkt_type htype;
  __le16 fc;
  int tmp_2;
  
#line 1293 
  hdr = (struct ieee80211_hdr *)skb->data;
  
#line 1294 
  fc = hdr->frame_control;
  
#line 1296 
  tmp_2 = ieee80211_is_beacon((unsigned short)((int)fc));
  
#line 1296 
  if (tmp_2 != 0) 
#line 1297 
                  htype = ATH9K_PKT_TYPE_BEACON;
  else {
    int tmp_1;
    
#line 1298 
    tmp_1 = ieee80211_is_probe_resp((unsigned short)((int)fc));
    
#line 1298 
    if (tmp_1 != 0) 
#line 1299 
                    htype = ATH9K_PKT_TYPE_PROBE_RESP;
    else {
      int tmp_0;
      
#line 1300 
      tmp_0 = ieee80211_is_atim((unsigned short)((int)fc));
      
#line 1300 
      if (tmp_0 != 0) 
#line 1301 
                      htype = ATH9K_PKT_TYPE_ATIM;
      else {
        int tmp;
        
#line 1302 
        tmp = ieee80211_is_pspoll((unsigned short)((int)fc));
        
#line 1302 
        if (tmp != 0) 
#line 1303 
                      htype = ATH9K_PKT_TYPE_PSPOLL; else 
#line 1305 
                                                          htype = ATH9K_PKT_TYPE_NORMAL;
      }
    }
  }
  
#line 1307 
  return htype;
}


#line 1310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static void ath_tx_fill_desc(struct ath_softc *sc, struct ath_buf *bf, struct ath_txq *txq, int len)
{
  struct ath_tx_info info;
  
#line 1313 
  struct ath_hw *ah = sc->sc_ah;
  
#line 1314 
  struct ath_buf *bf_first = (struct ath_buf *)0;
  
#line 1316 
  u32 rts_thresh = ((sc->hw)->wiphy)->rts_threshold;
  
#line 1317 
  bool rts = (_Bool)0;
  
#line 1319 
  memset((void *)(& info),0,184UL);
  
#line 1320 
  info.is_first = (_Bool)1;
  
#line 1321 
  info.is_last = (_Bool)1;
  
#line 1322 
  info.qcu = (unsigned char)txq->axq_qnum;
  
#line 1324 
  goto ldv_54001;
  ldv_54000: 
#line 1325 
  ;
  {
    
#line 1325 
    struct sk_buff *skb = bf->bf_mpdu;
    
#line 1326 
    struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
    
#line 1327 
    struct ath_frame_info *fi = get_frame_info(skb);
    
#line 1328 
    bool aggr = (_Bool)(((int)bf->bf_state.bf_type & 2) != 0);
    
#line 1330 
    info.type = get_hw_packet_type(skb);
    
#line 1331 
    if (bf->bf_next != (struct ath_buf *)0) 
#line 1332 
                                            info.link = (bf->bf_next)->bf_daddr;
    else 
      
#line 1334 
      if ((int)sc->tx99_state != 0) 
#line 1334 
                                    info.link = bf->bf_daddr; else 
#line 1334 
                                                                   info.link = 0ULL;
    
#line 1336 
    if (bf_first == (struct ath_buf *)0) {
      
#line 1337 
      bf_first = bf;
      
#line 1339 
      if (! sc->tx99_state) 
#line 1340 
                            info.flags = 16U; else ;
      
#line 1341 
      if ((tx_info->flags & 8U) != 0U || sc->tx.uapsdq == txq) 
#line 1343 
                                                               info.flags |= 4096U; else ;
      
#line 1345 
      if ((tx_info->flags & 4U) != 0U) 
#line 1346 
                                       info.flags |= 2U; else ;
      
#line 1347 
      if ((tx_info->flags & 4194304U) != 0U) 
#line 1348 
                                             info.flags |= 2048U; else ;
      
#line 1350 
      if ((unsigned int)bf->bf_state.bfs_paprd != 0U) 
#line 1351 
                                                      info.flags |= (unsigned int)bf->bf_state.bfs_paprd << 16; else ;
      
#line 1361 
      if (((int)aggr != 0 && bf == bf_first) && (long)(rts_thresh != 4294967295U) != 0L) {
        
#line 1366 
        if (rts_thresh == 0U || (unsigned int)len > rts_thresh) 
#line 1367 
                                                                rts = (_Bool)1; else ;
      }
      else ;
      
#line 1370 
      if (! aggr) 
#line 1371 
                  len = (int)fi->framelen; else ;
      
#line 1373 
      ath_buf_set_rate(sc,bf,& info,len,(_Bool)((bool)((int)rts) != 0));
    }
    else ;
    
#line 1376 
    info.buf_addr[0] = bf->bf_buf_addr;
    
#line 1377 
    info.buf_len[0] = (int)skb->len;
    
#line 1378 
    info.pkt_len = (int)fi->framelen;
    
#line 1379 
    info.keyix = fi->keyix;
    
#line 1380 
    info.keytype = (enum ath9k_key_type)fi->keytype;
    
#line 1382 
    if ((int)aggr != 0) {
      
#line 1383 
      if (bf == bf_first) 
#line 1384 
                          info.aggr = AGGR_BUF_FIRST;
      else 
        
#line 1385 
        if (bf_first->bf_lastbf == bf) 
#line 1386 
                                       info.aggr = AGGR_BUF_LAST; else 
                                                                    
#line 1388 
                                                                    info.aggr = AGGR_BUF_MIDDLE;
      
#line 1390 
      info.ndelim = bf->bf_state.ndelim;
      
#line 1391 
      info.aggr_len = (unsigned short)len;
    }
    else ;
    
#line 1394 
    if (bf_first->bf_lastbf == bf) 
#line 1395 
                                   bf_first = (struct ath_buf *)0; else ;
    
#line 1397 
    ath9k_hw_set_txdesc(ah,bf->bf_desc,& info);
    
#line 1398 
    bf = bf->bf_next;
  }
  ldv_54001: 
#line 1400 
  ;
  
#line 1324 
  if (bf != (struct ath_buf *)0) 
#line 1326 
                                 goto ldv_54000; else 
#line 1329 
                                                      goto ldv_54002;
  ldv_54002: 
#line 1330 
  ;
  
#line 1331 
  return;
}


#line 1403  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static void ath_tx_form_burst(struct ath_softc *sc, struct ath_txq *txq, struct ath_atx_tid *tid, struct list_head *bf_q, struct ath_buf *bf_first, struct sk_buff_head *tid_q)
{
  struct sk_buff *skb;
  
#line 1407 
  struct ath_buf *bf = bf_first;
  
#line 1407 
  struct ath_buf *bf_prev = (struct ath_buf *)0;
  
#line 1409 
  int nframes = 0;
  ldv_54017: 
#line 1410 
  ;
  {
    struct ieee80211_tx_info *tx_info;
    
#line 1413 
    skb = bf->bf_mpdu;
    
#line 1415 
    nframes += 1;
    
#line 1416 
    __skb_unlink(skb,tid_q);
    
#line 1417 
    list_add_tail(& bf->list,bf_q);
    
#line 1418 
    if (bf_prev != (struct ath_buf *)0) 
#line 1419 
                                        bf_prev->bf_next = bf; else ;
    
#line 1420 
    bf_prev = bf;
    
#line 1422 
    if (nframes > 1) 
#line 1423 
                     goto ldv_54016; else ;
    
#line 1425 
    bf = ath_tx_get_tid_subframe(sc,txq,tid,& tid_q);
    
#line 1426 
    if (bf == (struct ath_buf *)0) 
#line 1427 
                                   goto ldv_54016; else ;
    
#line 1429 
    tx_info = IEEE80211_SKB_CB(bf->bf_mpdu);
    
#line 1430 
    if ((tx_info->flags & 64U) != 0U) 
#line 1431 
                                      goto ldv_54016; else ;
    
#line 1433 
    ath_set_rates((tid->an)->vif,(tid->an)->sta,bf);
  }
  
#line 1411 
  goto ldv_54017;
  ldv_54016: 
#line 1412 
  ;
  
#line 1413 
  return;
}


#line 1437  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static bool ath_tx_sched_aggr(struct ath_softc *sc, struct ath_txq *txq, struct ath_atx_tid *tid, bool *stop)
{
  bool __retres;
  struct ath_buf *bf;
  struct ieee80211_tx_info *tx_info;
  struct sk_buff_head *tid_q;
  struct list_head bf_q;
  bool aggr;
  int tmp_0;
  bool tmp;
  int tmp_1;
  
#line 1444 
  int aggr_len = 0;
  
#line 1445 
  bool last = (_Bool)1;
  
#line 1447 
  tmp = ath_tid_has_buffered(tid);
  
#line 1447 
  if (tmp) 
#line 1447 
           tmp_0 = 0; else 
#line 1447 
                           tmp_0 = 1;
  
#line 1447 
  if (tmp_0) {
    
#line 1448 
    __retres = (_Bool)0;
    
#line 1448 
    goto return_label;
  }
  else ;
  
#line 1450 
  INIT_LIST_HEAD(& bf_q);
  
#line 1452 
  bf = ath_tx_get_tid_subframe(sc,txq,tid,& tid_q);
  
#line 1453 
  if (bf == (struct ath_buf *)0) {
    
#line 1454 
    __retres = (_Bool)0;
    
#line 1454 
    goto return_label;
  }
  else ;
  
#line 1456 
  tx_info = IEEE80211_SKB_CB(bf->bf_mpdu);
  
#line 1457 
  aggr = (_Bool)((tx_info->flags & 64U) != 0U);
  
#line 1458 
  if (((int)aggr != 0 && txq->axq_ampdu_depth > 1U) || (! aggr && txq->axq_depth > 7U)) {
    
#line 1460 
    *stop = (_Bool)1;
    
#line 1461 
    __retres = (_Bool)0;
    
#line 1461 
    goto return_label;
  }
  else ;
  
#line 1464 
  ath_set_rates((tid->an)->vif,(tid->an)->sta,bf);
  
#line 1465 
  if ((int)aggr != 0) 
#line 1466 
                      last = ath_tx_form_aggr(sc,txq,tid,& bf_q,bf,tid_q,& aggr_len); else 
                                                                    
#line 1469 
                                                                    ath_tx_form_burst(sc,txq,tid,& bf_q,bf,tid_q);
  
#line 1471 
  tmp_1 = list_empty((struct list_head const *)(& bf_q));
  
#line 1471 
  if (tmp_1 != 0) {
    
#line 1472 
    __retres = (_Bool)0;
    
#line 1472 
    goto return_label;
  }
  else ;
  
#line 1474 
  if ((int)(tid->ac)->clear_ps_filter != 0 || (int)(tid->an)->no_ps_filter != 0) {
    
#line 1475 
    (tid->ac)->clear_ps_filter = (_Bool)0;
    
#line 1476 
    tx_info->flags |= 8U;
  }
  else ;
  
#line 1479 
  ath_tx_fill_desc(sc,bf,txq,aggr_len);
  
#line 1480 
  ath_tx_txqaddbuf(sc,txq,& bf_q,(_Bool)0);
  
#line 1481 
  __retres = (_Bool)1;
  return_label: 
#line 1481 
                return __retres;
}


#line 1484  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
int ath_tx_aggr_start(struct ath_softc *sc, struct ieee80211_sta *sta, u16 tid, u16 *ssn)
{
  int __retres;
  struct ath_atx_tid *txtid;
  struct ath_txq *txq;
  struct ath_node *an;
  u8 density;
  u16 tmp;
  int tmp_0;
  
#line 1492 
  an = (struct ath_node *)(& sta->drv_priv);
  
#line 1493 
  txtid = & an->tid[(int)tid];
  
#line 1494 
  txq = (txtid->ac)->txq;
  
#line 1496 
  ath_txq_lock(sc,txq);
  
#line 1502 
  if ((int)sta->ht_cap.ht_supported != 0) {
    
#line 1503 
    an->maxampdu = (unsigned short)((unsigned int)((unsigned short)(1 << ((int)sta->ht_cap.ampdu_factor + 13))) + 65535U);
    
#line 1505 
    density = ath9k_parse_mpdudensity((unsigned char)((int)sta->ht_cap.ampdu_density));
    
#line 1506 
    an->mpdudensity = density;
  }
  else ;
  
#line 1510 
  ath_tx_tid_change_state(sc,txtid);
  
#line 1512 
  txtid->active = (_Bool)1;
  
#line 1513 
  tmp = txtid->seq_next;
  
#line 1513 
  txtid->seq_start = tmp;
  
#line 1513 
  *ssn = tmp;
  
#line 1514 
  txtid->bar_index = (signed char)(-1);
  
#line 1516 
  memset((void *)(& txtid->tx_buf),0,16UL);
  
#line 1517 
  tmp_0 = 0;
  
#line 1517 
  txtid->baw_tail = tmp_0;
  
#line 1517 
  txtid->baw_head = tmp_0;
  
#line 1519 
  ath_txq_unlock_complete(sc,txq);
  
#line 1521 
  __retres = 0;
  
#line 1521 
  return __retres;
}


#line 1524  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
void ath_tx_aggr_stop(struct ath_softc *sc, struct ieee80211_sta *sta, u16 tid)
{
  
#line 1526 
  struct ath_node *an = (struct ath_node *)(& sta->drv_priv);
  
#line 1527 
  struct ath_atx_tid *txtid = & an->tid[(int)tid];
  
#line 1528 
  struct ath_txq *txq = (txtid->ac)->txq;
  
#line 1530 
  ath_txq_lock(sc,txq);
  
#line 1531 
  txtid->active = (_Bool)0;
  
#line 1532 
  ath_tx_flush_tid(sc,txtid);
  
#line 1533 
  ath_tx_tid_change_state(sc,txtid);
  
#line 1534 
  ath_txq_unlock_complete(sc,txq);
  
#line 1535 
  return;
}


#line 1537  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
void ath_tx_aggr_sleep(struct ieee80211_sta *sta, struct ath_softc *sc, struct ath_node *an)
{
  struct ath_atx_tid *tid;
  struct ath_atx_ac *ac;
  struct ath_txq *txq;
  bool buffered;
  int tidno;
  
#line 1546 
  tidno = 0;
  
#line 1546 
  tid = & an->tid[tidno];
  
#line 1546 
  goto ldv_54061;
  ldv_54060: 
#line 1547 
  ;
  
#line 1549 
  ac = tid->ac;
  
#line 1550 
  txq = ac->txq;
  
#line 1552 
  ath_txq_lock(sc,txq);
  
#line 1554 
  if (! tid->sched) {
    
#line 1555 
    ath_txq_unlock(sc,txq);
    
#line 1556 
    goto ldv_54059;
  }
  else ;
  
#line 1559 
  buffered = ath_tid_has_buffered(tid);
  
#line 1561 
  tid->sched = (_Bool)0;
  
#line 1562 
  list_del(& tid->list);
  
#line 1564 
  if ((int)ac->sched != 0) {
    
#line 1565 
    ac->sched = (_Bool)0;
    
#line 1566 
    list_del(& ac->list);
  }
  else ;
  
#line 1569 
  ath_txq_unlock(sc,txq);
  
#line 1571 
  ieee80211_sta_set_buffered(sta,(unsigned char)((int)((unsigned char)tidno)),(_Bool)((bool)((int)buffered) != 0));
  ldv_54059: 
#line 1572 
  ;
  
#line 1547 
  tidno += 1;
  
#line 1547 
  tid += 1;
  ldv_54061: 
#line 1548 
  ;
  
#line 1546 
  if (tidno <= 15) 
#line 1549 
                   goto ldv_54060; else 
#line 1552 
                                        goto ldv_54062;
  ldv_54062: 
#line 1553 
  ;
  
#line 1554 
  return;
}


#line 1575  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
void ath_tx_aggr_wakeup(struct ath_softc *sc, struct ath_node *an)
{
  struct ath_atx_tid *tid;
  struct ath_atx_ac *ac;
  struct ath_txq *txq;
  int tidno;
  bool tmp;
  
#line 1582 
  tidno = 0;
  
#line 1582 
  tid = & an->tid[tidno];
  
#line 1582 
  goto ldv_54072;
  ldv_54071: 
#line 1583 
  ;
  
#line 1585 
  ac = tid->ac;
  
#line 1586 
  txq = ac->txq;
  
#line 1588 
  ath_txq_lock(sc,txq);
  
#line 1589 
  ac->clear_ps_filter = (_Bool)1;
  
#line 1591 
  tmp = ath_tid_has_buffered(tid);
  
#line 1591 
  if ((int)tmp != 0) {
    
#line 1592 
    ath_tx_queue_tid(sc,txq,tid);
    
#line 1593 
    ath_txq_schedule(sc,txq);
  }
  else ;
  
#line 1596 
  ath_txq_unlock_complete(sc,txq);
  
#line 1583 
  tidno += 1;
  
#line 1583 
  tid += 1;
  ldv_54072: 
#line 1584 
  ;
  
#line 1582 
  if (tidno <= 15) 
#line 1585 
                   goto ldv_54071; else 
#line 1588 
                                        goto ldv_54073;
  ldv_54073: 
#line 1589 
  ;
  
#line 1590 
  return;
}


#line 1600  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
void ath_tx_aggr_resume(struct ath_softc *sc, struct ieee80211_sta *sta, u16 tidno)
{
  struct ath_atx_tid *tid;
  struct ath_node *an;
  struct ath_txq *txq;
  bool tmp;
  
#line 1607 
  an = (struct ath_node *)(& sta->drv_priv);
  
#line 1608 
  tid = & an->tid[(int)tidno];
  
#line 1609 
  txq = (tid->ac)->txq;
  
#line 1611 
  ath_txq_lock(sc,txq);
  
#line 1613 
  tid->baw_size = (unsigned short)(8 << (int)sta->ht_cap.ampdu_factor);
  
#line 1615 
  tmp = ath_tid_has_buffered(tid);
  
#line 1615 
  if ((int)tmp != 0) {
    
#line 1616 
    ath_tx_queue_tid(sc,txq,tid);
    
#line 1617 
    ath_txq_schedule(sc,txq);
  }
  else ;
  
#line 1620 
  ath_txq_unlock_complete(sc,txq);
  
#line 1621 
  return;
}


#line 1623  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
void ath9k_release_buffered_frames(struct ieee80211_hw *hw, struct ieee80211_sta *sta, u16 tids, int nframes, enum ieee80211_frame_release_type reason, bool more_data)
{
  struct ieee80211_tx_info *info;
  struct list_head bf_q;
  struct ath_buf *bf;
  struct sk_buff_head *tid_q;
  int i;
  int tmp_1;
  struct ath_buf *tmp_2;
  
#line 1629 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 1630 
  struct ath_node *an = (struct ath_node *)(& sta->drv_priv);
  
#line 1631 
  struct ath_txq *txq = sc->tx.uapsdq;
  
#line 1634 
  struct ath_buf *bf_tail = (struct ath_buf *)0;
  
#line 1636 
  int sent = 0;
  
#line 1639 
  INIT_LIST_HEAD(& bf_q);
  
#line 1640 
  i = 0;
  
#line 1640 
  goto ldv_54106;
  ldv_54105: 
#line 1641 
  ;
  {
    struct ath_atx_tid *tid;
    
#line 1643 
    if (((int)tids & 1) == 0) 
#line 1644 
                              goto ldv_54101; else ;
    
#line 1646 
    tid = & an->tid[i];
    
#line 1648 
    ath_txq_lock(sc,(tid->ac)->txq);
    
#line 1649 
    goto ldv_54104;
    ldv_54103: 
#line 1650 
    ;
    
#line 1650 
    bf = ath_tx_get_tid_subframe(sc,sc->tx.uapsdq,tid,& tid_q);
    
#line 1651 
    if (bf == (struct ath_buf *)0) 
#line 1652 
                                   goto ldv_54102; else ;
    
#line 1654 
    __skb_unlink(bf->bf_mpdu,tid_q);
    
#line 1655 
    list_add_tail(& bf->list,& bf_q);
    
#line 1656 
    ath_set_rates((tid->an)->vif,(tid->an)->sta,bf);
    
#line 1657 
    if (((int)bf->bf_state.bf_type & 1) != 0) {
      
#line 1658 
      ath_tx_addto_baw(sc,tid,bf);
      
#line 1659 
      bf->bf_state.bf_type = (unsigned char)((unsigned int)bf->bf_state.bf_type & 253U);
    }
    else ;
    
#line 1661 
    if (bf_tail != (struct ath_buf *)0) 
#line 1662 
                                        bf_tail->bf_next = bf; else ;
    
#line 1664 
    bf_tail = bf;
    
#line 1665 
    nframes -= 1;
    
#line 1666 
    sent += 1;
    
#line 1667 
    sc->debug.stats.txstats[txq->axq_qnum].a_queued_hw += 1U;
    
#line 1669 
    if (an->sta != (struct ieee80211_sta *)0) {
      int tmp_0;
      bool tmp;
      
#line 1669 
      tmp = ath_tid_has_buffered(tid);
      
#line 1669 
      if (tmp) 
#line 1669 
               tmp_0 = 0; else 
#line 1669 
                               tmp_0 = 1;
      
#line 1669 
      if (tmp_0) 
#line 1670 
                 ieee80211_sta_set_buffered(an->sta,(unsigned char)((int)((unsigned char)i)),(_Bool)0); else ;
    }
    else ;
    ldv_54104: 
#line 1671 
    ;
    
#line 1649 
    if (nframes > 0) 
#line 1651 
                     goto ldv_54103; else 
#line 1654 
                                          goto ldv_54102;
    ldv_54102: 
#line 1655 
    ;
    
#line 1672 
    ath_txq_unlock_complete(sc,(tid->ac)->txq);
  }
  ldv_54101: 
#line 1674 
  ;
  
#line 1640 
  i += 1;
  
#line 1640 
  tids = (unsigned short)((int)tids >> 1);
  ldv_54106: 
#line 1641 
  ;
  
#line 1640 
  if ((unsigned int)tids != 0U && nframes != 0) 
#line 1642 
                                                goto ldv_54105; else 
                                                                  
#line 1645 
                                                                  goto ldv_54107;
  ldv_54107: 
#line 1646 
  ;
  
#line 1675 
  tmp_1 = list_empty((struct list_head const *)(& bf_q));
  
#line 1675 
  if (tmp_1 != 0) 
#line 1676 
                  goto return_label; else ;
  
#line 1678 
  info = IEEE80211_SKB_CB(bf_tail->bf_mpdu);
  
#line 1679 
  info->flags |= 268435456U;
  {
    
#line 1681 
    struct list_head const *__mptr = (struct list_head const *)bf_q.next;
    
#line 1681 
    tmp_2 = (struct ath_buf *)__mptr;
  }
  
#line 1681 
  bf = tmp_2;
  
#line 1682 
  ath_txq_lock(sc,txq);
  
#line 1683 
  ath_tx_fill_desc(sc,bf,txq,0);
  
#line 1684 
  ath_tx_txqaddbuf(sc,txq,& bf_q,(_Bool)0);
  
#line 1685 
  ath_txq_unlock(sc,txq);
  return_label: 
#line 1686 
                return;
}


#line 1692  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
struct ath_txq *ath_txq_setup(struct ath_softc *sc, int qtype, int subtype)
{
  struct ath_txq *__retres;
  struct ath9k_tx_queue_info qi;
  int axq_qnum;
  int i;
  
#line 1694 
  struct ath_hw *ah = sc->sc_ah;
  
#line 1696 
  int const subtype_txq_to_hwq[4U] = {3, 2, 1, 0};
  
#line 1704 
  memset((void *)(& qi),0,60UL);
  
#line 1705 
  qi.tqi_subtype = subtype_txq_to_hwq[subtype];
  
#line 1706 
  qi.tqi_aifs = 4294967295U;
  
#line 1707 
  qi.tqi_cwmin = 4294967295U;
  
#line 1708 
  qi.tqi_cwmax = 4294967295U;
  
#line 1709 
  qi.tqi_physCompBuf = 0U;
  
#line 1726 
  if ((ah->caps.hw_caps & 16U) != 0U) 
#line 1727 
                                      qi.tqi_qflags = TXQ_FLAG_TXINT_ENABLE;
  else 
    
#line 1729 
    if (qtype == 4) 
#line 1730 
                    qi.tqi_qflags = TXQ_FLAG_TXDESCINT_ENABLE; else 
#line 1732 
                                                                    qi.tqi_qflags = (enum ath9k_tx_queue_flags)6;
  
#line 1735 
  axq_qnum = ath9k_hw_setuptxqueue(ah,(enum ath9k_tx_queue)qtype,(struct ath9k_tx_queue_info const *)(& qi));
  
#line 1736 
  if (axq_qnum == -1) {
    
#line 1741 
    __retres = (struct ath_txq *)0;
    
#line 1741 
    goto return_label;
  }
  else ;
  
#line 1743 
  if ((sc->tx.txqsetup & (unsigned int)(1 << axq_qnum)) == 0U) {
    u8 tmp;
    
#line 1744 
    struct ath_txq *txq = & sc->tx.txq[axq_qnum];
    
#line 1746 
    txq->axq_qnum = (unsigned int)axq_qnum;
    
#line 1747 
    txq->mac80211_qnum = -1;
    
#line 1748 
    txq->axq_link = (void *)0;
    
#line 1749 
    __skb_queue_head_init(& txq->complete_q);
    
#line 1750 
    INIT_LIST_HEAD(& txq->axq_q);
    
#line 1751 
    spinlock_check(& txq->axq_lock);
    {
      struct lock_class_key __key;
      
#line 1751 
      __raw_spin_lock_init(& txq->axq_lock.__anonCompField_spinlock_18.rlock,"&(&txq->axq_lock)->rlock",& __key);
    }
    
#line 1752 
    txq->axq_depth = 0U;
    
#line 1753 
    txq->axq_ampdu_depth = 0U;
    
#line 1754 
    txq->axq_tx_inprogress = (_Bool)0;
    
#line 1755 
    sc->tx.txqsetup |= (unsigned int)(1 << axq_qnum);
    
#line 1757 
    tmp = (unsigned char)0U;
    
#line 1757 
    txq->txq_tailidx = tmp;
    
#line 1757 
    txq->txq_headidx = tmp;
    
#line 1758 
    i = 0;
    
#line 1758 
    goto ldv_54123;
    ldv_54122: 
#line 1759 
    ;
    
#line 1759 
    INIT_LIST_HEAD(& txq->txq_fifo[i]);
    
#line 1758 
    i += 1;
    ldv_54123: 
#line 1759 
    ;
    
#line 1758 
    if (i <= 7) 
#line 1760 
                goto ldv_54122; else 
#line 1763 
                                     goto ldv_54124;
    ldv_54124: 
#line 1764 
    ;
  }
  else ;
  
#line 1761 
  __retres = & sc->tx.txq[axq_qnum];
  return_label: 
#line 1761 
                return __retres;
}


#line 1764  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
int ath_txq_update(struct ath_softc *sc, int qnum, struct ath9k_tx_queue_info *qinfo)
{
  struct ath9k_tx_queue_info qi;
  int tmp_1;
  bool tmp_0;
  
#line 1767 
  struct ath_hw *ah = sc->sc_ah;
  
#line 1768 
  int error = 0;
  
#line 1771 
  if ((long)(sc->tx.txq[qnum].axq_qnum != (unsigned int)qnum) != 0L) {
    
#line 1773 
    ldv_inline_asm();
    
#line 1771 
    ;
  }
  else ;
  
#line 1773 
  ath9k_hw_get_txq_props(ah,qnum,& qi);
  
#line 1774 
  qi.tqi_aifs = qinfo->tqi_aifs;
  
#line 1775 
  qi.tqi_cwmin = qinfo->tqi_cwmin;
  
#line 1776 
  qi.tqi_cwmax = qinfo->tqi_cwmax;
  
#line 1777 
  qi.tqi_burstTime = qinfo->tqi_burstTime;
  
#line 1778 
  qi.tqi_readyTime = qinfo->tqi_readyTime;
  
#line 1780 
  tmp_0 = ath9k_hw_set_txq_props(ah,qnum,(struct ath9k_tx_queue_info const *)(& qi));
  
#line 1780 
  if (tmp_0) 
#line 1780 
             tmp_1 = 0; else 
#line 1780 
                             tmp_1 = 1;
  
#line 1780 
  if (tmp_1) {
    struct ath_common *tmp;
    
#line 1781 
    ;
    
#line 1781 
    tmp = ath9k_hw_common(sc->sc_ah);
    
#line 1781 
    ath_printk("\001",(struct ath_common const *)tmp,"Unable to update hardware queue %u!\n",qnum);
    
#line 1783 
    error = -5;
  }
  else 
#line 1785 
       ath9k_hw_resettxqueue(ah,(unsigned int)qnum);
  
#line 1788 
  return error;
}


#line 1791  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
int ath_cabq_update(struct ath_softc *sc)
{
  int __retres;
  struct ath9k_tx_queue_info qi;
  
#line 1794 
  struct ath_beacon_config *cur_conf = & (sc->cur_chan)->beacon;
  
#line 1795 
  int qnum = (int)(sc->beacon.cabq)->axq_qnum;
  
#line 1797 
  ath9k_hw_get_txq_props(sc->sc_ah,qnum,& qi);
  
#line 1799 
  qi.tqi_readyTime = (unsigned int)(((cur_conf->beacon_interval << 10) * 80) / 100);
  
#line 1801 
  ath_txq_update(sc,qnum,& qi);
  
#line 1803 
  __retres = 0;
  
#line 1803 
  return __retres;
}


#line 1806  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static void ath_drain_txq_list(struct ath_softc *sc, struct ath_txq *txq, struct list_head *list)
{
  struct ath_buf *bf;
  struct ath_buf *lastbf;
  struct list_head bf_head;
  struct ath_tx_status ts;
  struct ath_buf *tmp;
  int tmp_0;
  
#line 1813 
  memset((void *)(& ts),0,48UL);
  
#line 1814 
  ts.ts_status = (unsigned char)64U;
  
#line 1815 
  INIT_LIST_HEAD(& bf_head);
  
#line 1817 
  goto ldv_54150;
  ldv_54151: 
#line 1818 
  ;
  {
    
#line 1818 
    struct list_head const *__mptr = (struct list_head const *)list->next;
    
#line 1818 
    tmp = (struct ath_buf *)__mptr;
  }
  
#line 1818 
  bf = tmp;
  
#line 1820 
  if ((int)bf->bf_state.stale != 0) {
    
#line 1821 
    list_del(& bf->list);
    
#line 1823 
    ath_tx_return_buffer(sc,bf);
    
#line 1824 
    goto ldv_54150;
  }
  else ;
  
#line 1827 
  lastbf = bf->bf_lastbf;
  
#line 1828 
  list_cut_position(& bf_head,list,& lastbf->list);
  
#line 1829 
  ath_tx_process_buffer(sc,txq,& ts,bf,& bf_head);
  ldv_54150: 
#line 1830 
  ;
  
#line 1817 
  tmp_0 = list_empty((struct list_head const *)list);
  
#line 1817 
  if (tmp_0 == 0) 
#line 1819 
                  goto ldv_54151; else 
#line 1822 
                                       goto ldv_54152;
  ldv_54152: 
#line 1823 
  ;
  
#line 1824 
  return;
}


#line 1839  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
void ath_draintxq(struct ath_softc *sc, struct ath_txq *txq)
{
  
#line 1841 
  ath_txq_lock(sc,txq);
  
#line 1843 
  if (((sc->sc_ah)->caps.hw_caps & 16U) != 0U) {
    int tmp;
    
#line 1844 
    int idx = (int)txq->txq_tailidx;
    
#line 1846 
    goto ldv_54159;
    ldv_54158: 
#line 1847 
    ;
    
#line 1847 
    ath_drain_txq_list(sc,txq,& txq->txq_fifo[idx]);
    
#line 1849 
    idx += 1;
    
#line 1849 
    idx &= 7;
    ldv_54159: 
#line 1850 
    ;
    
#line 1846 
    tmp = list_empty((struct list_head const *)(& txq->txq_fifo[idx]));
    
#line 1846 
    if (tmp == 0) 
#line 1848 
                  goto ldv_54158; else 
#line 1851 
                                       goto ldv_54160;
    ldv_54160: 
#line 1852 
    ;
    
#line 1851 
    txq->txq_tailidx = (unsigned char)idx;
  }
  else ;
  
#line 1854 
  txq->axq_link = (void *)0;
  
#line 1855 
  txq->axq_tx_inprogress = (_Bool)0;
  
#line 1856 
  ath_drain_txq_list(sc,txq,& txq->axq_q);
  
#line 1858 
  ath_txq_unlock_complete(sc,txq);
  
#line 1859 
  return;
}


#line 1861  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
bool ath_drain_all_txq(struct ath_softc *sc)
{
  bool __retres;
  struct ath_txq *txq;
  int i;
  int tmp_0;
  u32 tmp_1;
  
#line 1863 
  struct ath_hw *ah = sc->sc_ah;
  
#line 1864 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 1867 
  u32 npend = 0U;
  
#line 1869 
  tmp_0 = constant_test_bit(0L,(unsigned long const volatile *)(& common->op_flags));
  
#line 1869 
  if (tmp_0 != 0) {
    
#line 1870 
    __retres = (_Bool)1;
    
#line 1870 
    goto return_label;
  }
  else ;
  
#line 1872 
  ath9k_hw_abort_tx_dma(ah);
  
#line 1875 
  i = 0;
  
#line 1875 
  goto ldv_54171;
  ldv_54170: 
#line 1876 
  ;
  
#line 1876 
  if ((sc->tx.txqsetup & (unsigned int)(1 << i)) == 0U) 
#line 1877 
                                                        goto ldv_54169; else ;
  
#line 1879 
  if (sc->tx.txq[i].axq_depth == 0U) 
#line 1880 
                                     goto ldv_54169; else ;
  
#line 1882 
  tmp_1 = ath9k_hw_numtxpending(ah,sc->tx.txq[i].axq_qnum);
  
#line 1882 
  if (tmp_1 != 0U) 
#line 1883 
                   npend = (unsigned int)(1UL << i) | npend; else ;
  ldv_54169: 
#line 1884 
  ;
  
#line 1875 
  i += 1;
  ldv_54171: 
#line 1876 
  ;
  
#line 1875 
  if (i <= 9) 
#line 1877 
              goto ldv_54170; else 
#line 1880 
                                   goto ldv_54172;
  ldv_54172: 
#line 1881 
  ;
  
#line 1886 
  if (npend != 0U) 
#line 1887 
                   ath_printk("\001",(struct ath_common const *)common,"Failed to stop TX DMA, queues=0x%03x!\n",npend); else ;
  
#line 1889 
  i = 0;
  
#line 1889 
  goto ldv_54175;
  ldv_54174: 
#line 1890 
  ;
  
#line 1890 
  if ((sc->tx.txqsetup & (unsigned int)(1 << i)) == 0U) 
#line 1891 
                                                        goto ldv_54173; else ;
  
#line 1898 
  txq = & sc->tx.txq[i];
  
#line 1899 
  txq->stopped = (_Bool)0;
  
#line 1900 
  ath_draintxq(sc,txq);
  ldv_54173: 
#line 1901 
  ;
  
#line 1889 
  i += 1;
  ldv_54175: 
#line 1890 
  ;
  
#line 1889 
  if (i <= 9) 
#line 1891 
              goto ldv_54174; else 
#line 1894 
                                   goto ldv_54176;
  ldv_54176: 
#line 1895 
  ;
  
#line 1903 
  __retres = (_Bool)(npend == 0U);
  return_label: 
#line 1903 
                return __retres;
}


#line 1906  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
void ath_tx_cleanupq(struct ath_softc *sc, struct ath_txq *txq)
{
  
#line 1908 
  ath9k_hw_releasetxqueue(sc->sc_ah,txq->axq_qnum);
  
#line 1909 
  sc->tx.txqsetup &= (unsigned int)(~ (1 << txq->axq_qnum));
  
#line 1910 
  return;
}


#line 1915  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
void ath_txq_schedule(struct ath_softc *sc, struct ath_txq *txq)
{
  struct ath_atx_ac *ac;
  struct ath_atx_ac *last_ac;
  struct ath_atx_tid *tid;
  struct ath_atx_tid *last_tid;
  struct list_head *ac_list;
  int tmp_0;
  int tmp_1;
  struct ath_atx_ac *tmp_2;
  int tmp_11;
  
#line 1917 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 1921 
  bool sent = (_Bool)0;
  
#line 1923 
  if (txq->mac80211_qnum < 0) 
#line 1924 
                              goto return_label; else ;
  
#line 1926 
  tmp_0 = constant_test_bit(4L,(unsigned long const volatile *)(& common->op_flags));
  
#line 1926 
  if (tmp_0 != 0) 
#line 1927 
                  goto return_label; else ;
  
#line 1929 
  ldv_spin_lock_bh_80(& sc->chan_lock);
  
#line 1930 
  ac_list = & (sc->cur_chan)->acq[txq->mac80211_qnum];
  
#line 1932 
  tmp_1 = list_empty((struct list_head const *)ac_list);
  
#line 1932 
  if (tmp_1 != 0) {
    
#line 1933 
    ldv_spin_unlock_bh_81(& sc->chan_lock);
    
#line 1934 
    goto return_label;
  }
  else ;
  
#line 1937 
  rcu_read_lock();
  {
    
#line 1939 
    struct list_head const *__mptr = (struct list_head const *)ac_list->prev;
    
#line 1939 
    tmp_2 = (struct ath_atx_ac *)__mptr + 18446744073709551608U;
  }
  
#line 1939 
  last_ac = tmp_2;
  
#line 1940 
  goto ldv_54208;
  ldv_54207: 
#line 1941 
  ;
  {
    struct ath_atx_ac *tmp_3;
    struct ath_atx_tid *tmp_4;
    struct ath_atx_tid *tmp_5;
    bool tmp_6;
    bool tmp_7;
    int tmp_8;
    int tmp_9;
    
#line 1941 
    bool stop = (_Bool)0;
    
#line 1943 
    if ((int)(sc->cur_chan)->stopped != 0) 
#line 1944 
                                           goto ldv_54195; else ;
    {
      
#line 1946 
      struct list_head const *__mptr_0 = (struct list_head const *)ac_list->next;
      
#line 1946 
      tmp_3 = (struct ath_atx_ac *)__mptr_0 + 18446744073709551608U;
    }
    
#line 1946 
    ac = tmp_3;
    {
      
#line 1947 
      struct list_head const *__mptr_1 = (struct list_head const *)ac->tid_q.prev;
      
#line 1947 
      tmp_4 = (struct ath_atx_tid *)__mptr_1;
    }
    
#line 1947 
    last_tid = tmp_4;
    
#line 1948 
    list_del(& ac->list);
    
#line 1949 
    ac->sched = (_Bool)0;
    
#line 1951 
    goto ldv_54204;
    ldv_54203: 
#line 1952 
    ;
    {
      
#line 1953 
      struct list_head const *__mptr_2 = (struct list_head const *)ac->tid_q.next;
      
#line 1953 
      tmp_5 = (struct ath_atx_tid *)__mptr_2;
    }
    
#line 1953 
    tid = tmp_5;
    
#line 1955 
    list_del(& tid->list);
    
#line 1956 
    tid->sched = (_Bool)0;
    
#line 1958 
    tmp_6 = ath_tx_sched_aggr(sc,txq,tid,& stop);
    
#line 1958 
    if ((int)tmp_6 != 0) 
#line 1959 
                         sent = (_Bool)1; else ;
    
#line 1965 
    tmp_7 = ath_tid_has_buffered(tid);
    
#line 1965 
    if ((int)tmp_7 != 0) 
#line 1966 
                         ath_tx_queue_tid(sc,txq,tid); else ;
    
#line 1968 
    if ((int)stop != 0 || tid == last_tid) 
#line 1969 
                                           goto ldv_54202; else ;
    ldv_54204: 
#line 1970 
    ;
    
#line 1951 
    tmp_8 = list_empty((struct list_head const *)(& ac->tid_q));
    
#line 1951 
    if (tmp_8 == 0) 
#line 1953 
                    goto ldv_54203; else 
#line 1956 
                                         goto ldv_54202;
    ldv_54202: 
#line 1957 
    ;
    
#line 1972 
    tmp_9 = list_empty((struct list_head const *)(& ac->tid_q));
    
#line 1972 
    if (tmp_9 == 0) {
      
#line 1972 
      if (! ac->sched) {
        
#line 1973 
        ac->sched = (_Bool)1;
        
#line 1974 
        list_add_tail(& ac->list,ac_list);
      }
      else ;
    }
    else ;
    
#line 1977 
    if ((int)stop != 0) 
#line 1978 
                        goto ldv_54195; else ;
    
#line 1980 
    if (ac == last_ac) {
      struct ath_atx_ac *tmp_10;
      
#line 1981 
      if (! sent) 
#line 1982 
                  goto ldv_54195; else ;
      
#line 1984 
      sent = (_Bool)0;
      {
        
#line 1985 
        struct list_head const *__mptr_3 = (struct list_head const *)ac_list->prev;
        
#line 1985 
        tmp_10 = (struct ath_atx_ac *)__mptr_3 + 18446744073709551608U;
      }
      
#line 1985 
      last_ac = tmp_10;
    }
    else ;
  }
  ldv_54208: 
#line 1989 
  ;
  
#line 1940 
  tmp_11 = list_empty((struct list_head const *)ac_list);
  
#line 1940 
  if (tmp_11 == 0) 
#line 1942 
                   goto ldv_54207; else 
#line 1945 
                                        goto ldv_54195;
  ldv_54195: 
#line 1946 
  ;
  
#line 1990 
  rcu_read_unlock();
  
#line 1991 
  ldv_spin_unlock_bh_82(& sc->chan_lock);
  return_label: 
#line 1992 
                return;
}


#line 1994  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
void ath_txq_schedule_all(struct ath_softc *sc)
{
  struct ath_txq *txq;
  int i;
  
#line 1999 
  i = 0;
  
#line 1999 
  goto ldv_54215;
  ldv_54214: 
#line 2000 
  ;
  
#line 2000 
  txq = sc->tx.txq_map[i];
  
#line 2002 
  ldv_spin_lock_bh_83(& txq->axq_lock);
  
#line 2003 
  ath_txq_schedule(sc,txq);
  
#line 2004 
  ldv_spin_unlock_bh_84(& txq->axq_lock);
  
#line 1999 
  i += 1;
  ldv_54215: 
#line 2000 
  ;
  
#line 1999 
  if (i <= 3) 
#line 2001 
              goto ldv_54214; else 
#line 2004 
                                   goto ldv_54216;
  ldv_54216: 
#line 2005 
  ;
  
#line 2006 
  return;
}


#line 2016  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static void ath_tx_txqaddbuf(struct ath_softc *sc, struct ath_txq *txq, struct list_head *head, bool internal)
{
  struct ath_buf *bf;
  struct ath_buf *bf_last;
  bool edma;
  int tmp_0;
  struct ath_buf *tmp_1;
  struct ath_buf *tmp_2;
  
#line 2019 
  struct ath_hw *ah = sc->sc_ah;
  
#line 2020 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 2022 
  bool puttxbuf = (_Bool)0;
  
#line 2030 
  tmp_0 = list_empty((struct list_head const *)head);
  
#line 2030 
  if (tmp_0 != 0) 
#line 2031 
                  goto return_label; else ;
  
#line 2033 
  edma = (_Bool)((ah->caps.hw_caps & 16U) != 0U);
  {
    
#line 2034 
    struct list_head const *__mptr = (struct list_head const *)head->next;
    
#line 2034 
    tmp_1 = (struct ath_buf *)__mptr;
  }
  
#line 2034 
  bf = tmp_1;
  {
    
#line 2035 
    struct list_head const *__mptr_0 = (struct list_head const *)head->prev;
    
#line 2035 
    tmp_2 = (struct ath_buf *)__mptr_0;
  }
  
#line 2035 
  bf_last = tmp_2;
  
#line 2037 
  if ((common->debug_mask & 2) != 0) 
#line 2037 
                                     ath_printk("\001",(struct ath_common const *)common,"qnum: %d, txq depth: %d\n",txq->axq_qnum,txq->axq_depth); else ;
  
#line 2040 
  if ((int)edma != 0) {
    int tmp_3;
    
#line 2040 
    tmp_3 = list_empty((struct list_head const *)(& txq->txq_fifo[(int)txq->txq_headidx]));
    
#line 2040 
    if (tmp_3 != 0) {
      
#line 2041 
      list_splice_tail_init(head,& txq->txq_fifo[(int)txq->txq_headidx]);
      
#line 2042 
      txq->txq_headidx = (u8)((int)txq->txq_headidx + 1);
      
#line 2042 
      txq->txq_headidx = (unsigned char)((unsigned int)txq->txq_headidx & 7U);
      
#line 2043 
      puttxbuf = (_Bool)1;
    }
    else 
#line 2040 
         goto _LAND;
  }
  else {
    _LAND: {
             
#line 2045 
             list_splice_tail_init(head,& txq->axq_q);
             
#line 2047 
             if (txq->axq_link != (void *)0) {
               
#line 2048 
               ath9k_hw_set_desc_link(ah,txq->axq_link,(unsigned int)bf->bf_daddr);
               
#line 2049 
               if ((common->debug_mask & 128) != 0) 
#line 2049 
                                                    ath_printk("\001",(struct ath_common const *)common,"link[%u] (%p)=%llx (%p)\n",txq->axq_qnum,txq->axq_link,bf->bf_daddr,bf->bf_desc); else ;
             }
             else 
               
#line 2052 
               if (! edma) 
#line 2053 
                           puttxbuf = (_Bool)1; else ;
             
#line 2055 
             txq->axq_link = bf_last->bf_desc;
           }
  }
  
#line 2058 
  if ((int)puttxbuf != 0) {
    
#line 2059 
    sc->debug.stats.txstats[txq->axq_qnum].puttxbuf += 1U;
    
#line 2060 
    ath9k_hw_puttxbuf(ah,txq->axq_qnum,(unsigned int)bf->bf_daddr);
    
#line 2061 
    if ((common->debug_mask & 128) != 0) 
#line 2061 
                                         ath_printk("\001",(struct ath_common const *)common,"TXDP[%u] = %llx (%p)\n",txq->axq_qnum,bf->bf_daddr,bf->bf_desc); else ;
  }
  else ;
  
#line 2065 
  if (! edma || (int)sc->tx99_state != 0) {
    
#line 2066 
    sc->debug.stats.txstats[txq->axq_qnum].txstart += 1U;
    
#line 2067 
    ath9k_hw_txstart(ah,txq->axq_qnum);
  }
  else ;
  
#line 2070 
  if (! internal) {
    bool tmp_4;
    
#line 2071 
    goto ldv_54234;
    ldv_54233: 
#line 2072 
    ;
    
#line 2072 
    txq->axq_depth += 1U;
    
#line 2073 
    tmp_4 = bf_is_ampdu_not_probing(bf);
    
#line 2073 
    if ((int)tmp_4 != 0) 
#line 2074 
                         txq->axq_ampdu_depth += 1U; else ;
    
#line 2076 
    bf_last = bf->bf_lastbf;
    
#line 2077 
    bf = bf_last->bf_next;
    
#line 2078 
    bf_last->bf_next = (struct ath_buf *)0;
    ldv_54234: 
#line 2079 
    ;
    
#line 2071 
    if (bf != (struct ath_buf *)0) 
#line 2073 
                                   goto ldv_54233; else 
#line 2076 
                                                        goto ldv_54235;
    ldv_54235: 
#line 2077 
    ;
  }
  else ;
  return_label: 
#line 2079 
                return;
}


#line 2083  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static void ath_tx_send_normal(struct ath_softc *sc, struct ath_txq *txq, struct ath_atx_tid *tid, struct sk_buff *skb)
{
  struct list_head bf_head;
  
#line 2086 
  struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
  
#line 2087 
  struct ath_frame_info *fi = get_frame_info(skb);
  
#line 2089 
  struct ath_buf *bf = fi->bf;
  
#line 2091 
  INIT_LIST_HEAD(& bf_head);
  
#line 2092 
  list_add_tail(& bf->list,& bf_head);
  
#line 2093 
  bf->bf_state.bf_type = (unsigned char)0U;
  
#line 2094 
  if (tid != (struct ath_atx_tid *)0 && (tx_info->flags & 64U) != 0U) {
    
#line 2095 
    bf->bf_state.bf_type = (unsigned char)1U;
    
#line 2096 
    ath_tx_addto_baw(sc,tid,bf);
  }
  else ;
  
#line 2099 
  bf->bf_next = (struct ath_buf *)0;
  
#line 2100 
  bf->bf_lastbf = bf;
  
#line 2101 
  ath_tx_fill_desc(sc,bf,txq,(int)fi->framelen);
  
#line 2102 
  ath_tx_txqaddbuf(sc,txq,& bf_head,(_Bool)0);
  
#line 2103 
  sc->debug.stats.txstats[txq->axq_qnum].queued += 1U;
  
#line 2104 
  return;
}


#line 2106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static void setup_frame_info(struct ieee80211_hw *hw, struct ieee80211_sta *sta, struct sk_buff *skb, int framelen)
{
  struct ieee80211_rate const *rate;
  enum ath9k_key_type keytype;
  u8 txpower;
  int tmp_2;
  
#line 2111 
  struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
  
#line 2112 
  struct ieee80211_key_conf *hw_key = tx_info->__anonCompField_ieee80211_tx_info_98.control.hw_key;
  
#line 2113 
  struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
  
#line 2115 
  struct ath_frame_info *fi = get_frame_info(skb);
  
#line 2116 
  struct ath_node *an = (struct ath_node *)0;
  
#line 2118 
  bool short_preamble = (_Bool)0;
  
#line 2126 
  if (tx_info->__anonCompField_ieee80211_tx_info_98.control.vif != (struct ieee80211_vif *)0 && (int)(tx_info->__anonCompField_ieee80211_tx_info_98.control.vif)->bss_conf.use_short_preamble != 0) 
    
#line 2128 
    short_preamble = (_Bool)1; else ;
  
#line 2130 
  rate = (struct ieee80211_rate const *)ieee80211_get_rts_cts_rate((struct ieee80211_hw const *)hw,(struct ieee80211_tx_info const *)tx_info);
  
#line 2131 
  tmp_2 = ath9k_cmn_get_hw_crypto_keytype(skb);
  
#line 2131 
  keytype = (enum ath9k_key_type)tmp_2;
  
#line 2133 
  if (sta != (struct ieee80211_sta *)0) 
#line 2134 
                                        an = (struct ath_node *)(& sta->drv_priv); else ;
  
#line 2136 
  if (tx_info->__anonCompField_ieee80211_tx_info_98.control.vif != (struct ieee80211_vif *)0) {
    
#line 2137 
    struct ieee80211_vif *vif = tx_info->__anonCompField_ieee80211_tx_info_98.control.vif;
    
#line 2139 
    txpower = (unsigned char)((unsigned int)((unsigned char)vif->bss_conf.txpower) * 2U);
  }
  else {
    
#line 2141 
    struct ath_softc *sc = (struct ath_softc *)hw->priv;
    
#line 2143 
    txpower = (unsigned char)(sc->cur_chan)->cur_txpower;
  }
  
#line 2146 
  memset((void *)fi,0,16UL);
  
#line 2147 
  fi->txq = (signed char)(-1);
  
#line 2148 
  if (hw_key != (struct ieee80211_key_conf *)0) 
#line 2149 
                                                fi->keyix = hw_key->hw_key_idx;
  else 
    
#line 2150 
    if (an != (struct ath_node *)0) {
      int tmp_3;
      
#line 2150 
      tmp_3 = ieee80211_is_data((unsigned short)((int)hdr->frame_control));
      
#line 2150 
      if (tmp_3 != 0) 
        
#line 2150 
        if ((int)an->ps_key > 0) 
#line 2151 
                                 fi->keyix = (unsigned char)an->ps_key; else 
                                                                    
#line 2153 
                                                                    fi->keyix = (unsigned char)255U;
      else 
#line 2153 
           fi->keyix = (unsigned char)255U;
    }
    else 
#line 2153 
         fi->keyix = (unsigned char)255U;
  
#line 2154 
  fi->keytype = (enum ath9k_key_type __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))keytype;
  
#line 2155 
  fi->framelen = (unsigned short)framelen;
  
#line 2156 
  fi->tx_power = txpower;
  
#line 2158 
  if (rate == (struct ieee80211_rate const *)0) 
#line 2159 
                                                goto return_label; else ;
  
#line 2160 
  fi->rtscts_rate = (unsigned char)rate->hw_value;
  
#line 2161 
  if ((int)short_preamble != 0) 
#line 2162 
                                fi->rtscts_rate = (unsigned char)((int)fi->rtscts_rate | (int)((unsigned char)rate->hw_value_short)); else ;
  return_label: 
#line 2163 
                return;
}


#line 2165  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
u8 ath_txchainmask_reduction(struct ath_softc *sc, u8 chainmask, u32 rate)
{
  u8 __retres;
  
#line 2167 
  struct ath_hw *ah = sc->sc_ah;
  
#line 2168 
  struct ath9k_channel *curchan = ah->curchan;
  
#line 2170 
  if (((ah->caps.hw_caps & 8192U) != 0U && ((unsigned long)curchan->channelFlags & 1UL) != 0UL) && ((unsigned int)chainmask == 7U && rate <= 143U)) {
    
#line 2172 
    __retres = (unsigned char)3U;
    
#line 2172 
    goto return_label;
  }
  else 
    
#line 2173 
    if (ah->hw_version.macVersion == 640U) {
      bool tmp;
      
#line 2173 
      tmp = ath9k_hw_btcoex_is_enabled(ah);
      
#line 2173 
      if ((int)tmp != 0) 
        
#line 2173 
        if (rate + 4294967272U <= 6U) {
          
#line 2175 
          __retres = (unsigned char)2U;
          
#line 2175 
          goto return_label;
        }
        else {
          
#line 2177 
          __retres = chainmask;
          
#line 2177 
          goto return_label;
        }
      else {
        
#line 2177 
        __retres = chainmask;
        
#line 2177 
        goto return_label;
      }
    }
    else {
      
#line 2177 
      __retres = chainmask;
      
#line 2177 
      goto return_label;
    }
  return_label: 
#line 2170 
                return __retres;
}


#line 2184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static struct ath_buf *ath_tx_setup_buffer(struct ath_softc *sc, struct ath_txq *txq, struct ath_atx_tid *tid, struct sk_buff *skb)
{
  struct ath_buf *__retres;
  struct ath_buf *bf;
  int fragno;
  u16 seqno;
  int tmp_4;
  
#line 2189 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 2190 
  struct ath_frame_info *fi = get_frame_info(skb);
  
#line 2191 
  struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
  
#line 2196 
  bf = ath_tx_get_buffer(sc);
  
#line 2197 
  if (bf == (struct ath_buf *)0) {
    
#line 2198 
    if ((common->debug_mask & 128) != 0) 
#line 2198 
                                         ath_printk("\001",(struct ath_common const *)common,"TX buffers are full\n"); else ;
    
#line 2199 
    __retres = (struct ath_buf *)0;
    
#line 2199 
    goto return_label;
  }
  else ;
  
#line 2202 
  bf->bf_lastbf = (struct ath_buf *)0;
  
#line 2202 
  bf->bf_next = (struct ath_buf *)0;
  
#line 2202 
  memset((void *)(& bf->bf_state),0,16UL);
  
#line 2204 
  if (tid != (struct ath_atx_tid *)0) {
    int tmp_2;
    
#line 2204 
    tmp_2 = ieee80211_is_data_present((unsigned short)((int)hdr->frame_control));
    
#line 2204 
    if (tmp_2 != 0) {
      int tmp_1;
      
#line 2205 
      fragno = (int)hdr->seq_ctrl & 15;
      
#line 2206 
      seqno = tid->seq_next;
      
#line 2207 
      hdr->seq_ctrl = (unsigned short)((int)tid->seq_next << 4U);
      
#line 2209 
      if (fragno != 0) 
#line 2210 
                       hdr->seq_ctrl = (unsigned short)((int)hdr->seq_ctrl | (int)((unsigned short)fragno)); else ;
      
#line 2212 
      tmp_1 = ieee80211_has_morefrags((unsigned short)((int)hdr->frame_control));
      
#line 2212 
      if (tmp_1 == 0) {
        
#line 2213 
        tid->seq_next = (u16)((int)tid->seq_next + 1);
        
#line 2213 
        tid->seq_next = (unsigned short)((unsigned int)tid->seq_next & 4095U);
      }
      else ;
      
#line 2215 
      bf->bf_state.seqno = seqno;
    }
    else ;
  }
  else ;
  
#line 2218 
  bf->bf_mpdu = skb;
  
#line 2220 
  bf->bf_buf_addr = dma_map_single_attrs(sc->dev,(void *)skb->data,(unsigned long)skb->len,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
  
#line 2222 
  tmp_4 = dma_mapping_error(sc->dev,bf->bf_buf_addr);
  
#line 2222 
  if ((long)(tmp_4 != 0) != 0L) {
    struct ath_common *tmp_3;
    
#line 2223 
    bf->bf_mpdu = (struct sk_buff *)0;
    
#line 2224 
    bf->bf_buf_addr = 0ULL;
    
#line 2225 
    tmp_3 = ath9k_hw_common(sc->sc_ah);
    
#line 2225 
    ath_printk("\001",(struct ath_common const *)tmp_3,"dma_mapping_error() on TX\n");
    
#line 2227 
    ath_tx_return_buffer(sc,bf);
    
#line 2228 
    __retres = (struct ath_buf *)0;
    
#line 2228 
    goto return_label;
  }
  else ;
  
#line 2231 
  fi->bf = bf;
  
#line 2233 
  __retres = bf;
  return_label: 
#line 2233 
                return __retres;
}


#line 2236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
void ath_assign_seq(struct ath_common *common, struct sk_buff *skb)
{
  struct ath_vif *avp;
  
#line 2238 
  struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
  
#line 2239 
  struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
  
#line 2240 
  struct ieee80211_vif *vif = info->__anonCompField_ieee80211_tx_info_98.control.vif;
  
#line 2243 
  if ((info->flags & 2U) == 0U) 
#line 2244 
                                goto return_label; else ;
  
#line 2246 
  if (vif == (struct ieee80211_vif *)0) 
#line 2247 
                                        goto return_label; else ;
  
#line 2249 
  avp = (struct ath_vif *)(& vif->drv_priv);
  
#line 2251 
  if ((info->flags & 16U) != 0U) 
#line 2252 
                                 avp->seq_no = (unsigned short)((unsigned int)avp->seq_no + 16U); else ;
  
#line 2254 
  hdr->seq_ctrl = (unsigned short)((unsigned int)hdr->seq_ctrl & 15U);
  
#line 2255 
  hdr->seq_ctrl = (unsigned short)((int)hdr->seq_ctrl | (int)avp->seq_no);
  return_label: 
#line 2256 
                return;
}


#line 2258  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static int ath_tx_prepare(struct ieee80211_hw *hw, struct sk_buff *skb, struct ath_tx_control *txctl)
{
  int __retres;
  struct ath_vif *avp;
  int padpos;
  int padsize;
  struct ath_common *tmp_1;
  unsigned int tmp_3;
  
#line 2261 
  struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
  
#line 2262 
  struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
  
#line 2263 
  struct ieee80211_sta *sta = txctl->sta;
  
#line 2264 
  struct ieee80211_vif *vif = info->__anonCompField_ieee80211_tx_info_98.control.vif;
  
#line 2266 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 2267 
  int frmlen = (int)(skb->len + 4U);
  
#line 2271 
  if (sta != (struct ieee80211_sta *)0) 
#line 2272 
                                        txctl->an = (struct ath_node *)(& sta->drv_priv);
  else 
    
#line 2273 
    if (vif != (struct ieee80211_vif *)0) {
      int tmp_0;
      
#line 2273 
      tmp_0 = ieee80211_is_data((unsigned short)((int)hdr->frame_control));
      
#line 2273 
      if (tmp_0 != 0) {
        
#line 2274 
        avp = (struct ath_vif *)(& vif->drv_priv);
        
#line 2275 
        txctl->an = & avp->mcast_node;
      }
      else ;
    }
    else ;
  
#line 2278 
  if (info->__anonCompField_ieee80211_tx_info_98.control.hw_key != (struct ieee80211_key_conf *)0) 
    
#line 2279 
    frmlen = (int)(info->__anonCompField_ieee80211_tx_info_98.control.hw_key)->icv_len + frmlen; else ;
  
#line 2281 
  ;
  
#line 2281 
  tmp_1 = ath9k_hw_common(sc->sc_ah);
  
#line 2281 
  ath_assign_seq(tmp_1,skb);
  
#line 2283 
  if ((vif != (struct ieee80211_vif *)0 && vif->type != (unsigned int)NL80211_IFTYPE_AP) && vif->type != (unsigned int)NL80211_IFTYPE_AP_VLAN) 
    
#line 2286 
    info->flags |= 8U;
  else {
    int tmp_2;
    
#line 2284 
    tmp_2 = ieee80211_is_data((unsigned short)((int)hdr->frame_control));
    
#line 2284 
    if (tmp_2 == 0) 
#line 2286 
                    info->flags |= 8U; else ;
  }
  
#line 2289 
  tmp_3 = ieee80211_hdrlen((unsigned short)((int)hdr->frame_control));
  
#line 2289 
  padpos = (int)tmp_3;
  
#line 2290 
  padsize = padpos & 3;
  
#line 2291 
  if (padsize != 0 && skb->len > (unsigned int)padpos) {
    unsigned int tmp_4;
    
#line 2292 
    tmp_4 = skb_headroom((struct sk_buff const *)skb);
    
#line 2292 
    ;
    
#line 2292 
    if (tmp_4 < (unsigned int)padsize) {
      
#line 2293 
      __retres = -12;
      
#line 2293 
      goto return_label;
    }
    else ;
    
#line 2295 
    skb_push(skb,(unsigned int)padsize);
    
#line 2296 
    memmove((void *)skb->data,(void const *)(skb->data + padsize),(unsigned long)padpos);
  }
  else ;
  
#line 2299 
  setup_frame_info(hw,sta,skb,frmlen);
  
#line 2300 
  __retres = 0;
  return_label: 
#line 2300 
                return __retres;
}


#line 2305  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
int ath_tx_start(struct ieee80211_hw *hw, struct sk_buff *skb, struct ath_tx_control *txctl)
{
  int __retres;
  struct ieee80211_hdr *hdr;
  struct ath_buf *bf;
  bool queue;
  bool ps_resp;
  int q;
  int ret;
  u16 tmp_1;
  int tmp_3;
  
#line 2309 
  struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
  
#line 2310 
  struct ieee80211_sta *sta = txctl->sta;
  
#line 2311 
  struct ieee80211_vif *vif = info->__anonCompField_ieee80211_tx_info_98.control.vif;
  
#line 2312 
  struct ath_frame_info *fi = get_frame_info(skb);
  
#line 2313 
  struct ath_vif *avp = (struct ath_vif *)0;
  
#line 2314 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 2315 
  struct ath_txq *txq = txctl->txq;
  
#line 2316 
  struct ath_atx_tid *tid = (struct ath_atx_tid *)0;
  
#line 2318 
  bool skip_uapsd = (_Bool)0;
  
#line 2321 
  if (vif != (struct ieee80211_vif *)0) 
#line 2322 
                                        avp = (struct ath_vif *)(& vif->drv_priv); else ;
  
#line 2324 
  if ((info->flags & 33554432U) != 0U) 
#line 2325 
                                       txctl->force_channel = (_Bool)1; else ;
  
#line 2327 
  ps_resp = (_Bool)((info->__anonCompField_ieee80211_tx_info_98.control.flags & 2U) != 0U);
  
#line 2329 
  ret = ath_tx_prepare(hw,skb,txctl);
  
#line 2330 
  if (ret != 0) {
    
#line 2331 
    __retres = ret;
    
#line 2331 
    goto return_label;
  }
  else ;
  
#line 2333 
  hdr = (struct ieee80211_hdr *)skb->data;
  
#line 2339 
  tmp_1 = skb_get_queue_mapping((struct sk_buff const *)skb);
  
#line 2339 
  q = (int)tmp_1;
  
#line 2341 
  ath_txq_lock(sc,txq);
  
#line 2342 
  if (sc->tx.txq_map[q] == txq) {
    
#line 2343 
    fi->txq = (signed char)q;
    
#line 2344 
    txq->pending_frames += 1;
    
#line 2344 
    ;
    
#line 2344 
    if ((unsigned int)txq->pending_frames > sc->tx.txq_max_pending[q]) {
      
#line 2345 
      if (! txq->stopped) {
        bool tmp_2;
        
#line 2346 
        tmp_2 = ath9k_is_chanctx_enabled();
        
#line 2346 
        if ((int)tmp_2 != 0) 
#line 2347 
                             ieee80211_stop_queue(sc->hw,(int)info->hw_queue); else 
                                                                    
#line 2349 
                                                                    ieee80211_stop_queue(sc->hw,q);
        
#line 2350 
        txq->stopped = (_Bool)1;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 2354 
  tmp_3 = ieee80211_is_data_present((unsigned short)((int)hdr->frame_control));
  
#line 2354 
  queue = (_Bool)(tmp_3 != 0);
  
#line 2360 
  if (((avp != (struct ath_vif *)0 && avp->chanctx != sc->cur_chan) || (int)(sc->cur_chan)->stopped != 0) && ! txctl->force_channel) {
    
#line 2362 
    if (txctl->an == (struct ath_node *)0) 
#line 2363 
                                           txctl->an = & avp->mcast_node; else ;
    
#line 2364 
    queue = (_Bool)1;
    
#line 2365 
    skip_uapsd = (_Bool)1;
  }
  else ;
  
#line 2368 
  if (txctl->an != (struct ath_node *)0 && (int)queue != 0) 
#line 2369 
                                                            tid = ath_get_skb_tid(sc,txctl->an,skb); else ;
  
#line 2371 
  if (! skip_uapsd && (int)ps_resp != 0) {
    
#line 2372 
    ath_txq_unlock(sc,txq);
    
#line 2373 
    txq = sc->tx.uapsdq;
    
#line 2374 
    ath_txq_lock(sc,txq);
  }
  else 
    
#line 2375 
    if (txctl->an != (struct ath_node *)0 && (int)queue != 0) {
      {
        
#line 2376 
        int __ret_warn_on = (tid->ac)->txq != txctl->txq;
        
#line 2376 
        if ((long)(__ret_warn_on != 0) != 0L) 
#line 2376 
                                              warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c",2376); else ;
        
#line 2376 
        long tmp_4 = (long)(__ret_warn_on != 0);
      }
      
#line 2378 
      if ((info->flags & 8U) != 0U) 
#line 2379 
                                    (tid->ac)->clear_ps_filter = (_Bool)1; else ;
      
#line 2385 
      sc->debug.stats.txstats[txq->axq_qnum].a_queued_sw += 1U;
      
#line 2386 
      __skb_queue_tail(& tid->buf_q,skb);
      
#line 2387 
      if (! (txctl->an)->sleeping) 
#line 2388 
                                   ath_tx_queue_tid(sc,txq,tid); else ;
      
#line 2390 
      ath_txq_schedule(sc,txq);
      
#line 2391 
      goto out;
    }
    else ;
  
#line 2394 
  bf = ath_tx_setup_buffer(sc,txq,tid,skb);
  
#line 2395 
  if (bf == (struct ath_buf *)0) {
    
#line 2396 
    ath_txq_skb_done(sc,txq,skb);
    
#line 2397 
    if ((unsigned int)txctl->paprd != 0U) 
#line 2398 
                                          dev_kfree_skb_any(skb); else 
                                                                    
#line 2400 
                                                                    ieee80211_free_txskb(sc->hw,skb);
    
#line 2401 
    goto out;
  }
  else ;
  
#line 2404 
  bf->bf_state.bfs_paprd = txctl->paprd;
  
#line 2406 
  if ((unsigned int)txctl->paprd != 0U) 
#line 2407 
                                        bf->bf_state.bfs_paprd_timestamp = jiffies; else ;
  
#line 2409 
  ath_set_rates(vif,sta,bf);
  
#line 2410 
  ath_tx_send_normal(sc,txq,tid,skb);
  out: 
#line 2412 
  ;
  
#line 2413 
  ath_txq_unlock(sc,txq);
  
#line 2415 
  __retres = 0;
  return_label: 
#line 2415 
                return __retres;
}


#line 2418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
void ath_tx_cabq(struct ieee80211_hw *hw, struct ieee80211_vif *vif, struct sk_buff *skb)
{
  struct ieee80211_hdr *hdr;
  struct ath_buf *bf;
  int max_duration;
  int tmp_1;
  struct ath_buf *tmp_2;
  
#line 2421 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 2422 
  struct ath_tx_control txctl = {.txq = sc->beacon.cabq, .an = (struct ath_node *)0, .sta = (struct ieee80211_sta *)0, .paprd = (unsigned char)0, .force_channel = (_Bool)0};
  
#line 2425 
  struct ath_tx_info info = {.qcu = (unsigned char)0, .is_first = (_Bool)0, .is_last = (_Bool)0, .aggr = 0, .ndelim = (unsigned char)0, .aggr_len = (unsigned short)0, .link = 0ULL, .pkt_len = 0, .flags = 0U, .buf_addr = {0ULL, 0ULL, 0ULL, 0ULL}, .buf_len = {0, 0, 0, 0}, .rates = {{.Tries = 0U, .Rate = 0U, .PktDuration = 0U, .ChSel = 0U, .RateFlags = 0U}, {.Tries = 0U, .Rate = 0U, .PktDuration = 0U, .ChSel = 0U, .RateFlags = 0U}, {.Tries = 0U, .Rate = 0U, .PktDuration = 0U, .ChSel = 0U, .RateFlags = 0U}, {.Tries = 0U, .Rate = 0U, .PktDuration = 0U, .ChSel = 0U, .RateFlags = 0U}}, .rtscts_rate = (unsigned char)0, .dur_update = (_Bool)0, .type = 0, .keytype = 0, .keyix = (unsigned char)0, .txpower = {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}};
  
#line 2427 
  struct ath_buf *bf_tail = (struct ath_buf *)0;
  
#line 2429 
  struct list_head bf_q = {.next = & bf_q, .prev = & bf_q};
  
#line 2430 
  int duration = 0;
  
#line 2433 
  max_duration = (((sc->cur_chan)->beacon.beacon_interval * 1000) * (int)(sc->cur_chan)->beacon.dtim_period) / 8;
  ldv_54343: 
#line 2436 
  ;
  {
    int tmp_0;
    
#line 2438 
    struct ath_frame_info *fi = get_frame_info(skb);
    
#line 2440 
    tmp_0 = ath_tx_prepare(hw,skb,& txctl);
    
#line 2440 
    if (tmp_0 != 0) 
#line 2441 
                    goto ldv_54342; else ;
    
#line 2443 
    bf = ath_tx_setup_buffer(sc,txctl.txq,(struct ath_atx_tid *)0,skb);
    
#line 2444 
    if (bf == (struct ath_buf *)0) 
#line 2445 
                                   goto ldv_54342; else ;
    
#line 2447 
    bf->bf_lastbf = bf;
    
#line 2448 
    ath_set_rates(vif,(struct ieee80211_sta *)0,bf);
    
#line 2449 
    ath_buf_set_rate(sc,bf,& info,(int)fi->framelen,(_Bool)0);
    
#line 2450 
    duration = (int)(info.rates[0].PktDuration + (unsigned int)duration);
    
#line 2451 
    if (bf_tail != (struct ath_buf *)0) 
#line 2452 
                                        bf_tail->bf_next = bf; else ;
    
#line 2454 
    list_add_tail(& bf->list,& bf_q);
    
#line 2455 
    bf_tail = bf;
    
#line 2456 
    skb = (struct sk_buff *)0;
    
#line 2458 
    if (duration > max_duration) 
#line 2459 
                                 goto ldv_54342; else ;
    
#line 2461 
    skb = ieee80211_get_buffered_bc(hw,vif);
  }
  
#line 2462 
  if (skb != (struct sk_buff *)0) 
#line 2464 
                                  goto ldv_54343; else 
#line 2467 
                                                       goto ldv_54342;
  ldv_54342: 
#line 2468 
  ;
  
#line 2464 
  if (skb != (struct sk_buff *)0) 
#line 2465 
                                  ieee80211_free_txskb(hw,skb); else ;
  
#line 2467 
  tmp_1 = list_empty((struct list_head const *)(& bf_q));
  
#line 2467 
  if (tmp_1 != 0) 
#line 2468 
                  goto return_label; else ;
  {
    
#line 2470 
    struct list_head const *__mptr = (struct list_head const *)bf_q.next;
    
#line 2470 
    tmp_2 = (struct ath_buf *)__mptr;
  }
  
#line 2470 
  bf = tmp_2;
  
#line 2471 
  hdr = (struct ieee80211_hdr *)(bf->bf_mpdu)->data;
  
#line 2473 
  if (((int)hdr->frame_control & 8192) != 0) {
    
#line 2474 
    hdr->frame_control = (unsigned short)((unsigned int)hdr->frame_control & 57343U);
    
#line 2475 
    dma_sync_single_for_device(sc->dev,bf->bf_buf_addr,30UL,(enum dma_data_direction)DMA_TO_DEVICE);
  }
  else ;
  
#line 2479 
  ath_txq_lock(sc,txctl.txq);
  
#line 2480 
  ath_tx_fill_desc(sc,bf,txctl.txq,0);
  
#line 2481 
  ath_tx_txqaddbuf(sc,txctl.txq,& bf_q,(_Bool)0);
  
#line 2482 
  sc->debug.stats.txstats[(txctl.txq)->axq_qnum].queued += 1U;
  
#line 2483 
  ath_txq_unlock(sc,txctl.txq);
  return_label: 
#line 2484 
                return;
}


#line 2490  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static void ath_tx_complete(struct ath_softc *sc, struct sk_buff *skb, int tx_flags, struct ath_txq *txq)
{
  int padpos;
  int padsize;
  unsigned long flags;
  unsigned int tmp_1;
  
#line 2493 
  struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
  
#line 2494 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 2495 
  struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
  
#line 2499 
  if ((common->debug_mask & 128) != 0) 
#line 2499 
                                       ath_printk("\001",(struct ath_common const *)common,"TX complete: skb: %p\n",skb); else ;
  
#line 2501 
  if ((sc->sc_ah)->caldata != (struct ath9k_hw_cal_data *)0) 
#line 2502 
                                                             set_bit(1L,(unsigned long volatile *)(& ((sc->sc_ah)->caldata)->cal_flags)); else ;
  
#line 2504 
  if ((tx_flags & 1) == 0) 
    
#line 2505 
    if ((tx_info->flags & 4U) != 0U) 
#line 2506 
                                     tx_info->flags |= 2147483648U; else 
                                                                    
#line 2508 
                                                                    tx_info->flags |= 512U;
  else ;
  
#line 2511 
  tmp_1 = ieee80211_hdrlen((unsigned short)((int)hdr->frame_control));
  
#line 2511 
  padpos = (int)tmp_1;
  
#line 2512 
  padsize = padpos & 3;
  
#line 2513 
  if (padsize != 0 && skb->len > (unsigned int)(padpos + padsize)) {
    
#line 2518 
    memmove((void *)(skb->data + padsize),(void const *)skb->data,(unsigned long)padpos);
    
#line 2519 
    skb_pull(skb,(unsigned int)padsize);
  }
  else ;
  
#line 2522 
  ldv___ldv_spin_lock_85(& sc->sc_pm_lock);
  
#line 2523 
  if (((unsigned long)sc->ps_flags & 8UL) != 0UL && txq->axq_depth == 0U) {
    
#line 2524 
    sc->ps_flags = (unsigned short)((unsigned int)sc->ps_flags & 65527U);
    
#line 2525 
    if ((common->debug_mask & 2048) != 0) 
#line 2525 
                                          ath_printk("\001",(struct ath_common const *)common,"Going back to sleep after having received TX status (0x%lx)\n",(unsigned long)sc->ps_flags & 15UL); else ;
  }
  else ;
  
#line 2532 
  ldv_spin_unlock_irqrestore_86(& sc->sc_pm_lock,flags);
  
#line 2534 
  __skb_queue_tail(& txq->complete_q,skb);
  
#line 2535 
  ath_txq_skb_done(sc,txq,skb);
  
#line 2536 
  return;
}


#line 2538  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static void ath_tx_complete_buf(struct ath_softc *sc, struct ath_buf *bf, struct ath_txq *txq, struct list_head *bf_q, struct ath_tx_status *ts, int txok)
{
  unsigned long flags;
  
#line 2542 
  struct sk_buff *skb = bf->bf_mpdu;
  
#line 2543 
  struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
  
#line 2545 
  int tx_flags = 0;
  
#line 2547 
  if (txok == 0) 
#line 2548 
                 tx_flags |= 1; else ;
  
#line 2550 
  if (((int)ts->ts_status & 2) != 0) 
#line 2551 
                                     tx_info->flags |= 256U; else ;
  
#line 2553 
  dma_unmap_single_attrs(sc->dev,bf->bf_buf_addr,(unsigned long)skb->len,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
  
#line 2554 
  bf->bf_buf_addr = 0ULL;
  
#line 2555 
  if ((int)sc->tx99_state != 0) 
#line 2556 
                                goto skip_tx_complete; else ;
  
#line 2558 
  if ((unsigned int)bf->bf_state.bfs_paprd != 0U) {
    int tmp_0;
    {
      unsigned long __dummy;
      unsigned long volatile __dummy2;
      
#line 2559 
      tmp_0 = 1;
    }
    
#line 2559 
    if (tmp_0 != 0) {
      int tmp_1;
      {
        unsigned long __dummy_0;
        unsigned long __dummy2_0;
        
#line 2559 
        tmp_1 = 1;
      }
      
#line 2559 
      if (tmp_1 != 0) {
        unsigned long tmp_2;
        
#line 2559 
        tmp_2 = msecs_to_jiffies(100U);
        
#line 2559 
        ;
        
#line 2559 
        if ((long)((bf->bf_state.bfs_paprd_timestamp + tmp_2) - jiffies) < 0L) 
          
#line 2562 
          dev_kfree_skb_any(skb); else 
#line 2564 
                                       complete(& sc->paprd_complete);
      }
      else 
#line 2564 
           complete(& sc->paprd_complete);
    }
    else 
#line 2564 
         complete(& sc->paprd_complete);
  }
  else {
    
#line 2566 
    ath_debug_stat_tx(sc,bf,ts,txq,(unsigned int)tx_flags);
    
#line 2567 
    ath_tx_complete(sc,skb,tx_flags,txq);
  }
  skip_tx_complete: 
#line 2569 
  ;
  
#line 2573 
  bf->bf_mpdu = (struct sk_buff *)0;
  
#line 2578 
  ldv___ldv_spin_lock_87(& sc->tx.txbuflock);
  
#line 2579 
  list_splice_tail_init(bf_q,& sc->tx.txbuf);
  
#line 2580 
  ldv_spin_unlock_irqrestore_88(& sc->tx.txbuflock,flags);
  
#line 2581 
  return;
}


#line 2583  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static void ath_tx_rc_status(struct ath_softc *sc, struct ath_buf *bf, struct ath_tx_status *ts, int nframes, int nbad, int txok)
{
  u8 i;
  u8 tx_rateindex;
  
#line 2587 
  struct sk_buff *skb = bf->bf_mpdu;
  
#line 2588 
  struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
  
#line 2589 
  struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
  
#line 2590 
  struct ieee80211_hw *hw = sc->hw;
  
#line 2591 
  struct ath_hw *ah = sc->sc_ah;
  
#line 2594 
  if (txok != 0) 
#line 2595 
                 tx_info->__anonCompField_ieee80211_tx_info_98.status.ack_signal = (int)ts->ts_rssi; else ;
  
#line 2597 
  tx_rateindex = ts->ts_rateindex;
  {
    
#line 2598 
    int __ret_warn_on = (int)hw->max_rates <= (int)tx_rateindex;
    
#line 2598 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 2598 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c",2598); else ;
    
#line 2598 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 2600 
  if ((tx_info->flags & 64U) != 0U) {
    
#line 2601 
    tx_info->flags |= 1024U;
    
#line 2603 
    if ((long)(nbad > nframes) != 0L) {
      
#line 2605 
      ldv_inline_asm();
      
#line 2603 
      ;
    }
    else ;
  }
  else ;
  
#line 2605 
  tx_info->__anonCompField_ieee80211_tx_info_98.status.ampdu_len = (unsigned char)nframes;
  
#line 2606 
  tx_info->__anonCompField_ieee80211_tx_info_98.status.ampdu_ack_len = (unsigned char)((int)((unsigned char)nframes) - (int)((unsigned char)nbad));
  
#line 2608 
  if (((int)ts->ts_status & 2) == 0 && (tx_info->flags & 4U) == 0U) {
    
#line 2622 
    if ((long)(((int)ts->ts_flags & 24) != 0) != 0L) {
      int tmp_0;
      
#line 2623 
      tmp_0 = ieee80211_is_data((unsigned short)((int)hdr->frame_control));
      
#line 2623 
      if (tmp_0 != 0) {
        
#line 2625 
        if ((int)ah->tx_trig_level >= (int)((unsigned short)(sc->sc_ah)->config.max_txtrig_level)) 
          
#line 2626 
          tx_info->__anonCompField_ieee80211_tx_info_98.status.rates[(int)tx_rateindex].count = (unsigned short __attribute__((__FRAMA_C_BITFIELD_SIZE__(5))))hw->max_rate_tries; else ;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 2630 
  i = (unsigned char)((unsigned int)tx_rateindex + 1U);
  
#line 2630 
  goto ldv_54395;
  ldv_54394: 
#line 2631 
  ;
  
#line 2631 
  tx_info->__anonCompField_ieee80211_tx_info_98.status.rates[(int)i].count = (unsigned short __attribute__((__FRAMA_C_BITFIELD_SIZE__(5))))0U;
  
#line 2632 
  tx_info->__anonCompField_ieee80211_tx_info_98.status.rates[(int)i].idx = (signed char)(-1);
  
#line 2630 
  i = (u8)((int)i + 1);
  ldv_54395: 
#line 2631 
  ;
  
#line 2630 
  if ((int)hw->max_rates > (int)i) 
#line 2632 
                                   goto ldv_54394; else 
#line 2635 
                                                        goto ldv_54396;
  ldv_54396: 
#line 2636 
  ;
  
#line 2635 
  tx_info->__anonCompField_ieee80211_tx_info_98.status.rates[(int)tx_rateindex].count = (unsigned short __attribute__((__FRAMA_C_BITFIELD_SIZE__(5))))((unsigned int)ts->ts_longretry + 1U);
  
#line 2636 
  return;
}


#line 2638  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static void ath_tx_processq(struct ath_softc *sc, struct ath_txq *txq)
{
  struct ath_buf *bf;
  struct ath_buf *lastbf;
  struct list_head bf_head;
  struct ath_desc *ds;
  struct ath_tx_status ts;
  int status;
  int tmp_1;
  int tmp_2;
  struct ath_buf *tmp_3;
  int tmp_6;
  
#line 2640 
  struct ath_hw *ah = sc->sc_ah;
  
#line 2641 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 2642 
  struct ath_buf *bf_held = (struct ath_buf *)0;
  
#line 2648 
  if ((common->debug_mask & 2) != 0) {
    u32 tmp_0;
    
#line 2648 
    ;
    
#line 2648 
    tmp_0 = ath9k_hw_gettxbuf(sc->sc_ah,txq->axq_qnum);
    
#line 2648 
    ;
    
#line 2648 
    ;
    
#line 2648 
    ath_printk("\001",(struct ath_common const *)common,"tx queue %d (%x), link %p\n",txq->axq_qnum,tmp_0,txq->axq_link);
  }
  else ;
  
#line 2652 
  ath_txq_lock(sc,txq);
  ldv_54415: 
#line 2653 
  ;
  
#line 2654 
  tmp_1 = constant_test_bit(4L,(unsigned long const volatile *)(& common->op_flags));
  
#line 2654 
  if (tmp_1 != 0) 
#line 2655 
                  goto ldv_54410; else ;
  
#line 2657 
  tmp_2 = list_empty((struct list_head const *)(& txq->axq_q));
  
#line 2657 
  if (tmp_2 != 0) {
    
#line 2658 
    txq->axq_link = (void *)0;
    
#line 2659 
    ath_txq_schedule(sc,txq);
    
#line 2660 
    goto ldv_54410;
  }
  else ;
  {
    
#line 2662 
    struct list_head const *__mptr = (struct list_head const *)txq->axq_q.next;
    
#line 2662 
    tmp_3 = (struct ath_buf *)__mptr;
  }
  
#line 2662 
  bf = tmp_3;
  
#line 2672 
  bf_held = (struct ath_buf *)0;
  
#line 2673 
  if ((int)bf->bf_state.stale != 0) {
    int tmp_4;
    struct ath_buf *tmp_5;
    
#line 2674 
    bf_held = bf;
    
#line 2675 
    tmp_4 = list_is_last((struct list_head const *)(& bf_held->list),(struct list_head const *)(& txq->axq_q));
    
#line 2675 
    if (tmp_4 != 0) 
#line 2676 
                    goto ldv_54410; else ;
    {
      
#line 2678 
      struct list_head const *__mptr_0 = (struct list_head const *)bf_held->list.next;
      
#line 2678 
      tmp_5 = (struct ath_buf *)__mptr_0;
    }
    
#line 2678 
    bf = tmp_5;
  }
  else ;
  
#line 2682 
  lastbf = bf->bf_lastbf;
  
#line 2683 
  ds = (struct ath_desc *)lastbf->bf_desc;
  
#line 2685 
  memset((void *)(& ts),0,48UL);
  
#line 2686 
  status = ath9k_hw_txprocdesc(ah,(void *)ds,& ts);
  
#line 2687 
  if (status == -115) 
#line 2688 
                      goto ldv_54410; else ;
  
#line 2690 
  sc->debug.stats.txstats[txq->axq_qnum].txprocdesc += 1U;
  
#line 2697 
  lastbf->bf_state.stale = (_Bool)1;
  
#line 2698 
  INIT_LIST_HEAD(& bf_head);
  
#line 2699 
  tmp_6 = list_is_singular((struct list_head const *)(& lastbf->list));
  
#line 2699 
  if (tmp_6 == 0) 
#line 2700 
                  list_cut_position(& bf_head,& txq->axq_q,lastbf->list.prev); else ;
  
#line 2703 
  if (bf_held != (struct ath_buf *)0) {
    
#line 2704 
    list_del(& bf_held->list);
    
#line 2705 
    ath_tx_return_buffer(sc,bf_held);
  }
  else ;
  
#line 2708 
  ath_tx_process_buffer(sc,txq,& ts,bf,& bf_head);
  
#line 2654 
  goto ldv_54415;
  ldv_54410: 
#line 2655 
  ;
  
#line 2710 
  ath_txq_unlock_complete(sc,txq);
  
#line 2711 
  return;
}


#line 2713  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
void ath_tx_tasklet(struct ath_softc *sc)
{
  int i;
  
#line 2715 
  struct ath_hw *ah = sc->sc_ah;
  
#line 2716 
  u32 qcumask = ah->intr_txqs & 1023U;
  
#line 2719 
  i = 0;
  
#line 2719 
  goto ldv_54423;
  ldv_54422: 
#line 2720 
  ;
  
#line 2720 
  if ((sc->tx.txqsetup & (unsigned int)(1 << i)) != 0U && ((unsigned int)(1 << i) & qcumask) != 0U) 
    
#line 2721 
    ath_tx_processq(sc,& sc->tx.txq[i]); else ;
  
#line 2719 
  i += 1;
  ldv_54423: 
#line 2720 
  ;
  
#line 2719 
  if (i <= 9) 
#line 2721 
              goto ldv_54422; else 
#line 2724 
                                   goto ldv_54424;
  ldv_54424: 
#line 2725 
  ;
  
#line 2726 
  return;
}


#line 2725  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
void ath_tx_edma_tasklet(struct ath_softc *sc)
{
  struct ath_tx_status ts;
  struct ath_txq *txq;
  struct ath_buf *bf;
  struct ath_buf *lastbf;
  struct list_head bf_head;
  struct list_head *fifo_list;
  int status;
  int tmp_0;
  int tmp_2;
  struct ath_buf *tmp_3;
  int tmp_6;
  
#line 2728 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 2729 
  struct ath_hw *ah = sc->sc_ah;
  ldv_54444: 
#line 2735 
  ;
  
#line 2737 
  tmp_0 = constant_test_bit(4L,(unsigned long const volatile *)(& common->op_flags));
  
#line 2737 
  if (tmp_0 != 0) 
#line 2738 
                  goto ldv_54437; else ;
  
#line 2740 
  status = ath9k_hw_txprocdesc(ah,(void *)0,& ts);
  
#line 2741 
  if (status == -115) 
#line 2742 
                      goto ldv_54437; else ;
  
#line 2743 
  if (status == -5) {
    
#line 2744 
    if ((common->debug_mask & 128) != 0) 
#line 2744 
                                         ath_printk("\001",(struct ath_common const *)common,"Error processing tx status\n"); else ;
    
#line 2745 
    goto ldv_54437;
  }
  else ;
  
#line 2749 
  if ((unsigned int)ts.qid == sc->beacon.beaconq) {
    bool tmp_1;
    
#line 2750 
    sc->beacon.tx_processed = (_Bool)1;
    
#line 2751 
    sc->beacon.tx_last = (_Bool)(((int)ts.ts_status & 95) == 0);
    
#line 2753 
    tmp_1 = ath9k_is_chanctx_enabled();
    
#line 2753 
    if ((int)tmp_1 != 0) 
#line 2754 
                         ath_chanctx_event(sc,(struct ieee80211_vif *)0,(enum ath_chanctx_event)ATH_CHANCTX_EVENT_BEACON_SENT); else ;
    
#line 2758 
    ath9k_csa_update(sc);
    
#line 2759 
    goto ldv_54438;
  }
  else ;
  
#line 2762 
  txq = & sc->tx.txq[(int)ts.qid];
  
#line 2764 
  ath_txq_lock(sc,txq);
  
#line 2766 
  sc->debug.stats.txstats[txq->axq_qnum].txprocdesc += 1U;
  
#line 2768 
  fifo_list = & txq->txq_fifo[(int)txq->txq_tailidx];
  
#line 2769 
  tmp_2 = list_empty((struct list_head const *)fifo_list);
  
#line 2769 
  if (tmp_2 != 0) {
    
#line 2770 
    ath_txq_unlock(sc,txq);
    
#line 2771 
    goto return_label;
  }
  else ;
  {
    
#line 2774 
    struct list_head const *__mptr = (struct list_head const *)fifo_list->next;
    
#line 2774 
    tmp_3 = (struct ath_buf *)__mptr;
  }
  
#line 2774 
  bf = tmp_3;
  
#line 2775 
  if ((int)bf->bf_state.stale != 0) {
    struct ath_buf *tmp_4;
    
#line 2776 
    list_del(& bf->list);
    
#line 2777 
    ath_tx_return_buffer(sc,bf);
    {
      
#line 2778 
      struct list_head const *__mptr_0 = (struct list_head const *)fifo_list->next;
      
#line 2778 
      tmp_4 = (struct ath_buf *)__mptr_0;
    }
    
#line 2778 
    bf = tmp_4;
  }
  else ;
  
#line 2781 
  lastbf = bf->bf_lastbf;
  
#line 2783 
  INIT_LIST_HEAD(& bf_head);
  
#line 2784 
  tmp_6 = list_is_last((struct list_head const *)(& lastbf->list),(struct list_head const *)fifo_list);
  
#line 2784 
  if (tmp_6 != 0) {
    int tmp_5;
    
#line 2785 
    list_splice_tail_init(fifo_list,& bf_head);
    
#line 2786 
    txq->txq_tailidx = (u8)((int)txq->txq_tailidx + 1);
    
#line 2786 
    txq->txq_tailidx = (unsigned char)((unsigned int)txq->txq_tailidx & 7U);
    
#line 2788 
    tmp_5 = list_empty((struct list_head const *)(& txq->axq_q));
    
#line 2788 
    if (tmp_5 == 0) {
      struct list_head bf_q;
      
#line 2791 
      INIT_LIST_HEAD(& bf_q);
      
#line 2792 
      txq->axq_link = (void *)0;
      
#line 2793 
      list_splice_tail_init(& txq->axq_q,& bf_q);
      
#line 2794 
      ath_tx_txqaddbuf(sc,txq,& bf_q,(_Bool)1);
    }
    else ;
  }
  else {
    
#line 2797 
    lastbf->bf_state.stale = (_Bool)1;
    
#line 2798 
    if (bf != lastbf) 
#line 2799 
                      list_cut_position(& bf_head,fifo_list,lastbf->list.prev); else ;
  }
  
#line 2803 
  ath_tx_process_buffer(sc,txq,& ts,bf,& bf_head);
  
#line 2804 
  ath_txq_unlock_complete(sc,txq);
  ldv_54438: 
#line 2805 
  ;
  
#line 2737 
  goto ldv_54444;
  ldv_54437: 
#line 2738 
  ;
  return_label: 
#line 2739 
                return;
}


#line 2812  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static int ath_txstatus_setup(struct ath_softc *sc, int size)
{
  int __retres;
  
#line 2814 
  struct ath_descdma *dd = & sc->txsdma;
  
#line 2815 
  u8 txs_len = (sc->sc_ah)->caps.txs_len;
  
#line 2817 
  dd->dd_desc_len = (unsigned int)((int)txs_len * size);
  
#line 2818 
  dd->dd_desc = dmam_alloc_coherent(sc->dev,(unsigned long)dd->dd_desc_len,& dd->dd_desc_paddr,208U);
  
#line 2820 
  if (dd->dd_desc == (void *)0) {
    
#line 2821 
    __retres = -12;
    
#line 2821 
    goto return_label;
  }
  else ;
  
#line 2823 
  __retres = 0;
  return_label: 
#line 2823 
                return __retres;
}


#line 2826  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
static int ath_tx_edma_init(struct ath_softc *sc)
{
  int err;
  
#line 2830 
  err = ath_txstatus_setup(sc,512);
  
#line 2831 
  if (err == 0) 
#line 2832 
                ath9k_hw_setup_statusring(sc->sc_ah,sc->txsdma.dd_desc,(unsigned int)sc->txsdma.dd_desc_paddr,(unsigned short)512); else ;
  
#line 2836 
  return err;
}


#line 2839  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
int ath_tx_init(struct ath_softc *sc, int nbufs)
{
  int __retres;
  
#line 2841 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 2842 
  int error = 0;
  
#line 2844 
  spinlock_check(& sc->tx.txbuflock);
  {
    struct lock_class_key __key;
    
#line 2844 
    __raw_spin_lock_init(& sc->tx.txbuflock.__anonCompField_spinlock_18.rlock,"&(&sc->tx.txbuflock)->rlock",& __key);
  }
  
#line 2846 
  error = ath_descdma_setup(sc,& sc->tx.txdma,& sc->tx.txbuf,"tx",nbufs,1,(_Bool)1);
  
#line 2848 
  if (error != 0) {
    
#line 2849 
    ath_printk("\001",(struct ath_common const *)common,"Failed to allocate tx descriptors: %d\n",error);
    
#line 2851 
    __retres = error;
    
#line 2851 
    goto return_label;
  }
  else ;
  
#line 2854 
  error = ath_descdma_setup(sc,& sc->beacon.bdma,& sc->beacon.bbuf,"beacon",8,1,(_Bool)1);
  
#line 2856 
  if (error != 0) {
    
#line 2857 
    ath_printk("\001",(struct ath_common const *)common,"Failed to allocate beacon descriptors: %d\n",error);
    
#line 2859 
    __retres = error;
    
#line 2859 
    goto return_label;
  }
  else ;
  {
    struct lock_class_key __key_0;
    
#line 2862 
    __init_work(& sc->tx_complete_work.work,0);
    
#line 2862 
    atomic_long_t __constr_expr_37 = {.counter = WORK_STRUCT_NO_POOL_0};
    
#line 2862 
    sc->tx_complete_work.work.data = __constr_expr_37;
    
#line 2862 
    lockdep_init_map(& sc->tx_complete_work.work.lockdep_map,"(&(&sc->tx_complete_work)->work)",& __key_0,0);
    
#line 2862 
    INIT_LIST_HEAD(& sc->tx_complete_work.work.entry);
    
#line 2862 
    sc->tx_complete_work.work.func = & ath_tx_complete_poll_work;
  }
  {
    struct lock_class_key __key_1;
    
#line 2862 
    init_timer_key(& sc->tx_complete_work.timer,2097152U,"(&(&sc->tx_complete_work)->timer)",& __key_1);
  }
  
#line 2862 
  sc->tx_complete_work.timer.function = & delayed_work_timer_fn;
  
#line 2862 
  sc->tx_complete_work.timer.data = (unsigned long)(& sc->tx_complete_work);
  
#line 2864 
  if (((sc->sc_ah)->caps.hw_caps & 16U) != 0U) 
#line 2865 
                                               error = ath_tx_edma_init(sc); else ;
  
#line 2867 
  __retres = error;
  return_label: 
#line 2867 
                return __retres;
}


#line 2870  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
void ath_tx_node_init(struct ath_softc *sc, struct ath_node *an)
{
  struct ath_atx_tid *tid;
  struct ath_atx_ac *ac;
  int tidno;
  int acno;
  u16 tmp;
  int tmp_0;
  
#line 2876 
  tidno = 0;
  
#line 2876 
  tid = & an->tid[tidno];
  
#line 2876 
  goto ldv_54474;
  ldv_54473: 
#line 2877 
  ;
  
#line 2879 
  tid->an = an;
  
#line 2880 
  tid->tidno = (unsigned char)tidno;
  
#line 2881 
  tmp = (unsigned short)0U;
  
#line 2881 
  tid->seq_next = tmp;
  
#line 2881 
  tid->seq_start = tmp;
  
#line 2882 
  tid->baw_size = (unsigned short)64U;
  
#line 2883 
  tmp_0 = 0;
  
#line 2883 
  tid->baw_tail = tmp_0;
  
#line 2883 
  tid->baw_head = tmp_0;
  
#line 2884 
  tid->sched = (_Bool)0;
  
#line 2885 
  tid->active = (_Bool)0;
  
#line 2886 
  __skb_queue_head_init(& tid->buf_q);
  
#line 2887 
  __skb_queue_head_init(& tid->retry_q);
  
#line 2888 
  if (tidno != 0 && tidno != 3) {
    int tmp_1;
    
#line 2888 
    if ((unsigned int)tidno + 4294967295U > 1U) 
#line 2888 
                                                tmp_1 = (unsigned int)tidno + 4294967292U <= 1U; else 
                                                                    
#line 2888 
                                                                    tmp_1 = 3;
    
#line 2888 
    acno = tmp_1;
  }
  else 
#line 2888 
       acno = 2;
  
#line 2889 
  tid->ac = & an->ac[acno];
  
#line 2878 
  tidno += 1;
  
#line 2878 
  tid += 1;
  ldv_54474: 
#line 2879 
  ;
  
#line 2876 
  if (tidno <= 15) 
#line 2879 
                   goto ldv_54473; else 
#line 2882 
                                        goto ldv_54475;
  ldv_54475: 
#line 2883 
  ;
  
#line 2892 
  acno = 0;
  
#line 2892 
  ac = & an->ac[acno];
  
#line 2892 
  goto ldv_54477;
  ldv_54476: 
#line 2893 
  ;
  
#line 2894 
  ac->sched = (_Bool)0;
  
#line 2895 
  ac->clear_ps_filter = (_Bool)1;
  
#line 2896 
  ac->txq = sc->tx.txq_map[acno];
  
#line 2897 
  INIT_LIST_HEAD(& ac->tid_q);
  
#line 2893 
  acno += 1;
  
#line 2893 
  ac += 1;
  ldv_54477: 
#line 2894 
  ;
  
#line 2892 
  if (acno <= 3) 
#line 2895 
                 goto ldv_54476; else 
#line 2898 
                                      goto ldv_54478;
  ldv_54478: 
#line 2899 
  ;
  
#line 2900 
  return;
}


#line 2901  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
void ath_tx_node_cleanup(struct ath_softc *sc, struct ath_node *an)
{
  struct ath_atx_ac *ac;
  struct ath_atx_tid *tid;
  struct ath_txq *txq;
  int tidno;
  
#line 2908 
  tidno = 0;
  
#line 2908 
  tid = & an->tid[tidno];
  
#line 2908 
  goto ldv_54488;
  ldv_54487: 
#line 2909 
  ;
  
#line 2911 
  ac = tid->ac;
  
#line 2912 
  txq = ac->txq;
  
#line 2914 
  ath_txq_lock(sc,txq);
  
#line 2916 
  if ((int)tid->sched != 0) {
    
#line 2917 
    list_del(& tid->list);
    
#line 2918 
    tid->sched = (_Bool)0;
  }
  else ;
  
#line 2921 
  if ((int)ac->sched != 0) {
    
#line 2922 
    list_del(& ac->list);
    
#line 2923 
    (tid->ac)->sched = (_Bool)0;
  }
  else ;
  
#line 2926 
  ath_tid_drain(sc,txq,tid);
  
#line 2927 
  tid->active = (_Bool)0;
  
#line 2929 
  ath_txq_unlock(sc,txq);
  
#line 2909 
  tidno += 1;
  
#line 2909 
  tid += 1;
  ldv_54488: 
#line 2910 
  ;
  
#line 2908 
  if (tidno <= 15) 
#line 2911 
                   goto ldv_54487; else 
#line 2914 
                                        goto ldv_54489;
  ldv_54489: 
#line 2915 
  ;
  
#line 2916 
  return;
}


#line 2935  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/xmit.c"
int ath9k_tx99_send(struct ath_softc *sc, struct sk_buff *skb, struct ath_tx_control *txctl)
{
  int __retres;
  struct ath_buf *bf;
  int padpos;
  int padsize;
  unsigned int tmp_1;
  
#line 2938 
  struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
  
#line 2939 
  struct ath_frame_info *fi = get_frame_info(skb);
  
#line 2940 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 2944 
  tmp_1 = ieee80211_hdrlen((unsigned short)((int)hdr->frame_control));
  
#line 2944 
  padpos = (int)tmp_1;
  
#line 2945 
  padsize = padpos & 3;
  
#line 2947 
  if (padsize != 0 && skb->len > (unsigned int)padpos) {
    unsigned int tmp_2;
    
#line 2948 
    tmp_2 = skb_headroom((struct sk_buff const *)skb);
    
#line 2948 
    ;
    
#line 2948 
    if (tmp_2 < (unsigned int)padsize) {
      
#line 2949 
      if ((common->debug_mask & 128) != 0) 
#line 2949 
                                           ath_printk("\001",(struct ath_common const *)common,"tx99 padding failed\n"); else ;
      
#line 2951 
      __retres = -22;
      
#line 2951 
      goto return_label;
    }
    else ;
    
#line 2954 
    skb_push(skb,(unsigned int)padsize);
    
#line 2955 
    memmove((void *)skb->data,(void const *)(skb->data + padsize),(unsigned long)padpos);
  }
  else ;
  
#line 2958 
  fi->keyix = (unsigned char)255U;
  
#line 2959 
  fi->framelen = (unsigned short)((unsigned int)((unsigned short)skb->len) + 4U);
  
#line 2960 
  fi->keytype = (enum ath9k_key_type __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U;
  
#line 2962 
  bf = ath_tx_setup_buffer(sc,txctl->txq,(struct ath_atx_tid *)0,skb);
  
#line 2963 
  if (bf == (struct ath_buf *)0) {
    
#line 2964 
    if ((common->debug_mask & 128) != 0) 
#line 2964 
                                         ath_printk("\001",(struct ath_common const *)common,"tx99 buffer setup failed\n"); else ;
    
#line 2965 
    __retres = -22;
    
#line 2965 
    goto return_label;
  }
  else ;
  
#line 2968 
  ath_set_rates(sc->tx99_vif,(struct ieee80211_sta *)0,bf);
  
#line 2970 
  ath9k_hw_set_desc_link(sc->sc_ah,bf->bf_desc,(unsigned int)bf->bf_daddr);
  
#line 2971 
  ath9k_hw_tx99_start(sc->sc_ah,(txctl->txq)->axq_qnum);
  
#line 2973 
  ath_tx_send_normal(sc,txctl->txq,(struct ath_atx_tid *)0,skb);
  
#line 2975 
  __retres = 0;
  return_label: 
#line 2975 
                return __retres;
}


#line 737  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_xmit.c.aux"
static void ldv_spin_lock_bh_72_1(spinlock_t *lock)
{
  
#line 741 
  ldv_spin_model_lock((char *)"axq_lock_of_ath_txq");
  
#line 743 
  spin_lock_bh_2(lock);
  
#line 744 
  return;
}


#line 747  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_xmit.c.aux"
static void ldv_spin_unlock_bh_73_1(spinlock_t *lock)
{
  
#line 751 
  ldv_spin_model_unlock((char *)"axq_lock_of_ath_txq");
  
#line 753 
  spin_unlock_bh_2(lock);
  
#line 754 
  return;
}


#line 757  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_xmit.c.aux"
static void ldv_spin_unlock_bh_74_0(spinlock_t *lock)
{
  
#line 761 
  ldv_spin_model_unlock((char *)"axq_lock_of_ath_txq");
  
#line 763 
  spin_unlock_bh_2(lock);
  
#line 764 
  return;
}


#line 767  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_xmit.c.aux"
static void ldv_spin_lock_bh_75(spinlock_t *lock)
{
  
#line 771 
  ldv_spin_model_lock((char *)"txbuflock_of_ath_tx");
  
#line 773 
  spin_lock_bh_2(lock);
  
#line 774 
  return;
}


#line 777  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_xmit.c.aux"
static void ldv_spin_unlock_bh_76_0(spinlock_t *lock)
{
  
#line 781 
  ldv_spin_model_unlock((char *)"txbuflock_of_ath_tx");
  
#line 783 
  spin_unlock_bh_2(lock);
  
#line 784 
  return;
}


#line 787  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_xmit.c.aux"
static void ldv_spin_unlock_bh_77(spinlock_t *lock)
{
  
#line 791 
  ldv_spin_model_unlock((char *)"txbuflock_of_ath_tx");
  
#line 793 
  spin_unlock_bh_2(lock);
  
#line 794 
  return;
}


#line 797  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_xmit.c.aux"
static void ldv_spin_lock_bh_78(spinlock_t *lock)
{
  
#line 801 
  ldv_spin_model_lock((char *)"txbuflock_of_ath_tx");
  
#line 803 
  spin_lock_bh_2(lock);
  
#line 804 
  return;
}


#line 807  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_xmit.c.aux"
static void ldv_spin_unlock_bh_79(spinlock_t *lock)
{
  
#line 811 
  ldv_spin_model_unlock((char *)"txbuflock_of_ath_tx");
  
#line 813 
  spin_unlock_bh_2(lock);
  
#line 814 
  return;
}


#line 817  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_xmit.c.aux"
static void ldv_spin_lock_bh_80(spinlock_t *lock)
{
  
#line 821 
  ldv_spin_model_lock((char *)"chan_lock_of_ath_softc");
  
#line 823 
  spin_lock_bh_2(lock);
  
#line 824 
  return;
}


#line 827  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_xmit.c.aux"
static void ldv_spin_unlock_bh_81(spinlock_t *lock)
{
  
#line 831 
  ldv_spin_model_unlock((char *)"chan_lock_of_ath_softc");
  
#line 833 
  spin_unlock_bh_2(lock);
  
#line 834 
  return;
}


#line 837  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_xmit.c.aux"
static void ldv_spin_unlock_bh_82(spinlock_t *lock)
{
  
#line 841 
  ldv_spin_model_unlock((char *)"chan_lock_of_ath_softc");
  
#line 843 
  spin_unlock_bh_2(lock);
  
#line 844 
  return;
}


#line 847  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_xmit.c.aux"
static void ldv_spin_lock_bh_83(spinlock_t *lock)
{
  
#line 851 
  ldv_spin_model_lock((char *)"axq_lock_of_ath_txq");
  
#line 853 
  spin_lock_bh_2(lock);
  
#line 854 
  return;
}


#line 857  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_xmit.c.aux"
static void ldv_spin_unlock_bh_84(spinlock_t *lock)
{
  
#line 861 
  ldv_spin_model_unlock((char *)"axq_lock_of_ath_txq");
  
#line 863 
  spin_unlock_bh_2(lock);
  
#line 864 
  return;
}


#line 867  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_xmit.c.aux"
static void ldv___ldv_spin_lock_85(spinlock_t *ldv_func_arg1)
{
  
#line 871 
  ldv_spin_model_lock((char *)"sc_pm_lock_of_ath_softc");
  
#line 873 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 874 
  return;
}


#line 877  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_xmit.c.aux"
static void ldv_spin_unlock_irqrestore_86(spinlock_t *lock, unsigned long flags)
{
  
#line 881 
  ldv_spin_model_unlock((char *)"sc_pm_lock_of_ath_softc");
  
#line 883 
  spin_unlock_irqrestore_2(lock,flags);
  
#line 884 
  return;
}


#line 887  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_xmit.c.aux"
static void ldv___ldv_spin_lock_87(spinlock_t *ldv_func_arg1)
{
  
#line 891 
  ldv_spin_model_lock((char *)"txbuflock_of_ath_tx");
  
#line 893 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 894 
  return;
}


#line 897  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_xmit.c.aux"
static void ldv_spin_unlock_irqrestore_88(spinlock_t *lock, unsigned long flags)
{
  
#line 901 
  ldv_spin_model_unlock((char *)"txbuflock_of_ath_tx");
  
#line 903 
  spin_unlock_irqrestore_2(lock,flags);
  
#line 904 
  return;
}


#line 402  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
int sprintf(char *, char const * , ...);


#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
size_t strlen(char const *);


#line 37  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
static void ldv_mutex_lock_72_0(struct mutex *ldv_func_arg1);


#line 193  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
static void ldv_mutex_unlock_73(struct mutex *ldv_func_arg1);


#line 581  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kzalloc_0(size_t size, gfp_t flags);


#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/vmalloc.h"
void *vmalloc(unsigned long);


#line 83 
void vfree(void const *);


#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seq_file.h"
ssize_t seq_read(struct file *, char *, size_t, loff_t *);


#line 115 
loff_t seq_lseek(struct file *, loff_t, int);


#line 119 
int seq_puts(struct seq_file *, char const *);


#line 122 
int seq_printf(struct seq_file *, char const * , ...);


#line 131 
int single_open(struct file *, int (*)(struct seq_file *, void *), void *);


#line 133 
int single_release(struct inode *, struct file *);


#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debugfs.h"
static struct dentry *ldv_debugfs_create_file_74(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 58 
static struct dentry *ldv_debugfs_create_file_75(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 62 
static struct dentry *ldv_debugfs_create_file_76(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 66 
static struct dentry *ldv_debugfs_create_file_77(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 70 
static struct dentry *ldv_debugfs_create_file_78(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 74 
static struct dentry *ldv_debugfs_create_file_79(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 78 
static struct dentry *ldv_debugfs_create_file_80(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 82 
static struct dentry *ldv_debugfs_create_file_81(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 86 
static struct dentry *ldv_debugfs_create_file_82(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 90 
static struct dentry *ldv_debugfs_create_file_83(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 94 
static struct dentry *ldv_debugfs_create_file_84(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 102 
struct dentry *debugfs_create_dir(char const *, struct dentry *);


#line 118 
struct dentry *debugfs_create_u8(char const *, umode_t, struct dentry *, u8 *);


#line 122 
struct dentry *debugfs_create_u32(char const *, umode_t, struct dentry *, u32 *);


#line 138 
struct dentry *debugfs_create_bool(char const *, umode_t, struct dentry *, u32 *);


#line 156 
struct dentry *debugfs_create_devm_seqfile(struct device *, char const *, struct dentry *, int (*)(struct seq_file *, void *));


#line 5247  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
__inline static bool conf_is_ht40(struct ieee80211_conf *conf)
{
  bool __retres;
  
#line 5249 
  __retres = (_Bool)(conf->chandef.width == (unsigned int)NL80211_CHAN_WIDTH_40);
  
#line 5249 
  return __retres;
}


#line 322  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath.h"
char const *ath_opmode_to_string(enum nl80211_iftype);


#line 1044  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
u32 ath9k_hw_getrxfilter(struct ath_hw *);


#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw-ops.h"
__inline static void ath9k_hw_set_bt_ant_diversity(struct ath_hw *ah, bool enable)
{
  struct ath_hw_ops *tmp_0;
  
#line 107 
  tmp_0 = ath9k_hw_ops(ah);
  
#line 107 
  ;
  
#line 107 
  if (tmp_0->set_bt_ant_diversity != (void (*)(struct ath_hw *, bool ))0) {
    struct ath_hw_ops *tmp;
    
#line 108 
    tmp = ath9k_hw_ops(ah);
    
#line 108 
    (*(tmp->set_bt_ant_diversity))(ah,(_Bool)((bool)((int)enable) != 0));
  }
  else ;
  
#line 109 
  return;
}


#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/common-debug.h"
void ath9k_cmn_debug_modal_eeprom(struct dentry *, struct ath_hw *);


#line 65 
void ath9k_cmn_debug_base_eeprom(struct dentry *, struct ath_hw *);


#line 67 
void ath9k_cmn_debug_stat_rx(struct ath_rx_stats *, struct ath_rx_status *);


#line 69 
void ath9k_cmn_debug_recv(struct dentry *, struct ath_rx_stats *);


#line 71 
void ath9k_cmn_debug_phy_err(struct dentry *, struct ath_rx_stats *);


#line 154  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/common-spectral.h"
void ath9k_cmn_spectral_init_debug(struct ath_spec_scan_priv *, struct dentry *);


#line 155 
void ath9k_cmn_spectral_deinit_debug(struct ath_spec_scan_priv *);


#line 252  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.h"
void ath_debug_stat_interrupt(struct ath_softc *sc, enum ath9k_int status);


#line 257 
int ath9k_get_et_sset_count(struct ieee80211_hw *hw, struct ieee80211_vif *vif, int sset);


#line 259 
void ath9k_get_et_stats(struct ieee80211_hw *hw, struct ieee80211_vif *vif, struct ethtool_stats *stats, u64 *data);


#line 262 
void ath9k_get_et_strings(struct ieee80211_hw *hw, struct ieee80211_vif *vif, u32 sset, u8 *data);


#line 272 
void ath9k_debug_sync_cause(struct ath_softc *sc, u32 sync_cause);


#line 643  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
void ath9k_calculate_iter_data(struct ath_softc *sc, struct ath_chanctx *ctx, struct ath9k_vif_iter_data *iter_data);


#line 648 
void ath9k_set_txpower(struct ath_softc *sc, struct ieee80211_vif *vif);


#line 719 
void ath_check_ani(struct ath_softc *sc);


#line 770 
int ath9k_dump_btcoex(struct ath_softc *sc, u8 *buf, u32 size);


#line 1051 
void ath9k_tx99_init_debug(struct ath_softc *sc);


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
void ath9k_debug_sync_cause(struct ath_softc *sc, u32 sync_cause)
{
  
#line 31 
  if (sync_cause != 0U) 
#line 32 
                        sc->debug.stats.istats.sync_cause_all += 1U; else ;
  
#line 33 
  if ((sync_cause & 1U) != 0U) 
#line 34 
                               sc->debug.stats.istats.sync_rtc_irq += 1U; else ;
  
#line 35 
  if ((sync_cause & 2U) != 0U) 
#line 36 
                               sc->debug.stats.istats.sync_mac_irq += 1U; else ;
  
#line 37 
  if ((sync_cause & 4U) != 0U) 
#line 38 
                               sc->debug.stats.istats.eeprom_illegal_access += 1U; else ;
  
#line 39 
  if ((sync_cause & 8U) != 0U) 
#line 40 
                               sc->debug.stats.istats.apb_timeout += 1U; else ;
  
#line 41 
  if ((sync_cause & 16U) != 0U) 
#line 42 
                                sc->debug.stats.istats.pci_mode_conflict += 1U; else ;
  
#line 43 
  if ((sync_cause & 32U) != 0U) 
#line 44 
                                sc->debug.stats.istats.host1_fatal += 1U; else ;
  
#line 45 
  if ((sync_cause & 64U) != 0U) 
#line 46 
                                sc->debug.stats.istats.host1_perr += 1U; else ;
  
#line 47 
  if ((sync_cause & 128U) != 0U) 
#line 48 
                                 sc->debug.stats.istats.trcv_fifo_perr += 1U; else ;
  
#line 49 
  if ((sync_cause & 256U) != 0U) 
#line 50 
                                 sc->debug.stats.istats.radm_cpl_ep += 1U; else ;
  
#line 51 
  if ((sync_cause & 512U) != 0U) 
#line 52 
                                 sc->debug.stats.istats.radm_cpl_dllp_abort += 1U; else ;
  
#line 53 
  if ((sync_cause & 1024U) != 0U) 
#line 54 
                                  sc->debug.stats.istats.radm_cpl_tlp_abort += 1U; else ;
  
#line 55 
  if ((sync_cause & 2048U) != 0U) 
#line 56 
                                  sc->debug.stats.istats.radm_cpl_ecrc_err += 1U; else ;
  
#line 57 
  if ((sync_cause & 4096U) != 0U) 
#line 58 
                                  sc->debug.stats.istats.radm_cpl_timeout += 1U; else ;
  
#line 59 
  if ((sync_cause & 8192U) != 0U) 
#line 60 
                                  sc->debug.stats.istats.local_timeout += 1U; else ;
  
#line 61 
  if ((sync_cause & 16384U) != 0U) 
#line 62 
                                   sc->debug.stats.istats.pm_access += 1U; else ;
  
#line 63 
  if ((sync_cause & 32768U) != 0U) 
#line 64 
                                   sc->debug.stats.istats.mac_awake += 1U; else ;
  
#line 65 
  if ((sync_cause & 65536U) != 0U) 
#line 66 
                                   sc->debug.stats.istats.mac_asleep += 1U; else ;
  
#line 67 
  if ((sync_cause & 131072U) != 0U) 
#line 68 
                                    sc->debug.stats.istats.mac_sleep_access += 1U; else ;
  
#line 69 
  return;
}


#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static ssize_t ath9k_debugfs_read_buf(struct file *file, char *user_buf, size_t count, loff_t *ppos)
{
  ssize_t tmp_0;
  size_t tmp;
  
#line 74 
  u8 *buf = (u8 *)file->private_data;
  
#line 75 
  tmp = strlen((char const *)buf);
  
#line 75 
  ;
  
#line 75 
  ;
  
#line 75 
  ;
  
#line 75 
  ;
  
#line 75 
  tmp_0 = simple_read_from_buffer((void *)user_buf,count,ppos,(void const *)buf,tmp);
  
#line 75 
  return tmp_0;
}


#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static int ath9k_debugfs_release_buf(struct inode *inode, struct file *file)
{
  int __retres;
  
#line 80 
  vfree((void const *)file->private_data);
  
#line 81 
  __retres = 0;
  
#line 81 
  return __retres;
}


#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static ssize_t read_file_debug(struct file *file, char *user_buf, size_t count, loff_t *ppos)
{
  char buf[32U];
  unsigned int len;
  int tmp_0;
  ssize_t tmp_1;
  
#line 89 
  struct ath_softc *sc = (struct ath_softc *)file->private_data;
  
#line 90 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 94 
  tmp_0 = sprintf((char *)(& buf),"0x%08x\n",common->debug_mask);
  
#line 94 
  len = (unsigned int)tmp_0;
  
#line 95 
  tmp_1 = simple_read_from_buffer((void *)user_buf,count,ppos,(void const *)(& buf),(unsigned long)len);
  
#line 95 
  return tmp_1;
}


#line 98  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static ssize_t write_file_debug(struct file *file, char const *user_buf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  unsigned long mask;
  char buf[32U];
  ssize_t len;
  unsigned long tmp_1;
  unsigned long tmp_2;
  int tmp_3;
  
#line 101 
  struct ath_softc *sc = (struct ath_softc *)file->private_data;
  
#line 102 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  {
    unsigned long tmp_0;
    
#line 107 
    size_t _min1 = count;
    
#line 107 
    unsigned long _min2 = 31UL;
    
#line 107 
    if (_min1 < _min2) 
#line 107 
                       tmp_0 = _min1; else 
#line 107 
                                           tmp_0 = _min2;
    
#line 107 
    tmp_1 = tmp_0;
  }
  
#line 107 
  len = (long)tmp_1;
  
#line 108 
  tmp_2 = copy_from_user((void *)(& buf),(void const *)user_buf,(unsigned long)len);
  
#line 108 
  if (tmp_2 != 0UL) {
    
#line 109 
    __retres = -14L;
    
#line 109 
    goto return_label;
  }
  else ;
  
#line 111 
  buf[len] = (char)0;
  
#line 112 
  tmp_3 = kstrtoul((char const *)(& buf),0U,& mask);
  
#line 112 
  if (tmp_3 != 0) {
    
#line 113 
    __retres = -22L;
    
#line 113 
    goto return_label;
  }
  else ;
  
#line 115 
  common->debug_mask = (int)mask;
  
#line 116 
  __retres = (long)count;
  return_label: 
#line 116 
                return __retres;
}


#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static struct file_operations const fops_debug = {.owner = & __this_module, .llseek = & default_llseek, .read = & read_file_debug, .write = & write_file_debug, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static ssize_t read_file_ani(struct file *file, char *user_buf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  char *buf;
  int i;
  int tmp_2;
  char *tmp_1;
  int tmp_3;
  
#line 135 
  struct ath_softc *sc = (struct ath_softc *)file->private_data;
  
#line 136 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 137 
  struct ath_hw *ah = sc->sc_ah;
  
#line 138 
  unsigned int len = 0U;
  
#line 139 
  unsigned int const size = 1024U;
  
#line 140 
  ssize_t retval = 0L;
  
#line 146 
  struct __anonstruct_ani_info_3479 ani_info[14U] = {{.name = "ANI RESET", .val = ah->stats.ast_ani_reset}, {.name = "OFDM LEVEL", .val = (unsigned int)ah->ani.ofdmNoiseImmunityLevel}, {.name = "CCK LEVEL", .val = (unsigned int)ah->ani.cckNoiseImmunityLevel}, {.name = "SPUR UP", .val = ah->stats.ast_ani_spurup}, {.name = "SPUR DOWN", .val = ah->stats.ast_ani_spurup}, {.name = "OFDM WS-DET ON", .val = ah->stats.ast_ani_ofdmon}, {.name = "OFDM WS-DET OFF", .val = ah->stats.ast_ani_ofdmoff}, {.name = "MRC-CCK ON", .val = ah->stats.ast_ani_ccklow}, {.name = "MRC-CCK OFF", .val = ah->stats.ast_ani_cckhigh}, {.name = "FIR-STEP UP", .val = ah->stats.ast_ani_stepup}, {.name = "FIR-STEP DOWN", .val = ah->stats.ast_ani_stepdown}, {.name = "INV LISTENTIME", .val = ah->stats.ast_ani_lneg_or_lzero}, {.name = "OFDM ERRORS", .val = ah->stats.ast_ani_ofdmerrs}, {.name = "CCK ERRORS", .val = ah->stats.ast_ani_cckerrs}};
  
#line 163 
  buf = (char *)kzalloc_0((unsigned long)size,208U);
  
#line 164 
  if (buf == (char *)0) {
    
#line 165 
    __retres = -12L;
    
#line 165 
    goto return_label;
  }
  else ;
  
#line 167 
  if ((int)common->disable_ani != 0) 
#line 167 
                                     tmp_1 = (char *)"DISABLED"; else 
                                                                   
#line 167 
                                                                   tmp_1 = (char *)"ENABLED";
  
#line 167 
  ;
  
#line 167 
  tmp_2 = scnprintf(buf + len,(unsigned long)(1024U - len),"%15s: %s\n",(char *)"ANI",tmp_1);
  
#line 168 
  len = (unsigned int)tmp_2 + len;
  
#line 170 
  if ((int)common->disable_ani != 0) 
#line 171 
                                     goto exit; else ;
  
#line 173 
  i = 0;
  
#line 173 
  goto ldv_53692;
  ldv_53691: 
#line 174 
  ;
  
#line 174 
  tmp_3 = scnprintf(buf + len,(unsigned long)(1024U - len),"%15s: %u\n",ani_info[i].name,ani_info[i].val);
  
#line 175 
  len = (unsigned int)tmp_3 + len;
  
#line 173 
  i += 1;
  ldv_53692: 
#line 174 
  ;
  
#line 173 
  if ((unsigned int)i <= 13U) 
#line 175 
                              goto ldv_53691; else 
#line 178 
                                                   goto ldv_53693;
  ldv_53693: 
#line 179 
  ;
  exit: 
#line 177 
  ;
  
#line 178 
  if (len > 1024U) 
#line 179 
                   len = 1024U; else ;
  
#line 181 
  retval = simple_read_from_buffer((void *)user_buf,count,ppos,(void const *)buf,(unsigned long)len);
  
#line 182 
  kfree((void const *)buf);
  
#line 184 
  __retres = retval;
  return_label: 
#line 184 
                return __retres;
}


#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static ssize_t write_file_ani(struct file *file, char const *user_buf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  unsigned long ani;
  char buf[32U];
  ssize_t len;
  unsigned long tmp_1;
  unsigned long tmp_2;
  int tmp_3;
  
#line 191 
  struct ath_softc *sc = (struct ath_softc *)file->private_data;
  
#line 192 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  {
    unsigned long tmp_0;
    
#line 197 
    size_t _min1 = count;
    
#line 197 
    unsigned long _min2 = 31UL;
    
#line 197 
    if (_min1 < _min2) 
#line 197 
                       tmp_0 = _min1; else 
#line 197 
                                           tmp_0 = _min2;
    
#line 197 
    tmp_1 = tmp_0;
  }
  
#line 197 
  len = (long)tmp_1;
  
#line 198 
  tmp_2 = copy_from_user((void *)(& buf),(void const *)user_buf,(unsigned long)len);
  
#line 198 
  if (tmp_2 != 0UL) {
    
#line 199 
    __retres = -14L;
    
#line 199 
    goto return_label;
  }
  else ;
  
#line 201 
  buf[len] = (char)0;
  
#line 202 
  tmp_3 = kstrtoul((char const *)(& buf),0U,& ani);
  
#line 202 
  if (tmp_3 != 0) {
    
#line 203 
    __retres = -22L;
    
#line 203 
    goto return_label;
  }
  else ;
  
#line 205 
  if (ani > 1UL) {
    
#line 206 
    __retres = -22L;
    
#line 206 
    goto return_label;
  }
  else ;
  
#line 208 
  common->disable_ani = (_Bool)(ani == 0UL);
  
#line 210 
  if ((int)common->disable_ani != 0) {
    
#line 211 
    set_bit(2L,(unsigned long volatile *)(& common->op_flags));
    
#line 212 
    ath_stop_ani(sc);
  }
  else 
#line 214 
       ath_check_ani(sc);
  
#line 217 
  __retres = (long)count;
  return_label: 
#line 217 
                return __retres;
}


#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static struct file_operations const fops_ani = {.owner = & __this_module, .llseek = & default_llseek, .read = & read_file_ani, .write = & write_file_ani, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 230  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static ssize_t read_file_bt_ant_diversity(struct file *file, char *user_buf, size_t count, loff_t *ppos)
{
  char buf[32U];
  unsigned int len;
  int tmp_0;
  ssize_t tmp_1;
  
#line 234 
  struct ath_softc *sc = (struct ath_softc *)file->private_data;
  
#line 235 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 239 
  tmp_0 = sprintf((char *)(& buf),"%d\n",(int)common->bt_ant_diversity);
  
#line 239 
  len = (unsigned int)tmp_0;
  
#line 240 
  tmp_1 = simple_read_from_buffer((void *)user_buf,count,ppos,(void const *)(& buf),(unsigned long)len);
  
#line 240 
  return tmp_1;
}


#line 243  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static ssize_t write_file_bt_ant_diversity(struct file *file, char const *user_buf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  unsigned long bt_ant_diversity;
  char buf[32U];
  ssize_t len;
  unsigned long tmp_1;
  unsigned long tmp_2;
  int tmp_3;
  
#line 247 
  struct ath_softc *sc = (struct ath_softc *)file->private_data;
  
#line 248 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 249 
  struct ath9k_hw_capabilities *pCap = & (sc->sc_ah)->caps;
  {
    unsigned long tmp_0;
    
#line 254 
    size_t _min1 = count;
    
#line 254 
    unsigned long _min2 = 31UL;
    
#line 254 
    if (_min1 < _min2) 
#line 254 
                       tmp_0 = _min1; else 
#line 254 
                                           tmp_0 = _min2;
    
#line 254 
    tmp_1 = tmp_0;
  }
  
#line 254 
  len = (long)tmp_1;
  
#line 255 
  tmp_2 = copy_from_user((void *)(& buf),(void const *)user_buf,(unsigned long)len);
  
#line 255 
  if (tmp_2 != 0UL) {
    
#line 256 
    __retres = -14L;
    
#line 256 
    goto return_label;
  }
  else ;
  
#line 258 
  if ((pCap->hw_caps & 131072U) == 0U) 
#line 259 
                                       goto exit; else ;
  
#line 261 
  buf[len] = (char)0;
  
#line 262 
  tmp_3 = kstrtoul((char const *)(& buf),0U,& bt_ant_diversity);
  
#line 262 
  if (tmp_3 != 0) {
    
#line 263 
    __retres = -22L;
    
#line 263 
    goto return_label;
  }
  else ;
  
#line 265 
  common->bt_ant_diversity = (_Bool)(bt_ant_diversity != 0UL);
  
#line 266 
  ath9k_ps_wakeup(sc);
  
#line 267 
  ath9k_hw_set_bt_ant_diversity(sc->sc_ah,(_Bool)((bool)((int)common->bt_ant_diversity) != 0));
  
#line 268 
  if ((common->debug_mask & 512) != 0) 
#line 268 
                                       ath_printk("\001",(struct ath_common const *)common,"Enable WLAN/BT RX Antenna diversity: %d\n",(int)common->bt_ant_diversity); else ;
  
#line 270 
  ath9k_ps_restore(sc);
  exit: 
#line 271 
  ;
  
#line 272 
  __retres = (long)count;
  return_label: 
#line 272 
                return __retres;
}


#line 275  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static struct file_operations const fops_bt_ant_diversity = {.owner = & __this_module, .llseek = & default_llseek, .read = & read_file_bt_ant_diversity, .write = & write_file_bt_ant_diversity, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 285  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
void ath9k_debug_stat_ant(struct ath_softc *sc, struct ath_hw_antcomb_conf *div_ant_conf, int main_rssi_avg, int alt_rssi_avg)
{
  
#line 289 
  struct ath_antenna_stats *as_main = & sc->debug.stats.ant_stats[0];
  
#line 290 
  struct ath_antenna_stats *as_alt = & sc->debug.stats.ant_stats[1];
  
#line 292 
  as_main->lna_attempt_cnt[(int)div_ant_conf->main_lna_conf] += 1U;
  
#line 293 
  as_alt->lna_attempt_cnt[(int)div_ant_conf->alt_lna_conf] += 1U;
  
#line 295 
  as_main->rssi_avg = (unsigned int)main_rssi_avg;
  
#line 296 
  as_alt->rssi_avg = (unsigned int)alt_rssi_avg;
  
#line 297 
  return;
}


#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static ssize_t read_file_antenna_diversity(struct file *file, char *user_buf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  struct ath_hw_antcomb_conf div_ant_conf;
  char *buf;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  int tmp_4;
  int tmp_5;
  int tmp_6;
  int tmp_7;
  int tmp_8;
  int tmp_9;
  int tmp_10;
  int tmp_11;
  int tmp_12;
  int tmp_13;
  int tmp_14;
  int tmp_15;
  int tmp_16;
  int tmp_17;
  int tmp_18;
  int tmp_19;
  
#line 303 
  struct ath_softc *sc = (struct ath_softc *)file->private_data;
  
#line 304 
  struct ath_hw *ah = sc->sc_ah;
  
#line 305 
  struct ath9k_hw_capabilities *pCap = & ah->caps;
  
#line 306 
  struct ath_antenna_stats *as_main = & sc->debug.stats.ant_stats[0];
  
#line 307 
  struct ath_antenna_stats *as_alt = & sc->debug.stats.ant_stats[1];
  
#line 309 
  unsigned int len = 0U;
  
#line 310 
  unsigned int const size = 1024U;
  
#line 311 
  ssize_t retval = 0L;
  
#line 313 
  char const *lna_conf_str[4U] = {"LNA1_MINUS_LNA2", "LNA2", "LNA1", "LNA1_PLUS_LNA2"};
  
#line 317 
  buf = (char *)kzalloc_0((unsigned long)size,208U);
  
#line 318 
  if (buf == (char *)0) {
    
#line 319 
    __retres = -12L;
    
#line 319 
    goto return_label;
  }
  else ;
  
#line 321 
  if ((pCap->hw_caps & 1024U) == 0U) {
    int tmp_0;
    
#line 322 
    tmp_0 = scnprintf(buf + len,(unsigned long)(1024U - len),"%s\n",(char *)"Antenna Diversity Combining is disabled");
    
#line 323 
    len = (unsigned int)tmp_0 + len;
    
#line 324 
    goto exit;
  }
  else ;
  
#line 327 
  ath9k_ps_wakeup(sc);
  
#line 328 
  ath9k_hw_antdiv_comb_conf_get(ah,& div_ant_conf);
  
#line 329 
  tmp_1 = scnprintf(buf + len,(unsigned long)(1024U - len),"Current MAIN config : %s\n",lna_conf_str[(int)div_ant_conf.main_lna_conf]);
  
#line 330 
  len = (unsigned int)tmp_1 + len;
  
#line 331 
  tmp_2 = scnprintf(buf + len,(unsigned long)(1024U - len),"Current ALT config  : %s\n",lna_conf_str[(int)div_ant_conf.alt_lna_conf]);
  
#line 332 
  len = (unsigned int)tmp_2 + len;
  
#line 333 
  tmp_3 = scnprintf(buf + len,(unsigned long)(1024U - len),"Average MAIN RSSI   : %d\n",as_main->rssi_avg);
  
#line 334 
  len = (unsigned int)tmp_3 + len;
  
#line 335 
  tmp_4 = scnprintf(buf + len,(unsigned long)(1024U - len),"Average ALT RSSI    : %d\n\n",as_alt->rssi_avg);
  
#line 336 
  len = (unsigned int)tmp_4 + len;
  
#line 337 
  ath9k_ps_restore(sc);
  
#line 339 
  tmp_5 = scnprintf(buf + len,(unsigned long)(1024U - len),"Packet Receive Cnt:\n");
  
#line 339 
  len = (unsigned int)tmp_5 + len;
  
#line 340 
  tmp_6 = scnprintf(buf + len,(unsigned long)(1024U - len),"-------------------\n");
  
#line 340 
  len = (unsigned int)tmp_6 + len;
  
#line 342 
  tmp_7 = scnprintf(buf + len,(unsigned long)(1024U - len),"%30s%15s\n",(char *)"MAIN",(char *)"ALT");
  
#line 343 
  len = (unsigned int)tmp_7 + len;
  
#line 344 
  tmp_8 = scnprintf(buf + len,(unsigned long)(1024U - len),"%-14s:%15d%15d\n",(char *)"TOTAL COUNT",as_main->recv_cnt,as_alt->recv_cnt);
  
#line 347 
  len = (unsigned int)tmp_8 + len;
  
#line 348 
  tmp_9 = scnprintf(buf + len,(unsigned long)(1024U - len),"%-14s:%15d%15d\n",(char *)"LNA1",as_main->lna_recv_cnt[2],as_alt->lna_recv_cnt[2]);
  
#line 351 
  len = (unsigned int)tmp_9 + len;
  
#line 352 
  tmp_10 = scnprintf(buf + len,(unsigned long)(1024U - len),"%-14s:%15d%15d\n",(char *)"LNA2",as_main->lna_recv_cnt[1],as_alt->lna_recv_cnt[1]);
  
#line 355 
  len = (unsigned int)tmp_10 + len;
  
#line 356 
  tmp_11 = scnprintf(buf + len,(unsigned long)(1024U - len),"%-14s:%15d%15d\n",(char *)"LNA1 + LNA2",as_main->lna_recv_cnt[3],as_alt->lna_recv_cnt[3]);
  
#line 359 
  len = (unsigned int)tmp_11 + len;
  
#line 360 
  tmp_12 = scnprintf(buf + len,(unsigned long)(1024U - len),"%-14s:%15d%15d\n",(char *)"LNA1 - LNA2",as_main->lna_recv_cnt[0],as_alt->lna_recv_cnt[0]);
  
#line 363 
  len = (unsigned int)tmp_12 + len;
  
#line 365 
  tmp_13 = scnprintf(buf + len,(unsigned long)(1024U - len),"\nLNA Config Attempts:\n");
  
#line 365 
  len = (unsigned int)tmp_13 + len;
  
#line 366 
  tmp_14 = scnprintf(buf + len,(unsigned long)(1024U - len),"--------------------\n");
  
#line 366 
  len = (unsigned int)tmp_14 + len;
  
#line 368 
  tmp_15 = scnprintf(buf + len,(unsigned long)(1024U - len),"%30s%15s\n",(char *)"MAIN",(char *)"ALT");
  
#line 369 
  len = (unsigned int)tmp_15 + len;
  
#line 370 
  tmp_16 = scnprintf(buf + len,(unsigned long)(1024U - len),"%-14s:%15d%15d\n",(char *)"LNA1",as_main->lna_attempt_cnt[2],as_alt->lna_attempt_cnt[2]);
  
#line 373 
  len = (unsigned int)tmp_16 + len;
  
#line 374 
  tmp_17 = scnprintf(buf + len,(unsigned long)(1024U - len),"%-14s:%15d%15d\n",(char *)"LNA2",as_main->lna_attempt_cnt[1],as_alt->lna_attempt_cnt[1]);
  
#line 377 
  len = (unsigned int)tmp_17 + len;
  
#line 378 
  tmp_18 = scnprintf(buf + len,(unsigned long)(1024U - len),"%-14s:%15d%15d\n",(char *)"LNA1 + LNA2",as_main->lna_attempt_cnt[3],as_alt->lna_attempt_cnt[3]);
  
#line 381 
  len = (unsigned int)tmp_18 + len;
  
#line 382 
  tmp_19 = scnprintf(buf + len,(unsigned long)(1024U - len),"%-14s:%15d%15d\n",(char *)"LNA1 - LNA2",as_main->lna_attempt_cnt[0],as_alt->lna_attempt_cnt[0]);
  
#line 385 
  len = (unsigned int)tmp_19 + len;
  exit: 
#line 387 
  ;
  
#line 388 
  if (len > 1024U) 
#line 389 
                   len = 1024U; else ;
  
#line 391 
  retval = simple_read_from_buffer((void *)user_buf,count,ppos,(void const *)buf,(unsigned long)len);
  
#line 392 
  kfree((void const *)buf);
  
#line 394 
  __retres = retval;
  return_label: 
#line 394 
                return __retres;
}


#line 397  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static struct file_operations const fops_antenna_diversity = {.owner = & __this_module, .llseek = & default_llseek, .read = & read_file_antenna_diversity, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static int read_file_dma(struct seq_file *file, void *data)
{
  int __retres;
  u32 val[8U];
  int i;
  struct ath_common *tmp_0;
  struct ath_common *tmp_1;
  unsigned int tmp_3;
  struct ath_common *tmp_2;
  unsigned int tmp_5;
  struct ath_common *tmp_4;
  
#line 406 
  struct ieee80211_hw *hw = dev_get_drvdata((struct device const *)file->private);
  
#line 407 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 408 
  struct ath_hw *ah = sc->sc_ah;
  
#line 410 
  int qcuOffset = 0;
  
#line 410 
  int dcuOffset = 0;
  
#line 411 
  u32 *qcuBase = &(val[0]);
  
#line 411 
  u32 *dcuBase = & val[4];
  
#line 413 
  ath9k_ps_wakeup(sc);
  
#line 415 
  tmp_0 = ath9k_hw_common(ah);
  
#line 415 
  (*((tmp_0->ops)->write))((void *)ah,33024U,88U);
  
#line 420 
  seq_puts(file,"Raw DMA Debug values:\n");
  
#line 422 
  i = 0;
  
#line 422 
  goto ldv_53777;
  ldv_53776: 
#line 423 
  ;
  
#line 423 
  if (((unsigned int)i & 3U) == 0U) 
#line 424 
                                    seq_puts(file,"\n"); else ;
  
#line 426 
  tmp_1 = ath9k_hw_common(ah);
  
#line 426 
  val[i] = (*((tmp_1->ops)->read))((void *)ah,(unsigned int)((unsigned long)i + 56UL) * 4U);
  
#line 427 
  seq_printf(file,"%d: %08x ",i,val[i]);
  
#line 422 
  i += 1;
  ldv_53777: 
#line 423 
  ;
  
#line 422 
  if (i <= 7) 
#line 424 
              goto ldv_53776; else 
#line 427 
                                   goto ldv_53778;
  ldv_53778: 
#line 428 
  ;
  
#line 430 
  seq_puts(file,"\n\n");
  
#line 431 
  seq_puts(file,"Num QCU: chain_st fsp_ok fsp_st DCU: chain_st\n");
  
#line 433 
  i = 0;
  
#line 433 
  goto ldv_53780;
  ldv_53779: 
#line 434 
  ;
  
#line 434 
  if (i == 8) {
    
#line 435 
    qcuOffset = 0;
    
#line 436 
    qcuBase += 1;
  }
  else ;
  
#line 439 
  if (i == 6) {
    
#line 440 
    dcuOffset = 0;
    
#line 441 
    dcuBase += 1;
  }
  else ;
  
#line 444 
  seq_printf(file,"%2d          %2x      %1x     %2x           %2x\n",i,(*qcuBase & (unsigned int)(7 << qcuOffset)) >> qcuOffset,(*qcuBase & (unsigned int)(8 << qcuOffset)) >> (qcuOffset + 3),(val[2] & (unsigned int)(7 << i * 3)) >> i * 3,(*dcuBase & (unsigned int)(31 << dcuOffset)) >> dcuOffset);
  
#line 433 
  i += 1;
  
#line 433 
  qcuOffset += 4;
  
#line 433 
  dcuOffset += 5;
  ldv_53780: 
#line 434 
  ;
  
#line 433 
  if (i <= 9) 
#line 435 
              goto ldv_53779; else 
#line 438 
                                   goto ldv_53781;
  ldv_53781: 
#line 439 
  ;
  
#line 451 
  seq_puts(file,"\n");
  
#line 453 
  seq_printf(file,"qcu_stitch state:   %2x    qcu_fetch state:        %2x\n",(val[3] >> 18) & 15U,(val[3] >> 22) & 15U);
  
#line 455 
  seq_printf(file,"qcu_complete state: %2x    dcu_complete state:     %2x\n",(val[3] >> 26) & 7U,val[6] & 3U);
  
#line 457 
  seq_printf(file,"dcu_arb state:      %2x    dcu_fp state:           %2x\n",(val[5] >> 25) & 3U,(val[5] >> 27) & 7U);
  
#line 459 
  seq_printf(file,"chan_idle_dur:     %3d    chan_idle_dur_valid:     %1d\n",(val[6] >> 2) & 255U,(val[6] >> 10) & 1U);
  
#line 461 
  seq_printf(file,"txfifo_valid_0:      %1d    txfifo_valid_1:          %1d\n",(val[6] >> 11) & 1U,(val[6] >> 12) & 1U);
  
#line 463 
  seq_printf(file,"txfifo_dcu_num_0:   %2d    txfifo_dcu_num_1:       %2d\n",(val[6] >> 13) & 15U,(val[6] >> 17) & 15U);
  
#line 466 
  tmp_2 = ath9k_hw_common(ah);
  
#line 466 
  tmp_3 = (*((tmp_2->ops)->read))((void *)ah,32876U);
  
#line 466 
  ;
  
#line 466 
  seq_printf(file,"pcu observe: 0x%x\n",tmp_3);
  
#line 467 
  tmp_4 = ath9k_hw_common(ah);
  
#line 467 
  tmp_5 = (*((tmp_4->ops)->read))((void *)ah,8U);
  
#line 467 
  ;
  
#line 467 
  seq_printf(file,"AR_CR: 0x%x\n",tmp_5);
  
#line 469 
  ath9k_ps_restore(sc);
  
#line 471 
  __retres = 0;
  
#line 471 
  return __retres;
}


#line 474  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
void ath_debug_stat_interrupt(struct ath_softc *sc, enum ath9k_int status)
{
  
#line 476 
  if (status != (unsigned int)0) 
#line 477 
                                 sc->debug.stats.istats.total += 1U; else ;
  
#line 478 
  if (((sc->sc_ah)->caps.hw_caps & 16U) != 0U) {
    
#line 479 
    if (((unsigned int)status & 2U) != 0U) 
#line 480 
                                           sc->debug.stats.istats.rxlp += 1U; else ;
    
#line 481 
    if (((unsigned int)status & 1U) != 0U) 
#line 482 
                                           sc->debug.stats.istats.rxhp += 1U; else ;
    
#line 483 
    if (((unsigned int)status & 1024U) != 0U) 
#line 484 
                                              sc->debug.stats.istats.bb_watchdog += 1U; else ;
  }
  else 
    
#line 486 
    if (((unsigned int)status & 1U) != 0U) 
#line 487 
                                           sc->debug.stats.istats.rxok += 1U; else ;
  
#line 489 
  if (((unsigned int)status & 16U) != 0U) 
#line 490 
                                          sc->debug.stats.istats.rxeol += 1U; else ;
  
#line 491 
  if (((unsigned int)status & 32U) != 0U) 
#line 492 
                                          sc->debug.stats.istats.rxorn += 1U; else ;
  
#line 493 
  if (((unsigned int)status & 64U) != 0U) 
#line 494 
                                          sc->debug.stats.istats.txok += 1U; else ;
  
#line 495 
  if (((unsigned int)status & 2048U) != 0U) 
#line 496 
                                            sc->debug.stats.istats.txurn += 1U; else ;
  
#line 497 
  if (((unsigned int)status & 16384U) != 0U) 
#line 498 
                                             sc->debug.stats.istats.rxphyerr += 1U; else ;
  
#line 499 
  if (((unsigned int)status & 32768U) != 0U) 
#line 500 
                                             sc->debug.stats.istats.rx_keycache_miss += 1U; else ;
  
#line 501 
  if (((unsigned int)status & 65536U) != 0U) 
#line 502 
                                             sc->debug.stats.istats.swba += 1U; else ;
  
#line 503 
  if (((unsigned int)status & 262144U) != 0U) 
#line 504 
                                              sc->debug.stats.istats.bmiss += 1U; else ;
  
#line 505 
  if (((unsigned int)status & 1048576U) != 0U) 
#line 506 
                                               sc->debug.stats.istats.bnr += 1U; else ;
  
#line 507 
  if (((unsigned int)status & 268435456U) != 0U) 
#line 508 
                                                 sc->debug.stats.istats.cst += 1U; else ;
  
#line 509 
  if (((unsigned int)status & 536870912U) != 0U) 
#line 510 
                                                 sc->debug.stats.istats.gtt += 1U; else ;
  
#line 511 
  if (((unsigned int)status & 2097152U) != 0U) 
#line 512 
                                               sc->debug.stats.istats.tim += 1U; else ;
  
#line 513 
  if (((unsigned int)status & 33554432U) != 0U) 
#line 514 
                                                sc->debug.stats.istats.cabend += 1U; else ;
  
#line 515 
  if (((unsigned int)status & 8388608U) != 0U) 
#line 516 
                                               sc->debug.stats.istats.dtimsync += 1U; else ;
  
#line 517 
  if (((unsigned int)status & 4194304U) != 0U) 
#line 518 
                                               sc->debug.stats.istats.dtim += 1U; else ;
  
#line 519 
  if (((unsigned int)status & 67108864U) != 0U) 
#line 520 
                                                sc->debug.stats.istats.tsfoor += 1U; else ;
  
#line 521 
  if (((unsigned int)status & 512U) != 0U) 
#line 522 
                                           sc->debug.stats.istats.mci += 1U; else ;
  
#line 523 
  if (((unsigned int)status & 134217728U) != 0U) 
#line 524 
                                                 sc->debug.stats.istats.gen_timer += 1U; else ;
  
#line 525 
  return;
}


#line 527  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static int read_file_interrupt(struct seq_file *file, void *data)
{
  int __retres;
  
#line 529 
  struct ieee80211_hw *hw = dev_get_drvdata((struct device const *)file->private);
  
#line 530 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 538 
  if (((sc->sc_ah)->caps.hw_caps & 16U) != 0U) {
    
#line 539 
    seq_printf(file,"%21s: %10u\n",(char *)"RXLP",sc->debug.stats.istats.rxlp);
    
#line 540 
    seq_printf(file,"%21s: %10u\n",(char *)"RXHP",sc->debug.stats.istats.rxhp);
    
#line 541 
    seq_printf(file,"%21s: %10u\n",(char *)"WATHDOG",sc->debug.stats.istats.bb_watchdog);
  }
  else 
#line 543 
       seq_printf(file,"%21s: %10u\n",(char *)"RX",sc->debug.stats.istats.rxok);
  
#line 545 
  seq_printf(file,"%21s: %10u\n",(char *)"RXEOL",sc->debug.stats.istats.rxeol);
  
#line 546 
  seq_printf(file,"%21s: %10u\n",(char *)"RXORN",sc->debug.stats.istats.rxorn);
  
#line 547 
  seq_printf(file,"%21s: %10u\n",(char *)"TX",sc->debug.stats.istats.txok);
  
#line 548 
  seq_printf(file,"%21s: %10u\n",(char *)"TXURN",sc->debug.stats.istats.txurn);
  
#line 549 
  seq_printf(file,"%21s: %10u\n",(char *)"MIB",sc->debug.stats.istats.mib);
  
#line 550 
  seq_printf(file,"%21s: %10u\n",(char *)"RXPHY",sc->debug.stats.istats.rxphyerr);
  
#line 551 
  seq_printf(file,"%21s: %10u\n",(char *)"RXKCM",sc->debug.stats.istats.rx_keycache_miss);
  
#line 552 
  seq_printf(file,"%21s: %10u\n",(char *)"SWBA",sc->debug.stats.istats.swba);
  
#line 553 
  seq_printf(file,"%21s: %10u\n",(char *)"BMISS",sc->debug.stats.istats.bmiss);
  
#line 554 
  seq_printf(file,"%21s: %10u\n",(char *)"BNR",sc->debug.stats.istats.bnr);
  
#line 555 
  seq_printf(file,"%21s: %10u\n",(char *)"CST",sc->debug.stats.istats.cst);
  
#line 556 
  seq_printf(file,"%21s: %10u\n",(char *)"GTT",sc->debug.stats.istats.gtt);
  
#line 557 
  seq_printf(file,"%21s: %10u\n",(char *)"TIM",sc->debug.stats.istats.tim);
  
#line 558 
  seq_printf(file,"%21s: %10u\n",(char *)"CABEND",sc->debug.stats.istats.cabend);
  
#line 559 
  seq_printf(file,"%21s: %10u\n",(char *)"DTIMSYNC",sc->debug.stats.istats.dtimsync);
  
#line 560 
  seq_printf(file,"%21s: %10u\n",(char *)"DTIM",sc->debug.stats.istats.dtim);
  
#line 561 
  seq_printf(file,"%21s: %10u\n",(char *)"TSFOOR",sc->debug.stats.istats.tsfoor);
  
#line 562 
  seq_printf(file,"%21s: %10u\n",(char *)"MCI",sc->debug.stats.istats.mci);
  
#line 563 
  seq_printf(file,"%21s: %10u\n",(char *)"GENTIMER",sc->debug.stats.istats.gen_timer);
  
#line 564 
  seq_printf(file,"%21s: %10u\n",(char *)"TOTAL",sc->debug.stats.istats.total);
  
#line 566 
  seq_puts(file,"SYNC_CAUSE stats:\n");
  
#line 568 
  seq_printf(file,"%21s: %10u\n",(char *)"Sync-All",sc->debug.stats.istats.sync_cause_all);
  
#line 569 
  seq_printf(file,"%21s: %10u\n",(char *)"RTC-IRQ",sc->debug.stats.istats.sync_rtc_irq);
  
#line 570 
  seq_printf(file,"%21s: %10u\n",(char *)"MAC-IRQ",sc->debug.stats.istats.sync_mac_irq);
  
#line 571 
  seq_printf(file,"%21s: %10u\n",(char *)"EEPROM-Illegal-Access",sc->debug.stats.istats.eeprom_illegal_access);
  
#line 572 
  seq_printf(file,"%21s: %10u\n",(char *)"APB-Timeout",sc->debug.stats.istats.apb_timeout);
  
#line 573 
  seq_printf(file,"%21s: %10u\n",(char *)"PCI-Mode-Conflict",sc->debug.stats.istats.pci_mode_conflict);
  
#line 574 
  seq_printf(file,"%21s: %10u\n",(char *)"HOST1-Fatal",sc->debug.stats.istats.host1_fatal);
  
#line 575 
  seq_printf(file,"%21s: %10u\n",(char *)"HOST1-Perr",sc->debug.stats.istats.host1_perr);
  
#line 576 
  seq_printf(file,"%21s: %10u\n",(char *)"TRCV-FIFO-Perr",sc->debug.stats.istats.trcv_fifo_perr);
  
#line 577 
  seq_printf(file,"%21s: %10u\n",(char *)"RADM-CPL-EP",sc->debug.stats.istats.radm_cpl_ep);
  
#line 578 
  seq_printf(file,"%21s: %10u\n",(char *)"RADM-CPL-DLLP-Abort",sc->debug.stats.istats.radm_cpl_dllp_abort);
  
#line 579 
  seq_printf(file,"%21s: %10u\n",(char *)"RADM-CPL-TLP-Abort",sc->debug.stats.istats.radm_cpl_tlp_abort);
  
#line 580 
  seq_printf(file,"%21s: %10u\n",(char *)"RADM-CPL-ECRC-Err",sc->debug.stats.istats.radm_cpl_ecrc_err);
  
#line 581 
  seq_printf(file,"%21s: %10u\n",(char *)"RADM-CPL-Timeout",sc->debug.stats.istats.radm_cpl_timeout);
  
#line 582 
  seq_printf(file,"%21s: %10u\n",(char *)"Local-Bus-Timeout",sc->debug.stats.istats.local_timeout);
  
#line 583 
  seq_printf(file,"%21s: %10u\n",(char *)"PM-Access",sc->debug.stats.istats.pm_access);
  
#line 584 
  seq_printf(file,"%21s: %10u\n",(char *)"MAC-Awake",sc->debug.stats.istats.mac_awake);
  
#line 585 
  seq_printf(file,"%21s: %10u\n",(char *)"MAC-Asleep",sc->debug.stats.istats.mac_asleep);
  
#line 586 
  seq_printf(file,"%21s: %10u\n",(char *)"MAC-Sleep-Access",sc->debug.stats.istats.mac_sleep_access);
  
#line 588 
  __retres = 0;
  
#line 588 
  return __retres;
}


#line 591  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static int read_file_xmit(struct seq_file *file, void *data)
{
  int __retres;
  
#line 593 
  struct ieee80211_hw *hw = dev_get_drvdata((struct device const *)file->private);
  
#line 594 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 596 
  seq_printf(file,"%30s %10s%10s%10s\n\n",(char *)"BE",(char *)"BK",(char *)"VI",(char *)"VO");
  
#line 598 
  seq_printf(file,"%s%13u%11u%10u%10u\n",(char *)"MPDUs Queued:    ",sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].queued,sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].queued,sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].queued,sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].queued);
  
#line 599 
  seq_printf(file,"%s%13u%11u%10u%10u\n",(char *)"MPDUs Completed: ",sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].completed,sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].completed,sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].completed,sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].completed);
  
#line 600 
  seq_printf(file,"%s%13u%11u%10u%10u\n",(char *)"MPDUs XRetried:  ",sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].xretries,sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].xretries,sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].xretries,sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].xretries);
  
#line 601 
  seq_printf(file,"%s%13u%11u%10u%10u\n",(char *)"Aggregates:      ",sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].a_aggr,sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].a_aggr,sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].a_aggr,sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].a_aggr);
  
#line 602 
  seq_printf(file,"%s%13u%11u%10u%10u\n",(char *)"AMPDUs Queued HW:",sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].a_queued_hw,sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].a_queued_hw,sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].a_queued_hw,sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].a_queued_hw);
  
#line 603 
  seq_printf(file,"%s%13u%11u%10u%10u\n",(char *)"AMPDUs Queued SW:",sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].a_queued_sw,sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].a_queued_sw,sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].a_queued_sw,sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].a_queued_sw);
  
#line 604 
  seq_printf(file,"%s%13u%11u%10u%10u\n",(char *)"AMPDUs Completed:",sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].a_completed,sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].a_completed,sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].a_completed,sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].a_completed);
  
#line 605 
  seq_printf(file,"%s%13u%11u%10u%10u\n",(char *)"AMPDUs Retried:  ",sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].a_retries,sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].a_retries,sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].a_retries,sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].a_retries);
  
#line 606 
  seq_printf(file,"%s%13u%11u%10u%10u\n",(char *)"AMPDUs XRetried: ",sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].a_xretries,sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].a_xretries,sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].a_xretries,sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].a_xretries);
  
#line 607 
  seq_printf(file,"%s%13u%11u%10u%10u\n",(char *)"TXERR Filtered:  ",sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].txerr_filtered,sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].txerr_filtered,sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].txerr_filtered,sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].txerr_filtered);
  
#line 608 
  seq_printf(file,"%s%13u%11u%10u%10u\n",(char *)"FIFO Underrun:   ",sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].fifo_underrun,sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].fifo_underrun,sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].fifo_underrun,sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].fifo_underrun);
  
#line 609 
  seq_printf(file,"%s%13u%11u%10u%10u\n",(char *)"TXOP Exceeded:   ",sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].xtxop,sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].xtxop,sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].xtxop,sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].xtxop);
  
#line 610 
  seq_printf(file,"%s%13u%11u%10u%10u\n",(char *)"TXTIMER Expiry:  ",sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].timer_exp,sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].timer_exp,sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].timer_exp,sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].timer_exp);
  
#line 611 
  seq_printf(file,"%s%13u%11u%10u%10u\n",(char *)"DESC CFG Error:  ",sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].desc_cfg_err,sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].desc_cfg_err,sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].desc_cfg_err,sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].desc_cfg_err);
  
#line 612 
  seq_printf(file,"%s%13u%11u%10u%10u\n",(char *)"DATA Underrun:   ",sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].data_underrun,sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].data_underrun,sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].data_underrun,sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].data_underrun);
  
#line 613 
  seq_printf(file,"%s%13u%11u%10u%10u\n",(char *)"DELIM Underrun:  ",sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].delim_underrun,sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].delim_underrun,sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].delim_underrun,sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].delim_underrun);
  
#line 614 
  seq_printf(file,"%s%13u%11u%10u%10u\n",(char *)"TX-Pkts-All:     ",sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].tx_pkts_all,sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].tx_pkts_all,sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].tx_pkts_all,sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].tx_pkts_all);
  
#line 615 
  seq_printf(file,"%s%13u%11u%10u%10u\n",(char *)"TX-Bytes-All:    ",sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].tx_bytes_all,sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].tx_bytes_all,sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].tx_bytes_all,sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].tx_bytes_all);
  
#line 616 
  seq_printf(file,"%s%13u%11u%10u%10u\n",(char *)"HW-put-tx-buf:   ",sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].puttxbuf,sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].puttxbuf,sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].puttxbuf,sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].puttxbuf);
  
#line 617 
  seq_printf(file,"%s%13u%11u%10u%10u\n",(char *)"HW-tx-start:     ",sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].txstart,sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].txstart,sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].txstart,sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].txstart);
  
#line 618 
  seq_printf(file,"%s%13u%11u%10u%10u\n",(char *)"HW-tx-proc-desc: ",sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].txprocdesc,sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].txprocdesc,sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].txprocdesc,sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].txprocdesc);
  
#line 619 
  seq_printf(file,"%s%13u%11u%10u%10u\n",(char *)"TX-Failed:       ",sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].txfailed,sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].txfailed,sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].txfailed,sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].txfailed);
  
#line 621 
  __retres = 0;
  
#line 621 
  return __retres;
}


#line 624  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static void print_queue(struct ath_softc *sc, struct ath_txq *txq, struct seq_file *file)
{
  
#line 627 
  ath_txq_lock(sc,txq);
  
#line 629 
  seq_printf(file,"%s: %d ",(char *)"qnum",txq->axq_qnum);
  
#line 630 
  seq_printf(file,"%s: %2d ",(char *)"qdepth",txq->axq_depth);
  
#line 631 
  seq_printf(file,"%s: %2d ",(char *)"ampdu-depth",txq->axq_ampdu_depth);
  
#line 632 
  seq_printf(file,"%s: %3d ",(char *)"pending",txq->pending_frames);
  
#line 633 
  seq_printf(file,"%s: %d\n",(char *)"stopped",(int)txq->stopped);
  
#line 635 
  ath_txq_unlock(sc,txq);
  
#line 636 
  return;
}


#line 638  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static int read_file_queues(struct seq_file *file, void *data)
{
  int __retres;
  struct ath_txq *txq;
  int i;
  
#line 640 
  struct ieee80211_hw *hw = dev_get_drvdata((struct device const *)file->private);
  
#line 641 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 644 
  char const *qname[4U] = {"VO", "VI", "BE", "BK"};
  
#line 648 
  i = 0;
  
#line 648 
  goto ldv_53813;
  ldv_53812: 
#line 649 
  ;
  
#line 649 
  txq = sc->tx.txq_map[i];
  
#line 650 
  seq_printf(file,"(%s):  ",qname[i]);
  
#line 651 
  print_queue(sc,txq,file);
  
#line 648 
  i += 1;
  ldv_53813: 
#line 649 
  ;
  
#line 648 
  if (i <= 3) 
#line 650 
              goto ldv_53812; else 
#line 653 
                                   goto ldv_53814;
  ldv_53814: 
#line 654 
  ;
  
#line 654 
  seq_puts(file,"(CAB): ");
  
#line 655 
  print_queue(sc,sc->beacon.cabq,file);
  
#line 657 
  __retres = 0;
  
#line 657 
  return __retres;
}


#line 660  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static int read_file_misc(struct seq_file *file, void *data)
{
  int __retres;
  struct ath9k_vif_iter_data iter_data;
  struct ath_chanctx *ctx;
  unsigned int reg;
  u32 rxfilter;
  u32 i;
  char const *tmp_1;
  int tmp_2;
  u32 tmp_3;
  
#line 662 
  struct ieee80211_hw *hw = dev_get_drvdata((struct device const *)file->private);
  
#line 663 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 664 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 670 
  seq_printf(file,"BSSID: %pM\n",(u8 *)(& common->curbssid));
  
#line 671 
  seq_printf(file,"BSSID-MASK: %pM\n",(u8 *)(& common->bssidmask));
  
#line 672 
  tmp_1 = ath_opmode_to_string((sc->sc_ah)->opmode);
  
#line 672 
  ;
  
#line 672 
  seq_printf(file,"OPMODE: %s\n",tmp_1);
  
#line 675 
  ath9k_ps_wakeup(sc);
  
#line 676 
  rxfilter = ath9k_hw_getrxfilter(sc->sc_ah);
  
#line 677 
  ath9k_ps_restore(sc);
  
#line 679 
  seq_printf(file,"RXFILTER: 0x%x",rxfilter);
  
#line 681 
  if ((rxfilter & 1U) != 0U) 
#line 682 
                             seq_puts(file," UCAST"); else ;
  
#line 683 
  if ((rxfilter & 2U) != 0U) 
#line 684 
                             seq_puts(file," MCAST"); else ;
  
#line 685 
  if ((rxfilter & 4U) != 0U) 
#line 686 
                             seq_puts(file," BCAST"); else ;
  
#line 687 
  if ((rxfilter & 8U) != 0U) 
#line 688 
                             seq_puts(file," CONTROL"); else ;
  
#line 689 
  if ((rxfilter & 16U) != 0U) 
#line 690 
                              seq_puts(file," BEACON"); else ;
  
#line 691 
  if ((rxfilter & 32U) != 0U) 
#line 692 
                              seq_puts(file," PROM"); else ;
  
#line 693 
  if ((rxfilter & 128U) != 0U) 
#line 694 
                               seq_puts(file," PROBEREQ"); else ;
  
#line 695 
  if ((rxfilter & 256U) != 0U) 
#line 696 
                               seq_puts(file," PHYERR"); else ;
  
#line 697 
  if ((rxfilter & 512U) != 0U) 
#line 698 
                               seq_puts(file," MYBEACON"); else ;
  
#line 699 
  if ((rxfilter & 1024U) != 0U) 
#line 700 
                                seq_puts(file," COMP_BAR"); else ;
  
#line 701 
  if ((rxfilter & 16384U) != 0U) 
#line 702 
                                 seq_puts(file," PSPOLL"); else ;
  
#line 703 
  if ((rxfilter & 8192U) != 0U) 
#line 704 
                                seq_puts(file," PHYRADAR"); else ;
  
#line 705 
  if ((rxfilter & 32768U) != 0U) 
#line 706 
                                 seq_puts(file," MCAST_BCAST_ALL"); else ;
  
#line 707 
  if ((rxfilter & 524288U) != 0U) 
#line 708 
                                  seq_puts(file," CONTROL_WRAPPER"); else ;
  
#line 710 
  seq_puts(file,"\n");
  
#line 712 
  reg = (unsigned int)(sc->sc_ah)->imask;
  
#line 714 
  seq_printf(file,"INTERRUPT-MASK: 0x%x",reg);
  
#line 716 
  if ((reg & 65536U) != 0U) 
#line 717 
                            seq_puts(file," SWBA"); else ;
  
#line 718 
  if ((reg & 262144U) != 0U) 
#line 719 
                             seq_puts(file," BMISS"); else ;
  
#line 720 
  if ((reg & 268435456U) != 0U) 
#line 721 
                                seq_puts(file," CST"); else ;
  
#line 722 
  if ((reg & 1U) != 0U) 
#line 723 
                        seq_puts(file," RX"); else ;
  
#line 724 
  if ((reg & 1U) != 0U) 
#line 725 
                        seq_puts(file," RXHP"); else ;
  
#line 726 
  if ((reg & 2U) != 0U) 
#line 727 
                        seq_puts(file," RXLP"); else ;
  
#line 728 
  if ((reg & 1024U) != 0U) 
#line 729 
                           seq_puts(file," BB_WATCHDOG"); else ;
  
#line 731 
  seq_puts(file,"\n");
  
#line 733 
  i = 0U;
  
#line 734 
  ctx = & sc->chanctx[0];
  
#line 734 
  goto ldv_53832;
  ldv_53831: 
#line 735 
  ;
  
#line 735 
  tmp_2 = list_empty((struct list_head const *)(& ctx->vifs));
  
#line 735 
  if (tmp_2 != 0) 
#line 736 
                  goto ldv_53830; else ;
  
#line 737 
  ath9k_calculate_iter_data(sc,ctx,& iter_data);
  
#line 739 
  ;
  
#line 739 
  ;
  
#line 739 
  ;
  
#line 739 
  ;
  
#line 739 
  ;
  
#line 740 
  tmp_3 = i;
  
#line 740 
  i += 1U;
  
#line 739 
  ;
  
#line 739 
  ;
  
#line 739 
  seq_printf(file,"VIFS: CTX %i(%i) AP: %i STA: %i MESH: %i WDS: %i",tmp_3,(int)ctx->assigned,iter_data.naps,iter_data.nstations,iter_data.nmeshes,iter_data.nwds);
  
#line 744 
  seq_printf(file," ADHOC: %i TOTAL: %hi BEACON-VIF: %hi\n",iter_data.nadhocs,(int)(sc->cur_chan)->nvifs,(int)sc->nbcnvifs);
  ldv_53830: 
#line 747 
  ;
  
#line 734 
  ctx += 1;
  ldv_53832: 
#line 735 
  ;
  
#line 734 
  if (& sc->chanctx[1UL] >= ctx) 
#line 736 
                                 goto ldv_53831; else 
#line 739 
                                                      goto ldv_53833;
  ldv_53833: 
#line 740 
  ;
  
#line 749 
  __retres = 0;
  
#line 749 
  return __retres;
}


#line 752  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static int read_file_reset(struct seq_file *file, void *data)
{
  int __retres;
  int i;
  
#line 754 
  struct ieee80211_hw *hw = dev_get_drvdata((struct device const *)file->private);
  
#line 755 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 756 
  char const * const reset_cause[11U] = {"Baseband Hang", "Baseband Watchdog", "Fatal HW Error", "TX HW error", "Transmit timeout", "TX Path Hang", "PLL RX Hang", "MAC Hang", "Stuck Beacon", "MCI Reset", "Calibration error"};
  
#line 771 
  i = 0;
  
#line 771 
  goto ldv_53847;
  ldv_53846: 
#line 772 
  ;
  
#line 772 
  if (reset_cause[i] == (char const *)0) 
#line 773 
                                         goto ldv_53845; else ;
  
#line 775 
  seq_printf(file,"%17s: %2d\n",reset_cause[i],sc->debug.stats.reset[i]);
  ldv_53845: 
#line 777 
  ;
  
#line 771 
  i += 1;
  ldv_53847: 
#line 772 
  ;
  
#line 771 
  if ((unsigned int)i <= 10U) 
#line 773 
                              goto ldv_53846; else 
#line 776 
                                                   goto ldv_53848;
  ldv_53848: 
#line 777 
  ;
  
#line 779 
  __retres = 0;
  
#line 779 
  return __retres;
}


#line 782  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
void ath_debug_stat_tx(struct ath_softc *sc, struct ath_buf *bf, struct ath_tx_status *ts, struct ath_txq *txq, unsigned int flags)
{
  
#line 786 
  int qnum = (int)txq->axq_qnum;
  
#line 788 
  sc->debug.stats.txstats[qnum].tx_pkts_all += 1U;
  
#line 789 
  sc->debug.stats.txstats[qnum].tx_bytes_all += (bf->bf_mpdu)->len;
  
#line 791 
  if (((int)bf->bf_state.bf_type & 1) != 0) 
    
#line 792 
    if ((flags & 1U) != 0U) 
#line 793 
                            sc->debug.stats.txstats[qnum].a_xretries += 1U; else 
                                                                    
#line 795 
                                                                    sc->debug.stats.txstats[qnum].a_completed += 1U;
  else 
    
#line 797 
    if (((int)ts->ts_status & 1) != 0) 
#line 798 
                                       sc->debug.stats.txstats[qnum].xretries += 1U; else 
                                                                    
#line 800 
                                                                    sc->debug.stats.txstats[qnum].completed += 1U;
  
#line 803 
  if (((int)ts->ts_status & 2) != 0) 
#line 804 
                                     sc->debug.stats.txstats[qnum].txerr_filtered += 1U; else ;
  
#line 805 
  if (((int)ts->ts_status & 4) != 0) 
#line 806 
                                     sc->debug.stats.txstats[qnum].fifo_underrun += 1U; else ;
  
#line 807 
  if (((int)ts->ts_status & 8) != 0) 
#line 808 
                                     sc->debug.stats.txstats[qnum].xtxop += 1U; else ;
  
#line 809 
  if (((int)ts->ts_status & 16) != 0) 
#line 810 
                                      sc->debug.stats.txstats[qnum].timer_exp += 1U; else ;
  
#line 811 
  if (((int)ts->ts_flags & 4) != 0) 
#line 812 
                                    sc->debug.stats.txstats[qnum].desc_cfg_err += 1U; else ;
  
#line 813 
  if (((int)ts->ts_flags & 8) != 0) 
#line 814 
                                    sc->debug.stats.txstats[qnum].data_underrun += 1U; else ;
  
#line 815 
  if (((int)ts->ts_flags & 16) != 0) 
#line 816 
                                     sc->debug.stats.txstats[qnum].delim_underrun += 1U; else ;
  
#line 817 
  return;
}


#line 819  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
void ath_debug_stat_rx(struct ath_softc *sc, struct ath_rx_status *rs)
{
  
#line 821 
  ath9k_cmn_debug_stat_rx(& sc->debug.stats.rxstats,rs);
  
#line 822 
  return;
}


#line 824  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static ssize_t read_file_regidx(struct file *file, char *user_buf, size_t count, loff_t *ppos)
{
  char buf[32U];
  unsigned int len;
  int tmp;
  ssize_t tmp_0;
  
#line 827 
  struct ath_softc *sc = (struct ath_softc *)file->private_data;
  
#line 831 
  tmp = sprintf((char *)(& buf),"0x%08x\n",sc->debug.regidx);
  
#line 831 
  len = (unsigned int)tmp;
  
#line 832 
  tmp_0 = simple_read_from_buffer((void *)user_buf,count,ppos,(void const *)(& buf),(unsigned long)len);
  
#line 832 
  return tmp_0;
}


#line 835  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static ssize_t write_file_regidx(struct file *file, char const *user_buf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  unsigned long regidx;
  char buf[32U];
  ssize_t len;
  unsigned long tmp_0;
  unsigned long tmp_1;
  int tmp_2;
  
#line 838 
  struct ath_softc *sc = (struct ath_softc *)file->private_data;
  {
    unsigned long tmp;
    
#line 843 
    size_t _min1 = count;
    
#line 843 
    unsigned long _min2 = 31UL;
    
#line 843 
    if (_min1 < _min2) 
#line 843 
                       tmp = _min1; else 
#line 843 
                                         tmp = _min2;
    
#line 843 
    tmp_0 = tmp;
  }
  
#line 843 
  len = (long)tmp_0;
  
#line 844 
  tmp_1 = copy_from_user((void *)(& buf),(void const *)user_buf,(unsigned long)len);
  
#line 844 
  if (tmp_1 != 0UL) {
    
#line 845 
    __retres = -14L;
    
#line 845 
    goto return_label;
  }
  else ;
  
#line 847 
  buf[len] = (char)0;
  
#line 848 
  tmp_2 = kstrtoul((char const *)(& buf),0U,& regidx);
  
#line 848 
  if (tmp_2 != 0) {
    
#line 849 
    __retres = -22L;
    
#line 849 
    goto return_label;
  }
  else ;
  
#line 851 
  sc->debug.regidx = (unsigned int)regidx;
  
#line 852 
  __retres = (long)count;
  return_label: 
#line 852 
                return __retres;
}


#line 855  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static struct file_operations const fops_regidx = {.owner = & __this_module, .llseek = & default_llseek, .read = & read_file_regidx, .write = & write_file_regidx, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 863  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static ssize_t read_file_regval(struct file *file, char *user_buf, size_t count, loff_t *ppos)
{
  char buf[32U];
  unsigned int len;
  u32 regval;
  struct ath_common *tmp;
  int tmp_0;
  ssize_t tmp_1;
  
#line 866 
  struct ath_softc *sc = (struct ath_softc *)file->private_data;
  
#line 867 
  struct ath_hw *ah = sc->sc_ah;
  
#line 872 
  ath9k_ps_wakeup(sc);
  
#line 873 
  tmp = ath9k_hw_common(ah);
  
#line 873 
  regval = (*((tmp->ops)->read))((void *)ah,sc->debug.regidx);
  
#line 874 
  ath9k_ps_restore(sc);
  
#line 875 
  tmp_0 = sprintf((char *)(& buf),"0x%08x\n",regval);
  
#line 875 
  len = (unsigned int)tmp_0;
  
#line 876 
  tmp_1 = simple_read_from_buffer((void *)user_buf,count,ppos,(void const *)(& buf),(unsigned long)len);
  
#line 876 
  return tmp_1;
}


#line 879  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static ssize_t write_file_regval(struct file *file, char const *user_buf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  unsigned long regval;
  char buf[32U];
  ssize_t len;
  unsigned long tmp_0;
  unsigned long tmp_1;
  int tmp_2;
  struct ath_common *tmp_3;
  
#line 882 
  struct ath_softc *sc = (struct ath_softc *)file->private_data;
  
#line 883 
  struct ath_hw *ah = sc->sc_ah;
  {
    unsigned long tmp;
    
#line 888 
    size_t _min1 = count;
    
#line 888 
    unsigned long _min2 = 31UL;
    
#line 888 
    if (_min1 < _min2) 
#line 888 
                       tmp = _min1; else 
#line 888 
                                         tmp = _min2;
    
#line 888 
    tmp_0 = tmp;
  }
  
#line 888 
  len = (long)tmp_0;
  
#line 889 
  tmp_1 = copy_from_user((void *)(& buf),(void const *)user_buf,(unsigned long)len);
  
#line 889 
  if (tmp_1 != 0UL) {
    
#line 890 
    __retres = -14L;
    
#line 890 
    goto return_label;
  }
  else ;
  
#line 892 
  buf[len] = (char)0;
  
#line 893 
  tmp_2 = kstrtoul((char const *)(& buf),0U,& regval);
  
#line 893 
  if (tmp_2 != 0) {
    
#line 894 
    __retres = -22L;
    
#line 894 
    goto return_label;
  }
  else ;
  
#line 896 
  ath9k_ps_wakeup(sc);
  
#line 897 
  tmp_3 = ath9k_hw_common(ah);
  
#line 897 
  (*((tmp_3->ops)->write))((void *)ah,(unsigned int)regval,sc->debug.regidx);
  
#line 898 
  ath9k_ps_restore(sc);
  
#line 899 
  __retres = (long)count;
  return_label: 
#line 899 
                return __retres;
}


#line 902  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static struct file_operations const fops_regval = {.owner = & __this_module, .llseek = & default_llseek, .read = & read_file_regval, .write = & write_file_regval, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 912  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static int open_file_regdump(struct inode *inode, struct file *file)
{
  int __retres;
  u8 *buf;
  int i;
  unsigned long num_regs;
  unsigned long regdump_len;
  unsigned long max_reg_offset;
  int tmp;
  int tmp_2;
  unsigned int tmp_1;
  
#line 914 
  struct ath_softc *sc = (struct ath_softc *)inode->i_private;
  
#line 915 
  unsigned int len = 0U;
  
#line 920 
  if ((sc->sc_ah)->hw_version.macVersion > 447U) 
#line 920 
                                                 tmp = 93140; else 
#line 920 
                                                                   tmp = 46336;
  
#line 920 
  max_reg_offset = (unsigned long)tmp;
  
#line 921 
  num_regs = max_reg_offset / 4UL + 1UL;
  
#line 922 
  regdump_len = num_regs * 20UL + 1UL;
  
#line 923 
  buf = (u8 *)vmalloc(regdump_len);
  
#line 924 
  if (buf == (u8 *)0U) {
    
#line 925 
    __retres = -12;
    
#line 925 
    goto return_label;
  }
  else ;
  
#line 927 
  ath9k_ps_wakeup(sc);
  
#line 928 
  i = 0;
  
#line 928 
  goto ldv_53922;
  ldv_53921: 
#line 929 
  ;
  
#line 930 
  tmp_1 = (*((sc->sc_ah)->reg_ops.read))((void *)sc->sc_ah,(unsigned int)(i << 2));
  
#line 929 
  ;
  
#line 929 
  ;
  
#line 929 
  ;
  
#line 929 
  tmp_2 = scnprintf((char *)(buf + len),regdump_len - (unsigned long)len,"0x%06x 0x%08x\n",i << 2,tmp_1);
  
#line 930 
  len = (unsigned int)tmp_2 + len;
  
#line 928 
  i += 1;
  ldv_53922: 
#line 929 
  ;
  
#line 928 
  if ((unsigned long)i < num_regs) 
#line 930 
                                   goto ldv_53921; else 
#line 933 
                                                        goto ldv_53923;
  ldv_53923: 
#line 934 
  ;
  
#line 931 
  ath9k_ps_restore(sc);
  
#line 933 
  file->private_data = (void *)buf;
  
#line 935 
  __retres = 0;
  return_label: 
#line 935 
                return __retres;
}


#line 938  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static struct file_operations const fops_regdump = {.owner = & __this_module, .llseek = & default_llseek, .read = & ath9k_debugfs_read_buf, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & open_file_regdump, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = & ath9k_debugfs_release_buf, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 946  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static int read_file_dump_nfcal(struct seq_file *file, void *data)
{
  int __retres;
  u32 i;
  u32 j;
  u8 nread;
  
#line 948 
  struct ieee80211_hw *hw = dev_get_drvdata((struct device const *)file->private);
  
#line 949 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 950 
  struct ath_hw *ah = sc->sc_ah;
  
#line 951 
  struct ath9k_nfcal_hist *h = (struct ath9k_nfcal_hist *)(& (sc->cur_chan)->caldata.nfCalHist);
  
#line 952 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 953 
  struct ieee80211_conf *conf = & (common->hw)->conf;
  
#line 955 
  u8 chainmask = (unsigned char)(((int)ah->rxchainmask << 3) | (int)ah->rxchainmask);
  
#line 958 
  seq_printf(file,"Channel Noise Floor : %d\n",(int)ah->noise);
  
#line 959 
  seq_puts(file,"Chain | privNF | # Readings | NF Readings\n");
  
#line 960 
  i = 0U;
  
#line 960 
  goto ldv_53944;
  ldv_53943: 
#line 961 
  ;
  
#line 961 
  if ((((int)chainmask >> i) & 1) == 0) 
#line 961 
                                        goto _LOR;
  else 
    
#line 961 
    if (i > 2U) {
      int tmp_2;
      bool tmp_1;
      
#line 962 
      tmp_1 = conf_is_ht40(conf);
      
#line 962 
      if (tmp_1) 
#line 962 
                 tmp_2 = 0; else 
#line 962 
                                 tmp_2 = 1;
      
#line 962 
      if (tmp_2) _LOR: 
#line 963 
                       goto ldv_53939; else ;
    }
    else ;
  
#line 965 
  nread = (unsigned char)(5U - (unsigned int)(h + i)->invalidNFcount);
  
#line 966 
  seq_printf(file," %d\t %d\t %d\t\t",i,(int)(h + i)->privNF,(int)nread);
  
#line 967 
  j = 0U;
  
#line 967 
  goto ldv_53941;
  ldv_53940: 
#line 968 
  ;
  
#line 968 
  seq_printf(file," %d",(int)(h + i)->nfCalBuffer[j]);
  
#line 967 
  j += 1U;
  ldv_53941: 
#line 968 
  ;
  
#line 967 
  if ((unsigned int)nread > j) 
#line 969 
                               goto ldv_53940; else 
#line 972 
                                                    goto ldv_53942;
  ldv_53942: 
#line 973 
  ;
  
#line 969 
  seq_puts(file,"\n");
  ldv_53939: 
#line 970 
  ;
  
#line 960 
  i += 1U;
  ldv_53944: 
#line 961 
  ;
  
#line 960 
  if (i <= 5U) 
#line 962 
               goto ldv_53943; else 
#line 965 
                                    goto ldv_53945;
  ldv_53945: 
#line 966 
  ;
  
#line 972 
  __retres = 0;
  
#line 972 
  return __retres;
}


#line 975  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static int open_file_dump_nfcal(struct inode *inode, struct file *f)
{
  int tmp;
  
#line 977 
  tmp = single_open(f,& read_file_dump_nfcal,inode->i_private);
  
#line 977 
  return tmp;
}


#line 980  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static struct file_operations const fops_dump_nfcal = {.owner = & __this_module, .llseek = & seq_lseek, .read = & seq_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & open_file_dump_nfcal, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = & single_release, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 989  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static ssize_t read_file_btcoex(struct file *file, char *user_buf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  char *buf;
  size_t retval;
  int tmp_1;
  ssize_t tmp_2;
  
#line 992 
  struct ath_softc *sc = (struct ath_softc *)file->private_data;
  
#line 993 
  u32 len = 0U;
  
#line 993 
  u32 size = 1500U;
  
#line 997 
  buf = (char *)kzalloc_0((unsigned long)size,208U);
  
#line 998 
  if (buf == (char *)0) {
    
#line 999 
    __retres = -12L;
    
#line 999 
    goto return_label;
  }
  else ;
  
#line 1001 
  if (! (sc->sc_ah)->common.btcoex_enabled) {
    int tmp_0;
    
#line 1002 
    tmp_0 = scnprintf(buf,(unsigned long)size,"%s\n",(char *)"BTCOEX is disabled");
    
#line 1002 
    len = (unsigned int)tmp_0;
    
#line 1004 
    goto exit;
  }
  else ;
  
#line 1007 
  tmp_1 = ath9k_dump_btcoex(sc,(u8 *)buf,size);
  
#line 1007 
  len = (unsigned int)tmp_1;
  exit: 
#line 1008 
  ;
  
#line 1009 
  tmp_2 = simple_read_from_buffer((void *)user_buf,count,ppos,(void const *)buf,(unsigned long)len);
  
#line 1009 
  retval = (unsigned long)tmp_2;
  
#line 1010 
  kfree((void const *)buf);
  
#line 1012 
  __retres = (long)retval;
  return_label: 
#line 1012 
                return __retres;
}


#line 1015  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static struct file_operations const fops_btcoex = {.owner = & __this_module, .llseek = & default_llseek, .read = & read_file_btcoex, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 1024  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static ssize_t read_file_ackto(struct file *file, char *user_buf, size_t count, loff_t *ppos)
{
  char buf[32U];
  unsigned int len;
  int tmp_0;
  int tmp;
  ssize_t tmp_1;
  
#line 1027 
  struct ath_softc *sc = (struct ath_softc *)file->private_data;
  
#line 1028 
  struct ath_hw *ah = sc->sc_ah;
  
#line 1032 
  if ((int)ah->dynack.enabled != 0) 
#line 1032 
                                    tmp = 65; else 
#line 1032 
                                                   tmp = 83;
  
#line 1032 
  ;
  
#line 1032 
  tmp_0 = sprintf((char *)(& buf),"%u %c\n",ah->dynack.ackto,tmp);
  
#line 1032 
  len = (unsigned int)tmp_0;
  
#line 1035 
  tmp_1 = simple_read_from_buffer((void *)user_buf,count,ppos,(void const *)(& buf),(unsigned long)len);
  
#line 1035 
  return tmp_1;
}


#line 1038  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static struct file_operations const fops_ackto = {.owner = & __this_module, .llseek = & default_llseek, .read = & read_file_ackto, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 1048  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static ssize_t read_file_wow(struct file *file, char *user_buf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  ssize_t retval;
  char *buf;
  int tmp_1;
  char *tmp_0;
  
#line 1051 
  struct ath_softc *sc = (struct ath_softc *)file->private_data;
  
#line 1052 
  unsigned int len = 0U;
  
#line 1052 
  unsigned int size = 32U;
  
#line 1056 
  buf = (char *)kzalloc_0((unsigned long)size,208U);
  
#line 1057 
  if (buf == (char *)0) {
    
#line 1058 
    __retres = -12L;
    
#line 1058 
    goto return_label;
  }
  else ;
  
#line 1060 
  if ((int)sc->force_wow != 0) 
#line 1060 
                               tmp_0 = (char *)"ENABLED"; else 
#line 1060 
                                                               tmp_0 = (char *)"DISABLED";
  
#line 1060 
  ;
  
#line 1060 
  ;
  
#line 1060 
  tmp_1 = scnprintf(buf + len,(unsigned long)(size - len),"WOW: %s\n",tmp_0);
  
#line 1061 
  len = (unsigned int)tmp_1 + len;
  
#line 1063 
  if (len > size) 
#line 1064 
                  len = size; else ;
  
#line 1066 
  retval = simple_read_from_buffer((void *)user_buf,count,ppos,(void const *)buf,(unsigned long)len);
  
#line 1067 
  kfree((void const *)buf);
  
#line 1069 
  __retres = retval;
  return_label: 
#line 1069 
                return __retres;
}


#line 1072  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static ssize_t write_file_wow(struct file *file, char const *user_buf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  unsigned long val;
  char buf[32U];
  ssize_t len;
  unsigned long tmp_0;
  unsigned long tmp_1;
  int tmp_2;
  
#line 1075 
  struct ath_softc *sc = (struct ath_softc *)file->private_data;
  {
    unsigned long tmp;
    
#line 1080 
    size_t _min1 = count;
    
#line 1080 
    unsigned long _min2 = 31UL;
    
#line 1080 
    if (_min1 < _min2) 
#line 1080 
                       tmp = _min1; else 
#line 1080 
                                         tmp = _min2;
    
#line 1080 
    tmp_0 = tmp;
  }
  
#line 1080 
  len = (long)tmp_0;
  
#line 1081 
  tmp_1 = copy_from_user((void *)(& buf),(void const *)user_buf,(unsigned long)len);
  
#line 1081 
  if (tmp_1 != 0UL) {
    
#line 1082 
    __retres = -14L;
    
#line 1082 
    goto return_label;
  }
  else ;
  
#line 1084 
  buf[len] = (char)0;
  
#line 1085 
  tmp_2 = kstrtoul((char const *)(& buf),0U,& val);
  
#line 1085 
  if (tmp_2 != 0) {
    
#line 1086 
    __retres = -22L;
    
#line 1086 
    goto return_label;
  }
  else ;
  
#line 1088 
  if (val != 1UL) {
    
#line 1089 
    __retres = -22L;
    
#line 1089 
    goto return_label;
  }
  else ;
  
#line 1091 
  if (! sc->force_wow) {
    
#line 1092 
    sc->force_wow = (_Bool)1;
    
#line 1093 
    ath9k_init_wow(sc->hw);
  }
  else ;
  
#line 1096 
  __retres = (long)count;
  return_label: 
#line 1096 
                return __retres;
}


#line 1099  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static struct file_operations const fops_wow = {.owner = & __this_module, .llseek = & default_llseek, .read = & read_file_wow, .write = & write_file_wow, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 1109  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static ssize_t read_file_tpc(struct file *file, char *user_buf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  ssize_t retval;
  char *buf;
  int tmp_1;
  char *tmp_0;
  
#line 1112 
  struct ath_softc *sc = (struct ath_softc *)file->private_data;
  
#line 1113 
  struct ath_hw *ah = sc->sc_ah;
  
#line 1114 
  unsigned int len = 0U;
  
#line 1114 
  unsigned int size = 32U;
  
#line 1118 
  buf = (char *)kzalloc_0((unsigned long)size,208U);
  
#line 1119 
  if (buf == (char *)0) {
    
#line 1120 
    __retres = -12L;
    
#line 1120 
    goto return_label;
  }
  else ;
  
#line 1122 
  if ((int)ah->tpc_enabled != 0) 
#line 1122 
                                 tmp_0 = (char *)"ENABLED"; else 
#line 1122 
                                                                 tmp_0 = (char *)"DISABLED";
  
#line 1122 
  ;
  
#line 1122 
  ;
  
#line 1122 
  tmp_1 = scnprintf(buf + len,(unsigned long)(size - len),"%s\n",tmp_0);
  
#line 1123 
  len = (unsigned int)tmp_1 + len;
  
#line 1125 
  if (len > size) 
#line 1126 
                  len = size; else ;
  
#line 1128 
  retval = simple_read_from_buffer((void *)user_buf,count,ppos,(void const *)buf,(unsigned long)len);
  
#line 1129 
  kfree((void const *)buf);
  
#line 1131 
  __retres = retval;
  return_label: 
#line 1131 
                return __retres;
}


#line 1134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static ssize_t write_file_tpc(struct file *file, char const *user_buf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  unsigned long val;
  char buf[32U];
  ssize_t len;
  bool tpc_enabled;
  unsigned long tmp_0;
  unsigned long tmp_1;
  int tmp_2;
  
#line 1137 
  struct ath_softc *sc = (struct ath_softc *)file->private_data;
  
#line 1138 
  struct ath_hw *ah = sc->sc_ah;
  {
    unsigned long tmp;
    
#line 1144 
    size_t _min1 = count;
    
#line 1144 
    unsigned long _min2 = 31UL;
    
#line 1144 
    if (_min1 < _min2) 
#line 1144 
                       tmp = _min1; else 
#line 1144 
                                         tmp = _min2;
    
#line 1144 
    tmp_0 = tmp;
  }
  
#line 1144 
  len = (long)tmp_0;
  
#line 1145 
  tmp_1 = copy_from_user((void *)(& buf),(void const *)user_buf,(unsigned long)len);
  
#line 1145 
  if (tmp_1 != 0UL) {
    
#line 1146 
    __retres = -14L;
    
#line 1146 
    goto return_label;
  }
  else ;
  
#line 1148 
  buf[len] = (char)0;
  
#line 1149 
  tmp_2 = kstrtoul((char const *)(& buf),0U,& val);
  
#line 1149 
  if (tmp_2 != 0) {
    
#line 1150 
    __retres = -22L;
    
#line 1150 
    goto return_label;
  }
  else ;
  
#line 1152 
  if (val > 1UL) {
    
#line 1153 
    __retres = -22L;
    
#line 1153 
    goto return_label;
  }
  else ;
  
#line 1155 
  tpc_enabled = (_Bool)(val != 0UL);
  
#line 1157 
  if ((int)ah->tpc_enabled != (int)tpc_enabled) {
    
#line 1158 
    ah->tpc_enabled = tpc_enabled;
    
#line 1160 
    ldv_mutex_lock_72_0(& sc->mutex);
    
#line 1161 
    ath9k_set_txpower(sc,(struct ieee80211_vif *)0);
    
#line 1162 
    ldv_mutex_unlock_73(& sc->mutex);
  }
  else ;
  
#line 1165 
  __retres = (long)count;
  return_label: 
#line 1165 
                return __retres;
}


#line 1168  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static struct file_operations const fops_tpc = {.owner = & __this_module, .llseek = & default_llseek, .read = & read_file_tpc, .write = & write_file_tpc, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 1179  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
static char const ath9k_gstrings_stats[82U][32U] = {{(char)'t', (char)'x', (char)'_', (char)'p', (char)'k', (char)'t', (char)'s', (char)'_', (char)'n', (char)'i', (char)'c', (char)'\000'}, {(char)'t', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s', (char)'_', (char)'n', (char)'i', (char)'c', (char)'\000'}, {(char)'r', (char)'x', (char)'_', (char)'p', (char)'k', (char)'t', (char)'s', (char)'_', (char)'n', (char)'i', (char)'c', (char)'\000'}, {(char)'r', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s', (char)'_', (char)'n', (char)'i', (char)'c', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'p', (char)'k', (char)'t', (char)'s', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'p', (char)'k', (char)'t', (char)'s', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'p', (char)'k', (char)'t', (char)'s', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'p', (char)'k', (char)'t', (char)'s', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'m', (char)'p', (char)'d', (char)'u', (char)'s', (char)'_', (char)'q', (char)'u', (char)'e', (char)'u', (char)'e', (char)'d', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'m', (char)'p', (char)'d', (char)'u', (char)'s', (char)'_', (char)'q', (char)'u', (char)'e', (char)'u', (char)'e', (char)'d', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'m', (char)'p', (char)'d', (char)'u', (char)'s', (char)'_', (char)'q', (char)'u', (char)'e', (char)'u', (char)'e', (char)'d', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'m', (char)'p', (char)'d', (char)'u', (char)'s', (char)'_', (char)'q', (char)'u', (char)'e', (char)'u', (char)'e', (char)'d', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'m', (char)'p', (char)'d', (char)'u', (char)'s', (char)'_', (char)'c', (char)'o', (char)'m', (char)'p', (char)'l', (char)'e', (char)'t', (char)'e', (char)'d', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'m', (char)'p', (char)'d', (char)'u', (char)'s', (char)'_', (char)'c', (char)'o', (char)'m', (char)'p', (char)'l', (char)'e', (char)'t', (char)'e', (char)'d', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'m', (char)'p', (char)'d', (char)'u', (char)'s', (char)'_', (char)'c', (char)'o', (char)'m', (char)'p', (char)'l', (char)'e', (char)'t', (char)'e', (char)'d', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'m', (char)'p', (char)'d', (char)'u', (char)'s', (char)'_', (char)'c', (char)'o', (char)'m', (char)'p', (char)'l', (char)'e', (char)'t', (char)'e', (char)'d', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'m', (char)'p', (char)'d', (char)'u', (char)'_', (char)'x', (char)'r', (char)'e', (char)'t', (char)'r', (char)'i', (char)'e', (char)'s', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'m', (char)'p', (char)'d', (char)'u', (char)'_', (char)'x', (char)'r', (char)'e', (char)'t', (char)'r', (char)'i', (char)'e', (char)'s', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'m', (char)'p', (char)'d', (char)'u', (char)'_', (char)'x', (char)'r', (char)'e', (char)'t', (char)'r', (char)'i', (char)'e', (char)'s', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'m', (char)'p', (char)'d', (char)'u', (char)'_', (char)'x', (char)'r', (char)'e', (char)'t', (char)'r', (char)'i', (char)'e', (char)'s', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'a', (char)'g', (char)'g', (char)'r', (char)'e', (char)'g', (char)'a', (char)'t', (char)'e', (char)'s', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'a', (char)'g', (char)'g', (char)'r', (char)'e', (char)'g', (char)'a', (char)'t', (char)'e', (char)'s', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'a', (char)'g', (char)'g', (char)'r', (char)'e', (char)'g', (char)'a', (char)'t', (char)'e', (char)'s', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'a', (char)'g', (char)'g', (char)'r', (char)'e', (char)'g', (char)'a', (char)'t', (char)'e', (char)'s', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'a', (char)'m', (char)'p', (char)'d', (char)'u', (char)'s', (char)'_', (char)'q', (char)'u', (char)'e', (char)'u', (char)'e', (char)'d', (char)'_', (char)'h', (char)'w', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'a', (char)'m', (char)'p', (char)'d', (char)'u', (char)'s', (char)'_', (char)'q', (char)'u', (char)'e', (char)'u', (char)'e', (char)'d', (char)'_', (char)'h', (char)'w', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'a', (char)'m', (char)'p', (char)'d', (char)'u', (char)'s', (char)'_', (char)'q', (char)'u', (char)'e', (char)'u', (char)'e', (char)'d', (char)'_', (char)'h', (char)'w', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'a', (char)'m', (char)'p', (char)'d', (char)'u', (char)'s', (char)'_', (char)'q', (char)'u', (char)'e', (char)'u', (char)'e', (char)'d', (char)'_', (char)'h', (char)'w', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'a', (char)'m', (char)'p', (char)'d', (char)'u', (char)'s', (char)'_', (char)'q', (char)'u', (char)'e', (char)'u', (char)'e', (char)'d', (char)'_', (char)'s', (char)'w', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'a', (char)'m', (char)'p', (char)'d', (char)'u', (char)'s', (char)'_', (char)'q', (char)'u', (char)'e', (char)'u', (char)'e', (char)'d', (char)'_', (char)'s', (char)'w', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'a', (char)'m', (char)'p', (char)'d', (char)'u', (char)'s', (char)'_', (char)'q', (char)'u', (char)'e', (char)'u', (char)'e', (char)'d', (char)'_', (char)'s', (char)'w', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'a', (char)'m', (char)'p', (char)'d', (char)'u', (char)'s', (char)'_', (char)'q', (char)'u', (char)'e', (char)'u', (char)'e', (char)'d', (char)'_', (char)'s', (char)'w', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'a', (char)'m', (char)'p', (char)'d', (char)'u', (char)'s', (char)'_', (char)'c', (char)'o', (char)'m', (char)'p', (char)'l', (char)'e', (char)'t', (char)'e', (char)'d', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'a', (char)'m', (char)'p', (char)'d', (char)'u', (char)'s', (char)'_', (char)'c', (char)'o', (char)'m', (char)'p', (char)'l', (char)'e', (char)'t', (char)'e', (char)'d', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'a', (char)'m', (char)'p', (char)'d', (char)'u', (char)'s', (char)'_', (char)'c', (char)'o', (char)'m', (char)'p', (char)'l', (char)'e', (char)'t', (char)'e', (char)'d', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'a', (char)'m', (char)'p', (char)'d', (char)'u', (char)'s', (char)'_', (char)'c', (char)'o', (char)'m', (char)'p', (char)'l', (char)'e', (char)'t', (char)'e', (char)'d', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'a', (char)'m', (char)'p', (char)'d', (char)'u', (char)'_', (char)'r', (char)'e', (char)'t', (char)'r', (char)'i', (char)'e', (char)'s', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'a', (char)'m', (char)'p', (char)'d', (char)'u', (char)'_', (char)'r', (char)'e', (char)'t', (char)'r', (char)'i', (char)'e', (char)'s', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'a', (char)'m', (char)'p', (char)'d', (char)'u', (char)'_', (char)'r', (char)'e', (char)'t', (char)'r', (char)'i', (char)'e', (char)'s', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'a', (char)'m', (char)'p', (char)'d', (char)'u', (char)'_', (char)'r', (char)'e', (char)'t', (char)'r', (char)'i', (char)'e', (char)'s', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'a', (char)'m', (char)'p', (char)'d', (char)'u', (char)'_', (char)'x', (char)'r', (char)'e', (char)'t', (char)'r', (char)'i', (char)'e', (char)'s', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'a', (char)'m', (char)'p', (char)'d', (char)'u', (char)'_', (char)'x', (char)'r', (char)'e', (char)'t', (char)'r', (char)'i', (char)'e', (char)'s', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'a', (char)'m', (char)'p', (char)'d', (char)'u', (char)'_', (char)'x', (char)'r', (char)'e', (char)'t', (char)'r', (char)'i', (char)'e', (char)'s', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'a', (char)'m', (char)'p', (char)'d', (char)'u', (char)'_', (char)'x', (char)'r', (char)'e', (char)'t', (char)'r', (char)'i', (char)'e', (char)'s', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'f', (char)'i', (char)'f', (char)'o', (char)'_', (char)'u', (char)'n', (char)'d', (char)'e', (char)'r', (char)'r', (char)'u', (char)'n', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'f', (char)'i', (char)'f', (char)'o', (char)'_', (char)'u', (char)'n', (char)'d', (char)'e', (char)'r', (char)'r', (char)'u', (char)'n', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'f', (char)'i', (char)'f', (char)'o', (char)'_', (char)'u', (char)'n', (char)'d', (char)'e', (char)'r', (char)'r', (char)'u', (char)'n', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'f', (char)'i', (char)'f', (char)'o', (char)'_', (char)'u', (char)'n', (char)'d', (char)'e', (char)'r', (char)'r', (char)'u', (char)'n', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'o', (char)'p', (char)'_', (char)'e', (char)'x', (char)'c', (char)'e', (char)'e', (char)'d', (char)'e', (char)'d', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'o', (char)'p', (char)'_', (char)'e', (char)'x', (char)'c', (char)'e', (char)'e', (char)'d', (char)'e', (char)'d', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'o', (char)'p', (char)'_', (char)'e', (char)'x', (char)'c', (char)'e', (char)'e', (char)'d', (char)'e', (char)'d', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'o', (char)'p', (char)'_', (char)'e', (char)'x', (char)'c', (char)'e', (char)'e', (char)'d', (char)'e', (char)'d', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'t', (char)'i', (char)'m', (char)'e', (char)'r', (char)'_', (char)'e', (char)'x', (char)'p', (char)'i', (char)'r', (char)'y', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'t', (char)'i', (char)'m', (char)'e', (char)'r', (char)'_', (char)'e', (char)'x', (char)'p', (char)'i', (char)'r', (char)'y', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'t', (char)'i', (char)'m', (char)'e', (char)'r', (char)'_', (char)'e', (char)'x', (char)'p', (char)'i', (char)'r', (char)'y', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'t', (char)'i', (char)'m', (char)'e', (char)'r', (char)'_', (char)'e', (char)'x', (char)'p', (char)'i', (char)'r', (char)'y', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'d', (char)'e', (char)'s', (char)'c', (char)'_', (char)'c', (char)'f', (char)'g', (char)'_', (char)'e', (char)'r', (char)'r', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'d', (char)'e', (char)'s', (char)'c', (char)'_', (char)'c', (char)'f', (char)'g', (char)'_', (char)'e', (char)'r', (char)'r', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'d', (char)'e', (char)'s', (char)'c', (char)'_', (char)'c', (char)'f', (char)'g', (char)'_', (char)'e', (char)'r', (char)'r', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'d', (char)'e', (char)'s', (char)'c', (char)'_', (char)'c', (char)'f', (char)'g', (char)'_', (char)'e', (char)'r', (char)'r', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'d', (char)'a', (char)'t', (char)'a', (char)'_', (char)'u', (char)'n', (char)'d', (char)'e', (char)'r', (char)'r', (char)'u', (char)'n', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'d', (char)'a', (char)'t', (char)'a', (char)'_', (char)'u', (char)'n', (char)'d', (char)'e', (char)'r', (char)'r', (char)'u', (char)'n', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'d', (char)'a', (char)'t', (char)'a', (char)'_', (char)'u', (char)'n', (char)'d', (char)'e', (char)'r', (char)'r', (char)'u', (char)'n', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'d', (char)'a', (char)'t', (char)'a', (char)'_', (char)'u', (char)'n', (char)'d', (char)'e', (char)'r', (char)'r', (char)'u', (char)'n', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'d', (char)'e', (char)'l', (char)'i', (char)'m', (char)'_', (char)'u', (char)'n', (char)'d', (char)'e', (char)'r', (char)'r', (char)'u', (char)'n', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'d', (char)'e', (char)'l', (char)'i', (char)'m', (char)'_', (char)'u', (char)'n', (char)'d', (char)'e', (char)'r', (char)'r', (char)'u', (char)'n', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'d', (char)'e', (char)'l', (char)'i', (char)'m', (char)'_', (char)'u', (char)'n', (char)'d', (char)'e', (char)'r', (char)'r', (char)'u', (char)'n', (char)'\000'}, {(char)'d', (char)'_', (char)'t', (char)'x', (char)'_', (char)'d', (char)'e', (char)'l', (char)'i', (char)'m', (char)'_', (char)'u', (char)'n', (char)'d', (char)'e', (char)'r', (char)'r', (char)'u', (char)'n', (char)'\000'}, {(char)'d', (char)'_', (char)'r', (char)'x', (char)'_', (char)'c', (char)'r', (char)'c', (char)'_', (char)'e', (char)'r', (char)'r', (char)'\000'}, {(char)'d', (char)'_', (char)'r', (char)'x', (char)'_', (char)'d', (char)'e', (char)'c', (char)'r', (char)'y', (char)'p', (char)'t', (char)'_', (char)'c', (char)'r', (char)'c', (char)'_', (char)'e', (char)'r', (char)'r', (char)'\000'}, {(char)'d', (char)'_', (char)'r', (char)'x', (char)'_', (char)'p', (char)'h', (char)'y', (char)'_', (char)'e', (char)'r', (char)'r', (char)'\000'}, {(char)'d', (char)'_', (char)'r', (char)'x', (char)'_', (char)'m', (char)'i', (char)'c', (char)'_', (char)'e', (char)'r', (char)'r', (char)'\000'}, {(char)'d', (char)'_', (char)'r', (char)'x', (char)'_', (char)'p', (char)'r', (char)'e', (char)'_', (char)'d', (char)'e', (char)'l', (char)'i', (char)'m', (char)'_', (char)'c', (char)'r', (char)'c', (char)'_', (char)'e', (char)'r', (char)'r', (char)'\000'}, {(char)'d', (char)'_', (char)'r', (char)'x', (char)'_', (char)'p', (char)'o', (char)'s', (char)'t', (char)'_', (char)'d', (char)'e', (char)'l', (char)'i', (char)'m', (char)'_', (char)'c', (char)'r', (char)'c', (char)'_', (char)'e', (char)'r', (char)'r', (char)'\000'}, {(char)'d', (char)'_', (char)'r', (char)'x', (char)'_', (char)'d', (char)'e', (char)'c', (char)'r', (char)'y', (char)'p', (char)'t', (char)'_', (char)'b', (char)'u', (char)'s', (char)'y', (char)'_', (char)'e', (char)'r', (char)'r', (char)'\000'}, {(char)'d', (char)'_', (char)'r', (char)'x', (char)'_', (char)'p', (char)'h', (char)'y', (char)'e', (char)'r', (char)'r', (char)'_', (char)'r', (char)'a', (char)'d', (char)'a', (char)'r', (char)'\000'}, {(char)'d', (char)'_', (char)'r', (char)'x', (char)'_', (char)'p', (char)'h', (char)'y', (char)'e', (char)'r', (char)'r', (char)'_', (char)'o', (char)'f', (char)'d', (char)'m', (char)'_', (char)'t', (char)'i', (char)'m', (char)'i', (char)'n', (char)'g', (char)'\000'}, {(char)'d', (char)'_', (char)'r', (char)'x', (char)'_', (char)'p', (char)'h', (char)'y', (char)'e', (char)'r', (char)'r', (char)'_', (char)'c', (char)'c', (char)'k', (char)'_', (char)'t', (char)'i', (char)'m', (char)'i', (char)'n', (char)'g', (char)'\000'}};

#line 1216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
void ath9k_get_et_strings(struct ieee80211_hw *hw, struct ieee80211_vif *vif, u32 sset, u8 *data)
{
  
#line 1220 
  if (sset == 1U) 
#line 1221 
                  memcpy((void *)data,(void const *)(& ath9k_gstrings_stats),2624UL); else ;
  
#line 1222 
  return;
}


#line 1225  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
int ath9k_get_et_sset_count(struct ieee80211_hw *hw, struct ieee80211_vif *vif, int sset)
{
  int __retres;
  
#line 1228 
  if (sset == 1) {
    
#line 1229 
    __retres = 82;
    
#line 1229 
    goto return_label;
  }
  else ;
  
#line 1230 
  __retres = 0;
  return_label: 
#line 1230 
                return __retres;
}


#line 1246  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
void ath9k_get_et_stats(struct ieee80211_hw *hw, struct ieee80211_vif *vif, struct ethtool_stats *stats, u64 *data)
{
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  int tmp_4;
  int tmp_5;
  int tmp_6;
  int tmp_7;
  int tmp_8;
  int tmp_9;
  int tmp_10;
  int tmp_11;
  int tmp_12;
  int tmp_13;
  int tmp_14;
  int tmp_15;
  int tmp_16;
  int tmp_17;
  int tmp_18;
  int tmp_19;
  int tmp_20;
  int tmp_21;
  int tmp_22;
  int tmp_23;
  int tmp_24;
  int tmp_25;
  int tmp_26;
  int tmp_27;
  int tmp_28;
  int tmp_29;
  int tmp_30;
  int tmp_31;
  int tmp_32;
  int tmp_33;
  int tmp_34;
  int tmp_35;
  int tmp_36;
  int tmp_37;
  int tmp_38;
  int tmp_39;
  int tmp_40;
  int tmp_41;
  int tmp_42;
  int tmp_43;
  int tmp_44;
  int tmp_45;
  int tmp_46;
  int tmp_47;
  int tmp_48;
  int tmp_49;
  int tmp_50;
  int tmp_51;
  int tmp_52;
  int tmp_53;
  int tmp_54;
  int tmp_55;
  int tmp_56;
  int tmp_57;
  int tmp_58;
  int tmp_59;
  int tmp_60;
  int tmp_61;
  int tmp_62;
  int tmp_63;
  int tmp_64;
  int tmp_65;
  int tmp_66;
  int tmp_67;
  int tmp_68;
  int tmp_69;
  int tmp_70;
  int tmp_71;
  int tmp_72;
  int tmp_73;
  int tmp_74;
  int tmp_75;
  int tmp_76;
  int tmp_77;
  int tmp_78;
  int tmp_79;
  int tmp_80;
  
#line 1250 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 1251 
  int i = 0;
  
#line 1253 
  tmp = i;
  
#line 1253 
  i += 1;
  
#line 1253 
  *(data + tmp) = (unsigned long long)(((sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].tx_pkts_all + sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].tx_pkts_all) + sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].tx_pkts_all) + sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].tx_pkts_all);
  
#line 1257 
  tmp_0 = i;
  
#line 1257 
  i += 1;
  
#line 1257 
  *(data + tmp_0) = (unsigned long long)(((sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].tx_bytes_all + sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].tx_bytes_all) + sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].tx_bytes_all) + sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].tx_bytes_all);
  
#line 1261 
  tmp_1 = i;
  
#line 1261 
  i += 1;
  
#line 1261 
  *(data + tmp_1) = (unsigned long long)sc->debug.stats.rxstats.rx_pkts_all;
  
#line 1262 
  tmp_2 = i;
  
#line 1262 
  i += 1;
  
#line 1262 
  *(data + tmp_2) = (unsigned long long)sc->debug.stats.rxstats.rx_bytes_all;
  
#line 1264 
  tmp_3 = i;
  
#line 1264 
  i += 1;
  
#line 1264 
  *(data + tmp_3) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].tx_pkts_all;
  
#line 1264 
  tmp_4 = i;
  
#line 1264 
  i += 1;
  
#line 1264 
  *(data + tmp_4) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].tx_pkts_all;
  
#line 1264 
  tmp_5 = i;
  
#line 1264 
  i += 1;
  
#line 1264 
  *(data + tmp_5) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].tx_pkts_all;
  
#line 1264 
  tmp_6 = i;
  
#line 1264 
  i += 1;
  
#line 1264 
  *(data + tmp_6) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].tx_pkts_all;
  
#line 1265 
  tmp_7 = i;
  
#line 1265 
  i += 1;
  
#line 1265 
  *(data + tmp_7) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].tx_bytes_all;
  
#line 1265 
  tmp_8 = i;
  
#line 1265 
  i += 1;
  
#line 1265 
  *(data + tmp_8) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].tx_bytes_all;
  
#line 1265 
  tmp_9 = i;
  
#line 1265 
  i += 1;
  
#line 1265 
  *(data + tmp_9) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].tx_bytes_all;
  
#line 1265 
  tmp_10 = i;
  
#line 1265 
  i += 1;
  
#line 1265 
  *(data + tmp_10) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].tx_bytes_all;
  
#line 1266 
  tmp_11 = i;
  
#line 1266 
  i += 1;
  
#line 1266 
  *(data + tmp_11) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].queued;
  
#line 1266 
  tmp_12 = i;
  
#line 1266 
  i += 1;
  
#line 1266 
  *(data + tmp_12) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].queued;
  
#line 1266 
  tmp_13 = i;
  
#line 1266 
  i += 1;
  
#line 1266 
  *(data + tmp_13) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].queued;
  
#line 1266 
  tmp_14 = i;
  
#line 1266 
  i += 1;
  
#line 1266 
  *(data + tmp_14) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].queued;
  
#line 1267 
  tmp_15 = i;
  
#line 1267 
  i += 1;
  
#line 1267 
  *(data + tmp_15) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].completed;
  
#line 1267 
  tmp_16 = i;
  
#line 1267 
  i += 1;
  
#line 1267 
  *(data + tmp_16) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].completed;
  
#line 1267 
  tmp_17 = i;
  
#line 1267 
  i += 1;
  
#line 1267 
  *(data + tmp_17) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].completed;
  
#line 1267 
  tmp_18 = i;
  
#line 1267 
  i += 1;
  
#line 1267 
  *(data + tmp_18) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].completed;
  
#line 1268 
  tmp_19 = i;
  
#line 1268 
  i += 1;
  
#line 1268 
  *(data + tmp_19) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].xretries;
  
#line 1268 
  tmp_20 = i;
  
#line 1268 
  i += 1;
  
#line 1268 
  *(data + tmp_20) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].xretries;
  
#line 1268 
  tmp_21 = i;
  
#line 1268 
  i += 1;
  
#line 1268 
  *(data + tmp_21) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].xretries;
  
#line 1268 
  tmp_22 = i;
  
#line 1268 
  i += 1;
  
#line 1268 
  *(data + tmp_22) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].xretries;
  
#line 1269 
  tmp_23 = i;
  
#line 1269 
  i += 1;
  
#line 1269 
  *(data + tmp_23) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].a_aggr;
  
#line 1269 
  tmp_24 = i;
  
#line 1269 
  i += 1;
  
#line 1269 
  *(data + tmp_24) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].a_aggr;
  
#line 1269 
  tmp_25 = i;
  
#line 1269 
  i += 1;
  
#line 1269 
  *(data + tmp_25) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].a_aggr;
  
#line 1269 
  tmp_26 = i;
  
#line 1269 
  i += 1;
  
#line 1269 
  *(data + tmp_26) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].a_aggr;
  
#line 1270 
  tmp_27 = i;
  
#line 1270 
  i += 1;
  
#line 1270 
  *(data + tmp_27) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].a_queued_hw;
  
#line 1270 
  tmp_28 = i;
  
#line 1270 
  i += 1;
  
#line 1270 
  *(data + tmp_28) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].a_queued_hw;
  
#line 1270 
  tmp_29 = i;
  
#line 1270 
  i += 1;
  
#line 1270 
  *(data + tmp_29) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].a_queued_hw;
  
#line 1270 
  tmp_30 = i;
  
#line 1270 
  i += 1;
  
#line 1270 
  *(data + tmp_30) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].a_queued_hw;
  
#line 1271 
  tmp_31 = i;
  
#line 1271 
  i += 1;
  
#line 1271 
  *(data + tmp_31) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].a_queued_sw;
  
#line 1271 
  tmp_32 = i;
  
#line 1271 
  i += 1;
  
#line 1271 
  *(data + tmp_32) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].a_queued_sw;
  
#line 1271 
  tmp_33 = i;
  
#line 1271 
  i += 1;
  
#line 1271 
  *(data + tmp_33) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].a_queued_sw;
  
#line 1271 
  tmp_34 = i;
  
#line 1271 
  i += 1;
  
#line 1271 
  *(data + tmp_34) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].a_queued_sw;
  
#line 1272 
  tmp_35 = i;
  
#line 1272 
  i += 1;
  
#line 1272 
  *(data + tmp_35) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].a_completed;
  
#line 1272 
  tmp_36 = i;
  
#line 1272 
  i += 1;
  
#line 1272 
  *(data + tmp_36) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].a_completed;
  
#line 1272 
  tmp_37 = i;
  
#line 1272 
  i += 1;
  
#line 1272 
  *(data + tmp_37) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].a_completed;
  
#line 1272 
  tmp_38 = i;
  
#line 1272 
  i += 1;
  
#line 1272 
  *(data + tmp_38) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].a_completed;
  
#line 1273 
  tmp_39 = i;
  
#line 1273 
  i += 1;
  
#line 1273 
  *(data + tmp_39) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].a_retries;
  
#line 1273 
  tmp_40 = i;
  
#line 1273 
  i += 1;
  
#line 1273 
  *(data + tmp_40) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].a_retries;
  
#line 1273 
  tmp_41 = i;
  
#line 1273 
  i += 1;
  
#line 1273 
  *(data + tmp_41) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].a_retries;
  
#line 1273 
  tmp_42 = i;
  
#line 1273 
  i += 1;
  
#line 1273 
  *(data + tmp_42) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].a_retries;
  
#line 1274 
  tmp_43 = i;
  
#line 1274 
  i += 1;
  
#line 1274 
  *(data + tmp_43) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].a_xretries;
  
#line 1274 
  tmp_44 = i;
  
#line 1274 
  i += 1;
  
#line 1274 
  *(data + tmp_44) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].a_xretries;
  
#line 1274 
  tmp_45 = i;
  
#line 1274 
  i += 1;
  
#line 1274 
  *(data + tmp_45) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].a_xretries;
  
#line 1274 
  tmp_46 = i;
  
#line 1274 
  i += 1;
  
#line 1274 
  *(data + tmp_46) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].a_xretries;
  
#line 1275 
  tmp_47 = i;
  
#line 1275 
  i += 1;
  
#line 1275 
  *(data + tmp_47) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].fifo_underrun;
  
#line 1275 
  tmp_48 = i;
  
#line 1275 
  i += 1;
  
#line 1275 
  *(data + tmp_48) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].fifo_underrun;
  
#line 1275 
  tmp_49 = i;
  
#line 1275 
  i += 1;
  
#line 1275 
  *(data + tmp_49) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].fifo_underrun;
  
#line 1275 
  tmp_50 = i;
  
#line 1275 
  i += 1;
  
#line 1275 
  *(data + tmp_50) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].fifo_underrun;
  
#line 1276 
  tmp_51 = i;
  
#line 1276 
  i += 1;
  
#line 1276 
  *(data + tmp_51) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].xtxop;
  
#line 1276 
  tmp_52 = i;
  
#line 1276 
  i += 1;
  
#line 1276 
  *(data + tmp_52) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].xtxop;
  
#line 1276 
  tmp_53 = i;
  
#line 1276 
  i += 1;
  
#line 1276 
  *(data + tmp_53) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].xtxop;
  
#line 1276 
  tmp_54 = i;
  
#line 1276 
  i += 1;
  
#line 1276 
  *(data + tmp_54) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].xtxop;
  
#line 1277 
  tmp_55 = i;
  
#line 1277 
  i += 1;
  
#line 1277 
  *(data + tmp_55) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].timer_exp;
  
#line 1277 
  tmp_56 = i;
  
#line 1277 
  i += 1;
  
#line 1277 
  *(data + tmp_56) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].timer_exp;
  
#line 1277 
  tmp_57 = i;
  
#line 1277 
  i += 1;
  
#line 1277 
  *(data + tmp_57) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].timer_exp;
  
#line 1277 
  tmp_58 = i;
  
#line 1277 
  i += 1;
  
#line 1277 
  *(data + tmp_58) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].timer_exp;
  
#line 1278 
  tmp_59 = i;
  
#line 1278 
  i += 1;
  
#line 1278 
  *(data + tmp_59) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].desc_cfg_err;
  
#line 1278 
  tmp_60 = i;
  
#line 1278 
  i += 1;
  
#line 1278 
  *(data + tmp_60) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].desc_cfg_err;
  
#line 1278 
  tmp_61 = i;
  
#line 1278 
  i += 1;
  
#line 1278 
  *(data + tmp_61) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].desc_cfg_err;
  
#line 1278 
  tmp_62 = i;
  
#line 1278 
  i += 1;
  
#line 1278 
  *(data + tmp_62) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].desc_cfg_err;
  
#line 1279 
  tmp_63 = i;
  
#line 1279 
  i += 1;
  
#line 1279 
  *(data + tmp_63) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].data_underrun;
  
#line 1279 
  tmp_64 = i;
  
#line 1279 
  i += 1;
  
#line 1279 
  *(data + tmp_64) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].data_underrun;
  
#line 1279 
  tmp_65 = i;
  
#line 1279 
  i += 1;
  
#line 1279 
  *(data + tmp_65) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].data_underrun;
  
#line 1279 
  tmp_66 = i;
  
#line 1279 
  i += 1;
  
#line 1279 
  *(data + tmp_66) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].data_underrun;
  
#line 1280 
  tmp_67 = i;
  
#line 1280 
  i += 1;
  
#line 1280 
  *(data + tmp_67) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[2])->axq_qnum].delim_underrun;
  
#line 1280 
  tmp_68 = i;
  
#line 1280 
  i += 1;
  
#line 1280 
  *(data + tmp_68) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[3])->axq_qnum].delim_underrun;
  
#line 1280 
  tmp_69 = i;
  
#line 1280 
  i += 1;
  
#line 1280 
  *(data + tmp_69) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[1])->axq_qnum].delim_underrun;
  
#line 1280 
  tmp_70 = i;
  
#line 1280 
  i += 1;
  
#line 1280 
  *(data + tmp_70) = (unsigned long long)sc->debug.stats.txstats[(sc->tx.txq_map[0])->axq_qnum].delim_underrun;
  
#line 1282 
  tmp_71 = i;
  
#line 1282 
  i += 1;
  
#line 1282 
  *(data + tmp_71) = (unsigned long long)sc->debug.stats.rxstats.crc_err;
  
#line 1283 
  tmp_72 = i;
  
#line 1283 
  i += 1;
  
#line 1283 
  *(data + tmp_72) = (unsigned long long)sc->debug.stats.rxstats.decrypt_crc_err;
  
#line 1284 
  tmp_73 = i;
  
#line 1284 
  i += 1;
  
#line 1284 
  *(data + tmp_73) = (unsigned long long)sc->debug.stats.rxstats.phy_err;
  
#line 1285 
  tmp_74 = i;
  
#line 1285 
  i += 1;
  
#line 1285 
  *(data + tmp_74) = (unsigned long long)sc->debug.stats.rxstats.mic_err;
  
#line 1286 
  tmp_75 = i;
  
#line 1286 
  i += 1;
  
#line 1286 
  *(data + tmp_75) = (unsigned long long)sc->debug.stats.rxstats.pre_delim_crc_err;
  
#line 1287 
  tmp_76 = i;
  
#line 1287 
  i += 1;
  
#line 1287 
  *(data + tmp_76) = (unsigned long long)sc->debug.stats.rxstats.post_delim_crc_err;
  
#line 1288 
  tmp_77 = i;
  
#line 1288 
  i += 1;
  
#line 1288 
  *(data + tmp_77) = (unsigned long long)sc->debug.stats.rxstats.decrypt_busy_err;
  
#line 1290 
  tmp_78 = i;
  
#line 1290 
  i += 1;
  
#line 1290 
  *(data + tmp_78) = (unsigned long long)sc->debug.stats.rxstats.phy_err_stats[5];
  
#line 1291 
  tmp_79 = i;
  
#line 1291 
  i += 1;
  
#line 1291 
  *(data + tmp_79) = (unsigned long long)sc->debug.stats.rxstats.phy_err_stats[17];
  
#line 1292 
  tmp_80 = i;
  
#line 1292 
  i += 1;
  
#line 1292 
  *(data + tmp_80) = (unsigned long long)sc->debug.stats.rxstats.phy_err_stats[25];
  {
    
#line 1294 
    int __ret_warn_on = i != 82;
    
#line 1294 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 1294 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c",1294); else ;
    
#line 1294 
    long tmp_81 = (long)(__ret_warn_on != 0);
  }
  
#line 1296 
  return;
}


#line 1297  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
void ath9k_deinit_debug(struct ath_softc *sc)
{
  
#line 1299 
  ath9k_cmn_spectral_deinit_debug(& sc->spec_priv);
  
#line 1300 
  return;
}


#line 1302  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.c"
int ath9k_init_debug(struct ath_hw *ah)
{
  int __retres;
  
#line 1304 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 1305 
  struct ath_softc *sc = (struct ath_softc *)common->priv;
  
#line 1307 
  sc->debug.debugfs_phy = debugfs_create_dir("ath9k",((sc->hw)->wiphy)->debugfsdir);
  
#line 1309 
  if (sc->debug.debugfs_phy == (struct dentry *)0) {
    
#line 1310 
    __retres = -12;
    
#line 1310 
    goto return_label;
  }
  else ;
  
#line 1313 
  ldv_debugfs_create_file_74("debug",(unsigned short)384,sc->debug.debugfs_phy,(void *)sc,& fops_debug);
  
#line 1317 
  ath9k_dfs_init_debug(sc);
  
#line 1318 
  ath9k_tx99_init_debug(sc);
  
#line 1319 
  ath9k_cmn_spectral_init_debug(& sc->spec_priv,sc->debug.debugfs_phy);
  
#line 1321 
  debugfs_create_devm_seqfile(sc->dev,"dma",sc->debug.debugfs_phy,& read_file_dma);
  
#line 1323 
  debugfs_create_devm_seqfile(sc->dev,"interrupt",sc->debug.debugfs_phy,& read_file_interrupt);
  
#line 1325 
  debugfs_create_devm_seqfile(sc->dev,"xmit",sc->debug.debugfs_phy,& read_file_xmit);
  
#line 1327 
  debugfs_create_devm_seqfile(sc->dev,"queues",sc->debug.debugfs_phy,& read_file_queues);
  
#line 1329 
  debugfs_create_u32("qlen_bk",(unsigned short)384,sc->debug.debugfs_phy,& sc->tx.txq_max_pending[3]);
  
#line 1331 
  debugfs_create_u32("qlen_be",(unsigned short)384,sc->debug.debugfs_phy,& sc->tx.txq_max_pending[2]);
  
#line 1333 
  debugfs_create_u32("qlen_vi",(unsigned short)384,sc->debug.debugfs_phy,& sc->tx.txq_max_pending[1]);
  
#line 1335 
  debugfs_create_u32("qlen_vo",(unsigned short)384,sc->debug.debugfs_phy,& sc->tx.txq_max_pending[0]);
  
#line 1337 
  debugfs_create_devm_seqfile(sc->dev,"misc",sc->debug.debugfs_phy,& read_file_misc);
  
#line 1339 
  debugfs_create_devm_seqfile(sc->dev,"reset",sc->debug.debugfs_phy,& read_file_reset);
  
#line 1342 
  ath9k_cmn_debug_recv(sc->debug.debugfs_phy,& sc->debug.stats.rxstats);
  
#line 1343 
  ath9k_cmn_debug_phy_err(sc->debug.debugfs_phy,& sc->debug.stats.rxstats);
  
#line 1345 
  debugfs_create_u8("rx_chainmask",(unsigned short)256,sc->debug.debugfs_phy,& ah->rxchainmask);
  
#line 1347 
  debugfs_create_u8("tx_chainmask",(unsigned short)256,sc->debug.debugfs_phy,& ah->txchainmask);
  
#line 1349 
  ldv_debugfs_create_file_75("ani",(unsigned short)384,sc->debug.debugfs_phy,(void *)sc,& fops_ani);
  
#line 1351 
  debugfs_create_bool("paprd",(unsigned short)384,sc->debug.debugfs_phy,& (sc->sc_ah)->config.enable_paprd);
  
#line 1353 
  ldv_debugfs_create_file_76("regidx",(unsigned short)384,sc->debug.debugfs_phy,(void *)sc,& fops_regidx);
  
#line 1355 
  ldv_debugfs_create_file_77("regval",(unsigned short)384,sc->debug.debugfs_phy,(void *)sc,& fops_regval);
  
#line 1357 
  debugfs_create_bool("ignore_extcca",(unsigned short)384,sc->debug.debugfs_phy,& ah->config.cwm_ignore_extcca);
  
#line 1360 
  ldv_debugfs_create_file_78("regdump",(unsigned short)256,sc->debug.debugfs_phy,(void *)sc,& fops_regdump);
  
#line 1362 
  debugfs_create_devm_seqfile(sc->dev,"dump_nfcal",sc->debug.debugfs_phy,& read_file_dump_nfcal);
  
#line 1366 
  ath9k_cmn_debug_base_eeprom(sc->debug.debugfs_phy,sc->sc_ah);
  
#line 1367 
  ath9k_cmn_debug_modal_eeprom(sc->debug.debugfs_phy,sc->sc_ah);
  
#line 1369 
  debugfs_create_u32("gpio_mask",(unsigned short)384,sc->debug.debugfs_phy,& (sc->sc_ah)->gpio_mask);
  
#line 1371 
  debugfs_create_u32("gpio_val",(unsigned short)384,sc->debug.debugfs_phy,& (sc->sc_ah)->gpio_val);
  
#line 1373 
  ldv_debugfs_create_file_79("antenna_diversity",(unsigned short)256,sc->debug.debugfs_phy,(void *)sc,& fops_antenna_diversity);
  
#line 1376 
  ldv_debugfs_create_file_80("bt_ant_diversity",(unsigned short)384,sc->debug.debugfs_phy,(void *)sc,& fops_bt_ant_diversity);
  
#line 1378 
  ldv_debugfs_create_file_81("btcoex",(unsigned short)256,sc->debug.debugfs_phy,(void *)sc,& fops_btcoex);
  
#line 1383 
  ldv_debugfs_create_file_82("wow",(unsigned short)384,sc->debug.debugfs_phy,(void *)sc,& fops_wow);
  
#line 1388 
  ldv_debugfs_create_file_83("ack_to",(unsigned short)384,sc->debug.debugfs_phy,(void *)sc,& fops_ackto);
  
#line 1391 
  ldv_debugfs_create_file_84("tpc",(unsigned short)384,sc->debug.debugfs_phy,(void *)sc,& fops_tpc);
  
#line 1394 
  __retres = 0;
  return_label: 
#line 1394 
                return __retres;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
struct file_operations *ldv_emg_alias_fops_wow_2 = (struct file_operations *)(& fops_wow);

#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
struct file_operations *ldv_emg_alias_fops_btcoex_2 = (struct file_operations *)(& fops_btcoex);

#line 58  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
struct file_operations *ldv_emg_alias_fops_dump_nfcal_2 = (struct file_operations *)(& fops_dump_nfcal);

#line 59  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
struct file_operations *ldv_emg_alias_fops_ackto_2 = (struct file_operations *)(& fops_ackto);

#line 60  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
long (*ldv_emg_alias_seq_read_4)(struct file *, char *, unsigned long , long long *) = & seq_read;

#line 61  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
struct file_operations *ldv_emg_alias_fops_regidx_2 = (struct file_operations *)(& fops_regidx);

#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
struct file_operations *ldv_emg_alias_fops_regdump_2 = (struct file_operations *)(& fops_regdump);

#line 63  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
long long (*ldv_emg_alias_seq_lseek_3)(struct file *, long long , int ) = & seq_lseek;

#line 64  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
struct file_operations *ldv_emg_alias_fops_tpc_2 = (struct file_operations *)(& fops_tpc);

#line 65  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
struct file_operations *ldv_emg_alias_fops_bt_ant_diversity_2 = (struct file_operations *)(& fops_bt_ant_diversity);

#line 66  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
struct file_operations *ldv_emg_alias_fops_antenna_diversity_2 = (struct file_operations *)(& fops_antenna_diversity);

#line 67  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
struct file_operations *ldv_emg_alias_fops_regval_2 = (struct file_operations *)(& fops_regval);

#line 68  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
int (*ldv_emg_alias_single_release_5)(struct inode *, struct file *) = & single_release;

#line 69  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
struct file_operations *ldv_emg_alias_fops_ani_2 = (struct file_operations *)(& fops_ani);

#line 70  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
struct file_operations *ldv_emg_alias_fops_debug_2 = (struct file_operations *)(& fops_debug);

#line 85  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
long ldv_emg_wrapper_write_file_ani_4(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 86 
  tmp = write_file_ani(arg0,(char const *)arg1,arg2,arg3);
  
#line 86 
  return tmp;
}


#line 90  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
long ldv_emg_wrapper_read_file_regidx_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 91 
  tmp = read_file_regidx(arg0,arg1,arg2,arg3);
  
#line 91 
  return tmp;
}


#line 95  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
long ldv_emg_wrapper_write_file_wow_4(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 96 
  tmp = write_file_wow(arg0,(char const *)arg1,arg2,arg3);
  
#line 96 
  return tmp;
}


#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
long ldv_emg_wrapper_read_file_bt_ant_diversity_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 101 
  tmp = read_file_bt_ant_diversity(arg0,arg1,arg2,arg3);
  
#line 101 
  return tmp;
}


#line 105  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
long ldv_emg_wrapper_write_file_tpc_4(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 106 
  tmp = write_file_tpc(arg0,(char const *)arg1,arg2,arg3);
  
#line 106 
  return tmp;
}


#line 110  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
int ldv_emg_wrapper_open_file_regdump_5(struct inode *arg0, struct file *arg1)
{
  int tmp;
  
#line 111 
  tmp = open_file_regdump(arg0,arg1);
  
#line 111 
  return tmp;
}


#line 115  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
int ldv_emg_wrapper_open_file_dump_nfcal_6(struct inode *arg0, struct file *arg1)
{
  int tmp;
  
#line 116 
  tmp = open_file_dump_nfcal(arg0,arg1);
  
#line 116 
  return tmp;
}


#line 120  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
long ldv_emg_wrapper_write_file_regval_4(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 121 
  tmp = write_file_regval(arg0,(char const *)arg1,arg2,arg3);
  
#line 121 
  return tmp;
}


#line 125  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
long ldv_emg_wrapper_read_file_regval_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 126 
  tmp = read_file_regval(arg0,arg1,arg2,arg3);
  
#line 126 
  return tmp;
}


#line 130  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
long ldv_emg_wrapper_read_file_ani_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 131 
  tmp = read_file_ani(arg0,arg1,arg2,arg3);
  
#line 131 
  return tmp;
}


#line 135  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
long ldv_emg_wrapper_read_file_wow_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 136 
  tmp = read_file_wow(arg0,arg1,arg2,arg3);
  
#line 136 
  return tmp;
}


#line 140  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
long ldv_emg_wrapper_read_file_debug_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 141 
  tmp = read_file_debug(arg0,arg1,arg2,arg3);
  
#line 141 
  return tmp;
}


#line 145  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
long ldv_emg_wrapper_read_file_tpc_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 146 
  tmp = read_file_tpc(arg0,arg1,arg2,arg3);
  
#line 146 
  return tmp;
}


#line 150  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
long ldv_emg_wrapper_read_file_antenna_diversity_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 151 
  tmp = read_file_antenna_diversity(arg0,arg1,arg2,arg3);
  
#line 151 
  return tmp;
}


#line 155  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
long ldv_emg_wrapper_write_file_debug_4(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 156 
  tmp = write_file_debug(arg0,(char const *)arg1,arg2,arg3);
  
#line 156 
  return tmp;
}


#line 160  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
long ldv_emg_wrapper_write_file_bt_ant_diversity_4(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 161 
  tmp = write_file_bt_ant_diversity(arg0,(char const *)arg1,arg2,arg3);
  
#line 161 
  return tmp;
}


#line 165  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
long ldv_emg_wrapper_read_file_btcoex_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 166 
  tmp = read_file_btcoex(arg0,arg1,arg2,arg3);
  
#line 166 
  return tmp;
}


#line 170  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
int ldv_emg_wrapper_ath9k_debugfs_release_buf_4(struct inode *arg0, struct file *arg1)
{
  int tmp;
  
#line 171 
  tmp = ath9k_debugfs_release_buf(arg0,arg1);
  
#line 171 
  return tmp;
}


#line 175  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
long ldv_emg_wrapper_write_file_regidx_4(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 176 
  tmp = write_file_regidx(arg0,(char const *)arg1,arg2,arg3);
  
#line 176 
  return tmp;
}


#line 180  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
long ldv_emg_wrapper_read_file_ackto_4(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 181 
  tmp = read_file_ackto(arg0,arg1,arg2,arg3);
  
#line 181 
  return tmp;
}


#line 185  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
long ldv_emg_wrapper_ath9k_debugfs_read_buf_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 186 
  tmp = ath9k_debugfs_read_buf(arg0,arg1,arg2,arg3);
  
#line 186 
  return tmp;
}


#line 544  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
static void *kzalloc_0(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 547 
  tmp = ldv_kzalloc(size,flags);
  
#line 547 
  return tmp;
}


#line 861  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
static void ldv_mutex_lock_72_0(struct mutex *ldv_func_arg1)
{
  
#line 865 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 866 
  return;
}


#line 869  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
static void ldv_mutex_unlock_73(struct mutex *ldv_func_arg1)
{
  
#line 873 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 874 
  return;
}


#line 877  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
static struct dentry *ldv_debugfs_create_file_74(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 881 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 881 
  return tmp;
}


#line 885  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
static struct dentry *ldv_debugfs_create_file_75(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 889 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 889 
  return tmp;
}


#line 893  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
static struct dentry *ldv_debugfs_create_file_76(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 897 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 897 
  return tmp;
}


#line 901  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
static struct dentry *ldv_debugfs_create_file_77(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 905 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 905 
  return tmp;
}


#line 909  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
static struct dentry *ldv_debugfs_create_file_78(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 913 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 913 
  return tmp;
}


#line 917  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
static struct dentry *ldv_debugfs_create_file_79(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 921 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 921 
  return tmp;
}


#line 925  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
static struct dentry *ldv_debugfs_create_file_80(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 929 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 929 
  return tmp;
}


#line 933  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
static struct dentry *ldv_debugfs_create_file_81(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 937 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 937 
  return tmp;
}


#line 941  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
static struct dentry *ldv_debugfs_create_file_82(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 945 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 945 
  return tmp;
}


#line 949  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
static struct dentry *ldv_debugfs_create_file_83(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 953 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 953 
  return tmp;
}


#line 957  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug.c.aux"
static struct dentry *ldv_debugfs_create_file_84(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 961 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 961 
  return tmp;
}


#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/dfs.c"
static u32 dur_to_usecs(struct ath_hw *ah, u32 dur)
{
  u32 __retres;
  u32 nsecs;
  
#line 36 
  u32 const AR93X_NSECS_PER_DUR = 800U;
  
#line 37 
  u32 const AR93X_NSECS_PER_DUR_FAST = 727U;
  
#line 40 
  if (((unsigned long)(ah->curchan)->channelFlags & 1UL) != 0UL && (ah->caps.hw_caps & 128U) != 0U) 
    
#line 41 
    nsecs = dur * 727U; else 
#line 43 
                             nsecs = dur * 800U;
  
#line 45 
  __retres = (nsecs + 500U) / 1000U;
  
#line 45 
  return __retres;
}


#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/dfs.c"
static bool ath9k_postprocess_radar_event(struct ath_softc *sc, struct ath_radar_data *ard, struct pulse_event *pe)
{
  bool __retres;
  u8 rssi;
  u16 dur;
  u32 tmp;
  
#line 62 
  ard->pulse_bw_info = (unsigned char)((unsigned int)ard->pulse_bw_info & 3U);
  
#line 64 
  switch ((int)ard->pulse_bw_info) {
    case 1: 
#line 65 
    ;
    
#line 67 
    dur = (unsigned short)ard->pulse_length_pri;
    
#line 68 
    sc->debug.stats.dfs_stats.pri_phy_errors += 1U;
    
#line 73 
    if ((int)ard->ext_rssi < (int)ard->rssi + 3) 
#line 73 
                                                 rssi = ard->rssi; else 
                                                                    
#line 73 
                                                                    rssi = (unsigned char)0U;
    
#line 74 
    goto ldv_53357;
    case 2: 
#line 75 
    ;
    
#line 77 
    dur = (unsigned short)ard->pulse_length_ext;
    
#line 78 
    sc->debug.stats.dfs_stats.ext_phy_errors += 1U;
    
#line 83 
    if ((int)ard->rssi < (int)ard->ext_rssi + 12) 
#line 83 
                                                  rssi = ard->ext_rssi; else 
                                                                    
#line 83 
                                                                    rssi = (unsigned char)0U;
    
#line 84 
    goto ldv_53357;
    case 3: 
#line 85 
    ;
    
#line 93 
    if ((int)ard->pulse_length_ext >= (int)ard->pulse_length_pri) 
#line 94 
                                                                  dur = (unsigned short)ard->pulse_length_ext; else 
                                                                    
#line 96 
                                                                    dur = (unsigned short)ard->pulse_length_pri;
    
#line 97 
    sc->debug.stats.dfs_stats.dc_phy_errors += 1U;
    
#line 100 
    if ((int)ard->ext_rssi > (int)ard->rssi) 
#line 100 
                                             rssi = ard->ext_rssi; else 
                                                                    
#line 100 
                                                                    rssi = ard->rssi;
    
#line 101 
    goto ldv_53357;
    default: 
#line 102 
    ;
    
#line 107 
    sc->debug.stats.dfs_stats.bwinfo_discards += 1U;
    
#line 108 
    __retres = (_Bool)0;
    
#line 108 
    goto return_label;
  }
  ldv_53357: 
#line 111 
  ;
  
#line 111 
  if ((unsigned int)rssi == 0U) {
    
#line 112 
    sc->debug.stats.dfs_stats.rssi_discards += 1U;
    
#line 113 
    __retres = (_Bool)0;
    
#line 113 
    goto return_label;
  }
  else ;
  
#line 123 
  tmp = dur_to_usecs(sc->sc_ah,(unsigned int)dur);
  
#line 123 
  pe->width = (unsigned char)tmp;
  
#line 124 
  pe->rssi = rssi;
  
#line 126 
  sc->debug.stats.dfs_stats.pulses_detected += 1U;
  
#line 127 
  __retres = (_Bool)1;
  return_label: 
#line 127 
                return __retres;
}


#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/dfs.c"
static void ath9k_dfs_process_radar_pulse(struct ath_softc *sc, struct pulse_event *pe)
{
  int tmp_0;
  bool tmp;
  
#line 133 
  struct dfs_pattern_detector *pd = sc->dfs_detector;
  
#line 134 
  sc->debug.stats.dfs_stats.pulses_processed += 1U;
  
#line 135 
  if (pd == (struct dfs_pattern_detector *)0) 
#line 136 
                                              goto return_label; else ;
  
#line 137 
  tmp = (*(pd->add_pulse))(pd,pe);
  
#line 137 
  if (tmp) 
#line 137 
           tmp_0 = 0; else 
#line 137 
                           tmp_0 = 1;
  
#line 137 
  if (tmp_0) 
#line 138 
             goto return_label; else ;
  
#line 139 
  sc->debug.stats.dfs_stats.radar_detected += 1U;
  
#line 140 
  ieee80211_radar_detected(sc->hw);
  return_label: 
#line 141 
                return;
}


#line 146  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/dfs.c"
void ath9k_dfs_process_phyerr(struct ath_softc *sc, void *data, struct ath_rx_status *rs, u64 mactime)
{
  struct ath_radar_data ard;
  u16 datalen;
  char *vdata_end;
  struct pulse_event pe;
  int tmp_1;
  bool tmp_0;
  
#line 153 
  struct ath_hw *ah = sc->sc_ah;
  
#line 154 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 156 
  sc->debug.stats.dfs_stats.pulses_total += 1U;
  
#line 157 
  if ((unsigned int)rs->rs_phyerr != 5U && (unsigned int)rs->rs_phyerr != 24U) {
    
#line 159 
    if ((common->debug_mask & 65536) != 0) 
#line 159 
                                           ath_printk("\001",(struct ath_common const *)common,"Error: rs_phyer=0x%x not a radar error\n",(int)rs->rs_phyerr); else ;
    
#line 162 
    sc->debug.stats.dfs_stats.pulses_no_dfs += 1U;
    
#line 163 
    goto return_label;
  }
  else ;
  
#line 166 
  datalen = rs->rs_datalen;
  
#line 167 
  if ((unsigned int)datalen == 0U) {
    
#line 168 
    sc->debug.stats.dfs_stats.datalen_discards += 1U;
    
#line 169 
    goto return_label;
  }
  else ;
  
#line 172 
  ard.rssi = (unsigned char)rs->rs_rssi_ctl[0];
  
#line 173 
  ard.ext_rssi = (unsigned char)rs->rs_rssi_ext[0];
  
#line 179 
  if ((int)ard.rssi < 0) 
#line 180 
                         ard.rssi = (unsigned char)0U; else ;
  
#line 181 
  if ((int)ard.ext_rssi < 0) 
#line 182 
                             ard.ext_rssi = (unsigned char)0U; else ;
  
#line 184 
  vdata_end = (char *)data + (int)datalen;
  
#line 185 
  ard.pulse_bw_info = (unsigned char)*(vdata_end + 18446744073709551615U);
  
#line 186 
  ard.pulse_length_ext = (unsigned char)*(vdata_end + 18446744073709551614U);
  
#line 187 
  ard.pulse_length_pri = (unsigned char)*(vdata_end + 18446744073709551613U);
  
#line 188 
  pe.freq = (ah->curchan)->channel;
  
#line 189 
  pe.ts = mactime;
  
#line 190 
  tmp_0 = ath9k_postprocess_radar_event(sc,& ard,& pe);
  
#line 190 
  if (tmp_0) 
#line 190 
             tmp_1 = 0; else 
#line 190 
                             tmp_1 = 1;
  
#line 190 
  if (tmp_1) 
#line 191 
             goto return_label; else ;
  
#line 193 
  if ((common->debug_mask & 65536) != 0) 
#line 193 
                                         ath_printk("\001",(struct ath_common const *)common,"ath9k_dfs_process_phyerr: type=%d, freq=%d, ts=%llu, ",(int)ard.pulse_bw_info,(int)pe.freq,pe.ts,(int)pe.width,(int)pe.rssi,pe.ts - sc->dfs_prev_pulse_ts); else ;
  
#line 198 
  sc->dfs_prev_pulse_ts = pe.ts;
  
#line 199 
  if (((int)ard.pulse_bw_info & 1) != 0) 
#line 200 
                                         ath9k_dfs_process_radar_pulse(sc,& pe); else ;
  
#line 201 
  if (((int)ard.pulse_bw_info & 2) != 0) {
    unsigned int tmp_2;
    
#line 202 
    if (((unsigned long)(ah->curchan)->channelFlags & 16UL) != 0UL) 
#line 202 
                                                                    tmp_2 = 20U; else 
                                                                    
#line 202 
                                                                    tmp_2 = 65516U;
    
#line 202 
    pe.freq = (unsigned short)((unsigned int)pe.freq + tmp_2);
    
#line 203 
    ath9k_dfs_process_radar_pulse(sc,& pe);
  }
  else ;
  return_label: 
#line 205 
                return;
}


#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_api_smp.h"
void _raw_spin_lock(raw_spinlock_t *);


#line 41 
void _raw_spin_unlock(raw_spinlock_t *);


#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock(spinlock_t *lock)
{
  
#line 312 
  _raw_spin_lock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 313 
  return;
}


#line 358 
static void ldv_spin_lock_76(spinlock_t *lock);


#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock(spinlock_t *lock)
{
  
#line 365 
  _raw_spin_unlock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 366 
  return;
}


#line 407 
static void ldv_spin_unlock_77(spinlock_t *lock);


#line 446  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_irqrestore_3(spinlock_t *lock, unsigned long flags)
{
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
  }
  
#line 448 
  _raw_spin_unlock_irqrestore(& lock->__anonCompField_spinlock_18.rlock,flags);
  
#line 449 
  return;
}


#line 478 
static void ldv_spin_unlock_irqrestore_73_0(spinlock_t *lock, unsigned long flags);


#line 482 
static void ldv_spin_unlock_irqrestore_75_1(spinlock_t *lock, unsigned long flags);


#line 70  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_link.c.aux"
static void ldv___ldv_spin_lock_72_0(spinlock_t *ldv_func_arg1);


#line 74 
static void ldv___ldv_spin_lock_74_1(spinlock_t *ldv_func_arg1);


#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/completion.h"
unsigned long wait_for_completion_timeout(struct completion *, unsigned long);


#line 284  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
unsigned int jiffies_to_msecs(unsigned long const);


#line 173  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
static int ldv_mod_timer_78(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2);


#line 177 
static int ldv_mod_timer_79(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2);


#line 232 
static int ldv_del_timer_sync_80_0(struct timer_list *ldv_func_arg1);


#line 772  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
void kfree_skb(struct sk_buff *);


#line 783 
struct sk_buff *__alloc_skb(unsigned int, gfp_t, int, int);


#line 787  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct sk_buff *alloc_skb(unsigned int size, gfp_t priority)
{
  struct sk_buff *tmp;
  
#line 790 
  tmp = __alloc_skb(size,priority,0,-1);
  
#line 790 
  return tmp;
}


#line 4666  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
void ieee80211_queue_work(struct ieee80211_hw *, struct work_struct *);


#line 4678 
void ieee80211_queue_delayed_work(struct ieee80211_hw *, struct delayed_work *, unsigned long);


#line 208  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath.h"
void ath_hw_cycle_counters_update(struct ath_common *);


#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/calib.h"
bool ath9k_hw_reset_calvalid(struct ath_hw *);


#line 119 
s16 ath9k_hw_getchan_noise(struct ath_hw *, struct ath9k_channel *, s16);


#line 1059  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
u32 ar9003_get_pll_sqsum_dvc(struct ath_hw *);


#line 1065 
bool ath9k_hw_check_alive(struct ath_hw *);


#line 1109 
void ar9003_paprd_enable(struct ath_hw *, bool);


#line 1110 
void ar9003_paprd_populate_single_table(struct ath_hw *, struct ath9k_hw_cal_data *, int);


#line 1113 
int ar9003_paprd_create_curve(struct ath_hw *, struct ath9k_hw_cal_data *, int);


#line 1115 
void ar9003_paprd_setup_gain_table(struct ath_hw *, int);


#line 1116 
int ar9003_paprd_init_table(struct ath_hw *);


#line 1117 
bool ar9003_paprd_is_done(struct ath_hw *);


#line 1118 
bool ar9003_is_paprd_enabled(struct ath_hw *);


#line 1141 
void ath9k_hw_ani_monitor(struct ath_hw *, struct ath9k_channel *);


#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw-ops.h"
__inline static int ath9k_hw_calibrate(struct ath_hw *ah, struct ath9k_channel *chan, u8 rxchainmask, bool longcal)
{
  int tmp_0;
  struct ath_hw_ops *tmp;
  
#line 48 
  tmp = ath9k_hw_ops(ah);
  
#line 48 
  tmp_0 = (*(tmp->calibrate))(ah,chan,(unsigned char)((int)rxchainmask),(_Bool)((bool)((int)longcal) != 0));
  
#line 48 
  return tmp_0;
}


#line 717  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
void ath_start_ani(struct ath_softc *sc);


#line 720 
int ath_update_survey_stats(struct ath_softc *sc);


#line 721 
void ath_update_survey_nf(struct ath_softc *sc, int channel);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/link.c"
void ath_tx_complete_poll_work(struct work_struct *work)
{
  struct ath_softc *tmp;
  struct ath_txq *txq;
  int i;
  unsigned long tmp_4;
  {
    
#line 25 
    struct work_struct const *__mptr = (struct work_struct const *)work;
    
#line 25 
    tmp = (struct ath_softc *)__mptr + 18446744073709537328U;
  }
  
#line 25 
  struct ath_softc *sc = tmp;
  
#line 29 
  bool needreset = (_Bool)0;
  
#line 32 
  if ((int)sc->tx99_state != 0) {
    struct ath_common *tmp_1;
    
#line 33 
    tmp_1 = ath9k_hw_common(sc->sc_ah);
    
#line 33 
    ;
    
#line 33 
    if ((tmp_1->debug_mask & 1) != 0) {
      struct ath_common *tmp_0;
      
#line 33 
      tmp_0 = ath9k_hw_common(sc->sc_ah);
      
#line 33 
      ath_printk("\001",(struct ath_common const *)tmp_0,"skip tx hung detection on tx99\n");
    }
    else ;
    
#line 35 
    goto return_label;
  }
  else ;
  
#line 38 
  i = 0;
  
#line 38 
  goto ldv_53397;
  ldv_53396: 
#line 39 
  ;
  
#line 39 
  txq = sc->tx.txq_map[i];
  
#line 41 
  ath_txq_lock(sc,txq);
  
#line 42 
  if (txq->axq_depth != 0U) 
    
#line 43 
    if ((int)txq->axq_tx_inprogress != 0) {
      
#line 44 
      needreset = (_Bool)1;
      
#line 45 
      ath_txq_unlock(sc,txq);
      
#line 46 
      goto ldv_53395;
    }
    else 
#line 48 
         txq->axq_tx_inprogress = (_Bool)1;
  else ;
  
#line 51 
  ath_txq_unlock(sc,txq);
  
#line 38 
  i += 1;
  ldv_53397: 
#line 39 
  ;
  
#line 38 
  if (i <= 3) 
#line 40 
              goto ldv_53396; else 
#line 43 
                                   goto ldv_53395;
  ldv_53395: 
#line 44 
  ;
  
#line 54 
  if ((int)needreset != 0) {
    struct ath_common *tmp_3;
    
#line 55 
    tmp_3 = ath9k_hw_common(sc->sc_ah);
    
#line 55 
    ;
    
#line 55 
    if ((tmp_3->debug_mask & 1) != 0) {
      struct ath_common *tmp_2;
      
#line 55 
      tmp_2 = ath9k_hw_common(sc->sc_ah);
      
#line 55 
      ath_printk("\001",(struct ath_common const *)tmp_2,"tx hung, resetting the chip\n");
    }
    else ;
    
#line 57 
    ath9k_queue_reset(sc,(enum ath_reset_type)RESET_TYPE_TX_HANG);
    
#line 58 
    goto return_label;
  }
  else ;
  
#line 61 
  tmp_4 = msecs_to_jiffies(1000U);
  
#line 61 
  ;
  
#line 61 
  ;
  
#line 61 
  ieee80211_queue_delayed_work(sc->hw,& sc->tx_complete_work,tmp_4);
  return_label: 
#line 63 
                return;
}


#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/link.c"
bool ath_hw_check(struct ath_softc *sc)
{
  enum ath_reset_type type;
  bool is_alive;
  
#line 70 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 74 
  ath9k_ps_wakeup(sc);
  
#line 76 
  is_alive = ath9k_hw_check_alive(sc->sc_ah);
  
#line 78 
  if (! is_alive) {
    
#line 79 
    if ((common->debug_mask & 1) != 0) 
#line 79 
                                       ath_printk("\001",(struct ath_common const *)common,"HW hang detected, schedule chip reset\n"); else ;
    
#line 81 
    type = RESET_TYPE_MAC_HANG;
    
#line 82 
    ath9k_queue_reset(sc,type);
  }
  else ;
  
#line 85 
  ath9k_ps_restore(sc);
  
#line 87 
  return is_alive;
}


#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/link.c"
static bool ath_hw_pll_rx_hang_check(struct ath_softc *sc, u32 pll_sqsum)
{
  bool __retres;
  int count;
  
#line 96 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 98 
  if (pll_sqsum > 262143U) {
    
#line 99 
    count += 1;
    
#line 100 
    if (count == 3) {
      
#line 101 
      if ((common->debug_mask & 1) != 0) 
#line 101 
                                         ath_printk("\001",(struct ath_common const *)common,"PLL WAR, resetting the chip\n"); else ;
      
#line 102 
      ath9k_queue_reset(sc,(enum ath_reset_type)RESET_TYPE_PLL_HANG);
      
#line 103 
      count = 0;
      
#line 104 
      __retres = (_Bool)1;
      
#line 104 
      goto return_label;
    }
    else ;
  }
  else 
#line 107 
       count = 0;
  
#line 110 
  __retres = (_Bool)0;
  return_label: 
#line 110 
                return __retres;
}


#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/link.c"
void ath_hw_pll_work(struct work_struct *work)
{
  u32 pll_sqsum;
  struct ath_softc *tmp;
  int tmp_1;
  bool tmp_2;
  unsigned long tmp_3;
  {
    
#line 116 
    struct work_struct const *__mptr = (struct work_struct const *)work;
    
#line 116 
    tmp = (struct ath_softc *)__mptr + 18446744073709537104U;
  }
  
#line 116 
  struct ath_softc *sc = tmp;
  
#line 118 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 125 
  tmp_1 = constant_test_bit(1L,(unsigned long const volatile *)(& common->op_flags));
  
#line 125 
  if (tmp_1 == 0) 
#line 126 
                  goto return_label; else ;
  
#line 128 
  if ((int)sc->tx99_state != 0) 
#line 129 
                                goto return_label; else ;
  
#line 131 
  ath9k_ps_wakeup(sc);
  
#line 132 
  pll_sqsum = ar9003_get_pll_sqsum_dvc(sc->sc_ah);
  
#line 133 
  ath9k_ps_restore(sc);
  
#line 134 
  tmp_2 = ath_hw_pll_rx_hang_check(sc,pll_sqsum);
  
#line 134 
  if ((int)tmp_2 != 0) 
#line 135 
                       goto return_label; else ;
  
#line 137 
  tmp_3 = msecs_to_jiffies(100U);
  
#line 137 
  ;
  
#line 137 
  ;
  
#line 137 
  ieee80211_queue_delayed_work(sc->hw,& sc->hw_pll_work,tmp_3);
  return_label: 
#line 139 
                return;
}


#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/link.c"
static void ath_paprd_activate(struct ath_softc *sc)
{
  int chain;
  
#line 146 
  struct ath_hw *ah = sc->sc_ah;
  
#line 147 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 148 
  struct ath9k_hw_cal_data *caldata = ah->caldata;
  
#line 151 
  if (caldata == (struct ath9k_hw_cal_data *)0) 
#line 151 
                                                goto _LOR;
  else {
    int tmp_0;
    
#line 151 
    tmp_0 = constant_test_bit(2L,(unsigned long const volatile *)(& caldata->cal_flags));
    
#line 151 
    if (tmp_0 == 0) {
      _LOR: {
              
#line 152 
              if ((common->debug_mask & 8) != 0) 
#line 152 
                                                 ath_printk("\001",(struct ath_common const *)common,"Failed to activate PAPRD\n"); else ;
              
#line 153 
              goto return_label;
            }
    }
    else ;
  }
  
#line 156 
  ar9003_paprd_enable(ah,(_Bool)0);
  
#line 157 
  chain = 0;
  
#line 157 
  goto ldv_53427;
  ldv_53426: 
#line 158 
  ;
  
#line 158 
  if ((((unsigned long)ah->txchainmask >> chain) & 1UL) == 0UL) 
#line 159 
                                                                goto ldv_53425; else ;
  
#line 161 
  ar9003_paprd_populate_single_table(ah,caldata,chain);
  ldv_53425: 
#line 162 
  ;
  
#line 157 
  chain += 1;
  ldv_53427: 
#line 158 
  ;
  
#line 157 
  if (chain <= 2) 
#line 159 
                  goto ldv_53426; else 
#line 162 
                                       goto ldv_53428;
  ldv_53428: 
#line 163 
  ;
  
#line 164 
  if ((common->debug_mask & 8) != 0) 
#line 164 
                                     ath_printk("\001",(struct ath_common const *)common,"Activating PAPRD\n"); else ;
  
#line 165 
  ar9003_paprd_enable(ah,(_Bool)1);
  return_label: 
#line 166 
                return;
}


#line 168  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/link.c"
static bool ath_paprd_send_frame(struct ath_softc *sc, struct sk_buff *skb, int chain)
{
  bool __retres;
  struct ath_tx_control txctl;
  int time_left;
  int tmp_1;
  unsigned long tmp_3;
  unsigned long tmp_2;
  
#line 170 
  struct ieee80211_hw *hw = sc->hw;
  
#line 171 
  struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
  
#line 172 
  struct ath_hw *ah = sc->sc_ah;
  
#line 173 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 177 
  memset((void *)(& txctl),0,32UL);
  
#line 178 
  txctl.txq = sc->tx.txq_map[2];
  
#line 180 
  memset((void *)tx_info,0,48UL);
  
#line 181 
  tx_info->band = (unsigned char)(sc->cur_chandef.chan)->band;
  
#line 182 
  tx_info->flags |= 4U;
  
#line 183 
  tx_info->__anonCompField_ieee80211_tx_info_98.control.__anonCompField___anonstruct_control_358_96.__anonCompField___anonunion_359_95.rates[0].idx = (signed char)0;
  
#line 184 
  tx_info->__anonCompField_ieee80211_tx_info_98.control.__anonCompField___anonstruct_control_358_96.__anonCompField___anonunion_359_95.rates[0].count = (unsigned short __attribute__((__FRAMA_C_BITFIELD_SIZE__(5))))1U;
  
#line 185 
  tx_info->__anonCompField_ieee80211_tx_info_98.control.__anonCompField___anonstruct_control_358_96.__anonCompField___anonunion_359_95.rates[0].flags = (unsigned short __attribute__((__FRAMA_C_BITFIELD_SIZE__(11))))8U;
  
#line 186 
  tx_info->__anonCompField_ieee80211_tx_info_98.control.__anonCompField___anonstruct_control_358_96.__anonCompField___anonunion_359_95.rates[1].idx = (signed char)(-1);
  
#line 188 
  init_completion(& sc->paprd_complete);
  
#line 189 
  txctl.paprd = (unsigned char)(1UL << chain);
  
#line 191 
  tmp_1 = ath_tx_start(hw,skb,& txctl);
  
#line 191 
  if (tmp_1 != 0) {
    
#line 192 
    if ((common->debug_mask & 8) != 0) 
#line 192 
                                       ath_printk("\001",(struct ath_common const *)common,"PAPRD TX failed\n"); else ;
    
#line 193 
    dev_kfree_skb_any(skb);
    
#line 194 
    __retres = (_Bool)0;
    
#line 194 
    goto return_label;
  }
  else ;
  
#line 197 
  tmp_2 = msecs_to_jiffies(100U);
  
#line 197 
  ;
  
#line 197 
  tmp_3 = wait_for_completion_timeout(& sc->paprd_complete,tmp_2);
  
#line 197 
  time_left = (int)tmp_3;
  
#line 200 
  if (time_left == 0) {
    
#line 201 
    if ((common->debug_mask & 8) != 0) 
#line 201 
                                       ath_printk("\001",(struct ath_common const *)common,"Timeout waiting for paprd training on TX chain %d\n",chain); else ;
  }
  else ;
  
#line 205 
  __retres = (_Bool)(time_left != 0);
  return_label: 
#line 205 
                return __retres;
}


#line 208  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/link.c"
void ath_paprd_calibrate(struct work_struct *work)
{
  struct ath_softc *tmp;
  struct ieee80211_hdr *hdr;
  int ftype;
  int chain;
  int ret;
  int tmp_3;
  int tmp_5;
  bool tmp_4;
  int tmp_7;
  bool tmp_6;
  {
    
#line 210 
    struct work_struct const *__mptr = (struct work_struct const *)work;
    
#line 210 
    tmp = (struct ath_softc *)__mptr + 18446744073709548680U;
  }
  
#line 210 
  struct ath_softc *sc = tmp;
  
#line 211 
  struct ieee80211_hw *hw = sc->hw;
  
#line 212 
  struct ath_hw *ah = sc->sc_ah;
  
#line 214 
  struct sk_buff *skb = (struct sk_buff *)0;
  
#line 215 
  struct ath9k_hw_cal_data *caldata = ah->caldata;
  
#line 216 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 218 
  int chain_ok = 0;
  
#line 220 
  int len = 1800;
  
#line 223 
  if (caldata == (struct ath9k_hw_cal_data *)0) 
#line 223 
                                                goto _LOR;
  else {
    int tmp_1;
    
#line 223 
    tmp_1 = constant_test_bit(1L,(unsigned long const volatile *)(& caldata->cal_flags));
    
#line 223 
    if (tmp_1 == 0) 
#line 223 
                    goto _LOR;
    else {
      int tmp_2;
      
#line 224 
      tmp_2 = constant_test_bit(2L,(unsigned long const volatile *)(& caldata->cal_flags));
      
#line 224 
      if (tmp_2 != 0) {
        _LOR: {
                
#line 226 
                if ((common->debug_mask & 8) != 0) 
#line 226 
                                                   ath_printk("\001",(struct ath_common const *)common,"Skipping PAPRD calibration\n"); else ;
                
#line 227 
                goto return_label;
              }
      }
      else ;
    }
  }
  
#line 230 
  ath9k_ps_wakeup(sc);
  
#line 232 
  tmp_3 = ar9003_paprd_init_table(ah);
  
#line 232 
  if (tmp_3 < 0) 
#line 233 
                 goto fail_paprd; else ;
  
#line 235 
  skb = alloc_skb((unsigned int)len,208U);
  
#line 236 
  if (skb == (struct sk_buff *)0) 
#line 237 
                                  goto fail_paprd; else ;
  
#line 239 
  skb_put(skb,(unsigned int)len);
  
#line 240 
  memset((void *)skb->data,0,(unsigned long)len);
  
#line 241 
  hdr = (struct ieee80211_hdr *)skb->data;
  
#line 242 
  ftype = 72;
  
#line 243 
  hdr->frame_control = (unsigned short)ftype;
  
#line 244 
  hdr->duration_id = (unsigned short)10U;
  
#line 245 
  memcpy((void *)(& hdr->addr1),(void const *)(& (hw->wiphy)->perm_addr),6UL);
  
#line 246 
  memcpy((void *)(& hdr->addr2),(void const *)(& (hw->wiphy)->perm_addr),6UL);
  
#line 247 
  memcpy((void *)(& hdr->addr3),(void const *)(& (hw->wiphy)->perm_addr),6UL);
  
#line 249 
  chain = 0;
  
#line 249 
  goto ldv_53461;
  ldv_53460: 
#line 250 
  ;
  
#line 250 
  if ((((unsigned long)ah->txchainmask >> chain) & 1UL) == 0UL) 
#line 251 
                                                                goto ldv_53458; else ;
  
#line 253 
  chain_ok = 0;
  
#line 254 
  ar9003_paprd_setup_gain_table(ah,chain);
  
#line 256 
  if ((common->debug_mask & 8) != 0) 
#line 256 
                                     ath_printk("\001",(struct ath_common const *)common,"Sending PAPRD training frame on chain %d\n",chain); else ;
  
#line 258 
  tmp_4 = ath_paprd_send_frame(sc,skb,chain);
  
#line 258 
  if (tmp_4) 
#line 258 
             tmp_5 = 0; else 
#line 258 
                             tmp_5 = 1;
  
#line 258 
  if (tmp_5) 
#line 259 
             goto fail_paprd; else ;
  
#line 261 
  tmp_6 = ar9003_paprd_is_done(ah);
  
#line 261 
  if (tmp_6) 
#line 261 
             tmp_7 = 0; else 
#line 261 
                             tmp_7 = 1;
  
#line 261 
  if (tmp_7) {
    
#line 262 
    if ((common->debug_mask & 8) != 0) 
#line 262 
                                       ath_printk("\001",(struct ath_common const *)common,"PAPRD not yet done on chain %d\n",chain); else ;
    
#line 264 
    goto ldv_53459;
  }
  else ;
  
#line 267 
  ret = ar9003_paprd_create_curve(ah,caldata,chain);
  
#line 268 
  if (ret == -115) {
    
#line 269 
    if ((common->debug_mask & 8) != 0) 
#line 269 
                                       ath_printk("\001",(struct ath_common const *)common,"PAPRD curve on chain %d needs to be re-trained\n",chain); else ;
    
#line 272 
    goto ldv_53459;
  }
  else 
    
#line 273 
    if (ret != 0) {
      
#line 274 
      if ((common->debug_mask & 8) != 0) 
#line 274 
                                         ath_printk("\001",(struct ath_common const *)common,"PAPRD create curve failed on chain %d\n",chain); else ;
      
#line 277 
      goto ldv_53459;
    }
    else ;
  
#line 280 
  chain_ok = 1;
  ldv_53458: 
#line 281 
  ;
  
#line 249 
  chain += 1;
  ldv_53461: 
#line 250 
  ;
  
#line 249 
  if (chain <= 2) 
#line 251 
                  goto ldv_53460; else 
#line 254 
                                       goto ldv_53459;
  ldv_53459: 
#line 255 
  ;
  
#line 282 
  kfree_skb(skb);
  
#line 284 
  if (chain_ok != 0) {
    
#line 285 
    set_bit(2L,(unsigned long volatile *)(& caldata->cal_flags));
    
#line 286 
    ath_paprd_activate(sc);
  }
  else ;
  fail_paprd: 
#line 289 
  ;
  
#line 290 
  ath9k_ps_restore(sc);
  return_label: 
#line 291 
                return;
}


#line 300  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/link.c"
void ath_ani_calibrate(unsigned long data)
{
  u32 cal_interval;
  u32 short_cal_interval;
  u32 long_cal_interval;
  unsigned long flags;
  int tmp_2;
  unsigned int tmp_9;
  unsigned long tmp_12;
  bool tmp_14;
  
#line 302 
  struct ath_softc *sc = (struct ath_softc *)data;
  
#line 303 
  struct ath_hw *ah = sc->sc_ah;
  
#line 304 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 305 
  bool longcal = (_Bool)0;
  
#line 306 
  bool shortcal = (_Bool)0;
  
#line 307 
  bool aniflag = (_Bool)0;
  
#line 308 
  unsigned int timestamp = jiffies_to_msecs(jiffies);
  
#line 312 
  if (ah->caldata != (struct ath9k_hw_cal_data *)0) {
    int tmp_1;
    
#line 312 
    tmp_1 = constant_test_bit(4L,(unsigned long const volatile *)(& (ah->caldata)->cal_flags));
    
#line 312 
    if (tmp_1 != 0) 
#line 313 
                    long_cal_interval = 1000U; else 
#line 315 
                                                    long_cal_interval = 30000U;
  }
  else 
#line 315 
       long_cal_interval = 30000U;
  
#line 318 
  if (ah->opmode == (unsigned int)NL80211_IFTYPE_AP) 
#line 318 
                                                     tmp_2 = 100; else 
                                                                    
#line 318 
                                                                    tmp_2 = 1000;
  
#line 317 
  short_cal_interval = (unsigned int)tmp_2;
  
#line 321 
  if ((sc->sc_ah)->power_mode != (unsigned int)ATH9K_PM_AWAKE) {
    
#line 322 
    ah->ani_skip_count += 1U;
    
#line 322 
    if (ah->ani_skip_count > 9U) {
      
#line 323 
      ldv___ldv_spin_lock_72_0(& sc->sc_pm_lock);
      
#line 324 
      sc->ps_flags = (unsigned short)((unsigned int)sc->ps_flags | 32U);
      
#line 325 
      ldv_spin_unlock_irqrestore_73_0(& sc->sc_pm_lock,flags);
    }
    else ;
    
#line 327 
    goto set_timer;
  }
  else ;
  
#line 329 
  ah->ani_skip_count = 0U;
  
#line 330 
  ldv___ldv_spin_lock_74_1(& sc->sc_pm_lock);
  
#line 331 
  sc->ps_flags = (unsigned short)((unsigned int)sc->ps_flags & 65503U);
  
#line 332 
  ldv_spin_unlock_irqrestore_75_1(& sc->sc_pm_lock,flags);
  
#line 334 
  ath9k_ps_wakeup(sc);
  
#line 337 
  if (timestamp - common->ani.longcal_timer >= long_cal_interval) {
    
#line 338 
    longcal = (_Bool)1;
    
#line 339 
    common->ani.longcal_timer = timestamp;
  }
  else ;
  
#line 343 
  if (! common->ani.caldone) {
    
#line 344 
    if (timestamp - common->ani.shortcal_timer >= short_cal_interval) {
      
#line 345 
      shortcal = (_Bool)1;
      
#line 346 
      common->ani.shortcal_timer = timestamp;
      
#line 347 
      common->ani.resetcal_timer = timestamp;
    }
    else ;
  }
  else 
    
#line 350 
    if (timestamp - common->ani.resetcal_timer > 1199999U) {
      
#line 352 
      common->ani.caldone = ath9k_hw_reset_calvalid(ah);
      
#line 353 
      if ((int)common->ani.caldone != 0) 
#line 354 
                                         common->ani.resetcal_timer = timestamp; else ;
    }
    else ;
  
#line 359 
  if (timestamp - common->ani.checkani_timer >= (unsigned int)ah->config.ani_poll_interval) {
    
#line 360 
    aniflag = (_Bool)1;
    
#line 361 
    common->ani.checkani_timer = timestamp;
  }
  else ;
  
#line 365 
  if ((int)aniflag != 0) {
    
#line 366 
    ldv_spin_lock_76(& common->cc_lock);
    
#line 367 
    ath9k_hw_ani_monitor(ah,ah->curchan);
    
#line 368 
    ath_update_survey_stats(sc);
    
#line 369 
    ldv_spin_unlock_77(& common->cc_lock);
  }
  else ;
  
#line 373 
  if ((int)longcal != 0 || (int)shortcal != 0) {
    
#line 374 
    int ret = ath9k_hw_calibrate(ah,ah->curchan,(unsigned char)((int)ah->rxchainmask),(_Bool)((bool)((int)longcal) != 0));
    
#line 376 
    if (ret < 0) {
      
#line 377 
      common->ani.caldone = (_Bool)0;
      
#line 378 
      ath9k_queue_reset(sc,(enum ath_reset_type)RESET_TYPE_CALIBRATION);
      
#line 379 
      goto return_label;
    }
    else ;
    
#line 382 
    common->ani.caldone = (_Bool)(ret != 0);
  }
  else ;
  
#line 385 
  if ((common->debug_mask & 64) != 0) {
    char *tmp_4;
    char *tmp_5;
    char *tmp_6;
    char *tmp_7;
    
#line 385 
    if ((int)common->ani.caldone != 0) 
#line 385 
                                       tmp_4 = (char *)"true"; else 
#line 385 
                                                                    tmp_4 = (char *)"false";
    
#line 385 
    if ((int)aniflag != 0) 
#line 385 
                           tmp_5 = (char *)"ani"; else 
#line 385 
                                                       tmp_5 = (char *)"";
    
#line 385 
    if ((int)shortcal != 0) 
#line 385 
                            tmp_6 = (char *)"short"; else 
#line 385 
                                                          tmp_6 = (char *)"";
    
#line 385 
    if ((int)longcal != 0) 
#line 385 
                           tmp_7 = (char *)"long"; else 
#line 385 
                                                        tmp_7 = (char *)"";
    
#line 385 
    ;
    
#line 385 
    ;
    
#line 385 
    ath_printk("\001",(struct ath_common const *)common,"Calibration @%lu finished: %s %s %s, caldone: %s\n",jiffies,tmp_7,tmp_6,tmp_5,tmp_4);
  }
  else ;
  
#line 391 
  ath9k_ps_restore(sc);
  set_timer: 
#line 393 
  ;
  
#line 399 
  cal_interval = 30000U;
  {
    u32 tmp_8;
    
#line 400 
    u32 _min1 = cal_interval;
    
#line 400 
    unsigned int _min2 = (unsigned int)ah->config.ani_poll_interval;
    
#line 400 
    if (_min1 < _min2) 
#line 400 
                       tmp_8 = _min1; else 
#line 400 
                                           tmp_8 = _min2;
    
#line 400 
    tmp_9 = tmp_8;
  }
  
#line 400 
  cal_interval = tmp_9;
  
#line 401 
  if (! common->ani.caldone) {
    unsigned int tmp_11;
    {
      u32 tmp_10;
      
#line 402 
      u32 _min1_0 = cal_interval;
      
#line 402 
      unsigned int _min2_0 = short_cal_interval;
      
#line 402 
      if (_min1_0 < _min2_0) 
#line 402 
                             tmp_10 = _min1_0; else 
#line 402 
                                                    tmp_10 = _min2_0;
      
#line 402 
      tmp_11 = tmp_10;
    }
    
#line 402 
    cal_interval = tmp_11;
  }
  else ;
  
#line 404 
  tmp_12 = msecs_to_jiffies(cal_interval);
  
#line 404 
  ;
  
#line 404 
  ;
  
#line 404 
  ldv_mod_timer_78(& common->ani.timer,tmp_12 + jiffies);
  
#line 406 
  tmp_14 = ar9003_is_paprd_enabled(ah);
  
#line 406 
  if ((int)tmp_14 != 0) {
    
#line 406 
    if (ah->caldata != (struct ath9k_hw_cal_data *)0) {
      int tmp_13;
      
#line 407 
      tmp_13 = constant_test_bit(2L,(unsigned long const volatile *)(& (ah->caldata)->cal_flags));
      
#line 407 
      if (tmp_13 == 0) 
#line 408 
                       ieee80211_queue_work(sc->hw,& sc->paprd_work);
      else 
        
#line 409 
        if (! ah->paprd_table_write_done) {
          
#line 410 
          ath9k_ps_wakeup(sc);
          
#line 411 
          ath_paprd_activate(sc);
          
#line 412 
          ath9k_ps_restore(sc);
        }
        else ;
    }
    else ;
  }
  else ;
  return_label: 
#line 414 
                return;
}


#line 417  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/link.c"
void ath_start_ani(struct ath_softc *sc)
{
  unsigned int tmp_0;
  unsigned long tmp_2;
  
#line 419 
  struct ath_hw *ah = sc->sc_ah;
  
#line 420 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 421 
  tmp_0 = jiffies_to_msecs(jiffies);
  
#line 421 
  unsigned long timestamp = (unsigned long)tmp_0;
  
#line 423 
  if ((int)common->disable_ani != 0) 
#line 426 
                                     goto return_label;
  else {
    int tmp_1;
    
#line 423 
    tmp_1 = constant_test_bit(2L,(unsigned long const volatile *)(& common->op_flags));
    
#line 423 
    if (tmp_1 == 0) 
#line 426 
                    goto return_label;
    else 
      
#line 424 
      if ((int)(sc->cur_chan)->offchannel != 0) 
#line 426 
                                                goto return_label; else ;
  }
  
#line 428 
  common->ani.longcal_timer = (unsigned int)timestamp;
  
#line 429 
  common->ani.shortcal_timer = (unsigned int)timestamp;
  
#line 430 
  common->ani.checkani_timer = (unsigned int)timestamp;
  
#line 432 
  if ((common->debug_mask & 64) != 0) 
#line 432 
                                      ath_printk("\001",(struct ath_common const *)common,"Starting ANI\n"); else ;
  
#line 433 
  tmp_2 = msecs_to_jiffies((unsigned int)ah->config.ani_poll_interval);
  
#line 433 
  ;
  
#line 433 
  ;
  
#line 433 
  ldv_mod_timer_79(& common->ani.timer,tmp_2 + jiffies);
  return_label: 
#line 435 
                return;
}


#line 437  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/link.c"
void ath_stop_ani(struct ath_softc *sc)
{
  
#line 439 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 441 
  if ((common->debug_mask & 64) != 0) 
#line 441 
                                      ath_printk("\001",(struct ath_common const *)common,"Stopping ANI\n"); else ;
  
#line 442 
  ldv_del_timer_sync_80_0(& common->ani.timer);
  
#line 443 
  return;
}


#line 445  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/link.c"
void ath_check_ani(struct ath_softc *sc)
{
  int tmp_2;
  
#line 447 
  struct ath_hw *ah = sc->sc_ah;
  
#line 448 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 449 
  struct ath_beacon_config *cur_conf = & (sc->cur_chan)->beacon;
  
#line 455 
  if (ah->opmode == (unsigned int)NL80211_IFTYPE_ADHOC) {
    
#line 456 
    if ((unsigned int)cur_conf->enable_beacon == 0U) 
#line 457 
                                                     goto stop_ani; else ;
  }
  else 
    
#line 458 
    if (ah->opmode == (unsigned int)NL80211_IFTYPE_AP) {
      
#line 459 
      if ((unsigned int)cur_conf->enable_beacon == 0U) {
        int tmp_0;
        
#line 464 
        tmp_0 = constant_test_bit(3L,(unsigned long const volatile *)(& common->op_flags));
        
#line 464 
        if (tmp_0 == 0) 
#line 465 
                        goto stop_ani; else ;
      }
      else ;
    }
    else 
      
#line 467 
      if (ah->opmode == (unsigned int)NL80211_IFTYPE_STATION) {
        int tmp_1;
        
#line 468 
        tmp_1 = constant_test_bit(3L,(unsigned long const volatile *)(& common->op_flags));
        
#line 468 
        if (tmp_1 == 0) 
#line 469 
                        goto stop_ani; else ;
      }
      else ;
  
#line 472 
  tmp_2 = constant_test_bit(2L,(unsigned long const volatile *)(& common->op_flags));
  
#line 472 
  if (tmp_2 == 0) {
    
#line 473 
    set_bit(2L,(unsigned long volatile *)(& common->op_flags));
    
#line 474 
    ath_start_ani(sc);
  }
  else ;
  
#line 477 
  goto return_label;
  stop_ani: 
#line 479 
  ;
  
#line 480 
  set_bit(2L,(unsigned long volatile *)(& common->op_flags));
  
#line 481 
  ath_stop_ani(sc);
  return_label: 
#line 482 
                return;
}


#line 484  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/link.c"
void ath_update_survey_nf(struct ath_softc *sc, int channel)
{
  
#line 486 
  struct ath_hw *ah = sc->sc_ah;
  
#line 487 
  struct ath9k_channel *chan = & ah->channels[channel];
  
#line 488 
  struct survey_info *survey = & sc->survey[channel];
  
#line 490 
  if ((int)chan->noisefloor != 0) {
    s16 tmp;
    
#line 491 
    survey->filled |= 1U;
    
#line 492 
    tmp = ath9k_hw_getchan_noise(ah,chan,(short)((int)chan->noisefloor));
    
#line 492 
    survey->noise = (signed char)tmp;
  }
  else ;
  
#line 495 
  return;
}


#line 502  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/link.c"
int ath_update_survey_stats(struct ath_softc *sc)
{
  int __retres;
  
#line 504 
  struct ath_hw *ah = sc->sc_ah;
  
#line 505 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 506 
  int pos = (int)(((long)ah->curchan - (long)(& ah->channels[0])) / 16L);
  
#line 507 
  struct survey_info *survey = & sc->survey[pos];
  
#line 508 
  struct ath_cycle_counters *cc = & common->cc_survey;
  
#line 509 
  unsigned int div = common->clockrate * 1000U;
  
#line 510 
  int ret = 0;
  
#line 512 
  if (ah->curchan == (struct ath9k_channel *)0) {
    
#line 513 
    __retres = -1;
    
#line 513 
    goto return_label;
  }
  else ;
  
#line 515 
  if (ah->power_mode == (unsigned int)ATH9K_PM_AWAKE) 
#line 516 
                                                      ath_hw_cycle_counters_update(common); else ;
  
#line 518 
  if (cc->cycles != 0U) {
    
#line 519 
    survey->filled |= 108U;
    
#line 523 
    survey->time += (unsigned long long)(cc->cycles / div);
    
#line 524 
    survey->time_busy += (unsigned long long)(cc->rx_busy / div);
    
#line 525 
    survey->time_rx += (unsigned long long)(cc->rx_frame / div);
    
#line 526 
    survey->time_tx += (unsigned long long)(cc->tx_frame / div);
  }
  else ;
  
#line 529 
  if (cc->cycles < div) {
    
#line 530 
    __retres = -1;
    
#line 530 
    goto return_label;
  }
  else ;
  
#line 532 
  if (cc->cycles != 0U) 
#line 533 
                        ret = (int)((cc->rx_busy * 100U) / cc->cycles); else ;
  
#line 535 
  memset((void *)cc,0,16UL);
  
#line 537 
  ath_update_survey_nf(sc,pos);
  
#line 539 
  __retres = ret;
  return_label: 
#line 539 
                return __retres;
}


#line 64  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_link.c.aux"
int ldv_emg_mod_timer(struct timer_list *arg0, unsigned long arg1);


#line 737  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_link.c.aux"
static void ldv___ldv_spin_lock_72_0(spinlock_t *ldv_func_arg1)
{
  
#line 741 
  ldv_spin_model_lock((char *)"sc_pm_lock_of_ath_softc");
  
#line 743 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 744 
  return;
}


#line 747  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_link.c.aux"
static void ldv_spin_unlock_irqrestore_73_0(spinlock_t *lock, unsigned long flags)
{
  
#line 751 
  ldv_spin_model_unlock((char *)"sc_pm_lock_of_ath_softc");
  
#line 753 
  spin_unlock_irqrestore_3(lock,flags);
  
#line 754 
  return;
}


#line 757  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_link.c.aux"
static void ldv___ldv_spin_lock_74_1(spinlock_t *ldv_func_arg1)
{
  
#line 761 
  ldv_spin_model_lock((char *)"sc_pm_lock_of_ath_softc");
  
#line 763 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 764 
  return;
}


#line 767  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_link.c.aux"
static void ldv_spin_unlock_irqrestore_75_1(spinlock_t *lock, unsigned long flags)
{
  
#line 771 
  ldv_spin_model_unlock((char *)"sc_pm_lock_of_ath_softc");
  
#line 773 
  spin_unlock_irqrestore_3(lock,flags);
  
#line 774 
  return;
}


#line 777  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_link.c.aux"
static void ldv_spin_lock_76(spinlock_t *lock)
{
  
#line 781 
  ldv_spin_model_lock((char *)"cc_lock_of_ath_common");
  
#line 783 
  spin_lock(lock);
  
#line 784 
  return;
}


#line 787  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_link.c.aux"
static void ldv_spin_unlock_77(spinlock_t *lock)
{
  
#line 791 
  ldv_spin_model_unlock((char *)"cc_lock_of_ath_common");
  
#line 793 
  spin_unlock(lock);
  
#line 794 
  return;
}


#line 797  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_link.c.aux"
static int ldv_mod_timer_78(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2)
{
  int tmp;
  
#line 801 
  tmp = ldv_emg_mod_timer(ldv_func_arg1,ldv_func_arg2);
  
#line 801 
  return tmp;
}


#line 805  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_link.c.aux"
static int ldv_mod_timer_79(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2)
{
  int tmp;
  
#line 809 
  tmp = ldv_emg_mod_timer(ldv_func_arg1,ldv_func_arg2);
  
#line 809 
  return tmp;
}


#line 813  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_link.c.aux"
static int ldv_del_timer_sync_80_0(struct timer_list *ldv_func_arg1)
{
  int tmp;
  
#line 817 
  tmp = ldv_emg_del_timer_sync(ldv_func_arg1);
  
#line 817 
  return tmp;
}


#line 581  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kzalloc_1(size_t size, gfp_t flags);


#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debugfs.h"
static struct dentry *ldv_debugfs_create_file_72_0(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 58 
static struct dentry *ldv_debugfs_create_file_73_0(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 265  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug.h"
void ath9k_sta_add_debugfs(struct ieee80211_hw *hw, struct ieee80211_vif *vif, struct ieee80211_sta *sta, struct dentry *dir);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug_sta.c"
static ssize_t read_file_node_aggr(struct file *file, char *user_buf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  struct ath_atx_tid *tid;
  struct ath_atx_ac *ac;
  struct ath_txq *txq;
  char *buf;
  size_t retval;
  int tidno;
  int acno;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  int tmp_4;
  int tmp_5;
  ssize_t tmp_7;
  
#line 26 
  struct ath_node *an = (struct ath_node *)file->private_data;
  
#line 27 
  struct ath_softc *sc = an->sc;
  
#line 31 
  u32 len = 0U;
  
#line 31 
  u32 size = 4096U;
  
#line 36 
  buf = (char *)kzalloc_1((unsigned long)size,208U);
  
#line 37 
  if (buf == (char *)0) {
    
#line 38 
    __retres = -12L;
    
#line 38 
    goto return_label;
  }
  else ;
  
#line 40 
  if (! (an->sta)->ht_cap.ht_supported) {
    int tmp_0;
    
#line 41 
    tmp_0 = scnprintf(buf,(unsigned long)size,"%s\n",(char *)"HT not supported");
    
#line 41 
    len = (unsigned int)tmp_0;
    
#line 43 
    goto exit;
  }
  else ;
  
#line 46 
  tmp_1 = scnprintf(buf,(unsigned long)size,"Max-AMPDU: %d\n",(int)an->maxampdu);
  
#line 46 
  len = (unsigned int)tmp_1;
  
#line 48 
  tmp_2 = scnprintf(buf + len,(unsigned long)(size - len),"MPDU Density: %d\n\n",(int)an->mpdudensity);
  
#line 49 
  len = (unsigned int)tmp_2 + len;
  
#line 51 
  tmp_3 = scnprintf(buf + len,(unsigned long)(size - len),"%2s%7s\n",(char *)"AC",(char *)"SCHED");
  
#line 52 
  len = (unsigned int)tmp_3 + len;
  
#line 54 
  acno = 0;
  
#line 54 
  ac = & an->ac[acno];
  
#line 54 
  goto ldv_53379;
  ldv_53378: 
#line 55 
  ;
  
#line 56 
  txq = ac->txq;
  
#line 57 
  ath_txq_lock(sc,txq);
  
#line 58 
  tmp_4 = scnprintf(buf + len,(unsigned long)(size - len),"%2d%7d\n",acno,(int)ac->sched);
  
#line 60 
  len = (unsigned int)tmp_4 + len;
  
#line 61 
  ath_txq_unlock(sc,txq);
  
#line 55 
  acno += 1;
  
#line 55 
  ac += 1;
  ldv_53379: 
#line 56 
  ;
  
#line 54 
  if (acno <= 3) 
#line 57 
                 goto ldv_53378; else 
#line 60 
                                      goto ldv_53380;
  ldv_53380: 
#line 61 
  ;
  
#line 64 
  tmp_5 = scnprintf(buf + len,(unsigned long)(size - len),"\n%3s%11s%10s%10s%10s%10s%9s%6s%8s\n",(char *)"TID",(char *)"SEQ_START",(char *)"SEQ_NEXT",(char *)"BAW_SIZE",(char *)"BAW_HEAD",(char *)"BAW_TAIL",(char *)"BAR_IDX",(char *)"SCHED",(char *)"PAUSED");
  
#line 67 
  len = (unsigned int)tmp_5 + len;
  
#line 69 
  tidno = 0;
  
#line 69 
  tid = & an->tid[tidno];
  
#line 69 
  goto ldv_53382;
  ldv_53381: 
#line 70 
  ;
  
#line 71 
  txq = (tid->ac)->txq;
  
#line 72 
  ath_txq_lock(sc,txq);
  
#line 73 
  if ((int)tid->active != 0) {
    int tmp_6;
    
#line 74 
    tmp_6 = scnprintf(buf + len,(unsigned long)(size - len),"%3d%11d%10d%10d%10d%10d%9d%6d\n",(int)tid->tidno,(int)tid->seq_start,(int)tid->seq_next,(int)tid->baw_size,tid->baw_head,tid->baw_tail,(int)tid->bar_index,(int)tid->sched);
    
#line 83 
    len = (unsigned int)tmp_6 + len;
  }
  else ;
  
#line 85 
  ath_txq_unlock(sc,txq);
  
#line 70 
  tidno += 1;
  
#line 70 
  tid += 1;
  ldv_53382: 
#line 71 
  ;
  
#line 69 
  if (tidno <= 15) 
#line 72 
                   goto ldv_53381; else 
#line 75 
                                        goto ldv_53383;
  ldv_53383: 
#line 76 
  ;
  exit: 
#line 87 
  ;
  
#line 88 
  tmp_7 = simple_read_from_buffer((void *)user_buf,count,ppos,(void const *)buf,(unsigned long)len);
  
#line 88 
  retval = (unsigned long)tmp_7;
  
#line 89 
  kfree((void const *)buf);
  
#line 91 
  __retres = (long)retval;
  return_label: 
#line 91 
                return __retres;
}


#line 94  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug_sta.c"
static struct file_operations const fops_node_aggr = {.owner = & __this_module, .llseek = & default_llseek, .read = & read_file_node_aggr, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug_sta.c"
void ath_debug_rate_stats(struct ath_softc *sc, struct ath_rx_status *rs, struct sk_buff *skb)
{
  struct ieee80211_rx_status *rxs;
  struct ath_rx_rate_stats *rstats;
  struct ieee80211_sta *sta;
  struct ath_node *an;
  int tmp;
  
#line 109 
  struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
  
#line 110 
  struct ath_hw *ah = sc->sc_ah;
  
#line 116 
  tmp = ieee80211_is_data((unsigned short)((int)hdr->frame_control));
  
#line 116 
  if (tmp == 0) 
#line 117 
                goto return_label; else ;
  
#line 119 
  rcu_read_lock();
  
#line 121 
  sta = ieee80211_find_sta_by_ifaddr(sc->hw,(u8 const *)(& hdr->addr2),(u8 const *)0U);
  
#line 122 
  if (sta == (struct ieee80211_sta *)0) 
#line 123 
                                        goto exit; else ;
  
#line 125 
  an = (struct ath_node *)(& sta->drv_priv);
  
#line 126 
  rstats = & an->rx_rate_stats;
  
#line 127 
  rxs = IEEE80211_SKB_RXCB(skb);
  
#line 129 
  if ((int)rs->rs_rate < 0) {
    
#line 130 
    if ((unsigned int)rxs->rate_idx > 23U) 
#line 131 
                                           goto exit; else ;
    
#line 133 
    if ((rxs->flag & 1024U) != 0U) 
#line 134 
                                   rstats->ht_stats[(int)rxs->rate_idx].ht40_cnt += 1U; else 
                                                                    
#line 136 
                                                                    rstats->ht_stats[(int)rxs->rate_idx].ht20_cnt += 1U;
    
#line 138 
    if ((rxs->flag & 2048U) != 0U) 
#line 139 
                                   rstats->ht_stats[(int)rxs->rate_idx].sgi_cnt += 1U; else 
                                                                    
#line 141 
                                                                    rstats->ht_stats[(int)rxs->rate_idx].lgi_cnt += 1U;
    
#line 143 
    goto exit;
  }
  else ;
  
#line 146 
  if ((unsigned int)rs->rs_rate + 232U <= 6U) {
    
#line 147 
    if ((rxs->flag & 256U) != 0U) 
#line 148 
                                  rstats->cck_stats[(int)rxs->rate_idx].cck_sp_cnt += 1U; else 
                                                                    
#line 150 
                                                                    rstats->cck_stats[(int)rxs->rate_idx].cck_lp_cnt += 1U;
    
#line 152 
    goto exit;
  }
  else ;
  
#line 155 
  if ((unsigned int)rs->rs_rate + 248U <= 7U) 
    
#line 156 
    if (((ah->curchan)->chan)->band == (unsigned int)IEEE80211_BAND_2GHZ) 
      
#line 157 
      rstats->ofdm_stats[(int)rxs->rate_idx + -4].ofdm_cnt += 1U; else 
                                                                    
#line 159 
                                                                    rstats->ofdm_stats[(int)rxs->rate_idx].ofdm_cnt += 1U;
  else ;
  exit: 
#line 161 
  ;
  
#line 162 
  rcu_read_unlock();
  return_label: 
#line 163 
                return;
}


#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug_sta.c"
static ssize_t read_file_node_recv(struct file *file, char *user_buf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  struct ath_rx_rate_stats *rstats;
  enum ieee80211_band band;
  char *buf;
  size_t retval;
  int i;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  int tmp_10;
  int tmp_11;
  int tmp_12;
  int tmp_13;
  int tmp_14;
  int tmp_15;
  int tmp_16;
  int tmp_17;
  ssize_t tmp_18;
  
#line 185 
  struct ath_node *an = (struct ath_node *)file->private_data;
  
#line 186 
  struct ath_softc *sc = an->sc;
  
#line 187 
  struct ath_hw *ah = sc->sc_ah;
  
#line 189 
  struct ieee80211_sta *sta = an->sta;
  
#line 191 
  u32 len = 0U;
  
#line 191 
  u32 size = 4096U;
  
#line 196 
  buf = (char *)kzalloc_1((unsigned long)size,208U);
  
#line 197 
  if (buf == (char *)0) {
    
#line 198 
    __retres = -12L;
    
#line 198 
    goto return_label;
  }
  else ;
  
#line 200 
  band = ((ah->curchan)->chan)->band;
  
#line 201 
  rstats = & an->rx_rate_stats;
  
#line 203 
  if (! sta->ht_cap.ht_supported) 
#line 204 
                                  goto legacy; else ;
  
#line 206 
  tmp_0 = scnprintf(buf + len,(unsigned long)(size - len),"%24s%10s%10s%10s\n",(char *)"HT20",(char *)"HT40",(char *)"SGI",(char *)"LGI");
  
#line 208 
  len = (unsigned int)tmp_0 + len;
  
#line 210 
  i = 0;
  
#line 210 
  goto ldv_53419;
  ldv_53418: 
#line 211 
  ;
  
#line 211 
  tmp_1 = scnprintf(buf + len,(unsigned long)(size - len),"%8s%3u : %10u%10u%10u%10u\n",(char *)"MCS",i,rstats->ht_stats[i].ht20_cnt,rstats->ht_stats[i].ht40_cnt,rstats->ht_stats[i].sgi_cnt,rstats->ht_stats[i].lgi_cnt);
  
#line 217 
  len = (unsigned int)tmp_1 + len;
  
#line 210 
  i += 1;
  ldv_53419: 
#line 211 
  ;
  
#line 210 
  if (i <= 23) 
#line 212 
               goto ldv_53418; else 
#line 215 
                                    goto ldv_53420;
  ldv_53420: 
#line 216 
  ;
  
#line 220 
  tmp_2 = scnprintf(buf + len,(unsigned long)(size - len),"\n");
  
#line 220 
  len = (unsigned int)tmp_2 + len;
  legacy: 
#line 222 
  ;
  
#line 223 
  if (band == (unsigned int)IEEE80211_BAND_2GHZ) {
    int tmp_3;
    int tmp_4;
    int tmp_5;
    int tmp_6;
    int tmp_7;
    int tmp_8;
    int tmp_9;
    
#line 224 
    tmp_3 = scnprintf(buf + len,(unsigned long)(size - len),"%11s : %10u\n",(char *)"CCK-1M/LP",rstats->cck_stats[0].cck_lp_cnt);
    
#line 224 
    len = (unsigned int)tmp_3 + len;
    
#line 225 
    tmp_4 = scnprintf(buf + len,(unsigned long)(size - len),"%11s : %10u\n",(char *)"CCK-2M/LP",rstats->cck_stats[1].cck_lp_cnt);
    
#line 225 
    len = (unsigned int)tmp_4 + len;
    
#line 226 
    tmp_5 = scnprintf(buf + len,(unsigned long)(size - len),"%11s : %10u\n",(char *)"CCK-5.5M/LP",rstats->cck_stats[2].cck_lp_cnt);
    
#line 226 
    len = (unsigned int)tmp_5 + len;
    
#line 227 
    tmp_6 = scnprintf(buf + len,(unsigned long)(size - len),"%11s : %10u\n",(char *)"CCK-11M/LP",rstats->cck_stats[3].cck_lp_cnt);
    
#line 227 
    len = (unsigned int)tmp_6 + len;
    
#line 229 
    tmp_7 = scnprintf(buf + len,(unsigned long)(size - len),"%11s : %10u\n",(char *)"CCK-2M/SP",rstats->cck_stats[1].cck_sp_cnt);
    
#line 229 
    len = (unsigned int)tmp_7 + len;
    
#line 230 
    tmp_8 = scnprintf(buf + len,(unsigned long)(size - len),"%11s : %10u\n",(char *)"CCK-5.5M/SP",rstats->cck_stats[2].cck_sp_cnt);
    
#line 230 
    len = (unsigned int)tmp_8 + len;
    
#line 231 
    tmp_9 = scnprintf(buf + len,(unsigned long)(size - len),"%11s : %10u\n",(char *)"CCK-11M/SP",rstats->cck_stats[3].cck_sp_cnt);
    
#line 231 
    len = (unsigned int)tmp_9 + len;
  }
  else ;
  
#line 234 
  tmp_10 = scnprintf(buf + len,(unsigned long)(size - len),"%11s : %10u\n",(char *)"OFDM-6M",rstats->ofdm_stats[0].ofdm_cnt);
  
#line 234 
  len = (unsigned int)tmp_10 + len;
  
#line 235 
  tmp_11 = scnprintf(buf + len,(unsigned long)(size - len),"%11s : %10u\n",(char *)"OFDM-9M",rstats->ofdm_stats[1].ofdm_cnt);
  
#line 235 
  len = (unsigned int)tmp_11 + len;
  
#line 236 
  tmp_12 = scnprintf(buf + len,(unsigned long)(size - len),"%11s : %10u\n",(char *)"OFDM-12M",rstats->ofdm_stats[2].ofdm_cnt);
  
#line 236 
  len = (unsigned int)tmp_12 + len;
  
#line 237 
  tmp_13 = scnprintf(buf + len,(unsigned long)(size - len),"%11s : %10u\n",(char *)"OFDM-18M",rstats->ofdm_stats[3].ofdm_cnt);
  
#line 237 
  len = (unsigned int)tmp_13 + len;
  
#line 238 
  tmp_14 = scnprintf(buf + len,(unsigned long)(size - len),"%11s : %10u\n",(char *)"OFDM-24M",rstats->ofdm_stats[4].ofdm_cnt);
  
#line 238 
  len = (unsigned int)tmp_14 + len;
  
#line 239 
  tmp_15 = scnprintf(buf + len,(unsigned long)(size - len),"%11s : %10u\n",(char *)"OFDM-36M",rstats->ofdm_stats[5].ofdm_cnt);
  
#line 239 
  len = (unsigned int)tmp_15 + len;
  
#line 240 
  tmp_16 = scnprintf(buf + len,(unsigned long)(size - len),"%11s : %10u\n",(char *)"OFDM-48M",rstats->ofdm_stats[6].ofdm_cnt);
  
#line 240 
  len = (unsigned int)tmp_16 + len;
  
#line 241 
  tmp_17 = scnprintf(buf + len,(unsigned long)(size - len),"%11s : %10u\n",(char *)"OFDM-54M",rstats->ofdm_stats[7].ofdm_cnt);
  
#line 241 
  len = (unsigned int)tmp_17 + len;
  
#line 243 
  tmp_18 = simple_read_from_buffer((void *)user_buf,count,ppos,(void const *)buf,(unsigned long)len);
  
#line 243 
  retval = (unsigned long)tmp_18;
  
#line 244 
  kfree((void const *)buf);
  
#line 246 
  __retres = (long)retval;
  return_label: 
#line 246 
                return __retres;
}


#line 252  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug_sta.c"
static struct file_operations const fops_node_recv = {.owner = & __this_module, .llseek = & default_llseek, .read = & read_file_node_recv, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 259  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/debug_sta.c"
void ath9k_sta_add_debugfs(struct ieee80211_hw *hw, struct ieee80211_vif *vif, struct ieee80211_sta *sta, struct dentry *dir)
{
  
#line 264 
  struct ath_node *an = (struct ath_node *)(& sta->drv_priv);
  
#line 266 
  ldv_debugfs_create_file_72_0("node_aggr",(unsigned short)292,dir,(void *)an,& fops_node_aggr);
  
#line 267 
  ldv_debugfs_create_file_73_0("node_recv",(unsigned short)292,dir,(void *)an,& fops_node_recv);
  
#line 268 
  return;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug_sta.c.aux"
struct file_operations *ldv_emg_alias_fops_node_aggr_2 = (struct file_operations *)(& fops_node_aggr);

#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug_sta.c.aux"
struct file_operations *ldv_emg_alias_fops_node_recv_2 = (struct file_operations *)(& fops_node_recv);

#line 72  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug_sta.c.aux"
long ldv_emg_wrapper_read_file_node_aggr_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 73 
  tmp = read_file_node_aggr(arg0,arg1,arg2,arg3);
  
#line 73 
  return tmp;
}


#line 77  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug_sta.c.aux"
long ldv_emg_wrapper_read_file_node_recv_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 78 
  tmp = read_file_node_recv(arg0,arg1,arg2,arg3);
  
#line 78 
  return tmp;
}


#line 436  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug_sta.c.aux"
static void *kzalloc_1(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 439 
  tmp = ldv_kzalloc(size,flags);
  
#line 439 
  return tmp;
}


#line 753  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug_sta.c.aux"
static struct dentry *ldv_debugfs_create_file_72_0(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 757 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 757 
  return tmp;
}


#line 761  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_debug_sta.c.aux"
static struct dentry *ldv_debugfs_create_file_73_0(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 765 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 765 
  return tmp;
}


#line 204  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr, unsigned long volatile *addr)
{
  int __retres;
  
#line 206 
  ldv_inline_asm();
  
#line 207 
  ldv_inline_asm();
  
#line 206 
  __retres = 0;
  
#line 206 
  goto return_label;
  cc_label: 
#line 206 
  ;
  
#line 206 
  __retres = 1;
  return_label: 
#line 206 
                return __retres;
}


#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
int memcmp(void const *, void const *, size_t);


#line 355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_bh_3(spinlock_t *lock)
{
  
#line 357 
  _raw_spin_lock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 358 
  return;
}


#line 383 
static void ldv_spin_lock_bh_72_2(spinlock_t *lock);


#line 387 
static void ldv_spin_lock_bh_74_0(spinlock_t *lock);


#line 391 
static void ldv_spin_lock_bh_76(spinlock_t *lock);


#line 395 
static void ldv_spin_lock_bh_79(spinlock_t *lock);


#line 399 
static void ldv_spin_lock_bh_81(spinlock_t *lock);


#line 403 
static void ldv_spin_lock_bh_86(spinlock_t *lock);


#line 407 
static void ldv_spin_lock_bh_88(spinlock_t *lock);


#line 411 
static void ldv_spin_lock_bh_91(spinlock_t *lock);


#line 415 
static void ldv_spin_lock_bh_93(spinlock_t *lock);


#line 419 
static void ldv_spin_lock_bh_98(spinlock_t *lock);


#line 423 
static void ldv_spin_lock_bh_102(spinlock_t *lock);


#line 427 
static void ldv_spin_lock_bh_107(spinlock_t *lock);


#line 431 
static void ldv_spin_lock_bh_111(spinlock_t *lock);


#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_bh_3(spinlock_t *lock)
{
  
#line 406 
  _raw_spin_unlock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 407 
  return;
}


#line 432 
static void ldv_spin_unlock_bh_73_2(spinlock_t *lock);


#line 436 
static void ldv_spin_unlock_bh_75_0(spinlock_t *lock);


#line 440 
static void ldv_spin_unlock_bh_77_0(spinlock_t *lock);


#line 444 
static void ldv_spin_unlock_bh_78_0(spinlock_t *lock);


#line 448 
static void ldv_spin_unlock_bh_80(spinlock_t *lock);


#line 452 
static void ldv_spin_unlock_bh_82_0(spinlock_t *lock);


#line 456 
static void ldv_spin_unlock_bh_83(spinlock_t *lock);


#line 460 
static void ldv_spin_unlock_bh_84_0(spinlock_t *lock);


#line 464 
static void ldv_spin_unlock_bh_87(spinlock_t *lock);


#line 468 
static void ldv_spin_unlock_bh_89(spinlock_t *lock);


#line 472 
static void ldv_spin_unlock_bh_90(spinlock_t *lock);


#line 476 
static void ldv_spin_unlock_bh_92(spinlock_t *lock);


#line 480 
static void ldv_spin_unlock_bh_94(spinlock_t *lock);


#line 484 
static void ldv_spin_unlock_bh_99(spinlock_t *lock);


#line 488 
static void ldv_spin_unlock_bh_100(spinlock_t *lock);


#line 492 
static void ldv_spin_unlock_bh_101(spinlock_t *lock);


#line 496 
static void ldv_spin_unlock_bh_103(spinlock_t *lock);


#line 500 
static void ldv_spin_unlock_bh_110(spinlock_t *lock);


#line 504 
static void ldv_spin_unlock_bh_112(spinlock_t *lock);


#line 518  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_irqrestore_4(spinlock_t *lock, unsigned long flags)
{
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
  }
  
#line 520 
  _raw_spin_unlock_irqrestore(& lock->__anonCompField_spinlock_18.rlock,flags);
  
#line 521 
  return;
}


#line 550 
static void ldv_spin_unlock_irqrestore_109(spinlock_t *lock, unsigned long flags);


#line 37  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_mutex_lock_104(struct mutex *ldv_func_arg1);


#line 74 
static void ldv___ldv_spin_lock_108(spinlock_t *ldv_func_arg1);


#line 285  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
unsigned int jiffies_to_usecs(unsigned long const);


#line 365 
unsigned long __usecs_to_jiffies(unsigned int const);


#line 367  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
__inline static unsigned long _usecs_to_jiffies(unsigned int const u)
{
  unsigned long __retres;
  
#line 369 
  __retres = (unsigned long)(((long)u + 3999L) / 4000L);
  
#line 369 
  return __retres;
}


#line 408  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
__inline static unsigned long usecs_to_jiffies(unsigned int const u)
{
  unsigned long __retres;
  
#line 410 
  if (0 != 0) {
    unsigned int tmp;
    unsigned long tmp_0;
    
#line 411 
    tmp = jiffies_to_usecs(4611686018427387902UL);
    
#line 411 
    ;
    
#line 411 
    if (tmp < u) {
      
#line 412 
      __retres = 4611686018427387902UL;
      
#line 412 
      goto return_label;
    }
    else ;
    
#line 413 
    tmp_0 = _usecs_to_jiffies(u);
    
#line 413 
    __retres = tmp_0;
    
#line 413 
    goto return_label;
  }
  else {
    unsigned long tmp_1;
    
#line 415 
    tmp_1 = __usecs_to_jiffies(u);
    
#line 415 
    __retres = tmp_1;
    
#line 415 
    goto return_label;
  }
  return_label: 
#line 410 
                return __retres;
}


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timekeeping.h"
void getrawmonotonic64(struct timespec *);


#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timekeeping.h"
__inline static void getrawmonotonic(struct timespec *ts)
{
  
#line 69 
  getrawmonotonic64(ts);
  
#line 70 
  return;
}


#line 193  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
static void ldv_mutex_unlock_105(struct mutex *ldv_func_arg1);


#line 173  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
static int ldv_mod_timer_85(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2);


#line 177 
static int ldv_mod_timer_95(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2);


#line 181 
static int ldv_mod_timer_96(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2);


#line 185 
static int ldv_mod_timer_97(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2);


#line 232 
static int ldv_del_timer_sync_106(struct timer_list *ldv_func_arg1);


#line 444  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
bool cancel_work_sync(struct work_struct *);


#line 3290  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_set_queue_mapping(struct sk_buff *skb, u16 queue_mapping)
{
  
#line 3292 
  skb->queue_mapping = queue_mapping;
  
#line 3293 
  return;
}


#line 4118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct sk_buff *ieee80211_nullfunc_get(struct ieee80211_hw *, struct ieee80211_vif *);


#line 4134 
struct sk_buff *ieee80211_probereq_get(struct ieee80211_hw *, u8 const *, u8 const *, size_t, size_t);


#line 4516 
void ieee80211_scan_completed(struct ieee80211_hw *, bool);


#line 4747 
struct ieee80211_sta *ieee80211_find_sta(struct ieee80211_vif *, u8 const *);


#line 5006 
void ieee80211_ready_on_channel(struct ieee80211_hw *);


#line 5012 
void ieee80211_remain_on_channel_expired(struct ieee80211_hw *);


#line 5261  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
__inline static enum nl80211_iftype ieee80211_iftype_p2p(enum nl80211_iftype type, bool p2p)
{
  enum nl80211_iftype __retres;
  
#line 5263 
  if ((int)p2p != 0) {
    
#line 5264 
    switch ((unsigned int)type) {
      case (unsigned int)2: 
#line 5265 
      ;
      
#line 5266 
      __retres = NL80211_IFTYPE_P2P_CLIENT;
      
#line 5266 
      goto return_label;
      case (unsigned int)3: 
#line 5267 
      ;
      
#line 5268 
      __retres = NL80211_IFTYPE_P2P_GO;
      
#line 5268 
      goto return_label;
      default: 
#line 5269 
      ;
      
#line 5270 
      goto ldv_49415;
    }
    ldv_49415: 
#line 5272 
    ;
  }
  else ;
  
#line 5273 
  __retres = type;
  return_label: 
#line 5273 
                return __retres;
}


#line 5277  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
__inline static enum nl80211_iftype ieee80211_vif_type_p2p(struct ieee80211_vif *vif)
{
  enum nl80211_iftype tmp;
  
#line 5279 
  tmp = ieee80211_iftype_p2p(vif->type,(_Bool)((bool)((int)vif->p2p) != 0));
  
#line 5279 
  return tmp;
}


#line 5322 
bool ieee80211_tx_prepare_skb(struct ieee80211_hw *, struct ieee80211_vif *, struct sk_buff *, int, struct ieee80211_sta **);


#line 5362 
int ieee80211_parse_p2p_noa(struct ieee80211_p2p_noa_attr const *, struct ieee80211_noa_data *, u32);


#line 5371 
void ieee80211_update_p2p_noa(struct ieee80211_noa_data *, u32);


#line 1052  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
u32 ath9k_hw_gettsf32(struct ath_hw *);


#line 1056 
u32 ath9k_hw_get_tsf_offset(struct timespec *, struct timespec *);


#line 1070 
struct ath_gen_timer *ath_gen_timer_alloc(struct ath_hw *, void (*)(void *), void (*)(void *), void *, u8);


#line 1075 
void ath9k_hw_gen_timer_start(struct ath_hw *, struct ath_gen_timer *, u32, u32);


#line 1080 
void ath9k_hw_gen_timer_stop(struct ath_hw *, struct ath_gen_timer *);


#line 1082 
void ath_gen_timer_free(struct ath_hw *, struct ath_gen_timer *);


#line 157  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/common-spectral.h"
void ath9k_cmn_spectral_scan_trigger(struct ath_common *, struct ath_spec_scan_priv *);


#line 434  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
void ath_chanctx_set_channel(struct ath_softc *sc, struct ath_chanctx *ctx, struct cfg80211_chan_def *chandef);


#line 453 
void ath9k_p2p_remove_vif(struct ath_softc *sc, struct ieee80211_vif *vif);


#line 456 
void ath9k_p2p_bss_info_changed(struct ath_softc *sc, struct ieee80211_vif *vif);


#line 460 
void ath9k_p2p_ps_timer(void *priv);


#line 461 
void ath9k_chanctx_wake_queues(struct ath_softc *sc, struct ath_chanctx *ctx);


#line 462 
void ath9k_chanctx_stop_queues(struct ath_softc *sc, struct ath_chanctx *ctx);


#line 463 
void ath_chanctx_check_active(struct ath_softc *sc, struct ath_chanctx *ctx);


#line 471 
void ath_chanctx_set_next(struct ath_softc *sc, bool force);


#line 472 
void ath_offchannel_next(struct ath_softc *sc);


#line 473 
void ath_scan_complete(struct ath_softc *sc, bool abort);


#line 474 
void ath_roc_complete(struct ath_softc *sc, bool abort);


#line 475 
struct ath_chanctx *ath_is_go_chanctx_present(struct ath_softc *sc);


#line 724 
void __ath9k_flush(struct ieee80211_hw *hw, u32 queues, bool drop, bool sw_pending, bool timeout_override);


#line 1075 
int ath_reset(struct ath_softc *sc, struct ath9k_channel *hchan);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
static int ath_set_channel(struct ath_softc *sc)
{
  int __retres;
  struct ath9k_channel *hchan;
  int r;
  int tmp_0;
  
#line 25 
  struct ath_hw *ah = sc->sc_ah;
  
#line 26 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 27 
  struct ieee80211_hw *hw = sc->hw;
  
#line 29 
  struct cfg80211_chan_def *chandef = & (sc->cur_chan)->chandef;
  
#line 30 
  struct ieee80211_channel *chan = chandef->chan;
  
#line 31 
  int pos = (int)chan->hw_value;
  
#line 32 
  int old_pos = -1;
  
#line 35 
  tmp_0 = constant_test_bit(0L,(unsigned long const volatile *)(& common->op_flags));
  
#line 35 
  if (tmp_0 != 0) {
    
#line 36 
    __retres = -5;
    
#line 36 
    goto return_label;
  }
  else ;
  
#line 38 
  if (ah->curchan != (struct ath9k_channel *)0) 
#line 39 
                                                old_pos = (int)(((long)ah->curchan - (long)(& ah->channels[0])) / 16L); else ;
  
#line 41 
  if ((common->debug_mask & 512) != 0) 
#line 41 
                                       ath_printk("\001",(struct ath_common const *)common,"Set channel: %d MHz width: %d\n",(int)chan->center_freq,(unsigned int)chandef->width); else ;
  
#line 45 
  ldv_spin_lock_bh_72_2(& common->cc_lock);
  
#line 46 
  ath_update_survey_stats(sc);
  
#line 47 
  ldv_spin_unlock_bh_73_2(& common->cc_lock);
  
#line 49 
  ath9k_cmn_get_channel(hw,ah,chandef);
  
#line 56 
  if (! (sc->cur_chan)->offchannel && sc->cur_survey != & sc->survey[pos]) {
    
#line 57 
    if (sc->cur_survey != (struct survey_info *)0) 
#line 58 
                                                   (sc->cur_survey)->filled &= 4294967293U; else ;
    
#line 60 
    sc->cur_survey = & sc->survey[pos];
    
#line 62 
    memset((void *)sc->cur_survey,0,64UL);
    
#line 63 
    (sc->cur_survey)->filled |= 2U;
  }
  else 
    
#line 64 
    if ((sc->survey[pos].filled & 2U) == 0U) 
#line 65 
                                             memset((void *)(& sc->survey[pos]),0,64UL); else ;
  
#line 68 
  hchan = & (sc->sc_ah)->channels[pos];
  
#line 69 
  r = ath_reset(sc,hchan);
  
#line 70 
  if (r != 0) {
    
#line 71 
    __retres = r;
    
#line 71 
    goto return_label;
  }
  else ;
  
#line 77 
  if (old_pos >= 0) 
#line 78 
                    ath_update_survey_nf(sc,old_pos); else ;
  
#line 83 
  if ((int)hw->conf.radar_enabled != 0) {
    u32 rxfilter;
    
#line 86 
    rxfilter = ath9k_hw_getrxfilter(ah);
    
#line 87 
    rxfilter |= 8448U;
    
#line 89 
    ath9k_hw_setrxfilter(ah,rxfilter);
    
#line 90 
    if ((common->debug_mask & 65536) != 0) 
#line 90 
                                           ath_printk("\001",(struct ath_common const *)common,"DFS enabled at freq %d\n",(int)chan->center_freq); else ;
  }
  else {
    int tmp_1;
    
#line 94 
    tmp_1 = constant_test_bit(5L,(unsigned long const volatile *)(& common->op_flags));
    
#line 94 
    if (tmp_1 != 0) {
      
#line 94 
      if (sc->spec_priv.spectral_mode == (unsigned int)SPECTRAL_CHANSCAN) 
        
#line 96 
        ath9k_cmn_spectral_scan_trigger(common,& sc->spec_priv); else ;
    }
    else ;
  }
  
#line 99 
  __retres = 0;
  return_label: 
#line 99 
                return __retres;
}


#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
void ath_chanctx_init(struct ath_softc *sc)
{
  struct ath_chanctx *ctx;
  struct ieee80211_supported_band *sband;
  struct ieee80211_channel *chan;
  int i;
  int j;
  
#line 105 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 110 
  sband = & common->sbands[0];
  
#line 111 
  if (sband->n_channels == 0) 
#line 112 
                              sband = & common->sbands[1]; else ;
  
#line 114 
  chan = sband->channels;
  
#line 115 
  i = 0;
  
#line 115 
  goto ldv_53573;
  ldv_53572: 
#line 116 
  ;
  
#line 116 
  ctx = & sc->chanctx[i];
  
#line 117 
  cfg80211_chandef_create(& ctx->chandef,chan,(enum nl80211_channel_type)NL80211_CHAN_HT20);
  
#line 118 
  INIT_LIST_HEAD(& ctx->vifs);
  
#line 119 
  ctx->txpower = (unsigned short)100U;
  
#line 120 
  ctx->flush_timeout = 50;
  
#line 121 
  j = 0;
  
#line 121 
  goto ldv_53570;
  ldv_53569: 
#line 122 
  ;
  
#line 122 
  INIT_LIST_HEAD(& ctx->acq[j]);
  
#line 121 
  j += 1;
  ldv_53570: 
#line 122 
  ;
  
#line 121 
  if ((unsigned int)j <= 3U) 
#line 123 
                             goto ldv_53569; else 
#line 126 
                                                  goto ldv_53571;
  ldv_53571: 
#line 127 
  ;
  
#line 115 
  i += 1;
  ldv_53573: 
#line 116 
  ;
  
#line 115 
  if (i <= 1) 
#line 117 
              goto ldv_53572; else 
#line 120 
                                   goto ldv_53574;
  ldv_53574: 
#line 121 
  ;
  
#line 122 
  return;
}


#line 126  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
void ath_chanctx_set_channel(struct ath_softc *sc, struct ath_chanctx *ctx, struct cfg80211_chan_def *chandef)
{
  bool cur_chan;
  
#line 129 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 132 
  ldv_spin_lock_bh_74_0(& sc->chan_lock);
  
#line 133 
  if (chandef != (struct cfg80211_chan_def *)0) 
#line 134 
                                                memcpy((void *)(& ctx->chandef),(void const *)chandef,24UL); else ;
  
#line 135 
  cur_chan = (_Bool)(sc->cur_chan == ctx);
  
#line 136 
  ldv_spin_unlock_bh_75_0(& sc->chan_lock);
  
#line 138 
  if (! cur_chan) {
    
#line 139 
    if ((common->debug_mask & 262144) != 0) 
#line 139 
                                            ath_printk("\001",(struct ath_common const *)common,"Current context differs from the new context\n"); else ;
    
#line 141 
    goto return_label;
  }
  else ;
  
#line 144 
  ath_set_channel(sc);
  return_label: 
#line 145 
                return;
}


#line 153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
struct ath_chanctx *ath_is_go_chanctx_present(struct ath_softc *sc)
{
  struct ath_chanctx *__retres;
  struct ath_chanctx *ctx;
  struct ath_vif *avp;
  struct ieee80211_vif *vif;
  struct ath_vif *tmp;
  enum nl80211_iftype tmp_0;
  struct ath_vif *tmp_1;
  
#line 159 
  ldv_spin_lock_bh_76(& sc->chan_lock);
  
#line 161 
  ctx = & sc->chanctx[0];
  
#line 161 
  goto ldv_53600;
  ldv_53599: 
#line 162 
  ;
  
#line 162 
  if (! ctx->active) 
#line 163 
                     goto ldv_53591; else ;
  {
    
#line 165 
    struct list_head const *__mptr = (struct list_head const *)ctx->vifs.next;
    
#line 165 
    tmp = (struct ath_vif *)__mptr;
  }
  
#line 165 
  avp = tmp;
  
#line 165 
  goto ldv_53597;
  ldv_53596: 
#line 166 
  ;
  
#line 166 
  vif = avp->vif;
  
#line 168 
  tmp_0 = ieee80211_vif_type_p2p(vif);
  
#line 168 
  if (tmp_0 == (unsigned int)NL80211_IFTYPE_P2P_GO) {
    
#line 169 
    ldv_spin_unlock_bh_77_0(& sc->chan_lock);
    
#line 170 
    __retres = ctx;
    
#line 170 
    goto return_label;
  }
  else ;
  {
    
#line 165 
    struct list_head const *__mptr_0 = (struct list_head const *)avp->list.next;
    
#line 165 
    tmp_1 = (struct ath_vif *)__mptr_0;
  }
  
#line 165 
  avp = tmp_1;
  ldv_53597: 
#line 167 
  ;
  
#line 165 
  if (& avp->list != & ctx->vifs) 
#line 167 
                                  goto ldv_53596; else 
#line 170 
                                                       goto ldv_53598;
  ldv_53598: 
#line 171 
  ;
  ldv_53591: 
#line 172 
  ;
  
#line 161 
  ctx += 1;
  ldv_53600: 
#line 162 
  ;
  
#line 161 
  if (& sc->chanctx[1UL] >= ctx) 
#line 163 
                                 goto ldv_53599; else 
#line 166 
                                                      goto ldv_53601;
  ldv_53601: 
#line 167 
  ;
  
#line 175 
  ldv_spin_unlock_bh_78_0(& sc->chan_lock);
  
#line 176 
  __retres = (struct ath_chanctx *)0;
  return_label: 
#line 176 
                return __retres;
}


#line 183  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
static char const *offchannel_state_string(enum ath_offchannel_state state)
{
  char const *__retres;
  
#line 185 
  switch ((unsigned int)state) {
    case (unsigned int)0: 
#line 186 
    ;
    
#line 186 
    __retres = "ATH_OFFCHANNEL_IDLE";
    
#line 186 
    goto return_label;
    case (unsigned int)1: 
#line 187 
    ;
    
#line 187 
    __retres = "ATH_OFFCHANNEL_PROBE_SEND";
    
#line 187 
    goto return_label;
    case (unsigned int)2: 
#line 188 
    ;
    
#line 188 
    __retres = "ATH_OFFCHANNEL_PROBE_WAIT";
    
#line 188 
    goto return_label;
    case (unsigned int)3: 
#line 189 
    ;
    
#line 189 
    __retres = "ATH_OFFCHANNEL_SUSPEND";
    
#line 189 
    goto return_label;
    case (unsigned int)4: 
#line 190 
    ;
    
#line 190 
    __retres = "ATH_OFFCHANNEL_ROC_START";
    
#line 190 
    goto return_label;
    case (unsigned int)5: 
#line 191 
    ;
    
#line 191 
    __retres = "ATH_OFFCHANNEL_ROC_WAIT";
    
#line 191 
    goto return_label;
    case (unsigned int)6: 
#line 192 
    ;
    
#line 192 
    __retres = "ATH_OFFCHANNEL_ROC_DONE";
    
#line 192 
    goto return_label;
    default: 
#line 193 
    ;
    
#line 194 
    __retres = "unknown";
    
#line 194 
    goto return_label;
  }
  return_label: 
#line 185 
                return __retres;
}


#line 198  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
static char const *chanctx_event_string(enum ath_chanctx_event ev)
{
  char const *__retres;
  
#line 200 
  switch ((unsigned int)ev) {
    case (unsigned int)0: 
#line 201 
    ;
    
#line 201 
    __retres = "ATH_CHANCTX_EVENT_BEACON_PREPARE";
    
#line 201 
    goto return_label;
    case (unsigned int)1: 
#line 202 
    ;
    
#line 202 
    __retres = "ATH_CHANCTX_EVENT_BEACON_SENT";
    
#line 202 
    goto return_label;
    case (unsigned int)2: 
#line 203 
    ;
    
#line 203 
    __retres = "ATH_CHANCTX_EVENT_TSF_TIMER";
    
#line 203 
    goto return_label;
    case (unsigned int)3: 
#line 204 
    ;
    
#line 204 
    __retres = "ATH_CHANCTX_EVENT_BEACON_RECEIVED";
    
#line 204 
    goto return_label;
    case (unsigned int)4: 
#line 205 
    ;
    
#line 205 
    __retres = "ATH_CHANCTX_EVENT_AUTHORIZED";
    
#line 205 
    goto return_label;
    case (unsigned int)5: 
#line 206 
    ;
    
#line 206 
    __retres = "ATH_CHANCTX_EVENT_SWITCH";
    
#line 206 
    goto return_label;
    case (unsigned int)6: 
#line 207 
    ;
    
#line 207 
    __retres = "ATH_CHANCTX_EVENT_ASSIGN";
    
#line 207 
    goto return_label;
    case (unsigned int)7: 
#line 208 
    ;
    
#line 208 
    __retres = "ATH_CHANCTX_EVENT_UNASSIGN";
    
#line 208 
    goto return_label;
    case (unsigned int)8: 
#line 209 
    ;
    
#line 209 
    __retres = "ATH_CHANCTX_EVENT_CHANGE";
    
#line 209 
    goto return_label;
    case (unsigned int)9: 
#line 210 
    ;
    
#line 210 
    __retres = "ATH_CHANCTX_EVENT_ENABLE_MULTICHANNEL";
    
#line 210 
    goto return_label;
    default: 
#line 211 
    ;
    
#line 212 
    __retres = "unknown";
    
#line 212 
    goto return_label;
  }
  return_label: 
#line 200 
                return __retres;
}


#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
static char const *chanctx_state_string(enum ath_chanctx_state state)
{
  char const *__retres;
  
#line 218 
  switch ((unsigned int)state) {
    case (unsigned int)0: 
#line 219 
    ;
    
#line 219 
    __retres = "ATH_CHANCTX_STATE_IDLE";
    
#line 219 
    goto return_label;
    case (unsigned int)1: 
#line 220 
    ;
    
#line 220 
    __retres = "ATH_CHANCTX_STATE_WAIT_FOR_BEACON";
    
#line 220 
    goto return_label;
    case (unsigned int)2: 
#line 221 
    ;
    
#line 221 
    __retres = "ATH_CHANCTX_STATE_WAIT_FOR_TIMER";
    
#line 221 
    goto return_label;
    case (unsigned int)3: 
#line 222 
    ;
    
#line 222 
    __retres = "ATH_CHANCTX_STATE_SWITCH";
    
#line 222 
    goto return_label;
    case (unsigned int)4: 
#line 223 
    ;
    
#line 223 
    __retres = "ATH_CHANCTX_STATE_FORCE_ACTIVE";
    
#line 223 
    goto return_label;
    default: 
#line 224 
    ;
    
#line 225 
    __retres = "unknown";
    
#line 225 
    goto return_label;
  }
  return_label: 
#line 218 
                return __retres;
}


#line 229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
void ath_chanctx_check_active(struct ath_softc *sc, struct ath_chanctx *ctx)
{
  struct ath_chanctx *ictx;
  struct ath_vif *avp;
  struct ath_vif *tmp_2;
  struct ath_vif *tmp_3;
  unsigned long tmp_5;
  int tmp_6;
  bool tmp_7;
  
#line 231 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 234 
  bool active = (_Bool)0;
  
#line 235 
  u8 n_active = (unsigned char)0U;
  
#line 237 
  if (ctx == (struct ath_chanctx *)0) 
#line 238 
                                      goto return_label; else ;
  
#line 240 
  if (& sc->offchannel.chan == ctx) {
    
#line 241 
    ldv_spin_lock_bh_79(& sc->chan_lock);
    
#line 243 
    if ((long)(sc->sched.channel_switch_time != 0U) != 0L) {
      unsigned long tmp_0;
      
#line 244 
      tmp_0 = usecs_to_jiffies(sc->sched.channel_switch_time);
      
#line 244 
      ctx->flush_timeout = (int)tmp_0;
    }
    else {
      unsigned long tmp_1;
      
#line 247 
      tmp_1 = msecs_to_jiffies(10U);
      
#line 247 
      ctx->flush_timeout = (int)tmp_1;
    }
    
#line 250 
    ldv_spin_unlock_bh_80(& sc->chan_lock);
    
#line 257 
    goto return_label;
  }
  else ;
  
#line 260 
  ictx = ctx;
  {
    
#line 262 
    struct list_head const *__mptr = (struct list_head const *)ctx->vifs.next;
    
#line 262 
    tmp_2 = (struct ath_vif *)__mptr;
  }
  
#line 262 
  avp = tmp_2;
  
#line 262 
  goto ldv_53655;
  ldv_53654: 
#line 263 
  ;
  {
    
#line 263 
    struct ieee80211_vif *vif = avp->vif;
    
#line 265 
    switch ((unsigned int)vif->type) {
      case (unsigned int)8: 
#line 266 
      ;
      case (unsigned int)2: 
#line 267 
      ;
      
#line 268 
      if ((int)avp->assoc != 0) 
#line 269 
                                active = (_Bool)1; else ;
      
#line 270 
      goto ldv_53652;
      default: 
#line 271 
      ;
      
#line 272 
      active = (_Bool)1;
      
#line 273 
      goto ldv_53652;
    }
    ldv_53652: 
#line 275 
    ;
  }
  {
    
#line 262 
    struct list_head const *__mptr_0 = (struct list_head const *)avp->list.next;
    
#line 262 
    tmp_3 = (struct ath_vif *)__mptr_0;
  }
  
#line 262 
  avp = tmp_3;
  ldv_53655: 
#line 264 
  ;
  
#line 262 
  if (& avp->list != & ctx->vifs) 
#line 264 
                                  goto ldv_53654; else 
#line 267 
                                                       goto ldv_53656;
  ldv_53656: 
#line 268 
  ;
  
#line 276 
  ctx->active = active;
  
#line 278 
  ctx = & sc->chanctx[0];
  
#line 278 
  goto ldv_53662;
  ldv_53661: 
#line 279 
  ;
  
#line 279 
  if (! ctx->assigned) 
#line 279 
                       goto _LOR;
  else {
    int tmp_4;
    
#line 279 
    tmp_4 = list_empty((struct list_head const *)(& ctx->vifs));
    
#line 279 
    if (tmp_4 != 0) _LOR: 
#line 280 
                          goto ldv_53660; else ;
  }
  
#line 281 
  n_active = (u8)((int)n_active + 1);
  ldv_53660: 
#line 282 
  ;
  
#line 278 
  ctx += 1;
  ldv_53662: 
#line 279 
  ;
  
#line 278 
  if (& sc->chanctx[1UL] >= ctx) 
#line 280 
                                 goto ldv_53661; else 
#line 283 
                                                      goto ldv_53663;
  ldv_53663: 
#line 284 
  ;
  
#line 284 
  ldv_spin_lock_bh_81(& sc->chan_lock);
  
#line 286 
  if ((unsigned int)n_active <= 1U) {
    
#line 287 
    ictx->flush_timeout = 50;
    
#line 288 
    set_bit(6L,(unsigned long volatile *)(& common->op_flags));
    
#line 289 
    ldv_spin_unlock_bh_82_0(& sc->chan_lock);
    
#line 290 
    goto return_label;
  }
  else ;
  
#line 293 
  tmp_5 = usecs_to_jiffies(sc->sched.channel_switch_time);
  
#line 293 
  ictx->flush_timeout = (int)tmp_5;
  
#line 295 
  tmp_6 = test_and_set_bit(6L,(unsigned long volatile *)(& common->op_flags));
  
#line 295 
  if (tmp_6 != 0) {
    
#line 296 
    ldv_spin_unlock_bh_83(& sc->chan_lock);
    
#line 297 
    goto return_label;
  }
  else ;
  
#line 300 
  ldv_spin_unlock_bh_84_0(& sc->chan_lock);
  
#line 302 
  tmp_7 = ath9k_is_chanctx_enabled();
  
#line 302 
  if ((int)tmp_7 != 0) 
#line 303 
                       ath_chanctx_event(sc,(struct ieee80211_vif *)0,(enum ath_chanctx_event)ATH_CHANCTX_EVENT_ENABLE_MULTICHANNEL); else ;
  return_label: 
#line 304 
                return;
}


#line 309  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
static struct ath_chanctx *ath_chanctx_get_next(struct ath_softc *sc, struct ath_chanctx *ctx)
{
  struct ath_chanctx *__retres;
  
#line 311 
  int idx = (int)(((long)ctx - (long)(& sc->chanctx[0])) / 992L);
  
#line 313 
  __retres = & sc->chanctx[idx == 0];
  
#line 313 
  return __retres;
}


#line 316  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
static void ath_chanctx_adjust_tbtt_delta(struct ath_softc *sc)
{
  struct ath_chanctx *prev;
  struct ath_chanctx *cur;
  struct timespec ts;
  u32 cur_tsf;
  u32 prev_tsf;
  u32 beacon_int;
  s32 offset;
  u32 tmp;
  u32 tmp_0;
  
#line 323 
  beacon_int = (unsigned int)((sc->cur_chan)->beacon.beacon_interval << 10);
  
#line 325 
  cur = sc->cur_chan;
  
#line 326 
  prev = ath_chanctx_get_next(sc,cur);
  
#line 328 
  if (! prev->switch_after_beacon) 
#line 329 
                                   goto return_label; else ;
  
#line 331 
  getrawmonotonic(& ts);
  
#line 333 
  tmp = ath9k_hw_get_tsf_offset(& cur->tsf_ts,& ts);
  
#line 332 
  cur_tsf = (unsigned int)cur->tsf_val + tmp;
  
#line 335 
  prev_tsf = (prev->last_beacon - (unsigned int)prev->tsf_val) + cur_tsf;
  
#line 336 
  tmp_0 = ath9k_hw_get_tsf_offset(& prev->tsf_ts,& ts);
  
#line 336 
  prev_tsf -= tmp_0;
  
#line 341 
  offset = (int)(cur_tsf - prev_tsf);
  
#line 344 
  if (offset < 0 || beacon_int * 3U < (unsigned int)offset) 
#line 345 
                                                            goto return_label; else ;
  
#line 347 
  offset = (int)(beacon_int / 2U - (unsigned int)offset % beacon_int);
  
#line 348 
  prev->tsf_val += (unsigned long long)offset;
  return_label: 
#line 349 
                return;
}


#line 355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
static void ath_chanctx_setup_timer(struct ath_softc *sc, u32 tsf_time)
{
  u32 tmp_0;
  unsigned long tmp_1;
  
#line 357 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 358 
  struct ath_hw *ah = sc->sc_ah;
  
#line 360 
  ath9k_hw_gen_timer_start(ah,sc->p2p_ps_timer,tsf_time,1000000U);
  
#line 361 
  tmp_0 = ath9k_hw_gettsf32(ah);
  
#line 361 
  tsf_time -= tmp_0;
  
#line 362 
  tmp_1 = msecs_to_jiffies(tsf_time / 1000U);
  
#line 362 
  tsf_time = (unsigned int)tmp_1 + 1U;
  
#line 363 
  ldv_mod_timer_85(& sc->sched.timer,(unsigned long)tsf_time + jiffies);
  
#line 365 
  if ((common->debug_mask & 262144) != 0) {
    unsigned int tmp_2;
    
#line 365 
    tmp_2 = jiffies_to_msecs((unsigned long)tsf_time);
    
#line 365 
    ;
    
#line 365 
    ath_printk("\001",(struct ath_common const *)common,"Setup chanctx timer with timeout: %d ms\n",tmp_2);
  }
  else ;
  
#line 366 
  return;
}


#line 369  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
static void ath_chanctx_handle_bmiss(struct ath_softc *sc, struct ath_chanctx *ctx, struct ath_vif *avp)
{
  
#line 379 
  if ((int)ctx->active != 0 && (int)sc->sched.extend_absence != 0) {
    
#line 380 
    avp->noa_duration = 0U;
    
#line 381 
    sc->sched.extend_absence = (_Bool)0;
  }
  else ;
  
#line 388 
  if ((int)ctx->active != 0 && (unsigned int)sc->sched.beacon_miss > 1U) {
    
#line 389 
    avp->noa_duration = 0U;
    
#line 390 
    sc->sched.extend_absence = (_Bool)1;
  }
  else ;
  
#line 392 
  return;
}


#line 394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
static void ath_chanctx_offchannel_noa(struct ath_softc *sc, struct ath_chanctx *ctx, struct ath_vif *avp, u32 tsf_time)
{
  
#line 399 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 401 
  avp->noa_index = (u8)((int)avp->noa_index + 1);
  
#line 402 
  avp->offchannel_start = tsf_time;
  
#line 403 
  avp->offchannel_duration = sc->sched.offchannel_duration;
  
#line 405 
  if ((common->debug_mask & 262144) != 0) 
#line 405 
                                          ath_printk("\001",(struct ath_common const *)common,"offchannel noa_duration: %d, noa_start: %d, noa_index: %d\n",avp->offchannel_duration,avp->offchannel_start,(int)avp->noa_index); else ;
  
#line 416 
  if ((int)ctx->active != 0 && avp->noa_duration != 0U) 
#line 417 
                                                        avp->noa_duration = 0U; else ;
  
#line 418 
  return;
}


#line 420  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
static void ath_chanctx_set_periodic_noa(struct ath_softc *sc, struct ath_vif *avp, struct ath_beacon_config *cur_conf, u32 tsf_time, u32 beacon_int)
{
  int tmp_0;
  
#line 426 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 428 
  avp->noa_index = (u8)((int)avp->noa_index + 1);
  
#line 429 
  avp->noa_start = tsf_time;
  
#line 431 
  if ((int)sc->sched.extend_absence != 0) 
#line 432 
                                          avp->noa_duration = (beacon_int * 3U) / 2U + sc->sched.channel_switch_time; else 
                                                                    
#line 435 
                                                                    avp->noa_duration = (unsigned int)((cur_conf->beacon_interval << 10) / 2) + sc->sched.channel_switch_time;
  
#line 439 
  tmp_0 = constant_test_bit(5L,(unsigned long const volatile *)(& common->op_flags));
  
#line 439 
  if (tmp_0 != 0) 
#line 439 
                  goto _LOR;
  else 
    
#line 439 
    if ((int)sc->sched.extend_absence != 0) _LOR: 
#line 441 
                                                  avp->periodic_noa = (_Bool)0; else 
                                                                    
#line 443 
                                                                    avp->periodic_noa = (_Bool)1;
  
#line 445 
  if ((common->debug_mask & 262144) != 0) 
#line 445 
                                          ath_printk("\001",(struct ath_common const *)common,"noa_duration: %d, noa_start: %d, noa_index: %d, periodic: %d\n",avp->noa_duration,avp->noa_start,(int)avp->noa_index,(int)avp->periodic_noa); else ;
  
#line 446 
  return;
}


#line 453  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
static void ath_chanctx_set_oneshot_noa(struct ath_softc *sc, struct ath_vif *avp, u32 tsf_time, u32 duration)
{
  
#line 458 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 460 
  avp->noa_index = (u8)((int)avp->noa_index + 1);
  
#line 461 
  avp->noa_start = tsf_time;
  
#line 462 
  avp->periodic_noa = (_Bool)0;
  
#line 463 
  avp->oneshot_noa = (_Bool)1;
  
#line 464 
  avp->noa_duration = sc->sched.channel_switch_time + duration;
  
#line 466 
  if ((common->debug_mask & 262144) != 0) 
#line 466 
                                          ath_printk("\001",(struct ath_common const *)common,"oneshot noa_duration: %d, noa_start: %d, noa_index: %d, periodic: %d\n",avp->noa_duration,avp->noa_start,(int)avp->noa_index,(int)avp->periodic_noa); else ;
  
#line 467 
  return;
}


#line 474  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
void ath_chanctx_event(struct ath_softc *sc, struct ieee80211_vif *vif, enum ath_chanctx_event ev)
{
  struct ath_beacon_config *cur_conf;
  struct ath_chanctx *ctx;
  u32 tsf_time;
  u32 beacon_int;
  
#line 477 
  struct ath_hw *ah = sc->sc_ah;
  
#line 478 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 480 
  struct ath_vif *avp = (struct ath_vif *)0;
  
#line 485 
  if (vif != (struct ieee80211_vif *)0) 
#line 486 
                                        avp = (struct ath_vif *)(& vif->drv_priv); else ;
  
#line 488 
  ldv_spin_lock_bh_86(& sc->chan_lock);
  
#line 490 
  if ((common->debug_mask & 262144) != 0) {
    char const *tmp_0;
    char const *tmp_1;
    
#line 490 
    tmp_0 = chanctx_state_string(sc->sched.state);
    
#line 490 
    tmp_1 = chanctx_event_string(ev);
    
#line 490 
    ;
    
#line 490 
    ;
    
#line 490 
    ath_printk("\001",(struct ath_common const *)common,"cur_chan: %d MHz, event: %s, state: %s\n",(sc->cur_chan)->chandef.center_freq1,tmp_1,tmp_0);
  }
  else ;
  
#line 495 
  switch ((unsigned int)ev) {
    int tmp_3;
    u32 tmp_4;
    u32 tmp_5;
    int tmp_6;
    u32 tmp_7;
    case (unsigned int)0: 
#line 496 
    ;
    
#line 497 
    if (avp->offchannel_duration != 0U) 
#line 498 
                                        avp->offchannel_duration = 0U; else ;
    
#line 500 
    if ((int)avp->oneshot_noa != 0) {
      
#line 501 
      avp->noa_duration = 0U;
      
#line 502 
      avp->oneshot_noa = (_Bool)0;
      
#line 504 
      if ((common->debug_mask & 262144) != 0) 
#line 504 
                                              ath_printk("\001",(struct ath_common const *)common,"Clearing oneshot NoA\n"); else ;
    }
    else ;
    
#line 508 
    if (avp->chanctx != sc->cur_chan) {
      
#line 509 
      if ((common->debug_mask & 262144) != 0) 
#line 509 
                                              ath_printk("\001",(struct ath_common const *)common,"Contexts differ, not preparing beacon\n"); else ;
      
#line 511 
      goto ldv_53725;
    }
    else ;
    
#line 514 
    if ((int)sc->sched.offchannel_pending != 0 && ! sc->sched.wait_switch) {
      
#line 515 
      sc->sched.offchannel_pending = (_Bool)0;
      
#line 516 
      sc->next_chan = & sc->offchannel.chan;
      
#line 517 
      sc->sched.state = ATH_CHANCTX_STATE_WAIT_FOR_BEACON;
      
#line 518 
      if ((common->debug_mask & 262144) != 0) 
#line 518 
                                              ath_printk("\001",(struct ath_common const *)common,"Setting offchannel_pending to false\n"); else ;
    }
    else ;
    
#line 522 
    ctx = ath_chanctx_get_next(sc,sc->cur_chan);
    
#line 523 
    if ((int)ctx->active != 0 && sc->sched.state == (unsigned int)ATH_CHANCTX_STATE_IDLE) {
      
#line 524 
      sc->next_chan = ctx;
      
#line 525 
      sc->sched.state = ATH_CHANCTX_STATE_WAIT_FOR_BEACON;
      
#line 526 
      if ((common->debug_mask & 262144) != 0) 
#line 526 
                                              ath_printk("\001",(struct ath_common const *)common,"Set next context, move chanctx state to WAIT_FOR_BEACON\n"); else ;
    }
    else ;
    
#line 531 
    if (sc->sched.state == (unsigned int)ATH_CHANCTX_STATE_WAIT_FOR_TIMER) {
      
#line 532 
      sc->sched.state = ATH_CHANCTX_STATE_WAIT_FOR_BEACON;
      
#line 533 
      if ((common->debug_mask & 262144) != 0) 
#line 533 
                                              ath_printk("\001",(struct ath_common const *)common,"Move chanctx state from WAIT_FOR_TIMER to WAIT_FOR_BEACON\n"); else ;
    }
    else ;
    
#line 537 
    if ((int)sc->sched.mgd_prepare_tx != 0) 
#line 538 
                                            sc->sched.state = ATH_CHANCTX_STATE_WAIT_FOR_BEACON; else ;
    
#line 546 
    if ((! ctx->active && avp->noa_duration != 0U) && sc->sched.state != (unsigned int)ATH_CHANCTX_STATE_WAIT_FOR_BEACON) {
      
#line 548 
      avp->noa_duration = 0U;
      
#line 549 
      avp->periodic_noa = (_Bool)0;
      
#line 551 
      if ((common->debug_mask & 262144) != 0) 
#line 551 
                                              ath_printk("\001",(struct ath_common const *)common,"Clearing NoA schedule\n"); else ;
    }
    else ;
    
#line 555 
    if (sc->sched.state != (unsigned int)ATH_CHANCTX_STATE_WAIT_FOR_BEACON) 
      
#line 556 
      goto ldv_53725; else ;
    
#line 558 
    if ((common->debug_mask & 262144) != 0) 
#line 558 
                                            ath_printk("\001",(struct ath_common const *)common,"Preparing beacon for vif: %pM\n",(u8 *)(& vif->addr)); else ;
    
#line 560 
    sc->sched.beacon_pending = (_Bool)1;
    
#line 561 
    sc->sched.next_tbtt = (*(ah->reg_ops.read))((void *)ah,33280U);
    
#line 563 
    cur_conf = & (sc->cur_chan)->beacon;
    
#line 564 
    beacon_int = (unsigned int)(cur_conf->beacon_interval << 10);
    
#line 567 
    tsf_time = sc->sched.next_tbtt + beacon_int / 4U;
    
#line 568 
    sc->sched.switch_start_time = tsf_time;
    
#line 569 
    (sc->cur_chan)->last_beacon = sc->sched.next_tbtt;
    
#line 576 
    if (sc->next_chan == & sc->offchannel.chan) {
      
#line 577 
      ath_chanctx_offchannel_noa(sc,ctx,avp,tsf_time);
      
#line 578 
      goto ldv_53725;
    }
    else ;
    
#line 581 
    ath_chanctx_handle_bmiss(sc,ctx,avp);
    
#line 589 
    if ((int)sc->sched.mgd_prepare_tx != 0) {
      unsigned int tmp_2;
      
#line 590 
      tmp_2 = jiffies_to_usecs(50UL);
      
#line 590 
      ;
      
#line 590 
      ;
      
#line 590 
      ;
      
#line 590 
      ath_chanctx_set_oneshot_noa(sc,avp,tsf_time,tmp_2);
      
#line 592 
      goto ldv_53725;
    }
    else ;
    
#line 596 
    if (avp->noa_duration != 0U && tsf_time - avp->noa_start > 1073741824U) 
      
#line 597 
      avp->noa_duration = 0U; else ;
    
#line 604 
    if ((int)ctx->active != 0 && (avp->noa_duration == 0U || (int)sc->sched.force_noa_update != 0)) 
      
#line 606 
      ath_chanctx_set_periodic_noa(sc,avp,cur_conf,tsf_time,beacon_int); else ;
    
#line 609 
    if ((int)ctx->active != 0 && (int)sc->sched.force_noa_update != 0) 
      
#line 610 
      sc->sched.force_noa_update = (_Bool)0; else ;
    
#line 612 
    goto ldv_53725;
    case (unsigned int)1: 
#line 613 
    ;
    
#line 614 
    if (! sc->sched.beacon_pending) {
      
#line 615 
      if ((common->debug_mask & 262144) != 0) 
#line 615 
                                              ath_printk("\001",(struct ath_common const *)common,"No pending beacon\n"); else ;
      
#line 617 
      goto ldv_53725;
    }
    else ;
    
#line 620 
    sc->sched.beacon_pending = (_Bool)0;
    
#line 622 
    if ((int)sc->sched.mgd_prepare_tx != 0) {
      
#line 623 
      sc->sched.mgd_prepare_tx = (_Bool)0;
      
#line 624 
      complete(& sc->go_beacon);
      
#line 625 
      if ((common->debug_mask & 262144) != 0) 
#line 625 
                                              ath_printk("\001",(struct ath_common const *)common,"Beacon sent, complete go_beacon\n"); else ;
      
#line 627 
      goto ldv_53725;
    }
    else ;
    
#line 630 
    if (sc->sched.state != (unsigned int)ATH_CHANCTX_STATE_WAIT_FOR_BEACON) 
      
#line 631 
      goto ldv_53725; else ;
    
#line 633 
    if ((common->debug_mask & 262144) != 0) 
#line 633 
                                            ath_printk("\001",(struct ath_common const *)common,"Move chanctx state to WAIT_FOR_TIMER\n"); else ;
    
#line 636 
    sc->sched.state = ATH_CHANCTX_STATE_WAIT_FOR_TIMER;
    
#line 637 
    ath_chanctx_setup_timer(sc,sc->sched.switch_start_time);
    
#line 638 
    goto ldv_53725;
    case (unsigned int)2: 
#line 639 
    ;
    
#line 640 
    if (sc->sched.state != (unsigned int)ATH_CHANCTX_STATE_WAIT_FOR_TIMER) 
      
#line 641 
      goto ldv_53725; else ;
    
#line 643 
    if (! (sc->cur_chan)->switch_after_beacon && (int)sc->sched.beacon_pending != 0) 
      
#line 645 
      sc->sched.beacon_miss = (u8)((int)sc->sched.beacon_miss + 1); else ;
    
#line 647 
    if ((common->debug_mask & 262144) != 0) 
#line 647 
                                            ath_printk("\001",(struct ath_common const *)common,"Move chanctx state to SWITCH\n"); else ;
    
#line 650 
    sc->sched.state = ATH_CHANCTX_STATE_SWITCH;
    
#line 651 
    ieee80211_queue_work(sc->hw,& sc->chanctx_work);
    
#line 652 
    goto ldv_53725;
    case (unsigned int)3: 
#line 653 
    ;
    
#line 654 
    tmp_3 = constant_test_bit(6L,(unsigned long const volatile *)(& common->op_flags));
    
#line 654 
    if (tmp_3 == 0) 
#line 656 
                    goto ldv_53725;
    else 
      
#line 654 
      if (sc->cur_chan == & sc->offchannel.chan) 
#line 656 
                                                 goto ldv_53725; else ;
    
#line 658 
    sc->sched.beacon_pending = (_Bool)0;
    
#line 659 
    sc->sched.beacon_miss = (unsigned char)0U;
    
#line 661 
    if ((sc->sched.state == (unsigned int)ATH_CHANCTX_STATE_FORCE_ACTIVE || ! sc->sched.beacon_adjust) || (sc->cur_chan)->tsf_val == 0ULL) 
      
#line 664 
      goto ldv_53725; else ;
    
#line 666 
    ath_chanctx_adjust_tbtt_delta(sc);
    
#line 671 
    tsf_time = sc->sched.switch_start_time;
    
#line 673 
    tmp_4 = ath9k_hw_get_tsf_offset(& (sc->cur_chan)->tsf_ts,(struct timespec *)0);
    
#line 673 
    tsf_time -= (unsigned int)(sc->cur_chan)->tsf_val + tmp_4;
    
#line 674 
    tmp_5 = ath9k_hw_gettsf32(ah);
    
#line 674 
    tsf_time = tmp_5 + tsf_time;
    
#line 676 
    sc->sched.beacon_adjust = (_Bool)0;
    
#line 677 
    ath_chanctx_setup_timer(sc,tsf_time);
    
#line 678 
    goto ldv_53725;
    case (unsigned int)4: 
#line 679 
    ;
    
#line 680 
    if (sc->sched.state != (unsigned int)ATH_CHANCTX_STATE_FORCE_ACTIVE || avp->chanctx != sc->cur_chan) 
      
#line 682 
      goto ldv_53725; else ;
    
#line 684 
    if ((common->debug_mask & 262144) != 0) 
#line 684 
                                            ath_printk("\001",(struct ath_common const *)common,"Move chanctx state from FORCE_ACTIVE to IDLE\n"); else ;
    
#line 687 
    sc->sched.state = ATH_CHANCTX_STATE_IDLE;
    case (unsigned int)5: 
#line 689 
    ;
    
#line 690 
    tmp_6 = constant_test_bit(6L,(unsigned long const volatile *)(& common->op_flags));
    
#line 690 
    if (tmp_6 == 0) 
#line 694 
                    goto ldv_53725;
    else 
      
#line 690 
      if (sc->sched.state == (unsigned int)ATH_CHANCTX_STATE_FORCE_ACTIVE) 
        
#line 694 
        goto ldv_53725;
      else 
        
#line 691 
        if ((int)(sc->cur_chan)->switch_after_beacon != 0) 
#line 694 
                                                           goto ldv_53725;
        else 
          
#line 692 
          if (sc->cur_chan == & sc->offchannel.chan) 
#line 694 
                                                     goto ldv_53725; else ;
    
#line 699 
    sc->next_chan = ath_chanctx_get_next(sc,sc->cur_chan);
    
#line 700 
    cur_conf = & (sc->cur_chan)->beacon;
    
#line 702 
    if ((common->debug_mask & 262144) != 0) 
#line 702 
                                            ath_printk("\001",(struct ath_common const *)common,"Move chanctx state to WAIT_FOR_TIMER (event SWITCH)\n"); else ;
    
#line 705 
    sc->sched.state = ATH_CHANCTX_STATE_WAIT_FOR_TIMER;
    
#line 706 
    sc->sched.wait_switch = (_Bool)0;
    
#line 708 
    tsf_time = (unsigned int)((cur_conf->beacon_interval << 10) / 2);
    
#line 710 
    if ((int)sc->sched.extend_absence != 0) {
      
#line 711 
      sc->sched.beacon_miss = (unsigned char)0U;
      
#line 712 
      tsf_time *= 3U;
    }
    else ;
    
#line 715 
    tsf_time -= sc->sched.channel_switch_time;
    
#line 716 
    tmp_7 = ath9k_hw_gettsf32(sc->sc_ah);
    
#line 716 
    tsf_time = tmp_7 + tsf_time;
    
#line 717 
    sc->sched.switch_start_time = tsf_time;
    
#line 719 
    ath_chanctx_setup_timer(sc,tsf_time);
    
#line 720 
    sc->sched.beacon_pending = (_Bool)1;
    
#line 721 
    sc->sched.beacon_adjust = (_Bool)1;
    
#line 722 
    goto ldv_53725;
    case (unsigned int)9: 
#line 723 
    ;
    
#line 724 
    if (sc->cur_chan == & sc->offchannel.chan || (int)(sc->cur_chan)->switch_after_beacon != 0) 
      
#line 726 
      goto ldv_53725; else ;
    
#line 728 
    sc->next_chan = ath_chanctx_get_next(sc,sc->cur_chan);
    
#line 729 
    ieee80211_queue_work(sc->hw,& sc->chanctx_work);
    
#line 730 
    goto ldv_53725;
    case (unsigned int)7: 
#line 731 
    ;
    
#line 732 
    if ((int)(sc->cur_chan)->assigned != 0) {
      
#line 733 
      if ((sc->next_chan != (struct ath_chanctx *)0 && ! (sc->next_chan)->assigned) && sc->next_chan != & sc->offchannel.chan) 
        
#line 735 
        sc->sched.state = ATH_CHANCTX_STATE_IDLE; else ;
      
#line 736 
      goto ldv_53725;
    }
    else ;
    
#line 739 
    ctx = ath_chanctx_get_next(sc,sc->cur_chan);
    
#line 740 
    sc->sched.state = ATH_CHANCTX_STATE_IDLE;
    
#line 741 
    if (! ctx->assigned) 
#line 742 
                         goto ldv_53725; else ;
    
#line 744 
    sc->next_chan = ctx;
    
#line 745 
    ieee80211_queue_work(sc->hw,& sc->chanctx_work);
    
#line 746 
    goto ldv_53725;
    case (unsigned int)6: 
#line 747 
    ;
    
#line 748 
    goto ldv_53725;
    case (unsigned int)8: 
#line 749 
    ;
    
#line 750 
    goto ldv_53725;
  }
  ldv_53725: 
#line 753 
  ;
  
#line 753 
  ldv_spin_unlock_bh_87(& sc->chan_lock);
  
#line 754 
  return;
}


#line 756  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
void ath_chanctx_beacon_sent_ev(struct ath_softc *sc, enum ath_chanctx_event ev)
{
  
#line 759 
  if ((int)sc->sched.beacon_pending != 0) 
#line 760 
                                          ath_chanctx_event(sc,(struct ieee80211_vif *)0,ev); else ;
  
#line 761 
  return;
}


#line 763  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
void ath_chanctx_beacon_recv_ev(struct ath_softc *sc, enum ath_chanctx_event ev)
{
  
#line 766 
  ath_chanctx_event(sc,(struct ieee80211_vif *)0,ev);
  
#line 767 
  return;
}


#line 769  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
static int ath_scan_channel_duration(struct ath_softc *sc, struct ieee80211_channel *chan)
{
  int __retres;
  
#line 772 
  struct cfg80211_scan_request *req = sc->offchannel.scan_req;
  
#line 774 
  if (req->n_ssids == 0 || (chan->flags & 2U) != 0U) {
    
#line 775 
    __retres = 27;
    
#line 775 
    goto return_label;
  }
  else ;
  
#line 777 
  __retres = 15;
  return_label: 
#line 777 
                return __retres;
}


#line 780  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
static void ath_chanctx_switch(struct ath_softc *sc, struct ath_chanctx *ctx, struct cfg80211_chan_def *chandef)
{
  int tmp_1;
  
#line 783 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 785 
  ldv_spin_lock_bh_88(& sc->chan_lock);
  
#line 787 
  tmp_1 = constant_test_bit(6L,(unsigned long const volatile *)(& common->op_flags));
  
#line 787 
  if (tmp_1 != 0) {
    
#line 787 
    if (sc->cur_chan != ctx) {
      
#line 788 
      if (& sc->offchannel.chan == ctx) {
        unsigned int tmp_0;
        
#line 789 
        if (chandef != (struct cfg80211_chan_def *)0) 
#line 790 
                                                      ctx->chandef = *chandef; else ;
        
#line 792 
        sc->sched.offchannel_pending = (_Bool)1;
        
#line 793 
        sc->sched.wait_switch = (_Bool)1;
        
#line 794 
        tmp_0 = jiffies_to_usecs((unsigned long)sc->offchannel.duration);
        
#line 794 
        sc->sched.offchannel_duration = tmp_0 + sc->sched.channel_switch_time;
        
#line 798 
        ldv_spin_unlock_bh_89(& sc->chan_lock);
        
#line 799 
        if ((common->debug_mask & 262144) != 0) 
#line 799 
                                                ath_printk("\001",(struct ath_common const *)common,"Set offchannel_pending to true\n"); else ;
        
#line 801 
        goto return_label;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 804 
  sc->next_chan = ctx;
  
#line 805 
  if (chandef != (struct cfg80211_chan_def *)0) {
    
#line 806 
    ctx->chandef = *chandef;
    
#line 807 
    if ((common->debug_mask & 262144) != 0) 
#line 807 
                                            ath_printk("\001",(struct ath_common const *)common,"Assigned next_chan to %d MHz\n",chandef->center_freq1); else ;
  }
  else ;
  
#line 811 
  if (sc->next_chan == & sc->offchannel.chan) {
    unsigned int tmp_2;
    
#line 812 
    tmp_2 = jiffies_to_usecs((unsigned long)sc->offchannel.duration);
    
#line 812 
    sc->sched.offchannel_duration = tmp_2 + sc->sched.channel_switch_time;
    
#line 816 
    if (chandef != (struct cfg80211_chan_def *)0) {
      
#line 817 
      if ((common->debug_mask & 262144) != 0) 
#line 817 
                                              ath_printk("\001",(struct ath_common const *)common,"Offchannel duration for chan %d MHz : %u\n",chandef->center_freq1,sc->sched.offchannel_duration); else ;
    }
    else ;
  }
  else ;
  
#line 823 
  ldv_spin_unlock_bh_90(& sc->chan_lock);
  
#line 824 
  ieee80211_queue_work(sc->hw,& sc->chanctx_work);
  return_label: 
#line 825 
                return;
}


#line 827  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
static void ath_chanctx_offchan_switch(struct ath_softc *sc, struct ieee80211_channel *chan)
{
  struct cfg80211_chan_def chandef;
  
#line 830 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 833 
  cfg80211_chandef_create(& chandef,chan,(enum nl80211_channel_type)NL80211_CHAN_NO_HT);
  
#line 834 
  if ((common->debug_mask & 262144) != 0) 
#line 834 
                                          ath_printk("\001",(struct ath_common const *)common,"Channel definition created: %d MHz\n",chandef.center_freq1); else ;
  
#line 837 
  ath_chanctx_switch(sc,& sc->offchannel.chan,& chandef);
  
#line 838 
  return;
}


#line 840  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
static struct ath_chanctx *ath_chanctx_get_oper_chan(struct ath_softc *sc, bool active)
{
  struct ath_chanctx *__retres;
  struct ath_chanctx *ctx;
  
#line 845 
  ctx = & sc->chanctx[0];
  
#line 845 
  goto ldv_53770;
  ldv_53769: 
#line 846 
  ;
  
#line 846 
  if (! ctx->assigned) 
#line 846 
                       goto _LOR;
  else {
    int tmp;
    
#line 846 
    tmp = list_empty((struct list_head const *)(& ctx->vifs));
    
#line 846 
    if (tmp != 0) _LOR: 
#line 847 
                        goto ldv_53768; else ;
  }
  
#line 848 
  if ((int)active != 0 && ! ctx->active) 
#line 849 
                                         goto ldv_53768; else ;
  
#line 851 
  if ((int)ctx->switch_after_beacon != 0) {
    
#line 852 
    __retres = ctx;
    
#line 852 
    goto return_label;
  }
  else ;
  ldv_53768: 
#line 853 
  ;
  
#line 845 
  ctx += 1;
  ldv_53770: 
#line 846 
  ;
  
#line 845 
  if (& sc->chanctx[1UL] >= ctx) 
#line 847 
                                 goto ldv_53769; else 
#line 850 
                                                      goto ldv_53771;
  ldv_53771: 
#line 851 
  ;
  
#line 855 
  __retres = & sc->chanctx[0];
  return_label: 
#line 855 
                return __retres;
}


#line 859  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
static void ath_scan_next_channel(struct ath_softc *sc)
{
  struct ieee80211_channel *chan;
  int tmp_1;
  
#line 861 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 862 
  struct cfg80211_scan_request *req = sc->offchannel.scan_req;
  
#line 865 
  if ((unsigned int)sc->offchannel.scan_idx >= req->n_channels) {
    struct ath_chanctx *tmp_0;
    
#line 866 
    if ((common->debug_mask & 262144) != 0) 
#line 866 
                                            ath_printk("\001",(struct ath_common const *)common,"Moving offchannel state to ATH_OFFCHANNEL_IDLE, ",sc->offchannel.scan_idx,req->n_channels); else ;
    
#line 872 
    sc->offchannel.state = ATH_OFFCHANNEL_IDLE;
    
#line 873 
    tmp_0 = ath_chanctx_get_oper_chan(sc,(_Bool)0);
    
#line 873 
    ;
    
#line 873 
    ath_chanctx_switch(sc,tmp_0,(struct cfg80211_chan_def *)0);
    
#line 875 
    goto return_label;
  }
  else ;
  
#line 878 
  if ((common->debug_mask & 262144) != 0) 
#line 878 
                                          ath_printk("\001",(struct ath_common const *)common,"Moving offchannel state to ATH_OFFCHANNEL_PROBE_SEND, scan_idx: %d\n",sc->offchannel.scan_idx); else ;
  
#line 882 
  tmp_1 = sc->offchannel.scan_idx;
  
#line 882 
  sc->offchannel.scan_idx += 1;
  
#line 882 
  chan = req->channels[tmp_1];
  
#line 883 
  sc->offchannel.duration = ath_scan_channel_duration(sc,chan);
  
#line 884 
  sc->offchannel.state = ATH_OFFCHANNEL_PROBE_SEND;
  
#line 886 
  ath_chanctx_offchan_switch(sc,chan);
  return_label: 
#line 887 
                return;
}


#line 889  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
void ath_offchannel_next(struct ath_softc *sc)
{
  struct ieee80211_vif *vif;
  
#line 893 
  if (sc->offchannel.scan_req != (struct cfg80211_scan_request *)0) {
    
#line 894 
    vif = sc->offchannel.scan_vif;
    
#line 895 
    sc->offchannel.chan.txpower = (unsigned short)vif->bss_conf.txpower;
    
#line 896 
    ath_scan_next_channel(sc);
  }
  else 
    
#line 897 
    if (sc->offchannel.roc_vif != (struct ieee80211_vif *)0) {
      unsigned long tmp;
      
#line 898 
      vif = sc->offchannel.roc_vif;
      
#line 899 
      sc->offchannel.chan.txpower = (unsigned short)vif->bss_conf.txpower;
      
#line 900 
      tmp = msecs_to_jiffies((unsigned int)sc->offchannel.roc_duration);
      
#line 900 
      sc->offchannel.duration = (int)tmp;
      
#line 902 
      sc->offchannel.state = ATH_OFFCHANNEL_ROC_START;
      
#line 903 
      ath_chanctx_offchan_switch(sc,sc->offchannel.roc_chan);
    }
    else {
      struct ath_chanctx *tmp_0;
      
#line 905 
      ldv_spin_lock_bh_91(& sc->chan_lock);
      
#line 906 
      sc->sched.offchannel_pending = (_Bool)0;
      
#line 907 
      sc->sched.wait_switch = (_Bool)0;
      
#line 908 
      ldv_spin_unlock_bh_92(& sc->chan_lock);
      
#line 910 
      tmp_0 = ath_chanctx_get_oper_chan(sc,(_Bool)0);
      
#line 910 
      ;
      
#line 910 
      ath_chanctx_switch(sc,tmp_0,(struct cfg80211_chan_def *)0);
      
#line 912 
      sc->offchannel.state = ATH_OFFCHANNEL_IDLE;
      
#line 913 
      if ((int)sc->ps_idle != 0) 
#line 914 
                                 ath_cancel_work(sc); else ;
    }
  
#line 916 
  return;
}


#line 918  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
void ath_roc_complete(struct ath_softc *sc, bool abort)
{
  
#line 920 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 922 
  if ((int)abort != 0) {
    
#line 923 
    if ((common->debug_mask & 262144) != 0) 
#line 923 
                                            ath_printk("\001",(struct ath_common const *)common,"RoC aborted\n"); else ;
  }
  else 
    
#line 925 
    if ((common->debug_mask & 262144) != 0) 
#line 925 
                                            ath_printk("\001",(struct ath_common const *)common,"RoC expired\n"); else ;
  
#line 927 
  sc->offchannel.roc_vif = (struct ieee80211_vif *)0;
  
#line 928 
  sc->offchannel.roc_chan = (struct ieee80211_channel *)0;
  
#line 929 
  ieee80211_remain_on_channel_expired(sc->hw);
  
#line 930 
  ath_offchannel_next(sc);
  
#line 931 
  ath9k_ps_restore(sc);
  
#line 932 
  return;
}


#line 934  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
void ath_scan_complete(struct ath_softc *sc, bool abort)
{
  int tmp_0;
  
#line 936 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 938 
  if ((int)abort != 0) {
    
#line 939 
    if ((common->debug_mask & 262144) != 0) 
#line 939 
                                            ath_printk("\001",(struct ath_common const *)common,"HW scan aborted\n"); else ;
  }
  else 
    
#line 941 
    if ((common->debug_mask & 262144) != 0) 
#line 941 
                                            ath_printk("\001",(struct ath_common const *)common,"HW scan complete\n"); else ;
  
#line 943 
  sc->offchannel.scan_req = (struct cfg80211_scan_request *)0;
  
#line 944 
  sc->offchannel.scan_vif = (struct ieee80211_vif *)0;
  
#line 945 
  sc->offchannel.state = ATH_OFFCHANNEL_IDLE;
  
#line 946 
  ieee80211_scan_completed(sc->hw,(_Bool)((bool)((int)abort) != 0));
  
#line 947 
  set_bit(5L,(unsigned long volatile *)(& common->op_flags));
  
#line 948 
  ldv_spin_lock_bh_93(& sc->chan_lock);
  
#line 949 
  tmp_0 = constant_test_bit(6L,(unsigned long const volatile *)(& common->op_flags));
  
#line 949 
  if (tmp_0 != 0) 
#line 950 
                  sc->sched.force_noa_update = (_Bool)1; else ;
  
#line 951 
  ldv_spin_unlock_bh_94(& sc->chan_lock);
  
#line 952 
  ath_offchannel_next(sc);
  
#line 953 
  ath9k_ps_restore(sc);
  
#line 954 
  return;
}


#line 956  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
static void ath_scan_send_probe(struct ath_softc *sc, struct cfg80211_ssid *ssid)
{
  struct sk_buff *skb;
  struct ieee80211_tx_info *info;
  int tmp_1;
  bool tmp_0;
  int tmp_2;
  
#line 959 
  struct cfg80211_scan_request *req = sc->offchannel.scan_req;
  
#line 960 
  struct ieee80211_vif *vif = sc->offchannel.scan_vif;
  
#line 961 
  struct ath_tx_control txctl = {.txq = (struct ath_txq *)0, .an = (struct ath_node *)0, .sta = (struct ieee80211_sta *)0, .paprd = (unsigned char)0, .force_channel = (_Bool)0};
  
#line 964 
  int band = (int)(sc->offchannel.chan.chandef.chan)->band;
  
#line 966 
  skb = ieee80211_probereq_get(sc->hw,(u8 const *)(& vif->addr),(u8 const *)(& ssid->ssid),(unsigned long)ssid->ssid_len,req->ie_len);
  
#line 968 
  if (skb == (struct sk_buff *)0) 
#line 969 
                                  goto return_label; else ;
  
#line 971 
  info = IEEE80211_SKB_CB(skb);
  
#line 972 
  if ((int)req->no_cck != 0) 
#line 973 
                             info->flags |= 134217728U; else ;
  
#line 975 
  if (req->ie_len != 0UL) {
    unsigned char *tmp;
    
#line 976 
    ;
    
#line 976 
    ;
    
#line 976 
    tmp = skb_put(skb,(unsigned int)req->ie_len);
    
#line 976 
    memcpy((void *)tmp,(void const *)req->ie,req->ie_len);
  }
  else ;
  
#line 978 
  skb_set_queue_mapping(skb,(unsigned short)0);
  
#line 980 
  tmp_0 = ieee80211_tx_prepare_skb(sc->hw,vif,skb,band,(struct ieee80211_sta **)0);
  
#line 980 
  if (tmp_0) 
#line 980 
             tmp_1 = 0; else 
#line 980 
                             tmp_1 = 1;
  
#line 980 
  if (tmp_1) 
#line 981 
             goto error; else ;
  
#line 983 
  txctl.txq = sc->tx.txq_map[0];
  
#line 984 
  txctl.force_channel = (_Bool)1;
  
#line 985 
  tmp_2 = ath_tx_start(sc->hw,skb,& txctl);
  
#line 985 
  if (tmp_2 != 0) 
#line 986 
                  goto error; else ;
  
#line 988 
  goto return_label;
  error: 
#line 990 
  ;
  
#line 991 
  ieee80211_free_txskb(sc->hw,skb);
  return_label: 
#line 992 
                return;
}


#line 994  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
static void ath_scan_channel_start(struct ath_softc *sc)
{
  int i;
  
#line 996 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 997 
  struct cfg80211_scan_request *req = sc->offchannel.scan_req;
  
#line 1000 
  if ((((sc->cur_chan)->chandef.chan)->flags & 2U) == 0U && req->n_ssids != 0) {
    
#line 1002 
    i = 0;
    
#line 1002 
    goto ldv_53810;
    ldv_53809: 
#line 1003 
    ;
    
#line 1003 
    ath_scan_send_probe(sc,req->ssids + i);
    
#line 1002 
    i += 1;
    ldv_53810: 
#line 1003 
    ;
    
#line 1002 
    if (req->n_ssids > i) 
#line 1004 
                          goto ldv_53809; else 
#line 1007 
                                               goto ldv_53811;
    ldv_53811: 
#line 1008 
    ;
  }
  else ;
  
#line 1007 
  if ((common->debug_mask & 262144) != 0) 
#line 1007 
                                          ath_printk("\001",(struct ath_common const *)common,"Moving offchannel state to ATH_OFFCHANNEL_PROBE_WAIT\n"); else ;
  
#line 1010 
  sc->offchannel.state = ATH_OFFCHANNEL_PROBE_WAIT;
  
#line 1011 
  ldv_mod_timer_95(& sc->offchannel.timer,(unsigned long)sc->offchannel.duration + jiffies);
  
#line 1012 
  return;
}


#line 1014  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
static void ath_chanctx_timer(unsigned long data)
{
  
#line 1016 
  struct ath_softc *sc = (struct ath_softc *)data;
  
#line 1017 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 1019 
  if ((common->debug_mask & 262144) != 0) 
#line 1019 
                                          ath_printk("\001",(struct ath_common const *)common,"Channel context timer invoked\n"); else ;
  
#line 1022 
  ath_chanctx_event(sc,(struct ieee80211_vif *)0,(enum ath_chanctx_event)ATH_CHANCTX_EVENT_TSF_TIMER);
  
#line 1023 
  return;
}


#line 1025  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
static void ath_offchannel_timer(unsigned long data)
{
  struct ath_chanctx *ctx;
  
#line 1027 
  struct ath_softc *sc = (struct ath_softc *)data;
  
#line 1029 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 1031 
  if ((common->debug_mask & 262144) != 0) {
    char const *tmp_0;
    
#line 1031 
    tmp_0 = offchannel_state_string(sc->offchannel.state);
    
#line 1031 
    ;
    
#line 1031 
    ath_printk("\001",(struct ath_common const *)common,"%s: offchannel state: %s\n","ath_offchannel_timer",tmp_0);
  }
  else ;
  
#line 1034 
  switch ((unsigned int)sc->offchannel.state) {
    case (unsigned int)2: 
#line 1035 
    ;
    
#line 1036 
    if (sc->offchannel.scan_req == (struct cfg80211_scan_request *)0) 
      
#line 1037 
      goto return_label; else ;
    
#line 1040 
    ctx = ath_chanctx_get_oper_chan(sc,(_Bool)1);
    
#line 1041 
    if ((int)ctx->active != 0) {
      
#line 1042 
      if ((common->debug_mask & 262144) != 0) 
#line 1042 
                                              ath_printk("\001",(struct ath_common const *)common,"Switch to oper/active context, "); else ;
      
#line 1046 
      sc->offchannel.state = ATH_OFFCHANNEL_SUSPEND;
      
#line 1047 
      ath_chanctx_switch(sc,ctx,(struct cfg80211_chan_def *)0);
      
#line 1048 
      ldv_mod_timer_96(& sc->offchannel.timer,jiffies + 25UL);
      
#line 1049 
      goto ldv_53825;
    }
    else ;
    case (unsigned int)3: 
#line 1052 
    ;
    
#line 1053 
    if (sc->offchannel.scan_req == (struct cfg80211_scan_request *)0) 
      
#line 1054 
      goto return_label; else ;
    
#line 1056 
    ath_scan_next_channel(sc);
    
#line 1057 
    goto ldv_53825;
    case (unsigned int)4: 
#line 1058 
    ;
    case (unsigned int)5: 
#line 1059 
    ;
    
#line 1060 
    sc->offchannel.state = ATH_OFFCHANNEL_ROC_DONE;
    
#line 1061 
    ath_roc_complete(sc,(_Bool)0);
    
#line 1062 
    goto ldv_53825;
    default: 
#line 1063 
    ;
    
#line 1064 
    goto ldv_53825;
  }
  ldv_53825: 
#line 1066 
  ;
  return_label: 
#line 1067 
                return;
}


#line 1069  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
static bool ath_chanctx_send_vif_ps_frame(struct ath_softc *sc, struct ath_vif *avp, bool powersave)
{
  bool __retres;
  struct ieee80211_hdr_3addr *nullfunc;
  struct ath_tx_control txctl;
  struct sk_buff *skb;
  int tmp_1;
  
#line 1072 
  struct ieee80211_vif *vif = avp->vif;
  
#line 1073 
  struct ieee80211_sta *sta = (struct ieee80211_sta *)0;
  
#line 1077 
  int band = (int)((sc->cur_chan)->chandef.chan)->band;
  
#line 1079 
  switch ((unsigned int)vif->type) {
    int tmp_0;
    bool tmp;
    case (unsigned int)2: 
#line 1080 
    ;
    
#line 1081 
    if (! avp->assoc) {
      
#line 1082 
      __retres = (_Bool)0;
      
#line 1082 
      goto return_label;
    }
    else ;
    
#line 1084 
    skb = ieee80211_nullfunc_get(sc->hw,vif);
    
#line 1085 
    if (skb == (struct sk_buff *)0) {
      
#line 1086 
      __retres = (_Bool)0;
      
#line 1086 
      goto return_label;
    }
    else ;
    
#line 1088 
    nullfunc = (struct ieee80211_hdr_3addr *)skb->data;
    
#line 1089 
    if ((int)powersave != 0) 
#line 1090 
                             nullfunc->frame_control = (unsigned short)((unsigned int)nullfunc->frame_control | 4096U); else ;
    
#line 1093 
    skb_set_queue_mapping(skb,(unsigned short)0);
    
#line 1094 
    tmp = ieee80211_tx_prepare_skb(sc->hw,vif,skb,band,& sta);
    
#line 1094 
    if (tmp) 
#line 1094 
             tmp_0 = 0; else 
#line 1094 
                             tmp_0 = 1;
    
#line 1094 
    if (tmp_0) {
      
#line 1095 
      dev_kfree_skb_any(skb);
      
#line 1096 
      __retres = (_Bool)0;
      
#line 1096 
      goto return_label;
    }
    else ;
    
#line 1098 
    goto ldv_53842;
    default: 
#line 1099 
    ;
    
#line 1100 
    __retres = (_Bool)0;
    
#line 1100 
    goto return_label;
  }
  ldv_53842: 
#line 1103 
  ;
  
#line 1103 
  memset((void *)(& txctl),0,32UL);
  
#line 1104 
  txctl.txq = sc->tx.txq_map[0];
  
#line 1105 
  txctl.sta = sta;
  
#line 1106 
  txctl.force_channel = (_Bool)1;
  
#line 1107 
  tmp_1 = ath_tx_start(sc->hw,skb,& txctl);
  
#line 1107 
  if (tmp_1 != 0) {
    
#line 1108 
    ieee80211_free_txskb(sc->hw,skb);
    
#line 1109 
    __retres = (_Bool)0;
    
#line 1109 
    goto return_label;
  }
  else ;
  
#line 1112 
  __retres = (_Bool)1;
  return_label: 
#line 1112 
                return __retres;
}


#line 1116  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
static bool ath_chanctx_send_ps_frame(struct ath_softc *sc, bool powersave)
{
  struct ath_vif *avp;
  struct ath_vif *tmp;
  bool tmp_0;
  struct ath_vif *tmp_1;
  
#line 1119 
  bool sent = (_Bool)0;
  
#line 1121 
  rcu_read_lock();
  {
    
#line 1122 
    struct list_head const *__mptr = (struct list_head const *)(sc->cur_chan)->vifs.next;
    
#line 1122 
    tmp = (struct ath_vif *)__mptr;
  }
  
#line 1122 
  avp = tmp;
  
#line 1122 
  goto ldv_53855;
  ldv_53854: 
#line 1123 
  ;
  
#line 1123 
  tmp_0 = ath_chanctx_send_vif_ps_frame(sc,avp,(_Bool)((bool)((int)powersave) != 0));
  
#line 1123 
  if ((int)tmp_0 != 0) 
#line 1124 
                       sent = (_Bool)1; else ;
  {
    
#line 1122 
    struct list_head const *__mptr_0 = (struct list_head const *)avp->list.next;
    
#line 1122 
    tmp_1 = (struct ath_vif *)__mptr_0;
  }
  
#line 1122 
  avp = tmp_1;
  ldv_53855: 
#line 1124 
  ;
  
#line 1122 
  if (& avp->list != & (sc->cur_chan)->vifs) 
#line 1124 
                                             goto ldv_53854; else 
#line 1127 
                                                                  goto ldv_53856;
  ldv_53856: 
#line 1128 
  ;
  
#line 1126 
  rcu_read_unlock();
  
#line 1128 
  return sent;
}


#line 1131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
static bool ath_chanctx_defer_switch(struct ath_softc *sc)
{
  bool __retres;
  
#line 1133 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 1135 
  if (sc->cur_chan == & sc->offchannel.chan) {
    
#line 1136 
    __retres = (_Bool)0;
    
#line 1136 
    goto return_label;
  }
  else ;
  
#line 1138 
  switch ((unsigned int)sc->sched.state) {
    case (unsigned int)3: 
#line 1139 
    ;
    
#line 1140 
    __retres = (_Bool)0;
    
#line 1140 
    goto return_label;
    case (unsigned int)0: 
#line 1141 
    ;
    
#line 1142 
    if (! (sc->cur_chan)->switch_after_beacon) {
      
#line 1143 
      __retres = (_Bool)0;
      
#line 1143 
      goto return_label;
    }
    else ;
    
#line 1145 
    if ((common->debug_mask & 262144) != 0) 
#line 1145 
                                            ath_printk("\001",(struct ath_common const *)common,"Defer switch, set chanctx state to WAIT_FOR_BEACON\n"); else ;
    
#line 1148 
    sc->sched.state = ATH_CHANCTX_STATE_WAIT_FOR_BEACON;
    
#line 1149 
    goto ldv_53863;
    default: 
#line 1150 
    ;
    
#line 1151 
    goto ldv_53863;
  }
  ldv_53863: 
#line 1154 
  ;
  
#line 1154 
  __retres = (_Bool)1;
  return_label: 
#line 1154 
                return __retres;
}


#line 1157  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
static void ath_offchannel_channel_change(struct ath_softc *sc)
{
  
#line 1159 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 1161 
  if ((common->debug_mask & 262144) != 0) {
    char const *tmp_0;
    
#line 1161 
    tmp_0 = offchannel_state_string(sc->offchannel.state);
    
#line 1161 
    ;
    
#line 1161 
    ath_printk("\001",(struct ath_common const *)common,"%s: offchannel state: %s\n","ath_offchannel_channel_change",tmp_0);
  }
  else ;
  
#line 1164 
  switch ((unsigned int)sc->offchannel.state) {
    case (unsigned int)1: 
#line 1165 
    ;
    
#line 1166 
    if (sc->offchannel.scan_req == (struct cfg80211_scan_request *)0) 
      
#line 1167 
      goto return_label; else ;
    
#line 1169 
    if ((sc->cur_chan)->chandef.chan != sc->offchannel.chan.chandef.chan) 
      
#line 1171 
      goto return_label; else ;
    
#line 1173 
    ath_scan_channel_start(sc);
    
#line 1174 
    goto ldv_53871;
    case (unsigned int)0: 
#line 1175 
    ;
    
#line 1176 
    if (sc->offchannel.scan_req == (struct cfg80211_scan_request *)0) 
      
#line 1177 
      goto return_label; else ;
    
#line 1179 
    ath_scan_complete(sc,(_Bool)0);
    
#line 1180 
    goto ldv_53871;
    case (unsigned int)4: 
#line 1181 
    ;
    
#line 1182 
    if (sc->cur_chan != & sc->offchannel.chan) 
#line 1183 
                                               goto ldv_53871; else ;
    
#line 1185 
    sc->offchannel.state = ATH_OFFCHANNEL_ROC_WAIT;
    
#line 1186 
    ldv_mod_timer_97(& sc->offchannel.timer,(unsigned long)sc->offchannel.duration + jiffies);
    
#line 1188 
    ieee80211_ready_on_channel(sc->hw);
    
#line 1189 
    goto ldv_53871;
    case (unsigned int)6: 
#line 1190 
    ;
    
#line 1191 
    goto ldv_53871;
    default: 
#line 1192 
    ;
    
#line 1193 
    goto ldv_53871;
  }
  ldv_53871: 
#line 1195 
  ;
  return_label: 
#line 1196 
                return;
}


#line 1197  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
void ath_chanctx_set_next(struct ath_softc *sc, bool force)
{
  struct ath_chanctx *old_ctx;
  struct timespec ts;
  
#line 1199 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 1202 
  bool measure_time = (_Bool)0;
  
#line 1203 
  bool send_ps = (_Bool)0;
  
#line 1204 
  bool queues_stopped = (_Bool)0;
  
#line 1206 
  ldv_spin_lock_bh_98(& sc->chan_lock);
  
#line 1207 
  if (sc->next_chan == (struct ath_chanctx *)0) {
    
#line 1208 
    ldv_spin_unlock_bh_99(& sc->chan_lock);
    
#line 1209 
    goto return_label;
  }
  else ;
  
#line 1212 
  if (! force) {
    bool tmp_0;
    
#line 1212 
    tmp_0 = ath_chanctx_defer_switch(sc);
    
#line 1212 
    if ((int)tmp_0 != 0) {
      
#line 1213 
      ldv_spin_unlock_bh_100(& sc->chan_lock);
      
#line 1214 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 1217 
  if ((common->debug_mask & 262144) != 0) 
#line 1217 
                                          ath_printk("\001",(struct ath_common const *)common,"%s: current: %d MHz, next: %d MHz\n","ath_chanctx_set_next",(sc->cur_chan)->chandef.center_freq1,(sc->next_chan)->chandef.center_freq1); else ;
  
#line 1223 
  if (sc->cur_chan != sc->next_chan) {
    bool tmp_1;
    
#line 1224 
    if ((common->debug_mask & 262144) != 0) 
#line 1224 
                                            ath_printk("\001",(struct ath_common const *)common,"Stopping current chanctx: %d\n",(sc->cur_chan)->chandef.center_freq1); else ;
    
#line 1227 
    (sc->cur_chan)->stopped = (_Bool)1;
    
#line 1228 
    ldv_spin_unlock_bh_101(& sc->chan_lock);
    
#line 1230 
    if (sc->next_chan == & sc->offchannel.chan) {
      
#line 1231 
      getrawmonotonic(& ts);
      
#line 1232 
      measure_time = (_Bool)1;
    }
    else ;
    
#line 1235 
    ath9k_chanctx_stop_queues(sc,sc->cur_chan);
    
#line 1236 
    queues_stopped = (_Bool)1;
    
#line 1238 
    __ath9k_flush(sc->hw,4294967295U,(_Bool)1,(_Bool)0,(_Bool)0);
    
#line 1240 
    tmp_1 = ath_chanctx_send_ps_frame(sc,(_Bool)1);
    
#line 1240 
    if ((int)tmp_1 != 0) 
#line 1241 
                         __ath9k_flush(sc->hw,1U,(_Bool)0,(_Bool)0,(_Bool)0); else ;
    
#line 1244 
    send_ps = (_Bool)1;
    
#line 1245 
    ldv_spin_lock_bh_102(& sc->chan_lock);
    
#line 1247 
    if (sc->cur_chan != & sc->offchannel.chan) {
      
#line 1248 
      getrawmonotonic(& (sc->cur_chan)->tsf_ts);
      
#line 1249 
      (sc->cur_chan)->tsf_val = ath9k_hw_gettsf64(sc->sc_ah);
    }
    else ;
  }
  else ;
  
#line 1252 
  old_ctx = sc->cur_chan;
  
#line 1253 
  sc->cur_chan = sc->next_chan;
  
#line 1254 
  (sc->cur_chan)->stopped = (_Bool)0;
  
#line 1255 
  sc->next_chan = (struct ath_chanctx *)0;
  
#line 1257 
  if (! sc->sched.offchannel_pending) 
#line 1258 
                                      sc->sched.offchannel_duration = 0U; else ;
  
#line 1260 
  if (sc->sched.state != (unsigned int)ATH_CHANCTX_STATE_FORCE_ACTIVE) 
    
#line 1261 
    sc->sched.state = ATH_CHANCTX_STATE_IDLE; else ;
  
#line 1263 
  ldv_spin_unlock_bh_103(& sc->chan_lock);
  
#line 1265 
  if ((int)(sc->sc_ah)->chip_fullsleep != 0) 
#line 1265 
                                             goto _LOR;
  else {
    int tmp_2;
    
#line 1265 
    tmp_2 = memcmp((void const *)(& sc->cur_chandef),(void const *)(& (sc->cur_chan)->chandef),24UL);
    
#line 1265 
    if (tmp_2 != 0) {
      _LOR: {
              
#line 1268 
              if ((common->debug_mask & 262144) != 0) 
#line 1268 
                                                      ath_printk("\001",(struct ath_common const *)common,"%s: Set channel %d MHz\n","ath_chanctx_set_next",(sc->cur_chan)->chandef.center_freq1); else ;
              
#line 1271 
              ath_set_channel(sc);
              
#line 1272 
              if ((int)measure_time != 0) 
#line 1273 
                                          sc->sched.channel_switch_time = ath9k_hw_get_tsf_offset(& ts,(struct timespec *)0); else ;
              
#line 1279 
              goto out;
            }
    }
    else ;
  }
  
#line 1282 
  if ((int)queues_stopped != 0) 
#line 1283 
                                ath9k_chanctx_wake_queues(sc,old_ctx); else ;
  out: 
#line 1284 
  ;
  
#line 1285 
  if ((int)send_ps != 0) 
#line 1286 
                         ath_chanctx_send_ps_frame(sc,(_Bool)0); else ;
  
#line 1288 
  ath_offchannel_channel_change(sc);
  
#line 1289 
  ath_chanctx_event(sc,(struct ieee80211_vif *)0,(enum ath_chanctx_event)ATH_CHANCTX_EVENT_SWITCH);
  return_label: 
#line 1290 
                return;
}


#line 1292  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
static void ath_chanctx_work(struct work_struct *work)
{
  struct ath_softc *tmp;
  {
    
#line 1294 
    struct work_struct const *__mptr = (struct work_struct const *)work;
    
#line 1294 
    tmp = (struct ath_softc *)__mptr + 18446744073709548336U;
  }
  
#line 1294 
  struct ath_softc *sc = tmp;
  
#line 1296 
  ldv_mutex_lock_104(& sc->mutex);
  
#line 1297 
  ath_chanctx_set_next(sc,(_Bool)0);
  
#line 1298 
  ldv_mutex_unlock_105(& sc->mutex);
  
#line 1299 
  return;
}


#line 1301  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
void ath9k_offchannel_init(struct ath_softc *sc)
{
  struct ath_chanctx *ctx;
  struct ieee80211_supported_band *sband;
  struct ieee80211_channel *chan;
  int i;
  
#line 1304 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 1309 
  sband = & common->sbands[0];
  
#line 1310 
  if (sband->n_channels == 0) 
#line 1311 
                              sband = & common->sbands[1]; else ;
  
#line 1313 
  chan = sband->channels;
  
#line 1315 
  ctx = & sc->offchannel.chan;
  
#line 1316 
  INIT_LIST_HEAD(& ctx->vifs);
  
#line 1317 
  ctx->txpower = (unsigned short)100U;
  
#line 1318 
  cfg80211_chandef_create(& ctx->chandef,chan,(enum nl80211_channel_type)NL80211_CHAN_HT20);
  
#line 1320 
  i = 0;
  
#line 1320 
  goto ldv_53906;
  ldv_53905: 
#line 1321 
  ;
  
#line 1321 
  INIT_LIST_HEAD(& ctx->acq[i]);
  
#line 1320 
  i += 1;
  ldv_53906: 
#line 1321 
  ;
  
#line 1320 
  if ((unsigned int)i <= 3U) 
#line 1322 
                             goto ldv_53905; else 
#line 1325 
                                                  goto ldv_53907;
  ldv_53907: 
#line 1326 
  ;
  
#line 1323 
  sc->offchannel.chan.offchannel = (_Bool)1;
  
#line 1324 
  return;
}


#line 1326  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
void ath9k_init_channel_context(struct ath_softc *sc)
{
  {
    struct lock_class_key __key;
    
#line 1328 
    __init_work(& sc->chanctx_work,0);
    
#line 1328 
    atomic_long_t __constr_expr_37 = {.counter = WORK_STRUCT_NO_POOL_1};
    
#line 1328 
    sc->chanctx_work.data = __constr_expr_37;
    
#line 1328 
    lockdep_init_map(& sc->chanctx_work.lockdep_map,"(&sc->chanctx_work)",& __key,0);
    
#line 1328 
    INIT_LIST_HEAD(& sc->chanctx_work.entry);
    
#line 1328 
    sc->chanctx_work.func = & ath_chanctx_work;
  }
  {
    struct lock_class_key __key_0;
    
#line 1330 
    init_timer_key(& sc->offchannel.timer,0U,"((&sc->offchannel.timer))",& __key_0);
  }
  
#line 1330 
  sc->offchannel.timer.function = & ath_offchannel_timer;
  
#line 1330 
  sc->offchannel.timer.data = (unsigned long)sc;
  {
    struct lock_class_key __key_1;
    
#line 1332 
    init_timer_key(& sc->sched.timer,0U,"((&sc->sched.timer))",& __key_1);
  }
  
#line 1332 
  sc->sched.timer.function = & ath_chanctx_timer;
  
#line 1332 
  sc->sched.timer.data = (unsigned long)sc;
  
#line 1335 
  init_completion(& sc->go_beacon);
  
#line 1336 
  return;
}


#line 1338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
void ath9k_deinit_channel_context(struct ath_softc *sc)
{
  
#line 1340 
  cancel_work_sync(& sc->chanctx_work);
  
#line 1341 
  return;
}


#line 1343  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
bool ath9k_is_chanctx_enabled(void)
{
  bool __retres;
  
#line 1345 
  __retres = (_Bool)(ath9k_use_chanctx == 1);
  
#line 1345 
  return __retres;
}


#line 1352  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
void ath9k_chanctx_stop_queues(struct ath_softc *sc, struct ath_chanctx *ctx)
{
  int i;
  
#line 1354 
  struct ath_hw *ah = sc->sc_ah;
  
#line 1357 
  if (& sc->offchannel.chan == ctx) 
#line 1358 
                                    ieee80211_stop_queue(sc->hw,(int)(sc->hw)->offchannel_tx_hw_queue);
  else {
    
#line 1361 
    i = 0;
    
#line 1361 
    goto ldv_53928;
    ldv_53927: 
#line 1362 
    ;
    
#line 1362 
    ieee80211_stop_queue(sc->hw,ctx->hw_queue_base + i);
    
#line 1361 
    i += 1;
    ldv_53928: 
#line 1362 
    ;
    
#line 1361 
    if (i <= 3) 
#line 1363 
                goto ldv_53927; else 
#line 1366 
                                     goto ldv_53929;
    ldv_53929: 
#line 1367 
    ;
  }
  
#line 1366 
  if (ah->opmode == (unsigned int)NL80211_IFTYPE_AP) 
#line 1367 
                                                     ieee80211_stop_queue(sc->hw,(int)(sc->hw)->queues + -2); else ;
  
#line 1368 
  return;
}


#line 1371  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
void ath9k_chanctx_wake_queues(struct ath_softc *sc, struct ath_chanctx *ctx)
{
  int i;
  
#line 1373 
  struct ath_hw *ah = sc->sc_ah;
  
#line 1376 
  if (& sc->offchannel.chan == ctx) 
#line 1377 
                                    ieee80211_wake_queue(sc->hw,(int)(sc->hw)->offchannel_tx_hw_queue);
  else {
    
#line 1380 
    i = 0;
    
#line 1380 
    goto ldv_53937;
    ldv_53936: 
#line 1381 
    ;
    
#line 1381 
    ieee80211_wake_queue(sc->hw,ctx->hw_queue_base + i);
    
#line 1380 
    i += 1;
    ldv_53937: 
#line 1381 
    ;
    
#line 1380 
    if (i <= 3) 
#line 1382 
                goto ldv_53936; else 
#line 1385 
                                     goto ldv_53938;
    ldv_53938: 
#line 1386 
    ;
  }
  
#line 1385 
  if (ah->opmode == (unsigned int)NL80211_IFTYPE_AP) 
#line 1386 
                                                     ieee80211_wake_queue(sc->hw,(int)(sc->hw)->queues + -2); else ;
  
#line 1387 
  return;
}


#line 1393  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
static void ath9k_update_p2p_ps_timer(struct ath_softc *sc, struct ath_vif *avp)
{
  s32 tsf;
  s32 target_tsf;
  u32 tmp;
  
#line 1395 
  struct ath_hw *ah = sc->sc_ah;
  
#line 1398 
  if (avp == (struct ath_vif *)0 || ! avp->noa.has_next_tsf) 
#line 1399 
                                                             goto return_label; else ;
  
#line 1401 
  ath9k_hw_gen_timer_stop(ah,sc->p2p_ps_timer);
  
#line 1403 
  tmp = ath9k_hw_gettsf32(sc->sc_ah);
  
#line 1403 
  tsf = (int)tmp;
  
#line 1405 
  target_tsf = (int)avp->noa.next_tsf;
  
#line 1406 
  if ((unsigned int)avp->noa.absent == 0U) 
#line 1407 
                                           target_tsf += -1000; else ;
  
#line 1409 
  if (target_tsf - tsf <= 999) 
#line 1410 
                               target_tsf = tsf + 1000; else ;
  
#line 1412 
  ath9k_hw_gen_timer_start(ah,sc->p2p_ps_timer,(unsigned int)target_tsf,1000000U);
  return_label: 
#line 1413 
                return;
}


#line 1415  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
static void ath9k_update_p2p_ps(struct ath_softc *sc, struct ieee80211_vif *vif)
{
  u32 tsf;
  
#line 1417 
  struct ath_vif *avp = (struct ath_vif *)(& vif->drv_priv);
  
#line 1420 
  if (sc->p2p_ps_timer == (struct ath_gen_timer *)0) 
#line 1421 
                                                     goto return_label; else ;
  
#line 1423 
  if (vif->type != (unsigned int)NL80211_IFTYPE_STATION || ! vif->p2p) 
    
#line 1424 
    goto return_label; else ;
  
#line 1426 
  sc->p2p_ps_vif = avp;
  
#line 1427 
  tsf = ath9k_hw_gettsf32(sc->sc_ah);
  
#line 1428 
  ieee80211_parse_p2p_noa((struct ieee80211_p2p_noa_attr const *)(& vif->bss_conf.p2p_noa_attr),& avp->noa,tsf);
  
#line 1429 
  ath9k_update_p2p_ps_timer(sc,avp);
  return_label: 
#line 1430 
                return;
}


#line 1432  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
static u8 ath9k_get_ctwin(struct ath_softc *sc, struct ath_vif *avp)
{
  u8 __retres;
  u8 switch_time;
  u8 ctwin;
  
#line 1434 
  struct ath_beacon_config *cur_conf = & (sc->cur_chan)->beacon;
  
#line 1444 
  switch_time = (unsigned char)(cur_conf->beacon_interval / 4);
  
#line 1446 
  ctwin = (avp->vif)->bss_conf.p2p_noa_attr.oppps_ctwindow;
  
#line 1447 
  if ((unsigned int)ctwin != 0U && (int)ctwin < (int)switch_time) {
    
#line 1448 
    __retres = ctwin;
    
#line 1448 
    goto return_label;
  }
  else ;
  
#line 1450 
  if ((unsigned int)switch_time <= 9U) {
    
#line 1451 
    __retres = (unsigned char)0U;
    
#line 1451 
    goto return_label;
  }
  else ;
  
#line 1453 
  __retres = (unsigned char)10U;
  return_label: 
#line 1453 
                return __retres;
}


#line 1456  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
void ath9k_beacon_add_noa(struct ath_softc *sc, struct ath_vif *avp, struct sk_buff *skb)
{
  struct ieee80211_p2p_noa_attr *noa;
  int noa_len;
  int noa_desc;
  u8 *hdr;
  
#line 1459 
  u8 const noa_ie_hdr[9U] = {(unsigned char)221U, (unsigned char)0U, (unsigned char)80U, (unsigned char)111U, (unsigned char)154U, (unsigned char)9U, (unsigned char)12U, (unsigned char)0U, (unsigned char)0U};
  
#line 1470 
  int i = 0;
  
#line 1473 
  if (avp->offchannel_duration == 0U && avp->noa_duration == 0U) 
#line 1474 
                                                                 goto return_label; else ;
  
#line 1476 
  noa_desc = (avp->offchannel_duration != 0U) + (avp->noa_duration != 0U);
  
#line 1477 
  noa_len = (int)((unsigned long)noa_desc * (unsigned long)13U + (unsigned long)2U);
  
#line 1479 
  hdr = skb_put(skb,9U);
  
#line 1480 
  memcpy((void *)hdr,(void const *)(& noa_ie_hdr),9UL);
  
#line 1481 
  *(hdr + 1U) = (unsigned char)((unsigned int)((unsigned char)noa_len) + 7U);
  
#line 1482 
  *(hdr + 7U) = (unsigned char)noa_len;
  
#line 1484 
  noa = (struct ieee80211_p2p_noa_attr *)skb_put(skb,(unsigned int)noa_len);
  
#line 1485 
  memset((void *)noa,0,(unsigned long)noa_len);
  
#line 1487 
  noa->index = avp->noa_index;
  
#line 1488 
  noa->oppps_ctwindow = ath9k_get_ctwin(sc,avp);
  
#line 1490 
  if (avp->noa_duration != 0U) {
    
#line 1491 
    if ((int)avp->periodic_noa != 0) {
      
#line 1492 
      u32 interval = (unsigned int)((sc->cur_chan)->beacon.beacon_interval << 10);
      
#line 1493 
      noa->desc[i].count = (unsigned char)255U;
      
#line 1494 
      noa->desc[i].interval = interval;
    }
    else 
#line 1496 
         noa->desc[i].count = (unsigned char)1U;
    
#line 1499 
    noa->desc[i].start_time = avp->noa_start;
    
#line 1500 
    noa->desc[i].duration = avp->noa_duration;
    
#line 1501 
    i += 1;
  }
  else ;
  
#line 1504 
  if (avp->offchannel_duration != 0U) {
    
#line 1505 
    noa->desc[i].count = (unsigned char)1U;
    
#line 1506 
    noa->desc[i].start_time = avp->offchannel_start;
    
#line 1507 
    noa->desc[i].duration = avp->offchannel_duration;
  }
  else ;
  return_label: 
#line 1509 
                return;
}


#line 1511  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
void ath9k_p2p_ps_timer(void *priv)
{
  struct ieee80211_vif *vif;
  struct ieee80211_sta *sta;
  struct ath_node *an;
  u32 tsf;
  
#line 1513 
  struct ath_softc *sc = (struct ath_softc *)priv;
  
#line 1514 
  struct ath_vif *avp = sc->p2p_ps_vif;
  
#line 1520 
  ldv_del_timer_sync_106(& sc->sched.timer);
  
#line 1521 
  ath9k_hw_gen_timer_stop(sc->sc_ah,sc->p2p_ps_timer);
  
#line 1522 
  ath_chanctx_event(sc,(struct ieee80211_vif *)0,(enum ath_chanctx_event)ATH_CHANCTX_EVENT_TSF_TIMER);
  
#line 1524 
  if (avp == (struct ath_vif *)0 || avp->chanctx != sc->cur_chan) 
#line 1525 
                                                                  goto return_label; else ;
  
#line 1527 
  tsf = ath9k_hw_gettsf32(sc->sc_ah);
  
#line 1528 
  if ((unsigned int)avp->noa.absent == 0U) 
#line 1529 
                                           tsf += 1000U; else ;
  
#line 1531 
  if (! avp->noa.has_next_tsf || avp->noa.next_tsf - tsf > 2147483648U) 
    
#line 1533 
    ieee80211_update_p2p_noa(& avp->noa,tsf); else ;
  
#line 1535 
  ath9k_update_p2p_ps_timer(sc,avp);
  
#line 1537 
  rcu_read_lock();
  
#line 1539 
  vif = avp->vif;
  
#line 1540 
  sta = ieee80211_find_sta(vif,(u8 const *)(& avp->bssid));
  
#line 1541 
  if (sta == (struct ieee80211_sta *)0) 
#line 1542 
                                        goto out; else ;
  
#line 1544 
  an = (struct ath_node *)(& sta->drv_priv);
  
#line 1545 
  if ((int)an->sleeping == ((unsigned int)avp->noa.absent != 0U)) 
#line 1546 
                                                                  goto out; else ;
  
#line 1548 
  an->sleeping = (_Bool)((unsigned int)avp->noa.absent != 0U);
  
#line 1549 
  if ((int)an->sleeping != 0) 
#line 1550 
                              ath_tx_aggr_sleep(sta,sc,an); else 
#line 1552 
                                                                 ath_tx_aggr_wakeup(sc,an);
  out: 
#line 1554 
  ;
  
#line 1555 
  rcu_read_unlock();
  return_label: 
#line 1556 
                return;
}


#line 1558  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
void ath9k_p2p_bss_info_changed(struct ath_softc *sc, struct ieee80211_vif *vif)
{
  unsigned long flags;
  
#line 1563 
  ldv_spin_lock_bh_107(& sc->sc_pcu_lock);
  
#line 1564 
  ldv___ldv_spin_lock_108(& sc->sc_pm_lock);
  
#line 1565 
  if (((unsigned long)sc->ps_flags & 16UL) == 0UL) 
#line 1566 
                                                   ath9k_update_p2p_ps(sc,vif); else ;
  
#line 1567 
  ldv_spin_unlock_irqrestore_109(& sc->sc_pm_lock,flags);
  
#line 1568 
  ldv_spin_unlock_bh_110(& sc->sc_pcu_lock);
  
#line 1569 
  return;
}


#line 1571  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
void ath9k_p2p_beacon_sync(struct ath_softc *sc)
{
  
#line 1573 
  if (sc->p2p_ps_vif != (struct ath_vif *)0) 
#line 1574 
                                             ath9k_update_p2p_ps(sc,(sc->p2p_ps_vif)->vif); else ;
  
#line 1575 
  return;
}


#line 1577  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
void ath9k_p2p_remove_vif(struct ath_softc *sc, struct ieee80211_vif *vif)
{
  
#line 1580 
  struct ath_vif *avp = (struct ath_vif *)(& vif->drv_priv);
  
#line 1582 
  ldv_spin_lock_bh_111(& sc->sc_pcu_lock);
  
#line 1583 
  if (sc->p2p_ps_vif == avp) {
    
#line 1584 
    sc->p2p_ps_vif = (struct ath_vif *)0;
    
#line 1585 
    ath9k_update_p2p_ps_timer(sc,(struct ath_vif *)0);
  }
  else ;
  
#line 1587 
  ldv_spin_unlock_bh_112(& sc->sc_pcu_lock);
  
#line 1588 
  return;
}


#line 1590  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
int ath9k_init_p2p(struct ath_softc *sc)
{
  int __retres;
  
#line 1592 
  sc->p2p_ps_timer = ath_gen_timer_alloc(sc->sc_ah,& ath9k_p2p_ps_timer,(void (*)(void *))0,(void *)sc,(unsigned char)7);
  
#line 1594 
  if (sc->p2p_ps_timer == (struct ath_gen_timer *)0) {
    
#line 1595 
    __retres = -12;
    
#line 1595 
    goto return_label;
  }
  else ;
  
#line 1597 
  __retres = 0;
  return_label: 
#line 1597 
                return __retres;
}


#line 1600  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/channel.c"
void ath9k_deinit_p2p(struct ath_softc *sc)
{
  
#line 1602 
  if (sc->p2p_ps_timer != (struct ath_gen_timer *)0) 
#line 1603 
                                                     ath_gen_timer_free(sc->sc_ah,sc->p2p_ps_timer); else ;
  
#line 1604 
  return;
}


#line 737  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_lock_bh_72_2(spinlock_t *lock)
{
  
#line 741 
  ldv_spin_model_lock((char *)"cc_lock_of_ath_common");
  
#line 743 
  spin_lock_bh_3(lock);
  
#line 744 
  return;
}


#line 747  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_unlock_bh_73_2(spinlock_t *lock)
{
  
#line 751 
  ldv_spin_model_unlock((char *)"cc_lock_of_ath_common");
  
#line 753 
  spin_unlock_bh_3(lock);
  
#line 754 
  return;
}


#line 757  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_lock_bh_74_0(spinlock_t *lock)
{
  
#line 761 
  ldv_spin_model_lock((char *)"chan_lock_of_ath_softc");
  
#line 763 
  spin_lock_bh_3(lock);
  
#line 764 
  return;
}


#line 767  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_unlock_bh_75_0(spinlock_t *lock)
{
  
#line 771 
  ldv_spin_model_unlock((char *)"chan_lock_of_ath_softc");
  
#line 773 
  spin_unlock_bh_3(lock);
  
#line 774 
  return;
}


#line 777  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_lock_bh_76(spinlock_t *lock)
{
  
#line 781 
  ldv_spin_model_lock((char *)"chan_lock_of_ath_softc");
  
#line 783 
  spin_lock_bh_3(lock);
  
#line 784 
  return;
}


#line 787  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_unlock_bh_77_0(spinlock_t *lock)
{
  
#line 791 
  ldv_spin_model_unlock((char *)"chan_lock_of_ath_softc");
  
#line 793 
  spin_unlock_bh_3(lock);
  
#line 794 
  return;
}


#line 797  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_unlock_bh_78_0(spinlock_t *lock)
{
  
#line 801 
  ldv_spin_model_unlock((char *)"chan_lock_of_ath_softc");
  
#line 803 
  spin_unlock_bh_3(lock);
  
#line 804 
  return;
}


#line 807  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_lock_bh_79(spinlock_t *lock)
{
  
#line 811 
  ldv_spin_model_lock((char *)"chan_lock_of_ath_softc");
  
#line 813 
  spin_lock_bh_3(lock);
  
#line 814 
  return;
}


#line 817  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_unlock_bh_80(spinlock_t *lock)
{
  
#line 821 
  ldv_spin_model_unlock((char *)"chan_lock_of_ath_softc");
  
#line 823 
  spin_unlock_bh_3(lock);
  
#line 824 
  return;
}


#line 827  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_lock_bh_81(spinlock_t *lock)
{
  
#line 831 
  ldv_spin_model_lock((char *)"chan_lock_of_ath_softc");
  
#line 833 
  spin_lock_bh_3(lock);
  
#line 834 
  return;
}


#line 837  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_unlock_bh_82_0(spinlock_t *lock)
{
  
#line 841 
  ldv_spin_model_unlock((char *)"chan_lock_of_ath_softc");
  
#line 843 
  spin_unlock_bh_3(lock);
  
#line 844 
  return;
}


#line 847  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_unlock_bh_83(spinlock_t *lock)
{
  
#line 851 
  ldv_spin_model_unlock((char *)"chan_lock_of_ath_softc");
  
#line 853 
  spin_unlock_bh_3(lock);
  
#line 854 
  return;
}


#line 857  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_unlock_bh_84_0(spinlock_t *lock)
{
  
#line 861 
  ldv_spin_model_unlock((char *)"chan_lock_of_ath_softc");
  
#line 863 
  spin_unlock_bh_3(lock);
  
#line 864 
  return;
}


#line 867  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static int ldv_mod_timer_85(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2)
{
  int tmp;
  
#line 871 
  tmp = ldv_emg_mod_timer(ldv_func_arg1,ldv_func_arg2);
  
#line 871 
  return tmp;
}


#line 875  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_lock_bh_86(spinlock_t *lock)
{
  
#line 879 
  ldv_spin_model_lock((char *)"chan_lock_of_ath_softc");
  
#line 881 
  spin_lock_bh_3(lock);
  
#line 882 
  return;
}


#line 885  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_unlock_bh_87(spinlock_t *lock)
{
  
#line 889 
  ldv_spin_model_unlock((char *)"chan_lock_of_ath_softc");
  
#line 891 
  spin_unlock_bh_3(lock);
  
#line 892 
  return;
}


#line 895  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_lock_bh_88(spinlock_t *lock)
{
  
#line 899 
  ldv_spin_model_lock((char *)"chan_lock_of_ath_softc");
  
#line 901 
  spin_lock_bh_3(lock);
  
#line 902 
  return;
}


#line 905  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_unlock_bh_89(spinlock_t *lock)
{
  
#line 909 
  ldv_spin_model_unlock((char *)"chan_lock_of_ath_softc");
  
#line 911 
  spin_unlock_bh_3(lock);
  
#line 912 
  return;
}


#line 915  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_unlock_bh_90(spinlock_t *lock)
{
  
#line 919 
  ldv_spin_model_unlock((char *)"chan_lock_of_ath_softc");
  
#line 921 
  spin_unlock_bh_3(lock);
  
#line 922 
  return;
}


#line 925  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_lock_bh_91(spinlock_t *lock)
{
  
#line 929 
  ldv_spin_model_lock((char *)"chan_lock_of_ath_softc");
  
#line 931 
  spin_lock_bh_3(lock);
  
#line 932 
  return;
}


#line 935  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_unlock_bh_92(spinlock_t *lock)
{
  
#line 939 
  ldv_spin_model_unlock((char *)"chan_lock_of_ath_softc");
  
#line 941 
  spin_unlock_bh_3(lock);
  
#line 942 
  return;
}


#line 945  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_lock_bh_93(spinlock_t *lock)
{
  
#line 949 
  ldv_spin_model_lock((char *)"chan_lock_of_ath_softc");
  
#line 951 
  spin_lock_bh_3(lock);
  
#line 952 
  return;
}


#line 955  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_unlock_bh_94(spinlock_t *lock)
{
  
#line 959 
  ldv_spin_model_unlock((char *)"chan_lock_of_ath_softc");
  
#line 961 
  spin_unlock_bh_3(lock);
  
#line 962 
  return;
}


#line 965  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static int ldv_mod_timer_95(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2)
{
  int tmp;
  
#line 969 
  tmp = ldv_emg_mod_timer(ldv_func_arg1,ldv_func_arg2);
  
#line 969 
  return tmp;
}


#line 973  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static int ldv_mod_timer_96(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2)
{
  int tmp;
  
#line 977 
  tmp = ldv_emg_mod_timer(ldv_func_arg1,ldv_func_arg2);
  
#line 977 
  return tmp;
}


#line 981  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static int ldv_mod_timer_97(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2)
{
  int tmp;
  
#line 985 
  tmp = ldv_emg_mod_timer(ldv_func_arg1,ldv_func_arg2);
  
#line 985 
  return tmp;
}


#line 989  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_lock_bh_98(spinlock_t *lock)
{
  
#line 993 
  ldv_spin_model_lock((char *)"chan_lock_of_ath_softc");
  
#line 995 
  spin_lock_bh_3(lock);
  
#line 996 
  return;
}


#line 999  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_unlock_bh_99(spinlock_t *lock)
{
  
#line 1003 
  ldv_spin_model_unlock((char *)"chan_lock_of_ath_softc");
  
#line 1005 
  spin_unlock_bh_3(lock);
  
#line 1006 
  return;
}


#line 1009  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_unlock_bh_100(spinlock_t *lock)
{
  
#line 1013 
  ldv_spin_model_unlock((char *)"chan_lock_of_ath_softc");
  
#line 1015 
  spin_unlock_bh_3(lock);
  
#line 1016 
  return;
}


#line 1019  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_unlock_bh_101(spinlock_t *lock)
{
  
#line 1023 
  ldv_spin_model_unlock((char *)"chan_lock_of_ath_softc");
  
#line 1025 
  spin_unlock_bh_3(lock);
  
#line 1026 
  return;
}


#line 1029  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_lock_bh_102(spinlock_t *lock)
{
  
#line 1033 
  ldv_spin_model_lock((char *)"chan_lock_of_ath_softc");
  
#line 1035 
  spin_lock_bh_3(lock);
  
#line 1036 
  return;
}


#line 1039  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_unlock_bh_103(spinlock_t *lock)
{
  
#line 1043 
  ldv_spin_model_unlock((char *)"chan_lock_of_ath_softc");
  
#line 1045 
  spin_unlock_bh_3(lock);
  
#line 1046 
  return;
}


#line 1049  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_mutex_lock_104(struct mutex *ldv_func_arg1)
{
  
#line 1053 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1054 
  return;
}


#line 1057  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_mutex_unlock_105(struct mutex *ldv_func_arg1)
{
  
#line 1061 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1062 
  return;
}


#line 1065  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static int ldv_del_timer_sync_106(struct timer_list *ldv_func_arg1)
{
  int tmp;
  
#line 1069 
  tmp = ldv_emg_del_timer_sync(ldv_func_arg1);
  
#line 1069 
  return tmp;
}


#line 1073  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_lock_bh_107(spinlock_t *lock)
{
  
#line 1077 
  ldv_spin_model_lock((char *)"sc_pcu_lock_of_ath_softc");
  
#line 1079 
  spin_lock_bh_3(lock);
  
#line 1080 
  return;
}


#line 1083  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv___ldv_spin_lock_108(spinlock_t *ldv_func_arg1)
{
  
#line 1087 
  ldv_spin_model_lock((char *)"sc_pm_lock_of_ath_softc");
  
#line 1089 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 1090 
  return;
}


#line 1093  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_unlock_irqrestore_109(spinlock_t *lock, unsigned long flags)
{
  
#line 1097 
  ldv_spin_model_unlock((char *)"sc_pm_lock_of_ath_softc");
  
#line 1099 
  spin_unlock_irqrestore_4(lock,flags);
  
#line 1100 
  return;
}


#line 1103  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_unlock_bh_110(spinlock_t *lock)
{
  
#line 1107 
  ldv_spin_model_unlock((char *)"sc_pcu_lock_of_ath_softc");
  
#line 1109 
  spin_unlock_bh_3(lock);
  
#line 1110 
  return;
}


#line 1113  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_lock_bh_111(spinlock_t *lock)
{
  
#line 1117 
  ldv_spin_model_lock((char *)"sc_pcu_lock_of_ath_softc");
  
#line 1119 
  spin_lock_bh_3(lock);
  
#line 1120 
  return;
}


#line 1123  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_channel.c.aux"
static void ldv_spin_unlock_bh_112(spinlock_t *lock)
{
  
#line 1127 
  ldv_spin_model_unlock((char *)"sc_pcu_lock_of_ath_softc");
  
#line 1129 
  spin_unlock_bh_3(lock);
  
#line 1130 
  return;
}


#line 405  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
int snprintf(char *, size_t, char const * , ...);


#line 355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_bh_4(spinlock_t *lock)
{
  
#line 357 
  _raw_spin_lock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 358 
  return;
}


#line 383 
static void ldv_spin_lock_bh_75_0(spinlock_t *lock);


#line 387 
static void ldv_spin_lock_bh_79_0(spinlock_t *lock);


#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_bh_4(spinlock_t *lock)
{
  
#line 406 
  _raw_spin_unlock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 407 
  return;
}


#line 432 
static void ldv_spin_unlock_bh_76_1(spinlock_t *lock);


#line 436 
static void ldv_spin_unlock_bh_80_0(spinlock_t *lock);


#line 450  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_irqrestore_5(spinlock_t *lock, unsigned long flags)
{
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
  }
  
#line 452 
  _raw_spin_unlock_irqrestore(& lock->__anonCompField_spinlock_18.rlock,flags);
  
#line 453 
  return;
}


#line 482 
static void ldv_spin_unlock_irqrestore_73_1(spinlock_t *lock, unsigned long flags);


#line 486 
static void ldv_spin_unlock_irqrestore_74(spinlock_t *lock, unsigned long flags);


#line 70  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_gpio.c.aux"
static void ldv___ldv_spin_lock_72_1(spinlock_t *ldv_func_arg1);


#line 173  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
static int ldv_mod_timer_77(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2);


#line 177 
static int ldv_mod_timer_78_0(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2);


#line 181 
static int ldv_mod_timer_82(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2);


#line 232 
static int ldv_del_timer_sync_81(struct timer_list *ldv_func_arg1);


#line 236 
static int ldv_del_timer_sync_83(struct timer_list *ldv_func_arg1);


#line 240 
static int ldv_del_timer_sync_84(struct timer_list *ldv_func_arg1);


#line 244 
static int ldv_del_timer_sync_85(struct timer_list *ldv_func_arg1);


#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
__inline static char const *kobject_name(struct kobject const *kobj)
{
  char const *__retres;
  
#line 89 
  __retres = kobj->name;
  
#line 89 
  return __retres;
}


#line 833  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static char const *dev_name(struct device const *dev)
{
  char const *__retres;
  char const *tmp;
  
#line 836 
  if (dev->init_name != (char const *)0) {
    
#line 837 
    __retres = dev->init_name;
    
#line 837 
    goto return_label;
  }
  else ;
  
#line 839 
  tmp = kobject_name(& dev->kobj);
  
#line 839 
  __retres = tmp;
  return_label: 
#line 839 
                return __retres;
}


#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/leds.h"
int led_classdev_register(struct device *, struct led_classdev *);


#line 110 
void led_classdev_unregister(struct led_classdev *);


#line 3292  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
__inline static struct device *wiphy_dev(struct wiphy *wiphy)
{
  struct device *__retres;
  
#line 3294 
  __retres = wiphy->dev.parent;
  
#line 3294 
  return __retres;
}


#line 3303  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
__inline static char const *wiphy_name(struct wiphy const *wiphy)
{
  char const *tmp;
  
#line 3305 
  tmp = dev_name(& wiphy->dev);
  
#line 3305 
  return tmp;
}


#line 4257 
void wiphy_rfkill_set_hw_state(struct wiphy *, bool);


#line 4263 
void wiphy_rfkill_start_polling(struct wiphy *);


#line 3547  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
char const *__ieee80211_get_radio_led_name(struct ieee80211_hw *);


#line 3629  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
__inline static char const *ieee80211_get_radio_led_name(struct ieee80211_hw *hw)
{
  char const *tmp;
  
#line 3632 
  tmp = __ieee80211_get_radio_led_name(hw);
  
#line 3632 
  return tmp;
}


#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/btcoex.h"
void ath9k_hw_btcoex_init_scheme(struct ath_hw *);


#line 124 
void ath9k_hw_btcoex_init_2wire(struct ath_hw *);


#line 125 
void ath9k_hw_btcoex_init_3wire(struct ath_hw *);


#line 126 
void ath9k_hw_btcoex_init_mci(struct ath_hw *);


#line 127 
void ath9k_hw_init_btcoex_hw(struct ath_hw *, int);


#line 128 
void ath9k_hw_btcoex_set_weight(struct ath_hw *, u32, u32, enum ath_stomp_type);


#line 132 
void ath9k_hw_btcoex_disable(struct ath_hw *);


#line 133 
void ath9k_hw_btcoex_bt_stomp(struct ath_hw *, enum ath_stomp_type);


#line 1023  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
u32 ath9k_hw_gpio_get(struct ath_hw *, u32);


#line 1024 
void ath9k_hw_cfg_output(struct ath_hw *, u32, u32);


#line 1026 
void ath9k_hw_set_gpio(struct ath_hw *, u32, u32);


#line 1027 
void ath9k_hw_request_gpio(struct ath_hw *, u32, char const *);


#line 1153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
__inline static bool ath9k_hw_mci_is_enabled(struct ath_hw *ah)
{
  bool __retres;
  
#line 1155 
  __retres = (_Bool)(((int)ah->common.btcoex_enabled != 0 && (ah->caps.hw_caps & 32768U) != 0U) != 0);
  
#line 1155 
  return __retres;
}


#line 1159 
void ath9k_hw_btcoex_enable(struct ath_hw *);


#line 1161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
__inline static enum ath_btcoex_scheme ath9k_hw_get_btcoex_scheme(struct ath_hw *ah)
{
  enum ath_btcoex_scheme __retres;
  
#line 1163 
  __retres = ah->btcoex_hw.scheme;
  
#line 1163 
  return __retres;
}


#line 309  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ar9003_mci.h"
u32 ar9003_mci_state(struct ath_hw *, u32);


#line 153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mci.h"
void ath_mci_flush_profile(struct ath_mci_profile *mci);


#line 154 
int ath_mci_setup(struct ath_softc *sc);


#line 155 
void ath_mci_cleanup(struct ath_softc *sc);


#line 156 
void ath_mci_intr(struct ath_softc *sc);


#line 157 
void ath9k_mci_update_rssi(struct ath_softc *sc);


#line 765  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
void ath9k_btcoex_timer_resume(struct ath_softc *sc);


#line 766 
void ath9k_btcoex_timer_pause(struct ath_softc *sc);


#line 767 
void ath9k_btcoex_handle_interrupt(struct ath_softc *sc, u32 status);


#line 769 
void ath9k_btcoex_stop_gen_timer(struct ath_softc *sc);


#line 1084 
void ath9k_rfkill_poll_state(struct ieee80211_hw *hw);


#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/gpio.c"
static void ath_led_brightness(struct led_classdev *led_cdev, enum led_brightness brightness)
{
  struct ath_softc *tmp;
  {
    
#line 27 
    struct led_classdev const *__mptr = (struct led_classdev const *)led_cdev;
    
#line 27 
    tmp = (struct ath_softc *)__mptr + 18446744073709539488U;
  }
  
#line 27 
  struct ath_softc *sc = tmp;
  
#line 28 
  u32 val = (unsigned int)(brightness == (unsigned int)LED_OFF);
  
#line 30 
  if ((int)(sc->sc_ah)->config.led_active_high != 0) 
#line 31 
                                                     val = (unsigned int)(val == 0U); else ;
  
#line 33 
  ath9k_hw_set_gpio(sc->sc_ah,(unsigned int)(sc->sc_ah)->led_pin,val);
  
#line 34 
  return;
}


#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/gpio.c"
void ath_deinit_leds(struct ath_softc *sc)
{
  
#line 38 
  if (! sc->led_registered) 
#line 39 
                            goto return_label; else ;
  
#line 41 
  ath_led_brightness(& sc->led_cdev,(enum led_brightness)LED_OFF);
  
#line 42 
  led_classdev_unregister(& sc->led_cdev);
  return_label: 
#line 43 
                return;
}


#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/gpio.c"
void ath_init_leds(struct ath_softc *sc)
{
  int ret;
  char const *tmp;
  struct device *tmp_0;
  
#line 49 
  if ((sc->sc_ah)->hw_version.macVersion == 20U) 
#line 50 
                                                 goto return_label; else ;
  
#line 52 
  if (ath9k_led_blink == 0) 
#line 53 
                            sc->led_cdev.default_trigger = ieee80211_get_radio_led_name(sc->hw); else ;
  
#line 57 
  tmp = wiphy_name((struct wiphy const *)(sc->hw)->wiphy);
  
#line 56 
  ;
  
#line 56 
  snprintf((char *)(& sc->led_name),32UL,"ath9k-%s",tmp);
  
#line 58 
  sc->led_cdev.name = (char const *)(& sc->led_name);
  
#line 59 
  sc->led_cdev.brightness_set = & ath_led_brightness;
  
#line 61 
  ;
  
#line 61 
  tmp_0 = wiphy_dev((sc->hw)->wiphy);
  
#line 61 
  ret = led_classdev_register(tmp_0,& sc->led_cdev);
  
#line 62 
  if (ret < 0) 
#line 63 
               goto return_label; else ;
  
#line 65 
  sc->led_registered = (_Bool)1;
  return_label: 
#line 66 
                return;
}


#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/gpio.c"
void ath_fill_led_pin(struct ath_softc *sc)
{
  
#line 70 
  struct ath_hw *ah = sc->sc_ah;
  
#line 72 
  if (ah->hw_version.macVersion == 20U) 
#line 73 
                                        goto return_label; else ;
  
#line 75 
  if (ah->led_pin >= 0) {
    unsigned int tmp;
    
#line 76 
    if (ah->hw_version.macVersion > 1023U) 
#line 76 
                                           tmp = 15U; else 
#line 76 
                                                           tmp = 4294967295U;
    
#line 76 
    ;
    
#line 76 
    if (((unsigned int)(1 << ah->led_pin) & tmp) == 0U) 
#line 77 
                                                        ath9k_hw_request_gpio(ah,(unsigned int)ah->led_pin,"ath9k-led"); else ;
    
#line 78 
    goto return_label;
  }
  else ;
  
#line 81 
  if (ah->hw_version.macVersion == 384U) 
#line 82 
                                         ah->led_pin = 8;
  else 
    
#line 83 
    if ((sc->sc_ah)->hw_version.macVersion == 576U) 
#line 84 
                                                    ah->led_pin = 6;
    else 
      
#line 85 
      if ((sc->sc_ah)->hw_version.macVersion == 448U) 
#line 86 
                                                      ah->led_pin = 10;
      else 
        
#line 87 
        if ((sc->sc_ah)->hw_version.macVersion == 640U || (sc->sc_ah)->hw_version.macVersion == 704U) 
          
#line 88 
          ah->led_pin = 4; else 
#line 90 
                                ah->led_pin = 1;
  
#line 93 
  ath9k_hw_cfg_output(ah,(unsigned int)ah->led_pin,0U);
  
#line 96 
  ath9k_hw_set_gpio(ah,(unsigned int)ah->led_pin,(unsigned int)(! ah->config.led_active_high));
  return_label: 
#line 97 
                return;
}


#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/gpio.c"
static bool ath_is_rfkill_set(struct ath_softc *sc)
{
  bool is_blocked;
  u32 tmp;
  
#line 106 
  struct ath_hw *ah = sc->sc_ah;
  
#line 109 
  ath9k_ps_wakeup(sc);
  
#line 110 
  tmp = ath9k_hw_gpio_get(ah,ah->rfkill_gpio);
  
#line 110 
  is_blocked = (_Bool)(tmp == ah->rfkill_polarity);
  
#line 112 
  ath9k_ps_restore(sc);
  
#line 114 
  return is_blocked;
}


#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/gpio.c"
void ath9k_rfkill_poll_state(struct ieee80211_hw *hw)
{
  bool tmp;
  
#line 119 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 120 
  tmp = ath_is_rfkill_set(sc);
  
#line 120 
  bool blocked = (_Bool)((int)tmp != 0);
  
#line 122 
  wiphy_rfkill_set_hw_state(hw->wiphy,(_Bool)((bool)((int)blocked) != 0));
  
#line 123 
  return;
}


#line 125  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/gpio.c"
void ath_start_rfkill_poll(struct ath_softc *sc)
{
  
#line 127 
  struct ath_hw *ah = sc->sc_ah;
  
#line 129 
  if ((ah->caps.hw_caps & 2U) != 0U) 
#line 130 
                                     wiphy_rfkill_start_polling((sc->hw)->wiphy); else ;
  
#line 131 
  return;
}


#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/gpio.c"
static void ath_detect_bt_priority(struct ath_softc *sc)
{
  u32 tmp;
  int tmp_4;
  
#line 144 
  struct ath_btcoex *btcoex = & sc->btcoex;
  
#line 145 
  struct ath_hw *ah = sc->sc_ah;
  
#line 147 
  tmp = ath9k_hw_gpio_get(sc->sc_ah,(unsigned int)ah->btcoex_hw.btpriority_gpio);
  
#line 147 
  if (tmp != 0U) 
#line 148 
                 btcoex->bt_priority_cnt += 1U; else ;
  {
    unsigned long __dummy;
    unsigned long volatile __dummy2;
    
#line 150 
    tmp_4 = 1;
  }
  
#line 150 
  if (tmp_4 != 0) {
    int tmp_5;
    {
      unsigned long __dummy_0;
      unsigned long __dummy2_0;
      
#line 150 
      tmp_5 = 1;
    }
    
#line 150 
    if (tmp_5 != 0) {
      unsigned long tmp_6;
      
#line 150 
      tmp_6 = msecs_to_jiffies(1000U);
      
#line 150 
      ;
      
#line 150 
      if ((long)((btcoex->bt_priority_time + tmp_6) - jiffies) < 0L) {
        
#line 152 
        set_bit(0L,(unsigned long volatile *)(& btcoex->op_flags));
        
#line 153 
        set_bit(1L,(unsigned long volatile *)(& btcoex->op_flags));
        
#line 155 
        if (btcoex->bt_priority_cnt > 14U) {
          struct ath_common *tmp_1;
          
#line 156 
          tmp_1 = ath9k_hw_common(sc->sc_ah);
          
#line 156 
          ;
          
#line 156 
          if ((tmp_1->debug_mask & 4096) != 0) {
            struct ath_common *tmp_0;
            
#line 156 
            tmp_0 = ath9k_hw_common(sc->sc_ah);
            
#line 156 
            ath_printk("\001",(struct ath_common const *)tmp_0,"BT scan detected\n");
          }
          else ;
          
#line 158 
          set_bit(0L,(unsigned long volatile *)(& btcoex->op_flags));
          
#line 159 
          set_bit(1L,(unsigned long volatile *)(& btcoex->op_flags));
        }
        else 
          
#line 160 
          if (btcoex->bt_priority_cnt > 2U) {
            struct ath_common *tmp_3;
            
#line 161 
            tmp_3 = ath9k_hw_common(sc->sc_ah);
            
#line 161 
            ;
            
#line 161 
            if ((tmp_3->debug_mask & 4096) != 0) {
              struct ath_common *tmp_2;
              
#line 161 
              tmp_2 = ath9k_hw_common(sc->sc_ah);
              
#line 161 
              ath_printk("\001",(struct ath_common const *)tmp_2,"BT priority traffic detected\n");
            }
            else ;
            
#line 163 
            set_bit(0L,(unsigned long volatile *)(& btcoex->op_flags));
          }
          else ;
        
#line 166 
        btcoex->bt_priority_cnt = 0U;
        
#line 167 
        btcoex->bt_priority_time = jiffies;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 169 
  return;
}


#line 171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/gpio.c"
static void ath_mci_ftp_adjust(struct ath_softc *sc)
{
  
#line 173 
  struct ath_btcoex *btcoex = & sc->btcoex;
  
#line 174 
  struct ath_mci_profile *mci = & btcoex->mci;
  
#line 175 
  struct ath_hw *ah = sc->sc_ah;
  
#line 177 
  if (btcoex->bt_wait_time > 100U) {
    u32 tmp;
    
#line 178 
    tmp = ar9003_mci_state(ah,22U);
    
#line 178 
    if (tmp != 0U) 
      
#line 178 
      if ((unsigned int)mci->num_pan != 0U || (unsigned int)mci->num_other_acl != 0U) 
        
#line 180 
        ah->btcoex_hw.mci.stomp_ftp = (unsigned char)(sc->rx.num_pkts <= 4U); else 
                                                                    
#line 183 
                                                                    ah->btcoex_hw.mci.stomp_ftp = (unsigned char)0U;
    else 
#line 183 
         ah->btcoex_hw.mci.stomp_ftp = (unsigned char)0U;
    
#line 184 
    btcoex->bt_wait_time = 0U;
    
#line 185 
    sc->rx.num_pkts = 0U;
  }
  else ;
  
#line 187 
  return;
}


#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/gpio.c"
static void ath_btcoex_period_timer(unsigned long data)
{
  enum ath_stomp_type stomp_type;
  u32 timer_period;
  unsigned long flags;
  unsigned long tmp_1;
  
#line 196 
  struct ath_softc *sc = (struct ath_softc *)data;
  
#line 197 
  struct ath_hw *ah = sc->sc_ah;
  
#line 198 
  struct ath_btcoex *btcoex = & sc->btcoex;
  
#line 203 
  ldv___ldv_spin_lock_72_1(& sc->sc_pm_lock);
  
#line 204 
  if ((sc->sc_ah)->power_mode == (unsigned int)ATH9K_PM_NETWORK_SLEEP) {
    
#line 205 
    btcoex->bt_wait_time += btcoex->btcoex_period;
    
#line 206 
    ldv_spin_unlock_irqrestore_73_1(& sc->sc_pm_lock,flags);
    
#line 207 
    goto skip_hw_wakeup;
  }
  else ;
  
#line 209 
  ldv_spin_unlock_irqrestore_74(& sc->sc_pm_lock,flags);
  
#line 211 
  ath9k_ps_wakeup(sc);
  
#line 212 
  ldv_spin_lock_bh_75_0(& btcoex->btcoex_lock);
  
#line 214 
  if ((ah->caps.hw_caps & 32768U) != 0U) {
    
#line 215 
    ath9k_mci_update_rssi(sc);
    
#line 216 
    ath_mci_ftp_adjust(sc);
  }
  else ;
  
#line 219 
  if ((ah->caps.hw_caps & 32768U) == 0U) 
#line 220 
                                         ath_detect_bt_priority(sc); else ;
  
#line 222 
  stomp_type = (enum ath_stomp_type)btcoex->bt_stomp_type;
  
#line 223 
  timer_period = btcoex->btcoex_no_stomp;
  
#line 225 
  if ((ah->caps.hw_caps & 32768U) == 0U) {
    int tmp;
    
#line 226 
    tmp = constant_test_bit(1L,(unsigned long const volatile *)(& btcoex->op_flags));
    
#line 226 
    if (tmp != 0) {
      
#line 227 
      stomp_type = ATH_BTCOEX_STOMP_ALL;
      
#line 228 
      timer_period = btcoex->btscan_no_stomp;
    }
    else ;
  }
  else 
    
#line 230 
    if ((unsigned int)btcoex->stomp_audio > 4U) {
      
#line 231 
      stomp_type = ATH_BTCOEX_STOMP_AUDIO;
      
#line 232 
      btcoex->stomp_audio = (unsigned char)0U;
    }
    else ;
  
#line 235 
  ath9k_hw_btcoex_bt_stomp(ah,stomp_type);
  
#line 236 
  ath9k_hw_btcoex_enable(ah);
  
#line 238 
  ldv_spin_unlock_bh_76_1(& btcoex->btcoex_lock);
  
#line 240 
  if (btcoex->btcoex_period != btcoex->btcoex_no_stomp) {
    unsigned long tmp_0;
    
#line 241 
    tmp_0 = msecs_to_jiffies(timer_period);
    
#line 241 
    ;
    
#line 241 
    ;
    
#line 241 
    ldv_mod_timer_77(& btcoex->no_stomp_timer,tmp_0 + jiffies);
  }
  else ;
  
#line 244 
  ath9k_ps_restore(sc);
  skip_hw_wakeup: 
#line 246 
  ;
  
#line 247 
  tmp_1 = msecs_to_jiffies(btcoex->btcoex_period);
  
#line 247 
  ;
  
#line 247 
  ;
  
#line 247 
  ldv_mod_timer_78_0(& btcoex->period_timer,tmp_1 + jiffies);
  
#line 249 
  return;
}


#line 255  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/gpio.c"
static void ath_btcoex_no_stomp_timer(unsigned long arg)
{
  
#line 257 
  struct ath_softc *sc = (struct ath_softc *)arg;
  
#line 258 
  struct ath_hw *ah = sc->sc_ah;
  
#line 259 
  struct ath_btcoex *btcoex = & sc->btcoex;
  
#line 261 
  ath9k_ps_wakeup(sc);
  
#line 262 
  ldv_spin_lock_bh_79_0(& btcoex->btcoex_lock);
  
#line 264 
  if (btcoex->bt_stomp_type == 1) 
#line 264 
                                  goto _LOR;
  else 
    
#line 264 
    if ((ah->caps.hw_caps & 32768U) == 0U) {
      int tmp;
      
#line 265 
      tmp = constant_test_bit(1L,(unsigned long const volatile *)(& btcoex->op_flags));
      
#line 265 
      if (tmp != 0) _LOR: 
#line 267 
                          ath9k_hw_btcoex_bt_stomp(ah,(enum ath_stomp_type)ATH_BTCOEX_STOMP_NONE); else 
                                                                    
#line 264 
                                                                    goto _LAND;
    }
    else {
      _LAND: 
#line 268 
      ;
      
#line 268 
      if (btcoex->bt_stomp_type == 0) 
#line 269 
                                      ath9k_hw_btcoex_bt_stomp(ah,(enum ath_stomp_type)ATH_BTCOEX_STOMP_LOW); else ;
    }
  
#line 271 
  ath9k_hw_btcoex_enable(ah);
  
#line 272 
  ldv_spin_unlock_bh_80_0(& btcoex->btcoex_lock);
  
#line 273 
  ath9k_ps_restore(sc);
  
#line 274 
  return;
}


#line 276  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/gpio.c"
static void ath_init_btcoex_timer(struct ath_softc *sc)
{
  
#line 278 
  struct ath_btcoex *btcoex = & sc->btcoex;
  
#line 280 
  btcoex->btcoex_period = 45U;
  
#line 281 
  btcoex->btcoex_no_stomp = (btcoex->btcoex_period * 45U) / 100U;
  
#line 283 
  btcoex->btscan_no_stomp = (btcoex->btcoex_period * 10U) / 100U;
  
#line 285 
  btcoex->bt_stomp_type = 1;
  {
    struct lock_class_key __key;
    
#line 287 
    init_timer_key(& btcoex->period_timer,0U,"((&btcoex->period_timer))",& __key);
  }
  
#line 287 
  btcoex->period_timer.function = & ath_btcoex_period_timer;
  
#line 287 
  btcoex->period_timer.data = (unsigned long)sc;
  {
    struct lock_class_key __key_0;
    
#line 289 
    init_timer_key(& btcoex->no_stomp_timer,0U,"((&btcoex->no_stomp_timer))",& __key_0);
  }
  
#line 289 
  btcoex->no_stomp_timer.function = & ath_btcoex_no_stomp_timer;
  
#line 289 
  btcoex->no_stomp_timer.data = (unsigned long)sc;
  
#line 292 
  spinlock_check(& btcoex->btcoex_lock);
  {
    struct lock_class_key __key_1;
    
#line 292 
    __raw_spin_lock_init(& btcoex->btcoex_lock.__anonCompField_spinlock_18.rlock,"&(&btcoex->btcoex_lock)->rlock",& __key_1);
  }
  
#line 294 
  return;
}


#line 298  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/gpio.c"
void ath9k_btcoex_timer_resume(struct ath_softc *sc)
{
  enum ath_btcoex_scheme tmp;
  struct ath_common *tmp_2;
  
#line 300 
  struct ath_btcoex *btcoex = & sc->btcoex;
  
#line 301 
  struct ath_hw *ah = sc->sc_ah;
  
#line 303 
  tmp = ath9k_hw_get_btcoex_scheme(ah);
  
#line 303 
  if (tmp != (unsigned int)ATH_BTCOEX_CFG_3WIRE) {
    enum ath_btcoex_scheme tmp_0;
    
#line 303 
    tmp_0 = ath9k_hw_get_btcoex_scheme(ah);
    
#line 303 
    if (tmp_0 != (unsigned int)ATH_BTCOEX_CFG_MCI) 
#line 305 
                                                   goto return_label; else ;
  }
  else ;
  
#line 307 
  tmp_2 = ath9k_hw_common(ah);
  
#line 307 
  ;
  
#line 307 
  if ((tmp_2->debug_mask & 4096) != 0) {
    struct ath_common *tmp_1;
    
#line 307 
    tmp_1 = ath9k_hw_common(ah);
    
#line 307 
    ath_printk("\001",(struct ath_common const *)tmp_1,"Starting btcoex timers\n");
  }
  else ;
  
#line 310 
  ldv_del_timer_sync_81(& btcoex->no_stomp_timer);
  
#line 312 
  btcoex->bt_priority_cnt = 0U;
  
#line 313 
  btcoex->bt_priority_time = jiffies;
  
#line 314 
  set_bit(0L,(unsigned long volatile *)(& btcoex->op_flags));
  
#line 315 
  set_bit(1L,(unsigned long volatile *)(& btcoex->op_flags));
  
#line 317 
  ldv_mod_timer_82(& btcoex->period_timer,jiffies);
  return_label: 
#line 318 
                return;
}


#line 323  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/gpio.c"
void ath9k_btcoex_timer_pause(struct ath_softc *sc)
{
  enum ath_btcoex_scheme tmp;
  struct ath_common *tmp_2;
  
#line 325 
  struct ath_btcoex *btcoex = & sc->btcoex;
  
#line 326 
  struct ath_hw *ah = sc->sc_ah;
  
#line 328 
  tmp = ath9k_hw_get_btcoex_scheme(ah);
  
#line 328 
  if (tmp != (unsigned int)ATH_BTCOEX_CFG_3WIRE) {
    enum ath_btcoex_scheme tmp_0;
    
#line 328 
    tmp_0 = ath9k_hw_get_btcoex_scheme(ah);
    
#line 328 
    if (tmp_0 != (unsigned int)ATH_BTCOEX_CFG_MCI) 
#line 330 
                                                   goto return_label; else ;
  }
  else ;
  
#line 332 
  tmp_2 = ath9k_hw_common(ah);
  
#line 332 
  ;
  
#line 332 
  if ((tmp_2->debug_mask & 4096) != 0) {
    struct ath_common *tmp_1;
    
#line 332 
    tmp_1 = ath9k_hw_common(ah);
    
#line 332 
    ath_printk("\001",(struct ath_common const *)tmp_1,"Stopping btcoex timers\n");
  }
  else ;
  
#line 334 
  ldv_del_timer_sync_83(& btcoex->period_timer);
  
#line 335 
  ldv_del_timer_sync_84(& btcoex->no_stomp_timer);
  return_label: 
#line 336 
                return;
}


#line 338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/gpio.c"
void ath9k_btcoex_stop_gen_timer(struct ath_softc *sc)
{
  
#line 340 
  struct ath_btcoex *btcoex = & sc->btcoex;
  
#line 342 
  ldv_del_timer_sync_85(& btcoex->no_stomp_timer);
  
#line 343 
  return;
}


#line 345  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/gpio.c"
u16 ath9k_btcoex_aggr_limit(struct ath_softc *sc, u32 max_4ms_framelen)
{
  
#line 347 
  struct ath_btcoex *btcoex = & sc->btcoex;
  
#line 348 
  struct ath_mci_profile *mci = & sc->btcoex.mci;
  
#line 349 
  u16 aggr_limit = (unsigned short)0U;
  
#line 351 
  if (((sc->sc_ah)->caps.hw_caps & 32768U) != 0U && (unsigned int)mci->aggr_limit != 0U) 
    
#line 352 
    aggr_limit = (unsigned short)((unsigned int)mci->aggr_limit * max_4ms_framelen >> 4);
  else {
    int tmp_1;
    
#line 353 
    tmp_1 = constant_test_bit(0L,(unsigned long const volatile *)(& btcoex->op_flags));
    
#line 353 
    if (tmp_1 != 0) {
      unsigned int tmp_0;
      {
        u32 tmp;
        
#line 354 
        u32 _min1 = (max_4ms_framelen * 3U) / 8U;
        
#line 354 
        unsigned int _min2 = 65535U;
        
#line 354 
        if (_min1 < _min2) 
#line 354 
                           tmp = _min1; else 
#line 354 
                                             tmp = _min2;
        
#line 354 
        tmp_0 = tmp;
      }
      
#line 354 
      aggr_limit = (unsigned short)tmp_0;
    }
    else ;
  }
  
#line 357 
  return aggr_limit;
}


#line 360  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/gpio.c"
void ath9k_btcoex_handle_interrupt(struct ath_softc *sc, u32 status)
{
  
#line 362 
  if ((status & 512U) != 0U) 
#line 363 
                             ath_mci_intr(sc); else ;
  
#line 364 
  return;
}


#line 366  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/gpio.c"
void ath9k_start_btcoex(struct ath_softc *sc)
{
  
#line 368 
  struct ath_hw *ah = sc->sc_ah;
  
#line 370 
  if ((int)ah->btcoex_hw.enabled != 0) 
#line 372 
                                       goto return_label;
  else {
    enum ath_btcoex_scheme tmp;
    
#line 370 
    tmp = ath9k_hw_get_btcoex_scheme(ah);
    
#line 370 
    if (tmp == (unsigned int)ATH_BTCOEX_CFG_NONE) 
#line 372 
                                                  goto return_label; else ;
  }
  
#line 374 
  if ((ah->caps.hw_caps & 32768U) == 0U) 
#line 375 
                                         ath9k_hw_btcoex_set_weight(ah,65365U,43176U,(enum ath_stomp_type)ATH_BTCOEX_STOMP_ALL); else 
                                                                    
#line 378 
                                                                    ath9k_hw_btcoex_set_weight(ah,0U,0U,(enum ath_stomp_type)ATH_BTCOEX_STOMP_NONE);
  
#line 380 
  ath9k_hw_btcoex_enable(ah);
  
#line 381 
  ath9k_btcoex_timer_resume(sc);
  return_label: 
#line 382 
                return;
}


#line 384  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/gpio.c"
void ath9k_stop_btcoex(struct ath_softc *sc)
{
  
#line 386 
  struct ath_hw *ah = sc->sc_ah;
  
#line 388 
  if (! ah->btcoex_hw.enabled) 
#line 390 
                               goto return_label;
  else {
    enum ath_btcoex_scheme tmp;
    
#line 388 
    tmp = ath9k_hw_get_btcoex_scheme(ah);
    
#line 388 
    if (tmp == (unsigned int)ATH_BTCOEX_CFG_NONE) 
#line 390 
                                                  goto return_label; else ;
  }
  
#line 392 
  ath9k_btcoex_timer_pause(sc);
  
#line 393 
  ath9k_hw_btcoex_disable(ah);
  
#line 395 
  if ((ah->caps.hw_caps & 32768U) != 0U) 
#line 396 
                                         ath_mci_flush_profile(& sc->btcoex.mci); else ;
  return_label: 
#line 397 
                return;
}


#line 399  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/gpio.c"
void ath9k_deinit_btcoex(struct ath_softc *sc)
{
  bool tmp;
  
#line 401 
  struct ath_hw *ah = sc->sc_ah;
  
#line 403 
  tmp = ath9k_hw_mci_is_enabled(ah);
  
#line 403 
  if ((int)tmp != 0) 
#line 404 
                     ath_mci_cleanup(sc); else ;
  
#line 405 
  return;
}


#line 407  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/gpio.c"
int ath9k_init_btcoex(struct ath_softc *sc)
{
  int __retres;
  struct ath_txq *txq;
  int r;
  enum ath_btcoex_scheme tmp;
  
#line 410 
  struct ath_hw *ah = sc->sc_ah;
  
#line 413 
  ath9k_hw_btcoex_init_scheme(ah);
  
#line 415 
  tmp = ath9k_hw_get_btcoex_scheme(sc->sc_ah);
  
#line 415 
  switch ((unsigned int)tmp) {
    case (unsigned int)0: 
#line 416 
    ;
    
#line 417 
    goto ldv_53530;
    case (unsigned int)1: 
#line 418 
    ;
    
#line 419 
    ath9k_hw_btcoex_init_2wire(sc->sc_ah);
    
#line 420 
    goto ldv_53530;
    case (unsigned int)2: 
#line 421 
    ;
    
#line 422 
    ath9k_hw_btcoex_init_3wire(sc->sc_ah);
    
#line 423 
    ath_init_btcoex_timer(sc);
    
#line 424 
    txq = sc->tx.txq_map[2];
    
#line 425 
    ath9k_hw_init_btcoex_hw(sc->sc_ah,(int)txq->axq_qnum);
    
#line 426 
    goto ldv_53530;
    case (unsigned int)3: 
#line 427 
    ;
    
#line 428 
    ath_init_btcoex_timer(sc);
    
#line 430 
    sc->btcoex.duty_cycle = 55U;
    
#line 431 
    INIT_LIST_HEAD(& sc->btcoex.mci.info);
    
#line 432 
    ath9k_hw_btcoex_init_mci(ah);
    
#line 434 
    r = ath_mci_setup(sc);
    
#line 435 
    if (r != 0) {
      
#line 436 
      __retres = r;
      
#line 436 
      goto return_label;
    }
    else ;
    
#line 438 
    goto ldv_53530;
    default: 
#line 439 
    ;
    {
      
#line 440 
      int __ret_warn_on = 1;
      
#line 440 
      if ((long)(__ret_warn_on != 0) != 0L) 
#line 440 
                                            warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/gpio.c",440); else ;
      
#line 440 
      long tmp_2 = (long)(__ret_warn_on != 0);
    }
    
#line 441 
    goto ldv_53530;
  }
  ldv_53530: 
#line 444 
  ;
  
#line 444 
  __retres = 0;
  return_label: 
#line 444 
                return __retres;
}


#line 447  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/gpio.c"
static int ath9k_dump_mci_btcoex(struct ath_softc *sc, u8 *buf, u32 size)
{
  int __retres;
  int i;
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  int tmp_4;
  int tmp_5;
  int tmp_6;
  int tmp_7;
  int tmp_8;
  int tmp_9;
  int tmp_10;
  int tmp_11;
  int tmp_12;
  int tmp_13;
  int tmp_14;
  int tmp_15;
  int tmp_16;
  int tmp_17;
  int tmp_18;
  int tmp_19;
  int tmp_20;
  int tmp_21;
  int tmp_22;
  
#line 449 
  struct ath_btcoex *btcoex = & sc->btcoex;
  
#line 450 
  struct ath_mci_profile *mci = & btcoex->mci;
  
#line 451 
  struct ath_hw *ah = sc->sc_ah;
  
#line 452 
  struct ath_btcoex_hw *btcoex_hw = & ah->btcoex_hw;
  
#line 453 
  u32 len = 0U;
  
#line 456 
  tmp = scnprintf((char *)(buf + len),(unsigned long)(size - len),"%20s : %10d\n",(char *)"Total BT profiles",((((int)mci->num_other_acl + (int)mci->num_a2dp) + (int)mci->num_hid) + (int)mci->num_pan) + (int)mci->num_sco);
  
#line 456 
  len = (unsigned int)tmp + len;
  
#line 457 
  tmp_0 = scnprintf((char *)(buf + len),(unsigned long)(size - len),"%20s : %10d\n",(char *)"MGMT",(int)mci->num_mgmt);
  
#line 457 
  len = (unsigned int)tmp_0 + len;
  
#line 458 
  tmp_1 = scnprintf((char *)(buf + len),(unsigned long)(size - len),"%20s : %10d\n",(char *)"SCO",(int)mci->num_sco);
  
#line 458 
  len = (unsigned int)tmp_1 + len;
  
#line 459 
  tmp_2 = scnprintf((char *)(buf + len),(unsigned long)(size - len),"%20s : %10d\n",(char *)"A2DP",(int)mci->num_a2dp);
  
#line 459 
  len = (unsigned int)tmp_2 + len;
  
#line 460 
  tmp_3 = scnprintf((char *)(buf + len),(unsigned long)(size - len),"%20s : %10d\n",(char *)"HID",(int)mci->num_hid);
  
#line 460 
  len = (unsigned int)tmp_3 + len;
  
#line 461 
  tmp_4 = scnprintf((char *)(buf + len),(unsigned long)(size - len),"%20s : %10d\n",(char *)"PAN",(int)mci->num_pan);
  
#line 461 
  len = (unsigned int)tmp_4 + len;
  
#line 462 
  tmp_5 = scnprintf((char *)(buf + len),(unsigned long)(size - len),"%20s : %10d\n",(char *)"ACL",(int)mci->num_other_acl);
  
#line 462 
  len = (unsigned int)tmp_5 + len;
  
#line 463 
  tmp_6 = scnprintf((char *)(buf + len),(unsigned long)(size - len),"%20s : %10d\n",(char *)"BDR",(int)mci->num_bdr);
  
#line 463 
  len = (unsigned int)tmp_6 + len;
  
#line 464 
  tmp_7 = scnprintf((char *)(buf + len),(unsigned long)(size - len),"%20s : %10d\n",(char *)"Aggr. Limit",(int)mci->aggr_limit);
  
#line 464 
  len = (unsigned int)tmp_7 + len;
  
#line 465 
  tmp_8 = scnprintf((char *)(buf + len),(unsigned long)(size - len),"%20s : %10d\n",(char *)"Stomp Type",btcoex->bt_stomp_type);
  
#line 465 
  len = (unsigned int)tmp_8 + len;
  
#line 466 
  tmp_9 = scnprintf((char *)(buf + len),(unsigned long)(size - len),"%20s : %10d\n",(char *)"BTCoex Period (msec)",btcoex->btcoex_period);
  
#line 466 
  len = (unsigned int)tmp_9 + len;
  
#line 467 
  tmp_10 = scnprintf((char *)(buf + len),(unsigned long)(size - len),"%20s : %10d\n",(char *)"Duty Cycle",btcoex->duty_cycle);
  
#line 467 
  len = (unsigned int)tmp_10 + len;
  
#line 468 
  tmp_11 = scnprintf((char *)(buf + len),(unsigned long)(size - len),"%20s : %10d\n",(char *)"BT Wait time",btcoex->bt_wait_time);
  
#line 468 
  len = (unsigned int)tmp_11 + len;
  
#line 469 
  tmp_12 = scnprintf((char *)(buf + len),(unsigned long)(size - len),"%20s : %10d\n",(char *)"Concurrent Tx",(int)btcoex_hw->mci.concur_tx);
  
#line 469 
  len = (unsigned int)tmp_12 + len;
  
#line 470 
  tmp_13 = scnprintf((char *)(buf + len),(unsigned long)(size - len),"%20s : %10d\n",(char *)"Concurrent RSSI cnt",btcoex->rssi_count);
  
#line 470 
  len = (unsigned int)tmp_13 + len;
  
#line 472 
  tmp_14 = scnprintf((char *)(buf + len),(unsigned long)(size - len),"BT Weights: ");
  
#line 472 
  len = (unsigned int)tmp_14 + len;
  
#line 473 
  i = 0;
  
#line 473 
  goto ldv_53549;
  ldv_53548: 
#line 474 
  ;
  
#line 474 
  tmp_15 = scnprintf((char *)(buf + len),(unsigned long)(size - len),"%08x ",btcoex_hw->bt_weight[i]);
  
#line 475 
  len = (unsigned int)tmp_15 + len;
  
#line 473 
  i += 1;
  ldv_53549: 
#line 474 
  ;
  
#line 473 
  if (i <= 3) 
#line 475 
              goto ldv_53548; else 
#line 478 
                                   goto ldv_53550;
  ldv_53550: 
#line 479 
  ;
  
#line 476 
  tmp_16 = scnprintf((char *)(buf + len),(unsigned long)(size - len),"\n");
  
#line 476 
  len = (unsigned int)tmp_16 + len;
  
#line 477 
  tmp_17 = scnprintf((char *)(buf + len),(unsigned long)(size - len),"WLAN Weights: ");
  
#line 477 
  len = (unsigned int)tmp_17 + len;
  
#line 478 
  i = 0;
  
#line 478 
  goto ldv_53552;
  ldv_53551: 
#line 479 
  ;
  
#line 479 
  tmp_18 = scnprintf((char *)(buf + len),(unsigned long)(size - len),"%08x ",btcoex_hw->wlan_weight[i]);
  
#line 480 
  len = (unsigned int)tmp_18 + len;
  
#line 478 
  i += 1;
  ldv_53552: 
#line 479 
  ;
  
#line 478 
  if (i <= 3) 
#line 480 
              goto ldv_53551; else 
#line 483 
                                   goto ldv_53553;
  ldv_53553: 
#line 484 
  ;
  
#line 481 
  tmp_19 = scnprintf((char *)(buf + len),(unsigned long)(size - len),"\n");
  
#line 481 
  len = (unsigned int)tmp_19 + len;
  
#line 482 
  tmp_20 = scnprintf((char *)(buf + len),(unsigned long)(size - len),"Tx Priorities: ");
  
#line 482 
  len = (unsigned int)tmp_20 + len;
  
#line 483 
  i = 0;
  
#line 483 
  goto ldv_53555;
  ldv_53554: 
#line 484 
  ;
  
#line 484 
  tmp_21 = scnprintf((char *)(buf + len),(unsigned long)(size - len),"%08x ",(int)btcoex_hw->tx_prio[i]);
  
#line 485 
  len = (unsigned int)tmp_21 + len;
  
#line 483 
  i += 1;
  ldv_53555: 
#line 484 
  ;
  
#line 483 
  if (i <= 4) 
#line 485 
              goto ldv_53554; else 
#line 488 
                                   goto ldv_53556;
  ldv_53556: 
#line 489 
  ;
  
#line 487 
  tmp_22 = scnprintf((char *)(buf + len),(unsigned long)(size - len),"\n");
  
#line 487 
  len = (unsigned int)tmp_22 + len;
  
#line 489 
  __retres = (int)len;
  
#line 489 
  return __retres;
}


#line 492  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/gpio.c"
static int ath9k_dump_legacy_btcoex(struct ath_softc *sc, u8 *buf, u32 size)
{
  int __retres;
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  
#line 495 
  struct ath_btcoex *btcoex = & sc->btcoex;
  
#line 496 
  u32 len = 0U;
  
#line 498 
  tmp = scnprintf((char *)(buf + len),(unsigned long)(size - len),"%20s : %10d\n",(char *)"Stomp Type",btcoex->bt_stomp_type);
  
#line 498 
  len = (unsigned int)tmp + len;
  
#line 499 
  tmp_0 = scnprintf((char *)(buf + len),(unsigned long)(size - len),"%20s : %10d\n",(char *)"BTCoex Period (msec)",btcoex->btcoex_period);
  
#line 499 
  len = (unsigned int)tmp_0 + len;
  
#line 500 
  tmp_1 = scnprintf((char *)(buf + len),(unsigned long)(size - len),"%20s : %10d\n",(char *)"Duty Cycle",btcoex->duty_cycle);
  
#line 500 
  len = (unsigned int)tmp_1 + len;
  
#line 501 
  tmp_2 = scnprintf((char *)(buf + len),(unsigned long)(size - len),"%20s : %10d\n",(char *)"BT Wait time",btcoex->bt_wait_time);
  
#line 501 
  len = (unsigned int)tmp_2 + len;
  
#line 503 
  __retres = (int)len;
  
#line 503 
  return __retres;
}


#line 506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/gpio.c"
int ath9k_dump_btcoex(struct ath_softc *sc, u8 *buf, u32 size)
{
  int __retres;
  bool tmp_1;
  
#line 508 
  tmp_1 = ath9k_hw_mci_is_enabled(sc->sc_ah);
  
#line 508 
  if ((int)tmp_1 != 0) {
    int tmp;
    
#line 509 
    tmp = ath9k_dump_mci_btcoex(sc,buf,size);
    
#line 509 
    __retres = tmp;
    
#line 509 
    goto return_label;
  }
  else {
    int tmp_0;
    
#line 511 
    tmp_0 = ath9k_dump_legacy_btcoex(sc,buf,size);
    
#line 511 
    __retres = tmp_0;
    
#line 511 
    goto return_label;
  }
  return_label: 
#line 508 
                return __retres;
}


#line 737  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_gpio.c.aux"
static void ldv___ldv_spin_lock_72_1(spinlock_t *ldv_func_arg1)
{
  
#line 741 
  ldv_spin_model_lock((char *)"sc_pm_lock_of_ath_softc");
  
#line 743 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 744 
  return;
}


#line 747  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_gpio.c.aux"
static void ldv_spin_unlock_irqrestore_73_1(spinlock_t *lock, unsigned long flags)
{
  
#line 751 
  ldv_spin_model_unlock((char *)"sc_pm_lock_of_ath_softc");
  
#line 753 
  spin_unlock_irqrestore_5(lock,flags);
  
#line 754 
  return;
}


#line 757  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_gpio.c.aux"
static void ldv_spin_unlock_irqrestore_74(spinlock_t *lock, unsigned long flags)
{
  
#line 761 
  ldv_spin_model_unlock((char *)"sc_pm_lock_of_ath_softc");
  
#line 763 
  spin_unlock_irqrestore_5(lock,flags);
  
#line 764 
  return;
}


#line 767  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_gpio.c.aux"
static void ldv_spin_lock_bh_75_0(spinlock_t *lock)
{
  
#line 771 
  ldv_spin_model_lock((char *)"btcoex_lock_of_ath_btcoex");
  
#line 773 
  spin_lock_bh_4(lock);
  
#line 774 
  return;
}


#line 777  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_gpio.c.aux"
static void ldv_spin_unlock_bh_76_1(spinlock_t *lock)
{
  
#line 781 
  ldv_spin_model_unlock((char *)"btcoex_lock_of_ath_btcoex");
  
#line 783 
  spin_unlock_bh_4(lock);
  
#line 784 
  return;
}


#line 787  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_gpio.c.aux"
static int ldv_mod_timer_77(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2)
{
  int tmp;
  
#line 791 
  tmp = ldv_emg_mod_timer(ldv_func_arg1,ldv_func_arg2);
  
#line 791 
  return tmp;
}


#line 795  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_gpio.c.aux"
static int ldv_mod_timer_78_0(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2)
{
  int tmp;
  
#line 799 
  tmp = ldv_emg_mod_timer(ldv_func_arg1,ldv_func_arg2);
  
#line 799 
  return tmp;
}


#line 803  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_gpio.c.aux"
static void ldv_spin_lock_bh_79_0(spinlock_t *lock)
{
  
#line 807 
  ldv_spin_model_lock((char *)"btcoex_lock_of_ath_btcoex");
  
#line 809 
  spin_lock_bh_4(lock);
  
#line 810 
  return;
}


#line 813  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_gpio.c.aux"
static void ldv_spin_unlock_bh_80_0(spinlock_t *lock)
{
  
#line 817 
  ldv_spin_model_unlock((char *)"btcoex_lock_of_ath_btcoex");
  
#line 819 
  spin_unlock_bh_4(lock);
  
#line 820 
  return;
}


#line 823  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_gpio.c.aux"
static int ldv_del_timer_sync_81(struct timer_list *ldv_func_arg1)
{
  int tmp;
  
#line 827 
  tmp = ldv_emg_del_timer_sync(ldv_func_arg1);
  
#line 827 
  return tmp;
}


#line 831  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_gpio.c.aux"
static int ldv_mod_timer_82(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2)
{
  int tmp;
  
#line 835 
  tmp = ldv_emg_mod_timer(ldv_func_arg1,ldv_func_arg2);
  
#line 835 
  return tmp;
}


#line 839  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_gpio.c.aux"
static int ldv_del_timer_sync_83(struct timer_list *ldv_func_arg1)
{
  int tmp;
  
#line 843 
  tmp = ldv_emg_del_timer_sync(ldv_func_arg1);
  
#line 843 
  return tmp;
}


#line 847  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_gpio.c.aux"
static int ldv_del_timer_sync_84(struct timer_list *ldv_func_arg1)
{
  int tmp;
  
#line 851 
  tmp = ldv_emg_del_timer_sync(ldv_func_arg1);
  
#line 851 
  return tmp;
}


#line 855  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_gpio.c.aux"
static int ldv_del_timer_sync_85(struct timer_list *ldv_func_arg1)
{
  int tmp;
  
#line 859 
  tmp = ldv_emg_del_timer_sync(ldv_func_arg1);
  
#line 859 
  return tmp;
}


#line 232  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
static int ldv_del_timer_sync_78(struct timer_list *ldv_func_arg1);


#line 859  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
int pci_bus_read_config_byte(struct pci_bus *, unsigned int, int, u8 *);


#line 863 
int pci_bus_read_config_dword(struct pci_bus *, unsigned int, int, u32 *);


#line 865 
int pci_bus_write_config_byte(struct pci_bus *, unsigned int, int, u8);


#line 869 
int pci_bus_write_config_dword(struct pci_bus *, unsigned int, int, u32);


#line 883  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_read_config_byte(struct pci_dev const *dev, int where, u8 *val)
{
  int tmp;
  
#line 885 
  tmp = pci_bus_read_config_byte(dev->bus,dev->devfn,where,val);
  
#line 885 
  return tmp;
}


#line 891  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_read_config_dword(struct pci_dev const *dev, int where, u32 *val)
{
  int tmp;
  
#line 894 
  tmp = pci_bus_read_config_dword(dev->bus,dev->devfn,where,val);
  
#line 894 
  return tmp;
}


#line 896  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_write_config_byte(struct pci_dev const *dev, int where, u8 val)
{
  int tmp;
  
#line 898 
  tmp = pci_bus_write_config_byte(dev->bus,dev->devfn,where,(unsigned char)((int)val));
  
#line 898 
  return tmp;
}


#line 904  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_write_config_dword(struct pci_dev const *dev, int where, u32 val)
{
  int tmp;
  
#line 907 
  tmp = pci_bus_write_config_dword(dev->bus,dev->devfn,where,val);
  
#line 907 
  return tmp;
}


#line 910 
int pcie_capability_read_word(struct pci_dev *, int, u16 *);


#line 914 
int pcie_capability_clear_and_set_word(struct pci_dev *, int, u16, u16);


#line 931  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pcie_capability_clear_word(struct pci_dev *dev, int pos, u16 clear)
{
  int tmp;
  
#line 934 
  tmp = pcie_capability_clear_and_set_word(dev,pos,(unsigned short)((int)clear),(unsigned short)0);
  
#line 934 
  return tmp;
}


#line 955 
int pcim_enable_device(struct pci_dev *);


#line 971 
void pci_set_master(struct pci_dev *);


#line 1146 
static int ldv___pci_register_driver_79(struct pci_driver *ldv_func_arg1, struct module *ldv_func_arg2, char const *ldv_func_arg3);


#line 1158 
static void ldv_pci_unregister_driver_80(struct pci_driver *ldv_func_arg1);


#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
int dma_supported(struct device *, u64);


#line 61 
int dma_set_mask(struct device *, u64);


#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
__inline static int dma_set_coherent_mask(struct device *dev, u64 mask)
{
  int __retres;
  int tmp;
  
#line 103 
  tmp = dma_supported(dev,mask);
  
#line 103 
  if (tmp == 0) {
    
#line 104 
    __retres = -5;
    
#line 104 
    goto return_label;
  }
  else ;
  
#line 105 
  dev->coherent_dma_mask = mask;
  
#line 106 
  __retres = 0;
  return_label: 
#line 106 
                return __retres;
}


#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_dma_mask(struct pci_dev *dev, u64 mask)
{
  int tmp;
  
#line 115 
  tmp = dma_set_mask(& dev->dev,mask);
  
#line 115 
  return tmp;
}


#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_consistent_dma_mask(struct pci_dev *dev, u64 mask)
{
  int tmp;
  
#line 120 
  tmp = dma_set_coherent_mask(& dev->dev,mask);
  
#line 120 
  return tmp;
}


#line 1471  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev)
{
  void *tmp;
  
#line 1473 
  tmp = dev_get_drvdata((struct device const *)(& pdev->dev));
  
#line 1473 
  return tmp;
}


#line 1476  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev, void *data)
{
  
#line 1478 
  dev_set_drvdata(& pdev->dev,data);
  
#line 1479 
  return;
}


#line 1620 
void * const *pcim_iomap_table(struct pci_dev *);


#line 1621 
int pcim_iomap_regions(struct pci_dev *, int, char const *);


#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
static int ldv_request_irq_73_0(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev);


#line 153 
static void ldv_free_irq_74_0(unsigned int ldv_func_arg1, void *ldv_func_arg2);


#line 157 
static void ldv_free_irq_76_0(unsigned int ldv_func_arg1, void *ldv_func_arg2);


#line 3520  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
static struct ieee80211_hw *ldv_ieee80211_alloc_hw_72_0(size_t priv_data_len, struct ieee80211_ops const *ops);


#line 3685 
static void ldv_ieee80211_free_hw_75_0(struct ieee80211_hw *ldv_func_arg1);


#line 3689 
static void ldv_ieee80211_free_hw_77_0(struct ieee80211_hw *ldv_func_arg1);


#line 1033  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
bool ath9k_hw_wait(struct ath_hw *, u32, u32, u32, u32);


#line 1047 
bool ath9k_hw_disable(struct ath_hw *);


#line 1067 
bool ath9k_hw_setpower(struct ath_hw *, enum ath9k_power_mode);


#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw-ops.h"
__inline static void ath9k_hw_configpcipowersave(struct ath_hw *ah, bool power_off)
{
  struct ath_hw_ops *tmp;
  
#line 27 
  if (! ah->aspm_enabled) 
#line 28 
                          goto return_label; else ;
  
#line 30 
  tmp = ath9k_hw_ops(ah);
  
#line 30 
  (*(tmp->config_pci_powersave))(ah,(_Bool)((bool)((int)power_off) != 0));
  return_label: 
#line 31 
                return;
}


#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/pci.c"
static struct pci_device_id const ath_pci_id_table[149U] = {{.vendor = 5772U, .device = 35U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5772U, .device = 36U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5772U, .device = 39U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5772U, .device = 41U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5772U, .device = 42U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5772U, .device = 42U, .subvendor = 6715U, .subdevice = 7281U, .class = 0U, .class_mask = 0U, .driver_data = 64UL}, {.vendor = 5772U, .device = 42U, .subvendor = 4187U, .subdevice = 57375U, .class = 0U, .class_mask = 0U, .driver_data = 64UL}, {.vendor = 5772U, .device = 42U, .subvendor = 4525U, .subdevice = 26162U, .class = 0U, .class_mask = 0U, .driver_data = 64UL}, {.vendor = 5772U, .device = 42U, .subvendor = 4525U, .subdevice = 26178U, .class = 0U, .class_mask = 0U, .driver_data = 64UL}, {.vendor = 5772U, .device = 42U, .subvendor = 6706U, .subdevice = 774U, .class = 0U, .class_mask = 0U, .driver_data = 64UL}, {.vendor = 5772U, .device = 42U, .subvendor = 6239U, .subdevice = 12445U, .class = 0U, .class_mask = 0U, .driver_data = 64UL}, {.vendor = 5772U, .device = 42U, .subvendor = 4303U, .subdevice = 5244U, .class = 0U, .class_mask = 0U, .driver_data = 64UL}, {.vendor = 5772U, .device = 42U, .subvendor = 4303U, .subdevice = 5245U, .class = 0U, .class_mask = 0U, .driver_data = 64UL}, {.vendor = 5772U, .device = 42U, .subvendor = 4303U, .subdevice = 5430U, .class = 0U, .class_mask = 0U, .driver_data = 64UL}, {.vendor = 5772U, .device = 43U, .subvendor = 6715U, .subdevice = 11319U, .class = 0U, .class_mask = 0U, .driver_data = 32UL}, {.vendor = 5772U, .device = 43U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5772U, .device = 44U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5772U, .device = 45U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5772U, .device = 46U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5772U, .device = 48U, .subvendor = 6742U, .subdevice = 8192U, .class = 0U, .class_mask = 0U, .driver_data = 1024UL}, {.vendor = 5772U, .device = 48U, .subvendor = 6742U, .subdevice = 8193U, .class = 0U, .class_mask = 0U, .driver_data = 1024UL}, {.vendor = 5772U, .device = 48U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5772U, .device = 50U, .subvendor = 6715U, .subdevice = 8326U, .class = 0U, .class_mask = 0U, .driver_data = 33UL}, {.vendor = 5772U, .device = 50U, .subvendor = 6715U, .subdevice = 4663U, .class = 0U, .class_mask = 0U, .driver_data = 33UL}, {.vendor = 5772U, .device = 50U, .subvendor = 6715U, .subdevice = 8486U, .class = 0U, .class_mask = 0U, .driver_data = 33UL}, {.vendor = 5772U, .device = 50U, .subvendor = 6715U, .subdevice = 4714U, .class = 0U, .class_mask = 0U, .driver_data = 33UL}, {.vendor = 5772U, .device = 50U, .subvendor = 6715U, .subdevice = 8530U, .class = 0U, .class_mask = 0U, .driver_data = 34UL}, {.vendor = 5772U, .device = 50U, .subvendor = 4187U, .subdevice = 57461U, .class = 0U, .class_mask = 0U, .driver_data = 34UL}, {.vendor = 5772U, .device = 50U, .subvendor = 5772U, .subdevice = 12569U, .class = 0U, .class_mask = 0U, .driver_data = 32UL}, {.vendor = 5772U, .device = 50U, .subvendor = 5772U, .subdevice = 12578U, .class = 0U, .class_mask = 0U, .driver_data = 32UL}, {.vendor = 5772U, .device = 50U, .subvendor = 6239U, .subdevice = 12569U, .class = 0U, .class_mask = 0U, .driver_data = 32UL}, {.vendor = 5772U, .device = 50U, .subvendor = 6239U, .subdevice = 12327U, .class = 0U, .class_mask = 0U, .driver_data = 32UL}, {.vendor = 5772U, .device = 50U, .subvendor = 5197U, .subdevice = 16645U, .class = 0U, .class_mask = 0U, .driver_data = 32UL}, {.vendor = 5772U, .device = 50U, .subvendor = 5197U, .subdevice = 16646U, .class = 0U, .class_mask = 0U, .driver_data = 32UL}, {.vendor = 5772U, .device = 50U, .subvendor = 5197U, .subdevice = 16653U, .class = 0U, .class_mask = 0U, .driver_data = 32UL}, {.vendor = 5772U, .device = 50U, .subvendor = 5197U, .subdevice = 16654U, .class = 0U, .class_mask = 0U, .driver_data = 32UL}, {.vendor = 5772U, .device = 50U, .subvendor = 5197U, .subdevice = 16655U, .class = 0U, .class_mask = 0U, .driver_data = 32UL}, {.vendor = 5772U, .device = 50U, .subvendor = 5197U, .subdevice = 50950U, .class = 0U, .class_mask = 0U, .driver_data = 32UL}, {.vendor = 5772U, .device = 50U, .subvendor = 5197U, .subdevice = 50816U, .class = 0U, .class_mask = 0U, .driver_data = 32UL}, {.vendor = 5772U, .device = 50U, .subvendor = 5197U, .subdevice = 50952U, .class = 0U, .class_mask = 0U, .driver_data = 32UL}, {.vendor = 5772U, .device = 50U, .subvendor = 6058U, .subdevice = 12824U, .class = 0U, .class_mask = 0U, .driver_data = 32UL}, {.vendor = 5772U, .device = 50U, .subvendor = 6058U, .subdevice = 12825U, .class = 0U, .class_mask = 0U, .driver_data = 32UL}, {.vendor = 5772U, .device = 50U, .subvendor = 6715U, .subdevice = 11415U, .class = 0U, .class_mask = 0U, .driver_data = 512UL}, {.vendor = 5772U, .device = 50U, .subvendor = 6715U, .subdevice = 8448U, .class = 0U, .class_mask = 0U, .driver_data = 512UL}, {.vendor = 5772U, .device = 50U, .subvendor = 7254U, .subdevice = 16385U, .class = 0U, .class_mask = 0U, .driver_data = 512UL}, {.vendor = 5772U, .device = 50U, .subvendor = 4525U, .subdevice = 26151U, .class = 0U, .class_mask = 0U, .driver_data = 512UL}, {.vendor = 5772U, .device = 50U, .subvendor = 4525U, .subdevice = 26152U, .class = 0U, .class_mask = 0U, .driver_data = 512UL}, {.vendor = 5772U, .device = 50U, .subvendor = 4187U, .subdevice = 57422U, .class = 0U, .class_mask = 0U, .driver_data = 512UL}, {.vendor = 5772U, .device = 50U, .subvendor = 4187U, .subdevice = 57423U, .class = 0U, .class_mask = 0U, .driver_data = 512UL}, {.vendor = 5772U, .device = 50U, .subvendor = 5199U, .subdevice = 29079U, .class = 0U, .class_mask = 0U, .driver_data = 512UL}, {.vendor = 5772U, .device = 50U, .subvendor = 7066U, .subdevice = 8192U, .class = 0U, .class_mask = 0U, .driver_data = 512UL}, {.vendor = 5772U, .device = 50U, .subvendor = 7066U, .subdevice = 8193U, .class = 0U, .class_mask = 0U, .driver_data = 512UL}, {.vendor = 5772U, .device = 50U, .subvendor = 6715U, .subdevice = 4486U, .class = 0U, .class_mask = 0U, .driver_data = 512UL}, {.vendor = 5772U, .device = 50U, .subvendor = 6715U, .subdevice = 8070U, .class = 0U, .class_mask = 0U, .driver_data = 512UL}, {.vendor = 5772U, .device = 50U, .subvendor = 6715U, .subdevice = 4501U, .class = 0U, .class_mask = 0U, .driver_data = 512UL}, {.vendor = 5772U, .device = 50U, .subvendor = 6715U, .subdevice = 8085U, .class = 0U, .class_mask = 0U, .driver_data = 512UL}, {.vendor = 5772U, .device = 50U, .subvendor = 7066U, .subdevice = 7168U, .class = 0U, .class_mask = 0U, .driver_data = 512UL}, {.vendor = 5772U, .device = 50U, .subvendor = 7066U, .subdevice = 7169U, .class = 0U, .class_mask = 0U, .driver_data = 512UL}, {.vendor = 5772U, .device = 50U, .subvendor = 4163U, .subdevice = 34061U, .class = 0U, .class_mask = 0U, .driver_data = 512UL}, {.vendor = 5772U, .device = 50U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5772U, .device = 51U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5772U, .device = 52U, .subvendor = 6715U, .subdevice = 8470U, .class = 0U, .class_mask = 0U, .driver_data = 4UL}, {.vendor = 5772U, .device = 52U, .subvendor = 4525U, .subdevice = 26209U, .class = 0U, .class_mask = 0U, .driver_data = 4UL}, {.vendor = 5772U, .device = 52U, .subvendor = 5772U, .subdevice = 12567U, .class = 0U, .class_mask = 0U, .driver_data = 16UL}, {.vendor = 5772U, .device = 52U, .subvendor = 6058U, .subdevice = 12820U, .class = 0U, .class_mask = 0U, .driver_data = 16UL}, {.vendor = 5772U, .device = 52U, .subvendor = 6505U, .subdevice = 145U, .class = 0U, .class_mask = 0U, .driver_data = 16UL}, {.vendor = 5772U, .device = 52U, .subvendor = 6715U, .subdevice = 8464U, .class = 0U, .class_mask = 0U, .driver_data = 16UL}, {.vendor = 5772U, .device = 52U, .subvendor = 4163U, .subdevice = 34062U, .class = 0U, .class_mask = 0U, .driver_data = 16UL}, {.vendor = 5772U, .device = 52U, .subvendor = 4525U, .subdevice = 26161U, .class = 0U, .class_mask = 0U, .driver_data = 16UL}, {.vendor = 5772U, .device = 52U, .subvendor = 4525U, .subdevice = 26177U, .class = 0U, .class_mask = 0U, .driver_data = 16UL}, {.vendor = 5772U, .device = 52U, .subvendor = 4156U, .subdevice = 6244U, .class = 0U, .class_mask = 0U, .driver_data = 16UL}, {.vendor = 5772U, .device = 52U, .subvendor = 5325U, .subdevice = 99U, .class = 0U, .class_mask = 0U, .driver_data = 16UL}, {.vendor = 5772U, .device = 52U, .subvendor = 5325U, .subdevice = 100U, .class = 0U, .class_mask = 0U, .driver_data = 16UL}, {.vendor = 5772U, .device = 52U, .subvendor = 4303U, .subdevice = 6019U, .class = 0U, .class_mask = 0U, .driver_data = 16UL}, {.vendor = 5772U, .device = 48U, .subvendor = 6742U, .subdevice = 8195U, .class = 0U, .class_mask = 0U, .driver_data = 1024UL}, {.vendor = 5772U, .device = 52U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5772U, .device = 55U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5772U, .device = 54U, .subvendor = 5772U, .subdevice = 12328U, .class = 0U, .class_mask = 0U, .driver_data = 296UL}, {.vendor = 5772U, .device = 54U, .subvendor = 6715U, .subdevice = 8566U, .class = 0U, .class_mask = 0U, .driver_data = 296UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4187U, .subdevice = 57448U, .class = 0U, .class_mask = 0U, .driver_data = 128UL}, {.vendor = 5772U, .device = 54U, .subvendor = 6239U, .subdevice = 41241U, .class = 0U, .class_mask = 0U, .driver_data = 128UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4525U, .subdevice = 1586U, .class = 0U, .class_mask = 0U, .driver_data = 128UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4525U, .subdevice = 1714U, .class = 0U, .class_mask = 0U, .driver_data = 128UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4525U, .subdevice = 2114U, .class = 0U, .class_mask = 0U, .driver_data = 128UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4525U, .subdevice = 6210U, .class = 0U, .class_mask = 0U, .driver_data = 128UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4525U, .subdevice = 26225U, .class = 0U, .class_mask = 0U, .driver_data = 128UL}, {.vendor = 5772U, .device = 54U, .subvendor = 7066U, .subdevice = 10257U, .class = 0U, .class_mask = 0U, .driver_data = 128UL}, {.vendor = 5772U, .device = 54U, .subvendor = 7066U, .subdevice = 10258U, .class = 0U, .class_mask = 0U, .driver_data = 128UL}, {.vendor = 5772U, .device = 54U, .subvendor = 7066U, .subdevice = 10401U, .class = 0U, .class_mask = 0U, .driver_data = 128UL}, {.vendor = 5772U, .device = 54U, .subvendor = 7066U, .subdevice = 10403U, .class = 0U, .class_mask = 0U, .driver_data = 128UL}, {.vendor = 5772U, .device = 54U, .subvendor = 6715U, .subdevice = 8586U, .class = 0U, .class_mask = 0U, .driver_data = 128UL}, {.vendor = 5772U, .device = 54U, .subvendor = 6715U, .subdevice = 12170U, .class = 0U, .class_mask = 0U, .driver_data = 128UL}, {.vendor = 5772U, .device = 54U, .subvendor = 5772U, .subdevice = 12325U, .class = 0U, .class_mask = 0U, .driver_data = 160UL}, {.vendor = 5772U, .device = 54U, .subvendor = 5772U, .subdevice = 12326U, .class = 0U, .class_mask = 0U, .driver_data = 160UL}, {.vendor = 5772U, .device = 54U, .subvendor = 5772U, .subdevice = 12331U, .class = 0U, .class_mask = 0U, .driver_data = 160UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4187U, .subdevice = 57449U, .class = 0U, .class_mask = 0U, .driver_data = 160UL}, {.vendor = 5772U, .device = 54U, .subvendor = 6239U, .subdevice = 12328U, .class = 0U, .class_mask = 0U, .driver_data = 160UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4525U, .subdevice = 1570U, .class = 0U, .class_mask = 0U, .driver_data = 160UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4525U, .subdevice = 1650U, .class = 0U, .class_mask = 0U, .driver_data = 160UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4525U, .subdevice = 1634U, .class = 0U, .class_mask = 0U, .driver_data = 160UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4525U, .subdevice = 1698U, .class = 0U, .class_mask = 0U, .driver_data = 160UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4525U, .subdevice = 1666U, .class = 0U, .class_mask = 0U, .driver_data = 160UL}, {.vendor = 5772U, .device = 54U, .subvendor = 6715U, .subdevice = 8506U, .class = 0U, .class_mask = 0U, .driver_data = 160UL}, {.vendor = 5772U, .device = 54U, .subvendor = 6715U, .subdevice = 8508U, .class = 0U, .class_mask = 0U, .driver_data = 160UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4156U, .subdevice = 6371U, .class = 0U, .class_mask = 0U, .driver_data = 160UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4156U, .subdevice = 8575U, .class = 0U, .class_mask = 0U, .driver_data = 160UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4156U, .subdevice = 8197U, .class = 0U, .class_mask = 0U, .driver_data = 160UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4136U, .subdevice = 524U, .class = 0U, .class_mask = 0U, .driver_data = 160UL}, {.vendor = 5772U, .device = 54U, .subvendor = 5197U, .subdevice = 16666U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 5197U, .subdevice = 16667U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 5197U, .subdevice = 16668U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 5197U, .subdevice = 16669U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 5197U, .subdevice = 16670U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 5197U, .subdevice = 16681U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 5197U, .subdevice = 16682U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 5772U, .subdevice = 12327U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 5772U, .subdevice = 12332U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4525U, .subdevice = 1602U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4525U, .subdevice = 1618U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4525U, .subdevice = 1554U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4525U, .subdevice = 2098U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4525U, .subdevice = 6194U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4525U, .subdevice = 1682U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4525U, .subdevice = 2051U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4525U, .subdevice = 2067U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 6715U, .subdevice = 8496U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 6715U, .subdevice = 8507U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 6715U, .subdevice = 8578U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 6715U, .subdevice = 8587U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 6715U, .subdevice = 8588U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 6715U, .subdevice = 12162U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 5199U, .subdevice = 29186U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 7066U, .subdevice = 10256U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 7066U, .subdevice = 10259U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 7066U, .subdevice = 10402U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 7066U, .subdevice = 10404U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 6239U, .subdevice = 12327U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 6239U, .subdevice = 41248U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4187U, .subdevice = 57471U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4187U, .subdevice = 57487U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4187U, .subdevice = 57473U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4187U, .subdevice = 57489U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4187U, .subdevice = 57497U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 6058U, .subdevice = 12326U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 6058U, .subdevice = 16422U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4163U, .subdevice = 34290U, .class = 0U, .class_mask = 0U, .driver_data = 288UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4136U, .subdevice = 526U, .class = 0U, .class_mask = 0U, .driver_data = 2336UL}, {.vendor = 5772U, .device = 54U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 32UL}, {.vendor = 0U, .device = 0U, .subvendor = 0U, .subdevice = 0U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}};

#line 759  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/pci.c"
static void ath_pci_read_cachesize(struct ath_common *common, int *csz)
{
  u8 u8tmp;
  struct pci_dev *tmp;
  
#line 761 
  struct ath_softc *sc = (struct ath_softc *)common->priv;
  {
    
#line 764 
    struct device const *__mptr = (struct device const *)sc->dev;
    
#line 764 
    tmp = (struct pci_dev *)__mptr + 18446744073709551464U;
  }
  
#line 764 
  pci_read_config_byte((struct pci_dev const *)tmp,12,& u8tmp);
  
#line 765 
  *csz = (int)u8tmp;
  
#line 773 
  if (*csz == 0) 
#line 774 
                 *csz = 8; else ;
  
#line 775 
  return;
}


#line 777  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/pci.c"
static bool ath_pci_eeprom_read(struct ath_common *common, u32 off, u16 *data)
{
  bool __retres;
  
#line 779 
  struct ath_softc *sc = (struct ath_softc *)common->priv;
  
#line 780 
  struct ath9k_platform_data *pdata = (struct ath9k_platform_data *)(sc->dev)->platform_data;
  
#line 782 
  if (pdata != (struct ath9k_platform_data *)0 && ! pdata->use_eeprom) {
    
#line 783 
    if (off > 2047U) 
#line 784 
                     ath_printk("\001",(struct ath_common const *)common,"%s: eeprom read failed, offset %08x is out of range\n","ath_pci_eeprom_read",off); else ;
    
#line 789 
    *data = pdata->eeprom_data[off];
  }
  else {
    int tmp_2;
    bool tmp_1;
    int tmp_0;
    unsigned int tmp_5;
    int tmp_4;
    
#line 791 
    struct ath_hw *ah = (struct ath_hw *)common->ah;
    
#line 793 
    (*((common->ops)->read))((void *)ah,(off << 2) + 8192U);
    
#line 797 
    if (ah->hw_version.macVersion != 768U) {
      int tmp;
      
#line 797 
      if (ah->hw_version.macVersion > 447U) 
#line 797 
                                            tmp = 16516; else 
#line 797 
                                                              tmp = 16508;
      
#line 797 
      tmp_0 = tmp;
    }
    else 
#line 797 
         tmp_0 = 16584;
    
#line 796 
    ;
    
#line 796 
    tmp_1 = ath9k_hw_wait(ah,(unsigned int)tmp_0,327680U,0U,100000U);
    
#line 796 
    if (tmp_1) 
#line 796 
               tmp_2 = 0; else 
#line 796 
                               tmp_2 = 1;
    
#line 796 
    if (tmp_2) {
      
#line 801 
      __retres = (_Bool)0;
      
#line 801 
      goto return_label;
    }
    else ;
    
#line 804 
    if (ah->hw_version.macVersion != 768U) {
      int tmp_3;
      
#line 804 
      if (ah->hw_version.macVersion > 447U) 
#line 804 
                                            tmp_3 = 16516; else 
#line 804 
                                                                tmp_3 = 16508;
      
#line 804 
      tmp_4 = tmp_3;
    }
    else 
#line 804 
         tmp_4 = 16584;
    
#line 804 
    ;
    
#line 804 
    tmp_5 = (*((common->ops)->read))((void *)ah,(unsigned int)tmp_4);
    
#line 804 
    *data = (unsigned short)tmp_5;
  }
  
#line 808 
  __retres = (_Bool)1;
  return_label: 
#line 808 
                return __retres;
}


#line 812  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/pci.c"
static void ath_pci_aspm_init(struct ath_common *common)
{
  struct pci_dev *tmp;
  struct pci_dev *parent;
  u16 aspm;
  enum ath_btcoex_scheme tmp_0;
  
#line 814 
  struct ath_softc *sc = (struct ath_softc *)common->priv;
  
#line 815 
  struct ath_hw *ah = sc->sc_ah;
  {
    
#line 816 
    struct device const *__mptr = (struct device const *)sc->dev;
    
#line 816 
    tmp = (struct pci_dev *)__mptr + 18446744073709551464U;
  }
  
#line 816 
  struct pci_dev *pdev = tmp;
  
#line 820 
  if (! ah->is_pciexpress) 
#line 821 
                           goto return_label; else ;
  
#line 823 
  parent = (pdev->bus)->self;
  
#line 824 
  if (parent == (struct pci_dev *)0) 
#line 825 
                                     goto return_label; else ;
  
#line 827 
  tmp_0 = ath9k_hw_get_btcoex_scheme(ah);
  
#line 827 
  if (tmp_0 != (unsigned int)ATH_BTCOEX_CFG_NONE) {
    
#line 827 
    if (ah->hw_version.macVersion == 192U) {
      
#line 830 
      pcie_capability_clear_word(pdev,16,(unsigned short)3);
      
#line 837 
      pcie_capability_clear_word(parent,16,(unsigned short)3);
      
#line 840 
      ath_printk("\001",(struct ath_common const *)common,"Disabling ASPM since BTCOEX is enabled\n");
      
#line 841 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 857 
  if (ah->hw_version.macVersion == 640U) 
#line 858 
                                         pci_read_config_dword((struct pci_dev const *)pdev,1804,& ah->config.aspm_l1_fix); else ;
  
#line 860 
  pcie_capability_read_word(parent,16,& aspm);
  
#line 861 
  if (((int)aspm & 3) != 0) {
    
#line 862 
    ah->aspm_enabled = (_Bool)1;
    
#line 864 
    ath9k_hw_configpcipowersave(ah,(_Bool)0);
    
#line 865 
    ath_printk("\001",(struct ath_common const *)common,"ASPM enabled: 0x%x\n",(int)aspm);
  }
  else ;
  return_label: 
#line 867 
                return;
}


#line 869  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/pci.c"
static struct ath_bus_ops const ath_pci_bus_ops = {.ath_bus_type = ATH_PCI, .read_cachesize = & ath_pci_read_cachesize, .eeprom_read = & ath_pci_eeprom_read, .bt_coex_prep = (void (*)(struct ath_common *))0, .aspm_init = & ath_pci_aspm_init};

#line 876  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/pci.c"
static int ath_pci_probe(struct pci_dev *pdev, struct pci_device_id const *id)
{
  int __retres;
  struct ath_softc *sc;
  struct ieee80211_hw *hw;
  u8 csz;
  u32 val;
  char hw_name[64U];
  int tmp;
  void * const *tmp_0;
  
#line 882 
  int ret = 0;
  
#line 885 
  tmp = pcim_enable_device(pdev);
  
#line 885 
  if (tmp != 0) {
    
#line 886 
    __retres = -5;
    
#line 886 
    goto return_label;
  }
  else ;
  
#line 888 
  ret = pci_set_dma_mask(pdev,4294967295ULL);
  
#line 889 
  if (ret != 0) {
    
#line 890 
    printk("\001");
    
#line 891 
    __retres = ret;
    
#line 891 
    goto return_label;
  }
  else ;
  
#line 894 
  ret = pci_set_consistent_dma_mask(pdev,4294967295ULL);
  
#line 895 
  if (ret != 0) {
    
#line 896 
    printk("\001");
    
#line 897 
    __retres = ret;
    
#line 897 
    goto return_label;
  }
  else ;
  
#line 904 
  pci_read_config_byte((struct pci_dev const *)pdev,12,& csz);
  
#line 905 
  if ((unsigned int)csz == 0U) {
    
#line 913 
    csz = (unsigned char)16U;
    
#line 914 
    pci_write_config_byte((struct pci_dev const *)pdev,12,(unsigned char)((int)csz));
  }
  else ;
  
#line 921 
  pci_write_config_byte((struct pci_dev const *)pdev,13,(unsigned char)168);
  
#line 923 
  pci_set_master(pdev);
  
#line 929 
  pci_read_config_dword((struct pci_dev const *)pdev,64,& val);
  
#line 930 
  if ((val & 65280U) != 0U) 
#line 931 
                            pci_write_config_dword((struct pci_dev const *)pdev,64,val & 4294902015U); else ;
  
#line 933 
  ret = pcim_iomap_regions(pdev,1,"ath9k");
  
#line 934 
  if (ret != 0) {
    
#line 935 
    dev_err((struct device const *)(& pdev->dev),"PCI memory region reserve error\n");
    
#line 936 
    __retres = -19;
    
#line 936 
    goto return_label;
  }
  else ;
  
#line 939 
  ath9k_fill_chanctx_ops();
  
#line 940 
  hw = ldv_ieee80211_alloc_hw_72_0(15648UL,(struct ieee80211_ops const *)(& ath9k_ops));
  
#line 941 
  if (hw == (struct ieee80211_hw *)0) {
    
#line 942 
    dev_err((struct device const *)(& pdev->dev),"No memory for ieee80211_hw\n");
    
#line 943 
    __retres = -12;
    
#line 943 
    goto return_label;
  }
  else ;
  
#line 946 
  SET_IEEE80211_DEV(hw,& pdev->dev);
  
#line 947 
  pci_set_drvdata(pdev,(void *)hw);
  
#line 949 
  sc = (struct ath_softc *)hw->priv;
  
#line 950 
  sc->hw = hw;
  
#line 951 
  sc->dev = & pdev->dev;
  
#line 952 
  tmp_0 = pcim_iomap_table(pdev);
  
#line 952 
  sc->mem = *tmp_0;
  
#line 953 
  sc->driver_data = id->driver_data;
  
#line 955 
  ret = ldv_request_irq_73_0(pdev->irq,& ath_isr,128UL,"ath9k",(void *)sc);
  
#line 956 
  if (ret != 0) {
    
#line 957 
    dev_err((struct device const *)(& pdev->dev),"request_irq failed\n");
    
#line 958 
    goto err_irq;
  }
  else ;
  
#line 961 
  sc->irq = (int)pdev->irq;
  
#line 963 
  ret = ath9k_init_device((unsigned short)((int)((unsigned short)id->device)),sc,& ath_pci_bus_ops);
  
#line 964 
  if (ret != 0) {
    
#line 965 
    dev_err((struct device const *)(& pdev->dev),"Failed to initialize device\n");
    
#line 966 
    goto err_init;
  }
  else ;
  
#line 969 
  ath9k_hw_name(sc->sc_ah,(char *)(& hw_name),64UL);
  
#line 970 
  _dev_info((struct device const *)(& (hw->wiphy)->dev),"%s mem=0x%lx, irq=%d\n",(char *)(& hw_name),(unsigned long)sc->mem,pdev->irq);
  
#line 973 
  __retres = 0;
  
#line 973 
  goto return_label;
  err_init: 
#line 975 
  ;
  
#line 976 
  ldv_free_irq_74_0((unsigned int)sc->irq,(void *)sc);
  err_irq: 
#line 977 
  ;
  
#line 978 
  ldv_ieee80211_free_hw_75_0(hw);
  
#line 979 
  __retres = ret;
  return_label: 
#line 979 
                return __retres;
}


#line 982  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/pci.c"
static void ath_pci_remove(struct pci_dev *pdev)
{
  
#line 984 
  struct ieee80211_hw *hw = pci_get_drvdata(pdev);
  
#line 985 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 987 
  if (! is_ath9k_unloaded) 
#line 988 
                           (sc->sc_ah)->ah_flags |= 2U; else ;
  
#line 989 
  ath9k_deinit_device(sc);
  
#line 990 
  ldv_free_irq_76_0((unsigned int)sc->irq,(void *)sc);
  
#line 991 
  ldv_ieee80211_free_hw_77_0(sc->hw);
  
#line 992 
  return;
}


#line 996  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/pci.c"
static int ath_pci_suspend(struct device *device)
{
  int __retres;
  struct pci_dev *tmp;
  int tmp_2;
  {
    
#line 998 
    struct device const *__mptr = (struct device const *)device;
    
#line 998 
    tmp = (struct pci_dev *)__mptr + 18446744073709551464U;
  }
  
#line 998 
  struct pci_dev *pdev = tmp;
  
#line 999 
  struct ieee80211_hw *hw = pci_get_drvdata(pdev);
  
#line 1000 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 1001 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 1003 
  tmp_2 = constant_test_bit(7L,(unsigned long const volatile *)(& common->op_flags));
  
#line 1003 
  if (tmp_2 != 0) {
    
#line 1004 
    _dev_info((struct device const *)(& pdev->dev),"WOW is enabled, bypassing PCI suspend\n");
    
#line 1005 
    __retres = 0;
    
#line 1005 
    goto return_label;
  }
  else ;
  
#line 1012 
  ath9k_stop_btcoex(sc);
  
#line 1013 
  ath9k_hw_disable(sc->sc_ah);
  
#line 1014 
  ldv_del_timer_sync_78(& sc->sleep_timer);
  
#line 1015 
  ath9k_hw_setpower(sc->sc_ah,(enum ath9k_power_mode)ATH9K_PM_FULL_SLEEP);
  
#line 1017 
  __retres = 0;
  return_label: 
#line 1017 
                return __retres;
}


#line 1020  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/pci.c"
static int ath_pci_resume(struct device *device)
{
  int __retres;
  struct pci_dev *tmp;
  u32 val;
  {
    
#line 1022 
    struct device const *__mptr = (struct device const *)device;
    
#line 1022 
    tmp = (struct pci_dev *)__mptr + 18446744073709551464U;
  }
  
#line 1022 
  struct pci_dev *pdev = tmp;
  
#line 1023 
  struct ieee80211_hw *hw = pci_get_drvdata(pdev);
  
#line 1024 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 1025 
  struct ath_hw *ah = sc->sc_ah;
  
#line 1026 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 1034 
  pci_read_config_dword((struct pci_dev const *)pdev,64,& val);
  
#line 1035 
  if ((val & 65280U) != 0U) 
#line 1036 
                            pci_write_config_dword((struct pci_dev const *)pdev,64,val & 4294902015U); else ;
  
#line 1038 
  ath_pci_aspm_init(common);
  
#line 1039 
  ah->reset_power_on = (_Bool)0;
  
#line 1041 
  __retres = 0;
  
#line 1041 
  return __retres;
}


#line 1044  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/pci.c"
static struct dev_pm_ops const ath9k_pm_ops = {.prepare = (int (*)(struct device *))0, .complete = (void (*)(struct device *))0, .suspend = & ath_pci_suspend, .resume = & ath_pci_resume, .freeze = & ath_pci_suspend, .thaw = & ath_pci_resume, .poweroff = & ath_pci_suspend, .restore = & ath_pci_resume, .suspend_late = (int (*)(struct device *))0, .resume_early = (int (*)(struct device *))0, .freeze_late = (int (*)(struct device *))0, .thaw_early = (int (*)(struct device *))0, .poweroff_late = (int (*)(struct device *))0, .restore_early = (int (*)(struct device *))0, .suspend_noirq = (int (*)(struct device *))0, .resume_noirq = (int (*)(struct device *))0, .freeze_noirq = (int (*)(struct device *))0, .thaw_noirq = (int (*)(struct device *))0, .poweroff_noirq = (int (*)(struct device *))0, .restore_noirq = (int (*)(struct device *))0, .runtime_suspend = (int (*)(struct device *))0, .runtime_resume = (int (*)(struct device *))0, .runtime_idle = (int (*)(struct device *))0};

#line 1055  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/pci.c"
struct pci_device_id const __mod_pci__ath_pci_id_table_device_table[149U];

#line 1057  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/pci.c"
static struct pci_driver ath_pci_driver = {.node = {.next = (struct list_head *)0, .prev = (struct list_head *)0}, .name = "ath9k", .id_table = (struct pci_device_id const *)(& ath_pci_id_table), .probe = & ath_pci_probe, .remove = & ath_pci_remove, .suspend = (int (*)(struct pci_dev *, pm_message_t ))0, .suspend_late = (int (*)(struct pci_dev *, pm_message_t ))0, .resume_early = (int (*)(struct pci_dev *))0, .resume = (int (*)(struct pci_dev *))0, .shutdown = (void (*)(struct pci_dev *))0, .sriov_configure = (int (*)(struct pci_dev *, int ))0, .err_handler = (struct pci_error_handlers const *)0, .driver = {.name = (char const *)0, .bus = (struct bus_type *)0, .owner = (struct module *)0, .mod_name = (char const *)0, .suppress_bind_attrs = (_Bool)0, .probe_type = 0, .of_match_table = (struct of_device_id const *)0, .acpi_match_table = (struct acpi_device_id const *)0, .probe = (int (*)(struct device *))0, .remove = (int (*)(struct device *))0, .shutdown = (void (*)(struct device *))0, .suspend = (int (*)(struct device *, pm_message_t ))0, .resume = (int (*)(struct device *))0, .groups = (struct attribute_group const **)0, .pm = & ath9k_pm_ops, .p = (struct driver_private *)0}, .dynids = {.lock = {.__anonCompField_spinlock_18 = {.rlock = {.raw_lock = {.val = {.counter = 0}}, .magic = 0U, .owner_cpu = 0U, .owner = (void *)0, .dep_map = {.key = (struct lock_class_key *)0, .class_cache = {(struct lock_class *)0, (struct lock_class *)0}, .name = (char const *)0, .cpu = 0, .ip = 0UL}}}}, .list = {.next = (struct list_head *)0, .prev = (struct list_head *)0}}};

#line 1065  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/pci.c"
int ath_pci_init(void)
{
  int tmp;
  
#line 1067 
  tmp = ldv___pci_register_driver_79(& ath_pci_driver,& __this_module,"ath9k");
  
#line 1067 
  return tmp;
}


#line 1070  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/pci.c"
void ath_pci_exit(void)
{
  
#line 1072 
  ldv_pci_unregister_driver_80(& ath_pci_driver);
  
#line 1073 
  return;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_pci.c.aux"
struct pci_driver *ldv_emg_alias_ath_pci_driver_2 = & ath_pci_driver;

#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_pci.c.aux"
struct dev_pm_ops *ldv_emg_alias_ath9k_pm_ops_3 = (struct dev_pm_ops *)(& ath9k_pm_ops);

#line 62 
int ldv_emg___pci_register_driver(struct pci_driver *arg0, struct module *arg1, char *arg2);


#line 68 
void ldv_emg_pci_unregister_driver(struct pci_driver *arg0);


#line 74  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_pci.c.aux"
void ldv_emg_wrapper_ath_pci_remove_3(struct pci_dev *arg0)
{
  
#line 75 
  ath_pci_remove(arg0);
  
#line 76 
  return;
}


#line 79  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_pci.c.aux"
int ldv_emg_wrapper_ath_pci_probe_2(struct pci_dev *arg0, struct pci_device_id *arg1)
{
  int tmp;
  
#line 80 
  tmp = ath_pci_probe(arg0,(struct pci_device_id const *)arg1);
  
#line 80 
  return tmp;
}


#line 84  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_pci.c.aux"
int ldv_emg_wrapper_ath_pci_resume_4(struct device *arg0)
{
  int tmp;
  
#line 85 
  tmp = ath_pci_resume(arg0);
  
#line 85 
  return tmp;
}


#line 89  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_pci.c.aux"
int ldv_emg_wrapper_ath_pci_suspend_2(struct device *arg0)
{
  int tmp;
  
#line 90 
  tmp = ath_pci_suspend(arg0);
  
#line 90 
  return tmp;
}


#line 765  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_pci.c.aux"
static struct ieee80211_hw *ldv_ieee80211_alloc_hw_72_0(size_t priv_data_len, struct ieee80211_ops const *ops)
{
  struct ieee80211_hw *tmp;
  
#line 769 
  tmp = ldv_emg_ieee80211_alloc_hw(priv_data_len,(struct ieee80211_ops *)ops);
  
#line 769 
  return tmp;
}


#line 773  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_pci.c.aux"
static int ldv_request_irq_73_0(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev)
{
  int tmp;
  
#line 777 
  tmp = ldv_emg_request_irq(irq,handler,flags,(char *)name,dev);
  
#line 777 
  return tmp;
}


#line 781  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_pci.c.aux"
static void ldv_free_irq_74_0(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  
#line 785 
  ldv_emg_free_irq(ldv_func_arg1,ldv_func_arg2);
  
#line 786 
  return;
}


#line 789  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_pci.c.aux"
static void ldv_ieee80211_free_hw_75_0(struct ieee80211_hw *ldv_func_arg1)
{
  
#line 793 
  ldv_emg_ieee80211_free_hw(ldv_func_arg1);
  
#line 794 
  return;
}


#line 797  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_pci.c.aux"
static void ldv_free_irq_76_0(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  
#line 801 
  ldv_emg_free_irq(ldv_func_arg1,ldv_func_arg2);
  
#line 802 
  return;
}


#line 805  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_pci.c.aux"
static void ldv_ieee80211_free_hw_77_0(struct ieee80211_hw *ldv_func_arg1)
{
  
#line 809 
  ldv_emg_ieee80211_free_hw(ldv_func_arg1);
  
#line 810 
  return;
}


#line 813  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_pci.c.aux"
static int ldv_del_timer_sync_78(struct timer_list *ldv_func_arg1)
{
  int tmp;
  
#line 817 
  tmp = ldv_emg_del_timer_sync(ldv_func_arg1);
  
#line 817 
  return tmp;
}


#line 821  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_pci.c.aux"
static int ldv___pci_register_driver_79(struct pci_driver *ldv_func_arg1, struct module *ldv_func_arg2, char const *ldv_func_arg3)
{
  int tmp;
  
#line 825 
  tmp = ldv_emg___pci_register_driver(ldv_func_arg1,ldv_func_arg2,(char *)ldv_func_arg3);
  
#line 825 
  return tmp;
}


#line 829  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_pci.c.aux"
static void ldv_pci_unregister_driver_80(struct pci_driver *ldv_func_arg1)
{
  
#line 833 
  ldv_emg_pci_unregister_driver(ldv_func_arg1);
  
#line 834 
  return;
}


#line 368  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
int kstrtou8_from_user(char const *, size_t, unsigned int, u8 *);


#line 127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/string.h"
int strtobool(char const *, bool *);


#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v, int i)
{
  
#line 39 
  v->counter = i;
  
#line 40 
  return;
}


#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debugfs.h"
static struct dentry *ldv_debugfs_create_file_72_1(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 58 
static struct dentry *ldv_debugfs_create_file_73_1(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 4495  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
void ieee80211_stop_queues(struct ieee80211_hw *);


#line 4503 
void ieee80211_wake_queues(struct ieee80211_hw *);


#line 92  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw-ops.h"
__inline static void ath9k_hw_tx99_stop(struct ath_hw *ah)
{
  struct ath_hw_ops *tmp;
  
#line 94 
  tmp = ath9k_hw_ops(ah);
  
#line 94 
  (*(tmp->tx99_stop))(ah);
  
#line 95 
  return;
}


#line 97  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw-ops.h"
__inline static void ath9k_hw_tx99_set_txpower(struct ath_hw *ah, u8 power)
{
  struct ath_hw_ops *tmp_0;
  
#line 99 
  tmp_0 = ath9k_hw_ops(ah);
  
#line 99 
  ;
  
#line 99 
  if (tmp_0->tx99_set_txpower != (void (*)(struct ath_hw *, u8 ))0) {
    struct ath_hw_ops *tmp;
    
#line 100 
    tmp = ath9k_hw_ops(ah);
    
#line 100 
    (*(tmp->tx99_set_txpower))(ah,(unsigned char)((int)power));
  }
  else ;
  
#line 101 
  return;
}


#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/tx99.c"
static void ath9k_tx99_stop(struct ath_softc *sc)
{
  
#line 21 
  struct ath_hw *ah = sc->sc_ah;
  
#line 22 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 24 
  ath_drain_all_txq(sc);
  
#line 25 
  ath_startrecv(sc);
  
#line 27 
  ath9k_hw_set_interrupts(ah);
  
#line 28 
  ath9k_hw_enable_interrupts(ah);
  
#line 30 
  ieee80211_wake_queues(sc->hw);
  
#line 32 
  kfree_skb(sc->tx99_skb);
  
#line 33 
  sc->tx99_skb = (struct sk_buff *)0;
  
#line 34 
  sc->tx99_state = (_Bool)0;
  
#line 36 
  ath9k_hw_tx99_stop(sc->sc_ah);
  
#line 37 
  if ((common->debug_mask & 128) != 0) 
#line 37 
                                       ath_printk("\001",(struct ath_common const *)common,"TX99 stopped\n"); else ;
  
#line 38 
  return;
}


#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/tx99.c"
static struct sk_buff *ath9k_build_tx99_skb(struct ath_softc *sc)
{
  struct sk_buff *__retres;
  struct ieee80211_tx_rate *rate;
  struct ieee80211_hdr *hdr;
  struct ieee80211_tx_info *tx_info;
  struct sk_buff *skb;
  struct ath_vif *avp;
  
#line 42 
  u8 PN9Data[64U] = {(unsigned char)255U, (unsigned char)135U, (unsigned char)184U, (unsigned char)89U, (unsigned char)183U, (unsigned char)161U, (unsigned char)204U, (unsigned char)36U, (unsigned char)87U, (unsigned char)94U, (unsigned char)75U, (unsigned char)156U, (unsigned char)14U, (unsigned char)233U, (unsigned char)234U, (unsigned char)80U, (unsigned char)42U, (unsigned char)190U, (unsigned char)180U, (unsigned char)27U, (unsigned char)182U, (unsigned char)176U, (unsigned char)93U, (unsigned char)241U, (unsigned char)230U, (unsigned char)154U, (unsigned char)227U, (unsigned char)69U, (unsigned char)253U, (unsigned char)44U, (unsigned char)83U, (unsigned char)24U, (unsigned char)12U, (unsigned char)202U, (unsigned char)201U, (unsigned char)251U, (unsigned char)73U, (unsigned char)55U, (unsigned char)229U, (unsigned char)168U, (unsigned char)81U, (unsigned char)59U, (unsigned char)47U, (unsigned char)97U, (unsigned char)170U, (unsigned char)114U, (unsigned char)24U, (unsigned char)132U, (unsigned char)2U, (unsigned char)35U, (unsigned char)35U, (unsigned char)171U, (unsigned char)99U, (unsigned char)137U, (unsigned char)81U, (unsigned char)179U, (unsigned char)231U, (unsigned char)139U, (unsigned char)114U, (unsigned char)144U, (unsigned char)76U, (unsigned char)232U, (unsigned char)251U, (unsigned char)192U};
  
#line 50 
  u32 len = 1200U;
  
#line 52 
  struct ieee80211_hw *hw = sc->hw;
  
#line 53 
  struct ath_hw *ah = sc->sc_ah;
  
#line 59 
  if (sc->tx99_vif == (struct ieee80211_vif *)0) {
    
#line 60 
    __retres = (struct sk_buff *)0;
    
#line 60 
    goto return_label;
  }
  else ;
  
#line 62 
  avp = (struct ath_vif *)(& (sc->tx99_vif)->drv_priv);
  
#line 64 
  skb = alloc_skb(len,208U);
  
#line 65 
  if (skb == (struct sk_buff *)0) {
    
#line 66 
    __retres = (struct sk_buff *)0;
    
#line 66 
    goto return_label;
  }
  else ;
  
#line 68 
  skb_put(skb,len);
  
#line 70 
  memset((void *)skb->data,0,(unsigned long)len);
  
#line 72 
  hdr = (struct ieee80211_hdr *)skb->data;
  
#line 73 
  hdr->frame_control = (unsigned short)8U;
  
#line 74 
  hdr->duration_id = (unsigned short)0U;
  
#line 76 
  memcpy((void *)(& hdr->addr1),(void const *)(& (hw->wiphy)->perm_addr),6UL);
  
#line 77 
  memcpy((void *)(& hdr->addr2),(void const *)(& (hw->wiphy)->perm_addr),6UL);
  
#line 78 
  memcpy((void *)(& hdr->addr3),(void const *)(& (hw->wiphy)->perm_addr),6UL);
  
#line 80 
  hdr->seq_ctrl = (unsigned short)((int)hdr->seq_ctrl | (int)avp->seq_no);
  
#line 82 
  tx_info = IEEE80211_SKB_CB(skb);
  
#line 83 
  memset((void *)tx_info,0,48UL);
  
#line 84 
  rate = & tx_info->__anonCompField_ieee80211_tx_info_98.control.__anonCompField___anonstruct_control_358_96.__anonCompField___anonunion_359_95.rates[0];
  
#line 85 
  tx_info->band = (unsigned char)((sc->cur_chan)->chandef.chan)->band;
  
#line 86 
  tx_info->flags = 4U;
  
#line 87 
  tx_info->__anonCompField_ieee80211_tx_info_98.control.vif = sc->tx99_vif;
  
#line 88 
  rate->count = (unsigned short __attribute__((__FRAMA_C_BITFIELD_SIZE__(5))))1U;
  
#line 89 
  if (ah->curchan != (struct ath9k_channel *)0 && ((unsigned long)(ah->curchan)->channelFlags & 8UL) != 0UL) {
    
#line 90 
    rate->flags = (unsigned short __attribute__((__FRAMA_C_BITFIELD_SIZE__(11))))((unsigned int)rate->flags | 8U);
    
#line 91 
    if (((unsigned long)(ah->curchan)->channelFlags & 48UL) != 0UL) 
#line 92 
                                                                    rate->flags = (unsigned short __attribute__((__FRAMA_C_BITFIELD_SIZE__(11))))((unsigned int)rate->flags | 32U); else ;
  }
  else ;
  
#line 95 
  memcpy((void *)(skb->data + 30U),(void const *)(& PN9Data),64UL);
  
#line 97 
  __retres = skb;
  return_label: 
#line 97 
                return __retres;
}


#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/tx99.c"
static void ath9k_tx99_deinit(struct ath_softc *sc)
{
  
#line 102 
  ath_reset(sc,(struct ath9k_channel *)0);
  
#line 104 
  ath9k_ps_wakeup(sc);
  
#line 105 
  ath9k_tx99_stop(sc);
  
#line 106 
  ath9k_ps_restore(sc);
  
#line 107 
  return;
}


#line 109  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/tx99.c"
static int ath9k_tx99_init(struct ath_softc *sc)
{
  int __retres;
  struct ath_tx_control txctl;
  int r;
  int tmp_0;
  
#line 111 
  struct ieee80211_hw *hw = sc->hw;
  
#line 112 
  struct ath_hw *ah = sc->sc_ah;
  
#line 113 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 117 
  tmp_0 = constant_test_bit(0L,(unsigned long const volatile *)(& common->op_flags));
  
#line 117 
  if (tmp_0 != 0) {
    
#line 118 
    ath_printk("\001",(struct ath_common const *)common,"driver is in invalid state unable to use TX99");
    
#line 120 
    __retres = -22;
    
#line 120 
    goto return_label;
  }
  else ;
  
#line 123 
  sc->tx99_skb = ath9k_build_tx99_skb(sc);
  
#line 124 
  if (sc->tx99_skb == (struct sk_buff *)0) {
    
#line 125 
    __retres = -12;
    
#line 125 
    goto return_label;
  }
  else ;
  
#line 127 
  memset((void *)(& txctl),0,32UL);
  
#line 128 
  txctl.txq = sc->tx.txq_map[0];
  
#line 130 
  ath_reset(sc,(struct ath9k_channel *)0);
  
#line 132 
  ath9k_ps_wakeup(sc);
  
#line 134 
  ath9k_hw_disable_interrupts(ah);
  
#line 135 
  atomic_set(& ah->intr_ref_cnt,-1);
  
#line 136 
  ath_drain_all_txq(sc);
  
#line 137 
  ath_stoprecv(sc);
  
#line 139 
  sc->tx99_state = (_Bool)1;
  
#line 141 
  ieee80211_stop_queues(hw);
  
#line 143 
  if ((int)sc->tx99_power == 64) 
#line 144 
                                 sc->tx99_power = (short)63; else ;
  
#line 146 
  ath9k_hw_tx99_set_txpower(ah,(unsigned char)((int)((unsigned char)sc->tx99_power)));
  
#line 147 
  r = ath9k_tx99_send(sc,sc->tx99_skb,& txctl);
  
#line 148 
  if (r != 0) {
    
#line 149 
    if ((common->debug_mask & 128) != 0) 
#line 149 
                                         ath_printk("\001",(struct ath_common const *)common,"Failed to xmit TX99 skb\n"); else ;
    
#line 150 
    __retres = r;
    
#line 150 
    goto return_label;
  }
  else ;
  
#line 153 
  if ((common->debug_mask & 128) != 0) 
#line 153 
                                       ath_printk("\001",(struct ath_common const *)common,"TX99 xmit started using %d ( %ddBm)\n",(int)sc->tx99_power,(int)sc->tx99_power / 2); else ;
  
#line 159 
  __retres = 0;
  return_label: 
#line 159 
                return __retres;
}


#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/tx99.c"
static ssize_t read_file_tx99(struct file *file, char *user_buf, size_t count, loff_t *ppos)
{
  char buf[3U];
  unsigned int len;
  int tmp;
  ssize_t tmp_0;
  
#line 165 
  struct ath_softc *sc = (struct ath_softc *)file->private_data;
  
#line 169 
  tmp = sprintf((char *)(& buf),"%d\n",(int)sc->tx99_state);
  
#line 169 
  len = (unsigned int)tmp;
  
#line 170 
  tmp_0 = simple_read_from_buffer((void *)user_buf,count,ppos,(void const *)(& buf),(unsigned long)len);
  
#line 170 
  return tmp_0;
}


#line 173  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/tx99.c"
static ssize_t write_file_tx99(struct file *file, char const *user_buf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  char buf[32U];
  bool start;
  ssize_t len;
  int r;
  unsigned long tmp_1;
  unsigned long tmp_2;
  int tmp_3;
  
#line 176 
  struct ath_softc *sc = (struct ath_softc *)file->private_data;
  
#line 177 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 183 
  if ((int)(sc->cur_chan)->nvifs > 1) {
    
#line 184 
    __retres = -95L;
    
#line 184 
    goto return_label;
  }
  else ;
  {
    unsigned long tmp_0;
    
#line 186 
    size_t _min1 = count;
    
#line 186 
    unsigned long _min2 = 31UL;
    
#line 186 
    if (_min1 < _min2) 
#line 186 
                       tmp_0 = _min1; else 
#line 186 
                                           tmp_0 = _min2;
    
#line 186 
    tmp_1 = tmp_0;
  }
  
#line 186 
  len = (long)tmp_1;
  
#line 187 
  tmp_2 = copy_from_user((void *)(& buf),(void const *)user_buf,(unsigned long)len);
  
#line 187 
  if (tmp_2 != 0UL) {
    
#line 188 
    __retres = -14L;
    
#line 188 
    goto return_label;
  }
  else ;
  
#line 190 
  tmp_3 = strtobool((char const *)(& buf),& start);
  
#line 190 
  if (tmp_3 != 0) {
    
#line 191 
    __retres = -22L;
    
#line 191 
    goto return_label;
  }
  else ;
  
#line 193 
  if ((int)sc->tx99_state == (int)start) {
    
#line 194 
    if (! start) {
      
#line 195 
      __retres = (long)count;
      
#line 195 
      goto return_label;
    }
    else ;
    
#line 196 
    if ((common->debug_mask & 128) != 0) 
#line 196 
                                         ath_printk("\001",(struct ath_common const *)common,"Resetting TX99\n"); else ;
    
#line 197 
    ath9k_tx99_deinit(sc);
  }
  else ;
  
#line 200 
  if (! start) {
    
#line 201 
    ath9k_tx99_deinit(sc);
    
#line 202 
    __retres = (long)count;
    
#line 202 
    goto return_label;
  }
  else ;
  
#line 205 
  r = ath9k_tx99_init(sc);
  
#line 206 
  if (r != 0) {
    
#line 207 
    __retres = (long)r;
    
#line 207 
    goto return_label;
  }
  else ;
  
#line 209 
  __retres = (long)count;
  return_label: 
#line 209 
                return __retres;
}


#line 212  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/tx99.c"
static struct file_operations const fops_tx99 = {.owner = & __this_module, .llseek = & default_llseek, .read = & read_file_tx99, .write = & write_file_tx99, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/tx99.c"
static ssize_t read_file_tx99_power(struct file *file, char *user_buf, size_t count, loff_t *ppos)
{
  char buf[32U];
  unsigned int len;
  int tmp;
  ssize_t tmp_0;
  
#line 224 
  struct ath_softc *sc = (struct ath_softc *)file->private_data;
  
#line 228 
  tmp = sprintf((char *)(& buf),"%d (%d dBm)\n",(int)sc->tx99_power,(int)sc->tx99_power / 2);
  
#line 228 
  len = (unsigned int)tmp;
  
#line 232 
  tmp_0 = simple_read_from_buffer((void *)user_buf,count,ppos,(void const *)(& buf),(unsigned long)len);
  
#line 232 
  return tmp_0;
}


#line 235  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/tx99.c"
static ssize_t write_file_tx99_power(struct file *file, char const *user_buf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int r;
  u8 tx_power;
  
#line 239 
  struct ath_softc *sc = (struct ath_softc *)file->private_data;
  
#line 243 
  r = kstrtou8_from_user(user_buf,count,0U,& tx_power);
  
#line 244 
  if (r != 0) {
    
#line 245 
    __retres = (long)r;
    
#line 245 
    goto return_label;
  }
  else ;
  
#line 247 
  if ((unsigned int)tx_power > 63U) {
    
#line 248 
    __retres = -22L;
    
#line 248 
    goto return_label;
  }
  else ;
  
#line 250 
  sc->tx99_power = (short)tx_power;
  
#line 252 
  ath9k_ps_wakeup(sc);
  
#line 253 
  ath9k_hw_tx99_set_txpower(sc->sc_ah,(unsigned char)((int)((unsigned char)sc->tx99_power)));
  
#line 254 
  ath9k_ps_restore(sc);
  
#line 256 
  __retres = (long)count;
  return_label: 
#line 256 
                return __retres;
}


#line 259  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/tx99.c"
static struct file_operations const fops_tx99_power = {.owner = & __this_module, .llseek = & default_llseek, .read = & read_file_tx99_power, .write = & write_file_tx99_power, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 267  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/tx99.c"
void ath9k_tx99_init_debug(struct ath_softc *sc)
{
  
#line 269 
  if ((sc->sc_ah)->hw_version.macVersion <= 447U) 
#line 270 
                                                  goto return_label; else ;
  
#line 272 
  ldv_debugfs_create_file_72_1("tx99",(unsigned short)384,sc->debug.debugfs_phy,(void *)sc,& fops_tx99);
  
#line 275 
  ldv_debugfs_create_file_73_1("tx99_power",(unsigned short)384,sc->debug.debugfs_phy,(void *)sc,& fops_tx99_power);
  return_label: 
#line 278 
                return;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_tx99.c.aux"
struct file_operations *ldv_emg_alias_fops_tx99_power_2 = (struct file_operations *)(& fops_tx99_power);

#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_tx99.c.aux"
struct file_operations *ldv_emg_alias_fops_tx99_2 = (struct file_operations *)(& fops_tx99);

#line 72  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_tx99.c.aux"
long ldv_emg_wrapper_read_file_tx99_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 73 
  tmp = read_file_tx99(arg0,arg1,arg2,arg3);
  
#line 73 
  return tmp;
}


#line 77  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_tx99.c.aux"
long ldv_emg_wrapper_write_file_tx99_4(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 78 
  tmp = write_file_tx99(arg0,(char const *)arg1,arg2,arg3);
  
#line 78 
  return tmp;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_tx99.c.aux"
long ldv_emg_wrapper_read_file_tx99_power_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 83 
  tmp = read_file_tx99_power(arg0,arg1,arg2,arg3);
  
#line 83 
  return tmp;
}


#line 87  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_tx99.c.aux"
long ldv_emg_wrapper_write_file_tx99_power_4(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 88 
  tmp = write_file_tx99_power(arg0,(char const *)arg1,arg2,arg3);
  
#line 88 
  return tmp;
}


#line 763  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_tx99.c.aux"
static struct dentry *ldv_debugfs_create_file_72_1(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 767 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 767 
  return tmp;
}


#line 771  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_tx99.c.aux"
static struct dentry *ldv_debugfs_create_file_73_1(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 775 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 775 
  return tmp;
}


#line 581  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kzalloc_2(size_t size, gfp_t flags);


#line 135  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/btcoex.h"
void ath9k_hw_btcoex_set_concur_txprio(struct ath_hw *, u8 *);


#line 306  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ar9003_mci.h"
bool ar9003_mci_send_message(struct ath_hw *, u8, u32, u32 *, u8, bool, bool);


#line 310 
int ar9003_mci_setup(struct ath_hw *, u32, void *, u16, u32);


#line 312 
void ar9003_mci_cleanup(struct ath_hw *);


#line 313 
void ar9003_mci_get_interrupt(struct ath_hw *, u32 *, u32 *);


#line 315 
u32 ar9003_mci_get_next_gpm_offset(struct ath_hw *, u32 *);


#line 316 
void ar9003_mci_set_bt_version(struct ath_hw *, u8, u8);


#line 317 
void ar9003_mci_send_wlan_channels(struct ath_hw *);


#line 160  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mci.h"
void ath_mci_enable(struct ath_softc *sc);


#line 161 
void ath9k_mci_update_wlan_channels(struct ath_softc *sc, bool allow_all);


#line 162 
void ath9k_mci_set_txpower(struct ath_softc *sc, bool setchannel, bool concur_tx);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mci.c"
static u8 const ath_mci_duty_cycle[9U] = {(unsigned char)55U, (unsigned char)50U, (unsigned char)60U, (unsigned char)70U, (unsigned char)80U, (unsigned char)85U, (unsigned char)90U, (unsigned char)95U, (unsigned char)98U};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mci.c"
static struct ath_mci_profile_info *ath_mci_find_profile(struct ath_mci_profile *mci, struct ath_mci_profile_info *info)
{
  struct ath_mci_profile_info *__retres;
  struct ath_mci_profile_info *entry;
  int tmp;
  struct ath_mci_profile_info *tmp_0;
  struct ath_mci_profile_info *tmp_1;
  
#line 31 
  tmp = list_empty((struct list_head const *)(& mci->info));
  
#line 31 
  if (tmp != 0) {
    
#line 32 
    __retres = (struct ath_mci_profile_info *)0;
    
#line 32 
    goto return_label;
  }
  else ;
  {
    
#line 34 
    struct list_head const *__mptr = (struct list_head const *)mci->info.next;
    
#line 34 
    tmp_0 = (struct ath_mci_profile_info *)__mptr + 18446744073709551600U;
  }
  
#line 34 
  entry = tmp_0;
  
#line 34 
  goto ldv_53347;
  ldv_53346: 
#line 35 
  ;
  
#line 35 
  if ((int)entry->conn_handle == (int)info->conn_handle) {
    
#line 36 
    __retres = entry;
    
#line 36 
    goto return_label;
  }
  else ;
  {
    
#line 34 
    struct list_head const *__mptr_0 = (struct list_head const *)entry->list.next;
    
#line 34 
    tmp_1 = (struct ath_mci_profile_info *)__mptr_0 + 18446744073709551600U;
  }
  
#line 34 
  entry = tmp_1;
  ldv_53347: 
#line 36 
  ;
  
#line 34 
  if (& entry->list != & mci->info) 
#line 36 
                                    goto ldv_53346; else 
#line 39 
                                                         goto ldv_53348;
  ldv_53348: 
#line 40 
  ;
  
#line 38 
  __retres = (struct ath_mci_profile_info *)0;
  return_label: 
#line 38 
                return __retres;
}


#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mci.c"
static bool ath_mci_add_profile(struct ath_common *common, struct ath_mci_profile *mci, struct ath_mci_profile_info *info)
{
  bool __retres;
  struct ath_mci_profile_info *entry;
  
#line 46 
  u8 voice_priority[9U] = {(unsigned char)110U, (unsigned char)110U, (unsigned char)110U, (unsigned char)112U, (unsigned char)110U, (unsigned char)110U, (unsigned char)114U, (unsigned char)116U, (unsigned char)118U};
  
#line 48 
  if ((unsigned int)mci->num_sco == 1U && (unsigned int)info->type == 5U) {
    
#line 50 
    __retres = (_Bool)0;
    
#line 50 
    goto return_label;
  }
  else ;
  
#line 52 
  if ((((int)mci->num_other_acl + (int)mci->num_a2dp) + (int)mci->num_hid) + (int)mci->num_pan == 7 && (unsigned int)info->type != 5U) {
    
#line 54 
    __retres = (_Bool)0;
    
#line 54 
    goto return_label;
  }
  else ;
  
#line 56 
  entry = (struct ath_mci_profile_info *)kzalloc_2(32UL,32U);
  
#line 57 
  if (entry == (struct ath_mci_profile_info *)0) {
    
#line 58 
    __retres = (_Bool)0;
    
#line 58 
    goto return_label;
  }
  else ;
  
#line 60 
  memcpy((void *)entry,(void const *)info,10UL);
  
#line 61 
  switch ((int)info->type) {
    case 1: 
#line 61 
    ;
    
#line 61 
    mci->num_other_acl = (u8)((int)mci->num_other_acl + 1);
    
#line 61 
    goto ldv_53357;
    case 2: 
#line 61 
    ;
    
#line 61 
    mci->num_a2dp = (u8)((int)mci->num_a2dp + 1);
    
#line 61 
    if (! info->edr) 
#line 61 
                     mci->num_bdr = (u8)((int)mci->num_bdr + 1); else ;
    
#line 61 
    goto ldv_53357;
    case 3: 
#line 61 
    ;
    
#line 61 
    mci->num_hid = (u8)((int)mci->num_hid + 1);
    
#line 61 
    goto ldv_53357;
    case 4: 
#line 61 
    ;
    
#line 61 
    mci->num_pan = (u8)((int)mci->num_pan + 1);
    
#line 61 
    goto ldv_53357;
    case 5: 
#line 61 
    ;
    case 6: 
#line 61 
    ;
    
#line 61 
    mci->num_sco = (u8)((int)mci->num_sco + 1);
    
#line 61 
    goto ldv_53357;
    default: 
#line 61 
    ;
    
#line 61 
    goto ldv_53357;
  }
  ldv_53357: 
#line 61 
  ;
  
#line 62 
  list_add_tail(& entry->list,& mci->info);
  
#line 63 
  if ((unsigned int)info->type == 5U) 
    
#line 64 
    if ((unsigned int)info->voice_type <= 8U) 
#line 65 
                                              mci->voice_priority = voice_priority[(int)info->voice_type]; else 
                                                                    
#line 67 
                                                                    mci->voice_priority = (unsigned char)110U;
  else ;
  
#line 70 
  __retres = (_Bool)1;
  return_label: 
#line 70 
                return __retres;
}


#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mci.c"
static void ath_mci_del_profile(struct ath_common *common, struct ath_mci_profile *mci, struct ath_mci_profile_info *entry)
{
  
#line 77 
  if (entry == (struct ath_mci_profile_info *)0) 
#line 78 
                                                 goto return_label; else ;
  
#line 80 
  switch ((int)entry->type) {
    case 1: 
#line 80 
    ;
    
#line 80 
    mci->num_other_acl = (u8)((int)mci->num_other_acl - 1);
    
#line 80 
    goto ldv_53370;
    case 2: 
#line 80 
    ;
    
#line 80 
    mci->num_a2dp = (u8)((int)mci->num_a2dp - 1);
    
#line 80 
    if (! entry->edr) 
#line 80 
                      mci->num_bdr = (u8)((int)mci->num_bdr - 1); else ;
    
#line 80 
    goto ldv_53370;
    case 3: 
#line 80 
    ;
    
#line 80 
    mci->num_hid = (u8)((int)mci->num_hid - 1);
    
#line 80 
    goto ldv_53370;
    case 4: 
#line 80 
    ;
    
#line 80 
    mci->num_pan = (u8)((int)mci->num_pan - 1);
    
#line 80 
    goto ldv_53370;
    case 5: 
#line 80 
    ;
    case 6: 
#line 80 
    ;
    
#line 80 
    mci->num_sco = (u8)((int)mci->num_sco - 1);
    
#line 80 
    goto ldv_53370;
    default: 
#line 80 
    ;
    
#line 80 
    goto ldv_53370;
  }
  ldv_53370: 
#line 80 
  ;
  
#line 81 
  list_del(& entry->list);
  
#line 82 
  kfree((void const *)entry);
  return_label: 
#line 83 
                return;
}


#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mci.c"
void ath_mci_flush_profile(struct ath_mci_profile *mci)
{
  struct ath_mci_profile_info *info;
  struct ath_mci_profile_info *tinfo;
  int tmp;
  struct ath_mci_profile_info *tmp_0;
  struct ath_mci_profile_info *tmp_1;
  struct ath_mci_profile_info *tmp_2;
  
#line 89 
  mci->aggr_limit = (unsigned short)0U;
  
#line 90 
  mci->num_mgmt = (unsigned char)0U;
  
#line 92 
  tmp = list_empty((struct list_head const *)(& mci->info));
  
#line 92 
  if (tmp != 0) 
#line 93 
                goto return_label; else ;
  {
    
#line 95 
    struct list_head const *__mptr = (struct list_head const *)mci->info.next;
    
#line 95 
    tmp_0 = (struct ath_mci_profile_info *)__mptr + 18446744073709551600U;
  }
  
#line 95 
  info = tmp_0;
  {
    
#line 95 
    struct list_head const *__mptr_0 = (struct list_head const *)info->list.next;
    
#line 95 
    tmp_1 = (struct ath_mci_profile_info *)__mptr_0 + 18446744073709551600U;
  }
  
#line 96 
  tinfo = tmp_1;
  
#line 95 
  goto ldv_53397;
  ldv_53396: 
#line 96 
  ;
  
#line 96 
  list_del(& info->list);
  
#line 97 
  switch ((int)info->type) {
    case 1: 
#line 97 
    ;
    
#line 97 
    mci->num_other_acl = (u8)((int)mci->num_other_acl - 1);
    
#line 97 
    goto ldv_53389;
    case 2: 
#line 97 
    ;
    
#line 97 
    mci->num_a2dp = (u8)((int)mci->num_a2dp - 1);
    
#line 97 
    if (! info->edr) 
#line 97 
                     mci->num_bdr = (u8)((int)mci->num_bdr - 1); else ;
    
#line 97 
    goto ldv_53389;
    case 3: 
#line 97 
    ;
    
#line 97 
    mci->num_hid = (u8)((int)mci->num_hid - 1);
    
#line 97 
    goto ldv_53389;
    case 4: 
#line 97 
    ;
    
#line 97 
    mci->num_pan = (u8)((int)mci->num_pan - 1);
    
#line 97 
    goto ldv_53389;
    case 5: 
#line 97 
    ;
    case 6: 
#line 97 
    ;
    
#line 97 
    mci->num_sco = (u8)((int)mci->num_sco - 1);
    
#line 97 
    goto ldv_53389;
    default: 
#line 97 
    ;
    
#line 97 
    goto ldv_53389;
  }
  ldv_53389: 
#line 97 
  ;
  
#line 98 
  kfree((void const *)info);
  
#line 95 
  info = tinfo;
  {
    
#line 95 
    struct list_head const *__mptr_1 = (struct list_head const *)tinfo->list.next;
    
#line 95 
    tmp_2 = (struct ath_mci_profile_info *)__mptr_1 + 18446744073709551600U;
  }
  
#line 95 
  tinfo = tmp_2;
  ldv_53397: 
#line 97 
  ;
  
#line 95 
  if (& info->list != & mci->info) 
#line 97 
                                   goto ldv_53396; else 
#line 100 
                                                        goto ldv_53398;
  ldv_53398: 
#line 101 
  ;
  return_label: 
#line 102 
                return;
}


#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mci.c"
static void ath_mci_adjust_aggr_limit(struct ath_btcoex *btcoex)
{
  
#line 104 
  struct ath_mci_profile *mci = & btcoex->mci;
  
#line 105 
  u32 wlan_airtime = (btcoex->btcoex_period * (100U - btcoex->duty_cycle)) / 100U;
  
#line 114 
  if (wlan_airtime <= 4U && ((unsigned int)mci->aggr_limit == 0U || (unsigned int)mci->aggr_limit > wlan_airtime * 2U)) 
    
#line 116 
    mci->aggr_limit = (unsigned short)((unsigned int)((unsigned short)wlan_airtime) * 2U); else ;
  
#line 117 
  return;
}


#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mci.c"
static void ath_mci_update_scheme(struct ath_softc *sc)
{
  struct ath_mci_profile_info *info;
  int tmp_2;
  
#line 121 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 122 
  struct ath_btcoex *btcoex = & sc->btcoex;
  
#line 123 
  struct ath_mci_profile *mci = & btcoex->mci;
  
#line 124 
  struct ath9k_hw_mci *mci_hw = & (sc->sc_ah)->btcoex_hw.mci;
  
#line 126 
  u32 num_profile = (unsigned int)(((((int)mci->num_other_acl + (int)mci->num_a2dp) + (int)mci->num_hid) + (int)mci->num_pan) + (int)mci->num_sco);
  
#line 128 
  if ((mci_hw->config & 16384U) != 0U) 
#line 129 
                                       goto skip_tuning; else ;
  
#line 131 
  mci->aggr_limit = (unsigned short)0U;
  
#line 132 
  btcoex->duty_cycle = (unsigned int)ath_mci_duty_cycle[num_profile];
  
#line 133 
  btcoex->btcoex_period = 40U;
  
#line 134 
  if (((((int)mci->num_other_acl + (int)mci->num_a2dp) + (int)mci->num_hid) + (int)mci->num_pan) + (int)mci->num_sco != 0) 
    
#line 135 
    btcoex->bt_stomp_type = 1; else 
#line 137 
                                    btcoex->bt_stomp_type = (unsigned int)mci->num_mgmt == 0U;
  
#line 140 
  if (num_profile == 1U) {
    struct ath_mci_profile_info *tmp_0;
    {
      
#line 141 
      struct list_head const *__mptr = (struct list_head const *)mci->info.next;
      
#line 141 
      tmp_0 = (struct ath_mci_profile_info *)__mptr + 18446744073709551600U;
    }
    
#line 141 
    info = tmp_0;
    
#line 144 
    if ((unsigned int)mci->num_sco != 0U) {
      
#line 145 
      if ((unsigned int)info->T == 12U) 
#line 146 
                                        mci->aggr_limit = (unsigned short)8U;
      else 
        
#line 147 
        if ((unsigned int)info->T == 6U) {
          
#line 148 
          mci->aggr_limit = (unsigned short)6U;
          
#line 149 
          btcoex->duty_cycle = 30U;
        }
        else 
#line 151 
             mci->aggr_limit = (unsigned short)6U;
      
#line 152 
      if ((common->debug_mask & 32768) != 0) 
#line 152 
                                             ath_printk("\001",(struct ath_common const *)common,"Single SCO, aggregation limit %d 1/4 ms\n",(int)mci->aggr_limit); else ;
    }
    else 
      
#line 155 
      if ((unsigned int)mci->num_pan != 0U || (unsigned int)mci->num_other_acl != 0U) {
        int tmp_1;
        
#line 160 
        if ((sc->sc_ah)->hw_version.macVersion == 704U) 
#line 160 
                                                        tmp_1 = 40; else 
                                                                    
#line 160 
                                                                    tmp_1 = 35;
        
#line 160 
        btcoex->duty_cycle = (unsigned int)tmp_1;
        
#line 161 
        btcoex->btcoex_period = 53U;
        
#line 162 
        if ((common->debug_mask & 32768) != 0) 
#line 162 
                                               ath_printk("\001",(struct ath_common const *)common,"Single PAN/FTP bt period %d ms dutycycle %d\n",btcoex->duty_cycle,btcoex->btcoex_period); else ;
      }
      else 
        
#line 165 
        if ((unsigned int)mci->num_hid != 0U) {
          
#line 166 
          btcoex->duty_cycle = 30U;
          
#line 167 
          mci->aggr_limit = (unsigned short)6U;
          
#line 168 
          if ((common->debug_mask & 32768) != 0) 
#line 168 
                                                 ath_printk("\001",(struct ath_common const *)common,"Multiple attempt/timeout single HID "); else ;
        }
        else ;
  }
  else 
    
#line 172 
    if (num_profile == 2U) {
      
#line 173 
      if ((unsigned int)mci->num_hid == 2U) 
#line 174 
                                            btcoex->duty_cycle = 30U; else ;
      
#line 175 
      mci->aggr_limit = (unsigned short)6U;
      
#line 176 
      if ((common->debug_mask & 32768) != 0) 
#line 176 
                                             ath_printk("\001",(struct ath_common const *)common,"Two BT profiles aggr limit 1.5 ms dutycycle %d%%\n",btcoex->duty_cycle); else ;
    }
    else 
      
#line 179 
      if (num_profile > 2U) {
        
#line 180 
        mci->aggr_limit = (unsigned short)4U;
        
#line 181 
        if ((common->debug_mask & 32768) != 0) 
#line 181 
                                               ath_printk("\001",(struct ath_common const *)common,"Three or more profiles aggregation limit 1 ms\n"); else ;
      }
      else ;
  skip_tuning: 
#line 185 
  ;
  
#line 186 
  if (((unsigned long)((sc->sc_ah)->curchan)->channelFlags & 1UL) == 0UL) 
    
#line 187 
    if (((unsigned long)((sc->sc_ah)->curchan)->channelFlags & 8UL) != 0UL) 
      
#line 188 
      ath_mci_adjust_aggr_limit(btcoex); else 
#line 190 
                                              btcoex->btcoex_period >>= 1;
  else ;
  
#line 193 
  ath9k_btcoex_timer_pause(sc);
  
#line 194 
  ath9k_hw_btcoex_disable(sc->sc_ah);
  
#line 196 
  if (((unsigned long)((sc->sc_ah)->curchan)->channelFlags & 1UL) != 0UL) 
    
#line 197 
    goto return_label; else ;
  
#line 199 
  if ((unsigned int)mci->num_bdr != 0U) 
#line 199 
                                        tmp_2 = 20; else 
#line 199 
                                                         tmp_2 = 0;
  
#line 199 
  btcoex->duty_cycle += (unsigned int)tmp_2;
  
#line 200 
  if (btcoex->duty_cycle > 90U) 
#line 201 
                                btcoex->duty_cycle = 90U; else ;
  
#line 203 
  btcoex->btcoex_no_stomp = (btcoex->btcoex_period * (100U - btcoex->duty_cycle)) / 100U;
  
#line 206 
  ath9k_hw_btcoex_enable(sc->sc_ah);
  
#line 207 
  ath9k_btcoex_timer_resume(sc);
  return_label: 
#line 208 
                return;
}


#line 210  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mci.c"
static void ath_mci_cal_msg(struct ath_softc *sc, u8 opcode, u8 *rx_payload)
{
  
#line 212 
  struct ath_hw *ah = sc->sc_ah;
  
#line 213 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 214 
  struct ath9k_hw_mci *mci_hw = & ah->btcoex_hw.mci;
  
#line 215 
  u32 payload[4U] = {0U, 0U, 0U, 0U};
  
#line 217 
  switch ((int)opcode) {
    case 0: 
#line 218 
    ;
    
#line 219 
    if ((unsigned int)mci_hw->bt_state == 1U) {
      
#line 220 
      mci_hw->bt_state = (unsigned char)2U;
      
#line 221 
      ath9k_queue_reset(sc,(enum ath_reset_type)RESET_TYPE_MCI);
    }
    else ;
    
#line 223 
    if ((common->debug_mask & 32768) != 0) 
#line 223 
                                           ath_printk("\001",(struct ath_common const *)common,"MCI State : %d\n",(int)mci_hw->bt_state); else ;
    
#line 224 
    goto ldv_53426;
    case 1: 
#line 225 
    ;
    
#line 226 
    *((u8 *)(& payload) + 4U) = (unsigned char)5U;
    
#line 227 
    ar9003_mci_send_message(sc->sc_ah,(unsigned char)128,0U,(u32 *)(& payload),(unsigned char)16,(_Bool)0,(_Bool)1);
    
#line 229 
    goto ldv_53426;
    default: 
#line 230 
    ;
    
#line 231 
    if ((common->debug_mask & 32768) != 0) 
#line 231 
                                           ath_printk("\001",(struct ath_common const *)common,"Unknown GPM CAL message\n"); else ;
    
#line 232 
    goto ldv_53426;
  }
  ldv_53426: 
#line 234 
  ;
  
#line 235 
  return;
}


#line 236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mci.c"
static void ath9k_mci_work(struct work_struct *work)
{
  struct ath_softc *tmp;
  {
    
#line 238 
    struct work_struct const *__mptr = (struct work_struct const *)work;
    
#line 238 
    tmp = (struct ath_softc *)__mptr + 18446744073709536272U;
  }
  
#line 238 
  struct ath_softc *sc = tmp;
  
#line 240 
  ath_mci_update_scheme(sc);
  
#line 241 
  return;
}


#line 243  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mci.c"
static void ath_mci_update_stomp_txprio(u8 cur_txprio, u8 *stomp_prio)
{
  
#line 245 
  if ((int)*(stomp_prio + 2U) > (int)cur_txprio) 
#line 246 
                                                 *(stomp_prio + 2U) = cur_txprio; else ;
  
#line 248 
  if ((int)*stomp_prio < (int)cur_txprio) 
#line 249 
                                          *stomp_prio = cur_txprio; else ;
  
#line 251 
  if ((unsigned int)cur_txprio > 60U && (int)*(stomp_prio + 1U) > (int)cur_txprio) 
    
#line 253 
    *(stomp_prio + 1U) = cur_txprio; else ;
  
#line 254 
  return;
}


#line 256  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mci.c"
static void ath_mci_set_concur_txprio(struct ath_softc *sc)
{
  u8 stomp_txprio[5U];
  
#line 258 
  struct ath_btcoex *btcoex = & sc->btcoex;
  
#line 259 
  struct ath_mci_profile *mci = & btcoex->mci;
  
#line 262 
  memset((void *)(& stomp_txprio),0,5UL);
  
#line 263 
  if ((unsigned int)mci->num_mgmt != 0U) {
    
#line 264 
    stomp_txprio[0] = (unsigned char)62U;
    
#line 265 
    if ((unsigned int)mci->num_pan == 0U && (unsigned int)mci->num_other_acl == 0U) 
      
#line 266 
      stomp_txprio[2] = (unsigned char)62U; else ;
  }
  else {
    
#line 269 
    u8 prof_prio[4U] = {(unsigned char)50U, (unsigned char)90U, (unsigned char)94U, (unsigned char)52U};
    
#line 271 
    stomp_txprio[2] = (unsigned char)255U;
    
#line 271 
    stomp_txprio[1] = stomp_txprio[2];
    
#line 274 
    if ((unsigned int)mci->num_sco != 0U) 
#line 275 
                                          ath_mci_update_stomp_txprio((unsigned char)((int)mci->voice_priority),(u8 *)(& stomp_txprio)); else ;
    
#line 277 
    if ((unsigned int)mci->num_other_acl != 0U) 
#line 278 
                                                ath_mci_update_stomp_txprio((unsigned char)((int)prof_prio[0]),(u8 *)(& stomp_txprio)); else ;
    
#line 279 
    if ((unsigned int)mci->num_a2dp != 0U) 
#line 280 
                                           ath_mci_update_stomp_txprio((unsigned char)((int)prof_prio[1]),(u8 *)(& stomp_txprio)); else ;
    
#line 281 
    if ((unsigned int)mci->num_hid != 0U) 
#line 282 
                                          ath_mci_update_stomp_txprio((unsigned char)((int)prof_prio[2]),(u8 *)(& stomp_txprio)); else ;
    
#line 283 
    if ((unsigned int)mci->num_pan != 0U) 
#line 284 
                                          ath_mci_update_stomp_txprio((unsigned char)((int)prof_prio[3]),(u8 *)(& stomp_txprio)); else ;
    
#line 286 
    if ((unsigned int)stomp_txprio[2] == 255U) 
#line 287 
                                               stomp_txprio[2] = (unsigned char)0U; else ;
    
#line 289 
    if ((unsigned int)stomp_txprio[1] == 255U) 
#line 290 
                                               stomp_txprio[1] = (unsigned char)0U; else ;
  }
  
#line 292 
  ath9k_hw_btcoex_set_concur_txprio(sc->sc_ah,(u8 *)(& stomp_txprio));
  
#line 293 
  return;
}


#line 295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mci.c"
static u8 ath_mci_process_profile(struct ath_softc *sc, struct ath_mci_profile_info *info)
{
  u8 __retres;
  
#line 298 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 299 
  struct ath_btcoex *btcoex = & sc->btcoex;
  
#line 300 
  struct ath_mci_profile *mci = & btcoex->mci;
  
#line 301 
  struct ath_mci_profile_info *entry = (struct ath_mci_profile_info *)0;
  
#line 303 
  entry = ath_mci_find_profile(mci,info);
  
#line 304 
  if (entry != (struct ath_mci_profile_info *)0) {
    
#line 313 
    if ((int)entry->type != (int)info->type) {
      
#line 314 
      switch ((int)entry->type) {
        case 1: 
#line 314 
        ;
        
#line 314 
        mci->num_other_acl = (u8)((int)mci->num_other_acl - 1);
        
#line 314 
        goto ldv_53455;
        case 2: 
#line 314 
        ;
        
#line 314 
        mci->num_a2dp = (u8)((int)mci->num_a2dp - 1);
        
#line 314 
        if (! entry->edr) 
#line 314 
                          mci->num_bdr = (u8)((int)mci->num_bdr - 1); else ;
        
#line 314 
        goto ldv_53455;
        case 3: 
#line 314 
        ;
        
#line 314 
        mci->num_hid = (u8)((int)mci->num_hid - 1);
        
#line 314 
        goto ldv_53455;
        case 4: 
#line 314 
        ;
        
#line 314 
        mci->num_pan = (u8)((int)mci->num_pan - 1);
        
#line 314 
        goto ldv_53455;
        case 5: 
#line 314 
        ;
        case 6: 
#line 314 
        ;
        
#line 314 
        mci->num_sco = (u8)((int)mci->num_sco - 1);
        
#line 314 
        goto ldv_53455;
        default: 
#line 314 
        ;
        
#line 314 
        goto ldv_53455;
      }
      ldv_53455: 
#line 314 
      ;
      
#line 315 
      switch ((int)info->type) {
        case 1: 
#line 315 
        ;
        
#line 315 
        mci->num_other_acl = (u8)((int)mci->num_other_acl + 1);
        
#line 315 
        goto ldv_53463;
        case 2: 
#line 315 
        ;
        
#line 315 
        mci->num_a2dp = (u8)((int)mci->num_a2dp + 1);
        
#line 315 
        if (! info->edr) 
#line 315 
                         mci->num_bdr = (u8)((int)mci->num_bdr + 1); else ;
        
#line 315 
        goto ldv_53463;
        case 3: 
#line 315 
        ;
        
#line 315 
        mci->num_hid = (u8)((int)mci->num_hid + 1);
        
#line 315 
        goto ldv_53463;
        case 4: 
#line 315 
        ;
        
#line 315 
        mci->num_pan = (u8)((int)mci->num_pan + 1);
        
#line 315 
        goto ldv_53463;
        case 5: 
#line 315 
        ;
        case 6: 
#line 315 
        ;
        
#line 315 
        mci->num_sco = (u8)((int)mci->num_sco + 1);
        
#line 315 
        goto ldv_53463;
        default: 
#line 315 
        ;
        
#line 315 
        goto ldv_53463;
      }
      ldv_53463: 
#line 315 
      ;
    }
    else ;
    
#line 317 
    memcpy((void *)entry,(void const *)info,10UL);
  }
  else ;
  
#line 320 
  if ((int)info->start != 0) {
    
#line 321 
    if (entry == (struct ath_mci_profile_info *)0) {
      int tmp_1;
      bool tmp_0;
      
#line 321 
      tmp_0 = ath_mci_add_profile(common,mci,info);
      
#line 321 
      if (tmp_0) 
#line 321 
                 tmp_1 = 0; else 
#line 321 
                                 tmp_1 = 1;
      
#line 321 
      if (tmp_1) {
        
#line 322 
        __retres = (unsigned char)0U;
        
#line 322 
        goto return_label;
      }
      else ;
    }
    else ;
  }
  else 
#line 324 
       ath_mci_del_profile(common,mci,entry);
  
#line 326 
  ath_mci_set_concur_txprio(sc);
  
#line 327 
  __retres = (unsigned char)1U;
  return_label: 
#line 327 
                return __retres;
}


#line 330  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mci.c"
static u8 ath_mci_process_status(struct ath_softc *sc, struct ath_mci_profile_status *status)
{
  u8 __retres;
  struct ath_mci_profile_info info;
  struct ath_mci_profile_info *tmp;
  int tmp_2;
  
#line 333 
  struct ath_btcoex *btcoex = & sc->btcoex;
  
#line 334 
  struct ath_mci_profile *mci = & btcoex->mci;
  
#line 336 
  int i = 0;
  
#line 336 
  int old_num_mgmt = (int)mci->num_mgmt;
  
#line 339 
  if ((int)status->is_link != 0) {
    
#line 340 
    __retres = (unsigned char)0U;
    
#line 340 
    goto return_label;
  }
  else ;
  
#line 342 
  info.conn_handle = status->conn_handle;
  
#line 343 
  tmp = ath_mci_find_profile(mci,& info);
  
#line 343 
  if (tmp != (struct ath_mci_profile_info *)0) {
    
#line 344 
    __retres = (unsigned char)0U;
    
#line 344 
    goto return_label;
  }
  else ;
  
#line 346 
  if ((unsigned int)status->conn_handle > 7U) {
    
#line 347 
    __retres = (unsigned char)0U;
    
#line 347 
    goto return_label;
  }
  else ;
  
#line 349 
  if ((int)status->is_critical != 0) 
#line 350 
                                     __set_bit((long)status->conn_handle,(unsigned long volatile *)(& mci->status)); else 
                                                                    
#line 352 
                                                                    __set_bit((long)status->conn_handle,(unsigned long volatile *)(& mci->status));
  
#line 354 
  mci->num_mgmt = (unsigned char)0U;
  ldv_53479: 
#line 355 
  ;
  
#line 356 
  if (0 != 0) {
    int tmp_0;
    
#line 356 
    tmp_0 = constant_test_bit((long)i,(unsigned long const volatile *)(& mci->status));
    
#line 356 
    tmp_2 = tmp_0 != 0;
  }
  else {
    int tmp_1;
    
#line 356 
    tmp_1 = variable_test_bit((long)i,(unsigned long const volatile *)(& mci->status));
    
#line 356 
    tmp_2 = tmp_1 != 0;
  }
  
#line 356 
  if (tmp_2) 
#line 357 
             mci->num_mgmt = (u8)((int)mci->num_mgmt + 1); else ;
  
#line 358 
  i += 1;
  
#line 358 
  if (i <= 7) 
#line 360 
              goto ldv_53479; else 
#line 363 
                                   goto ldv_53480;
  ldv_53480: 
#line 364 
  ;
  
#line 360 
  ath_mci_set_concur_txprio(sc);
  
#line 361 
  if ((int)mci->num_mgmt != old_num_mgmt) {
    
#line 362 
    __retres = (unsigned char)1U;
    
#line 362 
    goto return_label;
  }
  else ;
  
#line 364 
  __retres = (unsigned char)0U;
  return_label: 
#line 364 
                return __retres;
}


#line 367  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mci.c"
static void ath_mci_msg(struct ath_softc *sc, u8 opcode, u8 *rx_payload)
{
  struct ath_mci_profile_info profile_info;
  struct ath_mci_profile_status profile_status;
  u8 major;
  u8 minor;
  u32 seq_num;
  u32 tmp_0;
  
#line 369 
  struct ath_hw *ah = sc->sc_ah;
  
#line 372 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 373 
  u8 update_scheme = (unsigned char)0U;
  
#line 376 
  tmp_0 = ar9003_mci_state(ah,19U);
  
#line 376 
  if (tmp_0 != 0U) {
    u32 tmp_1;
    
#line 376 
    tmp_1 = ar9003_mci_state(ah,0U);
    
#line 376 
    if (tmp_1 != 0U) {
      
#line 378 
      if ((common->debug_mask & 32768) != 0) 
#line 378 
                                             ath_printk("\001",(struct ath_common const *)common,"(MCI) Need to flush BT profiles\n"); else ;
      
#line 379 
      ath_mci_flush_profile(& sc->btcoex.mci);
      
#line 380 
      ar9003_mci_state(ah,18U);
    }
    else ;
  }
  else ;
  
#line 383 
  switch ((int)opcode) {
    u8 tmp_2;
    u8 tmp_3;
    case 0: 
#line 384 
    ;
    
#line 385 
    ar9003_mci_state(ah,14U);
    
#line 386 
    goto ldv_53495;
    case 1: 
#line 387 
    ;
    
#line 388 
    major = *(rx_payload + 6U);
    
#line 389 
    minor = *(rx_payload + 7U);
    
#line 390 
    ar9003_mci_set_bt_version(ah,(unsigned char)((int)major),(unsigned char)((int)minor));
    
#line 391 
    goto ldv_53495;
    case 2: 
#line 392 
    ;
    
#line 393 
    ar9003_mci_send_wlan_channels(ah);
    
#line 394 
    goto ldv_53495;
    case 5: 
#line 395 
    ;
    
#line 396 
    memcpy((void *)(& profile_info),(void const *)(rx_payload + 6U),10UL);
    
#line 399 
    if ((unsigned int)profile_info.type + 255U > 5U) {
      
#line 401 
      if ((common->debug_mask & 32768) != 0) 
#line 401 
                                             ath_printk("\001",(struct ath_common const *)common,"Illegal profile type = %d, state = %d\n",(int)profile_info.type,(int)profile_info.start); else ;
      
#line 405 
      goto ldv_53495;
    }
    else ;
    
#line 408 
    tmp_2 = ath_mci_process_profile(sc,& profile_info);
    
#line 408 
    update_scheme = (unsigned char)((int)tmp_2 + (int)update_scheme);
    
#line 409 
    goto ldv_53495;
    case 6: 
#line 410 
    ;
    
#line 411 
    profile_status.is_link = (_Bool)((unsigned int)*(rx_payload + 6U) != 0U);
    
#line 413 
    profile_status.conn_handle = *(rx_payload + 7U);
    
#line 415 
    profile_status.is_critical = (_Bool)((unsigned int)*(rx_payload + 8U) != 0U);
    
#line 418 
    seq_num = *((u32 *)(rx_payload + 12U));
    
#line 419 
    if ((common->debug_mask & 32768) != 0) 
#line 419 
                                           ath_printk("\001",(struct ath_common const *)common,"BT_Status_Update: is_link=%d, linkId=%d, state=%d, SEQ=%u\n",(int)profile_status.is_link,(int)profile_status.conn_handle,(int)profile_status.is_critical,seq_num); else ;
    
#line 424 
    tmp_3 = ath_mci_process_status(sc,& profile_status);
    
#line 424 
    update_scheme = (unsigned char)((int)tmp_3 + (int)update_scheme);
    
#line 425 
    goto ldv_53495;
    default: 
#line 426 
    ;
    
#line 427 
    if ((common->debug_mask & 32768) != 0) 
#line 427 
                                           ath_printk("\001",(struct ath_common const *)common,"Unknown GPM COEX message = 0x%02x\n",(int)opcode); else ;
    
#line 428 
    goto ldv_53495;
  }
  ldv_53495: 
#line 430 
  ;
  
#line 430 
  if ((unsigned int)update_scheme != 0U) 
#line 431 
                                         ieee80211_queue_work(sc->hw,& sc->mci_work); else ;
  
#line 432 
  return;
}


#line 434  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mci.c"
int ath_mci_setup(struct ath_softc *sc)
{
  int __retres;
  int ret;
  
#line 436 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 437 
  struct ath_mci_coex *mci = & sc->mci_coex;
  
#line 438 
  struct ath_mci_buf *buf = & mci->sched_buf;
  
#line 441 
  buf->bf_addr = dmam_alloc_coherent(sc->dev,512UL,& buf->bf_paddr,208U);
  
#line 445 
  if (buf->bf_addr == (void *)0) {
    
#line 446 
    if ((common->debug_mask & 1024) != 0) 
#line 446 
                                          ath_printk("\001",(struct ath_common const *)common,"MCI buffer alloc failed\n"); else ;
    
#line 447 
    __retres = -12;
    
#line 447 
    goto return_label;
  }
  else ;
  
#line 450 
  memset(buf->bf_addr,254,512UL);
  
#line 453 
  mci->sched_buf.bf_len = 256U;
  
#line 455 
  mci->gpm_buf.bf_len = 256U;
  
#line 456 
  mci->gpm_buf.bf_addr = mci->sched_buf.bf_addr + mci->sched_buf.bf_len;
  
#line 457 
  mci->gpm_buf.bf_paddr = mci->sched_buf.bf_paddr + (unsigned long long)mci->sched_buf.bf_len;
  
#line 459 
  ret = ar9003_mci_setup(sc->sc_ah,(unsigned int)mci->gpm_buf.bf_paddr,mci->gpm_buf.bf_addr,(unsigned short)((int)((unsigned short)(mci->gpm_buf.bf_len >> 4))),(unsigned int)mci->sched_buf.bf_paddr);
  
#line 462 
  if (ret != 0) {
    
#line 463 
    ath_printk("\001",(struct ath_common const *)common,"Failed to initialize MCI\n");
    
#line 464 
    __retres = ret;
    
#line 464 
    goto return_label;
  }
  else ;
  {
    struct lock_class_key __key;
    
#line 467 
    __init_work(& sc->mci_work,0);
    
#line 467 
    atomic_long_t __constr_expr_37 = {.counter = WORK_STRUCT_NO_POOL_2};
    
#line 467 
    sc->mci_work.data = __constr_expr_37;
    
#line 467 
    lockdep_init_map(& sc->mci_work.lockdep_map,"(&sc->mci_work)",& __key,0);
    
#line 467 
    INIT_LIST_HEAD(& sc->mci_work.entry);
    
#line 467 
    sc->mci_work.func = & ath9k_mci_work;
  }
  
#line 468 
  if ((common->debug_mask & 32768) != 0) 
#line 468 
                                         ath_printk("\001",(struct ath_common const *)common,"MCI Initialized\n"); else ;
  
#line 470 
  __retres = 0;
  return_label: 
#line 470 
                return __retres;
}


#line 473  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mci.c"
void ath_mci_cleanup(struct ath_softc *sc)
{
  
#line 475 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 476 
  struct ath_hw *ah = sc->sc_ah;
  
#line 478 
  ar9003_mci_cleanup(ah);
  
#line 480 
  if ((common->debug_mask & 32768) != 0) 
#line 480 
                                         ath_printk("\001",(struct ath_common const *)common,"MCI De-Initialized\n"); else ;
  
#line 481 
  return;
}


#line 483  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mci.c"
void ath_mci_intr(struct ath_softc *sc)
{
  u32 mci_int;
  u32 mci_int_rxmsg;
  u32 offset;
  u32 subtype;
  u32 opcode;
  u32 *pgpm;
  u32 tmp_0;
  
#line 485 
  struct ath_mci_coex *mci = & sc->mci_coex;
  
#line 486 
  struct ath_hw *ah = sc->sc_ah;
  
#line 487 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 488 
  struct ath9k_hw_mci *mci_hw = & ah->btcoex_hw.mci;
  
#line 492 
  u32 more_data = 1U;
  
#line 493 
  bool skip_gpm = (_Bool)0;
  
#line 495 
  ar9003_mci_get_interrupt(sc->sc_ah,& mci_int,& mci_int_rxmsg);
  
#line 497 
  tmp_0 = ar9003_mci_state(ah,0U);
  
#line 497 
  if (tmp_0 == 0U) {
    
#line 498 
    ar9003_mci_state(ah,1U);
    
#line 499 
    goto return_label;
  }
  else ;
  
#line 502 
  if ((mci_int_rxmsg & 4096U) != 0U) {
    
#line 503 
    u32 payload[4U] = {4294967295U, 4294967295U, 4294967295U, 4294967040U};
    
#line 511 
    ar9003_mci_send_message(ah,(unsigned char)255,0U,(u32 *)(& payload),(unsigned char)16,(_Bool)1,(_Bool)0);
    
#line 513 
    ar9003_mci_send_message(ah,(unsigned char)112,0U,(u32 *)0U,(unsigned char)0,(_Bool)1,(_Bool)0);
    
#line 516 
    mci_int_rxmsg &= 4294963199U;
    
#line 517 
    ar9003_mci_state(ah,13U);
    
#line 522 
    ar9003_mci_state(ah,7U);
  }
  else ;
  
#line 525 
  if ((mci_int_rxmsg & 2048U) != 0U) {
    
#line 526 
    mci_int_rxmsg &= 4294965247U;
    
#line 528 
    if ((unsigned int)mci_hw->bt_state == 0U) {
      u32 tmp_1;
      
#line 528 
      tmp_1 = ar9003_mci_state(ah,11U);
      
#line 528 
      if (tmp_1 != 0U) 
#line 531 
                       ar9003_mci_state(ah,7U); else ;
    }
    else ;
  }
  else ;
  
#line 534 
  if ((mci_int_rxmsg & 1024U) != 0U) {
    
#line 535 
    mci_int_rxmsg &= 4294966271U;
    
#line 537 
    if ((unsigned int)mci_hw->bt_state == 1U) {
      u32 tmp_2;
      
#line 537 
      tmp_2 = ar9003_mci_state(ah,11U);
      
#line 537 
      if (tmp_2 != 1U) 
#line 540 
                       mci_hw->bt_state = (unsigned char)0U; else ;
    }
    else ;
  }
  else ;
  
#line 543 
  if ((mci_int & 8U) != 0U || mci_int < (u32)0) {
    
#line 545 
    ar9003_mci_state(ah,21U);
    
#line 546 
    skip_gpm = (_Bool)1;
  }
  else ;
  
#line 549 
  if ((mci_int_rxmsg & 32U) != 0U) {
    
#line 550 
    mci_int_rxmsg &= 4294967263U;
    
#line 551 
    offset = ar9003_mci_state(ah,10U);
  }
  else ;
  
#line 554 
  if ((mci_int_rxmsg & 256U) != 0U) {
    int tmp_3;
    
#line 555 
    mci_int_rxmsg &= 4294967039U;
    
#line 557 
    goto ldv_53537;
    ldv_53536: 
#line 558 
    ;
    
#line 558 
    tmp_3 = constant_test_bit(4L,(unsigned long const volatile *)(& common->op_flags));
    
#line 558 
    if (tmp_3 != 0) 
#line 559 
                    goto return_label; else ;
    
#line 561 
    pgpm = (u32 *)mci->gpm_buf.bf_addr;
    
#line 562 
    offset = ar9003_mci_get_next_gpm_offset(ah,& more_data);
    
#line 564 
    if (offset == 4294967295U) 
#line 565 
                               goto ldv_53531; else ;
    
#line 567 
    pgpm += offset >> 2;
    
#line 573 
    subtype = (unsigned int)*((u8 *)pgpm + 4U);
    
#line 574 
    opcode = (unsigned int)*((u8 *)pgpm + 5U);
    
#line 576 
    if ((int)skip_gpm != 0) 
#line 577 
                            goto recycle; else ;
    
#line 579 
    if (subtype <= 5U) 
#line 580 
                       ath_mci_cal_msg(sc,(unsigned char)((int)((unsigned char)subtype)),(u8 *)pgpm);
    else {
      
#line 582 
      switch (subtype) {
        case (u32)12: 
#line 583 
        ;
        
#line 584 
        ath_mci_msg(sc,(unsigned char)((int)((unsigned char)opcode)),(u8 *)pgpm);
        
#line 585 
        goto ldv_53534;
        default: 
#line 586 
        ;
        
#line 587 
        goto ldv_53534;
      }
      ldv_53534: 
#line 589 
      ;
    }
    recycle: 
#line 590 
    ;
    
#line 591 
    *(pgpm + 1U) = 4278124286U;
    ldv_53537: 
#line 592 
    ;
    
#line 557 
    if (more_data == 1U) 
#line 559 
                         goto ldv_53536; else 
#line 562 
                                              goto ldv_53531;
    ldv_53531: 
#line 563 
    ;
  }
  else ;
  
#line 595 
  if ((mci_int_rxmsg & 574U) != 0U) {
    
#line 596 
    if ((mci_int_rxmsg & 2U) != 0U) 
#line 597 
                                    mci_int_rxmsg &= 4294967293U; else ;
    
#line 599 
    if ((mci_int_rxmsg & 512U) != 0U) 
#line 600 
                                      mci_int_rxmsg &= 4294966783U; else ;
    
#line 602 
    if ((mci_int_rxmsg & 8U) != 0U) {
      
#line 603 
      int value_dbm = (int)mci_hw->cont_status & 255;
      
#line 606 
      mci_int_rxmsg &= 4294967287U;
      
#line 608 
      if ((common->debug_mask & 32768) != 0) {
        char *tmp_4;
        
#line 608 
        ;
        
#line 608 
        ;
        
#line 608 
        if ((mci_hw->cont_status & 65536U) != 0U) 
#line 608 
                                                  tmp_4 = (char *)"tx"; else 
                                                                    
#line 608 
                                                                    tmp_4 = (char *)"rx";
        
#line 608 
        ;
        
#line 608 
        ath_printk("\001",(struct ath_common const *)common,"MCI CONT_INFO: (%s) pri = %d pwr = %d dBm\n",tmp_4,(mci_hw->cont_status >> 8) & 255U,value_dbm);
      }
      else ;
    }
    else ;
    
#line 616 
    if ((mci_int_rxmsg & 4U) != 0U) 
#line 617 
                                    mci_int_rxmsg &= 4294967291U; else ;
    
#line 619 
    if ((mci_int_rxmsg & 16U) != 0U) 
#line 620 
                                     mci_int_rxmsg &= 4294967279U; else ;
  }
  else ;
  
#line 623 
  if ((mci_int & 8U) != 0U || mci_int < (u32)0) {
    
#line 625 
    mci_int &= 2147483639U;
    
#line 627 
    ath_mci_msg(sc,(unsigned char)8,(u8 *)0U);
  }
  else ;
  return_label: 
#line 629 
                return;
}


#line 631  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mci.c"
void ath_mci_enable(struct ath_softc *sc)
{
  
#line 633 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 635 
  if (! common->btcoex_enabled) 
#line 636 
                                goto return_label; else ;
  
#line 638 
  if (((sc->sc_ah)->caps.hw_caps & 32768U) != 0U) 
#line 639 
                                                  (sc->sc_ah)->imask = (enum ath9k_int)((unsigned int)(sc->sc_ah)->imask | 512U); else ;
  return_label: 
#line 640 
                return;
}


#line 642  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mci.c"
void ath9k_mci_update_wlan_channels(struct ath_softc *sc, bool allow_all)
{
  int i;
  s16 chan_start;
  s16 chan_end;
  u16 wlan_chan;
  struct ath_common *tmp_0;
  
#line 644 
  struct ath_hw *ah = sc->sc_ah;
  
#line 645 
  struct ath9k_hw_mci *mci = & ah->btcoex_hw.mci;
  
#line 646 
  struct ath9k_channel *chan = ah->curchan;
  
#line 647 
  u32 channelmap[4U] = {0U, 4294901760U, 4294967295U, 2147483647U};
  
#line 652 
  if (chan == (struct ath9k_channel *)0 || ((unsigned long)chan->channelFlags & 1UL) != 0UL) 
    
#line 653 
    goto return_label; else ;
  
#line 655 
  if ((int)allow_all != 0) 
#line 656 
                           goto send_wlan_chan; else ;
  
#line 658 
  wlan_chan = (unsigned short)((unsigned int)chan->channel + 63134U);
  
#line 660 
  chan_start = (short)((unsigned int)wlan_chan + 65526U);
  
#line 661 
  chan_end = (short)((unsigned int)wlan_chan + 10U);
  
#line 663 
  if (((unsigned long)chan->channelFlags & 16UL) != 0UL) 
#line 664 
                                                         chan_end = (short)((unsigned int)chan_end + 20U);
  else 
    
#line 665 
    if (((unsigned long)chan->channelFlags & 32UL) != 0UL) 
#line 666 
                                                           chan_start = (short)((unsigned int)chan_start + 65516U); else ;
  
#line 669 
  chan_start = (short)((unsigned int)chan_start + 65529U);
  
#line 670 
  chan_end = (short)((unsigned int)chan_end + 7U);
  
#line 672 
  if ((int)chan_start <= 0) 
#line 673 
                            chan_start = (short)0; else ;
  
#line 674 
  if ((int)chan_end > 78) 
#line 675 
                          chan_end = (short)78; else ;
  
#line 677 
  tmp_0 = ath9k_hw_common(ah);
  
#line 677 
  ;
  
#line 677 
  if ((tmp_0->debug_mask & 32768) != 0) {
    struct ath_common *tmp;
    
#line 677 
    ;
    
#line 677 
    ;
    
#line 677 
    ;
    
#line 677 
    tmp = ath9k_hw_common(ah);
    
#line 677 
    ath_printk("\001",(struct ath_common const *)tmp,"WLAN current channel %d mask BT channel %d - %d\n",(int)wlan_chan,(int)chan_start,(int)chan_end);
  }
  else ;
  
#line 681 
  i = (int)chan_start;
  
#line 681 
  goto ldv_53557;
  ldv_53556: 
#line 682 
  ;
  
#line 682 
  if (i <= 78) 
#line 682 
               *((u8 *)(& channelmap) + ((unsigned int)(i / 8) + 6U)) = (unsigned char)((int)*((u8 *)(& channelmap) + ((unsigned int)(i / 8) + 6U)) & ~ (1 << (i & 7))); else ;
  
#line 681 
  i += 1;
  ldv_53557: 
#line 682 
  ;
  
#line 681 
  if ((int)chan_end > i) 
#line 683 
                         goto ldv_53556; else 
#line 686 
                                              goto ldv_53558;
  ldv_53558: 
#line 687 
  ;
  send_wlan_chan: 
#line 684 
  ;
  
#line 686 
  i = 0;
  
#line 686 
  goto ldv_53560;
  ldv_53559: 
#line 687 
  ;
  
#line 687 
  mci->wlan_channels[i] = channelmap[i];
  
#line 686 
  i += 1;
  ldv_53560: 
#line 687 
  ;
  
#line 686 
  if (i <= 3) 
#line 688 
              goto ldv_53559; else 
#line 691 
                                   goto ldv_53561;
  ldv_53561: 
#line 692 
  ;
  
#line 688 
  ar9003_mci_send_wlan_channels(ah);
  
#line 689 
  ar9003_mci_state(ah,17U);
  return_label: 
#line 690 
                return;
}


#line 692  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mci.c"
void ath9k_mci_set_txpower(struct ath_softc *sc, bool setchannel, bool concur_tx)
{
  
#line 695 
  struct ath_hw *ah = sc->sc_ah;
  
#line 696 
  struct ath9k_hw_mci *mci_hw = & (sc->sc_ah)->btcoex_hw.mci;
  
#line 697 
  bool old_concur_tx = mci_hw->concur_tx;
  
#line 699 
  if ((mci_hw->config & 3U) == 0U) {
    
#line 700 
    mci_hw->concur_tx = (_Bool)0;
    
#line 701 
    goto return_label;
  }
  else ;
  
#line 704 
  if (((unsigned long)(ah->curchan)->channelFlags & 1UL) != 0UL) 
#line 705 
                                                                 goto return_label; else ;
  
#line 707 
  if ((int)setchannel != 0) {
    
#line 708 
    struct ath9k_hw_cal_data *caldata = & (sc->cur_chan)->caldata;
    
#line 709 
    if ((((unsigned long)(ah->curchan)->channelFlags & 16UL) != 0UL && (int)(ah->curchan)->channel > (int)caldata->channel) && (int)(ah->curchan)->channel <= (int)caldata->channel + 20) 
      
#line 712 
      goto return_label; else ;
    
#line 713 
    if ((((unsigned long)(ah->curchan)->channelFlags & 32UL) != 0UL && (int)(ah->curchan)->channel < (int)caldata->channel) && (int)(ah->curchan)->channel >= (int)caldata->channel + -20) 
      
#line 716 
      goto return_label; else ;
    
#line 717 
    mci_hw->concur_tx = (_Bool)0;
  }
  else 
#line 719 
       mci_hw->concur_tx = concur_tx;
  
#line 721 
  if ((int)mci_hw->concur_tx != (int)old_concur_tx) 
#line 722 
                                                    ath9k_hw_set_txpowerlimit(ah,(unsigned int)(sc->cur_chan)->txpower,(_Bool)0); else ;
  return_label: 
#line 723 
                return;
}


#line 725  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mci.c"
static void ath9k_mci_stomp_audio(struct ath_softc *sc)
{
  
#line 727 
  struct ath_hw *ah = sc->sc_ah;
  
#line 728 
  struct ath_btcoex *btcoex = & sc->btcoex;
  
#line 729 
  struct ath_mci_profile *mci = & btcoex->mci;
  
#line 731 
  if ((unsigned int)mci->num_sco == 0U && (unsigned int)mci->num_a2dp == 0U) 
    
#line 732 
    goto return_label; else ;
  
#line 734 
  if (ah->stats.avgbrssi > 25U) {
    
#line 735 
    btcoex->stomp_audio = (unsigned char)0U;
    
#line 736 
    goto return_label;
  }
  else ;
  
#line 739 
  btcoex->stomp_audio = (u8)((int)btcoex->stomp_audio + 1);
  return_label: 
#line 740 
                return;
}


#line 741  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mci.c"
void ath9k_mci_update_rssi(struct ath_softc *sc)
{
  
#line 743 
  struct ath_hw *ah = sc->sc_ah;
  
#line 744 
  struct ath_btcoex *btcoex = & sc->btcoex;
  
#line 745 
  struct ath9k_hw_mci *mci_hw = & (sc->sc_ah)->btcoex_hw.mci;
  
#line 747 
  ath9k_mci_stomp_audio(sc);
  
#line 749 
  if ((mci_hw->config & 3U) == 0U) 
#line 750 
                                   goto return_label; else ;
  
#line 752 
  if (ah->stats.avgbrssi > 39U) {
    
#line 753 
    if (btcoex->rssi_count < 0) 
#line 754 
                                btcoex->rssi_count = 0; else ;
    
#line 755 
    btcoex->rssi_count += 1;
    
#line 755 
    if (btcoex->rssi_count > 4) {
      
#line 756 
      btcoex->rssi_count = 0;
      
#line 757 
      ath9k_mci_set_txpower(sc,(_Bool)0,(_Bool)1);
    }
    else ;
  }
  else {
    
#line 760 
    if (btcoex->rssi_count > 0) 
#line 761 
                                btcoex->rssi_count = 0; else ;
    
#line 762 
    btcoex->rssi_count -= 1;
    
#line 762 
    if (btcoex->rssi_count < -4) {
      
#line 763 
      btcoex->rssi_count = 0;
      
#line 764 
      ath9k_mci_set_txpower(sc,(_Bool)0,(_Bool)0);
    }
    else ;
  }
  return_label: 
#line 767 
                return;
}


#line 501  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_mci.c.aux"
static void *kzalloc_2(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 504 
  tmp = ldv_kzalloc(size,flags);
  
#line 504 
  return tmp;
}


#line 178  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
void __might_sleep(char const *, int, int);


#line 98  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/atomic.h"
static void atomic_inc_0(atomic_t *v);


#line 114 
static void atomic_dec_0(atomic_t *v);


#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_0(spinlock_t *lock)
{
  
#line 312 
  _raw_spin_lock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 313 
  return;
}


#line 358 
static void ldv_spin_lock_76_0(spinlock_t *lock);


#line 362 
static void ldv_spin_lock_80(spinlock_t *lock);


#line 366 
static void ldv_spin_lock_85(spinlock_t *lock);


#line 370 
static void ldv_spin_lock_94(spinlock_t *lock);


#line 374 
static void ldv_spin_lock_95(spinlock_t *lock);


#line 378 
static void ldv_spin_lock_101(spinlock_t *lock);


#line 379  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_bh_5(spinlock_t *lock)
{
  
#line 381 
  _raw_spin_lock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 382 
  return;
}


#line 407 
static void ldv_spin_lock_bh_72_3(spinlock_t *lock);


#line 411 
static void ldv_spin_lock_bh_90(spinlock_t *lock);


#line 415 
static void ldv_spin_lock_bh_91_0(spinlock_t *lock);


#line 419 
static void ldv_spin_lock_bh_105(spinlock_t *lock);


#line 423 
static void ldv_spin_lock_bh_112(spinlock_t *lock);


#line 427 
static void ldv_spin_lock_bh_114(spinlock_t *lock);


#line 431 
static void ldv_spin_lock_bh_131(spinlock_t *lock);


#line 435 
static void ldv_spin_lock_bh_147(spinlock_t *lock);


#line 439 
static void ldv_spin_lock_bh_154(spinlock_t *lock);


#line 443 
static void ldv_spin_lock_bh_156(spinlock_t *lock);


#line 447 
static void ldv_spin_lock_bh_182(spinlock_t *lock);


#line 451 
static void ldv_spin_lock_bh_184(spinlock_t *lock);


#line 455 
static void ldv_spin_lock_bh_187(spinlock_t *lock);


#line 459 
static void ldv_spin_lock_bh_190(spinlock_t *lock);


#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_0(spinlock_t *lock)
{
  
#line 365 
  _raw_spin_unlock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 366 
  return;
}


#line 407 
static void ldv_spin_unlock_77_0(spinlock_t *lock);


#line 411 
static void ldv_spin_unlock_81(spinlock_t *lock);


#line 415 
static void ldv_spin_unlock_86(spinlock_t *lock);


#line 419 
static void ldv_spin_unlock_96(spinlock_t *lock);


#line 423 
static void ldv_spin_unlock_99(spinlock_t *lock);


#line 427 
static void ldv_spin_unlock_102(spinlock_t *lock);


#line 428  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_bh_5(spinlock_t *lock)
{
  
#line 430 
  _raw_spin_unlock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 431 
  return;
}


#line 456 
static void ldv_spin_unlock_bh_73_3(spinlock_t *lock);


#line 460 
static void ldv_spin_unlock_bh_92_0(spinlock_t *lock);


#line 464 
static void ldv_spin_unlock_bh_93(spinlock_t *lock);


#line 468 
static void ldv_spin_unlock_bh_106(spinlock_t *lock);


#line 472 
static void ldv_spin_unlock_bh_113(spinlock_t *lock);


#line 476 
static void ldv_spin_unlock_bh_115(spinlock_t *lock);


#line 480 
static void ldv_spin_unlock_bh_132(spinlock_t *lock);


#line 484 
static void ldv_spin_unlock_bh_148(spinlock_t *lock);


#line 488 
static void ldv_spin_unlock_bh_149(spinlock_t *lock);


#line 492 
static void ldv_spin_unlock_bh_155(spinlock_t *lock);


#line 496 
static void ldv_spin_unlock_bh_157(spinlock_t *lock);


#line 500 
static void ldv_spin_unlock_bh_183(spinlock_t *lock);


#line 504 
static void ldv_spin_unlock_bh_185(spinlock_t *lock);


#line 508 
static void ldv_spin_unlock_bh_188(spinlock_t *lock);


#line 512 
static void ldv_spin_unlock_bh_191(spinlock_t *lock);


#line 526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_irqrestore_6(spinlock_t *lock, unsigned long flags)
{
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
  }
  
#line 528 
  _raw_spin_unlock_irqrestore(& lock->__anonCompField_spinlock_18.rlock,flags);
  
#line 529 
  return;
}


#line 558 
static void ldv_spin_unlock_irqrestore_75_2(spinlock_t *lock, unsigned long flags);


#line 562 
static void ldv_spin_unlock_irqrestore_82(spinlock_t *lock, unsigned long flags);


#line 566 
static void ldv_spin_unlock_irqrestore_87(spinlock_t *lock, unsigned long flags);


#line 570 
static void ldv_spin_unlock_irqrestore_89(spinlock_t *lock, unsigned long flags);


#line 574 
static void ldv_spin_unlock_irqrestore_98(spinlock_t *lock, unsigned long flags);


#line 578 
static void ldv_spin_unlock_irqrestore_109_0(spinlock_t *lock, unsigned long flags);


#line 582 
static void ldv_spin_unlock_irqrestore_118(spinlock_t *lock, unsigned long flags);


#line 586 
static void ldv_spin_unlock_irqrestore_129(spinlock_t *lock, unsigned long flags);


#line 37  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_lock_104_0(struct mutex *ldv_func_arg1);


#line 41 
static void ldv_mutex_lock_110(struct mutex *ldv_func_arg1);


#line 45 
static void ldv_mutex_lock_119(struct mutex *ldv_func_arg1);


#line 49 
static void ldv_mutex_lock_122(struct mutex *ldv_func_arg1);


#line 53 
static void ldv_mutex_lock_125(struct mutex *ldv_func_arg1);


#line 57 
static void ldv_mutex_lock_127(struct mutex *ldv_func_arg1);


#line 61 
static void ldv_mutex_lock_133(struct mutex *ldv_func_arg1);


#line 65 
static void ldv_mutex_lock_135(struct mutex *ldv_func_arg1);


#line 69 
static void ldv_mutex_lock_137(struct mutex *ldv_func_arg1);


#line 73 
static void ldv_mutex_lock_139(struct mutex *ldv_func_arg1);


#line 77 
static void ldv_mutex_lock_141(struct mutex *ldv_func_arg1);


#line 81 
static void ldv_mutex_lock_143(struct mutex *ldv_func_arg1);


#line 85 
static void ldv_mutex_lock_145(struct mutex *ldv_func_arg1);


#line 89 
static void ldv_mutex_lock_150(struct mutex *ldv_func_arg1);


#line 93 
static void ldv_mutex_lock_152(struct mutex *ldv_func_arg1);


#line 97 
static void ldv_mutex_lock_160(struct mutex *ldv_func_arg1);


#line 101 
static void ldv_mutex_lock_162(struct mutex *ldv_func_arg1);


#line 105 
static void ldv_mutex_lock_165(struct mutex *ldv_func_arg1);


#line 109 
static void ldv_mutex_lock_167(struct mutex *ldv_func_arg1);


#line 113 
static void ldv_mutex_lock_170(struct mutex *ldv_func_arg1);


#line 117 
static void ldv_mutex_lock_173(struct mutex *ldv_func_arg1);


#line 121 
static void ldv_mutex_lock_175(struct mutex *ldv_func_arg1);


#line 125 
static void ldv_mutex_lock_177(struct mutex *ldv_func_arg1);


#line 129 
static void ldv_mutex_lock_179(struct mutex *ldv_func_arg1);


#line 133 
static void ldv_mutex_lock_181(struct mutex *ldv_func_arg1);


#line 137 
static void ldv_mutex_lock_189(struct mutex *ldv_func_arg1);


#line 141 
static void ldv_mutex_lock_193(struct mutex *ldv_func_arg1);


#line 178 
static void ldv___ldv_spin_lock_74_2(spinlock_t *ldv_func_arg1);


#line 182 
static void ldv___ldv_spin_lock_78(spinlock_t *ldv_func_arg1);


#line 186 
static void ldv___ldv_spin_lock_83(spinlock_t *ldv_func_arg1);


#line 190 
static void ldv___ldv_spin_lock_88(spinlock_t *ldv_func_arg1);


#line 194 
static void ldv___ldv_spin_lock_97(spinlock_t *ldv_func_arg1);


#line 198 
static void ldv___ldv_spin_lock_108_0(spinlock_t *ldv_func_arg1);


#line 202 
static void ldv___ldv_spin_lock_117(spinlock_t *ldv_func_arg1);


#line 206 
static void ldv___ldv_spin_lock_128(spinlock_t *ldv_func_arg1);


#line 149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
void __wake_up(wait_queue_head_t *, unsigned int, int, void *);


#line 926 
long prepare_to_wait_event(wait_queue_head_t *, wait_queue_t *, int);


#line 927 
void finish_wait(wait_queue_head_t *, wait_queue_t *);


#line 193  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
static void ldv_mutex_unlock_107(struct mutex *ldv_func_arg1);


#line 197 
static void ldv_mutex_unlock_111(struct mutex *ldv_func_arg1);


#line 201 
static void ldv_mutex_unlock_116(struct mutex *ldv_func_arg1);


#line 205 
static void ldv_mutex_unlock_120(struct mutex *ldv_func_arg1);


#line 209 
static void ldv_mutex_unlock_121(struct mutex *ldv_func_arg1);


#line 213 
static void ldv_mutex_unlock_123(struct mutex *ldv_func_arg1);


#line 217 
static void ldv_mutex_unlock_124(struct mutex *ldv_func_arg1);


#line 221 
static void ldv_mutex_unlock_126(struct mutex *ldv_func_arg1);


#line 225 
static void ldv_mutex_unlock_130(struct mutex *ldv_func_arg1);


#line 229 
static void ldv_mutex_unlock_134(struct mutex *ldv_func_arg1);


#line 233 
static void ldv_mutex_unlock_136(struct mutex *ldv_func_arg1);


#line 237 
static void ldv_mutex_unlock_138(struct mutex *ldv_func_arg1);


#line 241 
static void ldv_mutex_unlock_140(struct mutex *ldv_func_arg1);


#line 245 
static void ldv_mutex_unlock_142(struct mutex *ldv_func_arg1);


#line 249 
static void ldv_mutex_unlock_144(struct mutex *ldv_func_arg1);


#line 253 
static void ldv_mutex_unlock_146(struct mutex *ldv_func_arg1);


#line 257 
static void ldv_mutex_unlock_151(struct mutex *ldv_func_arg1);


#line 261 
static void ldv_mutex_unlock_153(struct mutex *ldv_func_arg1);


#line 265 
static void ldv_mutex_unlock_161(struct mutex *ldv_func_arg1);


#line 269 
static void ldv_mutex_unlock_164(struct mutex *ldv_func_arg1);


#line 273 
static void ldv_mutex_unlock_166(struct mutex *ldv_func_arg1);


#line 277 
static void ldv_mutex_unlock_169(struct mutex *ldv_func_arg1);


#line 281 
static void ldv_mutex_unlock_171(struct mutex *ldv_func_arg1);


#line 285 
static void ldv_mutex_unlock_172(struct mutex *ldv_func_arg1);


#line 289 
static void ldv_mutex_unlock_174(struct mutex *ldv_func_arg1);


#line 293 
static void ldv_mutex_unlock_176(struct mutex *ldv_func_arg1);


#line 297 
static void ldv_mutex_unlock_178(struct mutex *ldv_func_arg1);


#line 301 
static void ldv_mutex_unlock_180(struct mutex *ldv_func_arg1);


#line 305 
static void ldv_mutex_unlock_186(struct mutex *ldv_func_arg1);


#line 309 
static void ldv_mutex_unlock_192(struct mutex *ldv_func_arg1);


#line 313 
static void ldv_mutex_unlock_194(struct mutex *ldv_func_arg1);


#line 173  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
static int ldv_mod_timer_84(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2);


#line 232 
static int ldv_del_timer_sync_79(struct timer_list *ldv_func_arg1);


#line 236 
static int ldv_del_timer_sync_158(struct timer_list *ldv_func_arg1);


#line 240 
static int ldv_del_timer_sync_159(struct timer_list *ldv_func_arg1);


#line 244 
static int ldv_del_timer_sync_163(struct timer_list *ldv_func_arg1);


#line 248 
static int ldv_del_timer_sync_168(struct timer_list *ldv_func_arg1);


#line 448  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
bool cancel_delayed_work_sync(struct delayed_work *);


#line 421  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
long schedule_timeout(long);


#line 192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
void disable_irq(unsigned int);


#line 194 
void enable_irq(unsigned int);


#line 519  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
__inline static void tasklet_unlock_wait_0(struct tasklet_struct *t)
{
  int tmp;
  
#line 521 
  goto ldv_38070;
  ldv_38069: 
#line 522 
  ;
  
#line 523 
  ldv_inline_asm();
  ldv_38070: 
#line 524 
  ;
  
#line 521 
  tmp = constant_test_bit(1L,(unsigned long const volatile *)(& t->state));
  
#line 521 
  if (tmp != 0) 
#line 523 
                goto ldv_38069; else 
#line 526 
                                     goto ldv_38071;
  ldv_38071: 
#line 527 
  ;
  
#line 528 
  return;
}


#line 540 
static void ldv_tasklet_schedule_100(struct tasklet_struct *t);


#line 544 
static void ldv_tasklet_schedule_103(struct tasklet_struct *t);


#line 568  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
__inline static void tasklet_disable_nosync_0(struct tasklet_struct *t)
{
  
#line 570 
  atomic_inc_0(& t->count);
  
#line 571 
  ldv_inline_asm();
  
#line 572 
  return;
}


#line 574  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
__inline static void tasklet_disable_0(struct tasklet_struct *t)
{
  
#line 576 
  tasklet_disable_nosync_0(t);
  
#line 577 
  tasklet_unlock_wait_0(t);
  
#line 578 
  ldv_inline_asm();
  
#line 579 
  return;
}


#line 581  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
__inline static void tasklet_enable_0(struct tasklet_struct *t)
{
  
#line 583 
  ldv_inline_asm();
  
#line 584 
  atomic_dec_0(& t->count);
  
#line 585 
  return;
}


#line 233  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static void eth_broadcast_addr(u8 *addr)
{
  
#line 235 
  memset((void *)addr,255,6UL);
  
#line 236 
  return;
}


#line 244  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static void eth_zero_addr(u8 *addr)
{
  
#line 246 
  memset((void *)addr,0,6UL);
  
#line 247 
  return;
}


#line 271  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static void ether_addr_copy(u8 *dst, u8 const *src)
{
  
#line 274 
  *((u32 *)dst) = *((u32 const *)src);
  
#line 275 
  *((u16 *)(dst + 4U)) = *((u16 const *)(src + 4U));
  
#line 276 
  return;
}


#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
__inline static int ieee80211_has_pm(__le16 fc)
{
  int __retres;
  
#line 301 
  __retres = ((int)fc & 4096) != 0;
  
#line 301 
  return __retres;
}


#line 593  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
__inline static int ieee80211_is_nullfunc(__le16 fc)
{
  int __retres;
  
#line 595 
  __retres = ((int)fc & 252) == 72;
  
#line 595 
  return __retres;
}


#line 4707  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
void ieee80211_start_tx_ba_cb_irqsafe(struct ieee80211_vif *, u8 const *, u16);


#line 4733 
void ieee80211_stop_tx_ba_cb_irqsafe(struct ieee80211_vif *, u8 const *, u16);


#line 202  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath.h"
void ath_key_delete(struct ath_common *, struct ieee80211_key_conf *);


#line 203 
int ath_key_config(struct ath_common *, struct ieee80211_vif *, struct ieee80211_sta *, struct ieee80211_key_conf *);


#line 718  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/mac.h"
bool ath9k_hw_updatetxtriglevel(struct ath_hw *, bool);


#line 733 
bool ath9k_hw_setrxabort(struct ath_hw *, bool);


#line 739 
void ath9k_hw_set_tx_filter(struct ath_hw *, u8, bool);


#line 742 
bool ath9k_hw_intrpend(struct ath_hw *);


#line 746 
void ath9k_hw_kill_interrupts(struct ath_hw *);


#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/dynack.h"
void ath_dynack_reset(struct ath_hw *);


#line 84 
void ath_dynack_node_init(struct ath_hw *, struct ath_node *);


#line 85 
void ath_dynack_node_deinit(struct ath_hw *, struct ath_node *);


#line 1016  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw.h"
int ath9k_hw_reset(struct ath_hw *, struct ath9k_channel *, struct ath9k_hw_cal_data *, bool);


#line 1022 
void ath9k_hw_cfg_gpio_input(struct ath_hw *, u32);


#line 1046 
bool ath9k_hw_phy_disable(struct ath_hw *);


#line 1051 
void ath9k_hw_write_associd(struct ath_hw *);


#line 1054 
void ath9k_hw_settsf64(struct ath_hw *, u64);


#line 1057 
void ath9k_hw_set_tsfadjust(struct ath_hw *, bool);


#line 1083 
void ath_gen_timer_isr(struct ath_hw *);


#line 1104 
bool ar9003_hw_bb_watchdog_check(struct ath_hw *);


#line 1107 
void ar9003_hw_bb_watchdog_dbg_info(struct ath_hw *);


#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/hw-ops.h"
__inline static bool ath9k_hw_getisr(struct ath_hw *ah, enum ath9k_int *masked, u32 *sync_cause_p)
{
  bool tmp_0;
  struct ath_hw_ops *tmp;
  
#line 54 
  tmp = ath9k_hw_ops(ah);
  
#line 54 
  tmp_0 = (*(tmp->get_isr))(ah,masked,sync_cause_p);
  
#line 54 
  return tmp_0;
}


#line 440  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/ath9k.h"
__inline static struct ath_chanctx *ath_chanctx_get(struct ieee80211_chanctx_conf *ctx)
{
  struct ath_chanctx *__retres;
  
#line 442 
  struct ath_chanctx **ptr = (struct ath_chanctx **)(& ctx->drv_priv);
  
#line 443 
  __retres = *ptr;
  
#line 443 
  return __retres;
}


#line 646 
void ath9k_calculate_summary_state(struct ath_softc *sc, struct ath_chanctx *ctx);


#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
u8 ath9k_parse_mpdudensity(u8 mpdudensity)
{
  u8 __retres;
  
#line 35 
  switch ((int)mpdudensity) {
    case 0: 
#line 36 
    ;
    
#line 37 
    __retres = (unsigned char)0U;
    
#line 37 
    goto return_label;
    case 1: 
#line 38 
    ;
    case 2: 
#line 39 
    ;
    case 3: 
#line 40 
    ;
    
#line 43 
    __retres = (unsigned char)1U;
    
#line 43 
    goto return_label;
    case 4: 
#line 44 
    ;
    
#line 45 
    __retres = (unsigned char)2U;
    
#line 45 
    goto return_label;
    case 5: 
#line 46 
    ;
    
#line 47 
    __retres = (unsigned char)4U;
    
#line 47 
    goto return_label;
    case 6: 
#line 48 
    ;
    
#line 49 
    __retres = (unsigned char)8U;
    
#line 49 
    goto return_label;
    case 7: 
#line 50 
    ;
    
#line 51 
    __retres = (unsigned char)16U;
    
#line 51 
    goto return_label;
    default: 
#line 52 
    ;
    
#line 53 
    __retres = (unsigned char)0U;
    
#line 53 
    goto return_label;
  }
  return_label: 
#line 35 
                return __retres;
}


#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static bool ath9k_has_pending_frames(struct ath_softc *sc, struct ath_txq *txq, bool sw_pending)
{
  
#line 60 
  bool pending = (_Bool)0;
  
#line 62 
  ldv_spin_lock_bh_72_3(& txq->axq_lock);
  
#line 64 
  if (txq->axq_depth != 0U) {
    
#line 65 
    pending = (_Bool)1;
    
#line 66 
    goto out;
  }
  else ;
  
#line 69 
  if (! sw_pending) 
#line 70 
                    goto out; else ;
  
#line 72 
  if (txq->mac80211_qnum >= 0) {
    struct list_head *list;
    int tmp;
    
#line 75 
    list = & (sc->cur_chan)->acq[txq->mac80211_qnum];
    
#line 76 
    tmp = list_empty((struct list_head const *)list);
    
#line 76 
    if (tmp == 0) 
#line 77 
                  pending = (_Bool)1; else ;
  }
  else ;
  out: 
#line 79 
  ;
  
#line 80 
  ldv_spin_unlock_bh_73_3(& txq->axq_lock);
  
#line 81 
  return pending;
}


#line 84  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static bool ath9k_setpower(struct ath_softc *sc, enum ath9k_power_mode mode)
{
  unsigned long flags;
  bool ret;
  
#line 89 
  ldv___ldv_spin_lock_74_2(& sc->sc_pm_lock);
  
#line 90 
  ret = ath9k_hw_setpower(sc->sc_ah,mode);
  
#line 91 
  ldv_spin_unlock_irqrestore_75_2(& sc->sc_pm_lock,flags);
  
#line 93 
  return ret;
}


#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
void ath_ps_full_sleep(unsigned long data)
{
  bool reset;
  
#line 98 
  struct ath_softc *sc = (struct ath_softc *)data;
  
#line 99 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 102 
  ldv_spin_lock_76_0(& common->cc_lock);
  
#line 103 
  ath_hw_cycle_counters_update(common);
  
#line 104 
  ldv_spin_unlock_77_0(& common->cc_lock);
  
#line 106 
  ath9k_hw_setrxabort(sc->sc_ah,(_Bool)1);
  
#line 107 
  ath9k_hw_stopdmarecv(sc->sc_ah,& reset);
  
#line 109 
  ath9k_hw_setpower(sc->sc_ah,(enum ath9k_power_mode)ATH9K_PM_FULL_SLEEP);
  
#line 110 
  return;
}


#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
void ath9k_ps_wakeup(struct ath_softc *sc)
{
  unsigned long flags;
  enum ath9k_power_mode power_mode;
  
#line 114 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 118 
  ldv___ldv_spin_lock_78(& sc->sc_pm_lock);
  
#line 119 
  sc->ps_usecount += 1UL;
  
#line 119 
  if (sc->ps_usecount != 1UL) 
#line 120 
                              goto unlock; else ;
  
#line 122 
  ldv_del_timer_sync_79(& sc->sleep_timer);
  
#line 123 
  power_mode = (sc->sc_ah)->power_mode;
  
#line 124 
  ath9k_hw_setpower(sc->sc_ah,(enum ath9k_power_mode)ATH9K_PM_AWAKE);
  
#line 131 
  if (power_mode != (unsigned int)ATH9K_PM_AWAKE) {
    
#line 132 
    ldv_spin_lock_80(& common->cc_lock);
    
#line 133 
    ath_hw_cycle_counters_update(common);
    
#line 134 
    memset((void *)(& common->cc_survey),0,16UL);
    
#line 135 
    memset((void *)(& common->cc_ani),0,16UL);
    
#line 136 
    ldv_spin_unlock_81(& common->cc_lock);
  }
  else ;
  unlock: 
#line 139 
  ;
  
#line 140 
  ldv_spin_unlock_irqrestore_82(& sc->sc_pm_lock,flags);
  
#line 141 
  return;
}


#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
void ath9k_ps_restore(struct ath_softc *sc)
{
  enum ath9k_power_mode mode;
  unsigned long flags;
  
#line 145 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 149 
  ldv___ldv_spin_lock_83(& sc->sc_pm_lock);
  
#line 150 
  sc->ps_usecount -= 1UL;
  
#line 150 
  if (sc->ps_usecount != 0UL) 
#line 151 
                              goto unlock; else ;
  
#line 153 
  if ((int)sc->ps_idle != 0) {
    
#line 154 
    ldv_mod_timer_84(& sc->sleep_timer,jiffies + 25UL);
    
#line 155 
    goto unlock;
  }
  else ;
  
#line 158 
  if ((int)sc->ps_enabled != 0 && ((unsigned long)sc->ps_flags & 47UL) == 0UL) {
    bool tmp_0;
    
#line 164 
    mode = ATH9K_PM_NETWORK_SLEEP;
    
#line 165 
    tmp_0 = ath9k_hw_btcoex_is_enabled(sc->sc_ah);
    
#line 165 
    if ((int)tmp_0 != 0) 
#line 166 
                         ath9k_btcoex_stop_gen_timer(sc); else ;
  }
  else 
#line 168 
       goto unlock;
  
#line 171 
  ldv_spin_lock_85(& common->cc_lock);
  
#line 172 
  ath_hw_cycle_counters_update(common);
  
#line 173 
  ldv_spin_unlock_86(& common->cc_lock);
  
#line 175 
  ath9k_hw_setpower(sc->sc_ah,mode);
  unlock: 
#line 177 
  ;
  
#line 178 
  ldv_spin_unlock_irqrestore_87(& sc->sc_pm_lock,flags);
  
#line 179 
  return;
}


#line 181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void __ath_cancel_work(struct ath_softc *sc)
{
  bool tmp;
  
#line 183 
  cancel_work_sync(& sc->paprd_work);
  
#line 184 
  cancel_delayed_work_sync(& sc->tx_complete_work);
  
#line 185 
  cancel_delayed_work_sync(& sc->hw_pll_work);
  
#line 188 
  tmp = ath9k_hw_mci_is_enabled(sc->sc_ah);
  
#line 188 
  if ((int)tmp != 0) 
#line 189 
                     cancel_work_sync(& sc->mci_work); else ;
  
#line 190 
  return;
}


#line 193  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
void ath_cancel_work(struct ath_softc *sc)
{
  
#line 195 
  __ath_cancel_work(sc);
  
#line 196 
  cancel_work_sync(& sc->hw_reset_work);
  
#line 197 
  return;
}


#line 199  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
void ath_restart_work(struct ath_softc *sc)
{
  
#line 201 
  ieee80211_queue_delayed_work(sc->hw,& sc->tx_complete_work,0UL);
  
#line 203 
  if ((sc->sc_ah)->hw_version.macVersion == 768U || (sc->sc_ah)->hw_version.macVersion == 512U) {
    unsigned long tmp;
    
#line 204 
    tmp = msecs_to_jiffies(100U);
    
#line 204 
    ;
    
#line 204 
    ;
    
#line 204 
    ieee80211_queue_delayed_work(sc->hw,& sc->hw_pll_work,tmp);
  }
  else ;
  
#line 207 
  ath_start_ani(sc);
  
#line 208 
  return;
}


#line 210  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static bool ath_prepare_reset(struct ath_softc *sc)
{
  
#line 212 
  struct ath_hw *ah = sc->sc_ah;
  
#line 213 
  bool ret = (_Bool)1;
  
#line 215 
  ieee80211_stop_queues(sc->hw);
  
#line 216 
  ath_stop_ani(sc);
  
#line 217 
  ath9k_hw_disable_interrupts(ah);
  
#line 219 
  if (ah->hw_version.macVersion > 447U) {
    bool tmp;
    bool tmp_0;
    
#line 220 
    tmp = ath_stoprecv(sc);
    
#line 220 
    ret = (_Bool)(((int)ret & (int)tmp) != 0);
    
#line 221 
    tmp_0 = ath_drain_all_txq(sc);
    
#line 221 
    ret = (_Bool)(((int)ret & (int)tmp_0) != 0);
  }
  else {
    bool tmp_1;
    bool tmp_2;
    
#line 223 
    tmp_1 = ath_drain_all_txq(sc);
    
#line 223 
    ret = (_Bool)(((int)ret & (int)tmp_1) != 0);
    
#line 224 
    tmp_2 = ath_stoprecv(sc);
    
#line 224 
    ret = (_Bool)(((int)ret & (int)tmp_2) != 0);
  }
  
#line 227 
  return ret;
}


#line 230  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static bool ath_complete_reset(struct ath_softc *sc, bool start)
{
  bool __retres;
  unsigned long flags;
  
#line 232 
  struct ath_hw *ah = sc->sc_ah;
  
#line 233 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 236 
  ath9k_calculate_summary_state(sc,sc->cur_chan);
  
#line 237 
  ath_startrecv(sc);
  
#line 238 
  ath9k_cmn_update_txpow(ah,(unsigned short)((int)(sc->cur_chan)->cur_txpower),(unsigned short)((int)(sc->cur_chan)->txpower),& (sc->cur_chan)->cur_txpower);
  
#line 241 
  set_bit(4L,(unsigned long volatile *)(& common->op_flags));
  
#line 243 
  if (! (sc->cur_chan)->offchannel && (int)start != 0) {
    int tmp_0;
    
#line 245 
    if ((sc->cur_chan)->tsf_val != 0ULL) {
      u32 offset;
      
#line 248 
      offset = ath9k_hw_get_tsf_offset(& (sc->cur_chan)->tsf_ts,(struct timespec *)0);
      
#line 250 
      ath9k_hw_settsf64(ah,(sc->cur_chan)->tsf_val + (unsigned long long)offset);
    }
    else ;
    
#line 254 
    tmp_0 = constant_test_bit(1L,(unsigned long const volatile *)(& common->op_flags));
    
#line 254 
    if (tmp_0 == 0) 
#line 255 
                    goto work; else ;
    
#line 257 
    if (ah->opmode == (unsigned int)NL80211_IFTYPE_STATION) {
      int tmp_1;
      
#line 257 
      tmp_1 = constant_test_bit(3L,(unsigned long const volatile *)(& common->op_flags));
      
#line 257 
      if (tmp_1 != 0) {
        
#line 259 
        ldv___ldv_spin_lock_88(& sc->sc_pm_lock);
        
#line 260 
        sc->ps_flags = (unsigned short)((unsigned int)sc->ps_flags | 17U);
        
#line 261 
        ldv_spin_unlock_irqrestore_89(& sc->sc_pm_lock,flags);
      }
      else 
#line 263 
           ath9k_set_beacon(sc);
    }
    else 
#line 263 
         ath9k_set_beacon(sc);
    work: 
#line 265 
    ;
    
#line 266 
    ath_restart_work(sc);
    
#line 267 
    ath_txq_schedule_all(sc);
  }
  else ;
  
#line 270 
  sc->gtt_cnt = (unsigned char)0U;
  
#line 272 
  ath9k_hw_set_interrupts(ah);
  
#line 273 
  ath9k_hw_enable_interrupts(ah);
  
#line 274 
  ieee80211_wake_queues(sc->hw);
  
#line 275 
  ath9k_p2p_ps_timer((void *)sc);
  
#line 277 
  __retres = (_Bool)1;
  
#line 277 
  return __retres;
}


#line 280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static int ath_reset_internal(struct ath_softc *sc, struct ath9k_channel *hchan)
{
  int r;
  int tmp_1;
  bool tmp_0;
  bool tmp_2;
  bool tmp_3;
  int tmp_5;
  bool tmp_4;
  
#line 282 
  struct ath_hw *ah = sc->sc_ah;
  
#line 283 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 284 
  struct ath9k_hw_cal_data *caldata = (struct ath9k_hw_cal_data *)0;
  
#line 285 
  bool fastcc = (_Bool)1;
  
#line 288 
  __ath_cancel_work(sc);
  
#line 290 
  disable_irq((unsigned int)sc->irq);
  
#line 291 
  tasklet_disable_0(& sc->intr_tq);
  
#line 292 
  tasklet_disable_0(& sc->bcon_tasklet);
  
#line 293 
  ldv_spin_lock_bh_90(& sc->sc_pcu_lock);
  
#line 295 
  if (! (sc->cur_chan)->offchannel) {
    
#line 296 
    fastcc = (_Bool)0;
    
#line 297 
    caldata = & (sc->cur_chan)->caldata;
  }
  else ;
  
#line 300 
  if (hchan == (struct ath9k_channel *)0) {
    
#line 301 
    fastcc = (_Bool)0;
    
#line 302 
    hchan = ah->curchan;
  }
  else ;
  
#line 305 
  tmp_0 = ath_prepare_reset(sc);
  
#line 305 
  if (tmp_0) 
#line 305 
             tmp_1 = 0; else 
#line 305 
                             tmp_1 = 1;
  
#line 305 
  if (tmp_1) 
#line 306 
             fastcc = (_Bool)0; else ;
  
#line 308 
  tmp_2 = ath9k_is_chanctx_enabled();
  
#line 308 
  if ((int)tmp_2 != 0) 
#line 309 
                       fastcc = (_Bool)0; else ;
  
#line 311 
  ldv_spin_lock_bh_91_0(& sc->chan_lock);
  
#line 312 
  sc->cur_chandef = (sc->cur_chan)->chandef;
  
#line 313 
  ldv_spin_unlock_bh_92_0(& sc->chan_lock);
  
#line 315 
  if ((common->debug_mask & 512) != 0) 
#line 315 
                                       ath_printk("\001",(struct ath_common const *)common,"Reset to %u MHz, HT40: %d fastcc: %d\n",(int)hchan->channel,((unsigned long)hchan->channelFlags & 48UL) != 0UL,(int)fastcc); else ;
  
#line 318 
  r = ath9k_hw_reset(ah,hchan,caldata,(_Bool)((bool)((int)fastcc) != 0));
  
#line 319 
  if (r != 0) {
    
#line 320 
    ath_printk("\001",(struct ath_common const *)common,"Unable to reset channel, reset status %d\n",r);
    
#line 323 
    ath9k_hw_enable_interrupts(ah);
    
#line 324 
    ath9k_queue_reset(sc,(enum ath_reset_type)RESET_TYPE_BB_HANG);
    
#line 326 
    goto out;
  }
  else ;
  
#line 329 
  tmp_3 = ath9k_hw_mci_is_enabled(sc->sc_ah);
  
#line 329 
  if ((int)tmp_3 != 0) {
    
#line 329 
    if ((int)(sc->cur_chan)->offchannel != 0) 
#line 331 
                                              ath9k_mci_set_txpower(sc,(_Bool)1,(_Bool)0); else ;
  }
  else ;
  
#line 333 
  tmp_4 = ath_complete_reset(sc,(_Bool)1);
  
#line 333 
  if (tmp_4) 
#line 333 
             tmp_5 = 0; else 
#line 333 
                             tmp_5 = 1;
  
#line 333 
  if (tmp_5) 
#line 334 
             r = -5; else ;
  out: 
#line 336 
  ;
  
#line 337 
  enable_irq((unsigned int)sc->irq);
  
#line 338 
  ldv_spin_unlock_bh_93(& sc->sc_pcu_lock);
  
#line 339 
  tasklet_enable_0(& sc->bcon_tasklet);
  
#line 340 
  tasklet_enable_0(& sc->intr_tq);
  
#line 342 
  return r;
}


#line 345  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath_node_attach(struct ath_softc *sc, struct ieee80211_sta *sta, struct ieee80211_vif *vif)
{
  struct ath_node *an;
  
#line 349 
  an = (struct ath_node *)(& sta->drv_priv);
  
#line 351 
  an->sc = sc;
  
#line 352 
  an->sta = sta;
  
#line 353 
  an->vif = vif;
  
#line 354 
  memset((void *)(& an->key_idx),0,4UL);
  
#line 356 
  ath_tx_node_init(sc,an);
  
#line 358 
  ath_dynack_node_init(sc->sc_ah,an);
  
#line 359 
  return;
}


#line 361  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath_node_detach(struct ath_softc *sc, struct ieee80211_sta *sta)
{
  
#line 363 
  struct ath_node *an = (struct ath_node *)(& sta->drv_priv);
  
#line 364 
  ath_tx_node_cleanup(sc,an);
  
#line 366 
  ath_dynack_node_deinit(sc->sc_ah,an);
  
#line 367 
  return;
}


#line 369  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
void ath9k_tasklet(unsigned long data)
{
  enum ath_reset_type type;
  unsigned long flags;
  u32 rxmask;
  
#line 371 
  struct ath_softc *sc = (struct ath_softc *)data;
  
#line 372 
  struct ath_hw *ah = sc->sc_ah;
  
#line 373 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 376 
  u32 status = sc->intrstatus;
  
#line 379 
  ath9k_ps_wakeup(sc);
  
#line 380 
  ldv_spin_lock_94(& sc->sc_pcu_lock);
  
#line 382 
  if ((status & 1073741824U) != 0U) {
    
#line 383 
    type = RESET_TYPE_FATAL_INT;
    
#line 384 
    ath9k_queue_reset(sc,type);
    
#line 390 
    atomic_inc_0(& ah->intr_ref_cnt);
    
#line 391 
    if ((common->debug_mask & 1) != 0) 
#line 391 
                                       ath_printk("\001",(struct ath_common const *)common,"FATAL: Skipping interrupts\n"); else ;
    
#line 392 
    goto out;
  }
  else ;
  
#line 395 
  if (((int)ah->config.hw_hang_checks & 1) != 0 && (status & 1024U) != 0U) {
    bool tmp_0;
    
#line 397 
    ldv_spin_lock_95(& common->cc_lock);
    
#line 398 
    ath_hw_cycle_counters_update(common);
    
#line 399 
    ar9003_hw_bb_watchdog_dbg_info(ah);
    
#line 400 
    ldv_spin_unlock_96(& common->cc_lock);
    
#line 402 
    tmp_0 = ar9003_hw_bb_watchdog_check(ah);
    
#line 402 
    if ((int)tmp_0 != 0) {
      
#line 403 
      type = RESET_TYPE_BB_WATCHDOG;
      
#line 404 
      ath9k_queue_reset(sc,type);
      
#line 410 
      atomic_inc_0(& ah->intr_ref_cnt);
      
#line 411 
      if ((common->debug_mask & 1) != 0) 
#line 411 
                                         ath_printk("\001",(struct ath_common const *)common,"BB_WATCHDOG: Skipping interrupts\n"); else ;
      
#line 413 
      goto out;
    }
    else ;
  }
  else ;
  
#line 417 
  if ((status & 536870912U) != 0U) {
    
#line 418 
    sc->gtt_cnt = (u8)((int)sc->gtt_cnt + 1);
    
#line 420 
    if ((unsigned int)sc->gtt_cnt > 4U) {
      int tmp_2;
      bool tmp_1;
      
#line 420 
      tmp_1 = ath9k_hw_check_alive(ah);
      
#line 420 
      if (tmp_1) 
#line 420 
                 tmp_2 = 0; else 
#line 420 
                                 tmp_2 = 1;
      
#line 420 
      if (tmp_2) {
        
#line 421 
        type = RESET_TYPE_TX_GTT;
        
#line 422 
        ath9k_queue_reset(sc,type);
        
#line 423 
        atomic_inc_0(& ah->intr_ref_cnt);
        
#line 424 
        if ((common->debug_mask & 1) != 0) 
#line 424 
                                           ath_printk("\001",(struct ath_common const *)common,"GTT: Skipping interrupts\n"); else ;
        
#line 426 
        goto out;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 430 
  ldv___ldv_spin_lock_97(& sc->sc_pm_lock);
  
#line 431 
  if ((status & 67108864U) != 0U && (int)sc->ps_enabled != 0) {
    
#line 436 
    if ((common->debug_mask & 2048) != 0) 
#line 436 
                                          ath_printk("\001",(struct ath_common const *)common,"TSFOOR - Sync with next Beacon\n"); else ;
    
#line 437 
    sc->ps_flags = (unsigned short)((unsigned int)sc->ps_flags | 17U);
  }
  else ;
  
#line 439 
  ldv_spin_unlock_irqrestore_98(& sc->sc_pm_lock,flags);
  
#line 441 
  if ((ah->caps.hw_caps & 16U) != 0U) 
#line 442 
                                      rxmask = 51U; else 
#line 445 
                                                         rxmask = 49U;
  
#line 447 
  if ((status & rxmask) != 0U) {
    
#line 449 
    if ((ah->caps.hw_caps & 16U) != 0U && (status & 1U) != 0U) 
#line 451 
                                                               ath_rx_tasklet(sc,0,(_Bool)1); else ;
    
#line 453 
    ath_rx_tasklet(sc,0,(_Bool)0);
  }
  else ;
  
#line 456 
  if ((status & 64U) != 0U) {
    
#line 457 
    if ((ah->caps.hw_caps & 16U) != 0U) {
      
#line 464 
      sc->gtt_cnt = (unsigned char)0U;
      
#line 466 
      ath_tx_edma_tasklet(sc);
    }
    else 
#line 468 
         ath_tx_tasklet(sc);
    
#line 471 
    __wake_up(& sc->tx_wait,3U,1,(void *)0);
  }
  else ;
  
#line 474 
  if ((status & 134217728U) != 0U) 
#line 475 
                                   ath_gen_timer_isr(sc->sc_ah); else ;
  
#line 477 
  ath9k_btcoex_handle_interrupt(sc,status);
  
#line 480 
  ath9k_hw_enable_interrupts(ah);
  out: 
#line 481 
  ;
  
#line 482 
  ldv_spin_unlock_99(& sc->sc_pcu_lock);
  
#line 483 
  ath9k_ps_restore(sc);
  
#line 484 
  return;
}


#line 486  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
irqreturn_t ath_isr(int irq, void *dev)
{
  irqreturn_t __retres;
  enum ath9k_int status;
  int tmp_2;
  bool tmp_1;
  int tmp_3;
  
#line 504 
  struct ath_softc *sc = (struct ath_softc *)dev;
  
#line 505 
  struct ath_hw *ah = sc->sc_ah;
  
#line 506 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 508 
  u32 sync_cause = 0U;
  
#line 509 
  bool sched = (_Bool)0;
  
#line 516 
  if (ah == (struct ath_hw *)0) {
    
#line 517 
    __retres = IRQ_NONE;
    
#line 517 
    goto return_label;
  }
  else {
    int tmp_0;
    
#line 516 
    tmp_0 = constant_test_bit(0L,(unsigned long const volatile *)(& common->op_flags));
    
#line 516 
    if (tmp_0 != 0) {
      
#line 517 
      __retres = IRQ_NONE;
      
#line 517 
      goto return_label;
    }
    else ;
  }
  
#line 520 
  tmp_1 = ath9k_hw_intrpend(ah);
  
#line 520 
  if (tmp_1) 
#line 520 
             tmp_2 = 0; else 
#line 520 
                             tmp_2 = 1;
  
#line 520 
  if (tmp_2) {
    
#line 521 
    __retres = IRQ_NONE;
    
#line 521 
    goto return_label;
  }
  else ;
  
#line 529 
  ath9k_hw_getisr(ah,& status,& sync_cause);
  
#line 530 
  ath9k_debug_sync_cause(sc,sync_cause);
  
#line 531 
  status = (enum ath9k_int)((unsigned int)ah->imask & (unsigned int)status);
  
#line 533 
  tmp_3 = constant_test_bit(4L,(unsigned long const volatile *)(& common->op_flags));
  
#line 533 
  if (tmp_3 != 0) {
    
#line 534 
    __retres = IRQ_HANDLED;
    
#line 534 
    goto return_label;
  }
  else ;
  
#line 540 
  if (status == (unsigned int)0) {
    
#line 541 
    __retres = IRQ_NONE;
    
#line 541 
    goto return_label;
  }
  else ;
  
#line 544 
  sc->intrstatus = (unsigned int)status;
  
#line 546 
  if (((unsigned int)status & 2080638579U) != 0U) 
#line 547 
                                                  sched = (_Bool)1; else ;
  
#line 553 
  if (((unsigned int)status & 1073741824U) != 0U) 
#line 554 
                                                  goto chip_reset; else ;
  
#line 556 
  if (((int)ah->config.hw_hang_checks & 1) != 0 && ((unsigned int)status & 1024U) != 0U) 
    
#line 558 
    goto chip_reset; else ;
  
#line 560 
  if (((unsigned int)status & 65536U) != 0U) 
#line 561 
                                             ldv_tasklet_schedule_100(& sc->bcon_tasklet); else ;
  
#line 563 
  if (((unsigned int)status & 2048U) != 0U) 
#line 564 
                                            ath9k_hw_updatetxtriglevel(ah,(_Bool)1); else ;
  
#line 566 
  if (((unsigned int)status & 16U) != 0U) {
    
#line 567 
    ah->imask = (enum ath9k_int)((unsigned int)ah->imask & 4294967247U);
    
#line 568 
    ath9k_hw_set_interrupts(ah);
  }
  else ;
  
#line 571 
  if ((ah->caps.hw_caps & 4U) == 0U) {
    
#line 572 
    if (((unsigned int)status & 256U) != 0U) {
      int tmp_5;
      {
        bool __warned;
        
#line 573 
        int __ret_warn_once = (int)sc->ps_idle != 0;
        
#line 573 
        if ((long)(__ret_warn_once != 0) != 0L) {
          int tmp_4;
          {
            
#line 573 
            int __ret_warn_on = ! __warned;
            
#line 573 
            if ((long)(__ret_warn_on != 0) != 0L) 
#line 573 
                                                  warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c",573); else ;
            
#line 573 
            tmp_4 = (long)(__ret_warn_on != 0);
          }
          
#line 573 
          if ((long)tmp_4 != 0L) 
#line 573 
                                 __warned = (_Bool)1; else ;
        }
        else ;
        
#line 573 
        tmp_5 = (long)(__ret_warn_once != 0);
      }
      
#line 573 
      if ((long)tmp_5 != 0L) 
#line 574 
                             goto chip_reset; else ;
      
#line 577 
      ath9k_setpower(sc,(enum ath9k_power_mode)ATH9K_PM_AWAKE);
      
#line 578 
      ldv_spin_lock_101(& sc->sc_pm_lock);
      
#line 579 
      ath9k_hw_setrxabort(sc->sc_ah,(_Bool)0);
      
#line 580 
      sc->ps_flags = (unsigned short)((unsigned int)sc->ps_flags | 1U);
      
#line 581 
      ldv_spin_unlock_102(& sc->sc_pm_lock);
    }
    else ;
  }
  else ;
  chip_reset: 
#line 584 
  ;
  
#line 586 
  ath_debug_stat_interrupt(sc,status);
  
#line 588 
  if ((int)sched != 0) {
    
#line 590 
    ath9k_hw_disable_interrupts(ah);
    
#line 591 
    ldv_tasklet_schedule_103(& sc->intr_tq);
  }
  else ;
  
#line 594 
  __retres = IRQ_HANDLED;
  return_label: 
#line 594 
                return __retres;
}


#line 603  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
int ath_reset(struct ath_softc *sc, struct ath9k_channel *hchan)
{
  int r;
  
#line 605 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 608 
  ath9k_hw_kill_interrupts(sc->sc_ah);
  
#line 609 
  set_bit(4L,(unsigned long volatile *)(& common->op_flags));
  
#line 611 
  ath9k_ps_wakeup(sc);
  
#line 612 
  r = ath_reset_internal(sc,hchan);
  
#line 613 
  ath9k_ps_restore(sc);
  
#line 615 
  return r;
}


#line 623  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
void ath9k_queue_reset(struct ath_softc *sc, enum ath_reset_type type)
{
  
#line 625 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 627 
  sc->debug.stats.reset[(unsigned int)type] += 1U;
  
#line 629 
  ath9k_hw_kill_interrupts(sc->sc_ah);
  
#line 630 
  set_bit(4L,(unsigned long volatile *)(& common->op_flags));
  
#line 631 
  ieee80211_queue_work(sc->hw,& sc->hw_reset_work);
  
#line 632 
  return;
}


#line 634  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
void ath_reset_work(struct work_struct *work)
{
  struct ath_softc *tmp;
  {
    
#line 636 
    struct work_struct const *__mptr = (struct work_struct const *)work;
    
#line 636 
    tmp = (struct ath_softc *)__mptr + 18446744073709548600U;
  }
  
#line 636 
  struct ath_softc *sc = tmp;
  
#line 638 
  ath9k_ps_wakeup(sc);
  
#line 639 
  ath_reset_internal(sc,(struct ath9k_channel *)0);
  
#line 640 
  ath9k_ps_restore(sc);
  
#line 641 
  return;
}


#line 647  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static int ath9k_start(struct ieee80211_hw *hw)
{
  int __retres;
  struct ath9k_channel *init_channel;
  int r;
  int tmp_1;
  bool tmp_0;
  
#line 649 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 650 
  struct ath_hw *ah = sc->sc_ah;
  
#line 651 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 652 
  struct ieee80211_channel *curchan = (sc->cur_chan)->chandef.chan;
  
#line 653 
  struct ath_chanctx *ctx = sc->cur_chan;
  
#line 657 
  if ((common->debug_mask & 512) != 0) 
#line 657 
                                       ath_printk("\001",(struct ath_common const *)common,"Starting driver with initial channel: %d MHz\n",(int)curchan->center_freq); else ;
  
#line 661 
  ath9k_ps_wakeup(sc);
  
#line 662 
  ldv_mutex_lock_104_0(& sc->mutex);
  
#line 664 
  init_channel = ath9k_cmn_get_channel(hw,ah,& ctx->chandef);
  
#line 665 
  sc->cur_chandef = hw->conf.chandef;
  
#line 668 
  ath9k_hw_configpcipowersave(ah,(_Bool)0);
  
#line 677 
  ldv_spin_lock_bh_105(& sc->sc_pcu_lock);
  
#line 679 
  atomic_set(& ah->intr_ref_cnt,-1);
  
#line 681 
  r = ath9k_hw_reset(ah,init_channel,ah->caldata,(_Bool)0);
  
#line 682 
  if (r != 0) {
    
#line 683 
    ath_printk("\001",(struct ath_common const *)common,"Unable to reset hardware; reset status %d (freq %u MHz)\n",r,(int)curchan->center_freq);
    
#line 686 
    ah->reset_power_on = (_Bool)0;
  }
  else ;
  
#line 690 
  ah->imask = 3221225584;
  
#line 694 
  if ((ah->caps.hw_caps & 16U) != 0U) 
#line 695 
                                      ah->imask = (enum ath9k_int)((unsigned int)ah->imask | 3U); else 
                                                                    
#line 698 
                                                                    ah->imask = (enum ath9k_int)((unsigned int)ah->imask | 1U);
  
#line 700 
  if (((int)ah->config.hw_hang_checks & 1) != 0) 
#line 701 
                                                 ah->imask = (enum ath9k_int)((unsigned int)ah->imask | 1024U); else ;
  
#line 707 
  if (ah->hw_version.macVersion > 447U) 
#line 708 
                                        ah->imask = (enum ath9k_int)((unsigned int)ah->imask | 536870912U); else ;
  
#line 710 
  if ((ah->caps.hw_caps & 1U) != 0U) 
#line 711 
                                     ah->imask = (enum ath9k_int)((unsigned int)ah->imask | 268435456U); else ;
  
#line 713 
  ath_mci_enable(sc);
  
#line 715 
  set_bit(0L,(unsigned long volatile *)(& common->op_flags));
  
#line 716 
  (sc->sc_ah)->is_monitoring = (_Bool)0;
  
#line 718 
  tmp_0 = ath_complete_reset(sc,(_Bool)0);
  
#line 718 
  if (tmp_0) 
#line 718 
             tmp_1 = 0; else 
#line 718 
                             tmp_1 = 1;
  
#line 718 
  if (tmp_1) 
#line 719 
             ah->reset_power_on = (_Bool)0; else ;
  
#line 721 
  if (ah->led_pin >= 0) {
    
#line 722 
    ath9k_hw_cfg_output(ah,(unsigned int)ah->led_pin,0U);
    
#line 724 
    ath9k_hw_set_gpio(ah,(unsigned int)ah->led_pin,(unsigned int)((int)ah->config.led_active_high != 0));
  }
  else ;
  
#line 732 
  ath9k_cmn_init_crypto(sc->sc_ah);
  
#line 734 
  ath9k_hw_reset_tsf(ah);
  
#line 736 
  ldv_spin_unlock_bh_106(& sc->sc_pcu_lock);
  
#line 738 
  ldv_mutex_unlock_107(& sc->mutex);
  
#line 740 
  ath9k_ps_restore(sc);
  
#line 742 
  __retres = 0;
  
#line 742 
  return __retres;
}


#line 745  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath9k_tx(struct ieee80211_hw *hw, struct ieee80211_tx_control *control, struct sk_buff *skb)
{
  struct ath_tx_control txctl;
  unsigned long flags;
  u16 tmp_4;
  int tmp_5;
  
#line 749 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 750 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 752 
  struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
  
#line 755 
  if ((int)sc->ps_enabled != 0) {
    int tmp_0;
    
#line 760 
    tmp_0 = ieee80211_is_data((unsigned short)((int)hdr->frame_control));
    
#line 760 
    if (tmp_0 != 0) {
      int tmp_1;
      
#line 760 
      tmp_1 = ieee80211_is_nullfunc((unsigned short)((int)hdr->frame_control));
      
#line 760 
      if (tmp_1 == 0) {
        int tmp_2;
        
#line 761 
        tmp_2 = ieee80211_has_pm((unsigned short)((int)hdr->frame_control));
        
#line 761 
        if (tmp_2 == 0) {
          
#line 763 
          if ((common->debug_mask & 2048) != 0) 
#line 763 
                                                ath_printk("\001",(struct ath_common const *)common,"Add PM=1 for a TX frame while in PS mode\n"); else ;
          
#line 765 
          hdr->frame_control = (unsigned short)((unsigned int)hdr->frame_control | 4096U);
        }
        else ;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 769 
  if ((long)((sc->sc_ah)->power_mode == (unsigned int)ATH9K_PM_NETWORK_SLEEP) != 0L) {
    int tmp_3;
    
#line 775 
    ath9k_ps_wakeup(sc);
    
#line 776 
    ldv___ldv_spin_lock_108_0(& sc->sc_pm_lock);
    
#line 777 
    if (((sc->sc_ah)->caps.hw_caps & 4U) == 0U) 
#line 778 
                                                ath9k_hw_setrxabort(sc->sc_ah,(_Bool)0); else ;
    
#line 779 
    tmp_3 = ieee80211_is_pspoll((unsigned short)((int)hdr->frame_control));
    
#line 779 
    if (tmp_3 != 0) {
      
#line 780 
      if ((common->debug_mask & 2048) != 0) 
#line 780 
                                            ath_printk("\001",(struct ath_common const *)common,"Sending PS-Poll to pick a buffered frame\n"); else ;
      
#line 782 
      sc->ps_flags = (unsigned short)((unsigned int)sc->ps_flags | 4U);
    }
    else {
      
#line 784 
      if ((common->debug_mask & 2048) != 0) 
#line 784 
                                            ath_printk("\001",(struct ath_common const *)common,"Wake up to complete TX\n"); else ;
      
#line 785 
      sc->ps_flags = (unsigned short)((unsigned int)sc->ps_flags | 8U);
    }
    
#line 792 
    ldv_spin_unlock_irqrestore_109_0(& sc->sc_pm_lock,flags);
    
#line 793 
    ath9k_ps_restore(sc);
  }
  else ;
  
#line 800 
  if ((long)((sc->sc_ah)->power_mode == (unsigned int)ATH9K_PM_FULL_SLEEP) != 0L) {
    
#line 801 
    ath_printk("\001",(struct ath_common const *)common,"TX while HW is in FULL_SLEEP mode\n");
    
#line 802 
    goto exit;
  }
  else ;
  
#line 805 
  memset((void *)(& txctl),0,32UL);
  
#line 806 
  tmp_4 = skb_get_queue_mapping((struct sk_buff const *)skb);
  
#line 806 
  txctl.txq = sc->tx.txq_map[(int)tmp_4];
  
#line 807 
  txctl.sta = control->sta;
  
#line 809 
  if ((common->debug_mask & 128) != 0) 
#line 809 
                                       ath_printk("\001",(struct ath_common const *)common,"transmitting packet, skb: %p\n",skb); else ;
  
#line 811 
  tmp_5 = ath_tx_start(hw,skb,& txctl);
  
#line 811 
  if (tmp_5 != 0) {
    
#line 812 
    if ((common->debug_mask & 128) != 0) 
#line 812 
                                         ath_printk("\001",(struct ath_common const *)common,"TX failed\n"); else ;
    
#line 813 
    sc->debug.stats.txstats[(txctl.txq)->axq_qnum].txfailed += 1U;
    
#line 814 
    goto exit;
  }
  else ;
  
#line 817 
  goto return_label;
  exit: 
#line 818 
  ;
  
#line 819 
  ieee80211_free_txskb(hw,skb);
  return_label: 
#line 820 
                return;
}


#line 822  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath9k_stop(struct ieee80211_hw *hw)
{
  bool prev_idle;
  int tmp_0;
  
#line 824 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 825 
  struct ath_hw *ah = sc->sc_ah;
  
#line 826 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 829 
  ath9k_deinit_channel_context(sc);
  
#line 831 
  ldv_mutex_lock_110(& sc->mutex);
  
#line 833 
  ath_cancel_work(sc);
  
#line 835 
  tmp_0 = constant_test_bit(0L,(unsigned long const volatile *)(& common->op_flags));
  
#line 835 
  if (tmp_0 != 0) {
    
#line 836 
    if (common->debug_mask != 0) 
#line 836 
                                 ath_printk("\001",(struct ath_common const *)common,"Device not present\n"); else ;
    
#line 837 
    ldv_mutex_unlock_111(& sc->mutex);
    
#line 838 
    goto return_label;
  }
  else ;
  
#line 842 
  ath9k_ps_wakeup(sc);
  
#line 844 
  ldv_spin_lock_bh_112(& sc->sc_pcu_lock);
  
#line 847 
  ah->imask = (enum ath9k_int)((unsigned int)ah->imask & 2147483647U);
  
#line 851 
  ath9k_hw_disable_interrupts(ah);
  
#line 853 
  ldv_spin_unlock_bh_113(& sc->sc_pcu_lock);
  
#line 857 
  synchronize_irq((unsigned int)sc->irq);
  
#line 858 
  tasklet_kill(& sc->intr_tq);
  
#line 859 
  tasklet_kill(& sc->bcon_tasklet);
  
#line 861 
  prev_idle = sc->ps_idle;
  
#line 862 
  sc->ps_idle = (_Bool)1;
  
#line 864 
  ldv_spin_lock_bh_114(& sc->sc_pcu_lock);
  
#line 866 
  if (ah->led_pin >= 0) {
    
#line 867 
    ath9k_hw_set_gpio(ah,(unsigned int)ah->led_pin,(unsigned int)(! ah->config.led_active_high));
    
#line 869 
    ath9k_hw_cfg_gpio_input(ah,(unsigned int)ah->led_pin);
  }
  else ;
  
#line 872 
  ath_prepare_reset(sc);
  
#line 874 
  if (sc->rx.frag != (struct sk_buff *)0) {
    
#line 875 
    dev_kfree_skb_any(sc->rx.frag);
    
#line 876 
    sc->rx.frag = (struct sk_buff *)0;
  }
  else ;
  
#line 879 
  if (ah->curchan == (struct ath9k_channel *)0) 
#line 880 
                                                ah->curchan = ath9k_cmn_get_channel(hw,ah,& (sc->cur_chan)->chandef); else ;
  
#line 883 
  ath9k_hw_reset(ah,ah->curchan,ah->caldata,(_Bool)0);
  
#line 885 
  set_bit(0L,(unsigned long volatile *)(& common->op_flags));
  
#line 887 
  ath9k_hw_phy_disable(ah);
  
#line 889 
  ath9k_hw_configpcipowersave(ah,(_Bool)1);
  
#line 891 
  ldv_spin_unlock_bh_115(& sc->sc_pcu_lock);
  
#line 893 
  ath9k_ps_restore(sc);
  
#line 895 
  sc->ps_idle = prev_idle;
  
#line 897 
  ldv_mutex_unlock_116(& sc->mutex);
  
#line 899 
  if ((common->debug_mask & 512) != 0) 
#line 899 
                                       ath_printk("\001",(struct ath_common const *)common,"Driver halt\n"); else ;
  return_label: 
#line 900 
                return;
}


#line 902  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static bool ath9k_uses_beacons(int type)
{
  bool __retres;
  
#line 904 
  switch (type) {
    case 3: 
#line 905 
    ;
    case 1: 
#line 906 
    ;
    case 7: 
#line 907 
    ;
    
#line 908 
    __retres = (_Bool)1;
    
#line 908 
    goto return_label;
    default: 
#line 909 
    ;
    
#line 910 
    __retres = (_Bool)0;
    
#line 910 
    goto return_label;
  }
  return_label: 
#line 904 
                return __retres;
}


#line 914  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath9k_vif_iter(struct ath9k_vif_iter_data *iter_data, u8 *mac, struct ieee80211_vif *vif)
{
  int i;
  
#line 917 
  struct ath_vif *avp = (struct ath_vif *)(& vif->drv_priv);
  
#line 920 
  if ((int)iter_data->has_hw_macaddr != 0) {
    
#line 921 
    i = 0;
    
#line 921 
    goto ldv_54082;
    ldv_54081: 
#line 922 
    ;
    
#line 922 
    iter_data->mask[i] = (unsigned char)((int)iter_data->mask[i] & ~ ((int)iter_data->hw_macaddr[i] ^ (int)*(mac + i)));
    
#line 921 
    i += 1;
    ldv_54082: 
#line 922 
    ;
    
#line 921 
    if (i <= 5) 
#line 923 
                goto ldv_54081; else 
#line 926 
                                     goto ldv_54083;
    ldv_54083: 
#line 927 
    ;
  }
  else {
    
#line 925 
    memcpy((void *)(& iter_data->hw_macaddr),(void const *)mac,6UL);
    
#line 926 
    iter_data->has_hw_macaddr = (_Bool)1;
  }
  
#line 929 
  if (! vif->bss_conf.use_short_slot) 
#line 930 
                                      iter_data->slottime = (unsigned char)20U; else ;
  
#line 932 
  switch ((unsigned int)vif->type) {
    case (unsigned int)3: 
#line 933 
    ;
    
#line 934 
    iter_data->naps += 1;
    
#line 935 
    goto ldv_54085;
    case (unsigned int)2: 
#line 936 
    ;
    
#line 937 
    iter_data->nstations += 1;
    
#line 938 
    if ((int)avp->assoc != 0 && iter_data->primary_sta == (struct ieee80211_vif *)0) 
      
#line 939 
      iter_data->primary_sta = vif; else ;
    
#line 940 
    goto ldv_54085;
    case (unsigned int)1: 
#line 941 
    ;
    
#line 942 
    iter_data->nadhocs += 1;
    
#line 943 
    if ((int)vif->bss_conf.enable_beacon != 0) 
#line 944 
                                               iter_data->beacons = (_Bool)1; else ;
    
#line 945 
    goto ldv_54085;
    case (unsigned int)7: 
#line 946 
    ;
    
#line 947 
    iter_data->nmeshes += 1;
    
#line 948 
    if ((int)vif->bss_conf.enable_beacon != 0) 
#line 949 
                                               iter_data->beacons = (_Bool)1; else ;
    
#line 950 
    goto ldv_54085;
    case (unsigned int)5: 
#line 951 
    ;
    
#line 952 
    iter_data->nwds += 1;
    
#line 953 
    goto ldv_54085;
    default: 
#line 954 
    ;
    
#line 955 
    goto ldv_54085;
  }
  ldv_54085: 
#line 957 
  ;
  
#line 958 
  return;
}


#line 959  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath9k_update_bssid_mask(struct ath_softc *sc, struct ath_chanctx *ctx, struct ath9k_vif_iter_data *iter_data)
{
  struct ath_vif *avp;
  int i;
  int tmp_1;
  bool tmp_0;
  struct ath_vif *tmp_2;
  struct ath_vif *tmp_3;
  
#line 963 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 967 
  tmp_0 = ath9k_is_chanctx_enabled();
  
#line 967 
  if (tmp_0) 
#line 967 
             tmp_1 = 0; else 
#line 967 
                             tmp_1 = 1;
  
#line 967 
  if (tmp_1) 
#line 968 
             goto return_label; else ;
  {
    
#line 970 
    struct list_head const *__mptr = (struct list_head const *)ctx->vifs.next;
    
#line 970 
    tmp_2 = (struct ath_vif *)__mptr;
  }
  
#line 970 
  avp = tmp_2;
  
#line 970 
  goto ldv_54108;
  ldv_54107: 
#line 971 
  ;
  
#line 971 
  if ((int)ctx->nvifs_assigned != 1) 
#line 972 
                                     goto ldv_54103; else ;
  
#line 974 
  if (! (avp->vif)->p2p || ! iter_data->has_hw_macaddr) 
#line 975 
                                                        goto ldv_54103; else ;
  
#line 977 
  ether_addr_copy((u8 *)(& common->curbssid),(u8 const *)(& avp->bssid));
  
#line 980 
  i = 0;
  
#line 980 
  goto ldv_54105;
  ldv_54104: 
#line 981 
  ;
  
#line 981 
  iter_data->mask[i] = (unsigned char)((int)iter_data->mask[i] & ~ ((int)iter_data->hw_macaddr[i] ^ (int)((sc->hw)->wiphy)->perm_addr[i]));
  
#line 980 
  i += 1;
  ldv_54105: 
#line 981 
  ;
  
#line 980 
  if (i <= 5) 
#line 982 
              goto ldv_54104; else 
#line 985 
                                   goto ldv_54106;
  ldv_54106: 
#line 986 
  ;
  ldv_54103: 
#line 987 
  ;
  {
    
#line 970 
    struct list_head const *__mptr_0 = (struct list_head const *)avp->list.next;
    
#line 970 
    tmp_3 = (struct ath_vif *)__mptr_0;
  }
  
#line 970 
  avp = tmp_3;
  ldv_54108: 
#line 972 
  ;
  
#line 970 
  if (& avp->list != & ctx->vifs) 
#line 972 
                                  goto ldv_54107; else 
#line 975 
                                                       goto ldv_54109;
  ldv_54109: 
#line 976 
  ;
  return_label: 
#line 977 
                return;
}


#line 988  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
void ath9k_calculate_iter_data(struct ath_softc *sc, struct ath_chanctx *ctx, struct ath9k_vif_iter_data *iter_data)
{
  struct ath_vif *avp;
  struct ath_vif *tmp;
  struct ath_vif *tmp_0;
  
#line 998 
  memset((void *)iter_data,0,48UL);
  
#line 999 
  eth_broadcast_addr((u8 *)(& iter_data->mask));
  
#line 1000 
  iter_data->slottime = (unsigned char)9U;
  {
    
#line 1002 
    struct list_head const *__mptr = (struct list_head const *)ctx->vifs.next;
    
#line 1002 
    tmp = (struct ath_vif *)__mptr;
  }
  
#line 1002 
  avp = tmp;
  
#line 1002 
  goto ldv_54121;
  ldv_54120: 
#line 1003 
  ;
  
#line 1003 
  ath9k_vif_iter(iter_data,(u8 *)(& (avp->vif)->addr),avp->vif);
  {
    
#line 1002 
    struct list_head const *__mptr_0 = (struct list_head const *)avp->list.next;
    
#line 1002 
    tmp_0 = (struct ath_vif *)__mptr_0;
  }
  
#line 1002 
  avp = tmp_0;
  ldv_54121: 
#line 1004 
  ;
  
#line 1002 
  if (& avp->list != & ctx->vifs) 
#line 1004 
                                  goto ldv_54120; else 
#line 1007 
                                                       goto ldv_54122;
  ldv_54122: 
#line 1008 
  ;
  
#line 1005 
  ath9k_update_bssid_mask(sc,ctx,iter_data);
  
#line 1006 
  return;
}


#line 1008  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath9k_set_assoc_state(struct ath_softc *sc, struct ieee80211_vif *vif, bool changed)
{
  unsigned long flags;
  bool tmp_0;
  
#line 1011 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 1012 
  struct ath_vif *avp = (struct ath_vif *)(& vif->drv_priv);
  
#line 1015 
  set_bit(3L,(unsigned long volatile *)(& common->op_flags));
  
#line 1017 
  ether_addr_copy((u8 *)(& common->curbssid),(u8 const *)(& avp->bssid));
  
#line 1018 
  common->curaid = avp->aid;
  
#line 1019 
  ath9k_hw_write_associd(sc->sc_ah);
  
#line 1021 
  if ((int)changed != 0) {
    
#line 1022 
    common->last_rssi = 127;
    
#line 1023 
    (sc->sc_ah)->stats.avgbrssi = 127U;
    
#line 1025 
    ldv___ldv_spin_lock_117(& sc->sc_pm_lock);
    
#line 1026 
    sc->ps_flags = (unsigned short)((unsigned int)sc->ps_flags | 17U);
    
#line 1027 
    ldv_spin_unlock_irqrestore_118(& sc->sc_pm_lock,flags);
  }
  else ;
  
#line 1030 
  tmp_0 = ath9k_hw_mci_is_enabled(sc->sc_ah);
  
#line 1030 
  if ((int)tmp_0 != 0) 
#line 1031 
                       ath9k_mci_update_wlan_channels(sc,(_Bool)0); else ;
  
#line 1033 
  if ((common->debug_mask & 512) != 0) 
#line 1033 
                                       ath_printk("\001",(struct ath_common const *)common,"Primary Station interface: %pM, BSSID: %pM\n",(u8 *)(& vif->addr),(u8 *)(& common->curbssid)); else ;
  
#line 1034 
  return;
}


#line 1039  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath9k_set_offchannel_state(struct ath_softc *sc)
{
  int tmp_0;
  
#line 1041 
  struct ath_hw *ah = sc->sc_ah;
  
#line 1042 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 1043 
  struct ieee80211_vif *vif = (struct ieee80211_vif *)0;
  
#line 1045 
  ath9k_ps_wakeup(sc);
  
#line 1047 
  if (sc->offchannel.state <= (unsigned int)ATH_OFFCHANNEL_SUSPEND) 
#line 1048 
                                                                    vif = sc->offchannel.scan_vif; else 
                                                                    
#line 1050 
                                                                    vif = sc->offchannel.roc_vif;
  {
    
#line 1052 
    int __ret_warn_on = vif == (struct ieee80211_vif *)0;
    
#line 1052 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 1052 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c",1052); else ;
    
#line 1052 
    tmp_0 = (long)(__ret_warn_on != 0);
  }
  
#line 1052 
  if ((long)tmp_0 != 0L) 
#line 1053 
                         goto exit; else ;
  
#line 1055 
  eth_zero_addr((u8 *)(& common->curbssid));
  
#line 1056 
  eth_broadcast_addr((u8 *)(& common->bssidmask));
  
#line 1057 
  memcpy((void *)(& common->macaddr),(void const *)(& vif->addr),6UL);
  
#line 1058 
  common->curaid = (unsigned short)0U;
  
#line 1059 
  ah->opmode = vif->type;
  
#line 1060 
  ah->imask = (enum ath9k_int)((unsigned int)ah->imask & 4294901759U);
  
#line 1061 
  ah->imask = (enum ath9k_int)((unsigned int)ah->imask & 4227858431U);
  
#line 1062 
  ah->slottime = 9U;
  
#line 1064 
  ath_hw_setbssidmask(common);
  
#line 1065 
  ath9k_hw_setopmode(ah);
  
#line 1066 
  ath9k_hw_write_associd(sc->sc_ah);
  
#line 1067 
  ath9k_hw_set_interrupts(ah);
  
#line 1068 
  ath9k_hw_init_global_settings(ah);
  exit: 
#line 1070 
  ;
  
#line 1071 
  ath9k_ps_restore(sc);
  
#line 1072 
  return;
}


#line 1076  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
void ath9k_calculate_summary_state(struct ath_softc *sc, struct ath_chanctx *ctx)
{
  struct ath9k_vif_iter_data iter_data;
  struct ath_beacon_config *cur_conf;
  
#line 1079 
  struct ath_hw *ah = sc->sc_ah;
  
#line 1080 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 1084 
  ath_chanctx_check_active(sc,ctx);
  
#line 1086 
  if (sc->cur_chan != ctx) 
#line 1087 
                           goto return_label; else ;
  
#line 1090 
  if (& sc->offchannel.chan == ctx) 
#line 1091 
                                    ath9k_set_offchannel_state(sc); else ;
  
#line 1094 
  ath9k_ps_wakeup(sc);
  
#line 1095 
  ath9k_calculate_iter_data(sc,ctx,& iter_data);
  
#line 1097 
  if ((int)iter_data.has_hw_macaddr != 0) 
#line 1098 
                                          memcpy((void *)(& common->macaddr),(void const *)(& iter_data.hw_macaddr),6UL); else ;
  
#line 1100 
  memcpy((void *)(& common->bssidmask),(void const *)(& iter_data.mask),6UL);
  
#line 1101 
  ath_hw_setbssidmask(common);
  
#line 1103 
  if (iter_data.naps > 0) {
    
#line 1104 
    cur_conf = & ctx->beacon;
    
#line 1105 
    ath9k_hw_set_tsfadjust(ah,(_Bool)1);
    
#line 1106 
    ah->opmode = NL80211_IFTYPE_AP;
    
#line 1107 
    if ((unsigned int)cur_conf->enable_beacon != 0U) 
#line 1108 
                                                     iter_data.beacons = (_Bool)1; else ;
  }
  else {
    
#line 1110 
    ath9k_hw_set_tsfadjust(ah,(_Bool)0);
    
#line 1112 
    if (iter_data.nmeshes != 0) 
#line 1113 
                                ah->opmode = NL80211_IFTYPE_MESH_POINT;
    else 
      
#line 1114 
      if (iter_data.nwds != 0) 
#line 1115 
                               ah->opmode = NL80211_IFTYPE_AP;
      else 
        
#line 1116 
        if (iter_data.nadhocs != 0) 
#line 1117 
                                    ah->opmode = NL80211_IFTYPE_ADHOC; else 
                                                                    
#line 1119 
                                                                    ah->opmode = NL80211_IFTYPE_STATION;
  }
  
#line 1122 
  ath9k_hw_setopmode(ah);
  
#line 1124 
  ctx->switch_after_beacon = (_Bool)0;
  
#line 1125 
  if ((iter_data.nstations + iter_data.nadhocs) + iter_data.nmeshes > 0) 
    
#line 1126 
    ah->imask = (enum ath9k_int)((unsigned int)ah->imask | 67108864U);
  else {
    
#line 1128 
    ah->imask = (enum ath9k_int)((unsigned int)ah->imask & 4227858431U);
    
#line 1129 
    if (iter_data.naps == 1 && (int)iter_data.beacons != 0) 
#line 1130 
                                                            ctx->switch_after_beacon = (_Bool)1; else ;
  }
  
#line 1133 
  ah->imask = (enum ath9k_int)((unsigned int)ah->imask & 4294901759U);
  
#line 1134 
  if (ah->opmode == (unsigned int)NL80211_IFTYPE_STATION) {
    
#line 1135 
    bool changed = (_Bool)(iter_data.primary_sta != ctx->primary_sta);
    
#line 1137 
    if (iter_data.primary_sta != (struct ieee80211_vif *)0) {
      
#line 1138 
      iter_data.beacons = (_Bool)1;
      
#line 1139 
      ath9k_set_assoc_state(sc,iter_data.primary_sta,(_Bool)((bool)((int)changed) != 0));
      
#line 1141 
      ctx->primary_sta = iter_data.primary_sta;
    }
    else {
      bool tmp_0;
      
#line 1143 
      ctx->primary_sta = (struct ieee80211_vif *)0;
      
#line 1144 
      eth_zero_addr((u8 *)(& common->curbssid));
      
#line 1145 
      common->curaid = (unsigned short)0U;
      
#line 1146 
      ath9k_hw_write_associd(sc->sc_ah);
      
#line 1147 
      tmp_0 = ath9k_hw_mci_is_enabled(sc->sc_ah);
      
#line 1147 
      if ((int)tmp_0 != 0) 
#line 1148 
                           ath9k_mci_update_wlan_channels(sc,(_Bool)1); else ;
    }
  }
  else 
    
#line 1150 
    if ((int)iter_data.beacons != 0) 
#line 1151 
                                     ah->imask = (enum ath9k_int)((unsigned int)ah->imask | 65536U); else ;
  
#line 1153 
  ath9k_hw_set_interrupts(ah);
  
#line 1155 
  if ((int)iter_data.beacons != 0) 
#line 1156 
                                   set_bit(1L,(unsigned long volatile *)(& common->op_flags)); else 
                                                                    
#line 1158 
                                                                    set_bit(1L,(unsigned long volatile *)(& common->op_flags));
  
#line 1160 
  if (ah->slottime != (unsigned int)iter_data.slottime) {
    
#line 1161 
    ah->slottime = (unsigned int)iter_data.slottime;
    
#line 1162 
    ath9k_hw_init_global_settings(ah);
  }
  else ;
  
#line 1165 
  if (iter_data.primary_sta != (struct ieee80211_vif *)0) 
#line 1166 
                                                          set_bit(3L,(unsigned long volatile *)(& common->op_flags)); else 
                                                                    
#line 1168 
                                                                    set_bit(3L,(unsigned long volatile *)(& common->op_flags));
  
#line 1170 
  if ((common->debug_mask & 512) != 0) 
#line 1170 
                                       ath_printk("\001",(struct ath_common const *)common,"macaddr: %pM, bssid: %pM, bssidmask: %pM\n",(u8 *)(& common->macaddr),(u8 *)(& common->curbssid),(u8 *)(& common->bssidmask)); else ;
  
#line 1174 
  ath9k_ps_restore(sc);
  return_label: 
#line 1175 
                return;
}


#line 1177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath9k_tpc_vif_iter(void *data, u8 *mac, struct ieee80211_vif *vif)
{
  
#line 1179 
  int *power = (int *)data;
  
#line 1181 
  if (*power < vif->bss_conf.txpower) 
#line 1182 
                                      *power = vif->bss_conf.txpower; else ;
  
#line 1183 
  return;
}


#line 1186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
void ath9k_set_txpower(struct ath_softc *sc, struct ieee80211_vif *vif)
{
  int power;
  
#line 1189 
  struct ath_hw *ah = sc->sc_ah;
  
#line 1190 
  struct ath_regulatory *reg = ath9k_hw_regulatory(ah);
  
#line 1192 
  ath9k_ps_wakeup(sc);
  
#line 1193 
  if ((int)ah->tpc_enabled != 0) {
    
#line 1194 
    if (vif != (struct ieee80211_vif *)0) 
#line 1194 
                                          power = vif->bss_conf.txpower; else 
                                                                    
#line 1194 
                                                                    power = -1;
    
#line 1195 
    ieee80211_iterate_active_interfaces_atomic(sc->hw,1U,& ath9k_tpc_vif_iter,(void *)(& power));
    
#line 1198 
    if (power == -1) 
#line 1199 
                     power = (sc->hw)->conf.power_level; else ;
  }
  else 
#line 1201 
       power = (sc->hw)->conf.power_level;
  
#line 1203 
  (sc->cur_chan)->txpower = (unsigned short)((unsigned int)((unsigned short)power) * 2U);
  
#line 1204 
  ath9k_hw_set_txpowerlimit(ah,(unsigned int)(sc->cur_chan)->txpower,(_Bool)0);
  
#line 1205 
  (sc->cur_chan)->cur_txpower = reg->max_power_level;
  
#line 1206 
  ath9k_ps_restore(sc);
  
#line 1207 
  return;
}


#line 1209  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath9k_assign_hw_queues(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
{
  int i;
  int tmp_0;
  bool tmp;
  
#line 1214 
  tmp = ath9k_is_chanctx_enabled();
  
#line 1214 
  if (tmp) 
#line 1214 
           tmp_0 = 0; else 
#line 1214 
                           tmp_0 = 1;
  
#line 1214 
  if (tmp_0) 
#line 1215 
             goto return_label; else ;
  
#line 1217 
  i = 0;
  
#line 1217 
  goto ldv_54168;
  ldv_54167: 
#line 1218 
  ;
  
#line 1218 
  vif->hw_queue[i] = (unsigned char)i;
  
#line 1217 
  i += 1;
  ldv_54168: 
#line 1218 
  ;
  
#line 1217 
  if (i <= 3) 
#line 1219 
              goto ldv_54167; else 
#line 1222 
                                   goto ldv_54169;
  ldv_54169: 
#line 1223 
  ;
  
#line 1220 
  if (vif->type == (unsigned int)NL80211_IFTYPE_AP || vif->type == (unsigned int)NL80211_IFTYPE_MESH_POINT) 
    
#line 1222 
    vif->cab_queue = (unsigned char)((unsigned int)((unsigned char)hw->queues) + 254U); else 
                                                                    
#line 1224 
                                                                    vif->cab_queue = (unsigned char)255U;
  return_label: 
#line 1225 
                return;
}


#line 1227  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static int ath9k_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
{
  int __retres;
  bool tmp_0;
  int tmp_2;
  bool tmp_1;
  
#line 1230 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 1231 
  struct ath_hw *ah = sc->sc_ah;
  
#line 1232 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 1233 
  struct ath_vif *avp = (struct ath_vif *)(& vif->drv_priv);
  
#line 1234 
  struct ath_node *an = & avp->mcast_node;
  
#line 1236 
  ldv_mutex_lock_119(& sc->mutex);
  
#line 1239 
  if ((int)(sc->cur_chan)->nvifs > 0) {
    
#line 1240 
    ldv_mutex_unlock_120(& sc->mutex);
    
#line 1241 
    __retres = -95;
    
#line 1241 
    goto return_label;
  }
  else ;
  
#line 1243 
  sc->tx99_vif = vif;
  
#line 1246 
  if ((common->debug_mask & 512) != 0) 
#line 1246 
                                       ath_printk("\001",(struct ath_common const *)common,"Attach a VIF of type: %d\n",(unsigned int)vif->type); else ;
  
#line 1247 
  (sc->cur_chan)->nvifs = (short)((int)(sc->cur_chan)->nvifs + 1);
  
#line 1249 
  tmp_0 = ath9k_uses_beacons((int)vif->type);
  
#line 1249 
  if ((int)tmp_0 != 0) 
#line 1250 
                       ath9k_beacon_assign_slot(sc,vif); else ;
  
#line 1252 
  avp->vif = vif;
  
#line 1253 
  tmp_1 = ath9k_is_chanctx_enabled();
  
#line 1253 
  if (tmp_1) 
#line 1253 
             tmp_2 = 0; else 
#line 1253 
                             tmp_2 = 1;
  
#line 1253 
  if (tmp_2) {
    
#line 1254 
    avp->chanctx = sc->cur_chan;
    
#line 1255 
    list_add_tail(& avp->list,& (avp->chanctx)->vifs);
  }
  else ;
  
#line 1258 
  ath9k_calculate_summary_state(sc,avp->chanctx);
  
#line 1260 
  ath9k_assign_hw_queues(hw,vif);
  
#line 1262 
  ath9k_set_txpower(sc,vif);
  
#line 1264 
  an->sc = sc;
  
#line 1265 
  an->sta = (struct ieee80211_sta *)0;
  
#line 1266 
  an->vif = vif;
  
#line 1267 
  an->no_ps_filter = (_Bool)1;
  
#line 1268 
  ath_tx_node_init(sc,an);
  
#line 1270 
  ldv_mutex_unlock_121(& sc->mutex);
  
#line 1271 
  __retres = 0;
  return_label: 
#line 1271 
                return __retres;
}


#line 1274  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static int ath9k_change_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif, enum nl80211_iftype new_type, bool p2p)
{
  int __retres;
  bool tmp_0;
  bool tmp_1;
  
#line 1279 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 1280 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 1281 
  struct ath_vif *avp = (struct ath_vif *)(& vif->drv_priv);
  
#line 1283 
  ldv_mutex_lock_122(& sc->mutex);
  
#line 1286 
  ldv_mutex_unlock_123(& sc->mutex);
  
#line 1287 
  __retres = -95;
  
#line 1287 
  goto return_label;
  
#line 1290 
  if ((common->debug_mask & 512) != 0) 
#line 1290 
                                       ath_printk("\001",(struct ath_common const *)common,"Change Interface\n"); else ;
  
#line 1292 
  tmp_0 = ath9k_uses_beacons((int)vif->type);
  
#line 1292 
  if ((int)tmp_0 != 0) 
#line 1293 
                       ath9k_beacon_remove_slot(sc,vif); else ;
  
#line 1295 
  vif->type = new_type;
  
#line 1296 
  vif->p2p = p2p;
  
#line 1298 
  tmp_1 = ath9k_uses_beacons((int)vif->type);
  
#line 1298 
  if ((int)tmp_1 != 0) 
#line 1299 
                       ath9k_beacon_assign_slot(sc,vif); else ;
  
#line 1301 
  ath9k_assign_hw_queues(hw,vif);
  
#line 1302 
  ath9k_calculate_summary_state(sc,avp->chanctx);
  
#line 1304 
  ath9k_set_txpower(sc,vif);
  
#line 1306 
  ldv_mutex_unlock_124(& sc->mutex);
  
#line 1307 
  __retres = 0;
  return_label: 
#line 1307 
                return __retres;
}


#line 1310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath9k_remove_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
{
  int tmp_1;
  bool tmp_0;
  bool tmp_2;
  
#line 1313 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 1314 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 1315 
  struct ath_vif *avp = (struct ath_vif *)(& vif->drv_priv);
  
#line 1317 
  if ((common->debug_mask & 512) != 0) 
#line 1317 
                                       ath_printk("\001",(struct ath_common const *)common,"Detach Interface\n"); else ;
  
#line 1319 
  ldv_mutex_lock_125(& sc->mutex);
  
#line 1321 
  ath9k_p2p_remove_vif(sc,vif);
  
#line 1323 
  (sc->cur_chan)->nvifs = (short)((int)(sc->cur_chan)->nvifs - 1);
  
#line 1324 
  sc->tx99_vif = (struct ieee80211_vif *)0;
  
#line 1325 
  tmp_0 = ath9k_is_chanctx_enabled();
  
#line 1325 
  if (tmp_0) 
#line 1325 
             tmp_1 = 0; else 
#line 1325 
                             tmp_1 = 1;
  
#line 1325 
  if (tmp_1) 
#line 1326 
             list_del(& avp->list); else ;
  
#line 1328 
  tmp_2 = ath9k_uses_beacons((int)vif->type);
  
#line 1328 
  if ((int)tmp_2 != 0) 
#line 1329 
                       ath9k_beacon_remove_slot(sc,vif); else ;
  
#line 1331 
  ath_tx_node_cleanup(sc,& avp->mcast_node);
  
#line 1333 
  ath9k_calculate_summary_state(sc,avp->chanctx);
  
#line 1335 
  ath9k_set_txpower(sc,(struct ieee80211_vif *)0);
  
#line 1337 
  ldv_mutex_unlock_126(& sc->mutex);
  
#line 1338 
  return;
}


#line 1340  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath9k_enable_ps(struct ath_softc *sc)
{
  
#line 1342 
  struct ath_hw *ah = sc->sc_ah;
  
#line 1343 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 1346 
  goto return_label;
  
#line 1348 
  sc->ps_enabled = (_Bool)1;
  
#line 1349 
  if ((ah->caps.hw_caps & 4U) == 0U) {
    
#line 1350 
    if (((unsigned int)ah->imask & 256U) == 0U) {
      
#line 1351 
      ah->imask = (enum ath9k_int)((unsigned int)ah->imask | 256U);
      
#line 1352 
      ath9k_hw_set_interrupts(ah);
    }
    else ;
    
#line 1354 
    ath9k_hw_setrxabort(ah,(_Bool)1);
  }
  else ;
  
#line 1356 
  if ((common->debug_mask & 2048) != 0) 
#line 1356 
                                        ath_printk("\001",(struct ath_common const *)common,"PowerSave enabled\n"); else ;
  return_label: 
#line 1356 
                return;
}


#line 1359  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath9k_disable_ps(struct ath_softc *sc)
{
  
#line 1361 
  struct ath_hw *ah = sc->sc_ah;
  
#line 1362 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 1365 
  goto return_label;
  
#line 1367 
  sc->ps_enabled = (_Bool)0;
  
#line 1368 
  ath9k_hw_setpower(ah,(enum ath9k_power_mode)ATH9K_PM_AWAKE);
  
#line 1369 
  if ((ah->caps.hw_caps & 4U) == 0U) {
    
#line 1370 
    ath9k_hw_setrxabort(ah,(_Bool)0);
    
#line 1371 
    sc->ps_flags = (unsigned short)((unsigned int)sc->ps_flags & 65520U);
    
#line 1375 
    if (((unsigned int)ah->imask & 256U) != 0U) {
      
#line 1376 
      ah->imask = (enum ath9k_int)((unsigned int)ah->imask & 4294967039U);
      
#line 1377 
      ath9k_hw_set_interrupts(ah);
    }
    else ;
  }
  else ;
  
#line 1380 
  if ((common->debug_mask & 2048) != 0) 
#line 1380 
                                        ath_printk("\001",(struct ath_common const *)common,"PowerSave disabled\n"); else ;
  return_label: 
#line 1380 
                return;
}


#line 1383  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static int ath9k_config(struct ieee80211_hw *hw, u32 changed)
{
  int __retres;
  int tmp_1;
  bool tmp_0;
  
#line 1385 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 1386 
  struct ath_hw *ah = sc->sc_ah;
  
#line 1387 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 1388 
  struct ieee80211_conf *conf = & hw->conf;
  
#line 1389 
  struct ath_chanctx *ctx = sc->cur_chan;
  
#line 1391 
  ath9k_ps_wakeup(sc);
  
#line 1392 
  ldv_mutex_lock_127(& sc->mutex);
  
#line 1394 
  if ((changed & 256U) != 0U) {
    
#line 1395 
    sc->ps_idle = (_Bool)((conf->flags & 4U) != 0U);
    
#line 1396 
    if ((int)sc->ps_idle != 0) {
      
#line 1397 
      ath_cancel_work(sc);
      
#line 1398 
      ath9k_stop_btcoex(sc);
    }
    else {
      
#line 1400 
      ath9k_start_btcoex(sc);
      
#line 1405 
      ath_chanctx_set_channel(sc,ctx,& ctx->chandef);
    }
  }
  else ;
  
#line 1415 
  if ((changed & 16U) != 0U) {
    unsigned long flags;
    
#line 1417 
    ldv___ldv_spin_lock_128(& sc->sc_pm_lock);
    
#line 1418 
    if ((conf->flags & 2U) != 0U) 
#line 1419 
                                  ath9k_enable_ps(sc); else 
#line 1421 
                                                            ath9k_disable_ps(sc);
    
#line 1422 
    ldv_spin_unlock_irqrestore_129(& sc->sc_pm_lock,flags);
  }
  else ;
  
#line 1425 
  if ((changed & 8U) != 0U) 
    
#line 1426 
    if ((conf->flags & 1U) != 0U) {
      
#line 1427 
      if ((common->debug_mask & 512) != 0) 
#line 1427 
                                           ath_printk("\001",(struct ath_common const *)common,"Monitor mode is enabled\n"); else ;
      
#line 1428 
      (sc->sc_ah)->is_monitoring = (_Bool)1;
    }
    else {
      
#line 1430 
      if ((common->debug_mask & 512) != 0) 
#line 1430 
                                           ath_printk("\001",(struct ath_common const *)common,"Monitor mode is disabled\n"); else ;
      
#line 1431 
      (sc->sc_ah)->is_monitoring = (_Bool)0;
    }
  else ;
  
#line 1435 
  tmp_0 = ath9k_is_chanctx_enabled();
  
#line 1435 
  if (tmp_0) 
#line 1435 
             tmp_1 = 0; else 
#line 1435 
                             tmp_1 = 1;
  
#line 1435 
  if (tmp_1) {
    
#line 1435 
    if ((changed & 64U) != 0U) {
      
#line 1436 
      ctx->offchannel = (_Bool)((conf->flags & 8U) != 0U);
      
#line 1437 
      ath_chanctx_set_channel(sc,ctx,& hw->conf.chandef);
    }
    else ;
  }
  else ;
  
#line 1440 
  ldv_mutex_unlock_130(& sc->mutex);
  
#line 1441 
  ath9k_ps_restore(sc);
  
#line 1443 
  __retres = 0;
  
#line 1443 
  return __retres;
}


#line 1456  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath9k_configure_filter(struct ieee80211_hw *hw, unsigned int changed_flags, unsigned int *total_flags, u64 multicast)
{
  u32 rfilt;
  struct ath_common *tmp_0;
  
#line 1461 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 1464 
  changed_flags &= 502U;
  
#line 1465 
  *total_flags &= 502U;
  
#line 1467 
  ldv_spin_lock_bh_131(& sc->chan_lock);
  
#line 1468 
  (sc->cur_chan)->rxfilter = *total_flags;
  
#line 1469 
  ldv_spin_unlock_bh_132(& sc->chan_lock);
  
#line 1471 
  ath9k_ps_wakeup(sc);
  
#line 1472 
  rfilt = ath_calcrxfilter(sc);
  
#line 1473 
  ath9k_hw_setrxfilter(sc->sc_ah,rfilt);
  
#line 1474 
  ath9k_ps_restore(sc);
  
#line 1476 
  tmp_0 = ath9k_hw_common(sc->sc_ah);
  
#line 1476 
  ;
  
#line 1476 
  if ((tmp_0->debug_mask & 512) != 0) {
    struct ath_common *tmp;
    
#line 1476 
    ;
    
#line 1476 
    tmp = ath9k_hw_common(sc->sc_ah);
    
#line 1476 
    ath_printk("\001",(struct ath_common const *)tmp,"Set HW RX filter: 0x%x\n",rfilt);
  }
  else ;
  
#line 1477 
  return;
}


#line 1480  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static int ath9k_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif, struct ieee80211_sta *sta)
{
  int __retres;
  int key;
  
#line 1484 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 1485 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 1486 
  struct ath_node *an = (struct ath_node *)(& sta->drv_priv);
  
#line 1487 
  struct ieee80211_key_conf ps_key = {.tx_pn = {.counter = 0L}, .cipher = 0U, .icv_len = (unsigned char)0, .iv_len = (unsigned char)0, .hw_key_idx = (unsigned char)0, .flags = (unsigned char)0, .keyidx = (signed char)0, .keylen = (unsigned char)0, .key = {}};
  
#line 1490 
  ath_node_attach(sc,sta,vif);
  
#line 1492 
  if ((unsigned int)vif->type + 4294967293U > 1U) {
    
#line 1494 
    __retres = 0;
    
#line 1494 
    goto return_label;
  }
  else ;
  
#line 1496 
  key = ath_key_config(common,vif,sta,& ps_key);
  
#line 1497 
  if (key > 0) {
    
#line 1498 
    an->ps_key = (signed char)key;
    
#line 1499 
    an->key_idx[0] = (unsigned char)key;
  }
  else ;
  
#line 1502 
  __retres = 0;
  return_label: 
#line 1502 
                return __retres;
}


#line 1505  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath9k_del_ps_key(struct ath_softc *sc, struct ieee80211_vif *vif, struct ieee80211_sta *sta)
{
  
#line 1509 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 1510 
  struct ath_node *an = (struct ath_node *)(& sta->drv_priv);
  
#line 1511 
  struct ieee80211_key_conf ps_key = {.tx_pn = {.counter = 0L}, .cipher = 0U, .icv_len = (unsigned char)0, .iv_len = (unsigned char)0, .hw_key_idx = (unsigned char)an->ps_key, .flags = (unsigned char)0, .keyidx = (signed char)0, .keylen = (unsigned char)0, .key = {}};
  
#line 1513 
  if ((int)an->ps_key == 0) 
#line 1514 
                            goto return_label; else ;
  
#line 1516 
  ath_key_delete(common,& ps_key);
  
#line 1517 
  an->ps_key = (signed char)0;
  
#line 1518 
  an->key_idx[0] = (unsigned char)0U;
  return_label: 
#line 1519 
                return;
}


#line 1521  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static int ath9k_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif, struct ieee80211_sta *sta)
{
  int __retres;
  
#line 1525 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 1527 
  ath9k_del_ps_key(sc,vif,sta);
  
#line 1528 
  ath_node_detach(sc,sta);
  
#line 1530 
  __retres = 0;
  
#line 1530 
  return __retres;
}


#line 1533  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static int ath9k_sta_state(struct ieee80211_hw *hw, struct ieee80211_vif *vif, struct ieee80211_sta *sta, enum ieee80211_sta_state old_state, enum ieee80211_sta_state new_state)
{
  bool tmp_0;
  
#line 1539 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 1540 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 1541 
  int ret = 0;
  
#line 1543 
  if (old_state == (unsigned int)IEEE80211_STA_AUTH && new_state == (unsigned int)IEEE80211_STA_ASSOC) {
    
#line 1545 
    ret = ath9k_sta_add(hw,vif,sta);
    
#line 1546 
    if ((common->debug_mask & 512) != 0) 
#line 1546 
                                         ath_printk("\001",(struct ath_common const *)common,"Add station: %pM\n",(u8 *)(& sta->addr)); else ;
  }
  else 
    
#line 1548 
    if (old_state == (unsigned int)IEEE80211_STA_ASSOC && new_state == (unsigned int)IEEE80211_STA_AUTH) {
      
#line 1550 
      ret = ath9k_sta_remove(hw,vif,sta);
      
#line 1551 
      if ((common->debug_mask & 512) != 0) 
#line 1551 
                                           ath_printk("\001",(struct ath_common const *)common,"Remove station: %pM\n",(u8 *)(& sta->addr)); else ;
    }
    else ;
  
#line 1555 
  tmp_0 = ath9k_is_chanctx_enabled();
  
#line 1555 
  if ((int)tmp_0 != 0) {
    
#line 1556 
    if (vif->type == (unsigned int)NL80211_IFTYPE_STATION) {
      
#line 1557 
      if (old_state == (unsigned int)IEEE80211_STA_ASSOC && new_state == (unsigned int)IEEE80211_STA_AUTHORIZED) 
        
#line 1559 
        ath_chanctx_event(sc,vif,(enum ath_chanctx_event)ATH_CHANCTX_EVENT_AUTHORIZED); else ;
    }
    else ;
  }
  else ;
  
#line 1564 
  return ret;
}


#line 1567  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath9k_sta_set_tx_filter(struct ath_hw *ah, struct ath_node *an, bool set)
{
  int i;
  
#line 1573 
  i = 0;
  
#line 1573 
  goto ldv_54268;
  ldv_54267: 
#line 1574 
  ;
  
#line 1574 
  if ((unsigned int)an->key_idx[i] == 0U) 
#line 1575 
                                          goto ldv_54266; else ;
  
#line 1576 
  ath9k_hw_set_tx_filter(ah,(unsigned char)((int)an->key_idx[i]),(_Bool)((bool)((int)set) != 0));
  ldv_54266: 
#line 1577 
  ;
  
#line 1573 
  i += 1;
  ldv_54268: 
#line 1574 
  ;
  
#line 1573 
  if ((unsigned int)i <= 3U) 
#line 1575 
                             goto ldv_54267; else 
#line 1578 
                                                  goto ldv_54269;
  ldv_54269: 
#line 1579 
  ;
  
#line 1580 
  return;
}


#line 1580  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath9k_sta_notify(struct ieee80211_hw *hw, struct ieee80211_vif *vif, enum sta_notify_cmd cmd, struct ieee80211_sta *sta)
{
  
#line 1585 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 1586 
  struct ath_node *an = (struct ath_node *)(& sta->drv_priv);
  
#line 1588 
  switch ((unsigned int)cmd) {
    case (unsigned int)0: 
#line 1589 
    ;
    
#line 1590 
    an->sleeping = (_Bool)1;
    
#line 1591 
    ath_tx_aggr_sleep(sta,sc,an);
    
#line 1592 
    ath9k_sta_set_tx_filter(sc->sc_ah,an,(_Bool)1);
    
#line 1593 
    goto ldv_54279;
    case (unsigned int)1: 
#line 1594 
    ;
    
#line 1595 
    ath9k_sta_set_tx_filter(sc->sc_ah,an,(_Bool)0);
    
#line 1596 
    an->sleeping = (_Bool)0;
    
#line 1597 
    ath_tx_aggr_wakeup(sc,an);
    
#line 1598 
    goto ldv_54279;
  }
  ldv_54279: 
#line 1600 
  ;
  
#line 1601 
  return;
}


#line 1602  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static int ath9k_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif, u16 queue, struct ieee80211_tx_queue_params const *params)
{
  int __retres;
  struct ath_txq *txq;
  struct ath9k_tx_queue_info qi;
  
#line 1606 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 1607 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 1610 
  int ret = 0;
  
#line 1612 
  if ((unsigned int)queue > 3U) {
    
#line 1613 
    __retres = 0;
    
#line 1613 
    goto return_label;
  }
  else ;
  
#line 1615 
  txq = sc->tx.txq_map[(int)queue];
  
#line 1617 
  ath9k_ps_wakeup(sc);
  
#line 1618 
  ldv_mutex_lock_133(& sc->mutex);
  
#line 1620 
  memset((void *)(& qi),0,60UL);
  
#line 1622 
  qi.tqi_aifs = (unsigned int)params->aifs;
  
#line 1623 
  qi.tqi_cwmin = (unsigned int)params->cw_min;
  
#line 1624 
  qi.tqi_cwmax = (unsigned int)params->cw_max;
  
#line 1625 
  qi.tqi_burstTime = (unsigned int)((int)params->txop * 32);
  
#line 1627 
  if ((common->debug_mask & 512) != 0) 
#line 1627 
                                       ath_printk("\001",(struct ath_common const *)common,"Configure tx [queue/halq] [%d/%d], aifs: %d, cw_min: %d, cw_max: %d, txop: %d\n",(int)queue,txq->axq_qnum,(int)params->aifs,(int)params->cw_min,(int)params->cw_max,(int)params->txop); else ;
  
#line 1632 
  ath_update_max_aggr_framelen(sc,(int)queue,(int)qi.tqi_burstTime);
  
#line 1633 
  ret = ath_txq_update(sc,(int)txq->axq_qnum,& qi);
  
#line 1634 
  if (ret != 0) 
#line 1635 
                ath_printk("\001",(struct ath_common const *)common,"TXQ Update failed\n"); else ;
  
#line 1637 
  ldv_mutex_unlock_134(& sc->mutex);
  
#line 1638 
  ath9k_ps_restore(sc);
  
#line 1640 
  __retres = ret;
  return_label: 
#line 1640 
                return __retres;
}


#line 1643  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static int ath9k_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd, struct ieee80211_vif *vif, struct ieee80211_sta *sta, struct ieee80211_key_conf *key)
{
  int __retres;
  int i;
  
#line 1649 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 1650 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 1651 
  struct ath_node *an = (struct ath_node *)0;
  
#line 1652 
  int ret = 0;
  
#line 1654 
  if (ath9k_modparam_nohwcrypt != 0) {
    
#line 1655 
    __retres = -28;
    
#line 1655 
    goto return_label;
  }
  else ;
  
#line 1657 
  if (((vif->type == (unsigned int)NL80211_IFTYPE_ADHOC || vif->type == (unsigned int)NL80211_IFTYPE_MESH_POINT) && (key->cipher == 1027074U || key->cipher == 1027076U)) && ((int)key->flags & 8) == 0) {
    
#line 1669 
    __retres = -95;
    
#line 1669 
    goto return_label;
  }
  else ;
  
#line 1672 
  ldv_mutex_lock_135(& sc->mutex);
  
#line 1673 
  ath9k_ps_wakeup(sc);
  
#line 1674 
  if ((common->debug_mask & 512) != 0) 
#line 1674 
                                       ath_printk("\001",(struct ath_common const *)common,"Set HW Key %d\n",(unsigned int)cmd); else ;
  
#line 1675 
  if (sta != (struct ieee80211_sta *)0) 
#line 1676 
                                        an = (struct ath_node *)(& sta->drv_priv); else ;
  
#line 1678 
  switch ((unsigned int)cmd) {
    case (unsigned int)0: 
#line 1679 
    ;
    
#line 1680 
    if (sta != (struct ieee80211_sta *)0) 
#line 1681 
                                          ath9k_del_ps_key(sc,vif,sta); else ;
    
#line 1683 
    key->hw_key_idx = (unsigned char)0U;
    
#line 1684 
    ret = ath_key_config(common,vif,sta,key);
    
#line 1685 
    if (ret >= 0) {
      
#line 1686 
      key->hw_key_idx = (unsigned char)ret;
      
#line 1688 
      key->flags = (unsigned char)((unsigned int)key->flags | 2U);
      
#line 1689 
      if (key->cipher == 1027074U) 
#line 1690 
                                   key->flags = (unsigned char)((unsigned int)key->flags | 4U); else ;
      
#line 1691 
      if ((int)(sc->sc_ah)->sw_mgmt_crypto_tx != 0 && key->cipher == 1027076U) 
        
#line 1693 
        key->flags = (unsigned char)((unsigned int)key->flags | 16U); else ;
      
#line 1694 
      ret = 0;
    }
    else ;
    
#line 1696 
    if (an != (struct ath_node *)0 && (unsigned int)key->hw_key_idx != 0U) {
      
#line 1697 
      i = 0;
      
#line 1697 
      goto ldv_54311;
      ldv_54310: 
#line 1698 
      ;
      
#line 1698 
      if ((unsigned int)an->key_idx[i] != 0U) 
#line 1699 
                                              goto ldv_54308; else ;
      
#line 1700 
      an->key_idx[i] = key->hw_key_idx;
      
#line 1701 
      goto ldv_54309;
      ldv_54308: 
#line 1702 
      ;
      
#line 1697 
      i += 1;
      ldv_54311: 
#line 1698 
      ;
      
#line 1697 
      if ((unsigned int)i <= 3U) 
#line 1699 
                                 goto ldv_54310; else 
#line 1702 
                                                      goto ldv_54309;
      ldv_54309: 
#line 1703 
      ;
      {
        
#line 1703 
        int __ret_warn_on = i == 4;
        
#line 1703 
        if ((long)(__ret_warn_on != 0) != 0L) 
#line 1703 
                                              warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c",1703); else ;
        
#line 1703 
        long tmp_2 = (long)(__ret_warn_on != 0);
      }
    }
    else ;
    
#line 1705 
    goto ldv_54317;
    case (unsigned int)1: 
#line 1706 
    ;
    
#line 1707 
    ath_key_delete(common,key);
    
#line 1708 
    if (an != (struct ath_node *)0) {
      
#line 1709 
      i = 0;
      
#line 1709 
      goto ldv_54325;
      ldv_54324: 
#line 1710 
      ;
      
#line 1710 
      if ((int)an->key_idx[i] != (int)key->hw_key_idx) 
#line 1711 
                                                       goto ldv_54322; else ;
      
#line 1712 
      an->key_idx[i] = (unsigned char)0U;
      
#line 1713 
      goto ldv_54323;
      ldv_54322: 
#line 1714 
      ;
      
#line 1709 
      i += 1;
      ldv_54325: 
#line 1710 
      ;
      
#line 1709 
      if ((unsigned int)i <= 3U) 
#line 1711 
                                 goto ldv_54324; else 
#line 1714 
                                                      goto ldv_54323;
      ldv_54323: 
#line 1715 
      ;
    }
    else ;
    
#line 1716 
    key->hw_key_idx = (unsigned char)0U;
    
#line 1717 
    goto ldv_54317;
    default: 
#line 1718 
    ;
    
#line 1719 
    ret = -22;
  }
  ldv_54317: 
#line 1722 
  ;
  
#line 1722 
  ath9k_ps_restore(sc);
  
#line 1723 
  ldv_mutex_unlock_136(& sc->mutex);
  
#line 1725 
  __retres = ret;
  return_label: 
#line 1725 
                return __retres;
}


#line 1728  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath9k_bss_info_changed(struct ieee80211_hw *hw, struct ieee80211_vif *vif, struct ieee80211_bss_conf *bss_conf, u32 changed)
{
  int slottime;
  
#line 1738 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 1739 
  struct ath_hw *ah = sc->sc_ah;
  
#line 1740 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 1741 
  struct ath_vif *avp = (struct ath_vif *)(& vif->drv_priv);
  
#line 1744 
  ath9k_ps_wakeup(sc);
  
#line 1745 
  ldv_mutex_lock_137(& sc->mutex);
  
#line 1747 
  if ((changed & 1U) != 0U) {
    
#line 1748 
    if ((common->debug_mask & 512) != 0) 
#line 1748 
                                         ath_printk("\001",(struct ath_common const *)common,"BSSID %pM Changed ASSOC %d\n",bss_conf->bssid,(int)bss_conf->assoc); else ;
    
#line 1751 
    memcpy((void *)(& avp->bssid),(void const *)bss_conf->bssid,6UL);
    
#line 1752 
    avp->aid = bss_conf->aid;
    
#line 1753 
    avp->assoc = bss_conf->assoc;
    
#line 1755 
    ath9k_calculate_summary_state(sc,avp->chanctx);
  }
  else ;
  
#line 1758 
  if ((changed & 2048U) != 0U) {
    
#line 1759 
    memcpy((void *)(& common->curbssid),(void const *)bss_conf->bssid,6UL);
    
#line 1760 
    common->curaid = bss_conf->aid;
    
#line 1761 
    ath9k_hw_write_associd(sc->sc_ah);
  }
  else ;
  
#line 1764 
  if (((changed & 512U) != 0U || (changed & 64U) != 0U) || (changed & 1048576U) != 0U) {
    
#line 1767 
    ath9k_beacon_config(sc,vif,changed);
    
#line 1768 
    if ((changed & 512U) != 0U) 
#line 1769 
                                ath9k_calculate_summary_state(sc,avp->chanctx); else ;
  }
  else ;
  
#line 1772 
  if (avp->chanctx == sc->cur_chan && (changed & 8U) != 0U) {
    
#line 1774 
    if ((int)bss_conf->use_short_slot != 0) 
#line 1775 
                                            slottime = 9; else 
#line 1777 
                                                               slottime = 20;
    
#line 1778 
    if (vif->type == (unsigned int)NL80211_IFTYPE_AP) {
      
#line 1784 
      sc->beacon.slottime = slottime;
      
#line 1785 
      sc->beacon.updateslot = UPDATE;
    }
    else {
      
#line 1787 
      ah->slottime = (unsigned int)slottime;
      
#line 1788 
      ath9k_hw_init_global_settings(ah);
    }
  }
  else ;
  
#line 1792 
  if ((changed & 524288U) != 0U) 
#line 1793 
                                 ath9k_p2p_bss_info_changed(sc,vif); else ;
  
#line 1795 
  if ((changed & 2561U) != 0U) 
#line 1796 
                               ath_check_ani(sc); else ;
  
#line 1798 
  if ((changed & 262144U) != 0U) {
    
#line 1799 
    if ((common->debug_mask & 512) != 0) 
#line 1799 
                                         ath_printk("\001",(struct ath_common const *)common,"vif %pM power %d dbm power_type %d\n",(u8 *)(& vif->addr),bss_conf->txpower,(unsigned int)bss_conf->txpower_type); else ;
    
#line 1801 
    ath9k_set_txpower(sc,vif);
  }
  else ;
  
#line 1804 
  ldv_mutex_unlock_138(& sc->mutex);
  
#line 1805 
  ath9k_ps_restore(sc);
  
#line 1806 
  return;
}


#line 1810  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static u64 ath9k_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
{
  u64 tsf;
  
#line 1812 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 1815 
  ldv_mutex_lock_139(& sc->mutex);
  
#line 1816 
  ath9k_ps_wakeup(sc);
  
#line 1817 
  tsf = ath9k_hw_gettsf64(sc->sc_ah);
  
#line 1818 
  ath9k_ps_restore(sc);
  
#line 1819 
  ldv_mutex_unlock_140(& sc->mutex);
  
#line 1821 
  return tsf;
}


#line 1824  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath9k_set_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif, u64 tsf)
{
  
#line 1828 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 1830 
  ldv_mutex_lock_141(& sc->mutex);
  
#line 1831 
  ath9k_ps_wakeup(sc);
  
#line 1832 
  ath9k_hw_settsf64(sc->sc_ah,tsf);
  
#line 1833 
  ath9k_ps_restore(sc);
  
#line 1834 
  ldv_mutex_unlock_142(& sc->mutex);
  
#line 1835 
  return;
}


#line 1837  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath9k_reset_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
{
  
#line 1839 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 1841 
  ldv_mutex_lock_143(& sc->mutex);
  
#line 1843 
  ath9k_ps_wakeup(sc);
  
#line 1844 
  ath9k_hw_reset_tsf(sc->sc_ah);
  
#line 1845 
  ath9k_ps_restore(sc);
  
#line 1847 
  ldv_mutex_unlock_144(& sc->mutex);
  
#line 1848 
  return;
}


#line 1850  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static int ath9k_ampdu_action(struct ieee80211_hw *hw, struct ieee80211_vif *vif, enum ieee80211_ampdu_mlme_action action, struct ieee80211_sta *sta, u16 tid, u16 *ssn, u8 buf_size)
{
  
#line 1856 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 1857 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 1858 
  bool flush = (_Bool)0;
  
#line 1859 
  int ret = 0;
  
#line 1861 
  ldv_mutex_lock_145(& sc->mutex);
  
#line 1863 
  switch ((unsigned int)action) {
    bool tmp_1;
    struct ath_common *tmp_2;
    case (unsigned int)0: 
#line 1864 
    ;
    
#line 1865 
    goto ldv_54369;
    case (unsigned int)1: 
#line 1866 
    ;
    
#line 1867 
    goto ldv_54369;
    case (unsigned int)2: 
#line 1868 
    ;
    
#line 1869 
    tmp_1 = ath9k_is_chanctx_enabled();
    
#line 1869 
    if ((int)tmp_1 != 0) {
      int tmp_0;
      
#line 1870 
      tmp_0 = constant_test_bit(5L,(unsigned long const volatile *)(& common->op_flags));
      
#line 1870 
      if (tmp_0 != 0) {
        
#line 1871 
        ret = -16;
        
#line 1872 
        goto ldv_54369;
      }
      else ;
    }
    else ;
    
#line 1875 
    ath9k_ps_wakeup(sc);
    
#line 1876 
    ret = ath_tx_aggr_start(sc,sta,(unsigned short)((int)tid),ssn);
    
#line 1877 
    if (ret == 0) 
#line 1878 
                  ieee80211_start_tx_ba_cb_irqsafe(vif,(u8 const *)(& sta->addr),(unsigned short)((int)tid)); else ;
    
#line 1879 
    ath9k_ps_restore(sc);
    
#line 1880 
    goto ldv_54369;
    case (unsigned int)4: 
#line 1881 
    ;
    case (unsigned int)5: 
#line 1882 
    ;
    
#line 1883 
    flush = (_Bool)1;
    case (unsigned int)3: 
#line 1884 
    ;
    
#line 1885 
    ath9k_ps_wakeup(sc);
    
#line 1886 
    ath_tx_aggr_stop(sc,sta,(unsigned short)((int)tid));
    
#line 1887 
    if (! flush) 
#line 1888 
                 ieee80211_stop_tx_ba_cb_irqsafe(vif,(u8 const *)(& sta->addr),(unsigned short)((int)tid)); else ;
    
#line 1889 
    ath9k_ps_restore(sc);
    
#line 1890 
    goto ldv_54369;
    case (unsigned int)6: 
#line 1891 
    ;
    
#line 1892 
    ath9k_ps_wakeup(sc);
    
#line 1893 
    ath_tx_aggr_resume(sc,sta,(unsigned short)((int)tid));
    
#line 1894 
    ath9k_ps_restore(sc);
    
#line 1895 
    goto ldv_54369;
    default: 
#line 1896 
    ;
    
#line 1897 
    tmp_2 = ath9k_hw_common(sc->sc_ah);
    
#line 1897 
    ath_printk("\001",(struct ath_common const *)tmp_2,"Unknown AMPDU action\n");
  }
  ldv_54369: 
#line 1900 
  ;
  
#line 1900 
  ldv_mutex_unlock_146(& sc->mutex);
  
#line 1902 
  return ret;
}


#line 1905  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static int ath9k_get_survey(struct ieee80211_hw *hw, int idx, struct survey_info *survey)
{
  int __retres;
  struct ieee80211_supported_band *sband;
  struct ieee80211_channel *chan;
  int pos;
  
#line 1908 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 1909 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 1915 
  __retres = -95;
  
#line 1915 
  goto return_label;
  
#line 1917 
  ldv_spin_lock_bh_147(& common->cc_lock);
  
#line 1918 
  if (idx == 0) 
#line 1919 
                ath_update_survey_stats(sc); else ;
  
#line 1921 
  sband = (hw->wiphy)->bands[0];
  
#line 1922 
  if (sband != (struct ieee80211_supported_band *)0 && sband->n_channels <= idx) {
    
#line 1923 
    idx -= sband->n_channels;
    
#line 1924 
    sband = (struct ieee80211_supported_band *)0;
  }
  else ;
  
#line 1927 
  if (sband == (struct ieee80211_supported_band *)0) 
#line 1928 
                                                     sband = (hw->wiphy)->bands[1]; else ;
  
#line 1930 
  if (sband == (struct ieee80211_supported_band *)0 || sband->n_channels <= idx) {
    
#line 1931 
    ldv_spin_unlock_bh_148(& common->cc_lock);
    
#line 1932 
    __retres = -2;
    
#line 1932 
    goto return_label;
  }
  else ;
  
#line 1935 
  chan = sband->channels + idx;
  
#line 1936 
  pos = (int)chan->hw_value;
  
#line 1937 
  memcpy((void *)survey,(void const *)(& sc->survey[pos]),64UL);
  
#line 1938 
  survey->channel = chan;
  
#line 1939 
  ldv_spin_unlock_bh_149(& common->cc_lock);
  
#line 1941 
  __retres = 0;
  return_label: 
#line 1941 
                return __retres;
}


#line 1944  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath9k_enable_dynack(struct ath_softc *sc)
{
  u32 rfilt;
  
#line 1948 
  struct ath_hw *ah = sc->sc_ah;
  
#line 1950 
  ath_dynack_reset(ah);
  
#line 1952 
  ah->dynack.enabled = (_Bool)1;
  
#line 1953 
  rfilt = ath_calcrxfilter(sc);
  
#line 1954 
  ath9k_hw_setrxfilter(ah,rfilt);
  
#line 1955 
  return;
}


#line 1958  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath9k_set_coverage_class(struct ieee80211_hw *hw, s16 coverage_class)
{
  
#line 1961 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 1962 
  struct ath_hw *ah = sc->sc_ah;
  
#line 1965 
  goto return_label;
  
#line 1967 
  ldv_mutex_lock_150(& sc->mutex);
  
#line 1969 
  if ((int)coverage_class >= 0) {
    
#line 1970 
    ah->coverage_class = (int)coverage_class;
    
#line 1971 
    if ((int)ah->dynack.enabled != 0) {
      u32 rfilt;
      
#line 1974 
      ah->dynack.enabled = (_Bool)0;
      
#line 1975 
      rfilt = ath_calcrxfilter(sc);
      
#line 1976 
      ath9k_hw_setrxfilter(ah,rfilt);
    }
    else ;
    
#line 1978 
    ath9k_ps_wakeup(sc);
    
#line 1979 
    ath9k_hw_init_global_settings(ah);
    
#line 1980 
    ath9k_ps_restore(sc);
  }
  else 
    
#line 1981 
    if (! ah->dynack.enabled) 
#line 1982 
                              ath9k_enable_dynack(sc); else ;
  
#line 1985 
  ldv_mutex_unlock_151(& sc->mutex);
  return_label: 
#line 1985 
                return;
}


#line 1988  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static bool ath9k_has_tx_pending(struct ath_softc *sc, bool sw_pending)
{
  bool __retres;
  int i;
  bool tmp;
  
#line 1991 
  int npend = 0;
  
#line 1993 
  i = 0;
  
#line 1993 
  goto ldv_54408;
  ldv_54407: 
#line 1994 
  ;
  
#line 1994 
  if ((sc->tx.txqsetup & (unsigned int)(1 << i)) == 0U) 
#line 1995 
                                                        goto ldv_54405; else ;
  
#line 1997 
  tmp = ath9k_has_pending_frames(sc,& sc->tx.txq[i],(_Bool)((bool)((int)sw_pending) != 0));
  
#line 1997 
  npend = (int)tmp;
  
#line 1999 
  if (npend != 0) 
#line 2000 
                  goto ldv_54406; else ;
  ldv_54405: 
#line 2001 
  ;
  
#line 1993 
  i += 1;
  ldv_54408: 
#line 1994 
  ;
  
#line 1993 
  if (i <= 9) 
#line 1995 
              goto ldv_54407; else 
#line 1998 
                                   goto ldv_54406;
  ldv_54406: 
#line 1999 
  ;
  
#line 2003 
  __retres = (_Bool)(npend != 0);
  
#line 2003 
  return __retres;
}


#line 2006  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath9k_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif, u32 queues, bool drop)
{
  bool tmp_1;
  
#line 2009 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 2010 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 2012 
  tmp_1 = ath9k_is_chanctx_enabled();
  
#line 2012 
  if ((int)tmp_1 != 0) {
    int tmp_0;
    
#line 2013 
    tmp_0 = constant_test_bit(6L,(unsigned long const volatile *)(& common->op_flags));
    
#line 2013 
    if (tmp_0 == 0) 
#line 2014 
                    goto flush; else ;
    
#line 2026 
    __ath9k_flush(hw,queues,(_Bool)((bool)((int)drop) != 0),(_Bool)1,(_Bool)1);
    
#line 2027 
    goto return_label;
  }
  else ;
  flush: 
#line 2029 
  ;
  
#line 2030 
  ldv_mutex_lock_152(& sc->mutex);
  
#line 2031 
  __ath9k_flush(hw,queues,(_Bool)((bool)((int)drop) != 0),(_Bool)1,(_Bool)0);
  
#line 2032 
  ldv_mutex_unlock_153(& sc->mutex);
  return_label: 
#line 2033 
                return;
}


#line 2035  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
void __ath9k_flush(struct ieee80211_hw *hw, u32 queues, bool drop, bool sw_pending, bool timeout_override)
{
  int timeout;
  bool drain_txq;
  int tmp_0;
  long tmp_10;
  
#line 2038 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 2039 
  struct ath_hw *ah = sc->sc_ah;
  
#line 2040 
  struct ath_common *common = ath9k_hw_common(ah);
  
#line 2044 
  cancel_delayed_work_sync(& sc->tx_complete_work);
  
#line 2046 
  if ((ah->ah_flags & 2U) != 0U) {
    
#line 2047 
    if (common->debug_mask != 0) 
#line 2047 
                                 ath_printk("\001",(struct ath_common const *)common,"Device has been unplugged!\n"); else ;
    
#line 2048 
    goto return_label;
  }
  else ;
  
#line 2051 
  tmp_0 = constant_test_bit(0L,(unsigned long const volatile *)(& common->op_flags));
  
#line 2051 
  if (tmp_0 != 0) {
    
#line 2052 
    if (common->debug_mask != 0) 
#line 2052 
                                 ath_printk("\001",(struct ath_common const *)common,"Device not present\n"); else ;
    
#line 2053 
    goto return_label;
  }
  else ;
  
#line 2056 
  ldv_spin_lock_bh_154(& sc->chan_lock);
  
#line 2057 
  if ((int)timeout_override != 0) 
#line 2058 
                                  timeout = 50; else 
#line 2060 
                                                     timeout = (sc->cur_chan)->flush_timeout;
  
#line 2061 
  ldv_spin_unlock_bh_155(& sc->chan_lock);
  
#line 2063 
  if ((common->debug_mask & 262144) != 0) {
    unsigned int tmp_1;
    
#line 2063 
    tmp_1 = jiffies_to_msecs((unsigned long)timeout);
    
#line 2063 
    ;
    
#line 2063 
    ath_printk("\001",(struct ath_common const *)common,"Flush timeout: %d\n",tmp_1);
  }
  else ;
  {
    
#line 2066 
    long __ret = (long)timeout;
    
#line 2066 
    __might_sleep("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c",2067,0);
    {
      int tmp_9;
      {
        int tmp_8;
        bool tmp_7;
        
#line 2066 
        tmp_7 = ath9k_has_tx_pending(sc,(_Bool)((bool)((int)sw_pending) != 0));
        
#line 2066 
        if ((int)tmp_7 != 0) 
#line 2066 
                             tmp_8 = 0; else 
#line 2066 
                                             tmp_8 = 1;
        
#line 2066 
        bool __cond_0 = (_Bool)(tmp_8 != 0);
        
#line 2066 
        if ((int)__cond_0 != 0 && __ret == 0L) 
#line 2066 
                                               __ret = 1L; else ;
        
#line 2066 
        tmp_9 = ((int)__cond_0 != 0 || __ret == 0L) != 0;
      }
      
#line 2066 
      if (tmp_9 == 0) {
        long tmp_6;
        {
          wait_queue_t __wait;
          
#line 2066 
          long __ret_0 = (long)timeout;
          
#line 2066 
          INIT_LIST_HEAD(& __wait.task_list);
          
#line 2066 
          __wait.flags = 0U;
          ldv_54440: 
#line 2069 
          ;
          {
            int tmp_5;
            
#line 2066 
            long __int = prepare_to_wait_event(& sc->tx_wait,& __wait,2);
            {
              int tmp_4;
              bool tmp_3;
              
#line 2066 
              tmp_3 = ath9k_has_tx_pending(sc,(_Bool)((bool)((int)sw_pending) != 0));
              
#line 2066 
              if ((int)tmp_3 != 0) 
#line 2066 
                                   tmp_4 = 0; else 
#line 2066 
                                                   tmp_4 = 1;
              
#line 2066 
              bool __cond = (_Bool)(tmp_4 != 0);
              
#line 2066 
              if ((int)__cond != 0 && __ret_0 == 0L) 
#line 2066 
                                                     __ret_0 = 1L; else ;
              
#line 2066 
              tmp_5 = ((int)__cond != 0 || __ret_0 == 0L) != 0;
            }
            
#line 2066 
            if (tmp_5 != 0) 
#line 2066 
                            goto ldv_54439; else ;
            
#line 2066 
            __ret_0 = schedule_timeout(__ret_0);
          }
          
#line 2066 
          goto ldv_54440;
          ldv_54439: 
#line 2067 
          ;
          
#line 2066 
          finish_wait(& sc->tx_wait,& __wait);
          __out_0: 
#line 2066 
          ;
          
#line 2066 
          tmp_6 = __ret_0;
        }
        
#line 2066 
        __ret = tmp_6;
      }
      else ;
    }
    
#line 2066 
    tmp_10 = __ret;
  }
  
#line 2066 
  if (tmp_10 > 0L) 
#line 2068 
                   drop = (_Bool)0; else ;
  
#line 2070 
  if ((int)drop != 0) {
    
#line 2071 
    ath9k_ps_wakeup(sc);
    
#line 2072 
    ldv_spin_lock_bh_156(& sc->sc_pcu_lock);
    
#line 2073 
    drain_txq = ath_drain_all_txq(sc);
    
#line 2074 
    ldv_spin_unlock_bh_157(& sc->sc_pcu_lock);
    
#line 2076 
    if (! drain_txq) 
#line 2077 
                     ath_reset(sc,(struct ath9k_channel *)0); else ;
    
#line 2079 
    ath9k_ps_restore(sc);
  }
  else ;
  
#line 2082 
  ieee80211_queue_delayed_work(hw,& sc->tx_complete_work,0UL);
  return_label: 
#line 2083 
                return;
}


#line 2085  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static bool ath9k_tx_frames_pending(struct ieee80211_hw *hw)
{
  bool tmp;
  
#line 2087 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 2089 
  tmp = ath9k_has_tx_pending(sc,(_Bool)1);
  
#line 2089 
  return tmp;
}


#line 2092  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static int ath9k_tx_last_beacon(struct ieee80211_hw *hw)
{
  int __retres;
  struct ieee80211_vif *vif;
  struct ath_vif *avp;
  struct ath_buf *bf;
  struct ath_tx_status ts;
  int status;
  
#line 2094 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 2095 
  struct ath_hw *ah = sc->sc_ah;
  
#line 2100 
  bool edma = (_Bool)((ah->caps.hw_caps & 16U) != 0U);
  
#line 2103 
  vif = sc->beacon.bslot[0];
  
#line 2104 
  if (vif == (struct ieee80211_vif *)0) {
    
#line 2105 
    __retres = 0;
    
#line 2105 
    goto return_label;
  }
  else ;
  
#line 2107 
  if (! vif->bss_conf.enable_beacon) {
    
#line 2108 
    __retres = 0;
    
#line 2108 
    goto return_label;
  }
  else ;
  
#line 2110 
  avp = (struct ath_vif *)(& vif->drv_priv);
  
#line 2112 
  if (! sc->beacon.tx_processed && ! edma) {
    
#line 2113 
    tasklet_disable_0(& sc->bcon_tasklet);
    
#line 2115 
    bf = avp->av_bcbuf;
    
#line 2116 
    if (bf == (struct ath_buf *)0 || bf->bf_mpdu == (struct sk_buff *)0) 
      
#line 2117 
      goto skip; else ;
    
#line 2119 
    status = ath9k_hw_txprocdesc(ah,bf->bf_desc,& ts);
    
#line 2120 
    if (status == -115) 
#line 2121 
                        goto skip; else ;
    
#line 2123 
    sc->beacon.tx_processed = (_Bool)1;
    
#line 2124 
    sc->beacon.tx_last = (_Bool)(((int)ts.ts_status & 95) == 0);
    skip: 
#line 2126 
    ;
    
#line 2127 
    tasklet_enable_0(& sc->bcon_tasklet);
  }
  else ;
  
#line 2130 
  __retres = (int)sc->beacon.tx_last;
  return_label: 
#line 2130 
                return __retres;
}


#line 2133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static int ath9k_get_stats(struct ieee80211_hw *hw, struct ieee80211_low_level_stats *stats)
{
  int __retres;
  
#line 2136 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 2137 
  struct ath_hw *ah = sc->sc_ah;
  
#line 2138 
  struct ath9k_mib_stats *mib_stats = & ah->stats.ast_mibstats;
  
#line 2140 
  stats->dot11ACKFailureCount = mib_stats->ackrcv_bad;
  
#line 2141 
  stats->dot11RTSFailureCount = mib_stats->rts_bad;
  
#line 2142 
  stats->dot11FCSErrorCount = mib_stats->fcs_bad;
  
#line 2143 
  stats->dot11RTSSuccessCount = mib_stats->rts_good;
  
#line 2144 
  __retres = 0;
  
#line 2144 
  return __retres;
}


#line 2147  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static u32 fill_chainmask(u32 cap, u32 new)
{
  int i;
  
#line 2149 
  u32 filled = 0U;
  
#line 2152 
  i = 0;
  
#line 2152 
  goto ldv_54474;
  ldv_54473: 
#line 2153 
  ;
  
#line 2153 
  if (((unsigned long)cap & 1UL) == 0UL) 
#line 2154 
                                         goto ldv_54472; else ;
  
#line 2156 
  if (((unsigned long)new & 1UL) != 0UL) 
#line 2157 
                                         filled = (unsigned int)(1UL << i) | filled; else ;
  
#line 2159 
  new >>= 1;
  ldv_54472: 
#line 2160 
  ;
  
#line 2152 
  i += 1;
  
#line 2152 
  cap >>= 1;
  ldv_54474: 
#line 2153 
  ;
  
#line 2152 
  if (cap != 0U && new != 0U) 
#line 2154 
                              goto ldv_54473; else 
#line 2157 
                                                   goto ldv_54475;
  ldv_54475: 
#line 2158 
  ;
  
#line 2162 
  return filled;
}


#line 2165  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static bool validate_antenna_mask(struct ath_hw *ah, u32 val)
{
  bool __retres;
  
#line 2167 
  if (ah->hw_version.macVersion > 447U) {
    
#line 2168 
    __retres = (_Bool)1;
    
#line 2168 
    goto return_label;
  }
  else ;
  
#line 2170 
  switch (val & 7U) {
    case (unsigned int)1: 
#line 2171 
    ;
    case (unsigned int)3: 
#line 2172 
    ;
    case (unsigned int)7: 
#line 2173 
    ;
    
#line 2174 
    __retres = (_Bool)1;
    
#line 2174 
    goto return_label;
    case (unsigned int)2: 
#line 2175 
    ;
    
#line 2176 
    __retres = (_Bool)((unsigned int)ah->caps.rx_chainmask == 1U);
    
#line 2176 
    goto return_label;
    default: 
#line 2177 
    ;
    
#line 2178 
    __retres = (_Bool)0;
    
#line 2178 
    goto return_label;
  }
  return_label: 
#line 2170 
                return __retres;
}


#line 2182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static int ath9k_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)
{
  int __retres;
  int tmp_0;
  bool tmp;
  u32 tmp_2;
  
#line 2184 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 2185 
  struct ath_hw *ah = sc->sc_ah;
  
#line 2187 
  if ((unsigned int)ah->caps.rx_chainmask != 1U) 
#line 2188 
                                                 rx_ant |= tx_ant; else ;
  
#line 2190 
  tmp = validate_antenna_mask(ah,rx_ant);
  
#line 2190 
  if (tmp) 
#line 2190 
           tmp_0 = 0; else 
#line 2190 
                           tmp_0 = 1;
  
#line 2190 
  if (tmp_0) {
    
#line 2191 
    __retres = -22;
    
#line 2191 
    goto return_label;
  }
  else 
    
#line 2190 
    if (tx_ant == 0U) {
      
#line 2191 
      __retres = -22;
      
#line 2191 
      goto return_label;
    }
    else ;
  
#line 2193 
  sc->ant_rx = (unsigned char)rx_ant;
  
#line 2194 
  sc->ant_tx = (unsigned char)tx_ant;
  
#line 2196 
  if ((unsigned int)ah->caps.rx_chainmask == 1U) {
    
#line 2197 
    __retres = 0;
    
#line 2197 
    goto return_label;
  }
  else ;
  
#line 2200 
  if (ah->hw_version.macVersion == 20U) 
#line 2201 
                                        ah->rxchainmask = (unsigned char)7U;
  else {
    u32 tmp_1;
    
#line 2203 
    tmp_1 = fill_chainmask((unsigned int)ah->caps.rx_chainmask,rx_ant);
    
#line 2203 
    ah->rxchainmask = (unsigned char)tmp_1;
  }
  
#line 2205 
  tmp_2 = fill_chainmask((unsigned int)ah->caps.tx_chainmask,tx_ant);
  
#line 2205 
  ah->txchainmask = (unsigned char)tmp_2;
  
#line 2206 
  ath9k_cmn_reload_chainmask(ah);
  
#line 2208 
  __retres = 0;
  return_label: 
#line 2208 
                return __retres;
}


#line 2211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static int ath9k_get_antenna(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant)
{
  int __retres;
  
#line 2213 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 2215 
  *tx_ant = (unsigned int)sc->ant_tx;
  
#line 2216 
  *rx_ant = (unsigned int)sc->ant_rx;
  
#line 2217 
  __retres = 0;
  
#line 2217 
  return __retres;
}


#line 2220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath9k_sw_scan_start(struct ieee80211_hw *hw, struct ieee80211_vif *vif, u8 const *mac_addr)
{
  
#line 2224 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 2225 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 2226 
  set_bit(5L,(unsigned long volatile *)(& common->op_flags));
  
#line 2227 
  return;
}


#line 2229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath9k_sw_scan_complete(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
{
  
#line 2232 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 2233 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 2234 
  set_bit(5L,(unsigned long volatile *)(& common->op_flags));
  
#line 2235 
  return;
}


#line 2239  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath9k_cancel_pending_offchannel(struct ath_softc *sc)
{
  int tmp_0;
  
#line 2241 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 2243 
  if (sc->offchannel.roc_vif != (struct ieee80211_vif *)0) {
    
#line 2244 
    if ((common->debug_mask & 262144) != 0) 
#line 2244 
                                            ath_printk("\001",(struct ath_common const *)common,"%s: Aborting RoC\n","ath9k_cancel_pending_offchannel"); else ;
    
#line 2247 
    ldv_del_timer_sync_158(& sc->offchannel.timer);
    
#line 2248 
    if (sc->offchannel.state > (unsigned int)ATH_OFFCHANNEL_SUSPEND) 
      
#line 2249 
      ath_roc_complete(sc,(_Bool)1); else ;
  }
  else ;
  
#line 2252 
  tmp_0 = constant_test_bit(5L,(unsigned long const volatile *)(& common->op_flags));
  
#line 2252 
  if (tmp_0 != 0) {
    
#line 2253 
    if ((common->debug_mask & 262144) != 0) 
#line 2253 
                                            ath_printk("\001",(struct ath_common const *)common,"%s: Aborting HW scan\n","ath9k_cancel_pending_offchannel"); else ;
    
#line 2256 
    ldv_del_timer_sync_159(& sc->offchannel.timer);
    
#line 2257 
    ath_scan_complete(sc,(_Bool)1);
  }
  else ;
  
#line 2259 
  return;
}


#line 2261  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static int ath9k_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif, struct ieee80211_scan_request *hw_req)
{
  int tmp_0;
  
#line 2264 
  struct cfg80211_scan_request *req = & hw_req->req;
  
#line 2265 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 2266 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 2267 
  int ret = 0;
  
#line 2269 
  ldv_mutex_lock_160(& sc->mutex);
  {
    
#line 2271 
    int __ret_warn_on = sc->offchannel.scan_req != (struct cfg80211_scan_request *)0;
    
#line 2271 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 2271 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c",2271); else ;
    
#line 2271 
    tmp_0 = (long)(__ret_warn_on != 0);
  }
  
#line 2271 
  if ((long)tmp_0 != 0L) {
    
#line 2272 
    ret = -16;
    
#line 2273 
    goto out;
  }
  else ;
  
#line 2276 
  ath9k_ps_wakeup(sc);
  
#line 2277 
  set_bit(5L,(unsigned long volatile *)(& common->op_flags));
  
#line 2278 
  sc->offchannel.scan_vif = vif;
  
#line 2279 
  sc->offchannel.scan_req = req;
  
#line 2280 
  sc->offchannel.scan_idx = 0;
  
#line 2282 
  if ((common->debug_mask & 262144) != 0) 
#line 2282 
                                          ath_printk("\001",(struct ath_common const *)common,"HW scan request received on vif: %pM\n",(u8 *)(& vif->addr)); else ;
  
#line 2285 
  if (sc->offchannel.state == (unsigned int)ATH_OFFCHANNEL_IDLE) {
    
#line 2286 
    if ((common->debug_mask & 262144) != 0) 
#line 2286 
                                            ath_printk("\001",(struct ath_common const *)common,"Starting HW scan\n"); else ;
    
#line 2287 
    ath_offchannel_next(sc);
  }
  else ;
  out: 
#line 2290 
  ;
  
#line 2291 
  ldv_mutex_unlock_161(& sc->mutex);
  
#line 2293 
  return ret;
}


#line 2296  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath9k_cancel_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
{
  
#line 2299 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 2300 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 2302 
  if ((common->debug_mask & 262144) != 0) 
#line 2302 
                                          ath_printk("\001",(struct ath_common const *)common,"Cancel HW scan on vif: %pM\n",(u8 *)(& vif->addr)); else ;
  
#line 2304 
  ldv_mutex_lock_162(& sc->mutex);
  
#line 2305 
  ldv_del_timer_sync_163(& sc->offchannel.timer);
  
#line 2306 
  ath_scan_complete(sc,(_Bool)1);
  
#line 2307 
  ldv_mutex_unlock_164(& sc->mutex);
  
#line 2308 
  return;
}


#line 2310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static int ath9k_remain_on_channel(struct ieee80211_hw *hw, struct ieee80211_vif *vif, struct ieee80211_channel *chan, int duration, enum ieee80211_roc_type type)
{
  int tmp_0;
  
#line 2315 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 2316 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 2317 
  int ret = 0;
  
#line 2319 
  ldv_mutex_lock_165(& sc->mutex);
  {
    
#line 2321 
    int __ret_warn_on = sc->offchannel.roc_vif != (struct ieee80211_vif *)0;
    
#line 2321 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 2321 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c",2321); else ;
    
#line 2321 
    tmp_0 = (long)(__ret_warn_on != 0);
  }
  
#line 2321 
  if ((long)tmp_0 != 0L) {
    
#line 2322 
    ret = -16;
    
#line 2323 
    goto out;
  }
  else ;
  
#line 2326 
  ath9k_ps_wakeup(sc);
  
#line 2327 
  sc->offchannel.roc_vif = vif;
  
#line 2328 
  sc->offchannel.roc_chan = chan;
  
#line 2329 
  sc->offchannel.roc_duration = duration;
  
#line 2331 
  if ((common->debug_mask & 262144) != 0) 
#line 2331 
                                          ath_printk("\001",(struct ath_common const *)common,"RoC request on vif: %pM, type: %d duration: %d\n",(u8 *)(& vif->addr),(unsigned int)type,duration); else ;
  
#line 2335 
  if (sc->offchannel.state == (unsigned int)ATH_OFFCHANNEL_IDLE) {
    
#line 2336 
    if ((common->debug_mask & 262144) != 0) 
#line 2336 
                                            ath_printk("\001",(struct ath_common const *)common,"Starting RoC period\n"); else ;
    
#line 2337 
    ath_offchannel_next(sc);
  }
  else ;
  out: 
#line 2340 
  ;
  
#line 2341 
  ldv_mutex_unlock_166(& sc->mutex);
  
#line 2343 
  return ret;
}


#line 2346  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static int ath9k_cancel_remain_on_channel(struct ieee80211_hw *hw)
{
  int __retres;
  
#line 2348 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 2349 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 2351 
  ldv_mutex_lock_167(& sc->mutex);
  
#line 2353 
  if ((common->debug_mask & 262144) != 0) 
#line 2353 
                                          ath_printk("\001",(struct ath_common const *)common,"Cancel RoC\n"); else ;
  
#line 2354 
  ldv_del_timer_sync_168(& sc->offchannel.timer);
  
#line 2356 
  if (sc->offchannel.roc_vif != (struct ieee80211_vif *)0) {
    
#line 2357 
    if (sc->offchannel.state > (unsigned int)ATH_OFFCHANNEL_SUSPEND) 
      
#line 2358 
      ath_roc_complete(sc,(_Bool)1); else ;
  }
  else ;
  
#line 2361 
  ldv_mutex_unlock_169(& sc->mutex);
  
#line 2363 
  __retres = 0;
  
#line 2363 
  return __retres;
}


#line 2366  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static int ath9k_add_chanctx(struct ieee80211_hw *hw, struct ieee80211_chanctx_conf *conf)
{
  int __retres;
  struct ath_chanctx *ctx;
  struct ath_chanctx **ptr;
  int pos;
  
#line 2369 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 2370 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 2374 
  ldv_mutex_lock_170(& sc->mutex);
  
#line 2376 
  ctx = & sc->chanctx[0];
  
#line 2376 
  goto ldv_54566;
  ldv_54565: 
#line 2377 
  ;
  
#line 2377 
  if ((int)ctx->assigned != 0) 
#line 2378 
                               goto ldv_54564; else ;
  
#line 2380 
  ptr = (struct ath_chanctx **)(& conf->drv_priv);
  
#line 2381 
  *ptr = ctx;
  
#line 2382 
  ctx->assigned = (_Bool)1;
  
#line 2383 
  pos = (int)(((long)ctx - (long)(& sc->chanctx[0])) / 992L);
  
#line 2384 
  ctx->hw_queue_base = pos * 4;
  
#line 2386 
  if ((common->debug_mask & 262144) != 0) 
#line 2386 
                                          ath_printk("\001",(struct ath_common const *)common,"Add channel context: %d MHz\n",(int)(conf->def.chan)->center_freq); else ;
  
#line 2390 
  ath_chanctx_set_channel(sc,ctx,& conf->def);
  
#line 2392 
  ldv_mutex_unlock_171(& sc->mutex);
  
#line 2393 
  __retres = 0;
  
#line 2393 
  goto return_label;
  ldv_54564: 
#line 2394 
  ;
  
#line 2376 
  ctx += 1;
  ldv_54566: 
#line 2377 
  ;
  
#line 2376 
  if (& sc->chanctx[1UL] >= ctx) 
#line 2378 
                                 goto ldv_54565; else 
#line 2381 
                                                      goto ldv_54567;
  ldv_54567: 
#line 2382 
  ;
  
#line 2396 
  ldv_mutex_unlock_172(& sc->mutex);
  
#line 2397 
  __retres = -28;
  return_label: 
#line 2397 
                return __retres;
}


#line 2401  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath9k_remove_chanctx(struct ieee80211_hw *hw, struct ieee80211_chanctx_conf *conf)
{
  
#line 2404 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 2405 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 2406 
  struct ath_chanctx *ctx = ath_chanctx_get(conf);
  
#line 2408 
  ldv_mutex_lock_173(& sc->mutex);
  
#line 2410 
  if ((common->debug_mask & 262144) != 0) 
#line 2410 
                                          ath_printk("\001",(struct ath_common const *)common,"Remove channel context: %d MHz\n",(int)(conf->def.chan)->center_freq); else ;
  
#line 2414 
  ctx->assigned = (_Bool)0;
  
#line 2415 
  ctx->hw_queue_base = 0;
  
#line 2416 
  ath_chanctx_event(sc,(struct ieee80211_vif *)0,(enum ath_chanctx_event)ATH_CHANCTX_EVENT_UNASSIGN);
  
#line 2418 
  ldv_mutex_unlock_174(& sc->mutex);
  
#line 2419 
  return;
}


#line 2421  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath9k_change_chanctx(struct ieee80211_hw *hw, struct ieee80211_chanctx_conf *conf, u32 changed)
{
  
#line 2425 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 2426 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 2427 
  struct ath_chanctx *ctx = ath_chanctx_get(conf);
  
#line 2429 
  ldv_mutex_lock_175(& sc->mutex);
  
#line 2430 
  if ((common->debug_mask & 262144) != 0) 
#line 2430 
                                          ath_printk("\001",(struct ath_common const *)common,"Change channel context: %d MHz\n",(int)(conf->def.chan)->center_freq); else ;
  
#line 2433 
  ath_chanctx_set_channel(sc,ctx,& conf->def);
  
#line 2434 
  ldv_mutex_unlock_176(& sc->mutex);
  
#line 2435 
  return;
}


#line 2437  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static int ath9k_assign_vif_chanctx(struct ieee80211_hw *hw, struct ieee80211_vif *vif, struct ieee80211_chanctx_conf *conf)
{
  int __retres;
  int i;
  
#line 2441 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 2442 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 2443 
  struct ath_vif *avp = (struct ath_vif *)(& vif->drv_priv);
  
#line 2444 
  struct ath_chanctx *ctx = ath_chanctx_get(conf);
  
#line 2447 
  ath9k_cancel_pending_offchannel(sc);
  
#line 2449 
  ldv_mutex_lock_177(& sc->mutex);
  
#line 2451 
  if ((common->debug_mask & 262144) != 0) 
#line 2451 
                                          ath_printk("\001",(struct ath_common const *)common,"Assign VIF (addr: %pM, type: %d, p2p: %d) to channel context: %d MHz\n",(u8 *)(& vif->addr),(unsigned int)vif->type,(int)vif->p2p,(int)(conf->def.chan)->center_freq); else ;
  
#line 2456 
  avp->chanctx = ctx;
  
#line 2457 
  ctx->nvifs_assigned = (short)((int)ctx->nvifs_assigned + 1);
  
#line 2458 
  list_add_tail(& avp->list,& ctx->vifs);
  
#line 2459 
  ath9k_calculate_summary_state(sc,ctx);
  
#line 2460 
  i = 0;
  
#line 2460 
  goto ldv_54594;
  ldv_54593: 
#line 2461 
  ;
  
#line 2461 
  vif->hw_queue[i] = (unsigned char)((int)((unsigned char)ctx->hw_queue_base) + (int)((unsigned char)i));
  
#line 2460 
  i += 1;
  ldv_54594: 
#line 2461 
  ;
  
#line 2460 
  if (i <= 3) 
#line 2462 
              goto ldv_54593; else 
#line 2465 
                                   goto ldv_54595;
  ldv_54595: 
#line 2466 
  ;
  
#line 2463 
  ldv_mutex_unlock_178(& sc->mutex);
  
#line 2465 
  __retres = 0;
  
#line 2465 
  return __retres;
}


#line 2468  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath9k_unassign_vif_chanctx(struct ieee80211_hw *hw, struct ieee80211_vif *vif, struct ieee80211_chanctx_conf *conf)
{
  int ac;
  
#line 2472 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 2473 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 2474 
  struct ath_vif *avp = (struct ath_vif *)(& vif->drv_priv);
  
#line 2475 
  struct ath_chanctx *ctx = ath_chanctx_get(conf);
  
#line 2478 
  ath9k_cancel_pending_offchannel(sc);
  
#line 2480 
  ldv_mutex_lock_179(& sc->mutex);
  
#line 2482 
  if ((common->debug_mask & 262144) != 0) 
#line 2482 
                                          ath_printk("\001",(struct ath_common const *)common,"Remove VIF (addr: %pM, type: %d, p2p: %d) from channel context: %d MHz\n",(u8 *)(& vif->addr),(unsigned int)vif->type,(int)vif->p2p,(int)(conf->def.chan)->center_freq); else ;
  
#line 2487 
  avp->chanctx = (struct ath_chanctx *)0;
  
#line 2488 
  ctx->nvifs_assigned = (short)((int)ctx->nvifs_assigned - 1);
  
#line 2489 
  list_del(& avp->list);
  
#line 2490 
  ath9k_calculate_summary_state(sc,ctx);
  
#line 2491 
  ac = 0;
  
#line 2491 
  goto ldv_54607;
  ldv_54606: 
#line 2492 
  ;
  
#line 2492 
  vif->hw_queue[ac] = (unsigned char)255U;
  
#line 2491 
  ac += 1;
  ldv_54607: 
#line 2492 
  ;
  
#line 2491 
  if (ac <= 3) 
#line 2493 
               goto ldv_54606; else 
#line 2496 
                                    goto ldv_54608;
  ldv_54608: 
#line 2497 
  ;
  
#line 2494 
  ldv_mutex_unlock_180(& sc->mutex);
  
#line 2495 
  return;
}


#line 2497  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static void ath9k_mgd_prepare_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
{
  struct ath_beacon_config *cur_conf;
  struct ath_chanctx *go_ctx;
  unsigned long timeout;
  u32 beacon_int;
  int tmp_0;
  
#line 2500 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 2501 
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  
#line 2502 
  struct ath_vif *avp = (struct ath_vif *)(& vif->drv_priv);
  
#line 2506 
  bool changed = (_Bool)0;
  
#line 2509 
  tmp_0 = constant_test_bit(6L,(unsigned long const volatile *)(& common->op_flags));
  
#line 2509 
  if (tmp_0 == 0) 
#line 2510 
                  goto return_label; else ;
  
#line 2512 
  if (avp->chanctx == (struct ath_chanctx *)0) 
#line 2513 
                                               goto return_label; else ;
  
#line 2515 
  ldv_mutex_lock_181(& sc->mutex);
  
#line 2517 
  ldv_spin_lock_bh_182(& sc->chan_lock);
  
#line 2518 
  if (sc->next_chan != (struct ath_chanctx *)0 || sc->cur_chan != avp->chanctx) 
    
#line 2519 
    changed = (_Bool)1; else ;
  
#line 2520 
  ldv_spin_unlock_bh_183(& sc->chan_lock);
  
#line 2522 
  if (! changed) 
#line 2523 
                 goto out; else ;
  
#line 2525 
  ath9k_cancel_pending_offchannel(sc);
  
#line 2527 
  go_ctx = ath_is_go_chanctx_present(sc);
  
#line 2529 
  if (go_ctx != (struct ath_chanctx *)0) {
    unsigned long tmp_1;
    
#line 2534 
    ldv_spin_lock_bh_184(& sc->chan_lock);
    
#line 2535 
    sc->sched.mgd_prepare_tx = (_Bool)1;
    
#line 2536 
    cur_conf = & go_ctx->beacon;
    
#line 2537 
    beacon_int = (unsigned int)(cur_conf->beacon_interval << 10);
    
#line 2538 
    ldv_spin_unlock_bh_185(& sc->chan_lock);
    
#line 2540 
    timeout = usecs_to_jiffies(beacon_int * 2U);
    
#line 2541 
    init_completion(& sc->go_beacon);
    
#line 2543 
    ldv_mutex_unlock_186(& sc->mutex);
    
#line 2545 
    tmp_1 = wait_for_completion_timeout(& sc->go_beacon,timeout);
    
#line 2545 
    if (tmp_1 == 0UL) {
      
#line 2547 
      if ((common->debug_mask & 262144) != 0) 
#line 2547 
                                              ath_printk("\001",(struct ath_common const *)common,"Failed to send new NoA\n"); else ;
      
#line 2550 
      ldv_spin_lock_bh_187(& sc->chan_lock);
      
#line 2551 
      sc->sched.mgd_prepare_tx = (_Bool)0;
      
#line 2552 
      ldv_spin_unlock_bh_188(& sc->chan_lock);
    }
    else ;
    
#line 2555 
    ldv_mutex_lock_189(& sc->mutex);
  }
  else ;
  
#line 2558 
  if ((common->debug_mask & 262144) != 0) 
#line 2558 
                                          ath_printk("\001",(struct ath_common const *)common,"%s: Set chanctx state to FORCE_ACTIVE for vif: %pM\n","ath9k_mgd_prepare_tx",(u8 *)(& vif->addr)); else ;
  
#line 2562 
  ldv_spin_lock_bh_190(& sc->chan_lock);
  
#line 2563 
  sc->next_chan = avp->chanctx;
  
#line 2564 
  sc->sched.state = ATH_CHANCTX_STATE_FORCE_ACTIVE;
  
#line 2565 
  ldv_spin_unlock_bh_191(& sc->chan_lock);
  
#line 2567 
  ath_chanctx_set_next(sc,(_Bool)1);
  out: 
#line 2568 
  ;
  
#line 2569 
  ldv_mutex_unlock_192(& sc->mutex);
  return_label: 
#line 2570 
                return;
}


#line 2572  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
void ath9k_fill_chanctx_ops(void)
{
  int tmp_0;
  bool tmp;
  
#line 2574 
  tmp = ath9k_is_chanctx_enabled();
  
#line 2574 
  if (tmp) 
#line 2574 
           tmp_0 = 0; else 
#line 2574 
                           tmp_0 = 1;
  
#line 2574 
  if (tmp_0) 
#line 2575 
             goto return_label; else ;
  
#line 2577 
  ath9k_ops.hw_scan = & ath9k_hw_scan;
  
#line 2578 
  ath9k_ops.cancel_hw_scan = & ath9k_cancel_hw_scan;
  
#line 2579 
  ath9k_ops.remain_on_channel = & ath9k_remain_on_channel;
  
#line 2580 
  ath9k_ops.cancel_remain_on_channel = & ath9k_cancel_remain_on_channel;
  
#line 2581 
  ath9k_ops.add_chanctx = & ath9k_add_chanctx;
  
#line 2582 
  ath9k_ops.remove_chanctx = & ath9k_remove_chanctx;
  
#line 2583 
  ath9k_ops.change_chanctx = & ath9k_change_chanctx;
  
#line 2584 
  ath9k_ops.assign_vif_chanctx = & ath9k_assign_vif_chanctx;
  
#line 2585 
  ath9k_ops.unassign_vif_chanctx = & ath9k_unassign_vif_chanctx;
  
#line 2586 
  ath9k_ops.mgd_prepare_tx = & ath9k_mgd_prepare_tx;
  return_label: 
#line 2587 
                return;
}


#line 2591  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
static int ath9k_get_txpower(struct ieee80211_hw *hw, struct ieee80211_vif *vif, int *dbm)
{
  int __retres;
  
#line 2594 
  struct ath_softc *sc = (struct ath_softc *)hw->priv;
  
#line 2595 
  struct ath_vif *avp = (struct ath_vif *)(& vif->drv_priv);
  
#line 2597 
  ldv_mutex_lock_193(& sc->mutex);
  
#line 2598 
  if (avp->chanctx != (struct ath_chanctx *)0) 
#line 2599 
                                               *dbm = (int)(avp->chanctx)->cur_txpower; else 
                                                                    
#line 2601 
                                                                    *dbm = (int)(sc->cur_chan)->cur_txpower;
  
#line 2602 
  ldv_mutex_unlock_194(& sc->mutex);
  
#line 2604 
  *dbm /= 2;
  
#line 2606 
  __retres = 0;
  
#line 2606 
  return __retres;
}


#line 2609  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ath/ath9k/main.c"
struct ieee80211_ops ath9k_ops = {.tx = & ath9k_tx, .start = & ath9k_start, .stop = & ath9k_stop, .suspend = & ath9k_suspend, .resume = & ath9k_resume, .set_wakeup = & ath9k_set_wakeup, .add_interface = & ath9k_add_interface, .change_interface = & ath9k_change_interface, .remove_interface = & ath9k_remove_interface, .config = & ath9k_config, .bss_info_changed = & ath9k_bss_info_changed, .start_ap = (int (*)(struct ieee80211_hw *, struct ieee80211_vif *))0, .stop_ap = (void (*)(struct ieee80211_hw *, struct ieee80211_vif *))0, .prepare_multicast = (u64 (*)(struct ieee80211_hw *, struct netdev_hw_addr_list *))0, .configure_filter = & ath9k_configure_filter, .set_tim = (int (*)(struct ieee80211_hw *, struct ieee80211_sta *, bool ))0, .set_key = & ath9k_set_key, .update_tkip_key = (void (*)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_key_conf *, struct ieee80211_sta *, u32 , u16 *))0, .set_rekey_data = (void (*)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_gtk_rekey_data *))0, .set_default_unicast_key = (void (*)(struct ieee80211_hw *, struct ieee80211_vif *, int ))0, .hw_scan = (int (*)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_scan_request *))0, .cancel_hw_scan = (void (*)(struct ieee80211_hw *, struct ieee80211_vif *))0, .sched_scan_start = (int (*)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_sched_scan_request *, struct ieee80211_scan_ies *))0, .sched_scan_stop = (int (*)(struct ieee80211_hw *, struct ieee80211_vif *))0, .sw_scan_start = & ath9k_sw_scan_start, .sw_scan_complete = & ath9k_sw_scan_complete, .get_stats = & ath9k_get_stats, .get_key_seq = (void (*)(struct ieee80211_hw *, struct ieee80211_key_conf *, struct ieee80211_key_seq *))0, .set_frag_threshold = (int (*)(struct ieee80211_hw *, u32 ))0, .set_rts_threshold = (int (*)(struct ieee80211_hw *, u32 ))0, .sta_add = (int (*)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *))0, .sta_remove = (int (*)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *))0, .sta_add_debugfs = & ath9k_sta_add_debugfs, .sta_remove_debugfs = (void (*)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, struct dentry *))0, .sta_notify = & ath9k_sta_notify, .sta_state = & ath9k_sta_state, .sta_pre_rcu_remove = (void (*)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *))0, .sta_rc_update = (void (*)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, u32 ))0, .sta_rate_tbl_update = (void (*)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *))0, .sta_statistics = (void (*)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, struct station_info *))0, .conf_tx = & ath9k_conf_tx, .get_tsf = & ath9k_get_tsf, .set_tsf = & ath9k_set_tsf, .reset_tsf = & ath9k_reset_tsf, .tx_last_beacon = & ath9k_tx_last_beacon, .ampdu_action = & ath9k_ampdu_action, .get_survey = & ath9k_get_survey, .rfkill_poll = & ath9k_rfkill_poll_state, .set_coverage_class = & ath9k_set_coverage_class, .testmode_cmd = (int (*)(struct ieee80211_hw *, struct ieee80211_vif *, void *, int ))0, .testmode_dump = (int (*)(struct ieee80211_hw *, struct sk_buff *, struct netlink_callback *, void *, int ))0, .flush = & ath9k_flush, .channel_switch = (void (*)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_channel_switch *))0, .set_antenna = & ath9k_set_antenna, .get_antenna = & ath9k_get_antenna, .remain_on_channel = (int (*)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_channel *, int , enum ieee80211_roc_type ))0, .cancel_remain_on_channel = (int (*)(struct ieee80211_hw *))0, .set_ringparam = (int (*)(struct ieee80211_hw *, u32 , u32 ))0, .get_ringparam = (void (*)(struct ieee80211_hw *, u32 *, u32 *, u32 *, u32 *))0, .tx_frames_pending = & ath9k_tx_frames_pending, .set_bitrate_mask = (int (*)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_bitrate_mask const *))0, .event_callback = (void (*)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_event const *))0, .allow_buffered_frames = (void (*)(struct ieee80211_hw *, struct ieee80211_sta *, u16 , int , enum ieee80211_frame_release_type , bool ))0, .release_buffered_frames = & ath9k_release_buffered_frames, .get_et_sset_count = & ath9k_get_et_sset_count, .get_et_stats = & ath9k_get_et_stats, .get_et_strings = & ath9k_get_et_strings, .mgd_prepare_tx = (void (*)(struct ieee80211_hw *, struct ieee80211_vif *))0, .mgd_protect_tdls_discover = (void (*)(struct ieee80211_hw *, struct ieee80211_vif *))0, .add_chanctx = (int (*)(struct ieee80211_hw *, struct ieee80211_chanctx_conf *))0, .remove_chanctx = (void (*)(struct ieee80211_hw *, struct ieee80211_chanctx_conf *))0, .change_chanctx = (void (*)(struct ieee80211_hw *, struct ieee80211_chanctx_conf *, u32 ))0, .assign_vif_chanctx = (int (*)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_chanctx_conf *))0, .unassign_vif_chanctx = (void (*)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_chanctx_conf *))0, .switch_vif_chanctx = (int (*)(struct ieee80211_hw *, struct ieee80211_vif_chanctx_switch *, int , enum ieee80211_chanctx_switch_mode ))0, .reconfig_complete = (void (*)(struct ieee80211_hw *, enum ieee80211_reconfig_type ))0, .ipv6_addr_change = (void (*)(struct ieee80211_hw *, struct ieee80211_vif *, struct inet6_dev *))0, .channel_switch_beacon = (void (*)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_chan_def *))0, .pre_channel_switch = (int (*)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_channel_switch *))0, .post_channel_switch = (int (*)(struct ieee80211_hw *, struct ieee80211_vif *))0, .join_ibss = (int (*)(struct ieee80211_hw *, struct ieee80211_vif *))0, .leave_ibss = (void (*)(struct ieee80211_hw *, struct ieee80211_vif *))0, .get_expected_throughput = (u32 (*)(struct ieee80211_sta *))0, .get_txpower = & ath9k_get_txpower, .tdls_channel_switch = (int (*)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, u8 , struct cfg80211_chan_def *, struct sk_buff *, u32 ))0, .tdls_cancel_channel_switch = (void (*)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *))0, .tdls_recv_channel_switch = (void (*)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_tdls_ch_sw_params *))0, .wake_tx_queue = (void (*)(struct ieee80211_hw *, struct ieee80211_txq *))0};

#line 61  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
void ldv_emg_tasklet_schedule(struct tasklet_struct *arg0);


#line 68  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
void ldv_emg_wrapper_ath9k_set_tsf_19(struct ieee80211_hw *arg0, struct ieee80211_vif *arg1, unsigned long long arg2)
{
  
#line 69 
  ath9k_set_tsf(arg0,arg1,arg2);
  
#line 70 
  return;
}


#line 73  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
int ldv_emg_wrapper_ath9k_conf_tx_8(struct ieee80211_hw *arg0, struct ieee80211_vif *arg1, unsigned short arg2, struct ieee80211_tx_queue_params *arg3)
{
  int tmp;
  
#line 74 
  tmp = ath9k_conf_tx(arg0,arg1,(unsigned short)((int)arg2),(struct ieee80211_tx_queue_params const *)arg3);
  
#line 74 
  return tmp;
}


#line 78  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
int ldv_emg_wrapper_ath9k_get_survey_5(struct ieee80211_hw *arg0, int arg1, struct survey_info *arg2)
{
  int tmp;
  
#line 79 
  tmp = ath9k_get_survey(arg0,arg1,arg2);
  
#line 79 
  return tmp;
}


#line 83  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
int ldv_emg_wrapper_ath9k_change_interface_23(struct ieee80211_hw *arg0, struct ieee80211_vif *arg1, enum nl80211_iftype arg2, _Bool arg3)
{
  int tmp;
  
#line 84 
  tmp = ath9k_change_interface(arg0,arg1,arg2,(_Bool)((bool)((int)arg3) != 0));
  
#line 84 
  return tmp;
}


#line 88  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
int ldv_emg_wrapper_ath9k_set_key_18(struct ieee80211_hw *arg0, enum set_key_cmd arg1, struct ieee80211_vif *arg2, struct ieee80211_sta *arg3, struct ieee80211_key_conf *arg4)
{
  int tmp;
  
#line 89 
  tmp = ath9k_set_key(arg0,arg1,arg2,arg3,arg4);
  
#line 89 
  return tmp;
}


#line 93  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
int ldv_emg_wrapper_ath9k_get_txpower_14(struct ieee80211_hw *arg0, struct ieee80211_vif *arg1, int *arg2)
{
  int tmp;
  
#line 94 
  tmp = ath9k_get_txpower(arg0,arg1,arg2);
  
#line 94 
  return tmp;
}


#line 98  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
int ldv_emg_wrapper_ath9k_sta_state_15(struct ieee80211_hw *arg0, struct ieee80211_vif *arg1, struct ieee80211_sta *arg2, enum ieee80211_sta_state arg3, enum ieee80211_sta_state arg4)
{
  int tmp;
  
#line 99 
  tmp = ath9k_sta_state(arg0,arg1,arg2,arg3,arg4);
  
#line 99 
  return tmp;
}


#line 103  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
void ldv_emg_wrapper_ath9k_tx_7(struct ieee80211_hw *arg0, struct ieee80211_tx_control *arg1, struct sk_buff *arg2)
{
  
#line 104 
  ath9k_tx(arg0,arg1,arg2);
  
#line 105 
  return;
}


#line 108  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
unsigned long long ldv_emg_wrapper_ath9k_get_tsf_9(struct ieee80211_hw *arg0, struct ieee80211_vif *arg1)
{
  unsigned long long tmp;
  
#line 109 
  tmp = ath9k_get_tsf(arg0,arg1);
  
#line 109 
  return tmp;
}


#line 113  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
int ldv_emg_wrapper_ath9k_get_antenna_21(struct ieee80211_hw *arg0, unsigned int *arg1, unsigned int *arg2)
{
  int tmp;
  
#line 114 
  tmp = ath9k_get_antenna(arg0,arg1,arg2);
  
#line 114 
  return tmp;
}


#line 118  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
int ldv_emg_wrapper_ath9k_start_2(struct ieee80211_hw *arg0)
{
  int tmp;
  
#line 119 
  tmp = ath9k_start(arg0);
  
#line 119 
  return tmp;
}


#line 123  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
void ldv_emg_wrapper_ath9k_flush_6(struct ieee80211_hw *arg0, struct ieee80211_vif *arg1, unsigned int arg2, _Bool arg3)
{
  
#line 124 
  ath9k_flush(arg0,arg1,arg2,(_Bool)((bool)((int)arg3) != 0));
  
#line 125 
  return;
}


#line 128  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
void ldv_emg_wrapper_ath9k_sta_notify_3(struct ieee80211_hw *arg0, struct ieee80211_vif *arg1, enum sta_notify_cmd arg2, struct ieee80211_sta *arg3)
{
  
#line 129 
  ath9k_sta_notify(arg0,arg1,arg2,arg3);
  
#line 130 
  return;
}


#line 133  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
void ldv_emg_wrapper_ath9k_configure_filter_26(struct ieee80211_hw *arg0, unsigned int arg1, unsigned int *arg2, unsigned long long arg3)
{
  
#line 134 
  ath9k_configure_filter(arg0,arg1,arg2,arg3);
  
#line 135 
  return;
}


#line 138  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
int ldv_emg_wrapper_ath9k_add_interface_4(struct ieee80211_hw *arg0, struct ieee80211_vif *arg1)
{
  int tmp;
  
#line 139 
  tmp = ath9k_add_interface(arg0,arg1);
  
#line 139 
  return tmp;
}


#line 143  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
int ldv_emg_wrapper_ath9k_ampdu_action_12(struct ieee80211_hw *arg0, struct ieee80211_vif *arg1, enum ieee80211_ampdu_mlme_action arg2, struct ieee80211_sta *arg3, unsigned short arg4, unsigned short *arg5, unsigned char arg6)
{
  int tmp;
  
#line 144 
  tmp = ath9k_ampdu_action(arg0,arg1,arg2,arg3,(unsigned short)((int)arg4),arg5,(unsigned char)((int)arg6));
  
#line 144 
  return tmp;
}


#line 148  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
int ldv_emg_wrapper_ath9k_set_antenna_27(struct ieee80211_hw *arg0, unsigned int arg1, unsigned int arg2)
{
  int tmp;
  
#line 149 
  tmp = ath9k_set_antenna(arg0,arg1,arg2);
  
#line 149 
  return tmp;
}


#line 153  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
void ldv_emg_wrapper_ath9k_bss_info_changed_24(struct ieee80211_hw *arg0, struct ieee80211_vif *arg1, struct ieee80211_bss_conf *arg2, unsigned int arg3)
{
  
#line 154 
  ath9k_bss_info_changed(arg0,arg1,arg2,arg3);
  
#line 155 
  return;
}


#line 158  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
void ldv_emg_wrapper_ath9k_sw_scan_start_20(struct ieee80211_hw *arg0, struct ieee80211_vif *arg1, unsigned char *arg2)
{
  
#line 159 
  ath9k_sw_scan_start(arg0,arg1,(u8 const *)arg2);
  
#line 160 
  return;
}


#line 163  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
void ldv_emg_wrapper_ath9k_set_coverage_class_17(struct ieee80211_hw *arg0, short arg1)
{
  
#line 164 
  ath9k_set_coverage_class(arg0,(short)((int)arg1));
  
#line 165 
  return;
}


#line 168  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
void ldv_emg_wrapper_ath9k_sw_scan_complete_13(struct ieee80211_hw *arg0, struct ieee80211_vif *arg1)
{
  
#line 169 
  ath9k_sw_scan_complete(arg0,arg1);
  
#line 170 
  return;
}


#line 173  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
void ldv_emg_wrapper_ath9k_remove_interface_10(struct ieee80211_hw *arg0, struct ieee80211_vif *arg1)
{
  
#line 174 
  ath9k_remove_interface(arg0,arg1);
  
#line 175 
  return;
}


#line 178  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
int ldv_emg_wrapper_ath9k_tx_last_beacon_25(struct ieee80211_hw *arg0)
{
  int tmp;
  
#line 179 
  tmp = ath9k_tx_last_beacon(arg0);
  
#line 179 
  return tmp;
}


#line 183  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
int ldv_emg_wrapper_ath9k_config_22(struct ieee80211_hw *arg0, unsigned int arg1)
{
  int tmp;
  
#line 184 
  tmp = ath9k_config(arg0,arg1);
  
#line 184 
  return tmp;
}


#line 188  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
int ldv_emg_wrapper_ath9k_get_stats_16(struct ieee80211_hw *arg0, struct ieee80211_low_level_stats *arg1)
{
  int tmp;
  
#line 189 
  tmp = ath9k_get_stats(arg0,arg1);
  
#line 189 
  return tmp;
}


#line 193  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
_Bool ldv_emg_wrapper_ath9k_tx_frames_pending_28(struct ieee80211_hw *arg0)
{
  _Bool __retres;
  _Bool tmp;
  
#line 194 
  tmp = ath9k_tx_frames_pending(arg0);
  
#line 194 
  __retres = tmp != 0;
  
#line 194 
  return __retres;
}


#line 198  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
void ldv_emg_wrapper_ath9k_stop_29(struct ieee80211_hw *arg0)
{
  
#line 199 
  ath9k_stop(arg0);
  
#line 200 
  return;
}


#line 203  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
void ldv_emg_wrapper_ath9k_reset_tsf_11(struct ieee80211_hw *arg0, struct ieee80211_vif *arg1)
{
  
#line 204 
  ath9k_reset_tsf(arg0,arg1);
  
#line 205 
  return;
}


#line 262  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void atomic_inc_0(atomic_t *v)
{
  
#line 265 
  ldv_atomic_inc(v);
  
#line 266 
  return;
}


#line 269  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void atomic_dec_0(atomic_t *v)
{
  
#line 272 
  ldv_atomic_dec(v);
  
#line 273 
  return;
}


#line 879  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_lock_bh_72_3(spinlock_t *lock)
{
  
#line 883 
  ldv_spin_model_lock((char *)"axq_lock_of_ath_txq");
  
#line 885 
  spin_lock_bh_5(lock);
  
#line 886 
  return;
}


#line 889  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_unlock_bh_73_3(spinlock_t *lock)
{
  
#line 893 
  ldv_spin_model_unlock((char *)"axq_lock_of_ath_txq");
  
#line 895 
  spin_unlock_bh_5(lock);
  
#line 896 
  return;
}


#line 899  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv___ldv_spin_lock_74_2(spinlock_t *ldv_func_arg1)
{
  
#line 903 
  ldv_spin_model_lock((char *)"sc_pm_lock_of_ath_softc");
  
#line 905 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 906 
  return;
}


#line 909  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_unlock_irqrestore_75_2(spinlock_t *lock, unsigned long flags)
{
  
#line 913 
  ldv_spin_model_unlock((char *)"sc_pm_lock_of_ath_softc");
  
#line 915 
  spin_unlock_irqrestore_6(lock,flags);
  
#line 916 
  return;
}


#line 919  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_lock_76_0(spinlock_t *lock)
{
  
#line 923 
  ldv_spin_model_lock((char *)"cc_lock_of_ath_common");
  
#line 925 
  spin_lock_0(lock);
  
#line 926 
  return;
}


#line 929  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_unlock_77_0(spinlock_t *lock)
{
  
#line 933 
  ldv_spin_model_unlock((char *)"cc_lock_of_ath_common");
  
#line 935 
  spin_unlock_0(lock);
  
#line 936 
  return;
}


#line 939  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv___ldv_spin_lock_78(spinlock_t *ldv_func_arg1)
{
  
#line 943 
  ldv_spin_model_lock((char *)"sc_pm_lock_of_ath_softc");
  
#line 945 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 946 
  return;
}


#line 949  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static int ldv_del_timer_sync_79(struct timer_list *ldv_func_arg1)
{
  int tmp;
  
#line 953 
  tmp = ldv_emg_del_timer_sync(ldv_func_arg1);
  
#line 953 
  return tmp;
}


#line 957  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_lock_80(spinlock_t *lock)
{
  
#line 961 
  ldv_spin_model_lock((char *)"cc_lock_of_ath_common");
  
#line 963 
  spin_lock_0(lock);
  
#line 964 
  return;
}


#line 967  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_unlock_81(spinlock_t *lock)
{
  
#line 971 
  ldv_spin_model_unlock((char *)"cc_lock_of_ath_common");
  
#line 973 
  spin_unlock_0(lock);
  
#line 974 
  return;
}


#line 977  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_unlock_irqrestore_82(spinlock_t *lock, unsigned long flags)
{
  
#line 981 
  ldv_spin_model_unlock((char *)"sc_pm_lock_of_ath_softc");
  
#line 983 
  spin_unlock_irqrestore_6(lock,flags);
  
#line 984 
  return;
}


#line 987  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv___ldv_spin_lock_83(spinlock_t *ldv_func_arg1)
{
  
#line 991 
  ldv_spin_model_lock((char *)"sc_pm_lock_of_ath_softc");
  
#line 993 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 994 
  return;
}


#line 997  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static int ldv_mod_timer_84(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2)
{
  int tmp;
  
#line 1001 
  tmp = ldv_emg_mod_timer(ldv_func_arg1,ldv_func_arg2);
  
#line 1001 
  return tmp;
}


#line 1005  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_lock_85(spinlock_t *lock)
{
  
#line 1009 
  ldv_spin_model_lock((char *)"cc_lock_of_ath_common");
  
#line 1011 
  spin_lock_0(lock);
  
#line 1012 
  return;
}


#line 1015  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_unlock_86(spinlock_t *lock)
{
  
#line 1019 
  ldv_spin_model_unlock((char *)"cc_lock_of_ath_common");
  
#line 1021 
  spin_unlock_0(lock);
  
#line 1022 
  return;
}


#line 1025  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_unlock_irqrestore_87(spinlock_t *lock, unsigned long flags)
{
  
#line 1029 
  ldv_spin_model_unlock((char *)"sc_pm_lock_of_ath_softc");
  
#line 1031 
  spin_unlock_irqrestore_6(lock,flags);
  
#line 1032 
  return;
}


#line 1035  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv___ldv_spin_lock_88(spinlock_t *ldv_func_arg1)
{
  
#line 1039 
  ldv_spin_model_lock((char *)"sc_pm_lock_of_ath_softc");
  
#line 1041 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 1042 
  return;
}


#line 1045  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_unlock_irqrestore_89(spinlock_t *lock, unsigned long flags)
{
  
#line 1049 
  ldv_spin_model_unlock((char *)"sc_pm_lock_of_ath_softc");
  
#line 1051 
  spin_unlock_irqrestore_6(lock,flags);
  
#line 1052 
  return;
}


#line 1055  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_lock_bh_90(spinlock_t *lock)
{
  
#line 1059 
  ldv_spin_model_lock((char *)"sc_pcu_lock_of_ath_softc");
  
#line 1061 
  spin_lock_bh_5(lock);
  
#line 1062 
  return;
}


#line 1065  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_lock_bh_91_0(spinlock_t *lock)
{
  
#line 1069 
  ldv_spin_model_lock((char *)"chan_lock_of_ath_softc");
  
#line 1071 
  spin_lock_bh_5(lock);
  
#line 1072 
  return;
}


#line 1075  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_unlock_bh_92_0(spinlock_t *lock)
{
  
#line 1079 
  ldv_spin_model_unlock((char *)"chan_lock_of_ath_softc");
  
#line 1081 
  spin_unlock_bh_5(lock);
  
#line 1082 
  return;
}


#line 1085  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_unlock_bh_93(spinlock_t *lock)
{
  
#line 1089 
  ldv_spin_model_unlock((char *)"sc_pcu_lock_of_ath_softc");
  
#line 1091 
  spin_unlock_bh_5(lock);
  
#line 1092 
  return;
}


#line 1095  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_lock_94(spinlock_t *lock)
{
  
#line 1099 
  ldv_spin_model_lock((char *)"sc_pcu_lock_of_ath_softc");
  
#line 1101 
  spin_lock_0(lock);
  
#line 1102 
  return;
}


#line 1105  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_lock_95(spinlock_t *lock)
{
  
#line 1109 
  ldv_spin_model_lock((char *)"cc_lock_of_ath_common");
  
#line 1111 
  spin_lock_0(lock);
  
#line 1112 
  return;
}


#line 1115  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_unlock_96(spinlock_t *lock)
{
  
#line 1119 
  ldv_spin_model_unlock((char *)"cc_lock_of_ath_common");
  
#line 1121 
  spin_unlock_0(lock);
  
#line 1122 
  return;
}


#line 1125  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv___ldv_spin_lock_97(spinlock_t *ldv_func_arg1)
{
  
#line 1129 
  ldv_spin_model_lock((char *)"sc_pm_lock_of_ath_softc");
  
#line 1131 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 1132 
  return;
}


#line 1135  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_unlock_irqrestore_98(spinlock_t *lock, unsigned long flags)
{
  
#line 1139 
  ldv_spin_model_unlock((char *)"sc_pm_lock_of_ath_softc");
  
#line 1141 
  spin_unlock_irqrestore_6(lock,flags);
  
#line 1142 
  return;
}


#line 1145  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_unlock_99(spinlock_t *lock)
{
  
#line 1149 
  ldv_spin_model_unlock((char *)"sc_pcu_lock_of_ath_softc");
  
#line 1151 
  spin_unlock_0(lock);
  
#line 1152 
  return;
}


#line 1155  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_tasklet_schedule_100(struct tasklet_struct *t)
{
  
#line 1159 
  ldv_emg_tasklet_schedule(t);
  
#line 1160 
  return;
}


#line 1163  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_lock_101(spinlock_t *lock)
{
  
#line 1167 
  ldv_spin_model_lock((char *)"sc_pm_lock_of_ath_softc");
  
#line 1169 
  spin_lock_0(lock);
  
#line 1170 
  return;
}


#line 1173  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_unlock_102(spinlock_t *lock)
{
  
#line 1177 
  ldv_spin_model_unlock((char *)"sc_pm_lock_of_ath_softc");
  
#line 1179 
  spin_unlock_0(lock);
  
#line 1180 
  return;
}


#line 1183  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_tasklet_schedule_103(struct tasklet_struct *t)
{
  
#line 1187 
  ldv_emg_tasklet_schedule(t);
  
#line 1188 
  return;
}


#line 1191  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_lock_104_0(struct mutex *ldv_func_arg1)
{
  
#line 1195 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1196 
  return;
}


#line 1199  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_lock_bh_105(spinlock_t *lock)
{
  
#line 1203 
  ldv_spin_model_lock((char *)"sc_pcu_lock_of_ath_softc");
  
#line 1205 
  spin_lock_bh_5(lock);
  
#line 1206 
  return;
}


#line 1209  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_unlock_bh_106(spinlock_t *lock)
{
  
#line 1213 
  ldv_spin_model_unlock((char *)"sc_pcu_lock_of_ath_softc");
  
#line 1215 
  spin_unlock_bh_5(lock);
  
#line 1216 
  return;
}


#line 1219  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_107(struct mutex *ldv_func_arg1)
{
  
#line 1223 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1224 
  return;
}


#line 1227  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv___ldv_spin_lock_108_0(spinlock_t *ldv_func_arg1)
{
  
#line 1231 
  ldv_spin_model_lock((char *)"sc_pm_lock_of_ath_softc");
  
#line 1233 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 1234 
  return;
}


#line 1237  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_unlock_irqrestore_109_0(spinlock_t *lock, unsigned long flags)
{
  
#line 1241 
  ldv_spin_model_unlock((char *)"sc_pm_lock_of_ath_softc");
  
#line 1243 
  spin_unlock_irqrestore_6(lock,flags);
  
#line 1244 
  return;
}


#line 1247  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_lock_110(struct mutex *ldv_func_arg1)
{
  
#line 1251 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1252 
  return;
}


#line 1255  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_111(struct mutex *ldv_func_arg1)
{
  
#line 1259 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1260 
  return;
}


#line 1263  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_lock_bh_112(spinlock_t *lock)
{
  
#line 1267 
  ldv_spin_model_lock((char *)"sc_pcu_lock_of_ath_softc");
  
#line 1269 
  spin_lock_bh_5(lock);
  
#line 1270 
  return;
}


#line 1273  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_unlock_bh_113(spinlock_t *lock)
{
  
#line 1277 
  ldv_spin_model_unlock((char *)"sc_pcu_lock_of_ath_softc");
  
#line 1279 
  spin_unlock_bh_5(lock);
  
#line 1280 
  return;
}


#line 1283  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_lock_bh_114(spinlock_t *lock)
{
  
#line 1287 
  ldv_spin_model_lock((char *)"sc_pcu_lock_of_ath_softc");
  
#line 1289 
  spin_lock_bh_5(lock);
  
#line 1290 
  return;
}


#line 1293  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_unlock_bh_115(spinlock_t *lock)
{
  
#line 1297 
  ldv_spin_model_unlock((char *)"sc_pcu_lock_of_ath_softc");
  
#line 1299 
  spin_unlock_bh_5(lock);
  
#line 1300 
  return;
}


#line 1303  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_116(struct mutex *ldv_func_arg1)
{
  
#line 1307 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1308 
  return;
}


#line 1311  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv___ldv_spin_lock_117(spinlock_t *ldv_func_arg1)
{
  
#line 1315 
  ldv_spin_model_lock((char *)"sc_pm_lock_of_ath_softc");
  
#line 1317 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 1318 
  return;
}


#line 1321  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_unlock_irqrestore_118(spinlock_t *lock, unsigned long flags)
{
  
#line 1325 
  ldv_spin_model_unlock((char *)"sc_pm_lock_of_ath_softc");
  
#line 1327 
  spin_unlock_irqrestore_6(lock,flags);
  
#line 1328 
  return;
}


#line 1331  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_lock_119(struct mutex *ldv_func_arg1)
{
  
#line 1335 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1336 
  return;
}


#line 1339  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_120(struct mutex *ldv_func_arg1)
{
  
#line 1343 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1344 
  return;
}


#line 1347  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_121(struct mutex *ldv_func_arg1)
{
  
#line 1351 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1352 
  return;
}


#line 1355  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_lock_122(struct mutex *ldv_func_arg1)
{
  
#line 1359 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1360 
  return;
}


#line 1363  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_123(struct mutex *ldv_func_arg1)
{
  
#line 1367 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1368 
  return;
}


#line 1371  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_124(struct mutex *ldv_func_arg1)
{
  
#line 1375 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1376 
  return;
}


#line 1379  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_lock_125(struct mutex *ldv_func_arg1)
{
  
#line 1383 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1384 
  return;
}


#line 1387  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_126(struct mutex *ldv_func_arg1)
{
  
#line 1391 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1392 
  return;
}


#line 1395  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_lock_127(struct mutex *ldv_func_arg1)
{
  
#line 1399 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1400 
  return;
}


#line 1403  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv___ldv_spin_lock_128(spinlock_t *ldv_func_arg1)
{
  
#line 1407 
  ldv_spin_model_lock((char *)"sc_pm_lock_of_ath_softc");
  
#line 1409 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 1410 
  return;
}


#line 1413  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_unlock_irqrestore_129(spinlock_t *lock, unsigned long flags)
{
  
#line 1417 
  ldv_spin_model_unlock((char *)"sc_pm_lock_of_ath_softc");
  
#line 1419 
  spin_unlock_irqrestore_6(lock,flags);
  
#line 1420 
  return;
}


#line 1423  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_130(struct mutex *ldv_func_arg1)
{
  
#line 1427 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1428 
  return;
}


#line 1431  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_lock_bh_131(spinlock_t *lock)
{
  
#line 1435 
  ldv_spin_model_lock((char *)"chan_lock_of_ath_softc");
  
#line 1437 
  spin_lock_bh_5(lock);
  
#line 1438 
  return;
}


#line 1441  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_unlock_bh_132(spinlock_t *lock)
{
  
#line 1445 
  ldv_spin_model_unlock((char *)"chan_lock_of_ath_softc");
  
#line 1447 
  spin_unlock_bh_5(lock);
  
#line 1448 
  return;
}


#line 1451  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_lock_133(struct mutex *ldv_func_arg1)
{
  
#line 1455 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1456 
  return;
}


#line 1459  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_134(struct mutex *ldv_func_arg1)
{
  
#line 1463 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1464 
  return;
}


#line 1467  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_lock_135(struct mutex *ldv_func_arg1)
{
  
#line 1471 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1472 
  return;
}


#line 1475  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_136(struct mutex *ldv_func_arg1)
{
  
#line 1479 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1480 
  return;
}


#line 1483  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_lock_137(struct mutex *ldv_func_arg1)
{
  
#line 1487 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1488 
  return;
}


#line 1491  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_138(struct mutex *ldv_func_arg1)
{
  
#line 1495 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1496 
  return;
}


#line 1499  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_lock_139(struct mutex *ldv_func_arg1)
{
  
#line 1503 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1504 
  return;
}


#line 1507  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_140(struct mutex *ldv_func_arg1)
{
  
#line 1511 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1512 
  return;
}


#line 1515  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_lock_141(struct mutex *ldv_func_arg1)
{
  
#line 1519 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1520 
  return;
}


#line 1523  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_142(struct mutex *ldv_func_arg1)
{
  
#line 1527 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1528 
  return;
}


#line 1531  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_lock_143(struct mutex *ldv_func_arg1)
{
  
#line 1535 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1536 
  return;
}


#line 1539  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_144(struct mutex *ldv_func_arg1)
{
  
#line 1543 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1544 
  return;
}


#line 1547  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_lock_145(struct mutex *ldv_func_arg1)
{
  
#line 1551 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1552 
  return;
}


#line 1555  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_146(struct mutex *ldv_func_arg1)
{
  
#line 1559 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1560 
  return;
}


#line 1563  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_lock_bh_147(spinlock_t *lock)
{
  
#line 1567 
  ldv_spin_model_lock((char *)"cc_lock_of_ath_common");
  
#line 1569 
  spin_lock_bh_5(lock);
  
#line 1570 
  return;
}


#line 1573  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_unlock_bh_148(spinlock_t *lock)
{
  
#line 1577 
  ldv_spin_model_unlock((char *)"cc_lock_of_ath_common");
  
#line 1579 
  spin_unlock_bh_5(lock);
  
#line 1580 
  return;
}


#line 1583  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_unlock_bh_149(spinlock_t *lock)
{
  
#line 1587 
  ldv_spin_model_unlock((char *)"cc_lock_of_ath_common");
  
#line 1589 
  spin_unlock_bh_5(lock);
  
#line 1590 
  return;
}


#line 1593  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_lock_150(struct mutex *ldv_func_arg1)
{
  
#line 1597 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1598 
  return;
}


#line 1601  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_151(struct mutex *ldv_func_arg1)
{
  
#line 1605 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1606 
  return;
}


#line 1609  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_lock_152(struct mutex *ldv_func_arg1)
{
  
#line 1613 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1614 
  return;
}


#line 1617  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_153(struct mutex *ldv_func_arg1)
{
  
#line 1621 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1622 
  return;
}


#line 1625  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_lock_bh_154(spinlock_t *lock)
{
  
#line 1629 
  ldv_spin_model_lock((char *)"chan_lock_of_ath_softc");
  
#line 1631 
  spin_lock_bh_5(lock);
  
#line 1632 
  return;
}


#line 1635  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_unlock_bh_155(spinlock_t *lock)
{
  
#line 1639 
  ldv_spin_model_unlock((char *)"chan_lock_of_ath_softc");
  
#line 1641 
  spin_unlock_bh_5(lock);
  
#line 1642 
  return;
}


#line 1645  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_lock_bh_156(spinlock_t *lock)
{
  
#line 1649 
  ldv_spin_model_lock((char *)"sc_pcu_lock_of_ath_softc");
  
#line 1651 
  spin_lock_bh_5(lock);
  
#line 1652 
  return;
}


#line 1655  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_unlock_bh_157(spinlock_t *lock)
{
  
#line 1659 
  ldv_spin_model_unlock((char *)"sc_pcu_lock_of_ath_softc");
  
#line 1661 
  spin_unlock_bh_5(lock);
  
#line 1662 
  return;
}


#line 1665  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static int ldv_del_timer_sync_158(struct timer_list *ldv_func_arg1)
{
  int tmp;
  
#line 1669 
  tmp = ldv_emg_del_timer_sync(ldv_func_arg1);
  
#line 1669 
  return tmp;
}


#line 1673  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static int ldv_del_timer_sync_159(struct timer_list *ldv_func_arg1)
{
  int tmp;
  
#line 1677 
  tmp = ldv_emg_del_timer_sync(ldv_func_arg1);
  
#line 1677 
  return tmp;
}


#line 1681  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_lock_160(struct mutex *ldv_func_arg1)
{
  
#line 1685 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1686 
  return;
}


#line 1689  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_161(struct mutex *ldv_func_arg1)
{
  
#line 1693 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1694 
  return;
}


#line 1697  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_lock_162(struct mutex *ldv_func_arg1)
{
  
#line 1701 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1702 
  return;
}


#line 1705  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static int ldv_del_timer_sync_163(struct timer_list *ldv_func_arg1)
{
  int tmp;
  
#line 1709 
  tmp = ldv_emg_del_timer_sync(ldv_func_arg1);
  
#line 1709 
  return tmp;
}


#line 1713  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_164(struct mutex *ldv_func_arg1)
{
  
#line 1717 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1718 
  return;
}


#line 1721  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_lock_165(struct mutex *ldv_func_arg1)
{
  
#line 1725 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1726 
  return;
}


#line 1729  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_166(struct mutex *ldv_func_arg1)
{
  
#line 1733 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1734 
  return;
}


#line 1737  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_lock_167(struct mutex *ldv_func_arg1)
{
  
#line 1741 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1742 
  return;
}


#line 1745  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static int ldv_del_timer_sync_168(struct timer_list *ldv_func_arg1)
{
  int tmp;
  
#line 1749 
  tmp = ldv_emg_del_timer_sync(ldv_func_arg1);
  
#line 1749 
  return tmp;
}


#line 1753  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_169(struct mutex *ldv_func_arg1)
{
  
#line 1757 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1758 
  return;
}


#line 1761  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_lock_170(struct mutex *ldv_func_arg1)
{
  
#line 1765 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1766 
  return;
}


#line 1769  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_171(struct mutex *ldv_func_arg1)
{
  
#line 1773 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1774 
  return;
}


#line 1777  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_172(struct mutex *ldv_func_arg1)
{
  
#line 1781 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1782 
  return;
}


#line 1785  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_lock_173(struct mutex *ldv_func_arg1)
{
  
#line 1789 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1790 
  return;
}


#line 1793  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_174(struct mutex *ldv_func_arg1)
{
  
#line 1797 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1798 
  return;
}


#line 1801  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_lock_175(struct mutex *ldv_func_arg1)
{
  
#line 1805 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1806 
  return;
}


#line 1809  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_176(struct mutex *ldv_func_arg1)
{
  
#line 1813 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1814 
  return;
}


#line 1817  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_lock_177(struct mutex *ldv_func_arg1)
{
  
#line 1821 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1822 
  return;
}


#line 1825  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_178(struct mutex *ldv_func_arg1)
{
  
#line 1829 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1830 
  return;
}


#line 1833  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_lock_179(struct mutex *ldv_func_arg1)
{
  
#line 1837 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1838 
  return;
}


#line 1841  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_180(struct mutex *ldv_func_arg1)
{
  
#line 1845 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1846 
  return;
}


#line 1849  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_lock_181(struct mutex *ldv_func_arg1)
{
  
#line 1853 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1854 
  return;
}


#line 1857  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_lock_bh_182(spinlock_t *lock)
{
  
#line 1861 
  ldv_spin_model_lock((char *)"chan_lock_of_ath_softc");
  
#line 1863 
  spin_lock_bh_5(lock);
  
#line 1864 
  return;
}


#line 1867  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_unlock_bh_183(spinlock_t *lock)
{
  
#line 1871 
  ldv_spin_model_unlock((char *)"chan_lock_of_ath_softc");
  
#line 1873 
  spin_unlock_bh_5(lock);
  
#line 1874 
  return;
}


#line 1877  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_lock_bh_184(spinlock_t *lock)
{
  
#line 1881 
  ldv_spin_model_lock((char *)"chan_lock_of_ath_softc");
  
#line 1883 
  spin_lock_bh_5(lock);
  
#line 1884 
  return;
}


#line 1887  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_unlock_bh_185(spinlock_t *lock)
{
  
#line 1891 
  ldv_spin_model_unlock((char *)"chan_lock_of_ath_softc");
  
#line 1893 
  spin_unlock_bh_5(lock);
  
#line 1894 
  return;
}


#line 1897  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_186(struct mutex *ldv_func_arg1)
{
  
#line 1901 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1902 
  return;
}


#line 1905  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_lock_bh_187(spinlock_t *lock)
{
  
#line 1909 
  ldv_spin_model_lock((char *)"chan_lock_of_ath_softc");
  
#line 1911 
  spin_lock_bh_5(lock);
  
#line 1912 
  return;
}


#line 1915  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_unlock_bh_188(spinlock_t *lock)
{
  
#line 1919 
  ldv_spin_model_unlock((char *)"chan_lock_of_ath_softc");
  
#line 1921 
  spin_unlock_bh_5(lock);
  
#line 1922 
  return;
}


#line 1925  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_lock_189(struct mutex *ldv_func_arg1)
{
  
#line 1929 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1930 
  return;
}


#line 1933  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_lock_bh_190(spinlock_t *lock)
{
  
#line 1937 
  ldv_spin_model_lock((char *)"chan_lock_of_ath_softc");
  
#line 1939 
  spin_lock_bh_5(lock);
  
#line 1940 
  return;
}


#line 1943  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_spin_unlock_bh_191(spinlock_t *lock)
{
  
#line 1947 
  ldv_spin_model_unlock((char *)"chan_lock_of_ath_softc");
  
#line 1949 
  spin_unlock_bh_5(lock);
  
#line 1950 
  return;
}


#line 1953  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_192(struct mutex *ldv_func_arg1)
{
  
#line 1957 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1958 
  return;
}


#line 1961  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_lock_193(struct mutex *ldv_func_arg1)
{
  
#line 1965 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1966 
  return;
}


#line 1969  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_mutex_unlock_194(struct mutex *ldv_func_arg1)
{
  
#line 1973 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_ath_softc");
  
#line 1974 
  return;
}


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_add(int i, atomic_t *v)
{
  
#line 23 
  v->counter += i;
  
#line 24 
  return;
}


#line 27  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_sub(int i, atomic_t *v)
{
  
#line 29 
  v->counter -= i;
  
#line 30 
  return;
}


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_sub_and_test(int i, atomic_t *v)
{
  int __retres;
  
#line 35 
  v->counter -= i;
  
#line 36 
  if (v->counter != 0) {
    
#line 37 
    __retres = 0;
    
#line 37 
    goto return_label;
  }
  else ;
  
#line 39 
  __retres = 1;
  return_label: 
#line 39 
                return __retres;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_inc(atomic_t *v)
{
  
#line 45 
  v->counter += 1;
  
#line 46 
  return;
}


#line 49  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_dec(atomic_t *v)
{
  
#line 51 
  v->counter -= 1;
  
#line 52 
  return;
}


#line 55  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_dec_and_test(atomic_t *v)
{
  int __retres;
  
#line 57 
  v->counter -= 1;
  
#line 58 
  if (v->counter != 0) {
    
#line 59 
    __retres = 0;
    
#line 59 
    goto return_label;
  }
  else ;
  
#line 61 
  __retres = 1;
  return_label: 
#line 61 
                return __retres;
}


#line 65  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_inc_and_test(atomic_t *v)
{
  int __retres;
  
#line 67 
  v->counter += 1;
  
#line 68 
  if (v->counter != 0) {
    
#line 69 
    __retres = 0;
    
#line 69 
    goto return_label;
  }
  else ;
  
#line 71 
  __retres = 1;
  return_label: 
#line 71 
                return __retres;
}


#line 75  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_add_return(int i, atomic_t *v)
{
  int __retres;
  
#line 77 
  v->counter += i;
  
#line 78 
  __retres = v->counter;
  
#line 78 
  return __retres;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_add_negative(int i, atomic_t *v)
{
  int __retres;
  
#line 84 
  v->counter += i;
  
#line 85 
  __retres = v->counter < 0;
  
#line 85 
  return __retres;
}


#line 89  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_inc_short(short *v)
{
  int __retres;
  
#line 91 
  *v = (short)((unsigned int)*v + 1U);
  
#line 92 
  __retres = (int)*v;
  
#line 92 
  return __retres;
}


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/device.h"
void *ldv_dev_get_drvdata(struct device const *dev);


#line 24 
int ldv_dev_set_drvdata(struct device *dev, void *data);


#line 30  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_xmalloc(size_t size);


#line 31 
void *ldv_xzalloc(size_t size);


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
struct ldv_list_element global_list = {.data = (void *)0, .next = (struct ldv_list_element *)0};

#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
__inline static ldv_list_ptr ldv_list_create(void *data)
{
  
#line 35 
  ldv_list_ptr list = (struct ldv_list_element *)0;
  
#line 37 
  list = (ldv_list_ptr)ldv_xmalloc(16UL);
  
#line 39 
  list->data = data;
  
#line 40 
  list->next = (struct ldv_list_element *)0;
  
#line 42 
  return list;
}


#line 45  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
__inline static void ldv_save_pointer(void *data)
{
  ldv_list_ptr element;
  ldv_list_ptr cached;
  
#line 50 
  if (global_list.data == (void *)0) {
    
#line 51 
    element = & global_list;
    
#line 52 
    element->data = data;
  }
  else {
    
#line 54 
    element = ldv_list_create(data);
    
#line 55 
    cached = global_list.next;
    
#line 56 
    global_list.next = element;
    
#line 57 
    element->next = cached;
  }
  
#line 60 
  return;
}


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
void *ldv_dev_get_drvdata(struct device const *dev)
{
  void *__retres;
  
#line 30 
  if (dev != (struct device const *)0 && dev->p != (struct device_private *)0) {
    
#line 31 
    __retres = (dev->p)->driver_data;
    
#line 31 
    goto return_label;
  }
  else ;
  
#line 33 
  __retres = (void *)0;
  return_label: 
#line 33 
                return __retres;
}


#line 42  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
int ldv_dev_set_drvdata(struct device *dev, void *data)
{
  int __retres;
  
#line 44 
  dev->p = (struct device_private *)ldv_xzalloc(8UL);
  
#line 45 
  ldv_save_pointer((void *)dev->p);
  
#line 46 
  (dev->p)->driver_data = data;
  
#line 48 
  __retres = 0;
  
#line 48 
  return __retres;
}


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_zalloc(size_t size);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/spi.c"
struct spi_master *ldv_spi_alloc_master(struct device *host, unsigned int size)
{
  struct spi_master *__retres;
  struct spi_master *master;
  
#line 27 
  master = (struct spi_master *)ldv_zalloc((unsigned long)size + 2192UL);
  
#line 29 
  if (master == (struct spi_master *)0) {
    
#line 30 
    __retres = (struct spi_master *)0;
    
#line 30 
    goto return_label;
  }
  else ;
  
#line 32 
  ldv_dev_set_drvdata(& master->dev,(void *)(master + 1U));
  
#line 34 
  __retres = master;
  return_label: 
#line 34 
                return __retres;
}


#line 27  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/err.h"
long ldv_is_err(void const *ptr);


#line 28 
long ldv_is_err_or_null(void const *ptr);


#line 29 
void *ldv_err_ptr(long error);


#line 30 
long ldv_ptr_err(void const *ptr);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/common.h"
void __VERIFIER_assume(int);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_is_err(void const *ptr)
{
  long __retres;
  
#line 23 
  __retres = (long)((unsigned long)ptr > 4294967295UL);
  
#line 23 
  return __retres;
}


#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
void *ldv_err_ptr(long error)
{
  void *__retres;
  
#line 28 
  __VERIFIER_assume(error < 0L);
  
#line 29 
  __retres = (void *)(4294967295L - error);
  
#line 29 
  return __retres;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_ptr_err(void const *ptr)
{
  long __retres;
  
#line 34 
  __VERIFIER_assume((unsigned long)ptr > 4294967295UL);
  
#line 35 
  __retres = (long)(4294967295UL - (unsigned long)ptr);
  
#line 35 
  return __retres;
}


#line 38  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_is_err_or_null(void const *ptr)
{
  long __retres;
  int tmp_0;
  
#line 40 
  if (ptr == (void const *)0) 
#line 40 
                              tmp_0 = 1;
  else {
    long tmp;
    
#line 40 
    tmp = ldv_is_err(ptr);
    
#line 40 
    if (tmp != 0L) 
#line 40 
                   tmp_0 = 1; else 
#line 40 
                                   tmp_0 = 0;
  }
  
#line 40 
  __retres = (long)tmp_0;
  
#line 40 
  return __retres;
}


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/panic.h"
void ldv_panic(void);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/kernel/panic.c"
void ldv_panic(void)
{
  
#line 23 
  __VERIFIER_assume(0);
  
#line 24 
  return;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.h"
void ldv_switch_to_interrupt_context(void);


#line 42 
void ldv_switch_to_process_context(void);


#line 50 
bool ldv_in_interrupt_context(void);


#line 112 
int ldv_post_init(int init_ret_val);


#line 132 
int ldv_post_probe(int probe_ret_val);


#line 133 
void ldv_check_return_value_probe(int);


#line 141 
int ldv_filter_err_code(int ret_val);


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
static bool __ldv_in_interrupt_context = (_Bool)0;

#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
void ldv_switch_to_interrupt_context(void)
{
  
#line 30 
  __ldv_in_interrupt_context = (_Bool)1;
  
#line 31 
  return;
}


#line 34  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
void ldv_switch_to_process_context(void)
{
  
#line 36 
  __ldv_in_interrupt_context = (_Bool)0;
  
#line 37 
  return;
}


#line 39  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
bool ldv_in_interrupt_context(void)
{
  
#line 41 
  return __ldv_in_interrupt_context;
}


#line 44  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
static int ldv_filter_positive_int(int val)
{
  
#line 46 
  __VERIFIER_assume(val <= 0);
  
#line 47 
  return val;
}


#line 54  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_post_init(int init_ret_val)
{
  int tmp;
  
#line 56 
  tmp = ldv_filter_positive_int(init_ret_val);
  
#line 56 
  return tmp;
}


#line 60  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_post_probe(int probe_ret_val)
{
  int tmp;
  
#line 62 
  ldv_check_return_value_probe(probe_ret_val);
  
#line 63 
  tmp = ldv_filter_positive_int(probe_ret_val);
  
#line 63 
  return tmp;
}


#line 67  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_filter_err_code(int ret_val)
{
  int tmp;
  
#line 69 
  tmp = ldv_filter_positive_int(ret_val);
  
#line 69 
  return tmp;
}


#line 24  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kmalloc(size_t size, gfp_t flags);


#line 25 
void *ldv_kcalloc(size_t n, size_t size, gfp_t flags);


#line 26 
void *ldv_kmalloc_array(size_t n, size_t size, gfp_t flags);


#line 28 
void ldv_check_alloc_flags(gfp_t);


#line 29 
void ldv_after_alloc(void *);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_malloc(size_t size);


#line 24 
void *ldv_calloc(size_t nmemb, size_t size);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc(size_t size, gfp_t flags)
{
  void *res;
  
#line 25 
  ldv_check_alloc_flags(flags);
  
#line 26 
  res = ldv_malloc(size);
  
#line 27 
  ldv_after_alloc(res);
  
#line 29 
  return res;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kcalloc(size_t n, size_t size, gfp_t flags)
{
  void *res;
  
#line 36 
  ldv_check_alloc_flags(flags);
  
#line 37 
  res = ldv_calloc(n,size);
  
#line 38 
  ldv_after_alloc(res);
  
#line 40 
  return res;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kzalloc(size_t size, gfp_t flags)
{
  void *res;
  
#line 47 
  ldv_check_alloc_flags(flags);
  
#line 48 
  res = ldv_zalloc(size);
  
#line 49 
  ldv_after_alloc(res);
  
#line 51 
  return res;
}


#line 54  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc_array(size_t n, size_t size, gfp_t flags)
{
  void *res;
  
#line 58 
  ldv_check_alloc_flags(flags);
  
#line 59 
  res = ldv_malloc(n * size);
  
#line 60 
  ldv_after_alloc(res);
  
#line 62 
  return res;
}


#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void ldv_free(void *s);


#line 35 
void *ldv_malloc_unknown_size(void);


#line 36 
void *ldv_calloc_unknown_size(void);


#line 37 
void *ldv_zalloc_unknown_size(void);


#line 40 
void *ldv_reference_malloc(size_t size);


#line 41 
void *ldv_reference_calloc(size_t nmemb, size_t size);


#line 42 
void *ldv_reference_zalloc(size_t size);


#line 43 
void ldv_reference_free(void *s);


#line 47 
void *ldv_reference_xmalloc(size_t size);


#line 48 
void *ldv_reference_xzalloc(size_t size);


#line 52 
void *ldv_reference_malloc_unknown_size(void);


#line 53 
void *ldv_reference_calloc_unknown_size(void);


#line 54 
void *ldv_reference_zalloc_unknown_size(void);


#line 61 
void *ldv_xmalloc_unknown_size(size_t size);


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_reference_xmalloc_unknown_size(size_t size);


#line 34  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_malloc(size_t size)
{
  void *res;
  
#line 37 
  res = ldv_reference_malloc(size);
  
#line 38 
  if (res != (void *)0) {
    long tmp;
    
#line 39 
    tmp = ldv_is_err((void const *)res);
    
#line 39 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 40 
  return res;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc(size_t nmemb, size_t size)
{
  void *res;
  
#line 46 
  res = ldv_reference_calloc(nmemb,size);
  
#line 47 
  if (res != (void *)0) {
    long tmp;
    
#line 48 
    tmp = ldv_is_err((void const *)res);
    
#line 48 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 49 
  return res;
}


#line 52  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc(size_t size)
{
  void *res;
  
#line 55 
  res = ldv_reference_zalloc(size);
  
#line 56 
  if (res != (void *)0) {
    long tmp;
    
#line 57 
    tmp = ldv_is_err((void const *)res);
    
#line 57 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 58 
  return res;
}


#line 61  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void ldv_free(void *s)
{
  
#line 63 
  ldv_reference_free(s);
  
#line 64 
  return;
}


#line 66  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc(size_t size)
{
  void *res;
  long tmp;
  
#line 69 
  res = ldv_reference_xmalloc(size);
  
#line 70 
  tmp = ldv_is_err((void const *)res);
  
#line 70 
  __VERIFIER_assume(tmp == 0L);
  
#line 71 
  return res;
}


#line 74  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xzalloc(size_t size)
{
  void *res;
  long tmp;
  
#line 77 
  res = ldv_reference_xzalloc(size);
  
#line 78 
  tmp = ldv_is_err((void const *)res);
  
#line 78 
  __VERIFIER_assume(tmp == 0L);
  
#line 79 
  return res;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_malloc_unknown_size(void)
{
  void *res;
  
#line 85 
  res = ldv_reference_malloc_unknown_size();
  
#line 86 
  if (res != (void *)0) {
    long tmp;
    
#line 87 
    tmp = ldv_is_err((void const *)res);
    
#line 87 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 88 
  return res;
}


#line 91  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc_unknown_size(void)
{
  void *res;
  
#line 94 
  res = ldv_reference_calloc_unknown_size();
  
#line 95 
  if (res != (void *)0) {
    long tmp;
    
#line 96 
    tmp = ldv_is_err((void const *)res);
    
#line 96 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 97 
  return res;
}


#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc_unknown_size(void)
{
  void *res;
  
#line 103 
  res = ldv_reference_zalloc_unknown_size();
  
#line 104 
  if (res != (void *)0) {
    long tmp;
    
#line 105 
    tmp = ldv_is_err((void const *)res);
    
#line 105 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 106 
  return res;
}


#line 109  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc_unknown_size(size_t size)
{
  void *res;
  long tmp;
  
#line 112 
  res = ldv_reference_xmalloc_unknown_size(size);
  
#line 113 
  tmp = ldv_is_err((void const *)res);
  
#line 113 
  __VERIFIER_assume(tmp == 0L);
  
#line 114 
  return res;
}

long __builtin_expect(long exp, long c);


#line 22  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/common.h"
void __VERIFIER_error(void);


#line 24  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/gcc.c"
long __builtin_expect(long exp, long c)
{
  
#line 26 
  return exp;
}


#line 35  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/gcc.c"
void __builtin_trap(void)
{
  
#line 37 
  __VERIFIER_error();
  
#line 38 
  return;
}


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
int ldv_undef_int(void);


#line 24 
int ldv_undef_long(void);


#line 25 
unsigned int ldv_undef_uint(void);


#line 26 
unsigned long ldv_undef_ulong(void);


#line 27 
unsigned long long ldv_undef_ulonglong(void);


#line 28 
void *ldv_undef_ptr(void);


#line 31 
int ldv_undef_int_positive(void);


#line 34 
int ldv_undef_int_negative(void);


#line 37 
int ldv_undef_int_nonpositive(void);


#line 40 
void *ldv_undef_ptr_non_null(void);


#line 29  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int __VERIFIER_nondet_int(void);


#line 31 
long __VERIFIER_nondet_long(void);


#line 38 
unsigned int __VERIFIER_nondet_uint(void);


#line 41 
unsigned long __VERIFIER_nondet_ulong(void);


#line 42 
unsigned long long __VERIFIER_nondet_ulonglong(void);


#line 43 
void *__VERIFIER_nondet_pointer(void);


#line 46  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int(void)
{
  int tmp;
  
#line 48 
  tmp = __VERIFIER_nondet_int();
  
#line 48 
  return tmp;
}


#line 51  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_long(void)
{
  int __retres;
  long tmp;
  
#line 53 
  tmp = __VERIFIER_nondet_long();
  
#line 53 
  __retres = (int)tmp;
  
#line 53 
  return __retres;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned int ldv_undef_uint(void)
{
  unsigned int tmp;
  
#line 58 
  tmp = __VERIFIER_nondet_uint();
  
#line 58 
  return tmp;
}


#line 61  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr(void)
{
  void *tmp;
  
#line 63 
  tmp = __VERIFIER_nondet_pointer();
  
#line 63 
  return tmp;
}


#line 66  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long ldv_undef_ulong(void)
{
  unsigned long tmp;
  
#line 68 
  tmp = __VERIFIER_nondet_ulong();
  
#line 68 
  return tmp;
}


#line 71  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long long ldv_undef_ulonglong(void)
{
  unsigned long long tmp;
  
#line 73 
  tmp = __VERIFIER_nondet_ulonglong();
  
#line 73 
  return tmp;
}


#line 76  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_positive(void)
{
  
#line 78 
  int ret = ldv_undef_int();
  
#line 80 
  __VERIFIER_assume(ret > 0);
  
#line 82 
  return ret;
}


#line 85  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_negative(void)
{
  
#line 87 
  int ret = ldv_undef_int();
  
#line 89 
  __VERIFIER_assume(ret < 0);
  
#line 91 
  return ret;
}


#line 94  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_nonpositive(void)
{
  
#line 96 
  int ret = ldv_undef_int();
  
#line 98 
  __VERIFIER_assume(ret <= 0);
  
#line 100 
  return ret;
}


#line 103  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr_non_null(void)
{
  
#line 105 
  void *ret = ldv_undef_ptr();
  
#line 107 
  __VERIFIER_assume(ret != (void *)0);
  
#line 109 
  return ret;
}


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *external_allocated_data(void);


#line 45 
void *ldv_reference_realloc(void *ptr, size_t size);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *malloc(size_t);


#line 24 
void *calloc(size_t, size_t);


#line 25 
void free(void *);


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc(size_t size)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 37 
  tmp = ldv_undef_int();
  
#line 37 
  if (tmp != 0) {
    
#line 39 
    res = malloc(size);
    
#line 40 
    __VERIFIER_assume(res != (void *)0);
    
#line 41 
    __retres = res;
    
#line 41 
    goto return_label;
  }
  else {
    
#line 44 
    __retres = (void *)0;
    
#line 44 
    goto return_label;
  }
  return_label: 
#line 37 
                return __retres;
}


#line 47  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc(size_t nmemb, size_t size)
{
  void *tmp;
  
#line 49 
  tmp = calloc(nmemb,size);
  
#line 49 
  return tmp;
}


#line 52  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc(size_t size)
{
  void *tmp;
  
#line 54 
  tmp = calloc(1UL,size);
  
#line 54 
  return tmp;
}


#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void ldv_reference_free(void *s)
{
  
#line 59 
  free(s);
  
#line 60 
  return;
}


#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_realloc(void *ptr, size_t size)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 66 
  if (ptr != (void *)0 && size == 0UL) {
    
#line 67 
    free(ptr);
    
#line 68 
    __retres = (void *)0;
    
#line 68 
    goto return_label;
  }
  else ;
  
#line 71 
  if (ptr == (void *)0) {
    
#line 72 
    res = malloc(size);
    
#line 73 
    __retres = res;
    
#line 73 
    goto return_label;
  }
  else ;
  
#line 76 
  tmp = ldv_undef_int();
  
#line 76 
  if (tmp != 0) {
    
#line 78 
    res = malloc(size);
    
#line 79 
    __VERIFIER_assume(res != (void *)0);
    
#line 81 
    memcpy(res,(void const *)ptr,size);
    
#line 82 
    free(ptr);
    
#line 84 
    __retres = res;
    
#line 84 
    goto return_label;
  }
  else {
    
#line 87 
    __retres = (void *)0;
    
#line 87 
    goto return_label;
  }
  return_label: 
#line 76 
                return __retres;
}


#line 90  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc(size_t size)
{
  void *res;
  
#line 94 
  res = malloc(size);
  
#line 95 
  __VERIFIER_assume(res != (void *)0);
  
#line 97 
  return res;
}


#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xzalloc(size_t size)
{
  void *res;
  
#line 104 
  res = calloc(1UL,size);
  
#line 105 
  __VERIFIER_assume(res != (void *)0);
  
#line 107 
  return res;
}


#line 110  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc_unknown_size(void)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 114 
  tmp = ldv_undef_int();
  
#line 114 
  if (tmp != 0) {
    
#line 115 
    res = external_allocated_data();
    
#line 116 
    __VERIFIER_assume(res != (void *)0);
    
#line 117 
    __retres = res;
    
#line 117 
    goto return_label;
  }
  else {
    
#line 120 
    __retres = (void *)0;
    
#line 120 
    goto return_label;
  }
  return_label: 
#line 114 
                return __retres;
}


#line 123  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc_unknown_size(void)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 127 
  tmp = ldv_undef_int();
  
#line 127 
  if (tmp != 0) {
    
#line 128 
    res = external_allocated_data();
    
#line 129 
    memset(res,0,8UL);
    
#line 130 
    __VERIFIER_assume(res != (void *)0);
    
#line 131 
    __retres = res;
    
#line 131 
    goto return_label;
  }
  else {
    
#line 134 
    __retres = (void *)0;
    
#line 134 
    goto return_label;
  }
  return_label: 
#line 127 
                return __retres;
}


#line 137  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc_unknown_size(void)
{
  void *tmp;
  
#line 139 
  tmp = ldv_reference_calloc_unknown_size();
  
#line 139 
  return tmp;
}


#line 142  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc_unknown_size(size_t size)
{
  void *res;
  
#line 146 
  res = external_allocated_data();
  
#line 147 
  __VERIFIER_assume(res != (void *)0);
  
#line 149 
  return res;
}


#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.h"
void ldv_initialize(void);


#line 123 
void ldv_pre_probe(void);


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
int pthread_create(pthread_t *, pthread_attr_t const *, void *(*)(void *), void *);


#line 37 
int pthread_join(pthread_t, void **);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/err.h"
__inline static void *ERR_PTR(long error)
{
  void *__retres;
  
#line 25 
  __retres = (void *)error;
  
#line 25 
  return __retres;
}


#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rtnetlink.h"
void rtnl_lock(void);


#line 28 
void rtnl_unlock(void);


#line 166  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_15(void *arg0);


#line 167 
void ldv_dispatch_deregister_3_1(struct platform_driver *arg0);


#line 169 
void ldv_dispatch_register_9_3(struct platform_driver *arg0);


#line 170 
void *ldv_character_driver_scenario_34(void *arg0);


#line 171 
void *ldv_character_driver_scenario_38(void *arg0);


#line 172 
void ldv_dispatch_irq_register_14_3(int arg0, enum irqreturn (*arg1)(int , void *), enum irqreturn (*arg2)(int , void *), void *arg3);


#line 173 
void *ldv_character_driver_scenario_22(void *arg0);


#line 175 
void *ldv_character_driver_scenario_23(void *arg0);


#line 176 
void ldv_dispatch_irq_deregister_5_1(int arg0);


#line 177 
void *ldv_character_driver_scenario_29(void *arg0);


#line 178 
void ldv_dispatch_deregister_7_1(struct pci_driver *arg0);


#line 179 
void *ldv_character_driver_scenario_37(void *arg0);


#line 180 
void *ldv_initialization_1(void *arg0);


#line 181 
void ldv_dispatch_instance_deregister_11_1(struct timer_list *arg0);


#line 182 
void *ldv_character_driver_scenario_16(void *arg0);


#line 183 
void *ldv_interrupt_scenario_35(void *arg0);


#line 185 
void ldv_dispatch_register_4_3(struct ieee80211_hw *arg0);


#line 186 
void *ldv_pci_scenario_17(void *arg0);


#line 187 
void *ldv_platform_instance_33(void *arg0);


#line 188 
void ldv_dispatch_pm_deregister_33_12(void);


#line 189 
void *ldv_character_driver_scenario_25(void *arg0);


#line 190 
void ldv_dispatch_deregister_12_2(struct ieee80211_hw *arg0);


#line 191 
void *ldv_ieee80211_scenario_19(void *arg0);


#line 192 
void *ldv_character_driver_scenario_26(void *arg0);


#line 196 
void ldv_dispatch_instance_register_2_3(struct timer_list *arg0);


#line 197 
void *ldv_pm_ops_scenario_20(void *arg0);


#line 198 
void *ldv_character_driver_scenario_30(void *arg0);


#line 200 
void ldv_dispatch_register_8_3(struct pci_driver *arg0);


#line 201 
void *ldv_timer_scenario_21(void *arg0);


#line 202 
void *ldv_character_driver_scenario_36(void *arg0);


#line 203 
void ldv_dispatch_pm_register_33_13(void);


#line 204 
void *ldv_character_driver_scenario_18(void *arg0);


#line 205 
int main(void);


#line 206 
void *ldv_character_driver_scenario_32(void *arg0);


#line 207 
void *ldv_character_driver_scenario_28(void *arg0);


#line 208 
void ldv_dispatch_register_13_3(struct file_operations *arg0);


#line 210 
void *ldv_character_driver_scenario_24(void *arg0);


#line 211 
void *ldv_character_driver_scenario_27(void *arg0);


#line 213 
void *ldv_character_driver_scenario_31(void *arg0);


#line 218  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_33;

#line 219  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_21;

#line 220  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_37;

#line 221  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_36;

#line 222  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_16;

#line 223  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_31;

#line 224  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_35;

#line 225  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_22;

#line 226  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_34;

#line 227  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_25;

#line 228  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_20;

#line 229  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_18;

#line 230  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_38;

#line 231  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_19;

#line 232  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_24;

#line 233  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_15;

#line 234  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_28;

#line 235  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_23;

#line 236  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_17;

#line 237  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_29;

#line 238  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_32;

#line 239  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_26;

#line 240  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_27;

#line 241  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_30;

#line 245  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_del_timer_sync(struct timer_list *arg0)
{
  int __retres;
  struct timer_list *ldv_11_timer_list;
  
#line 251 
  ldv_11_timer_list = arg0;
  
#line 255 
  ldv_dispatch_instance_deregister_11_1(ldv_11_timer_list);
  
#line 256 
  ;
  
#line 256 
  __retres = 0;
  
#line 256 
  return __retres;
}


#line 264  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_tasklet_init(struct tasklet_struct *arg0, void (*arg1)(unsigned long ), unsigned long arg2)
{
  
#line 269 
  arg0->func = arg1;
  
#line 270 
  arg0->data = arg2;
  
#line 271 
  arg0->count.counter = 0;
  
#line 275 
  goto return_label;
  return_label: 
#line 277 
                return;
}


#line 282  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_15(void *arg0)
{
  void *__retres;
  struct file *ldv_15_resource_1;
  int ldv_15_ldv_param_2_3;
  long long ldv_15_ldv_param_1_2;
  char *ldv_15_ldv_param_1_4;
  struct inode *ldv_15_resource_0;
  unsigned long ldv_15_size_cnt;
  long long *ldv_15_ldv_param_3_5;
  char *ldv_15_ldv_param_1_6;
  long long *ldv_15_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 293 
  struct file_operations *ldv_15_container = ldv_emg_alias_fops_tx99_2;
  
#line 294 
  int ldv_15_ret = ldv_undef_int();
  
#line 297 
  struct ldv_struct_character_driver_scenario_15 *data = (struct ldv_struct_character_driver_scenario_15 *)arg0;
  
#line 301 
  ldv_15_ret = ldv_undef_int();
  
#line 304 
  if (data != (struct ldv_struct_character_driver_scenario_15 *)0) {
    
#line 305 
    ldv_15_container = data->arg0;
    
#line 306 
    ldv_free((void *)data);
  }
  else ;
  
#line 311 
  ldv_15_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 312 
  tmp_1 = ldv_undef_int();
  
#line 312 
  ldv_15_size_cnt = (unsigned long)tmp_1;
  
#line 319 
  goto ldv_main_15;
  
#line 321 
  __retres = (void *)0;
  
#line 321 
  goto return_label;
  ldv_main_15: 
#line 324 
  ;
  
#line 327 
  tmp_3 = ldv_undef_int();
  
#line 327 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 330 
    ldv_15_ret = (*ldv_emg_alias_simple_open_5)(ldv_15_resource_0,ldv_15_resource_1);
    
#line 332 
    ldv_15_ret = ldv_filter_err_code(ldv_15_ret);
    
#line 335 
    tmp_2 = ldv_undef_int();
    
#line 335 
    if (tmp_2 != 0) {
      
#line 337 
      __VERIFIER_assume(ldv_15_ret == 0);
      
#line 344 
      goto ldv_call_15;
    }
    else {
      
#line 348 
      __VERIFIER_assume(ldv_15_ret != 0);
      
#line 355 
      goto ldv_main_15;
    }
  }
  else {
    
#line 360 
    ldv_free((void *)ldv_15_resource_0);
    
#line 368 
    __retres = (void *)0;
    
#line 368 
    goto return_label;
  }
  
#line 371 
  __retres = (void *)0;
  
#line 371 
  goto return_label;
  ldv_call_15: 
#line 374 
  ;
  
#line 377 
  tmp_4 = ldv_undef_int();
  
#line 377 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 378 
    ;
    
#line 380 
    ldv_15_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 381 
    ldv_15_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 390 
    __VERIFIER_assume(ldv_15_size_cnt <= 2147479552UL);
    
#line 392 
    ldv_emg_wrapper_write_file_tx99_4(ldv_15_resource_1,ldv_15_ldv_param_1_6,ldv_15_size_cnt,ldv_15_ldv_param_3_7);
    
#line 396 
    ldv_free((void *)ldv_15_ldv_param_3_7);
    
#line 397 
    ldv_free((void *)ldv_15_ldv_param_1_6);
    
#line 404 
    goto ldv_call_15;
    case 2: 
#line 407 
    ;
    
#line 409 
    if (ldv_15_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 411 
      (*(ldv_15_container->release))(ldv_15_resource_0,ldv_15_resource_1); else ;
    
#line 419 
    goto ldv_main_15;
    case 3: 
#line 422 
    ;
    
#line 426 
    tmp_9 = ldv_undef_int();
    
#line 426 
    if (tmp_9 != 0) 
#line 429 
                    (*ldv_emg_alias_default_llseek_3)(ldv_15_resource_1,ldv_15_ldv_param_1_2,ldv_15_ldv_param_2_3);
    else {
      
#line 435 
      ldv_15_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 436 
      ldv_15_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 441 
      ldv_emg_wrapper_read_file_tx99_3(ldv_15_resource_1,ldv_15_ldv_param_1_4,ldv_15_size_cnt,ldv_15_ldv_param_3_5);
      
#line 445 
      ldv_free((void *)ldv_15_ldv_param_1_4);
      
#line 446 
      ldv_free((void *)ldv_15_ldv_param_3_5);
    }
    
#line 450 
    goto ldv_52043;
    default: 
#line 452 
    ;
    
#line 452 
    __VERIFIER_assume(0);
  }
  ldv_52043: 
#line 461 
  ;
  
#line 461 
  goto ldv_call_15;
  
#line 463 
  __retres = (void *)0;
  return_label: 
#line 463 
                return __retres;
}


#line 468  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_deregister_3_1(struct platform_driver *arg0)
{
  int ret;
  struct ldv_struct_platform_instance_33 *cf_arg_33;
  int tmp;
  
#line 471 
  tmp = ldv_undef_int();
  
#line 471 
  switch (tmp) {
    case 0: 
#line 472 
    ;
    
#line 473 
    ret = pthread_join(ldv_thread_33,(void **)0);
    
#line 474 
    __VERIFIER_assume(ret == 0);
    
#line 475 
    goto ldv_52051;
    default: 
#line 477 
    ;
    
#line 477 
    __VERIFIER_assume(0);
  }
  ldv_52051: 
#line 478 
  ;
  
#line 479 
  return;
}


#line 483  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg___pci_register_driver(struct pci_driver *arg0, struct module *arg1, char *arg2)
{
  int __retres;
  int tmp_0;
  
#line 486 
  struct pci_driver *ldv_8_pci_driver = ldv_emg_alias_ath_pci_driver_2;
  
#line 490 
  tmp_0 = ldv_undef_int();
  
#line 490 
  if (tmp_0 != 0) {
    
#line 492 
    ldv_8_pci_driver = arg0;
    
#line 496 
    ldv_dispatch_register_8_3(ldv_8_pci_driver);
    
#line 500 
    __retres = 0;
    
#line 500 
    goto return_label;
  }
  else {
    int tmp;
    
#line 507 
    tmp = ldv_undef_int_negative();
    
#line 507 
    __retres = tmp;
    
#line 507 
    goto return_label;
  }
  return_label: 
#line 490 
                return __retres;
}


#line 517  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_register_9_3(struct platform_driver *arg0)
{
  int ret;
  struct ldv_struct_platform_instance_33 *cf_arg_33;
  int tmp;
  
#line 520 
  tmp = ldv_undef_int();
  
#line 520 
  switch (tmp) {
    case 0: 
#line 521 
    ;
    
#line 522 
    cf_arg_33 = (struct ldv_struct_platform_instance_33 *)ldv_xmalloc(16UL);
    
#line 523 
    cf_arg_33->arg0 = arg0;
    
#line 524 
    ret = pthread_create(& ldv_thread_33,(pthread_attr_t const *)0,& ldv_platform_instance_33,(void *)cf_arg_33);
    
#line 525 
    __VERIFIER_assume(ret == 0);
    
#line 526 
    goto ldv_52065;
    default: 
#line 528 
    ;
    
#line 528 
    __VERIFIER_assume(0);
  }
  ldv_52065: 
#line 529 
  ;
  
#line 530 
  return;
}


#line 534  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_34(void *arg0)
{
  void *__retres;
  struct file *ldv_34_resource_1;
  int ldv_34_ldv_param_2_3;
  long long ldv_34_ldv_param_1_2;
  char *ldv_34_ldv_param_1_4;
  struct inode *ldv_34_resource_0;
  unsigned long ldv_34_size_cnt;
  long long *ldv_34_ldv_param_3_5;
  char *ldv_34_ldv_param_1_6;
  long long *ldv_34_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 545 
  struct file_operations *ldv_34_container = ldv_emg_alias_fops_regval_2;
  
#line 546 
  int ldv_34_ret = ldv_undef_int();
  
#line 549 
  struct ldv_struct_character_driver_scenario_15 *data = (struct ldv_struct_character_driver_scenario_15 *)arg0;
  
#line 553 
  ldv_34_ret = ldv_undef_int();
  
#line 556 
  if (data != (struct ldv_struct_character_driver_scenario_15 *)0) {
    
#line 557 
    ldv_34_container = data->arg0;
    
#line 558 
    ldv_free((void *)data);
  }
  else ;
  
#line 563 
  ldv_34_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 564 
  tmp_1 = ldv_undef_int();
  
#line 564 
  ldv_34_size_cnt = (unsigned long)tmp_1;
  
#line 571 
  goto ldv_main_34;
  
#line 573 
  __retres = (void *)0;
  
#line 573 
  goto return_label;
  ldv_main_34: 
#line 576 
  ;
  
#line 579 
  tmp_3 = ldv_undef_int();
  
#line 579 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 582 
    ldv_34_ret = (*ldv_emg_alias_simple_open_5)(ldv_34_resource_0,ldv_34_resource_1);
    
#line 584 
    ldv_34_ret = ldv_filter_err_code(ldv_34_ret);
    
#line 587 
    tmp_2 = ldv_undef_int();
    
#line 587 
    if (tmp_2 != 0) {
      
#line 589 
      __VERIFIER_assume(ldv_34_ret == 0);
      
#line 596 
      goto ldv_call_34;
    }
    else {
      
#line 600 
      __VERIFIER_assume(ldv_34_ret != 0);
      
#line 607 
      goto ldv_main_34;
    }
  }
  else {
    
#line 612 
    ldv_free((void *)ldv_34_resource_0);
    
#line 620 
    __retres = (void *)0;
    
#line 620 
    goto return_label;
  }
  
#line 623 
  __retres = (void *)0;
  
#line 623 
  goto return_label;
  ldv_call_34: 
#line 626 
  ;
  
#line 629 
  tmp_4 = ldv_undef_int();
  
#line 629 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 630 
    ;
    
#line 632 
    ldv_34_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 633 
    ldv_34_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 642 
    __VERIFIER_assume(ldv_34_size_cnt <= 2147479552UL);
    
#line 644 
    ldv_emg_wrapper_write_file_regval_4(ldv_34_resource_1,ldv_34_ldv_param_1_6,ldv_34_size_cnt,ldv_34_ldv_param_3_7);
    
#line 648 
    ldv_free((void *)ldv_34_ldv_param_3_7);
    
#line 649 
    ldv_free((void *)ldv_34_ldv_param_1_6);
    
#line 656 
    goto ldv_call_34;
    case 2: 
#line 659 
    ;
    
#line 661 
    if (ldv_34_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 663 
      (*(ldv_34_container->release))(ldv_34_resource_0,ldv_34_resource_1); else ;
    
#line 671 
    goto ldv_main_34;
    case 3: 
#line 674 
    ;
    
#line 678 
    tmp_9 = ldv_undef_int();
    
#line 678 
    if (tmp_9 != 0) 
#line 681 
                    (*ldv_emg_alias_default_llseek_3)(ldv_34_resource_1,ldv_34_ldv_param_1_2,ldv_34_ldv_param_2_3);
    else {
      
#line 687 
      ldv_34_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 688 
      ldv_34_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 693 
      ldv_emg_wrapper_read_file_regval_3(ldv_34_resource_1,ldv_34_ldv_param_1_4,ldv_34_size_cnt,ldv_34_ldv_param_3_5);
      
#line 697 
      ldv_free((void *)ldv_34_ldv_param_1_4);
      
#line 698 
      ldv_free((void *)ldv_34_ldv_param_3_5);
    }
    
#line 702 
    goto ldv_52087;
    default: 
#line 704 
    ;
    
#line 704 
    __VERIFIER_assume(0);
  }
  ldv_52087: 
#line 713 
  ;
  
#line 713 
  goto ldv_call_34;
  
#line 715 
  __retres = (void *)0;
  return_label: 
#line 715 
                return __retres;
}


#line 720  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_irq_register_14_3(int arg0, enum irqreturn (*arg1)(int , void *), enum irqreturn (*arg2)(int , void *), void *arg3)
{
  int ret;
  struct ldv_struct_interrupt_scenario_35 *cf_arg_35;
  int tmp;
  
#line 723 
  tmp = ldv_undef_int();
  
#line 723 
  switch (tmp) {
    case 0: 
#line 724 
    ;
    
#line 725 
    cf_arg_35 = (struct ldv_struct_interrupt_scenario_35 *)ldv_xmalloc(32UL);
    
#line 726 
    cf_arg_35->arg0 = arg0;
    
#line 727 
    cf_arg_35->arg1 = arg1;
    
#line 728 
    cf_arg_35->arg2 = arg2;
    
#line 729 
    cf_arg_35->arg3 = arg3;
    
#line 730 
    ret = pthread_create(& ldv_thread_35,(pthread_attr_t const *)0,& ldv_interrupt_scenario_35,(void *)cf_arg_35);
    
#line 731 
    __VERIFIER_assume(ret == 0);
    
#line 732 
    goto ldv_52102;
    default: 
#line 734 
    ;
    
#line 734 
    __VERIFIER_assume(0);
  }
  ldv_52102: 
#line 735 
  ;
  
#line 736 
  return;
}


#line 740  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_22(void *arg0)
{
  void *__retres;
  struct file *ldv_22_resource_1;
  int ldv_22_ldv_param_2_3;
  long long ldv_22_ldv_param_1_2;
  char *ldv_22_ldv_param_1_4;
  struct inode *ldv_22_resource_0;
  unsigned long ldv_22_size_cnt;
  long long *ldv_22_ldv_param_3_5;
  char *ldv_22_ldv_param_1_6;
  long long *ldv_22_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 751 
  struct file_operations *ldv_22_container = ldv_emg_alias_fops_wow_2;
  
#line 752 
  int ldv_22_ret = ldv_undef_int();
  
#line 755 
  struct ldv_struct_character_driver_scenario_15 *data = (struct ldv_struct_character_driver_scenario_15 *)arg0;
  
#line 759 
  ldv_22_ret = ldv_undef_int();
  
#line 762 
  if (data != (struct ldv_struct_character_driver_scenario_15 *)0) {
    
#line 763 
    ldv_22_container = data->arg0;
    
#line 764 
    ldv_free((void *)data);
  }
  else ;
  
#line 769 
  ldv_22_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 770 
  tmp_1 = ldv_undef_int();
  
#line 770 
  ldv_22_size_cnt = (unsigned long)tmp_1;
  
#line 777 
  goto ldv_main_22;
  
#line 779 
  __retres = (void *)0;
  
#line 779 
  goto return_label;
  ldv_main_22: 
#line 782 
  ;
  
#line 785 
  tmp_3 = ldv_undef_int();
  
#line 785 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 788 
    ldv_22_ret = (*ldv_emg_alias_simple_open_5)(ldv_22_resource_0,ldv_22_resource_1);
    
#line 790 
    ldv_22_ret = ldv_filter_err_code(ldv_22_ret);
    
#line 793 
    tmp_2 = ldv_undef_int();
    
#line 793 
    if (tmp_2 != 0) {
      
#line 795 
      __VERIFIER_assume(ldv_22_ret == 0);
      
#line 802 
      goto ldv_call_22;
    }
    else {
      
#line 806 
      __VERIFIER_assume(ldv_22_ret != 0);
      
#line 813 
      goto ldv_main_22;
    }
  }
  else {
    
#line 818 
    ldv_free((void *)ldv_22_resource_0);
    
#line 826 
    __retres = (void *)0;
    
#line 826 
    goto return_label;
  }
  
#line 829 
  __retres = (void *)0;
  
#line 829 
  goto return_label;
  ldv_call_22: 
#line 832 
  ;
  
#line 835 
  tmp_4 = ldv_undef_int();
  
#line 835 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 836 
    ;
    
#line 838 
    ldv_22_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 839 
    ldv_22_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 848 
    __VERIFIER_assume(ldv_22_size_cnt <= 2147479552UL);
    
#line 850 
    ldv_emg_wrapper_write_file_wow_4(ldv_22_resource_1,ldv_22_ldv_param_1_6,ldv_22_size_cnt,ldv_22_ldv_param_3_7);
    
#line 854 
    ldv_free((void *)ldv_22_ldv_param_1_6);
    
#line 855 
    ldv_free((void *)ldv_22_ldv_param_3_7);
    
#line 862 
    goto ldv_call_22;
    case 2: 
#line 865 
    ;
    
#line 867 
    if (ldv_22_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 869 
      (*(ldv_22_container->release))(ldv_22_resource_0,ldv_22_resource_1); else ;
    
#line 877 
    goto ldv_main_22;
    case 3: 
#line 880 
    ;
    
#line 884 
    tmp_9 = ldv_undef_int();
    
#line 884 
    if (tmp_9 != 0) 
#line 887 
                    (*ldv_emg_alias_default_llseek_3)(ldv_22_resource_1,ldv_22_ldv_param_1_2,ldv_22_ldv_param_2_3);
    else {
      
#line 893 
      ldv_22_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 894 
      ldv_22_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 899 
      ldv_emg_wrapper_read_file_wow_3(ldv_22_resource_1,ldv_22_ldv_param_1_4,ldv_22_size_cnt,ldv_22_ldv_param_3_5);
      
#line 903 
      ldv_free((void *)ldv_22_ldv_param_3_5);
      
#line 904 
      ldv_free((void *)ldv_22_ldv_param_1_4);
    }
    
#line 908 
    goto ldv_52124;
    default: 
#line 910 
    ;
    
#line 910 
    __VERIFIER_assume(0);
  }
  ldv_52124: 
#line 919 
  ;
  
#line 919 
  goto ldv_call_22;
  
#line 921 
  __retres = (void *)0;
  return_label: 
#line 921 
                return __retres;
}


#line 926  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
struct ieee80211_hw *ldv_emg_ieee80211_alloc_hw(unsigned long arg0, struct ieee80211_ops *arg1)
{
  struct ieee80211_hw *__retres;
  struct ieee80211_hw *ldv_4_ieee80211_hw;
  int tmp_0;
  
#line 929 
  struct ieee80211_ops *ldv_4_ieee80211_ops = & ath9k_ops;
  
#line 934 
  tmp_0 = ldv_undef_int();
  
#line 934 
  if (tmp_0 != 0) {
    
#line 936 
    ldv_4_ieee80211_ops = arg1;
    
#line 937 
    ldv_4_ieee80211_hw = (struct ieee80211_hw *)ldv_xmalloc_unknown_size(0UL);
    
#line 941 
    ldv_dispatch_register_4_3(ldv_4_ieee80211_hw);
    
#line 945 
    __retres = ldv_4_ieee80211_hw;
    
#line 945 
    goto return_label;
  }
  else {
    
#line 952 
    __retres = (struct ieee80211_hw *)0;
    
#line 952 
    goto return_label;
  }
  return_label: 
#line 934 
                return __retres;
}


#line 962  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_23(void *arg0)
{
  void *__retres;
  struct file *ldv_23_resource_1;
  int ldv_23_ldv_param_2_3;
  long long ldv_23_ldv_param_1_2;
  char *ldv_23_ldv_param_1_4;
  struct inode *ldv_23_resource_0;
  unsigned long ldv_23_size_cnt;
  long long *ldv_23_ldv_param_3_5;
  char *ldv_23_ldv_param_1_6;
  long long *ldv_23_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 973 
  struct file_operations *ldv_23_container = ldv_emg_alias_fops_ackto_2;
  
#line 974 
  int ldv_23_ret = ldv_undef_int();
  
#line 977 
  struct ldv_struct_character_driver_scenario_15 *data = (struct ldv_struct_character_driver_scenario_15 *)arg0;
  
#line 981 
  ldv_23_ret = ldv_undef_int();
  
#line 984 
  if (data != (struct ldv_struct_character_driver_scenario_15 *)0) {
    
#line 985 
    ldv_23_container = data->arg0;
    
#line 986 
    ldv_free((void *)data);
  }
  else ;
  
#line 991 
  ldv_23_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 992 
  tmp_1 = ldv_undef_int();
  
#line 992 
  ldv_23_size_cnt = (unsigned long)tmp_1;
  
#line 999 
  goto ldv_main_23;
  
#line 1001 
  __retres = (void *)0;
  
#line 1001 
  goto return_label;
  ldv_main_23: 
#line 1004 
  ;
  
#line 1007 
  tmp_3 = ldv_undef_int();
  
#line 1007 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 1010 
    ldv_23_ret = (*ldv_emg_alias_simple_open_5)(ldv_23_resource_0,ldv_23_resource_1);
    
#line 1012 
    ldv_23_ret = ldv_filter_err_code(ldv_23_ret);
    
#line 1015 
    tmp_2 = ldv_undef_int();
    
#line 1015 
    if (tmp_2 != 0) {
      
#line 1017 
      __VERIFIER_assume(ldv_23_ret == 0);
      
#line 1024 
      goto ldv_call_23;
    }
    else {
      
#line 1028 
      __VERIFIER_assume(ldv_23_ret != 0);
      
#line 1035 
      goto ldv_main_23;
    }
  }
  else {
    
#line 1040 
    ldv_free((void *)ldv_23_resource_0);
    
#line 1048 
    __retres = (void *)0;
    
#line 1048 
    goto return_label;
  }
  
#line 1051 
  __retres = (void *)0;
  
#line 1051 
  goto return_label;
  ldv_call_23: 
#line 1054 
  ;
  
#line 1057 
  tmp_4 = ldv_undef_int();
  
#line 1057 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 1058 
    ;
    
#line 1060 
    ldv_23_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 1061 
    ldv_23_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 1065 
    if (ldv_23_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 1071 
      __VERIFIER_assume(ldv_23_size_cnt <= 2147479552UL);
      
#line 1073 
      (*(ldv_23_container->write))(ldv_23_resource_1,(char const *)ldv_23_ldv_param_1_6,ldv_23_size_cnt,ldv_23_ldv_param_3_7);
    }
    else ;
    
#line 1078 
    ldv_free((void *)ldv_23_ldv_param_1_6);
    
#line 1079 
    ldv_free((void *)ldv_23_ldv_param_3_7);
    
#line 1086 
    goto ldv_call_23;
    case 2: 
#line 1089 
    ;
    
#line 1091 
    if (ldv_23_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 1093 
      (*(ldv_23_container->release))(ldv_23_resource_0,ldv_23_resource_1); else ;
    
#line 1101 
    goto ldv_main_23;
    case 3: 
#line 1104 
    ;
    
#line 1108 
    tmp_9 = ldv_undef_int();
    
#line 1108 
    if (tmp_9 != 0) 
#line 1111 
                    (*ldv_emg_alias_default_llseek_3)(ldv_23_resource_1,ldv_23_ldv_param_1_2,ldv_23_ldv_param_2_3);
    else {
      
#line 1117 
      ldv_23_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 1118 
      ldv_23_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 1123 
      ldv_emg_wrapper_read_file_ackto_4(ldv_23_resource_1,ldv_23_ldv_param_1_4,ldv_23_size_cnt,ldv_23_ldv_param_3_5);
      
#line 1127 
      ldv_free((void *)ldv_23_ldv_param_1_4);
      
#line 1128 
      ldv_free((void *)ldv_23_ldv_param_3_5);
    }
    
#line 1132 
    goto ldv_52152;
    default: 
#line 1134 
    ;
    
#line 1134 
    __VERIFIER_assume(0);
  }
  ldv_52152: 
#line 1143 
  ;
  
#line 1143 
  goto ldv_call_23;
  
#line 1145 
  __retres = (void *)0;
  return_label: 
#line 1145 
                return __retres;
}


#line 1150  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_pci_scenario_17(void *arg0)
{
  void *__retres;
  struct pci_dev *ldv_17_resource_1;
  struct pci_device_id *ldv_17_ldv_param_1_2;
  struct pm_message ldv_17_resource_0;
  int tmp_2;
  int tmp_3;
  
#line 1155 
  struct pci_driver *ldv_17_container = ldv_emg_alias_ath_pci_driver_2;
  
#line 1156 
  int ldv_17_ret = ldv_undef_int();
  
#line 1159 
  struct ldv_struct_pci_scenario_17 *data = (struct ldv_struct_pci_scenario_17 *)arg0;
  
#line 1163 
  ldv_17_ret = ldv_undef_int();
  
#line 1166 
  if (data != (struct ldv_struct_pci_scenario_17 *)0) {
    
#line 1167 
    ldv_17_container = data->arg0;
    
#line 1168 
    ldv_free((void *)data);
  }
  else ;
  
#line 1179 
  goto ldv_main_17;
  
#line 1181 
  __retres = (void *)0;
  
#line 1181 
  goto return_label;
  ldv_main_17: 
#line 1184 
  ;
  
#line 1187 
  tmp_2 = ldv_undef_int();
  
#line 1187 
  if (tmp_2 != 0) {
    int tmp_1;
    
#line 1189 
    ldv_17_ldv_param_1_2 = (struct pci_device_id *)ldv_xmalloc_unknown_size(0UL);
    
#line 1194 
    ldv_pre_probe();
    
#line 1196 
    ldv_17_ret = ldv_emg_wrapper_ath_pci_probe_2(ldv_17_resource_1,ldv_17_ldv_param_1_2);
    
#line 1198 
    ldv_17_ret = ldv_post_probe(ldv_17_ret);
    
#line 1202 
    ldv_free((void *)ldv_17_ldv_param_1_2);
    
#line 1205 
    tmp_1 = ldv_undef_int();
    
#line 1205 
    if (tmp_1 != 0) {
      
#line 1207 
      __VERIFIER_assume(ldv_17_ret == 0);
      
#line 1214 
      goto ldv_call_17;
    }
    else {
      
#line 1218 
      __VERIFIER_assume(ldv_17_ret != 0);
      
#line 1225 
      goto ldv_main_17;
    }
  }
  else {
    
#line 1237 
    __retres = (void *)0;
    
#line 1237 
    goto return_label;
  }
  
#line 1240 
  __retres = (void *)0;
  
#line 1240 
  goto return_label;
  ldv_call_17: 
#line 1243 
  ;
  
#line 1246 
  tmp_3 = ldv_undef_int();
  
#line 1246 
  switch (tmp_3) {
    case 1: 
#line 1247 
    ;
    
#line 1256 
    goto ldv_call_17;
    case 2: 
#line 1259 
    ;
    
#line 1261 
    if (ldv_17_container->suspend != (int (*)(struct pci_dev *, pm_message_t ))0) {
      
#line 1263 
      ldv_17_ret = (*(ldv_17_container->suspend))(ldv_17_resource_1,ldv_17_resource_0);
      
#line 1265 
      ldv_17_ret = ldv_filter_err_code(ldv_17_ret);
    }
    else 
#line 1267 
         ldv_17_ret = ldv_undef_int();
    
#line 1272 
    if (ldv_17_container->suspend_late != (int (*)(struct pci_dev *, pm_message_t ))0) {
      
#line 1274 
      ldv_17_ret = (*(ldv_17_container->suspend_late))(ldv_17_resource_1,ldv_17_resource_0);
      
#line 1276 
      ldv_17_ret = ldv_filter_err_code(ldv_17_ret);
    }
    else 
#line 1278 
         ldv_17_ret = ldv_undef_int();
    
#line 1283 
    if (ldv_17_container->resume_early != (int (*)(struct pci_dev *))0) 
      
#line 1285 
      (*(ldv_17_container->resume_early))(ldv_17_resource_1); else ;
    
#line 1290 
    if (ldv_17_container->resume != (int (*)(struct pci_dev *))0) 
#line 1292 
                                                                  (*(ldv_17_container->resume))(ldv_17_resource_1); else ;
    
#line 1300 
    goto ldv_call_17;
    case 3: 
#line 1303 
    ;
    
#line 1305 
    if (ldv_17_container->shutdown != (void (*)(struct pci_dev *))0) 
      
#line 1307 
      (*(ldv_17_container->shutdown))(ldv_17_resource_1); else ;
    
#line 1313 
    ldv_emg_wrapper_ath_pci_remove_3(ldv_17_resource_1);
    
#line 1320 
    goto ldv_main_17;
    default: 
#line 1323 
    ;
    
#line 1323 
    __VERIFIER_assume(0);
  }
  
#line 1326 
  __retres = (void *)0;
  return_label: 
#line 1326 
                return __retres;
}


#line 1331  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_irq_deregister_5_1(int arg0)
{
  int ret;
  struct ldv_struct_free_irq_5 *cf_arg_35;
  int tmp;
  
#line 1334 
  tmp = ldv_undef_int();
  
#line 1334 
  switch (tmp) {
    case 0: 
#line 1335 
    ;
    
#line 1336 
    ret = pthread_join(ldv_thread_35,(void **)0);
    
#line 1337 
    __VERIFIER_assume(ret == 0);
    
#line 1338 
    goto ldv_52175;
    default: 
#line 1340 
    ;
    
#line 1340 
    __VERIFIER_assume(0);
  }
  ldv_52175: 
#line 1341 
  ;
  
#line 1342 
  return;
}


#line 1346  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_29(void *arg0)
{
  void *__retres;
  struct file *ldv_29_resource_1;
  int ldv_29_ldv_param_2_3;
  long long ldv_29_ldv_param_1_2;
  char *ldv_29_ldv_param_1_4;
  struct inode *ldv_29_resource_0;
  unsigned long ldv_29_size_cnt;
  long long *ldv_29_ldv_param_3_5;
  char *ldv_29_ldv_param_1_6;
  long long *ldv_29_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 1357 
  struct file_operations *ldv_29_container = ldv_emg_alias_fops_debug_2;
  
#line 1358 
  int ldv_29_ret = ldv_undef_int();
  
#line 1361 
  struct ldv_struct_character_driver_scenario_15 *data = (struct ldv_struct_character_driver_scenario_15 *)arg0;
  
#line 1365 
  ldv_29_ret = ldv_undef_int();
  
#line 1368 
  if (data != (struct ldv_struct_character_driver_scenario_15 *)0) {
    
#line 1369 
    ldv_29_container = data->arg0;
    
#line 1370 
    ldv_free((void *)data);
  }
  else ;
  
#line 1375 
  ldv_29_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 1376 
  tmp_1 = ldv_undef_int();
  
#line 1376 
  ldv_29_size_cnt = (unsigned long)tmp_1;
  
#line 1383 
  goto ldv_main_29;
  
#line 1385 
  __retres = (void *)0;
  
#line 1385 
  goto return_label;
  ldv_main_29: 
#line 1388 
  ;
  
#line 1391 
  tmp_3 = ldv_undef_int();
  
#line 1391 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 1394 
    ldv_29_ret = (*ldv_emg_alias_simple_open_5)(ldv_29_resource_0,ldv_29_resource_1);
    
#line 1396 
    ldv_29_ret = ldv_filter_err_code(ldv_29_ret);
    
#line 1399 
    tmp_2 = ldv_undef_int();
    
#line 1399 
    if (tmp_2 != 0) {
      
#line 1401 
      __VERIFIER_assume(ldv_29_ret == 0);
      
#line 1408 
      goto ldv_call_29;
    }
    else {
      
#line 1412 
      __VERIFIER_assume(ldv_29_ret != 0);
      
#line 1419 
      goto ldv_main_29;
    }
  }
  else {
    
#line 1424 
    ldv_free((void *)ldv_29_resource_0);
    
#line 1432 
    __retres = (void *)0;
    
#line 1432 
    goto return_label;
  }
  
#line 1435 
  __retres = (void *)0;
  
#line 1435 
  goto return_label;
  ldv_call_29: 
#line 1438 
  ;
  
#line 1441 
  tmp_4 = ldv_undef_int();
  
#line 1441 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 1442 
    ;
    
#line 1444 
    ldv_29_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 1445 
    ldv_29_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 1454 
    __VERIFIER_assume(ldv_29_size_cnt <= 2147479552UL);
    
#line 1456 
    ldv_emg_wrapper_write_file_debug_4(ldv_29_resource_1,ldv_29_ldv_param_1_6,ldv_29_size_cnt,ldv_29_ldv_param_3_7);
    
#line 1460 
    ldv_free((void *)ldv_29_ldv_param_3_7);
    
#line 1461 
    ldv_free((void *)ldv_29_ldv_param_1_6);
    
#line 1468 
    goto ldv_call_29;
    case 2: 
#line 1471 
    ;
    
#line 1473 
    if (ldv_29_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 1475 
      (*(ldv_29_container->release))(ldv_29_resource_0,ldv_29_resource_1); else ;
    
#line 1483 
    goto ldv_main_29;
    case 3: 
#line 1486 
    ;
    
#line 1490 
    tmp_9 = ldv_undef_int();
    
#line 1490 
    if (tmp_9 != 0) 
#line 1493 
                    (*ldv_emg_alias_default_llseek_3)(ldv_29_resource_1,ldv_29_ldv_param_1_2,ldv_29_ldv_param_2_3);
    else {
      
#line 1499 
      ldv_29_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 1500 
      ldv_29_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 1505 
      ldv_emg_wrapper_read_file_debug_3(ldv_29_resource_1,ldv_29_ldv_param_1_4,ldv_29_size_cnt,ldv_29_ldv_param_3_5);
      
#line 1509 
      ldv_free((void *)ldv_29_ldv_param_1_4);
      
#line 1510 
      ldv_free((void *)ldv_29_ldv_param_3_5);
    }
    
#line 1514 
    goto ldv_52197;
    default: 
#line 1516 
    ;
    
#line 1516 
    __VERIFIER_assume(0);
  }
  ldv_52197: 
#line 1525 
  ;
  
#line 1525 
  goto ldv_call_29;
  
#line 1527 
  __retres = (void *)0;
  return_label: 
#line 1527 
                return __retres;
}


#line 1532  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_deregister_7_1(struct pci_driver *arg0)
{
  int ret;
  struct ldv_struct_pci_scenario_17 *cf_arg_17;
  int tmp;
  
#line 1535 
  tmp = ldv_undef_int();
  
#line 1535 
  switch (tmp) {
    case 0: 
#line 1536 
    ;
    
#line 1537 
    ret = pthread_join(ldv_thread_17,(void **)0);
    
#line 1538 
    __VERIFIER_assume(ret == 0);
    
#line 1539 
    goto ldv_52205;
    default: 
#line 1541 
    ;
    
#line 1541 
    __VERIFIER_assume(0);
  }
  ldv_52205: 
#line 1542 
  ;
  
#line 1543 
  return;
}


#line 1547  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_37(void *arg0)
{
  void *__retres;
  struct file *ldv_37_resource_1;
  int ldv_37_ldv_param_2_3;
  long long ldv_37_ldv_param_1_2;
  char *ldv_37_ldv_param_1_4;
  struct inode *ldv_37_resource_0;
  unsigned long ldv_37_size_cnt;
  long long *ldv_37_ldv_param_3_5;
  char *ldv_37_ldv_param_1_6;
  long long *ldv_37_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 1558 
  struct file_operations *ldv_37_container = ldv_emg_alias_fops_node_recv_2;
  
#line 1559 
  int ldv_37_ret = ldv_undef_int();
  
#line 1562 
  struct ldv_struct_character_driver_scenario_15 *data = (struct ldv_struct_character_driver_scenario_15 *)arg0;
  
#line 1566 
  ldv_37_ret = ldv_undef_int();
  
#line 1569 
  if (data != (struct ldv_struct_character_driver_scenario_15 *)0) {
    
#line 1570 
    ldv_37_container = data->arg0;
    
#line 1571 
    ldv_free((void *)data);
  }
  else ;
  
#line 1576 
  ldv_37_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 1577 
  tmp_1 = ldv_undef_int();
  
#line 1577 
  ldv_37_size_cnt = (unsigned long)tmp_1;
  
#line 1584 
  goto ldv_main_37;
  
#line 1586 
  __retres = (void *)0;
  
#line 1586 
  goto return_label;
  ldv_main_37: 
#line 1589 
  ;
  
#line 1592 
  tmp_3 = ldv_undef_int();
  
#line 1592 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 1595 
    ldv_37_ret = (*ldv_emg_alias_simple_open_5)(ldv_37_resource_0,ldv_37_resource_1);
    
#line 1597 
    ldv_37_ret = ldv_filter_err_code(ldv_37_ret);
    
#line 1600 
    tmp_2 = ldv_undef_int();
    
#line 1600 
    if (tmp_2 != 0) {
      
#line 1602 
      __VERIFIER_assume(ldv_37_ret == 0);
      
#line 1609 
      goto ldv_call_37;
    }
    else {
      
#line 1613 
      __VERIFIER_assume(ldv_37_ret != 0);
      
#line 1620 
      goto ldv_main_37;
    }
  }
  else {
    
#line 1625 
    ldv_free((void *)ldv_37_resource_0);
    
#line 1633 
    __retres = (void *)0;
    
#line 1633 
    goto return_label;
  }
  
#line 1636 
  __retres = (void *)0;
  
#line 1636 
  goto return_label;
  ldv_call_37: 
#line 1639 
  ;
  
#line 1642 
  tmp_4 = ldv_undef_int();
  
#line 1642 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 1643 
    ;
    
#line 1645 
    ldv_37_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 1646 
    ldv_37_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 1650 
    if (ldv_37_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 1656 
      __VERIFIER_assume(ldv_37_size_cnt <= 2147479552UL);
      
#line 1658 
      (*(ldv_37_container->write))(ldv_37_resource_1,(char const *)ldv_37_ldv_param_1_6,ldv_37_size_cnt,ldv_37_ldv_param_3_7);
    }
    else ;
    
#line 1663 
    ldv_free((void *)ldv_37_ldv_param_3_7);
    
#line 1664 
    ldv_free((void *)ldv_37_ldv_param_1_6);
    
#line 1671 
    goto ldv_call_37;
    case 2: 
#line 1674 
    ;
    
#line 1676 
    if (ldv_37_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 1678 
      (*(ldv_37_container->release))(ldv_37_resource_0,ldv_37_resource_1); else ;
    
#line 1686 
    goto ldv_main_37;
    case 3: 
#line 1689 
    ;
    
#line 1693 
    tmp_9 = ldv_undef_int();
    
#line 1693 
    if (tmp_9 != 0) 
#line 1696 
                    (*ldv_emg_alias_default_llseek_3)(ldv_37_resource_1,ldv_37_ldv_param_1_2,ldv_37_ldv_param_2_3);
    else {
      
#line 1702 
      ldv_37_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 1703 
      ldv_37_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 1708 
      ldv_emg_wrapper_read_file_node_recv_3(ldv_37_resource_1,ldv_37_ldv_param_1_4,ldv_37_size_cnt,ldv_37_ldv_param_3_5);
      
#line 1712 
      ldv_free((void *)ldv_37_ldv_param_3_5);
      
#line 1713 
      ldv_free((void *)ldv_37_ldv_param_1_4);
    }
    
#line 1717 
    goto ldv_52227;
    default: 
#line 1719 
    ;
    
#line 1719 
    __VERIFIER_assume(0);
  }
  ldv_52227: 
#line 1728 
  ;
  
#line 1728 
  goto ldv_call_37;
  
#line 1730 
  __retres = (void *)0;
  return_label: 
#line 1730 
                return __retres;
}


#line 1735  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_initialization_1(void *arg0)
{
  void *__retres;
  int ldv_1_ret;
  int tmp;
  
#line 1742 
  ldv_1_ret = ldv_emg_ath9k_init();
  
#line 1743 
  ldv_1_ret = ldv_post_init(ldv_1_ret);
  
#line 1746 
  tmp = ldv_undef_int();
  
#line 1746 
  if (tmp != 0) {
    
#line 1748 
    __VERIFIER_assume(ldv_1_ret != 0);
    
#line 1752 
    __retres = (void *)0;
    
#line 1752 
    goto return_label;
  }
  else {
    
#line 1756 
    __VERIFIER_assume(ldv_1_ret == 0);
    
#line 1761 
    ldv_emg_ath9k_exit();
    
#line 1765 
    __retres = (void *)0;
    
#line 1765 
    goto return_label;
  }
  
#line 1768 
  __retres = (void *)0;
  return_label: 
#line 1768 
                return __retres;
}


#line 1773  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_instance_deregister_11_1(struct timer_list *arg0)
{
  int ret;
  struct ldv_struct_timer_scenario_21 *cf_arg_21;
  int tmp;
  
#line 1776 
  tmp = ldv_undef_int();
  
#line 1776 
  switch (tmp) {
    case 0: 
#line 1777 
    ;
    
#line 1778 
    ret = pthread_join(ldv_thread_21,(void **)0);
    
#line 1779 
    __VERIFIER_assume(ret == 0);
    
#line 1780 
    goto ldv_52239;
    default: 
#line 1782 
    ;
    
#line 1782 
    __VERIFIER_assume(0);
  }
  ldv_52239: 
#line 1783 
  ;
  
#line 1784 
  return;
}


#line 1788  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_16(void *arg0)
{
  void *__retres;
  struct file *ldv_16_resource_1;
  int ldv_16_ldv_param_2_3;
  long long ldv_16_ldv_param_1_2;
  char *ldv_16_ldv_param_1_4;
  struct inode *ldv_16_resource_0;
  unsigned long ldv_16_size_cnt;
  long long *ldv_16_ldv_param_3_5;
  char *ldv_16_ldv_param_1_6;
  long long *ldv_16_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 1799 
  struct file_operations *ldv_16_container = ldv_emg_alias_fops_antenna_diversity_2;
  
#line 1800 
  int ldv_16_ret = ldv_undef_int();
  
#line 1803 
  struct ldv_struct_character_driver_scenario_15 *data = (struct ldv_struct_character_driver_scenario_15 *)arg0;
  
#line 1807 
  ldv_16_ret = ldv_undef_int();
  
#line 1810 
  if (data != (struct ldv_struct_character_driver_scenario_15 *)0) {
    
#line 1811 
    ldv_16_container = data->arg0;
    
#line 1812 
    ldv_free((void *)data);
  }
  else ;
  
#line 1817 
  ldv_16_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 1818 
  tmp_1 = ldv_undef_int();
  
#line 1818 
  ldv_16_size_cnt = (unsigned long)tmp_1;
  
#line 1825 
  goto ldv_main_16;
  
#line 1827 
  __retres = (void *)0;
  
#line 1827 
  goto return_label;
  ldv_main_16: 
#line 1830 
  ;
  
#line 1833 
  tmp_3 = ldv_undef_int();
  
#line 1833 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 1836 
    ldv_16_ret = (*ldv_emg_alias_simple_open_5)(ldv_16_resource_0,ldv_16_resource_1);
    
#line 1838 
    ldv_16_ret = ldv_filter_err_code(ldv_16_ret);
    
#line 1841 
    tmp_2 = ldv_undef_int();
    
#line 1841 
    if (tmp_2 != 0) {
      
#line 1843 
      __VERIFIER_assume(ldv_16_ret == 0);
      
#line 1850 
      goto ldv_call_16;
    }
    else {
      
#line 1854 
      __VERIFIER_assume(ldv_16_ret != 0);
      
#line 1861 
      goto ldv_main_16;
    }
  }
  else {
    
#line 1866 
    ldv_free((void *)ldv_16_resource_0);
    
#line 1874 
    __retres = (void *)0;
    
#line 1874 
    goto return_label;
  }
  
#line 1877 
  __retres = (void *)0;
  
#line 1877 
  goto return_label;
  ldv_call_16: 
#line 1880 
  ;
  
#line 1883 
  tmp_4 = ldv_undef_int();
  
#line 1883 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 1884 
    ;
    
#line 1886 
    ldv_16_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 1887 
    ldv_16_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 1891 
    if (ldv_16_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 1897 
      __VERIFIER_assume(ldv_16_size_cnt <= 2147479552UL);
      
#line 1899 
      (*(ldv_16_container->write))(ldv_16_resource_1,(char const *)ldv_16_ldv_param_1_6,ldv_16_size_cnt,ldv_16_ldv_param_3_7);
    }
    else ;
    
#line 1904 
    ldv_free((void *)ldv_16_ldv_param_1_6);
    
#line 1905 
    ldv_free((void *)ldv_16_ldv_param_3_7);
    
#line 1912 
    goto ldv_call_16;
    case 2: 
#line 1915 
    ;
    
#line 1917 
    if (ldv_16_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 1919 
      (*(ldv_16_container->release))(ldv_16_resource_0,ldv_16_resource_1); else ;
    
#line 1927 
    goto ldv_main_16;
    case 3: 
#line 1930 
    ;
    
#line 1934 
    tmp_9 = ldv_undef_int();
    
#line 1934 
    if (tmp_9 != 0) 
#line 1937 
                    (*ldv_emg_alias_default_llseek_3)(ldv_16_resource_1,ldv_16_ldv_param_1_2,ldv_16_ldv_param_2_3);
    else {
      
#line 1943 
      ldv_16_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 1944 
      ldv_16_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 1949 
      ldv_emg_wrapper_read_file_antenna_diversity_3(ldv_16_resource_1,ldv_16_ldv_param_1_4,ldv_16_size_cnt,ldv_16_ldv_param_3_5);
      
#line 1953 
      ldv_free((void *)ldv_16_ldv_param_3_5);
      
#line 1954 
      ldv_free((void *)ldv_16_ldv_param_1_4);
    }
    
#line 1958 
    goto ldv_52261;
    default: 
#line 1960 
    ;
    
#line 1960 
    __VERIFIER_assume(0);
  }
  ldv_52261: 
#line 1969 
  ;
  
#line 1969 
  goto ldv_call_16;
  
#line 1971 
  __retres = (void *)0;
  return_label: 
#line 1971 
                return __retres;
}


#line 1976  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_interrupt_scenario_35(void *arg0)
{
  void *__retres;
  enum irqreturn ldv_35_ret_val;
  int ldv_35_line;
  void *ldv_35_data;
  enum irqreturn (*ldv_35_thread)(int , void *);
  int tmp;
  
#line 1982 
  enum irqreturn (*ldv_35_callback)(int , void *) = & ath_isr;
  
#line 1985 
  struct ldv_struct_interrupt_scenario_35 *data = (struct ldv_struct_interrupt_scenario_35 *)arg0;
  
#line 1990 
  if (data != (struct ldv_struct_interrupt_scenario_35 *)0) {
    
#line 1991 
    ldv_35_line = data->arg0;
    
#line 1992 
    ldv_35_callback = data->arg1;
    
#line 1993 
    ldv_35_thread = data->arg2;
    
#line 1994 
    ldv_35_data = data->arg3;
    
#line 1995 
    ldv_free((void *)data);
  }
  else ;
  
#line 2001 
  ldv_switch_to_interrupt_context();
  
#line 2003 
  ldv_35_ret_val = ath_isr(ldv_35_line,ldv_35_data);
  
#line 2005 
  ldv_switch_to_process_context();
  
#line 2008 
  tmp = ldv_undef_int();
  
#line 2008 
  if (tmp != 0) {
    
#line 2010 
    __VERIFIER_assume(ldv_35_ret_val == (unsigned int)IRQ_WAKE_THREAD);
    
#line 2014 
    if (ldv_35_thread != (enum irqreturn (*)(int , void *))0) 
#line 2016 
                                                              (*ldv_35_thread)(ldv_35_line,ldv_35_data); else ;
  }
  else 
#line 2023 
       __VERIFIER_assume(ldv_35_ret_val != (unsigned int)IRQ_WAKE_THREAD);
  
#line 2032 
  __retres = (void *)0;
  
#line 2032 
  goto return_label;
  
#line 2034 
  __retres = (void *)0;
  return_label: 
#line 2034 
                return __retres;
}


#line 2039  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg___platform_driver_register(struct platform_driver *arg0, struct module *arg1)
{
  int __retres;
  int tmp_0;
  
#line 2042 
  struct platform_driver *ldv_9_platform_driver = ldv_emg_alias_ath_ahb_driver_2;
  
#line 2046 
  tmp_0 = ldv_undef_int();
  
#line 2046 
  if (tmp_0 != 0) {
    
#line 2048 
    ldv_9_platform_driver = arg0;
    
#line 2052 
    ldv_dispatch_register_9_3(ldv_9_platform_driver);
    
#line 2056 
    __retres = 0;
    
#line 2056 
    goto return_label;
  }
  else {
    int tmp;
    
#line 2063 
    tmp = ldv_undef_int_negative();
    
#line 2063 
    __retres = tmp;
    
#line 2063 
    goto return_label;
  }
  return_label: 
#line 2046 
                return __retres;
}


#line 2073  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_register_4_3(struct ieee80211_hw *arg0)
{
  int ret;
  struct ldv_struct_ieee80211_scenario_19 *cf_arg_19;
  int tmp;
  
#line 2076 
  tmp = ldv_undef_int();
  
#line 2076 
  switch (tmp) {
    case 0: 
#line 2077 
    ;
    
#line 2078 
    cf_arg_19 = (struct ldv_struct_ieee80211_scenario_19 *)ldv_xmalloc(16UL);
    
#line 2079 
    cf_arg_19->arg0 = arg0;
    
#line 2080 
    ret = pthread_create(& ldv_thread_19,(pthread_attr_t const *)0,& ldv_ieee80211_scenario_19,(void *)cf_arg_19);
    
#line 2081 
    __VERIFIER_assume(ret == 0);
    
#line 2082 
    goto ldv_52287;
    default: 
#line 2084 
    ;
    
#line 2084 
    __VERIFIER_assume(0);
  }
  ldv_52287: 
#line 2085 
  ;
  
#line 2086 
  return;
}


#line 2090  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_18(void *arg0)
{
  void *__retres;
  struct file *ldv_18_resource_1;
  int ldv_18_ldv_param_2_3;
  long long ldv_18_ldv_param_1_2;
  char *ldv_18_ldv_param_1_4;
  struct inode *ldv_18_resource_0;
  unsigned long ldv_18_size_cnt;
  long long *ldv_18_ldv_param_3_5;
  char *ldv_18_ldv_param_1_6;
  long long *ldv_18_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 2101 
  struct file_operations *ldv_18_container = ldv_emg_alias_fops_btcoex_2;
  
#line 2102 
  int ldv_18_ret = ldv_undef_int();
  
#line 2105 
  struct ldv_struct_character_driver_scenario_15 *data = (struct ldv_struct_character_driver_scenario_15 *)arg0;
  
#line 2109 
  ldv_18_ret = ldv_undef_int();
  
#line 2112 
  if (data != (struct ldv_struct_character_driver_scenario_15 *)0) {
    
#line 2113 
    ldv_18_container = data->arg0;
    
#line 2114 
    ldv_free((void *)data);
  }
  else ;
  
#line 2119 
  ldv_18_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 2120 
  tmp_1 = ldv_undef_int();
  
#line 2120 
  ldv_18_size_cnt = (unsigned long)tmp_1;
  
#line 2127 
  goto ldv_main_18;
  
#line 2129 
  __retres = (void *)0;
  
#line 2129 
  goto return_label;
  ldv_main_18: 
#line 2132 
  ;
  
#line 2135 
  tmp_3 = ldv_undef_int();
  
#line 2135 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 2138 
    ldv_18_ret = (*ldv_emg_alias_simple_open_5)(ldv_18_resource_0,ldv_18_resource_1);
    
#line 2140 
    ldv_18_ret = ldv_filter_err_code(ldv_18_ret);
    
#line 2143 
    tmp_2 = ldv_undef_int();
    
#line 2143 
    if (tmp_2 != 0) {
      
#line 2145 
      __VERIFIER_assume(ldv_18_ret == 0);
      
#line 2152 
      goto ldv_call_18;
    }
    else {
      
#line 2156 
      __VERIFIER_assume(ldv_18_ret != 0);
      
#line 2163 
      goto ldv_main_18;
    }
  }
  else {
    
#line 2168 
    ldv_free((void *)ldv_18_resource_0);
    
#line 2176 
    __retres = (void *)0;
    
#line 2176 
    goto return_label;
  }
  
#line 2179 
  __retres = (void *)0;
  
#line 2179 
  goto return_label;
  ldv_call_18: 
#line 2182 
  ;
  
#line 2185 
  tmp_4 = ldv_undef_int();
  
#line 2185 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 2186 
    ;
    
#line 2188 
    ldv_18_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 2189 
    ldv_18_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 2193 
    if (ldv_18_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 2199 
      __VERIFIER_assume(ldv_18_size_cnt <= 2147479552UL);
      
#line 2201 
      (*(ldv_18_container->write))(ldv_18_resource_1,(char const *)ldv_18_ldv_param_1_6,ldv_18_size_cnt,ldv_18_ldv_param_3_7);
    }
    else ;
    
#line 2206 
    ldv_free((void *)ldv_18_ldv_param_1_6);
    
#line 2207 
    ldv_free((void *)ldv_18_ldv_param_3_7);
    
#line 2214 
    goto ldv_call_18;
    case 2: 
#line 2217 
    ;
    
#line 2219 
    if (ldv_18_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 2221 
      (*(ldv_18_container->release))(ldv_18_resource_0,ldv_18_resource_1); else ;
    
#line 2229 
    goto ldv_main_18;
    case 3: 
#line 2232 
    ;
    
#line 2236 
    tmp_9 = ldv_undef_int();
    
#line 2236 
    if (tmp_9 != 0) 
#line 2239 
                    (*ldv_emg_alias_default_llseek_3)(ldv_18_resource_1,ldv_18_ldv_param_1_2,ldv_18_ldv_param_2_3);
    else {
      
#line 2245 
      ldv_18_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 2246 
      ldv_18_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 2251 
      ldv_emg_wrapper_read_file_btcoex_3(ldv_18_resource_1,ldv_18_ldv_param_1_4,ldv_18_size_cnt,ldv_18_ldv_param_3_5);
      
#line 2255 
      ldv_free((void *)ldv_18_ldv_param_3_5);
      
#line 2256 
      ldv_free((void *)ldv_18_ldv_param_1_4);
    }
    
#line 2260 
    goto ldv_52309;
    default: 
#line 2262 
    ;
    
#line 2262 
    __VERIFIER_assume(0);
  }
  ldv_52309: 
#line 2271 
  ;
  
#line 2271 
  goto ldv_call_18;
  
#line 2273 
  __retres = (void *)0;
  return_label: 
#line 2273 
                return __retres;
}


#line 2278  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_platform_instance_33(void *arg0)
{
  void *__retres;
  struct platform_device *ldv_33_resource;
  int tmp_1;
  int tmp_2;
  
#line 2282 
  struct platform_driver *ldv_33_container = ldv_emg_alias_ath_ahb_driver_2;
  
#line 2283 
  int ldv_33_probed = 1;
  
#line 2285 
  struct ldv_struct_platform_instance_33 *data = (struct ldv_struct_platform_instance_33 *)arg0;
  
#line 2289 
  ldv_33_probed = 1;
  
#line 2292 
  if (data != (struct ldv_struct_platform_instance_33 *)0) {
    
#line 2293 
    ldv_33_container = data->arg0;
    
#line 2294 
    ldv_free((void *)data);
  }
  else ;
  
#line 2299 
  ldv_33_resource = (struct platform_device *)ldv_xmalloc_unknown_size(0UL);
  
#line 2306 
  goto ldv_main_33;
  
#line 2308 
  __retres = (void *)0;
  
#line 2308 
  goto return_label;
  ldv_main_33: 
#line 2311 
  ;
  
#line 2314 
  tmp_1 = ldv_undef_int();
  
#line 2314 
  if (tmp_1 != 0) {
    int tmp_0;
    
#line 2317 
    ldv_pre_probe();
    
#line 2319 
    ldv_33_probed = ldv_emg_wrapper_ath_ahb_probe_2(ldv_33_resource);
    
#line 2321 
    ldv_33_probed = ldv_post_probe(ldv_33_probed);
    
#line 2324 
    tmp_0 = ldv_undef_int();
    
#line 2324 
    if (tmp_0 != 0) {
      
#line 2326 
      __VERIFIER_assume(ldv_33_probed == 0);
      
#line 2333 
      goto ldv_call_33;
    }
    else {
      
#line 2337 
      __VERIFIER_assume(ldv_33_probed != 0);
      
#line 2344 
      goto ldv_main_33;
    }
  }
  else {
    
#line 2349 
    ldv_free((void *)ldv_33_resource);
    
#line 2357 
    __retres = (void *)0;
    
#line 2357 
    goto return_label;
  }
  
#line 2360 
  __retres = (void *)0;
  
#line 2360 
  goto return_label;
  ldv_call_33: 
#line 2363 
  ;
  
#line 2366 
  tmp_2 = ldv_undef_int();
  
#line 2366 
  switch (tmp_2) {
    case 1: 
#line 2367 
    ;
    
#line 2376 
    goto ldv_call_33;
    case 2: 
#line 2379 
    ;
    
#line 2381 
    ldv_dispatch_pm_register_33_13();
    
#line 2385 
    ldv_dispatch_pm_deregister_33_12();
    
#line 2392 
    goto ldv_call_33;
    case 3: 
#line 2395 
    ;
    
#line 2398 
    ldv_emg_wrapper_ath_ahb_remove_3(ldv_33_resource);
    
#line 2402 
    ldv_33_probed = 1;
    
#line 2409 
    goto ldv_main_33;
    default: 
#line 2412 
    ;
    
#line 2412 
    __VERIFIER_assume(0);
  }
  
#line 2415 
  __retres = (void *)0;
  return_label: 
#line 2415 
                return __retres;
}


#line 2420  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_pm_deregister_33_12(void)
{
  int ret;
  struct ldv_struct_platform_instance_33 *cf_arg_20;
  int tmp;
  
#line 2423 
  tmp = ldv_undef_int();
  
#line 2423 
  switch (tmp) {
    case 0: 
#line 2424 
    ;
    
#line 2425 
    ret = pthread_join(ldv_thread_20,(void **)0);
    
#line 2426 
    __VERIFIER_assume(ret == 0);
    
#line 2427 
    goto ldv_52330;
    default: 
#line 2429 
    ;
    
#line 2429 
    __VERIFIER_assume(0);
  }
  ldv_52330: 
#line 2430 
  ;
  
#line 2431 
  return;
}


#line 2435  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_25(void *arg0)
{
  void *__retres;
  struct file *ldv_25_resource_1;
  int ldv_25_ldv_param_2_3;
  long long ldv_25_ldv_param_1_2;
  char *ldv_25_ldv_param_1_4;
  struct inode *ldv_25_resource_0;
  unsigned long ldv_25_size_cnt;
  long long *ldv_25_ldv_param_3_5;
  char *ldv_25_ldv_param_1_6;
  long long *ldv_25_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 2446 
  struct file_operations *ldv_25_container = ldv_emg_alias_fops_tx99_power_2;
  
#line 2447 
  int ldv_25_ret = ldv_undef_int();
  
#line 2450 
  struct ldv_struct_character_driver_scenario_15 *data = (struct ldv_struct_character_driver_scenario_15 *)arg0;
  
#line 2454 
  ldv_25_ret = ldv_undef_int();
  
#line 2457 
  if (data != (struct ldv_struct_character_driver_scenario_15 *)0) {
    
#line 2458 
    ldv_25_container = data->arg0;
    
#line 2459 
    ldv_free((void *)data);
  }
  else ;
  
#line 2464 
  ldv_25_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 2465 
  tmp_1 = ldv_undef_int();
  
#line 2465 
  ldv_25_size_cnt = (unsigned long)tmp_1;
  
#line 2472 
  goto ldv_main_25;
  
#line 2474 
  __retres = (void *)0;
  
#line 2474 
  goto return_label;
  ldv_main_25: 
#line 2477 
  ;
  
#line 2480 
  tmp_3 = ldv_undef_int();
  
#line 2480 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 2483 
    ldv_25_ret = (*ldv_emg_alias_simple_open_5)(ldv_25_resource_0,ldv_25_resource_1);
    
#line 2485 
    ldv_25_ret = ldv_filter_err_code(ldv_25_ret);
    
#line 2488 
    tmp_2 = ldv_undef_int();
    
#line 2488 
    if (tmp_2 != 0) {
      
#line 2490 
      __VERIFIER_assume(ldv_25_ret == 0);
      
#line 2497 
      goto ldv_call_25;
    }
    else {
      
#line 2501 
      __VERIFIER_assume(ldv_25_ret != 0);
      
#line 2508 
      goto ldv_main_25;
    }
  }
  else {
    
#line 2513 
    ldv_free((void *)ldv_25_resource_0);
    
#line 2521 
    __retres = (void *)0;
    
#line 2521 
    goto return_label;
  }
  
#line 2524 
  __retres = (void *)0;
  
#line 2524 
  goto return_label;
  ldv_call_25: 
#line 2527 
  ;
  
#line 2530 
  tmp_4 = ldv_undef_int();
  
#line 2530 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 2531 
    ;
    
#line 2533 
    ldv_25_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 2534 
    ldv_25_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 2543 
    __VERIFIER_assume(ldv_25_size_cnt <= 2147479552UL);
    
#line 2545 
    ldv_emg_wrapper_write_file_tx99_power_4(ldv_25_resource_1,ldv_25_ldv_param_1_6,ldv_25_size_cnt,ldv_25_ldv_param_3_7);
    
#line 2549 
    ldv_free((void *)ldv_25_ldv_param_3_7);
    
#line 2550 
    ldv_free((void *)ldv_25_ldv_param_1_6);
    
#line 2557 
    goto ldv_call_25;
    case 2: 
#line 2560 
    ;
    
#line 2562 
    if (ldv_25_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 2564 
      (*(ldv_25_container->release))(ldv_25_resource_0,ldv_25_resource_1); else ;
    
#line 2572 
    goto ldv_main_25;
    case 3: 
#line 2575 
    ;
    
#line 2579 
    tmp_9 = ldv_undef_int();
    
#line 2579 
    if (tmp_9 != 0) 
#line 2582 
                    (*ldv_emg_alias_default_llseek_3)(ldv_25_resource_1,ldv_25_ldv_param_1_2,ldv_25_ldv_param_2_3);
    else {
      
#line 2588 
      ldv_25_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 2589 
      ldv_25_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 2594 
      ldv_emg_wrapper_read_file_tx99_power_3(ldv_25_resource_1,ldv_25_ldv_param_1_4,ldv_25_size_cnt,ldv_25_ldv_param_3_5);
      
#line 2598 
      ldv_free((void *)ldv_25_ldv_param_1_4);
      
#line 2599 
      ldv_free((void *)ldv_25_ldv_param_3_5);
    }
    
#line 2603 
    goto ldv_52352;
    default: 
#line 2605 
    ;
    
#line 2605 
    __VERIFIER_assume(0);
  }
  ldv_52352: 
#line 2614 
  ;
  
#line 2614 
  goto ldv_call_25;
  
#line 2616 
  __retres = (void *)0;
  return_label: 
#line 2616 
                return __retres;
}


#line 2621  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_deregister_12_2(struct ieee80211_hw *arg0)
{
  int ret;
  struct ldv_struct_ieee80211_scenario_19 *cf_arg_19;
  int tmp;
  
#line 2624 
  tmp = ldv_undef_int();
  
#line 2624 
  switch (tmp) {
    case 0: 
#line 2625 
    ;
    
#line 2626 
    ret = pthread_join(ldv_thread_19,(void **)0);
    
#line 2627 
    __VERIFIER_assume(ret == 0);
    
#line 2628 
    goto ldv_52360;
    default: 
#line 2630 
    ;
    
#line 2630 
    __VERIFIER_assume(0);
  }
  ldv_52360: 
#line 2631 
  ;
  
#line 2632 
  return;
}


#line 2636  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_ieee80211_scenario_19(void *arg0)
{
  void *__retres;
  unsigned int ldv_19_ldv_param_2_72;
  unsigned short *ldv_19_ldv_param_5_35;
  struct ieee80211_key_conf *ldv_19_ldv_param_4_49;
  struct survey_info *ldv_19_ldv_param_2_7;
  unsigned short ldv_19_ldv_param_2_17;
  int ldv_19_ldv_param_2_28;
  struct ieee80211_vif *ldv_19_ldv_param_1_60;
  struct ethtool_stats *ldv_19_ldv_param_2_43;
  unsigned int ldv_19_ldv_param_3_63;
  struct ieee80211_vif *ldv_19_ldv_param_1_29;
  struct ieee80211_vif *ldv_19_ldv_param_1_19;
  _Bool ldv_19_ldv_param_3_10;
  struct ieee80211_vif *ldv_19_ldv_param_1_57;
  _Bool ldv_19_ldv_param_3_70;
  struct sk_buff *ldv_19_ldv_param_2_12;
  struct ieee80211_vif *ldv_19_ldv_param_1_61;
  int *ldv_19_ldv_param_2_20;
  struct ieee80211_vif *ldv_19_ldv_param_1_30;
  unsigned short ldv_19_ldv_param_4_34;
  struct ieee80211_vif *ldv_19_ldv_param_1_16;
  struct ieee80211_vif *ldv_19_ldv_param_1_21;
  struct dentry *ldv_19_ldv_param_3_15;
  enum ieee80211_frame_release_type *ldv_19_ldv_param_4_25;
  unsigned long long ldv_19_ldv_param_2_51;
  struct ieee80211_vif *ldv_19_ldv_param_1_68;
  unsigned long long *ldv_19_ldv_param_3_44;
  unsigned int ldv_19_ldv_param_1_56;
  struct ieee80211_hw *ldv_19_resource;
  unsigned int *ldv_19_ldv_param_2_66;
  enum set_key_cmd *ldv_19_ldv_param_1_46;
  struct ieee80211_vif *ldv_19_ldv_param_1_37;
  _Bool ldv_19_ldv_param_1_64;
  struct ieee80211_vif *ldv_19_ldv_param_1_50;
  unsigned int *ldv_19_ldv_param_2_55;
  unsigned int ldv_19_ldv_param_1_71;
  enum nl80211_iftype *ldv_19_ldv_param_2_69;
  struct ieee80211_vif *ldv_19_ldv_param_1_52;
  struct cfg80211_wowlan *ldv_19_ldv_param_1_73;
  struct ieee80211_vif *ldv_19_ldv_param_1_13;
  _Bool ldv_19_ldv_param_5_26;
  enum sta_notify_cmd *ldv_19_ldv_param_2_3;
  enum ieee80211_sta_state *ldv_19_ldv_param_4_40;
  unsigned char ldv_19_ldv_param_6_36;
  unsigned short ldv_19_ldv_param_2_23;
  unsigned int ldv_19_ldv_param_1_65;
  struct ieee80211_tx_queue_params *ldv_19_ldv_param_3_18;
  struct ieee80211_vif *ldv_19_ldv_param_1_2;
  short ldv_19_ldv_param_1_45;
  struct ieee80211_vif *ldv_19_ldv_param_1_5;
  struct ieee80211_tx_control *ldv_19_ldv_param_1_11;
  unsigned char *ldv_19_ldv_param_3_59;
  struct ieee80211_bss_conf *ldv_19_ldv_param_2_62;
  struct ieee80211_vif *ldv_19_ldv_param_1_8;
  unsigned long long ldv_19_ldv_param_3_67;
  struct ieee80211_vif *ldv_19_ldv_param_1_27;
  unsigned char *ldv_19_ldv_param_2_53;
  struct ieee80211_vif *ldv_19_ldv_param_2_47;
  struct ieee80211_vif *ldv_19_ldv_param_1_42;
  struct ieee80211_low_level_stats *ldv_19_ldv_param_1_41;
  unsigned int ldv_19_ldv_param_2_58;
  struct ieee80211_sta *ldv_19_ldv_param_3_48;
  int ldv_19_ldv_param_1_6;
  struct ieee80211_vif *ldv_19_ldv_param_1_31;
  struct ieee80211_sta *ldv_19_ldv_param_3_4;
  enum ieee80211_sta_state *ldv_19_ldv_param_3_39;
  struct ieee80211_sta *ldv_19_ldv_param_2_38;
  enum ieee80211_ampdu_mlme_action *ldv_19_ldv_param_2_32;
  struct ieee80211_sta *ldv_19_ldv_param_2_14;
  struct ieee80211_sta *ldv_19_ldv_param_1_22;
  unsigned int ldv_19_ldv_param_2_9;
  struct ieee80211_sta *ldv_19_ldv_param_3_33;
  int ldv_19_ldv_param_3_24;
  unsigned int *ldv_19_ldv_param_1_54;
  int tmp_1;
  int tmp_2;
  
#line 2711 
  int ldv_19_ret = ldv_undef_int();
  
#line 2714 
  struct ldv_struct_ieee80211_scenario_19 *data = (struct ldv_struct_ieee80211_scenario_19 *)arg0;
  
#line 2718 
  ldv_19_ret = ldv_undef_int();
  
#line 2721 
  if (data != (struct ldv_struct_ieee80211_scenario_19 *)0) {
    
#line 2722 
    ldv_19_resource = data->arg0;
    
#line 2723 
    ldv_free((void *)data);
  }
  else ;
  
#line 2731 
  goto ldv_main_19;
  
#line 2733 
  __retres = (void *)0;
  
#line 2733 
  goto return_label;
  ldv_main_19: 
#line 2736 
  ;
  
#line 2739 
  tmp_1 = ldv_undef_int();
  
#line 2739 
  if (tmp_1 != 0) {
    int tmp_0;
    
#line 2742 
    rtnl_lock();
    
#line 2744 
    ldv_19_ret = ldv_emg_wrapper_ath9k_start_2(ldv_19_resource);
    
#line 2746 
    ldv_19_ret = ldv_filter_err_code(ldv_19_ret);
    
#line 2747 
    rtnl_unlock();
    
#line 2750 
    tmp_0 = ldv_undef_int();
    
#line 2750 
    if (tmp_0 != 0) {
      
#line 2752 
      __VERIFIER_assume(ldv_19_ret == 0);
      
#line 2759 
      goto ldv_started_19;
    }
    else {
      
#line 2763 
      __VERIFIER_assume(ldv_19_ret != 0);
      
#line 2770 
      goto ldv_main_19;
    }
  }
  else {
    
#line 2779 
    __retres = (void *)0;
    
#line 2779 
    goto return_label;
  }
  
#line 2782 
  __retres = (void *)0;
  
#line 2782 
  goto return_label;
  ldv_started_19: 
#line 2785 
  ;
  
#line 2788 
  tmp_2 = ldv_undef_int();
  
#line 2788 
  switch (tmp_2) {
    int tmp_7;
    case 1: 
#line 2789 
    ;
    
#line 2791 
    ldv_19_ldv_param_1_73 = (struct cfg80211_wowlan *)ldv_xmalloc_unknown_size(0UL);
    
#line 2796 
    ath9k_suspend(ldv_19_resource,ldv_19_ldv_param_1_73);
    
#line 2800 
    ldv_free((void *)ldv_19_ldv_param_1_73);
    
#line 2805 
    ath9k_resume(ldv_19_resource);
    
#line 2812 
    goto ldv_started_19;
    case 2: 
#line 2815 
    ;
    
#line 2818 
    rtnl_lock();
    
#line 2820 
    ldv_emg_wrapper_ath9k_stop_29(ldv_19_resource);
    
#line 2822 
    rtnl_unlock();
    
#line 2829 
    goto ldv_main_19;
    case 3: 
#line 2832 
    ;
    
#line 2834 
    ldv_19_ldv_param_3_4 = (struct ieee80211_sta *)ldv_xmalloc_unknown_size(0UL);
    
#line 2835 
    ldv_19_ldv_param_2_3 = (enum sta_notify_cmd *)ldv_xmalloc_unknown_size(0UL);
    
#line 2836 
    ldv_19_ldv_param_1_2 = (struct ieee80211_vif *)ldv_xmalloc_unknown_size(0UL);
    
#line 2839 
    tmp_7 = ldv_undef_int();
    
#line 2839 
    switch (tmp_7) {
      case 1: 
#line 2840 
      ;
      
#line 2843 
      ldv_emg_wrapper_ath9k_sta_notify_3(ldv_19_resource,ldv_19_ldv_param_1_2,*ldv_19_ldv_param_2_3,ldv_19_ldv_param_3_4);
      
#line 2846 
      goto ldv_52446;
      case 2: 
#line 2848 
      ;
      
#line 2851 
      ldv_emg_wrapper_ath9k_tx_frames_pending_28(ldv_19_resource);
      
#line 2854 
      goto ldv_52446;
      case 3: 
#line 2856 
      ;
      
#line 2862 
      ldv_emg_wrapper_ath9k_set_antenna_27(ldv_19_resource,ldv_19_ldv_param_1_71,ldv_19_ldv_param_2_72);
      
#line 2868 
      goto ldv_52446;
      case 4: 
#line 2870 
      ;
      
#line 2872 
      ldv_19_ldv_param_1_68 = (struct ieee80211_vif *)ldv_xmalloc_unknown_size(0UL);
      
#line 2873 
      ldv_19_ldv_param_2_69 = (enum nl80211_iftype *)ldv_xmalloc_unknown_size(0UL);
      
#line 2878 
      ldv_emg_wrapper_ath9k_change_interface_23(ldv_19_resource,ldv_19_ldv_param_1_68,*ldv_19_ldv_param_2_69,(_Bool)((_Bool)((int)ldv_19_ldv_param_3_70) != 0));
      
#line 2882 
      ldv_free((void *)ldv_19_ldv_param_1_68);
      
#line 2883 
      ldv_free((void *)ldv_19_ldv_param_2_69);
      
#line 2886 
      goto ldv_52446;
      case 5: 
#line 2888 
      ;
      
#line 2890 
      ldv_19_ldv_param_2_66 = (unsigned int *)ldv_xmalloc_unknown_size(0UL);
      
#line 2895 
      ldv_emg_wrapper_ath9k_configure_filter_26(ldv_19_resource,ldv_19_ldv_param_1_65,ldv_19_ldv_param_2_66,ldv_19_ldv_param_3_67);
      
#line 2899 
      ldv_free((void *)ldv_19_ldv_param_2_66);
      
#line 2902 
      goto ldv_52446;
      case 6: 
#line 2904 
      ;
      
#line 2910 
      ath9k_set_wakeup(ldv_19_resource,(_Bool)((bool)((int)ldv_19_ldv_param_1_64) != 0));
      
#line 2916 
      goto ldv_52446;
      case 7: 
#line 2918 
      ;
      
#line 2921 
      ldv_emg_wrapper_ath9k_tx_last_beacon_25(ldv_19_resource);
      
#line 2924 
      goto ldv_52446;
      case 8: 
#line 2926 
      ;
      
#line 2928 
      ldv_19_ldv_param_2_62 = (struct ieee80211_bss_conf *)ldv_xmalloc_unknown_size(0UL);
      
#line 2929 
      ldv_19_ldv_param_1_61 = (struct ieee80211_vif *)ldv_xmalloc_unknown_size(0UL);
      
#line 2934 
      ldv_emg_wrapper_ath9k_bss_info_changed_24(ldv_19_resource,ldv_19_ldv_param_1_61,ldv_19_ldv_param_2_62,ldv_19_ldv_param_3_63);
      
#line 2938 
      ldv_free((void *)ldv_19_ldv_param_2_62);
      
#line 2939 
      ldv_free((void *)ldv_19_ldv_param_1_61);
      
#line 2942 
      goto ldv_52446;
      case 9: 
#line 2944 
      ;
      
#line 2946 
      ldv_19_ldv_param_1_60 = (struct ieee80211_vif *)ldv_xmalloc_unknown_size(0UL);
      
#line 2951 
      ldv_emg_wrapper_ath9k_remove_interface_10(ldv_19_resource,ldv_19_ldv_param_1_60);
      
#line 2955 
      ldv_free((void *)ldv_19_ldv_param_1_60);
      
#line 2958 
      goto ldv_52446;
      case 10: 
#line 2960 
      ;
      
#line 2962 
      ldv_19_ldv_param_1_57 = (struct ieee80211_vif *)ldv_xmalloc_unknown_size(0UL);
      
#line 2963 
      ldv_19_ldv_param_3_59 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
      
#line 2968 
      ath9k_get_et_strings(ldv_19_resource,ldv_19_ldv_param_1_57,ldv_19_ldv_param_2_58,ldv_19_ldv_param_3_59);
      
#line 2972 
      ldv_free((void *)ldv_19_ldv_param_1_57);
      
#line 2973 
      ldv_free((void *)ldv_19_ldv_param_3_59);
      
#line 2976 
      goto ldv_52446;
      case 11: 
#line 2978 
      ;
      
#line 2984 
      ldv_emg_wrapper_ath9k_config_22(ldv_19_resource,ldv_19_ldv_param_1_56);
      
#line 2990 
      goto ldv_52446;
      case 12: 
#line 2992 
      ;
      
#line 2994 
      ldv_19_ldv_param_1_54 = (unsigned int *)ldv_xmalloc_unknown_size(0UL);
      
#line 2995 
      ldv_19_ldv_param_2_55 = (unsigned int *)ldv_xmalloc_unknown_size(0UL);
      
#line 3000 
      ldv_emg_wrapper_ath9k_get_antenna_21(ldv_19_resource,ldv_19_ldv_param_1_54,ldv_19_ldv_param_2_55);
      
#line 3004 
      ldv_free((void *)ldv_19_ldv_param_1_54);
      
#line 3005 
      ldv_free((void *)ldv_19_ldv_param_2_55);
      
#line 3008 
      goto ldv_52446;
      case 13: 
#line 3010 
      ;
      
#line 3012 
      ldv_19_ldv_param_1_52 = (struct ieee80211_vif *)ldv_xmalloc_unknown_size(0UL);
      
#line 3013 
      ldv_19_ldv_param_2_53 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
      
#line 3018 
      ldv_emg_wrapper_ath9k_sw_scan_start_20(ldv_19_resource,ldv_19_ldv_param_1_52,ldv_19_ldv_param_2_53);
      
#line 3022 
      ldv_free((void *)ldv_19_ldv_param_1_52);
      
#line 3023 
      ldv_free((void *)ldv_19_ldv_param_2_53);
      
#line 3026 
      goto ldv_52446;
      case 14: 
#line 3028 
      ;
      
#line 3030 
      ldv_19_ldv_param_1_50 = (struct ieee80211_vif *)ldv_xmalloc_unknown_size(0UL);
      
#line 3035 
      ldv_emg_wrapper_ath9k_set_tsf_19(ldv_19_resource,ldv_19_ldv_param_1_50,ldv_19_ldv_param_2_51);
      
#line 3039 
      ldv_free((void *)ldv_19_ldv_param_1_50);
      
#line 3042 
      goto ldv_52446;
      case 15: 
#line 3044 
      ;
      
#line 3047 
      ath9k_rfkill_poll_state(ldv_19_resource);
      
#line 3050 
      goto ldv_52446;
      case 16: 
#line 3052 
      ;
      
#line 3054 
      ldv_19_ldv_param_2_47 = (struct ieee80211_vif *)ldv_xmalloc_unknown_size(0UL);
      
#line 3055 
      ldv_19_ldv_param_1_46 = (enum set_key_cmd *)ldv_xmalloc_unknown_size(0UL);
      
#line 3056 
      ldv_19_ldv_param_4_49 = (struct ieee80211_key_conf *)ldv_xmalloc_unknown_size(0UL);
      
#line 3057 
      ldv_19_ldv_param_3_48 = (struct ieee80211_sta *)ldv_xmalloc_unknown_size(0UL);
      
#line 3062 
      ldv_emg_wrapper_ath9k_set_key_18(ldv_19_resource,*ldv_19_ldv_param_1_46,ldv_19_ldv_param_2_47,ldv_19_ldv_param_3_48,ldv_19_ldv_param_4_49);
      
#line 3066 
      ldv_free((void *)ldv_19_ldv_param_2_47);
      
#line 3067 
      ldv_free((void *)ldv_19_ldv_param_1_46);
      
#line 3068 
      ldv_free((void *)ldv_19_ldv_param_4_49);
      
#line 3069 
      ldv_free((void *)ldv_19_ldv_param_3_48);
      
#line 3072 
      goto ldv_52446;
      case 17: 
#line 3074 
      ;
      
#line 3080 
      ldv_emg_wrapper_ath9k_set_coverage_class_17(ldv_19_resource,(short)((int)ldv_19_ldv_param_1_45));
      
#line 3086 
      goto ldv_52446;
      case 18: 
#line 3088 
      ;
      
#line 3090 
      ldv_19_ldv_param_2_43 = (struct ethtool_stats *)ldv_xmalloc_unknown_size(0UL);
      
#line 3091 
      ldv_19_ldv_param_3_44 = (unsigned long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 3092 
      ldv_19_ldv_param_1_42 = (struct ieee80211_vif *)ldv_xmalloc_unknown_size(0UL);
      
#line 3097 
      ath9k_get_et_stats(ldv_19_resource,ldv_19_ldv_param_1_42,ldv_19_ldv_param_2_43,ldv_19_ldv_param_3_44);
      
#line 3101 
      ldv_free((void *)ldv_19_ldv_param_2_43);
      
#line 3102 
      ldv_free((void *)ldv_19_ldv_param_3_44);
      
#line 3103 
      ldv_free((void *)ldv_19_ldv_param_1_42);
      
#line 3106 
      goto ldv_52446;
      case 19: 
#line 3108 
      ;
      
#line 3110 
      ldv_19_ldv_param_1_41 = (struct ieee80211_low_level_stats *)ldv_xmalloc_unknown_size(0UL);
      
#line 3115 
      ldv_emg_wrapper_ath9k_get_stats_16(ldv_19_resource,ldv_19_ldv_param_1_41);
      
#line 3119 
      ldv_free((void *)ldv_19_ldv_param_1_41);
      
#line 3122 
      goto ldv_52446;
      case 20: 
#line 3124 
      ;
      
#line 3126 
      ldv_19_ldv_param_1_37 = (struct ieee80211_vif *)ldv_xmalloc_unknown_size(0UL);
      
#line 3127 
      ldv_19_ldv_param_2_38 = (struct ieee80211_sta *)ldv_xmalloc_unknown_size(0UL);
      
#line 3128 
      ldv_19_ldv_param_4_40 = (enum ieee80211_sta_state *)ldv_xmalloc_unknown_size(0UL);
      
#line 3129 
      ldv_19_ldv_param_3_39 = (enum ieee80211_sta_state *)ldv_xmalloc_unknown_size(0UL);
      
#line 3134 
      ldv_emg_wrapper_ath9k_sta_state_15(ldv_19_resource,ldv_19_ldv_param_1_37,ldv_19_ldv_param_2_38,*ldv_19_ldv_param_3_39,*ldv_19_ldv_param_4_40);
      
#line 3138 
      ldv_free((void *)ldv_19_ldv_param_1_37);
      
#line 3139 
      ldv_free((void *)ldv_19_ldv_param_2_38);
      
#line 3140 
      ldv_free((void *)ldv_19_ldv_param_4_40);
      
#line 3141 
      ldv_free((void *)ldv_19_ldv_param_3_39);
      
#line 3144 
      goto ldv_52446;
      case 21: 
#line 3146 
      ;
      
#line 3148 
      ldv_19_ldv_param_1_31 = (struct ieee80211_vif *)ldv_xmalloc_unknown_size(0UL);
      
#line 3149 
      ldv_19_ldv_param_3_33 = (struct ieee80211_sta *)ldv_xmalloc_unknown_size(0UL);
      
#line 3150 
      ldv_19_ldv_param_5_35 = (unsigned short *)ldv_xmalloc_unknown_size(0UL);
      
#line 3151 
      ldv_19_ldv_param_2_32 = (enum ieee80211_ampdu_mlme_action *)ldv_xmalloc_unknown_size(0UL);
      
#line 3156 
      ldv_emg_wrapper_ath9k_ampdu_action_12(ldv_19_resource,ldv_19_ldv_param_1_31,*ldv_19_ldv_param_2_32,ldv_19_ldv_param_3_33,(unsigned short)((int)ldv_19_ldv_param_4_34),ldv_19_ldv_param_5_35,(unsigned char)((int)ldv_19_ldv_param_6_36));
      
#line 3160 
      ldv_free((void *)ldv_19_ldv_param_1_31);
      
#line 3161 
      ldv_free((void *)ldv_19_ldv_param_3_33);
      
#line 3162 
      ldv_free((void *)ldv_19_ldv_param_5_35);
      
#line 3163 
      ldv_free((void *)ldv_19_ldv_param_2_32);
      
#line 3166 
      goto ldv_52446;
      case 22: 
#line 3168 
      ;
      
#line 3170 
      ldv_19_ldv_param_1_30 = (struct ieee80211_vif *)ldv_xmalloc_unknown_size(0UL);
      
#line 3175 
      ldv_emg_wrapper_ath9k_sw_scan_complete_13(ldv_19_resource,ldv_19_ldv_param_1_30);
      
#line 3179 
      ldv_free((void *)ldv_19_ldv_param_1_30);
      
#line 3182 
      goto ldv_52446;
      case 23: 
#line 3184 
      ;
      
#line 3186 
      ldv_19_ldv_param_1_29 = (struct ieee80211_vif *)ldv_xmalloc_unknown_size(0UL);
      
#line 3191 
      ldv_emg_wrapper_ath9k_get_tsf_9(ldv_19_resource,ldv_19_ldv_param_1_29);
      
#line 3195 
      ldv_free((void *)ldv_19_ldv_param_1_29);
      
#line 3198 
      goto ldv_52446;
      case 24: 
#line 3200 
      ;
      
#line 3202 
      ldv_19_ldv_param_1_27 = (struct ieee80211_vif *)ldv_xmalloc_unknown_size(0UL);
      
#line 3207 
      ath9k_get_et_sset_count(ldv_19_resource,ldv_19_ldv_param_1_27,ldv_19_ldv_param_2_28);
      
#line 3211 
      ldv_free((void *)ldv_19_ldv_param_1_27);
      
#line 3214 
      goto ldv_52446;
      case 25: 
#line 3216 
      ;
      
#line 3218 
      ldv_19_ldv_param_1_22 = (struct ieee80211_sta *)ldv_xmalloc_unknown_size(0UL);
      
#line 3219 
      ldv_19_ldv_param_4_25 = (enum ieee80211_frame_release_type *)ldv_xmalloc_unknown_size(0UL);
      
#line 3224 
      ath9k_release_buffered_frames(ldv_19_resource,ldv_19_ldv_param_1_22,(unsigned short)((int)ldv_19_ldv_param_2_23),ldv_19_ldv_param_3_24,*ldv_19_ldv_param_4_25,(_Bool)((bool)((int)ldv_19_ldv_param_5_26) != 0));
      
#line 3228 
      ldv_free((void *)ldv_19_ldv_param_1_22);
      
#line 3229 
      ldv_free((void *)ldv_19_ldv_param_4_25);
      
#line 3232 
      goto ldv_52446;
      case 26: 
#line 3234 
      ;
      
#line 3236 
      ldv_19_ldv_param_1_21 = (struct ieee80211_vif *)ldv_xmalloc_unknown_size(0UL);
      
#line 3241 
      ldv_emg_wrapper_ath9k_reset_tsf_11(ldv_19_resource,ldv_19_ldv_param_1_21);
      
#line 3245 
      ldv_free((void *)ldv_19_ldv_param_1_21);
      
#line 3248 
      goto ldv_52446;
      case 27: 
#line 3250 
      ;
      
#line 3252 
      ldv_19_ldv_param_2_20 = (int *)ldv_xmalloc_unknown_size(0UL);
      
#line 3253 
      ldv_19_ldv_param_1_19 = (struct ieee80211_vif *)ldv_xmalloc_unknown_size(0UL);
      
#line 3258 
      ldv_emg_wrapper_ath9k_get_txpower_14(ldv_19_resource,ldv_19_ldv_param_1_19,ldv_19_ldv_param_2_20);
      
#line 3262 
      ldv_free((void *)ldv_19_ldv_param_2_20);
      
#line 3263 
      ldv_free((void *)ldv_19_ldv_param_1_19);
      
#line 3266 
      goto ldv_52446;
      case 28: 
#line 3268 
      ;
      
#line 3270 
      ldv_19_ldv_param_3_18 = (struct ieee80211_tx_queue_params *)ldv_xmalloc_unknown_size(0UL);
      
#line 3271 
      ldv_19_ldv_param_1_16 = (struct ieee80211_vif *)ldv_xmalloc_unknown_size(0UL);
      
#line 3276 
      ldv_emg_wrapper_ath9k_conf_tx_8(ldv_19_resource,ldv_19_ldv_param_1_16,(unsigned short)((int)ldv_19_ldv_param_2_17),ldv_19_ldv_param_3_18);
      
#line 3280 
      ldv_free((void *)ldv_19_ldv_param_3_18);
      
#line 3281 
      ldv_free((void *)ldv_19_ldv_param_1_16);
      
#line 3284 
      goto ldv_52446;
      case 29: 
#line 3286 
      ;
      
#line 3288 
      ldv_19_ldv_param_2_14 = (struct ieee80211_sta *)ldv_xmalloc_unknown_size(0UL);
      
#line 3289 
      ldv_19_ldv_param_1_13 = (struct ieee80211_vif *)ldv_xmalloc_unknown_size(0UL);
      
#line 3290 
      ldv_19_ldv_param_3_15 = (struct dentry *)ldv_xmalloc_unknown_size(0UL);
      
#line 3295 
      ath9k_sta_add_debugfs(ldv_19_resource,ldv_19_ldv_param_1_13,ldv_19_ldv_param_2_14,ldv_19_ldv_param_3_15);
      
#line 3299 
      ldv_free((void *)ldv_19_ldv_param_2_14);
      
#line 3300 
      ldv_free((void *)ldv_19_ldv_param_1_13);
      
#line 3301 
      ldv_free((void *)ldv_19_ldv_param_3_15);
      
#line 3304 
      goto ldv_52446;
      case 30: 
#line 3306 
      ;
      
#line 3308 
      ldv_19_ldv_param_1_11 = (struct ieee80211_tx_control *)ldv_xmalloc_unknown_size(0UL);
      
#line 3309 
      ldv_19_ldv_param_2_12 = (struct sk_buff *)ldv_xmalloc_unknown_size(0UL);
      
#line 3314 
      ldv_emg_wrapper_ath9k_tx_7(ldv_19_resource,ldv_19_ldv_param_1_11,ldv_19_ldv_param_2_12);
      
#line 3318 
      ldv_free((void *)ldv_19_ldv_param_1_11);
      
#line 3319 
      ldv_free((void *)ldv_19_ldv_param_2_12);
      
#line 3322 
      goto ldv_52446;
      case 31: 
#line 3324 
      ;
      
#line 3326 
      ldv_19_ldv_param_1_8 = (struct ieee80211_vif *)ldv_xmalloc_unknown_size(0UL);
      
#line 3331 
      ldv_emg_wrapper_ath9k_flush_6(ldv_19_resource,ldv_19_ldv_param_1_8,ldv_19_ldv_param_2_9,(_Bool)((_Bool)((int)ldv_19_ldv_param_3_10) != 0));
      
#line 3335 
      ldv_free((void *)ldv_19_ldv_param_1_8);
      
#line 3338 
      goto ldv_52446;
      case 32: 
#line 3340 
      ;
      
#line 3342 
      ldv_19_ldv_param_2_7 = (struct survey_info *)ldv_xmalloc_unknown_size(0UL);
      
#line 3347 
      ldv_emg_wrapper_ath9k_get_survey_5(ldv_19_resource,ldv_19_ldv_param_1_6,ldv_19_ldv_param_2_7);
      
#line 3351 
      ldv_free((void *)ldv_19_ldv_param_2_7);
      
#line 3354 
      goto ldv_52446;
      case 33: 
#line 3356 
      ;
      
#line 3358 
      ldv_19_ldv_param_1_5 = (struct ieee80211_vif *)ldv_xmalloc_unknown_size(0UL);
      
#line 3363 
      ldv_emg_wrapper_ath9k_add_interface_4(ldv_19_resource,ldv_19_ldv_param_1_5);
      
#line 3367 
      ldv_free((void *)ldv_19_ldv_param_1_5);
      
#line 3370 
      goto ldv_52446;
      default: 
#line 3372 
      ;
      
#line 3372 
      __VERIFIER_assume(0);
    }
    ldv_52446: 
#line 3374 
    ;
    
#line 3374 
    goto ldv_52480;
    default: 
#line 3376 
    ;
    
#line 3376 
    __VERIFIER_assume(0);
  }
  ldv_52480: 
#line 3379 
  ;
  
#line 3379 
  ldv_free((void *)ldv_19_ldv_param_3_4);
  
#line 3380 
  ldv_free((void *)ldv_19_ldv_param_2_3);
  
#line 3381 
  ldv_free((void *)ldv_19_ldv_param_1_2);
  
#line 3388 
  goto ldv_started_19;
  
#line 3390 
  __retres = (void *)0;
  return_label: 
#line 3390 
                return __retres;
}


#line 3395  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_26(void *arg0)
{
  void *__retres;
  struct file *ldv_26_resource_1;
  int ldv_26_ldv_param_2_3;
  long long ldv_26_ldv_param_1_2;
  char *ldv_26_ldv_param_1_4;
  struct inode *ldv_26_resource_0;
  unsigned long ldv_26_size_cnt;
  long long *ldv_26_ldv_param_3_5;
  char *ldv_26_ldv_param_1_6;
  long long *ldv_26_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 3406 
  struct file_operations *ldv_26_container = ldv_emg_alias_fops_ani_2;
  
#line 3407 
  int ldv_26_ret = ldv_undef_int();
  
#line 3410 
  struct ldv_struct_character_driver_scenario_15 *data = (struct ldv_struct_character_driver_scenario_15 *)arg0;
  
#line 3414 
  ldv_26_ret = ldv_undef_int();
  
#line 3417 
  if (data != (struct ldv_struct_character_driver_scenario_15 *)0) {
    
#line 3418 
    ldv_26_container = data->arg0;
    
#line 3419 
    ldv_free((void *)data);
  }
  else ;
  
#line 3424 
  ldv_26_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 3425 
  tmp_1 = ldv_undef_int();
  
#line 3425 
  ldv_26_size_cnt = (unsigned long)tmp_1;
  
#line 3432 
  goto ldv_main_26;
  
#line 3434 
  __retres = (void *)0;
  
#line 3434 
  goto return_label;
  ldv_main_26: 
#line 3437 
  ;
  
#line 3440 
  tmp_3 = ldv_undef_int();
  
#line 3440 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 3443 
    ldv_26_ret = (*ldv_emg_alias_simple_open_5)(ldv_26_resource_0,ldv_26_resource_1);
    
#line 3445 
    ldv_26_ret = ldv_filter_err_code(ldv_26_ret);
    
#line 3448 
    tmp_2 = ldv_undef_int();
    
#line 3448 
    if (tmp_2 != 0) {
      
#line 3450 
      __VERIFIER_assume(ldv_26_ret == 0);
      
#line 3457 
      goto ldv_call_26;
    }
    else {
      
#line 3461 
      __VERIFIER_assume(ldv_26_ret != 0);
      
#line 3468 
      goto ldv_main_26;
    }
  }
  else {
    
#line 3473 
    ldv_free((void *)ldv_26_resource_0);
    
#line 3481 
    __retres = (void *)0;
    
#line 3481 
    goto return_label;
  }
  
#line 3484 
  __retres = (void *)0;
  
#line 3484 
  goto return_label;
  ldv_call_26: 
#line 3487 
  ;
  
#line 3490 
  tmp_4 = ldv_undef_int();
  
#line 3490 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 3491 
    ;
    
#line 3493 
    ldv_26_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 3494 
    ldv_26_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 3503 
    __VERIFIER_assume(ldv_26_size_cnt <= 2147479552UL);
    
#line 3505 
    ldv_emg_wrapper_write_file_ani_4(ldv_26_resource_1,ldv_26_ldv_param_1_6,ldv_26_size_cnt,ldv_26_ldv_param_3_7);
    
#line 3509 
    ldv_free((void *)ldv_26_ldv_param_3_7);
    
#line 3510 
    ldv_free((void *)ldv_26_ldv_param_1_6);
    
#line 3517 
    goto ldv_call_26;
    case 2: 
#line 3520 
    ;
    
#line 3522 
    if (ldv_26_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 3524 
      (*(ldv_26_container->release))(ldv_26_resource_0,ldv_26_resource_1); else ;
    
#line 3532 
    goto ldv_main_26;
    case 3: 
#line 3535 
    ;
    
#line 3539 
    tmp_9 = ldv_undef_int();
    
#line 3539 
    if (tmp_9 != 0) 
#line 3542 
                    (*ldv_emg_alias_default_llseek_3)(ldv_26_resource_1,ldv_26_ldv_param_1_2,ldv_26_ldv_param_2_3);
    else {
      
#line 3548 
      ldv_26_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 3549 
      ldv_26_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 3554 
      ldv_emg_wrapper_read_file_ani_3(ldv_26_resource_1,ldv_26_ldv_param_1_4,ldv_26_size_cnt,ldv_26_ldv_param_3_5);
      
#line 3558 
      ldv_free((void *)ldv_26_ldv_param_3_5);
      
#line 3559 
      ldv_free((void *)ldv_26_ldv_param_1_4);
    }
    
#line 3563 
    goto ldv_52502;
    default: 
#line 3565 
    ;
    
#line 3565 
    __VERIFIER_assume(0);
  }
  ldv_52502: 
#line 3574 
  ;
  
#line 3574 
  goto ldv_call_26;
  
#line 3576 
  __retres = (void *)0;
  return_label: 
#line 3576 
                return __retres;
}


#line 3581  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_platform_driver_unregister(struct platform_driver *arg0)
{
  
#line 3584 
  struct platform_driver *ldv_3_platform_driver = ldv_emg_alias_ath_ahb_driver_2;
  
#line 3587 
  ldv_3_platform_driver = arg0;
  
#line 3591 
  ldv_dispatch_deregister_3_1(ldv_3_platform_driver);
  
#line 3595 
  goto return_label;
  return_label: 
#line 3597 
                return;
}


#line 3602  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
struct dentry *ldv_emg_debugfs_create_file(char *arg0, unsigned short arg1, struct dentry *arg2, void *arg3, struct file_operations *arg4)
{
  struct dentry *__retres;
  struct dentry *ldv_13_dentry;
  struct file_operations *ldv_13_file_operations;
  int tmp_1;
  
#line 3610 
  tmp_1 = ldv_undef_int();
  
#line 3610 
  if (tmp_1 != 0) {
    
#line 3612 
    ldv_13_dentry = (struct dentry *)ldv_xmalloc_unknown_size(0UL);
    
#line 3613 
    ldv_13_file_operations = arg4;
    
#line 3617 
    ldv_dispatch_register_13_3(ldv_13_file_operations);
    
#line 3621 
    __retres = ldv_13_dentry;
    
#line 3621 
    goto return_label;
  }
  else {
    struct dentry *tmp_0;
    
#line 3628 
    tmp_0 = (struct dentry *)ERR_PTR(-19L);
    
#line 3628 
    __retres = tmp_0;
    
#line 3628 
    goto return_label;
  }
  return_label: 
#line 3610 
                return __retres;
}


#line 3638  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_tasklet_schedule(struct tasklet_struct *arg0)
{
  unsigned long ldv_10_ldv_param_0_2;
  struct tasklet_struct *ldv_10_tasklet_struct;
  
#line 3645 
  ldv_10_tasklet_struct = arg0;
  
#line 3652 
  if (ldv_10_tasklet_struct->count.counter == 0) {
    
#line 3653 
    if (ldv_10_tasklet_struct->func != (void (*)(unsigned long ))0) 
#line 3655 
                                                                    (*(ldv_10_tasklet_struct->func))(ldv_10_ldv_param_0_2); else ;
  }
  else ;
  
#line 3664 
  goto return_label;
  return_label: 
#line 3666 
                return;
}


#line 3671  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_instance_register_2_3(struct timer_list *arg0)
{
  int ret;
  struct ldv_struct_timer_scenario_21 *cf_arg_21;
  int tmp;
  
#line 3674 
  tmp = ldv_undef_int();
  
#line 3674 
  switch (tmp) {
    case 0: 
#line 3675 
    ;
    
#line 3676 
    cf_arg_21 = (struct ldv_struct_timer_scenario_21 *)ldv_xmalloc(16UL);
    
#line 3677 
    cf_arg_21->arg0 = arg0;
    
#line 3678 
    ret = pthread_create(& ldv_thread_21,(pthread_attr_t const *)0,& ldv_timer_scenario_21,(void *)cf_arg_21);
    
#line 3679 
    __VERIFIER_assume(ret == 0);
    
#line 3680 
    goto ldv_52528;
    default: 
#line 3682 
    ;
    
#line 3682 
    __VERIFIER_assume(0);
  }
  ldv_52528: 
#line 3683 
  ;
  
#line 3684 
  return;
}


#line 3688  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_pm_ops_scenario_20(void *arg0)
{
  void *__retres;
  struct device *ldv_20_device;
  int tmp;
  
#line 3691 
  struct dev_pm_ops *ldv_20_pm_ops = ldv_emg_alias_ath9k_pm_ops_3;
  
#line 3695 
  ldv_free(arg0);
  
#line 3702 
  goto ldv_do_20;
  
#line 3704 
  __retres = (void *)0;
  
#line 3704 
  goto return_label;
  ldv_do_20: 
#line 3707 
  ;
  
#line 3710 
  tmp = ldv_undef_int();
  
#line 3710 
  switch (tmp) {
    int tmp_0;
    case 1: 
#line 3711 
    ;
    
#line 3713 
    if (ldv_20_pm_ops->runtime_idle != (int (*)(struct device *))0) 
#line 3715 
                                                                    (*(ldv_20_pm_ops->runtime_idle))(ldv_20_device); else ;
    
#line 3723 
    goto ldv_do_20;
    case 2: 
#line 3726 
    ;
    
#line 3728 
    if (ldv_20_pm_ops->runtime_suspend != (int (*)(struct device *))0) 
      
#line 3730 
      (*(ldv_20_pm_ops->runtime_suspend))(ldv_20_device); else ;
    
#line 3735 
    if (ldv_20_pm_ops->runtime_resume != (int (*)(struct device *))0) 
      
#line 3737 
      (*(ldv_20_pm_ops->runtime_resume))(ldv_20_device); else ;
    
#line 3745 
    goto ldv_do_20;
    case 3: 
#line 3748 
    ;
    
#line 3750 
    if (ldv_20_pm_ops->prepare != (int (*)(struct device *))0) 
#line 3752 
                                                               (*(ldv_20_pm_ops->prepare))(ldv_20_device); else ;
    
#line 3756 
    tmp_0 = ldv_undef_int();
    
#line 3756 
    switch (tmp_0) {
      int tmp_1;
      int tmp_2;
      int tmp_3;
      case 1: 
#line 3757 
      ;
      
#line 3760 
      ldv_emg_wrapper_ath_pci_suspend_2(ldv_20_device);
      
#line 3763 
      tmp_1 = ldv_undef_int();
      
#line 3763 
      if (tmp_1 != 0) {
        
#line 3765 
        if (ldv_20_pm_ops->suspend_noirq != (int (*)(struct device *))0) 
          
#line 3767 
          (*(ldv_20_pm_ops->suspend_noirq))(ldv_20_device); else ;
        
#line 3772 
        if (ldv_20_pm_ops->resume_noirq != (int (*)(struct device *))0) 
          
#line 3774 
          (*(ldv_20_pm_ops->resume_noirq))(ldv_20_device); else ;
      }
      else {
        
#line 3781 
        if (ldv_20_pm_ops->suspend_late != (int (*)(struct device *))0) 
          
#line 3783 
          (*(ldv_20_pm_ops->suspend_late))(ldv_20_device); else ;
        
#line 3788 
        if (ldv_20_pm_ops->resume_early != (int (*)(struct device *))0) 
          
#line 3790 
          (*(ldv_20_pm_ops->resume_early))(ldv_20_device); else ;
      }
      
#line 3797 
      ldv_emg_wrapper_ath_pci_resume_4(ldv_20_device);
      
#line 3800 
      goto ldv_52540;
      case 2: 
#line 3802 
      ;
      
#line 3805 
      ldv_emg_wrapper_ath_pci_suspend_2(ldv_20_device);
      
#line 3808 
      tmp_2 = ldv_undef_int();
      
#line 3808 
      if (tmp_2 != 0) {
        
#line 3810 
        if (ldv_20_pm_ops->freeze_late != (int (*)(struct device *))0) 
          
#line 3812 
          (*(ldv_20_pm_ops->freeze_late))(ldv_20_device); else ;
        
#line 3817 
        if (ldv_20_pm_ops->thaw_early != (int (*)(struct device *))0) 
          
#line 3819 
          (*(ldv_20_pm_ops->thaw_early))(ldv_20_device); else ;
      }
      else {
        
#line 3826 
        if (ldv_20_pm_ops->freeze_noirq != (int (*)(struct device *))0) 
          
#line 3828 
          (*(ldv_20_pm_ops->freeze_noirq))(ldv_20_device); else ;
        
#line 3833 
        if (ldv_20_pm_ops->thaw_noirq != (int (*)(struct device *))0) 
          
#line 3835 
          (*(ldv_20_pm_ops->thaw_noirq))(ldv_20_device); else ;
      }
      
#line 3842 
      ldv_emg_wrapper_ath_pci_resume_4(ldv_20_device);
      
#line 3845 
      goto ldv_52540;
      case 3: 
#line 3847 
      ;
      
#line 3850 
      ldv_emg_wrapper_ath_pci_suspend_2(ldv_20_device);
      
#line 3853 
      tmp_3 = ldv_undef_int();
      
#line 3853 
      if (tmp_3 != 0) {
        
#line 3855 
        if (ldv_20_pm_ops->poweroff_late != (int (*)(struct device *))0) 
          
#line 3857 
          (*(ldv_20_pm_ops->poweroff_late))(ldv_20_device); else ;
        
#line 3862 
        if (ldv_20_pm_ops->restore_early != (int (*)(struct device *))0) 
          
#line 3864 
          (*(ldv_20_pm_ops->restore_early))(ldv_20_device); else ;
      }
      else {
        
#line 3871 
        if (ldv_20_pm_ops->poweroff_noirq != (int (*)(struct device *))0) 
          
#line 3873 
          (*(ldv_20_pm_ops->poweroff_noirq))(ldv_20_device); else ;
        
#line 3878 
        if (ldv_20_pm_ops->restore_noirq != (int (*)(struct device *))0) 
          
#line 3880 
          (*(ldv_20_pm_ops->restore_noirq))(ldv_20_device); else ;
      }
      
#line 3887 
      ldv_emg_wrapper_ath_pci_resume_4(ldv_20_device);
      
#line 3890 
      goto ldv_52540;
      default: 
#line 3892 
      ;
      
#line 3892 
      __VERIFIER_assume(0);
    }
    ldv_52540: 
#line 3895 
    ;
    
#line 3895 
    if (ldv_20_pm_ops->complete != (void (*)(struct device *))0) 
#line 3897 
                                                                 (*(ldv_20_pm_ops->complete))(ldv_20_device); else ;
    
#line 3905 
    goto ldv_do_20;
    case 4: 
#line 3908 
    ;
    
#line 3914 
    __retres = (void *)0;
    
#line 3914 
    goto return_label;
    default: 
#line 3917 
    ;
    
#line 3917 
    __VERIFIER_assume(0);
  }
  
#line 3920 
  __retres = (void *)0;
  return_label: 
#line 3920 
                return __retres;
}


#line 3925  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_30(void *arg0)
{
  void *__retres;
  struct file *ldv_30_resource_1;
  int ldv_30_ldv_param_2_3;
  long long ldv_30_ldv_param_1_2;
  char *ldv_30_ldv_param_1_4;
  unsigned long ldv_30_size_cnt;
  long long *ldv_30_ldv_param_3_5;
  struct inode *ldv_30_resource_0;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 3934 
  struct file_operations *ldv_30_container = ldv_emg_alias_fops_simulate_radar_2;
  
#line 3935 
  int ldv_30_ret = ldv_undef_int();
  
#line 3938 
  struct ldv_struct_character_driver_scenario_15 *data = (struct ldv_struct_character_driver_scenario_15 *)arg0;
  
#line 3942 
  ldv_30_ret = ldv_undef_int();
  
#line 3945 
  if (data != (struct ldv_struct_character_driver_scenario_15 *)0) {
    
#line 3946 
    ldv_30_container = data->arg0;
    
#line 3947 
    ldv_free((void *)data);
  }
  else ;
  
#line 3952 
  ldv_30_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 3953 
  tmp_1 = ldv_undef_int();
  
#line 3953 
  ldv_30_size_cnt = (unsigned long)tmp_1;
  
#line 3960 
  goto ldv_main_30;
  
#line 3962 
  __retres = (void *)0;
  
#line 3962 
  goto return_label;
  ldv_main_30: 
#line 3965 
  ;
  
#line 3968 
  tmp_3 = ldv_undef_int();
  
#line 3968 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 3971 
    ldv_30_ret = (*ldv_emg_alias_simple_open_5)(ldv_30_resource_0,ldv_30_resource_1);
    
#line 3973 
    ldv_30_ret = ldv_filter_err_code(ldv_30_ret);
    
#line 3976 
    tmp_2 = ldv_undef_int();
    
#line 3976 
    if (tmp_2 != 0) {
      
#line 3978 
      __VERIFIER_assume(ldv_30_ret == 0);
      
#line 3985 
      goto ldv_call_30;
    }
    else {
      
#line 3989 
      __VERIFIER_assume(ldv_30_ret != 0);
      
#line 3996 
      goto ldv_main_30;
    }
  }
  else {
    
#line 4001 
    ldv_free((void *)ldv_30_resource_0);
    
#line 4009 
    __retres = (void *)0;
    
#line 4009 
    goto return_label;
  }
  
#line 4012 
  __retres = (void *)0;
  
#line 4012 
  goto return_label;
  ldv_call_30: 
#line 4015 
  ;
  
#line 4018 
  tmp_4 = ldv_undef_int();
  
#line 4018 
  switch (tmp_4) {
    case 1: 
#line 4019 
    ;
    
#line 4025 
    (*ldv_emg_alias_default_llseek_3)(ldv_30_resource_1,ldv_30_ldv_param_1_2,ldv_30_ldv_param_2_3);
    
#line 4035 
    goto ldv_call_30;
    case 2: 
#line 4038 
    ;
    
#line 4040 
    ldv_30_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 4041 
    ldv_30_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 4050 
    __VERIFIER_assume(ldv_30_size_cnt <= 2147479552UL);
    
#line 4052 
    ldv_emg_wrapper_write_file_simulate_radar_3(ldv_30_resource_1,ldv_30_ldv_param_1_4,ldv_30_size_cnt,ldv_30_ldv_param_3_5);
    
#line 4056 
    ldv_free((void *)ldv_30_ldv_param_3_5);
    
#line 4057 
    ldv_free((void *)ldv_30_ldv_param_1_4);
    
#line 4064 
    goto ldv_call_30;
    case 3: 
#line 4067 
    ;
    
#line 4069 
    if (ldv_30_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 4071 
      (*(ldv_30_container->release))(ldv_30_resource_0,ldv_30_resource_1); else ;
    
#line 4079 
    goto ldv_main_30;
    default: 
#line 4082 
    ;
    
#line 4082 
    __VERIFIER_assume(0);
  }
  
#line 4085 
  __retres = (void *)0;
  return_label: 
#line 4085 
                return __retres;
}


#line 4090  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_ieee80211_free_hw(struct ieee80211_hw *arg0)
{
  struct ieee80211_hw *ldv_12_ieee80211_hw;
  
#line 4096 
  ldv_dispatch_deregister_12_2(ldv_12_ieee80211_hw);
  
#line 4100 
  ldv_free((void *)ldv_12_ieee80211_hw);
  
#line 4104 
  goto return_label;
  return_label: 
#line 4106 
                return;
}


#line 4111  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_register_8_3(struct pci_driver *arg0)
{
  int ret;
  struct ldv_struct_pci_scenario_17 *cf_arg_17;
  int tmp;
  
#line 4114 
  tmp = ldv_undef_int();
  
#line 4114 
  switch (tmp) {
    case 0: 
#line 4115 
    ;
    
#line 4116 
    cf_arg_17 = (struct ldv_struct_pci_scenario_17 *)ldv_xmalloc(16UL);
    
#line 4117 
    cf_arg_17->arg0 = arg0;
    
#line 4118 
    ret = pthread_create(& ldv_thread_17,(pthread_attr_t const *)0,& ldv_pci_scenario_17,(void *)cf_arg_17);
    
#line 4119 
    __VERIFIER_assume(ret == 0);
    
#line 4120 
    goto ldv_52575;
    default: 
#line 4122 
    ;
    
#line 4122 
    __VERIFIER_assume(0);
  }
  ldv_52575: 
#line 4123 
  ;
  
#line 4124 
  return;
}


#line 4128  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_timer_scenario_21(void *arg0)
{
  void *__retres;
  struct timer_list *ldv_21_container;
  
#line 4133 
  struct ldv_struct_timer_scenario_21 *data = (struct ldv_struct_timer_scenario_21 *)arg0;
  
#line 4138 
  if (data != (struct ldv_struct_timer_scenario_21 *)0) {
    
#line 4139 
    ldv_21_container = data->arg0;
    
#line 4140 
    ldv_free((void *)data);
  }
  else ;
  
#line 4145 
  if (ldv_21_container->function != (void (*)(unsigned long ))0) {
    
#line 4147 
    ldv_switch_to_interrupt_context();
    
#line 4149 
    (*(ldv_21_container->function))(ldv_21_container->data);
    
#line 4151 
    ldv_switch_to_process_context();
  }
  else ;
  
#line 4160 
  __retres = (void *)0;
  
#line 4160 
  goto return_label;
  
#line 4162 
  __retres = (void *)0;
  return_label: 
#line 4162 
                return __retres;
}


#line 4167  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_36(void *arg0)
{
  void *__retres;
  struct file *ldv_36_resource_1;
  int ldv_36_ldv_param_2_3;
  long long ldv_36_ldv_param_1_2;
  char *ldv_36_ldv_param_1_4;
  struct inode *ldv_36_resource_0;
  unsigned long ldv_36_size_cnt;
  long long *ldv_36_ldv_param_3_5;
  char *ldv_36_ldv_param_1_6;
  long long *ldv_36_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 4178 
  struct file_operations *ldv_36_container = ldv_emg_alias_fops_dfs_stats_2;
  
#line 4179 
  int ldv_36_ret = ldv_undef_int();
  
#line 4182 
  struct ldv_struct_character_driver_scenario_15 *data = (struct ldv_struct_character_driver_scenario_15 *)arg0;
  
#line 4186 
  ldv_36_ret = ldv_undef_int();
  
#line 4189 
  if (data != (struct ldv_struct_character_driver_scenario_15 *)0) {
    
#line 4190 
    ldv_36_container = data->arg0;
    
#line 4191 
    ldv_free((void *)data);
  }
  else ;
  
#line 4196 
  ldv_36_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 4197 
  tmp_1 = ldv_undef_int();
  
#line 4197 
  ldv_36_size_cnt = (unsigned long)tmp_1;
  
#line 4204 
  goto ldv_main_36;
  
#line 4206 
  __retres = (void *)0;
  
#line 4206 
  goto return_label;
  ldv_main_36: 
#line 4209 
  ;
  
#line 4212 
  tmp_3 = ldv_undef_int();
  
#line 4212 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 4215 
    ldv_36_ret = (*ldv_emg_alias_simple_open_5)(ldv_36_resource_0,ldv_36_resource_1);
    
#line 4217 
    ldv_36_ret = ldv_filter_err_code(ldv_36_ret);
    
#line 4220 
    tmp_2 = ldv_undef_int();
    
#line 4220 
    if (tmp_2 != 0) {
      
#line 4222 
      __VERIFIER_assume(ldv_36_ret == 0);
      
#line 4229 
      goto ldv_call_36;
    }
    else {
      
#line 4233 
      __VERIFIER_assume(ldv_36_ret != 0);
      
#line 4240 
      goto ldv_main_36;
    }
  }
  else {
    
#line 4245 
    ldv_free((void *)ldv_36_resource_0);
    
#line 4253 
    __retres = (void *)0;
    
#line 4253 
    goto return_label;
  }
  
#line 4256 
  __retres = (void *)0;
  
#line 4256 
  goto return_label;
  ldv_call_36: 
#line 4259 
  ;
  
#line 4262 
  tmp_4 = ldv_undef_int();
  
#line 4262 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 4263 
    ;
    
#line 4265 
    ldv_36_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 4266 
    ldv_36_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 4275 
    __VERIFIER_assume(ldv_36_size_cnt <= 2147479552UL);
    
#line 4277 
    ldv_emg_wrapper_write_file_dfs_4(ldv_36_resource_1,ldv_36_ldv_param_1_6,ldv_36_size_cnt,ldv_36_ldv_param_3_7);
    
#line 4281 
    ldv_free((void *)ldv_36_ldv_param_1_6);
    
#line 4282 
    ldv_free((void *)ldv_36_ldv_param_3_7);
    
#line 4289 
    goto ldv_call_36;
    case 2: 
#line 4292 
    ;
    
#line 4294 
    if (ldv_36_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 4296 
      (*(ldv_36_container->release))(ldv_36_resource_0,ldv_36_resource_1); else ;
    
#line 4304 
    goto ldv_main_36;
    case 3: 
#line 4307 
    ;
    
#line 4311 
    tmp_9 = ldv_undef_int();
    
#line 4311 
    if (tmp_9 != 0) 
#line 4314 
                    (*ldv_emg_alias_default_llseek_3)(ldv_36_resource_1,ldv_36_ldv_param_1_2,ldv_36_ldv_param_2_3);
    else {
      
#line 4320 
      ldv_36_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 4321 
      ldv_36_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 4326 
      ldv_emg_wrapper_read_file_dfs_3(ldv_36_resource_1,ldv_36_ldv_param_1_4,ldv_36_size_cnt,ldv_36_ldv_param_3_5);
      
#line 4330 
      ldv_free((void *)ldv_36_ldv_param_3_5);
      
#line 4331 
      ldv_free((void *)ldv_36_ldv_param_1_4);
    }
    
#line 4335 
    goto ldv_52602;
    default: 
#line 4337 
    ;
    
#line 4337 
    __VERIFIER_assume(0);
  }
  ldv_52602: 
#line 4346 
  ;
  
#line 4346 
  goto ldv_call_36;
  
#line 4348 
  __retres = (void *)0;
  return_label: 
#line 4348 
                return __retres;
}


#line 4353  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_pm_register_33_13(void)
{
  int ret;
  struct ldv_struct_platform_instance_33 *cf_arg_20;
  int tmp;
  
#line 4356 
  tmp = ldv_undef_int();
  
#line 4356 
  switch (tmp) {
    case 0: 
#line 4357 
    ;
    
#line 4358 
    cf_arg_20 = (struct ldv_struct_platform_instance_33 *)ldv_xmalloc(16UL);
    
#line 4359 
    ret = pthread_create(& ldv_thread_20,(pthread_attr_t const *)0,& ldv_pm_ops_scenario_20,(void *)cf_arg_20);
    
#line 4360 
    __VERIFIER_assume(ret == 0);
    
#line 4361 
    goto ldv_52610;
    default: 
#line 4363 
    ;
    
#line 4363 
    __VERIFIER_assume(0);
  }
  ldv_52610: 
#line 4364 
  ;
  
#line 4365 
  return;
}


#line 4369  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_38(void *arg0)
{
  void *__retres;
  struct file *ldv_38_resource_1;
  int ldv_38_ldv_param_2_3;
  long long ldv_38_ldv_param_1_2;
  char *ldv_38_ldv_param_1_4;
  struct inode *ldv_38_resource_0;
  unsigned long ldv_38_size_cnt;
  long long *ldv_38_ldv_param_3_5;
  char *ldv_38_ldv_param_1_6;
  long long *ldv_38_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 4380 
  struct file_operations *ldv_38_container = ldv_emg_alias_fops_regdump_2;
  
#line 4381 
  int ldv_38_ret = ldv_undef_int();
  
#line 4384 
  struct ldv_struct_character_driver_scenario_15 *data = (struct ldv_struct_character_driver_scenario_15 *)arg0;
  
#line 4388 
  ldv_38_ret = ldv_undef_int();
  
#line 4391 
  if (data != (struct ldv_struct_character_driver_scenario_15 *)0) {
    
#line 4392 
    ldv_38_container = data->arg0;
    
#line 4393 
    ldv_free((void *)data);
  }
  else ;
  
#line 4398 
  ldv_38_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 4399 
  tmp_1 = ldv_undef_int();
  
#line 4399 
  ldv_38_size_cnt = (unsigned long)tmp_1;
  
#line 4406 
  goto ldv_main_38;
  
#line 4408 
  __retres = (void *)0;
  
#line 4408 
  goto return_label;
  ldv_main_38: 
#line 4411 
  ;
  
#line 4414 
  tmp_3 = ldv_undef_int();
  
#line 4414 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 4417 
    ldv_38_ret = ldv_emg_wrapper_open_file_regdump_5(ldv_38_resource_0,ldv_38_resource_1);
    
#line 4419 
    ldv_38_ret = ldv_filter_err_code(ldv_38_ret);
    
#line 4422 
    tmp_2 = ldv_undef_int();
    
#line 4422 
    if (tmp_2 != 0) {
      
#line 4424 
      __VERIFIER_assume(ldv_38_ret == 0);
      
#line 4431 
      goto ldv_call_38;
    }
    else {
      
#line 4435 
      __VERIFIER_assume(ldv_38_ret != 0);
      
#line 4442 
      goto ldv_main_38;
    }
  }
  else {
    
#line 4447 
    ldv_free((void *)ldv_38_resource_0);
    
#line 4455 
    __retres = (void *)0;
    
#line 4455 
    goto return_label;
  }
  
#line 4458 
  __retres = (void *)0;
  
#line 4458 
  goto return_label;
  ldv_call_38: 
#line 4461 
  ;
  
#line 4464 
  tmp_4 = ldv_undef_int();
  
#line 4464 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 4465 
    ;
    
#line 4467 
    ldv_38_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 4468 
    ldv_38_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 4472 
    if (ldv_38_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 4478 
      __VERIFIER_assume(ldv_38_size_cnt <= 2147479552UL);
      
#line 4480 
      (*(ldv_38_container->write))(ldv_38_resource_1,(char const *)ldv_38_ldv_param_1_6,ldv_38_size_cnt,ldv_38_ldv_param_3_7);
    }
    else ;
    
#line 4485 
    ldv_free((void *)ldv_38_ldv_param_3_7);
    
#line 4486 
    ldv_free((void *)ldv_38_ldv_param_1_6);
    
#line 4493 
    goto ldv_call_38;
    case 2: 
#line 4496 
    ;
    
#line 4499 
    ldv_emg_wrapper_ath9k_debugfs_release_buf_4(ldv_38_resource_0,ldv_38_resource_1);
    
#line 4506 
    goto ldv_main_38;
    case 3: 
#line 4509 
    ;
    
#line 4513 
    tmp_9 = ldv_undef_int();
    
#line 4513 
    if (tmp_9 != 0) 
#line 4516 
                    (*ldv_emg_alias_default_llseek_3)(ldv_38_resource_1,ldv_38_ldv_param_1_2,ldv_38_ldv_param_2_3);
    else {
      
#line 4522 
      ldv_38_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 4523 
      ldv_38_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 4528 
      ldv_emg_wrapper_ath9k_debugfs_read_buf_3(ldv_38_resource_1,ldv_38_ldv_param_1_4,ldv_38_size_cnt,ldv_38_ldv_param_3_5);
      
#line 4532 
      ldv_free((void *)ldv_38_ldv_param_3_5);
      
#line 4533 
      ldv_free((void *)ldv_38_ldv_param_1_4);
    }
    
#line 4537 
    goto ldv_52632;
    default: 
#line 4539 
    ;
    
#line 4539 
    __VERIFIER_assume(0);
  }
  ldv_52632: 
#line 4548 
  ;
  
#line 4548 
  goto ldv_call_38;
  
#line 4550 
  __retres = (void *)0;
  return_label: 
#line 4550 
                return __retres;
}


#line 4555  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
int main(void)
{
  int __retres;
  
#line 4558 
  ldv_initialize();
  
#line 4561 
  ldv_initialization_1((void *)0);
  
#line 4563 
  __retres = 0;
  
#line 4563 
  return __retres;
}


#line 4568  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_32(void *arg0)
{
  void *__retres;
  struct file *ldv_32_resource_1;
  int ldv_32_ldv_param_2_3;
  long long ldv_32_ldv_param_1_2;
  char *ldv_32_ldv_param_1_4;
  struct inode *ldv_32_resource_0;
  unsigned long ldv_32_size_cnt;
  long long *ldv_32_ldv_param_3_5;
  char *ldv_32_ldv_param_1_6;
  long long *ldv_32_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 4579 
  struct file_operations *ldv_32_container = ldv_emg_alias_fops_bt_ant_diversity_2;
  
#line 4580 
  int ldv_32_ret = ldv_undef_int();
  
#line 4583 
  struct ldv_struct_character_driver_scenario_15 *data = (struct ldv_struct_character_driver_scenario_15 *)arg0;
  
#line 4587 
  ldv_32_ret = ldv_undef_int();
  
#line 4590 
  if (data != (struct ldv_struct_character_driver_scenario_15 *)0) {
    
#line 4591 
    ldv_32_container = data->arg0;
    
#line 4592 
    ldv_free((void *)data);
  }
  else ;
  
#line 4597 
  ldv_32_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 4598 
  tmp_1 = ldv_undef_int();
  
#line 4598 
  ldv_32_size_cnt = (unsigned long)tmp_1;
  
#line 4605 
  goto ldv_main_32;
  
#line 4607 
  __retres = (void *)0;
  
#line 4607 
  goto return_label;
  ldv_main_32: 
#line 4610 
  ;
  
#line 4613 
  tmp_3 = ldv_undef_int();
  
#line 4613 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 4616 
    ldv_32_ret = (*ldv_emg_alias_simple_open_5)(ldv_32_resource_0,ldv_32_resource_1);
    
#line 4618 
    ldv_32_ret = ldv_filter_err_code(ldv_32_ret);
    
#line 4621 
    tmp_2 = ldv_undef_int();
    
#line 4621 
    if (tmp_2 != 0) {
      
#line 4623 
      __VERIFIER_assume(ldv_32_ret == 0);
      
#line 4630 
      goto ldv_call_32;
    }
    else {
      
#line 4634 
      __VERIFIER_assume(ldv_32_ret != 0);
      
#line 4641 
      goto ldv_main_32;
    }
  }
  else {
    
#line 4646 
    ldv_free((void *)ldv_32_resource_0);
    
#line 4654 
    __retres = (void *)0;
    
#line 4654 
    goto return_label;
  }
  
#line 4657 
  __retres = (void *)0;
  
#line 4657 
  goto return_label;
  ldv_call_32: 
#line 4660 
  ;
  
#line 4663 
  tmp_4 = ldv_undef_int();
  
#line 4663 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 4664 
    ;
    
#line 4666 
    ldv_32_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 4667 
    ldv_32_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 4676 
    __VERIFIER_assume(ldv_32_size_cnt <= 2147479552UL);
    
#line 4678 
    ldv_emg_wrapper_write_file_bt_ant_diversity_4(ldv_32_resource_1,ldv_32_ldv_param_1_6,ldv_32_size_cnt,ldv_32_ldv_param_3_7);
    
#line 4682 
    ldv_free((void *)ldv_32_ldv_param_1_6);
    
#line 4683 
    ldv_free((void *)ldv_32_ldv_param_3_7);
    
#line 4690 
    goto ldv_call_32;
    case 2: 
#line 4693 
    ;
    
#line 4695 
    if (ldv_32_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 4697 
      (*(ldv_32_container->release))(ldv_32_resource_0,ldv_32_resource_1); else ;
    
#line 4705 
    goto ldv_main_32;
    case 3: 
#line 4708 
    ;
    
#line 4712 
    tmp_9 = ldv_undef_int();
    
#line 4712 
    if (tmp_9 != 0) 
#line 4715 
                    (*ldv_emg_alias_default_llseek_3)(ldv_32_resource_1,ldv_32_ldv_param_1_2,ldv_32_ldv_param_2_3);
    else {
      
#line 4721 
      ldv_32_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 4722 
      ldv_32_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 4727 
      ldv_emg_wrapper_read_file_bt_ant_diversity_3(ldv_32_resource_1,ldv_32_ldv_param_1_4,ldv_32_size_cnt,ldv_32_ldv_param_3_5);
      
#line 4731 
      ldv_free((void *)ldv_32_ldv_param_3_5);
      
#line 4732 
      ldv_free((void *)ldv_32_ldv_param_1_4);
    }
    
#line 4736 
    goto ldv_52657;
    default: 
#line 4738 
    ;
    
#line 4738 
    __VERIFIER_assume(0);
  }
  ldv_52657: 
#line 4747 
  ;
  
#line 4747 
  goto ldv_call_32;
  
#line 4749 
  __retres = (void *)0;
  return_label: 
#line 4749 
                return __retres;
}


#line 4754  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_28(void *arg0)
{
  void *__retres;
  struct file *ldv_28_resource_1;
  int ldv_28_ldv_param_2_3;
  long long ldv_28_ldv_param_1_2;
  char *ldv_28_ldv_param_1_4;
  struct inode *ldv_28_resource_0;
  unsigned long ldv_28_size_cnt;
  long long *ldv_28_ldv_param_3_5;
  char *ldv_28_ldv_param_1_6;
  long long *ldv_28_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 4765 
  struct file_operations *ldv_28_container = ldv_emg_alias_fops_tpc_2;
  
#line 4766 
  int ldv_28_ret = ldv_undef_int();
  
#line 4769 
  struct ldv_struct_character_driver_scenario_15 *data = (struct ldv_struct_character_driver_scenario_15 *)arg0;
  
#line 4773 
  ldv_28_ret = ldv_undef_int();
  
#line 4776 
  if (data != (struct ldv_struct_character_driver_scenario_15 *)0) {
    
#line 4777 
    ldv_28_container = data->arg0;
    
#line 4778 
    ldv_free((void *)data);
  }
  else ;
  
#line 4783 
  ldv_28_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 4784 
  tmp_1 = ldv_undef_int();
  
#line 4784 
  ldv_28_size_cnt = (unsigned long)tmp_1;
  
#line 4791 
  goto ldv_main_28;
  
#line 4793 
  __retres = (void *)0;
  
#line 4793 
  goto return_label;
  ldv_main_28: 
#line 4796 
  ;
  
#line 4799 
  tmp_3 = ldv_undef_int();
  
#line 4799 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 4802 
    ldv_28_ret = (*ldv_emg_alias_simple_open_5)(ldv_28_resource_0,ldv_28_resource_1);
    
#line 4804 
    ldv_28_ret = ldv_filter_err_code(ldv_28_ret);
    
#line 4807 
    tmp_2 = ldv_undef_int();
    
#line 4807 
    if (tmp_2 != 0) {
      
#line 4809 
      __VERIFIER_assume(ldv_28_ret == 0);
      
#line 4816 
      goto ldv_call_28;
    }
    else {
      
#line 4820 
      __VERIFIER_assume(ldv_28_ret != 0);
      
#line 4827 
      goto ldv_main_28;
    }
  }
  else {
    
#line 4832 
    ldv_free((void *)ldv_28_resource_0);
    
#line 4840 
    __retres = (void *)0;
    
#line 4840 
    goto return_label;
  }
  
#line 4843 
  __retres = (void *)0;
  
#line 4843 
  goto return_label;
  ldv_call_28: 
#line 4846 
  ;
  
#line 4849 
  tmp_4 = ldv_undef_int();
  
#line 4849 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 4850 
    ;
    
#line 4852 
    ldv_28_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 4853 
    ldv_28_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 4862 
    __VERIFIER_assume(ldv_28_size_cnt <= 2147479552UL);
    
#line 4864 
    ldv_emg_wrapper_write_file_tpc_4(ldv_28_resource_1,ldv_28_ldv_param_1_6,ldv_28_size_cnt,ldv_28_ldv_param_3_7);
    
#line 4868 
    ldv_free((void *)ldv_28_ldv_param_1_6);
    
#line 4869 
    ldv_free((void *)ldv_28_ldv_param_3_7);
    
#line 4876 
    goto ldv_call_28;
    case 2: 
#line 4879 
    ;
    
#line 4881 
    if (ldv_28_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 4883 
      (*(ldv_28_container->release))(ldv_28_resource_0,ldv_28_resource_1); else ;
    
#line 4891 
    goto ldv_main_28;
    case 3: 
#line 4894 
    ;
    
#line 4898 
    tmp_9 = ldv_undef_int();
    
#line 4898 
    if (tmp_9 != 0) 
#line 4901 
                    (*ldv_emg_alias_default_llseek_3)(ldv_28_resource_1,ldv_28_ldv_param_1_2,ldv_28_ldv_param_2_3);
    else {
      
#line 4907 
      ldv_28_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 4908 
      ldv_28_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 4913 
      ldv_emg_wrapper_read_file_tpc_3(ldv_28_resource_1,ldv_28_ldv_param_1_4,ldv_28_size_cnt,ldv_28_ldv_param_3_5);
      
#line 4917 
      ldv_free((void *)ldv_28_ldv_param_3_5);
      
#line 4918 
      ldv_free((void *)ldv_28_ldv_param_1_4);
    }
    
#line 4922 
    goto ldv_52679;
    default: 
#line 4924 
    ;
    
#line 4924 
    __VERIFIER_assume(0);
  }
  ldv_52679: 
#line 4933 
  ;
  
#line 4933 
  goto ldv_call_28;
  
#line 4935 
  __retres = (void *)0;
  return_label: 
#line 4935 
                return __retres;
}


#line 4940  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_register_13_3(struct file_operations *arg0)
{
  int ret;
  struct ldv_struct_character_driver_scenario_15 *cf_arg_32;
  struct ldv_struct_character_driver_scenario_15 *cf_arg_34;
  struct ldv_struct_character_driver_scenario_15 *cf_arg_36;
  struct ldv_struct_character_driver_scenario_15 *cf_arg_37;
  struct ldv_struct_character_driver_scenario_15 *cf_arg_38;
  struct ldv_struct_character_driver_scenario_15 *cf_arg_15;
  struct ldv_struct_character_driver_scenario_15 *cf_arg_16;
  struct ldv_struct_character_driver_scenario_15 *cf_arg_18;
  struct ldv_struct_character_driver_scenario_15 *cf_arg_22;
  struct ldv_struct_character_driver_scenario_15 *cf_arg_23;
  struct ldv_struct_character_driver_scenario_15 *cf_arg_24;
  struct ldv_struct_character_driver_scenario_15 *cf_arg_25;
  struct ldv_struct_character_driver_scenario_15 *cf_arg_26;
  struct ldv_struct_character_driver_scenario_15 *cf_arg_27;
  struct ldv_struct_character_driver_scenario_15 *cf_arg_28;
  struct ldv_struct_character_driver_scenario_15 *cf_arg_29;
  struct ldv_struct_character_driver_scenario_15 *cf_arg_30;
  struct ldv_struct_character_driver_scenario_15 *cf_arg_31;
  int tmp;
  
#line 4960 
  tmp = ldv_undef_int();
  
#line 4960 
  switch (tmp) {
    case 0: 
#line 4961 
    ;
    
#line 4962 
    cf_arg_32 = (struct ldv_struct_character_driver_scenario_15 *)ldv_xmalloc(16UL);
    
#line 4963 
    cf_arg_32->arg0 = arg0;
    
#line 4964 
    ret = pthread_create(& ldv_thread_32,(pthread_attr_t const *)0,& ldv_character_driver_scenario_32,(void *)cf_arg_32);
    
#line 4965 
    __VERIFIER_assume(ret == 0);
    
#line 4966 
    goto ldv_52704;
    case 1: 
#line 4968 
    ;
    
#line 4969 
    cf_arg_34 = (struct ldv_struct_character_driver_scenario_15 *)ldv_xmalloc(16UL);
    
#line 4970 
    cf_arg_34->arg0 = arg0;
    
#line 4971 
    ret = pthread_create(& ldv_thread_34,(pthread_attr_t const *)0,& ldv_character_driver_scenario_34,(void *)cf_arg_34);
    
#line 4972 
    __VERIFIER_assume(ret == 0);
    
#line 4973 
    goto ldv_52704;
    case 2: 
#line 4975 
    ;
    
#line 4976 
    cf_arg_36 = (struct ldv_struct_character_driver_scenario_15 *)ldv_xmalloc(16UL);
    
#line 4977 
    cf_arg_36->arg0 = arg0;
    
#line 4978 
    ret = pthread_create(& ldv_thread_36,(pthread_attr_t const *)0,& ldv_character_driver_scenario_36,(void *)cf_arg_36);
    
#line 4979 
    __VERIFIER_assume(ret == 0);
    
#line 4980 
    goto ldv_52704;
    case 3: 
#line 4982 
    ;
    
#line 4983 
    cf_arg_37 = (struct ldv_struct_character_driver_scenario_15 *)ldv_xmalloc(16UL);
    
#line 4984 
    cf_arg_37->arg0 = arg0;
    
#line 4985 
    ret = pthread_create(& ldv_thread_37,(pthread_attr_t const *)0,& ldv_character_driver_scenario_37,(void *)cf_arg_37);
    
#line 4986 
    __VERIFIER_assume(ret == 0);
    
#line 4987 
    goto ldv_52704;
    case 4: 
#line 4989 
    ;
    
#line 4990 
    cf_arg_38 = (struct ldv_struct_character_driver_scenario_15 *)ldv_xmalloc(16UL);
    
#line 4991 
    cf_arg_38->arg0 = arg0;
    
#line 4992 
    ret = pthread_create(& ldv_thread_38,(pthread_attr_t const *)0,& ldv_character_driver_scenario_38,(void *)cf_arg_38);
    
#line 4993 
    __VERIFIER_assume(ret == 0);
    
#line 4994 
    goto ldv_52704;
    case 5: 
#line 4996 
    ;
    
#line 4997 
    cf_arg_15 = (struct ldv_struct_character_driver_scenario_15 *)ldv_xmalloc(16UL);
    
#line 4998 
    cf_arg_15->arg0 = arg0;
    
#line 4999 
    ret = pthread_create(& ldv_thread_15,(pthread_attr_t const *)0,& ldv_character_driver_scenario_15,(void *)cf_arg_15);
    
#line 5000 
    __VERIFIER_assume(ret == 0);
    
#line 5001 
    goto ldv_52704;
    case 6: 
#line 5003 
    ;
    
#line 5004 
    cf_arg_16 = (struct ldv_struct_character_driver_scenario_15 *)ldv_xmalloc(16UL);
    
#line 5005 
    cf_arg_16->arg0 = arg0;
    
#line 5006 
    ret = pthread_create(& ldv_thread_16,(pthread_attr_t const *)0,& ldv_character_driver_scenario_16,(void *)cf_arg_16);
    
#line 5007 
    __VERIFIER_assume(ret == 0);
    
#line 5008 
    goto ldv_52704;
    case 7: 
#line 5010 
    ;
    
#line 5011 
    cf_arg_18 = (struct ldv_struct_character_driver_scenario_15 *)ldv_xmalloc(16UL);
    
#line 5012 
    cf_arg_18->arg0 = arg0;
    
#line 5013 
    ret = pthread_create(& ldv_thread_18,(pthread_attr_t const *)0,& ldv_character_driver_scenario_18,(void *)cf_arg_18);
    
#line 5014 
    __VERIFIER_assume(ret == 0);
    
#line 5015 
    goto ldv_52704;
    case 8: 
#line 5017 
    ;
    
#line 5018 
    cf_arg_22 = (struct ldv_struct_character_driver_scenario_15 *)ldv_xmalloc(16UL);
    
#line 5019 
    cf_arg_22->arg0 = arg0;
    
#line 5020 
    ret = pthread_create(& ldv_thread_22,(pthread_attr_t const *)0,& ldv_character_driver_scenario_22,(void *)cf_arg_22);
    
#line 5021 
    __VERIFIER_assume(ret == 0);
    
#line 5022 
    goto ldv_52704;
    case 9: 
#line 5024 
    ;
    
#line 5025 
    cf_arg_23 = (struct ldv_struct_character_driver_scenario_15 *)ldv_xmalloc(16UL);
    
#line 5026 
    cf_arg_23->arg0 = arg0;
    
#line 5027 
    ret = pthread_create(& ldv_thread_23,(pthread_attr_t const *)0,& ldv_character_driver_scenario_23,(void *)cf_arg_23);
    
#line 5028 
    __VERIFIER_assume(ret == 0);
    
#line 5029 
    goto ldv_52704;
    case 10: 
#line 5031 
    ;
    
#line 5032 
    cf_arg_24 = (struct ldv_struct_character_driver_scenario_15 *)ldv_xmalloc(16UL);
    
#line 5033 
    cf_arg_24->arg0 = arg0;
    
#line 5034 
    ret = pthread_create(& ldv_thread_24,(pthread_attr_t const *)0,& ldv_character_driver_scenario_24,(void *)cf_arg_24);
    
#line 5035 
    __VERIFIER_assume(ret == 0);
    
#line 5036 
    goto ldv_52704;
    case 11: 
#line 5038 
    ;
    
#line 5039 
    cf_arg_25 = (struct ldv_struct_character_driver_scenario_15 *)ldv_xmalloc(16UL);
    
#line 5040 
    cf_arg_25->arg0 = arg0;
    
#line 5041 
    ret = pthread_create(& ldv_thread_25,(pthread_attr_t const *)0,& ldv_character_driver_scenario_25,(void *)cf_arg_25);
    
#line 5042 
    __VERIFIER_assume(ret == 0);
    
#line 5043 
    goto ldv_52704;
    case 12: 
#line 5045 
    ;
    
#line 5046 
    cf_arg_26 = (struct ldv_struct_character_driver_scenario_15 *)ldv_xmalloc(16UL);
    
#line 5047 
    cf_arg_26->arg0 = arg0;
    
#line 5048 
    ret = pthread_create(& ldv_thread_26,(pthread_attr_t const *)0,& ldv_character_driver_scenario_26,(void *)cf_arg_26);
    
#line 5049 
    __VERIFIER_assume(ret == 0);
    
#line 5050 
    goto ldv_52704;
    case 13: 
#line 5052 
    ;
    
#line 5053 
    cf_arg_27 = (struct ldv_struct_character_driver_scenario_15 *)ldv_xmalloc(16UL);
    
#line 5054 
    cf_arg_27->arg0 = arg0;
    
#line 5055 
    ret = pthread_create(& ldv_thread_27,(pthread_attr_t const *)0,& ldv_character_driver_scenario_27,(void *)cf_arg_27);
    
#line 5056 
    __VERIFIER_assume(ret == 0);
    
#line 5057 
    goto ldv_52704;
    case 14: 
#line 5059 
    ;
    
#line 5060 
    cf_arg_28 = (struct ldv_struct_character_driver_scenario_15 *)ldv_xmalloc(16UL);
    
#line 5061 
    cf_arg_28->arg0 = arg0;
    
#line 5062 
    ret = pthread_create(& ldv_thread_28,(pthread_attr_t const *)0,& ldv_character_driver_scenario_28,(void *)cf_arg_28);
    
#line 5063 
    __VERIFIER_assume(ret == 0);
    
#line 5064 
    goto ldv_52704;
    case 15: 
#line 5066 
    ;
    
#line 5067 
    cf_arg_29 = (struct ldv_struct_character_driver_scenario_15 *)ldv_xmalloc(16UL);
    
#line 5068 
    cf_arg_29->arg0 = arg0;
    
#line 5069 
    ret = pthread_create(& ldv_thread_29,(pthread_attr_t const *)0,& ldv_character_driver_scenario_29,(void *)cf_arg_29);
    
#line 5070 
    __VERIFIER_assume(ret == 0);
    
#line 5071 
    goto ldv_52704;
    case 16: 
#line 5073 
    ;
    
#line 5074 
    cf_arg_30 = (struct ldv_struct_character_driver_scenario_15 *)ldv_xmalloc(16UL);
    
#line 5075 
    cf_arg_30->arg0 = arg0;
    
#line 5076 
    ret = pthread_create(& ldv_thread_30,(pthread_attr_t const *)0,& ldv_character_driver_scenario_30,(void *)cf_arg_30);
    
#line 5077 
    __VERIFIER_assume(ret == 0);
    
#line 5078 
    goto ldv_52704;
    case 17: 
#line 5080 
    ;
    
#line 5081 
    cf_arg_31 = (struct ldv_struct_character_driver_scenario_15 *)ldv_xmalloc(16UL);
    
#line 5082 
    cf_arg_31->arg0 = arg0;
    
#line 5083 
    ret = pthread_create(& ldv_thread_31,(pthread_attr_t const *)0,& ldv_character_driver_scenario_31,(void *)cf_arg_31);
    
#line 5084 
    __VERIFIER_assume(ret == 0);
    
#line 5085 
    goto ldv_52704;
    default: 
#line 5087 
    ;
    
#line 5087 
    __VERIFIER_assume(0);
  }
  ldv_52704: 
#line 5088 
  ;
  
#line 5089 
  return;
}


#line 5093  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_pci_unregister_driver(struct pci_driver *arg0)
{
  
#line 5096 
  struct pci_driver *ldv_7_pci_driver = ldv_emg_alias_ath_pci_driver_2;
  
#line 5099 
  ldv_7_pci_driver = arg0;
  
#line 5103 
  ldv_dispatch_deregister_7_1(ldv_7_pci_driver);
  
#line 5107 
  goto return_label;
  return_label: 
#line 5109 
                return;
}


#line 5114  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_24(void *arg0)
{
  void *__retres;
  struct file *ldv_24_resource_1;
  int ldv_24_ldv_param_2_3;
  long long ldv_24_ldv_param_1_2;
  char *ldv_24_ldv_param_1_4;
  struct inode *ldv_24_resource_0;
  unsigned long ldv_24_size_cnt;
  long long *ldv_24_ldv_param_3_5;
  char *ldv_24_ldv_param_1_6;
  long long *ldv_24_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 5125 
  struct file_operations *ldv_24_container = ldv_emg_alias_fops_node_aggr_2;
  
#line 5126 
  int ldv_24_ret = ldv_undef_int();
  
#line 5129 
  struct ldv_struct_character_driver_scenario_15 *data = (struct ldv_struct_character_driver_scenario_15 *)arg0;
  
#line 5133 
  ldv_24_ret = ldv_undef_int();
  
#line 5136 
  if (data != (struct ldv_struct_character_driver_scenario_15 *)0) {
    
#line 5137 
    ldv_24_container = data->arg0;
    
#line 5138 
    ldv_free((void *)data);
  }
  else ;
  
#line 5143 
  ldv_24_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 5144 
  tmp_1 = ldv_undef_int();
  
#line 5144 
  ldv_24_size_cnt = (unsigned long)tmp_1;
  
#line 5151 
  goto ldv_main_24;
  
#line 5153 
  __retres = (void *)0;
  
#line 5153 
  goto return_label;
  ldv_main_24: 
#line 5156 
  ;
  
#line 5159 
  tmp_3 = ldv_undef_int();
  
#line 5159 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 5162 
    ldv_24_ret = (*ldv_emg_alias_simple_open_5)(ldv_24_resource_0,ldv_24_resource_1);
    
#line 5164 
    ldv_24_ret = ldv_filter_err_code(ldv_24_ret);
    
#line 5167 
    tmp_2 = ldv_undef_int();
    
#line 5167 
    if (tmp_2 != 0) {
      
#line 5169 
      __VERIFIER_assume(ldv_24_ret == 0);
      
#line 5176 
      goto ldv_call_24;
    }
    else {
      
#line 5180 
      __VERIFIER_assume(ldv_24_ret != 0);
      
#line 5187 
      goto ldv_main_24;
    }
  }
  else {
    
#line 5192 
    ldv_free((void *)ldv_24_resource_0);
    
#line 5200 
    __retres = (void *)0;
    
#line 5200 
    goto return_label;
  }
  
#line 5203 
  __retres = (void *)0;
  
#line 5203 
  goto return_label;
  ldv_call_24: 
#line 5206 
  ;
  
#line 5209 
  tmp_4 = ldv_undef_int();
  
#line 5209 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 5210 
    ;
    
#line 5212 
    ldv_24_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 5213 
    ldv_24_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 5217 
    if (ldv_24_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 5223 
      __VERIFIER_assume(ldv_24_size_cnt <= 2147479552UL);
      
#line 5225 
      (*(ldv_24_container->write))(ldv_24_resource_1,(char const *)ldv_24_ldv_param_1_6,ldv_24_size_cnt,ldv_24_ldv_param_3_7);
    }
    else ;
    
#line 5230 
    ldv_free((void *)ldv_24_ldv_param_1_6);
    
#line 5231 
    ldv_free((void *)ldv_24_ldv_param_3_7);
    
#line 5238 
    goto ldv_call_24;
    case 2: 
#line 5241 
    ;
    
#line 5243 
    if (ldv_24_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 5245 
      (*(ldv_24_container->release))(ldv_24_resource_0,ldv_24_resource_1); else ;
    
#line 5253 
    goto ldv_main_24;
    case 3: 
#line 5256 
    ;
    
#line 5260 
    tmp_9 = ldv_undef_int();
    
#line 5260 
    if (tmp_9 != 0) 
#line 5263 
                    (*ldv_emg_alias_default_llseek_3)(ldv_24_resource_1,ldv_24_ldv_param_1_2,ldv_24_ldv_param_2_3);
    else {
      
#line 5269 
      ldv_24_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 5270 
      ldv_24_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 5275 
      ldv_emg_wrapper_read_file_node_aggr_3(ldv_24_resource_1,ldv_24_ldv_param_1_4,ldv_24_size_cnt,ldv_24_ldv_param_3_5);
      
#line 5279 
      ldv_free((void *)ldv_24_ldv_param_3_5);
      
#line 5280 
      ldv_free((void *)ldv_24_ldv_param_1_4);
    }
    
#line 5284 
    goto ldv_52747;
    default: 
#line 5286 
    ;
    
#line 5286 
    __VERIFIER_assume(0);
  }
  ldv_52747: 
#line 5295 
  ;
  
#line 5295 
  goto ldv_call_24;
  
#line 5297 
  __retres = (void *)0;
  return_label: 
#line 5297 
                return __retres;
}


#line 5302  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_27(void *arg0)
{
  void *__retres;
  struct file *ldv_27_resource_1;
  int ldv_27_ldv_param_2_3;
  long long ldv_27_ldv_param_1_2;
  char *ldv_27_ldv_param_1_4;
  struct inode *ldv_27_resource_0;
  unsigned long ldv_27_size_cnt;
  long long *ldv_27_ldv_param_3_5;
  char *ldv_27_ldv_param_1_6;
  long long *ldv_27_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 5313 
  struct file_operations *ldv_27_container = ldv_emg_alias_fops_dump_nfcal_2;
  
#line 5314 
  int ldv_27_ret = ldv_undef_int();
  
#line 5317 
  struct ldv_struct_character_driver_scenario_15 *data = (struct ldv_struct_character_driver_scenario_15 *)arg0;
  
#line 5321 
  ldv_27_ret = ldv_undef_int();
  
#line 5324 
  if (data != (struct ldv_struct_character_driver_scenario_15 *)0) {
    
#line 5325 
    ldv_27_container = data->arg0;
    
#line 5326 
    ldv_free((void *)data);
  }
  else ;
  
#line 5331 
  ldv_27_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 5332 
  tmp_1 = ldv_undef_int();
  
#line 5332 
  ldv_27_size_cnt = (unsigned long)tmp_1;
  
#line 5339 
  goto ldv_main_27;
  
#line 5341 
  __retres = (void *)0;
  
#line 5341 
  goto return_label;
  ldv_main_27: 
#line 5344 
  ;
  
#line 5347 
  tmp_3 = ldv_undef_int();
  
#line 5347 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 5350 
    ldv_27_ret = ldv_emg_wrapper_open_file_dump_nfcal_6(ldv_27_resource_0,ldv_27_resource_1);
    
#line 5352 
    ldv_27_ret = ldv_filter_err_code(ldv_27_ret);
    
#line 5355 
    tmp_2 = ldv_undef_int();
    
#line 5355 
    if (tmp_2 != 0) {
      
#line 5357 
      __VERIFIER_assume(ldv_27_ret == 0);
      
#line 5364 
      goto ldv_call_27;
    }
    else {
      
#line 5368 
      __VERIFIER_assume(ldv_27_ret != 0);
      
#line 5375 
      goto ldv_main_27;
    }
  }
  else {
    
#line 5380 
    ldv_free((void *)ldv_27_resource_0);
    
#line 5388 
    __retres = (void *)0;
    
#line 5388 
    goto return_label;
  }
  
#line 5391 
  __retres = (void *)0;
  
#line 5391 
  goto return_label;
  ldv_call_27: 
#line 5394 
  ;
  
#line 5397 
  tmp_4 = ldv_undef_int();
  
#line 5397 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 5398 
    ;
    
#line 5400 
    ldv_27_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 5401 
    ldv_27_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 5405 
    if (ldv_27_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 5411 
      __VERIFIER_assume(ldv_27_size_cnt <= 2147479552UL);
      
#line 5413 
      (*(ldv_27_container->write))(ldv_27_resource_1,(char const *)ldv_27_ldv_param_1_6,ldv_27_size_cnt,ldv_27_ldv_param_3_7);
    }
    else ;
    
#line 5418 
    ldv_free((void *)ldv_27_ldv_param_1_6);
    
#line 5419 
    ldv_free((void *)ldv_27_ldv_param_3_7);
    
#line 5426 
    goto ldv_call_27;
    case 2: 
#line 5429 
    ;
    
#line 5432 
    (*ldv_emg_alias_single_release_5)(ldv_27_resource_0,ldv_27_resource_1);
    
#line 5439 
    goto ldv_main_27;
    case 3: 
#line 5442 
    ;
    
#line 5446 
    tmp_9 = ldv_undef_int();
    
#line 5446 
    if (tmp_9 != 0) 
#line 5449 
                    (*ldv_emg_alias_seq_lseek_3)(ldv_27_resource_1,ldv_27_ldv_param_1_2,ldv_27_ldv_param_2_3);
    else {
      
#line 5455 
      ldv_27_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 5456 
      ldv_27_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 5461 
      (*ldv_emg_alias_seq_read_4)(ldv_27_resource_1,ldv_27_ldv_param_1_4,ldv_27_size_cnt,ldv_27_ldv_param_3_5);
      
#line 5465 
      ldv_free((void *)ldv_27_ldv_param_3_5);
      
#line 5466 
      ldv_free((void *)ldv_27_ldv_param_1_4);
    }
    
#line 5470 
    goto ldv_52769;
    default: 
#line 5472 
    ;
    
#line 5472 
    __VERIFIER_assume(0);
  }
  ldv_52769: 
#line 5481 
  ;
  
#line 5481 
  goto ldv_call_27;
  
#line 5483 
  __retres = (void *)0;
  return_label: 
#line 5483 
                return __retres;
}


#line 5488  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_free_irq(unsigned int arg0, void *arg1)
{
  int ldv_5_line;
  
#line 5494 
  ldv_5_line = (int)arg0;
  
#line 5498 
  ldv_dispatch_irq_deregister_5_1(ldv_5_line);
  
#line 5502 
  goto return_label;
  return_label: 
#line 5504 
                return;
}


#line 5509  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_31(void *arg0)
{
  void *__retres;
  struct file *ldv_31_resource_1;
  int ldv_31_ldv_param_2_3;
  long long ldv_31_ldv_param_1_2;
  char *ldv_31_ldv_param_1_4;
  struct inode *ldv_31_resource_0;
  unsigned long ldv_31_size_cnt;
  long long *ldv_31_ldv_param_3_5;
  char *ldv_31_ldv_param_1_6;
  long long *ldv_31_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 5520 
  struct file_operations *ldv_31_container = ldv_emg_alias_fops_regidx_2;
  
#line 5521 
  int ldv_31_ret = ldv_undef_int();
  
#line 5524 
  struct ldv_struct_character_driver_scenario_15 *data = (struct ldv_struct_character_driver_scenario_15 *)arg0;
  
#line 5528 
  ldv_31_ret = ldv_undef_int();
  
#line 5531 
  if (data != (struct ldv_struct_character_driver_scenario_15 *)0) {
    
#line 5532 
    ldv_31_container = data->arg0;
    
#line 5533 
    ldv_free((void *)data);
  }
  else ;
  
#line 5538 
  ldv_31_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 5539 
  tmp_1 = ldv_undef_int();
  
#line 5539 
  ldv_31_size_cnt = (unsigned long)tmp_1;
  
#line 5546 
  goto ldv_main_31;
  
#line 5548 
  __retres = (void *)0;
  
#line 5548 
  goto return_label;
  ldv_main_31: 
#line 5551 
  ;
  
#line 5554 
  tmp_3 = ldv_undef_int();
  
#line 5554 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 5557 
    ldv_31_ret = (*ldv_emg_alias_simple_open_5)(ldv_31_resource_0,ldv_31_resource_1);
    
#line 5559 
    ldv_31_ret = ldv_filter_err_code(ldv_31_ret);
    
#line 5562 
    tmp_2 = ldv_undef_int();
    
#line 5562 
    if (tmp_2 != 0) {
      
#line 5564 
      __VERIFIER_assume(ldv_31_ret == 0);
      
#line 5571 
      goto ldv_call_31;
    }
    else {
      
#line 5575 
      __VERIFIER_assume(ldv_31_ret != 0);
      
#line 5582 
      goto ldv_main_31;
    }
  }
  else {
    
#line 5587 
    ldv_free((void *)ldv_31_resource_0);
    
#line 5595 
    __retres = (void *)0;
    
#line 5595 
    goto return_label;
  }
  
#line 5598 
  __retres = (void *)0;
  
#line 5598 
  goto return_label;
  ldv_call_31: 
#line 5601 
  ;
  
#line 5604 
  tmp_4 = ldv_undef_int();
  
#line 5604 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 5605 
    ;
    
#line 5607 
    ldv_31_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 5608 
    ldv_31_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 5617 
    __VERIFIER_assume(ldv_31_size_cnt <= 2147479552UL);
    
#line 5619 
    ldv_emg_wrapper_write_file_regidx_4(ldv_31_resource_1,ldv_31_ldv_param_1_6,ldv_31_size_cnt,ldv_31_ldv_param_3_7);
    
#line 5623 
    ldv_free((void *)ldv_31_ldv_param_1_6);
    
#line 5624 
    ldv_free((void *)ldv_31_ldv_param_3_7);
    
#line 5631 
    goto ldv_call_31;
    case 2: 
#line 5634 
    ;
    
#line 5636 
    if (ldv_31_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 5638 
      (*(ldv_31_container->release))(ldv_31_resource_0,ldv_31_resource_1); else ;
    
#line 5646 
    goto ldv_main_31;
    case 3: 
#line 5649 
    ;
    
#line 5653 
    tmp_9 = ldv_undef_int();
    
#line 5653 
    if (tmp_9 != 0) 
#line 5656 
                    (*ldv_emg_alias_default_llseek_3)(ldv_31_resource_1,ldv_31_ldv_param_1_2,ldv_31_ldv_param_2_3);
    else {
      
#line 5662 
      ldv_31_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 5663 
      ldv_31_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 5668 
      ldv_emg_wrapper_read_file_regidx_3(ldv_31_resource_1,ldv_31_ldv_param_1_4,ldv_31_size_cnt,ldv_31_ldv_param_3_5);
      
#line 5672 
      ldv_free((void *)ldv_31_ldv_param_3_5);
      
#line 5673 
      ldv_free((void *)ldv_31_ldv_param_1_4);
    }
    
#line 5677 
    goto ldv_52796;
    default: 
#line 5679 
    ;
    
#line 5679 
    __VERIFIER_assume(0);
  }
  ldv_52796: 
#line 5688 
  ;
  
#line 5688 
  goto ldv_call_31;
  
#line 5690 
  __retres = (void *)0;
  return_label: 
#line 5690 
                return __retres;
}


#line 5695  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_mod_timer(struct timer_list *arg0, unsigned long arg1)
{
  int __retres;
  struct timer_list *ldv_2_timer_list;
  int tmp_0;
  
#line 5702 
  tmp_0 = ldv_undef_int();
  
#line 5702 
  if (tmp_0 != 0) {
    
#line 5704 
    ldv_2_timer_list = arg0;
    
#line 5708 
    ldv_dispatch_instance_register_2_3(ldv_2_timer_list);
    
#line 5712 
    __retres = 0;
    
#line 5712 
    goto return_label;
  }
  else {
    int tmp;
    
#line 5719 
    tmp = ldv_undef_int_negative();
    
#line 5719 
    __retres = tmp;
    
#line 5719 
    goto return_label;
  }
  return_label: 
#line 5702 
                return __retres;
}


#line 5729  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ath/ath9k/ath9k.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_request_irq(unsigned int arg0, enum irqreturn (*arg1)(int , void *), unsigned long arg2, char *arg3, void *arg4)
{
  int __retres;
  int ldv_14_line;
  void *ldv_14_data;
  enum irqreturn (*ldv_14_thread)(int , void *);
  int tmp_0;
  
#line 5734 
  enum irqreturn (*ldv_14_callback)(int , void *) = & ath_isr;
  
#line 5739 
  tmp_0 = ldv_undef_int();
  
#line 5739 
  if (tmp_0 != 0) {
    
#line 5741 
    ldv_14_line = (int)arg0;
    
#line 5742 
    ldv_14_callback = arg1;
    
#line 5743 
    ldv_14_thread = (enum irqreturn (*)(int , void *))0;
    
#line 5744 
    ldv_14_data = arg4;
    
#line 5748 
    ldv_dispatch_irq_register_14_3(ldv_14_line,ldv_14_callback,ldv_14_thread,ldv_14_data);
    
#line 5752 
    __retres = 0;
    
#line 5752 
    goto return_label;
  }
  else {
    int tmp;
    
#line 5759 
    tmp = ldv_undef_int_negative();
    
#line 5759 
    __retres = tmp;
    
#line 5759 
    goto return_label;
  }
  return_label: 
#line 5739 
                return __retres;
}


