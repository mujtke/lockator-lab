/* Generated by Frama-C */

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef int __s32;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef signed char s8;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned char u8;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned short u16;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef int s32;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned int u32;

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef long long s64;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned long long u64;

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;

#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;

#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u16 __le16;

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u16 __be16;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __le32;

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __be32;

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __wsum;

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u32 __kernel_dev_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_dev_t dev_t;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned short umode_t;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_pid_t pid_t;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_clockid_t clockid_t;

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef _Bool bool;

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_uid32_t uid_t;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_gid32_t gid_t;

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_loff_t loff_t;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_size_t size_t;

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_time_t time_t;

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __s32 int32_t;

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u8 uint8_t;

#line 108  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u32 uint32_t;

#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u64 uint64_t;

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned long sector_t;

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned long blkcnt_t;

#line 152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef u64 dma_addr_t;

#line 157  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int gfp_t;

#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int fmode_t;

#line 159  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int oom_flags_t;

#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef u64 phys_addr_t;

#line 167  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef phys_addr_t resource_size_t;

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;

#line 183  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};

#line 188 
struct hlist_node;

#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};

#line 192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};

#line 203  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head *) ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct __anonstruct_9 {
   unsigned int a ;
   unsigned int b ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct __anonstruct_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) base1 : 8 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) type : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) s : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) dpl : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) p : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) limit : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) avl : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) l : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) g : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) base2 : 8 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
union __anonunion_8 {
   struct __anonstruct_9 __anonCompField___anonunion_8_4 ;
   struct __anonstruct_10 __anonCompField___anonunion_8_5 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion_8 __anonCompField_desc_struct_6 ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;

#line 361 
struct page;

#line 361  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;

#line 372 
struct file;

#line 385 
struct seq_file;

#line 423 
struct thread_struct;

#line 425 
struct mm_struct;

#line 426 
struct task_struct;

#line 427 
struct cpumask;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;

#line 234  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
struct _ddebug {
   char const *modname ;
   char const *function ;
   char const *filename ;
   char const *format ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))) lineno : 18 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) flags : 8 ;
};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_debug.h"
struct device;

#line 54 
struct net_device;

#line 420  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
struct file_operations;

#line 432 
struct completion;

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct timespec;

#line 103 
struct compat_timespec;

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_futex_16 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_nanosleep_17 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_poll_18 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
union __anonunion_15 {
   struct __anonstruct_futex_16 futex ;
   struct __anonstruct_nanosleep_17 nanosleep ;
   struct __anonstruct_poll_18 poll ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct restart_block {
   long (*fn)(struct restart_block *) ;
   union __anonunion_15 __anonCompField_restart_block_7 ;
};

#line 127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/vm86.h"
union __anonunion_19 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_19 __anonCompField_math_emu_info_8 ;
};

#line 328  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[128U] ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
typedef struct cpumask cpumask_t;

#line 652  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;

#line 260  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct __anonstruct_29 {
   u64 rip ;
   u64 rdp ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct __anonstruct_30 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union __anonunion_28 {
   struct __anonstruct_29 __anonCompField___anonunion_28_12 ;
   struct __anonstruct_30 __anonCompField___anonunion_28_13 ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union __anonunion_31 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_28 __anonCompField_fxregs_state_14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_31 __anonCompField_fxregs_state_15 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};

#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};

#line 179  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
   u8 __padding[4096U] ;
};

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
   union fpregs_state state ;
};

#line 170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
struct seq_operations;

#line 369 
struct perf_event;

#line 370  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   struct fpu fpu ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bottom_half.h"
struct lockdep_map;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};

#line 28  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};

#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const *name ;
   int cpu ;
   unsigned long ip ;
};

#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(13))) class_idx : 13 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) irq_context : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) trylock : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) read : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) check : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hardirqs_off : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))) references : 12 ;
   unsigned int pin_count ;
};

#line 546  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
struct __anonstruct_35 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
union __anonunion_34 {
   struct raw_spinlock rlock ;
   struct __anonstruct_35 __anonCompField___anonunion_34_17 ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_34 __anonCompField_spinlock_18 ;
};

#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_36 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_36 rwlock_t;

#line 41  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
struct mutex;

#line 30  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};

#line 193  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
typedef struct seqcount seqcount_t;

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;

#line 1170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debugobjects.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};

#line 437  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ktime.h"
typedef union ktime ktime_t;

#line 296  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
struct notifier_block;

#line 1120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
union __anonunion_46 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};

#line 1120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion_46 __anonCompField_idr_layer_19 ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};

#line 153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};

#line 185  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};

#line 97 
struct dentry;

#line 98 
struct iattr;

#line 99 
struct vm_area_struct;

#line 100 
struct super_block;

#line 101 
struct file_system_type;

#line 102 
struct kernfs_open_node;

#line 103 
struct kernfs_iattrs;

#line 126 
struct kernfs_root;

#line 126  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rbtree.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_node;

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};

#line 89 
struct kernfs_ops;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops const *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
union __anonunion_51 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const *name ;
   struct rb_node rb ;
   void const *ns ;
   unsigned int hash ;
   union __anonunion_51 __anonCompField_kernfs_node_20 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};

#line 138  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root *, int *, char *) ;
   int (*show_options)(struct seq_file *, struct kernfs_root *) ;
   int (*mkdir)(struct kernfs_node *, char const *, umode_t ) ;
   int (*rmdir)(struct kernfs_node *) ;
   int (*rename)(struct kernfs_node *, struct kernfs_node *, char const *) ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};

#line 171 
struct vm_operations_struct;

#line 171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct const *vm_ops ;
};

#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file *, void *) ;
   void *(*seq_start)(struct seq_file *, loff_t *) ;
   void *(*seq_next)(struct seq_file *, void *, loff_t *) ;
   void (*seq_stop)(struct seq_file *, void *) ;
   ssize_t (*read)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   int (*mmap)(struct kernfs_open_file *, struct vm_area_struct *) ;
   struct lock_class_key lockdep_key ;
};

#line 281 
struct inode;

#line 477 
struct sock;

#line 478 
struct kobject;

#line 479 
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
};

#line 485  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const *(*netlink_ns)(struct sock *) ;
   void const *(*initial_ns)(void) ;
   void (*drop_ns)(void *) ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/highuid.h"
struct user_namespace;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct __anonstruct_kuid_t_52 {
   uid_t val ;
};

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_52 kuid_t;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct __anonstruct_kgid_t_53 {
   gid_t val ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_53 kgid_t;

#line 139  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/stat.h"
struct bin_attribute;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/stat.h"
struct attribute {
   char const *name ;
   umode_t mode ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_lockdep : 1 ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct attribute_group {
   char const *name ;
   umode_t (*is_visible)(struct kobject *, struct attribute *, int ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};

#line 82  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t , size_t ) ;
   ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t , size_t ) ;
   int (*mmap)(struct file *, struct kobject *, struct bin_attribute *, struct vm_area_struct *) ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject *, struct attribute *, char *) ;
   ssize_t (*store)(struct kobject *, struct attribute *, char const *, size_t ) ;
};

#line 509  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kref.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};

#line 238  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
struct hrtimer;

#line 239 
enum hrtimer_restart;

#line 837  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/sysctl.h"
struct ctl_table;

#line 838 
struct nsproxy;

#line 839 
struct ctl_table_root;

#line 840 
struct ctl_table_header;

#line 841 
struct ctl_dir;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table *, int , void *, size_t *, loff_t *);

#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table {
   char const *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};

#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct __anonstruct_55 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
union __anonunion_54 {
   struct __anonstruct_55 __anonCompField___anonunion_54_21 ;
   struct callback_head rcu ;
};

#line 122 
struct ctl_table_set;

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion_54 __anonCompField_ctl_table_header_22 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};

#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};

#line 149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set *) ;
   struct ctl_dir dir ;
};

#line 154  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root *, struct nsproxy *) ;
   int (*permissions)(struct ctl_table_header *, struct ctl_table *) ;
};

#line 259  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
struct workqueue_struct;

#line 260 
struct work_struct;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct *) ;
   struct lockdep_map lockdep_map ;
};

#line 107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset;

#line 52 
struct kobj_type;

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobject {
   char const *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_initialized : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_in_sysfs : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_add_uevent_sent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_remove_uevent_sent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) uevent_suppress : 1 ;
};

#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject *) ;
   struct sysfs_ops const *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations const *(*child_ns_type)(struct kobject *) ;
   void const *(*namespace)(struct kobject *) ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const filter)(struct kset *, struct kobject *) ;
   char const *(* const name)(struct kset *, struct kobject *) ;
   int (* const uevent)(struct kset *, struct kobject *, struct kobj_uevent_env *) ;
};

#line 148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops const *uevent_ops ;
};

#line 223 
struct klist_node;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nodemask.h"
struct __anonstruct_nodemask_t_56 {
   unsigned long bits[16U] ;
};

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_56 nodemask_t;

#line 520 
struct path;

#line 521  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nodemask.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations const *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file *, loff_t *) ;
   void (*stop)(struct seq_file *, void *) ;
   void *(*next)(struct seq_file *, void *, loff_t *) ;
   int (*show)(struct seq_file *, void *) ;
};

#line 222 
struct pinctrl;

#line 223 
struct pinctrl_state;

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct pm_message {
   int event ;
};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
typedef struct pm_message pm_message_t;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device *) ;
   void (*complete)(struct device *) ;
   int (*suspend)(struct device *) ;
   int (*resume)(struct device *) ;
   int (*freeze)(struct device *) ;
   int (*thaw)(struct device *) ;
   int (*poweroff)(struct device *) ;
   int (*restore)(struct device *) ;
   int (*suspend_late)(struct device *) ;
   int (*resume_early)(struct device *) ;
   int (*freeze_late)(struct device *) ;
   int (*thaw_early)(struct device *) ;
   int (*poweroff_late)(struct device *) ;
   int (*restore_early)(struct device *) ;
   int (*suspend_noirq)(struct device *) ;
   int (*resume_noirq)(struct device *) ;
   int (*freeze_noirq)(struct device *) ;
   int (*thaw_noirq)(struct device *) ;
   int (*poweroff_noirq)(struct device *) ;
   int (*restore_noirq)(struct device *) ;
   int (*runtime_suspend)(struct device *) ;
   int (*runtime_resume)(struct device *) ;
   int (*runtime_idle)(struct device *) ;
};

#line 320 
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
};

#line 327 
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
};

#line 335 
struct wakeup_source;

#line 336 
struct wake_irq;

#line 338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};

#line 553 
struct dev_pm_qos;

#line 553  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) can_wakeup : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) async_suspend : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_prepared : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_noirq_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_late_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_children : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) early_init : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) direct_complete : 1 ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wakeup_path : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) syscore : 1 ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) disable_depth : 3 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) idle_notification : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) request_pending : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) deferred_resume : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) run_wake : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) runtime_auto : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_callbacks : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) irq_safe : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) use_autosuspend : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) timer_autosuspends : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device *, s32 ) ;
   struct dev_pm_qos *qos ;
};

#line 615  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device *, bool ) ;
   int (*activate)(struct device *) ;
   void (*sync)(struct device *) ;
   void (*dismiss)(struct device *) ;
};

#line 796  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
struct rw_semaphore;

#line 797  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block *, unsigned long , void *) ;
   struct notifier_block *next ;
   int priority ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
struct ldt_struct;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_121 {
   struct ldt_struct *ldt ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_121 mm_context_t;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/xen/features.h"
struct bio_vec;

#line 1281  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
struct llist_node;

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};

#line 428  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/gfp.h"
struct dma_map_ops;

#line 428  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/gfp.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/device.h"
struct pdev_archdata {
   
};

#line 15 
struct device_driver;

#line 16 
struct driver_private;

#line 17 
struct class;

#line 18 
struct subsys_private;

#line 19 
struct bus_type;

#line 20 
struct device_node;

#line 21 
struct fwnode_handle;

#line 22 
struct iommu_ops;

#line 23 
struct iommu_group;

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_attribute;

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct bus_type {
   char const *name ;
   char const *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group const **bus_groups ;
   struct attribute_group const **dev_groups ;
   struct attribute_group const **drv_groups ;
   int (*match)(struct device *, struct device_driver *) ;
   int (*uevent)(struct device *, struct kobj_uevent_env *) ;
   int (*probe)(struct device *) ;
   int (*remove)(struct device *) ;
   void (*shutdown)(struct device *) ;
   int (*online)(struct device *) ;
   int (*offline)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct dev_pm_ops const *pm ;
   struct iommu_ops const *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};

#line 139 
struct device_type;

#line 197 
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
};

#line 203 
struct of_device_id;

#line 203 
struct acpi_device_id;

#line 203  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_driver {
   char const *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id const *of_match_table ;
   struct acpi_device_id const *acpi_match_table ;
   int (*probe)(struct device *) ;
   int (*remove)(struct device *) ;
   void (*shutdown)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct attribute_group const **groups ;
   struct dev_pm_ops const *pm ;
   struct driver_private *p ;
};

#line 353 
struct class_attribute;

#line 353  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct class {
   char const *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group const **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *, struct kobj_uevent_env *) ;
   char *(*devnode)(struct device *, umode_t *) ;
   void (*class_release)(struct class *) ;
   void (*dev_release)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct kobj_ns_type_operations const *ns_type ;
   void const *(*namespace)(struct device *) ;
   struct dev_pm_ops const *pm ;
   struct subsys_private *p ;
};

#line 446  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *, struct class_attribute *, char *) ;
   ssize_t (*store)(struct class *, struct class_attribute *, char const *, size_t ) ;
};

#line 514  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_type {
   char const *name ;
   struct attribute_group const **groups ;
   int (*uevent)(struct device *, struct kobj_uevent_env *) ;
   char *(*devnode)(struct device *, umode_t *, kuid_t *, kgid_t *) ;
   void (*release)(struct device *) ;
   struct dev_pm_ops const *pm ;
};

#line 542  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *, struct device_attribute *, char *) ;
   ssize_t (*store)(struct device *, struct device_attribute *, char const *, size_t ) ;
};

#line 675  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};

#line 684 
struct dma_coherent_mem;

#line 684 
struct cma;

#line 684  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const *init_name ;
   struct device_type const *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group const **groups ;
   void (*release)(struct device *) ;
   struct iommu_group *iommu_group ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) offline_disabled : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) offline : 1 ;
};

#line 830  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct wakeup_source {
   char const *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) active : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) autosleep_enabled : 1 ;
};

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;

#line 186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
   __u32 cls ;
   __u32 cls_msk ;
};

#line 221  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const *data ;
};

#line 476  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct platform_device_id {
   char name[20U] ;
   kernel_ulong_t driver_data ;
};

#line 652 
struct mfd_cell;

#line 653  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct platform_device {
   char const *name ;
   int id ;
   bool id_auto ;
   struct device dev ;
   u32 num_resources ;
   struct resource *resource ;
   struct platform_device_id const *id_entry ;
   char *driver_override ;
   struct mfd_cell *mfd_cell ;
   struct pdev_archdata archdata ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};

#line 66 
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct __anonstruct_156 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct __anonstruct_157 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
union __anonunion_155 {
   struct __anonstruct_156 __anonCompField___anonunion_155_35 ;
   struct __anonstruct_157 __anonCompField___anonunion_155_36 ;
};

#line 73 
struct uprobe;

#line 73 
struct return_instance;

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion_155 __anonCompField_uprobe_task_37 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};

#line 94  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uprobes.h"
struct xol_area;

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};

#line 133 
struct address_space;

#line 134 
struct mem_cgroup;

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
typedef void compound_page_dtor(struct page *);

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_158 {
   struct address_space *mapping ;
   void *s_mem ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_160 {
   unsigned long index ;
   void *freelist ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_164 {
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) inuse : 16 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(15))) objects : 15 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) frozen : 1 ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_163 {
   atomic_t _mapcount ;
   struct __anonstruct_164 __anonCompField___anonunion_163_40 ;
   int units ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_162 {
   union __anonunion_163 __anonCompField___anonstruct_162_41 ;
   atomic_t _count ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_161 {
   unsigned long counters ;
   struct __anonstruct_162 __anonCompField___anonunion_161_42 ;
   unsigned int active ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_159 {
   union __anonunion_160 __anonCompField___anonstruct_159_39 ;
   union __anonunion_161 __anonCompField___anonstruct_159_43 ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_166 {
   struct page *next ;
   int pages ;
   int pobjects ;
};

#line 32 
struct slab;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_167 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_165 {
   struct list_head lru ;
   struct __anonstruct_166 __anonCompField___anonunion_165_45 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct_167 __anonCompField___anonunion_165_46 ;
   pgtable_t pmd_huge_pte ;
};

#line 32 
struct kmem_cache;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_168 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion_158 __anonCompField_page_38 ;
   struct __anonstruct_159 __anonCompField_page_44 ;
   union __anonunion_165 __anonCompField_page_47 ;
   union __anonunion_168 __anonCompField_page_48 ;
   struct mem_cgroup *mem_cgroup ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_shared_169 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};

#line 257 
struct anon_vma;

#line 257 
struct mempolicy;

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_169 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct const *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};

#line 331  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};

#line 344  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};

#line 352  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};

#line 357 
struct kioctx_table;

#line 358 
struct linux_binfmt;

#line 358 
struct mmu_notifier_mm;

#line 358  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};

#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kmemcheck.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uio.h"
union __anonunion_171 {
   struct iovec const *iov ;
   struct kvec const *kvec ;
   struct bio_vec const *bvec ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion_171 __anonCompField_iov_iter_49 ;
   unsigned long nr_segs ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;

#line 18 
struct pid;

#line 19 
struct cred;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};

#line 38 
struct kiocb;

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iov_iter msg_iter ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
   struct kiocb *msg_iocb ;
};

#line 217  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/fcntl.h"
enum ldv_15876 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/net.h"
typedef enum ldv_15876 socket_state;

#line 55 
struct pipe_inode_info;

#line 56 
struct net;

#line 73 
struct fasync_struct;

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/net.h"
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   struct callback_head rcu ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct proto_ops;

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct socket_wq *wq ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops const *ops ;
};

#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket *) ;
   int (*bind)(struct socket *, struct sockaddr *, int ) ;
   int (*connect)(struct socket *, struct sockaddr *, int , int ) ;
   int (*socketpair)(struct socket *, struct socket *) ;
   int (*accept)(struct socket *, struct socket *, int ) ;
   int (*getname)(struct socket *, struct sockaddr *, int *, int ) ;
   unsigned int (*poll)(struct file *, struct socket *, struct poll_table_struct *) ;
   int (*ioctl)(struct socket *, unsigned int , unsigned long ) ;
   int (*compat_ioctl)(struct socket *, unsigned int , unsigned long ) ;
   int (*listen)(struct socket *, int ) ;
   int (*shutdown)(struct socket *, int ) ;
   int (*setsockopt)(struct socket *, int , int , char *, unsigned int ) ;
   int (*getsockopt)(struct socket *, int , int , char *, int *) ;
   int (*compat_setsockopt)(struct socket *, int , int , char *, unsigned int ) ;
   int (*compat_getsockopt)(struct socket *, int , int , char *, int *) ;
   int (*sendmsg)(struct socket *, struct msghdr *, size_t ) ;
   int (*recvmsg)(struct socket *, struct msghdr *, size_t , int ) ;
   int (*mmap)(struct file *, struct socket *, struct vm_area_struct *) ;
   ssize_t (*sendpage)(struct socket *, struct page *, int , size_t , int ) ;
   ssize_t (*splice_read)(struct socket *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ) ;
   int (*set_peek_off)(struct sock *, int ) ;
};

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;

#line 84  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};

#line 4  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sem.h"
struct sem_undo_list;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};

#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/shm.h"
struct user_struct;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_173 {
   unsigned long sig[1U] ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_173 sigset_t;

#line 25 
struct siginfo;

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int );

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};

#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_175 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_176 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_177 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_178 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_180 {
   void *_lower ;
   void *_upper ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_179 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_180 _addr_bnd ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_181 {
   long _band ;
   int _fd ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_182 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_174 {
   int _pad[28U] ;
   struct __anonstruct__kill_175 _kill ;
   struct __anonstruct__timer_176 _timer ;
   struct __anonstruct__rt_177 _rt ;
   struct __anonstruct__sigchld_178 _sigchld ;
   struct __anonstruct__sigfault_179 _sigfault ;
   struct __anonstruct__sigpoll_181 _sigpoll ;
   struct __anonstruct__sigsys_182 _sigsys ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_174 _sifields ;
};

#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};

#line 243  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};

#line 443 
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
};

#line 450 
struct pid_namespace;

#line 450  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/seccomp.h"
struct seccomp_filter;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rtmutex.h"
struct rt_mutex_waiter;

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};

#line 50 
struct hrtimer_clock_base;

#line 51 
struct hrtimer_cpu_base;

#line 60 
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer *) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};

#line 156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_hrtirq : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hres_active : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};

#line 466  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/latencytop.h"
struct assoc_array_ptr;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
typedef int32_t key_serial_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
typedef uint32_t key_perm_t;

#line 35 
struct key;

#line 36 
struct signal_struct;

#line 37 
struct key_type;

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const *description ;
   size_t desc_len ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_189 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};

#line 123 
struct key_user;

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_190 {
   time_t expiry ;
   time_t revoked_at ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct __anonstruct_192 {
   struct key_type *type ;
   char *description ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_191 {
   struct keyring_index_key index_key ;
   struct __anonstruct_192 __anonCompField___anonunion_191_52 ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_type_data_193 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_payload_195 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_194 {
   union __anonunion_payload_195 payload ;
   struct assoc_array keys ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_189 __anonCompField_key_50 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_190 __anonCompField_key_51 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion_191 __anonCompField_key_53 ;
   union __anonunion_type_data_193 type_data ;
   union __anonunion_194 __anonCompField_key_54 ;
};

#line 358 
struct audit_context;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};

#line 369 
struct percpu_ref;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref *);

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) force_atomic : 1 ;
   struct callback_head rcu ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-rwsem.h"
struct cgroup;

#line 28 
struct cgroup_root;

#line 29 
struct cgroup_subsys;

#line 30 
struct cgroup_taskset;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-rwsem.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};

#line 197  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};

#line 270  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};

#line 306  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state *, struct cftype *) ;
   s64 (*read_s64)(struct cgroup_subsys_state *, struct cftype *) ;
   int (*seq_show)(struct seq_file *, void *) ;
   void *(*seq_start)(struct seq_file *, loff_t *) ;
   void *(*seq_next)(struct seq_file *, void *, loff_t *) ;
   void (*seq_stop)(struct seq_file *, void *) ;
   int (*write_u64)(struct cgroup_subsys_state *, struct cftype *, u64 ) ;
   int (*write_s64)(struct cgroup_subsys_state *, struct cftype *, s64 ) ;
   ssize_t (*write)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   struct lock_class_key lockdep_key ;
};

#line 388  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state *) ;
   int (*css_online)(struct cgroup_subsys_state *) ;
   void (*css_offline)(struct cgroup_subsys_state *) ;
   void (*css_released)(struct cgroup_subsys_state *) ;
   void (*css_free)(struct cgroup_subsys_state *) ;
   void (*css_reset)(struct cgroup_subsys_state *) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state *) ;
   int (*can_attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*cancel_attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*fork)(struct task_struct *) ;
   void (*exit)(struct cgroup_subsys_state *, struct cgroup_subsys_state *, struct task_struct *) ;
   void (*bind)(struct cgroup_subsys_state *) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};

#line 128  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct futex_pi_state;

#line 129 
struct robust_list_head;

#line 130 
struct bio_list;

#line 131 
struct fs_struct;

#line 132 
struct perf_event_context;

#line 133 
struct blk_plug;

#line 135 
struct nameidata;

#line 188 
struct cfs_rq;

#line 189 
struct task_group;

#line 477  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};

#line 516  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};

#line 524  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};

#line 531  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};

#line 543  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};

#line 563  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};

#line 584  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};

#line 620 
struct autogroup;

#line 621 
struct tty_struct;

#line 621 
struct taskstats;

#line 621 
struct tty_audit_buf;

#line 621  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_child_subreaper : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};

#line 802  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};

#line 845 
struct backing_dev_info;

#line 846 
struct reclaim_state;

#line 847  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};

#line 861  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};

#line 909  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};

#line 1138 
struct io_context;

#line 1172 
struct uts_namespace;

#line 1173  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};

#line 1181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};

#line 1206  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};

#line 1241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};

#line 1273 
struct rt_rq;

#line 1273  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};

#line 1289  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};

#line 1355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) may_oom : 1 ;
};

#line 1779 
struct sched_class;

#line 1779 
struct files_struct;

#line 1779 
struct compat_robust_list_head;

#line 1779 
struct numa_group;

#line 1779 
struct ftrace_ret_stack;

#line 1779  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_struct {
   long volatile state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class const *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_execve : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_iowait : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_reset_on_fork : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_contributes_to_load : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_migrated : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) memcg_kmem_skip_account : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred const *real_cred ;
   struct cred const *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void *) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
   struct thread_struct thread ;
};

#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/checksum_64.h"
struct in6_addr;

#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/checksum.h"
struct sk_buff;

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/checksum.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker *, struct shrink_control *) ;
   unsigned long (*scan_objects)(struct shrinker *, struct shrink_control *) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/page_ext.h"
struct file_ra_state;

#line 65 
struct writeback_control;

#line 66 
struct bdi_writeback;

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};

#line 239  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *) ;
   void (*close)(struct vm_area_struct *) ;
   int (*fault)(struct vm_area_struct *, struct vm_fault *) ;
   void (*map_pages)(struct vm_area_struct *, struct vm_fault *) ;
   int (*page_mkwrite)(struct vm_area_struct *, struct vm_fault *) ;
   int (*pfn_mkwrite)(struct vm_area_struct *, struct vm_fault *) ;
   int (*access)(struct vm_area_struct *, unsigned long , void *, int , int ) ;
   char const *(*name)(struct vm_area_struct *) ;
   int (*set_policy)(struct vm_area_struct *, struct mempolicy *) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct *, unsigned long ) ;
   struct page *(*find_special_page)(struct vm_area_struct *, unsigned long ) ;
};

#line 2291  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};

#line 380  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct dma_map_ops {
   void *(*alloc)(struct device *, size_t , dma_addr_t *, gfp_t , struct dma_attrs *) ;
   void (*free)(struct device *, size_t , void *, dma_addr_t , struct dma_attrs *) ;
   int (*mmap)(struct device *, struct vm_area_struct *, void *, dma_addr_t , size_t , struct dma_attrs *) ;
   int (*get_sgtable)(struct device *, struct sg_table *, void *, dma_addr_t , size_t , struct dma_attrs *) ;
   dma_addr_t (*map_page)(struct device *, struct page *, unsigned long , size_t , enum dma_data_direction , struct dma_attrs *) ;
   void (*unmap_page)(struct device *, dma_addr_t , size_t , enum dma_data_direction , struct dma_attrs *) ;
   int (*map_sg)(struct device *, struct scatterlist *, int , enum dma_data_direction , struct dma_attrs *) ;
   void (*unmap_sg)(struct device *, struct scatterlist *, int , enum dma_data_direction , struct dma_attrs *) ;
   void (*sync_single_for_cpu)(struct device *, dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_single_for_device)(struct device *, dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_sg_for_cpu)(struct device *, struct scatterlist *, int , enum dma_data_direction ) ;
   void (*sync_sg_for_device)(struct device *, struct scatterlist *, int , enum dma_data_direction ) ;
   int (*mapping_error)(struct device *, dma_addr_t ) ;
   int (*dma_supported)(struct device *, u64 ) ;
   int (*set_dma_mask)(struct device *, u64 ) ;
   int is_phys ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
typedef u64 netdev_features_t;

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
union __anonunion_in6_u_210 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
struct in6_addr {
   union __anonunion_in6_u_210 in6_u ;
};

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/in6.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow_dissector.h"
struct pipe_buf_operations;

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow_dissector.h"
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
   struct pipe_buf_operations const *ops ;
   unsigned int flags ;
   unsigned long private ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pipe_fs_i.h"
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int nrbufs ;
   unsigned int curbuf ;
   unsigned int buffers ;
   unsigned int readers ;
   unsigned int writers ;
   unsigned int files ;
   unsigned int waiting_writers ;
   unsigned int r_counter ;
   unsigned int w_counter ;
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pipe_fs_i.h"
struct pipe_buf_operations {
   int can_merge ;
   int (*confirm)(struct pipe_inode_info *, struct pipe_buffer *) ;
   void (*release)(struct pipe_inode_info *, struct pipe_buffer *) ;
   int (*steal)(struct pipe_inode_info *, struct pipe_buffer *) ;
   void (*get)(struct pipe_inode_info *, struct pipe_buffer *) ;
};

#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/splice.h"
struct napi_struct;

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/splice.h"
struct nf_conntrack {
   atomic_t use ;
};

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
enum ldv_22580 {
    BRNF_PROTO_UNCHANGED = 0,
    BRNF_PROTO_8021Q = 1,
    BRNF_PROTO_PPPOE = 2
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_215 {
   struct net_device *physoutdev ;
   char neigh_header[8U] ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_216 {
   __be32 ipv4_daddr ;
   struct in6_addr ipv6_daddr ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   enum ldv_22580 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) orig_proto : 8 ;
   bool pkt_otherhost ;
   __u16 frag_max_size ;
   unsigned int mask ;
   struct net_device *physindev ;
   union __anonunion_215 __anonCompField_nf_bridge_info_61 ;
   union __anonunion_216 __anonCompField_nf_bridge_info_62 ;
};

#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};

#line 403  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_219 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_218 {
   u64 v64 ;
   struct __anonstruct_219 __anonCompField___anonunion_218_63 ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_mstamp {
   union __anonunion_218 __anonCompField_skb_mstamp_64 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_222 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_221 {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion_222 __anonCompField___anonstruct_221_65 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_220 {
   struct __anonstruct_221 __anonCompField___anonunion_220_66 ;
   struct rb_node rbnode ;
};

#line 457 
struct sec_path;

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_224 {
   __u16 csum_start ;
   __u16 csum_offset ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_223 {
   __wsum csum ;
   struct __anonstruct_224 __anonCompField___anonunion_223_68 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_225 {
   unsigned int napi_id ;
   unsigned int sender_cpu ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_226 {
   __u32 mark ;
   __u32 reserved_tailroom ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_227 {
   __be16 inner_protocol ;
   __u8 inner_ipproto ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct sk_buff {
   union __anonunion_220 __anonCompField_sk_buff_67 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   void (*destructor)(struct sk_buff *) ;
   struct sec_path *sp ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   __u16 queue_mapping ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cloned : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) nohdr : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) fclone : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) peeked : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) head_frag : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) xmit_more : 1 ;
   __u32 headers_start[0U] ;
   __u8 __pkt_type_offset[0U] ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) pkt_type : 3 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pfmemalloc : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_df : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) nfctinfo : 3 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) nf_trace : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) ip_summed : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ooo_okay : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) l4_hash : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sw_hash : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wifi_acked_valid : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wifi_acked : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_fcs : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) encapsulation : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) encap_hdr_csum : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_valid : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_complete_sw : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) csum_level : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_bad : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) ndisc_nodetype : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ipvs_property : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) inner_protocol_type : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) remcsum_offload : 1 ;
   __u16 tc_index ;
   __u16 tc_verd ;
   union __anonunion_223 __anonCompField_sk_buff_69 ;
   __u32 priority ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   union __anonunion_225 __anonCompField_sk_buff_70 ;
   __u32 secmark ;
   union __anonunion_226 __anonCompField_sk_buff_71 ;
   union __anonunion_227 __anonCompField_sk_buff_72 ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __be16 protocol ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   __u32 headers_end[0U] ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};

#line 718 
struct dst_entry;

#line 1161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct ieee80211_p2p_noa_desc {
   u8 count ;
   __le32 duration ;
   __le32 interval ;
   __le32 start_time ;
};

#line 1180  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct ieee80211_p2p_noa_attr {
   u8 index ;
   u8 oppps_ctwindow ;
   struct ieee80211_p2p_noa_desc desc[4U] ;
};

#line 1204  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct ieee80211_mcs_info {
   u8 rx_mask[10U] ;
   __le16 rx_highest ;
   u8 tx_params ;
   u8 reserved[3U] ;
};

#line 1229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct ieee80211_ht_cap {
   __le16 cap_info ;
   u8 ampdu_params_info ;
   struct ieee80211_mcs_info mcs ;
   __le16 extended_ht_cap_info ;
   __le32 tx_BF_cap_info ;
   u8 antenna_selection_info ;
};

#line 1354  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct ieee80211_vht_mcs_info {
   __le16 rx_mcs_map ;
   __le16 rx_highest ;
   __le16 tx_mcs_map ;
   __le16 tx_highest ;
};

#line 1435  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct ieee80211_vht_cap {
   __le32 vht_cap_info ;
   struct ieee80211_vht_mcs_info supp_mcs ;
};

#line 1182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dmaengine.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_268 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_268 sync_serial_settings;

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_269 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_269 te1_settings;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_270 {
   unsigned short encoding ;
   unsigned short parity ;
};

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_270 raw_hdlc_proto;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_271 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_271 fr_proto;

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_272 {
   unsigned int dlci ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_272 fr_proto_pvc;

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_273 {
   unsigned int dlci ;
   char master[16U] ;
};

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_273 fr_proto_pvc_info;

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_274 {
   unsigned int interval ;
   unsigned int timeout ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_274 cisco_proto;

#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_275 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_275 ifs_ifsu ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_276 {
   char ifrn_name[16U] ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifr_ifru_277 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_276 ifr_ifrn ;
   union __anonunion_ifr_ifru_277 ifr_ifru ;
};

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kdev_t.h"
struct hlist_bl_node;

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kdev_t.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
struct __anonstruct_282 {
   spinlock_t lock ;
   int count ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
union __anonunion_281 {
   struct __anonstruct_282 __anonCompField___anonunion_281_74 ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
struct lockref {
   union __anonunion_281 __anonCompField_lockref_75 ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct vfsmount;

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct __anonstruct_284 {
   u32 hash ;
   u32 len ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
union __anonunion_283 {
   struct __anonstruct_284 __anonCompField___anonunion_283_76 ;
   u64 hash_len ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct qstr {
   union __anonunion_283 __anonCompField_qstr_77 ;
   unsigned char const *name ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry_operations;

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
union __anonunion_d_u_285 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations const *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_285 d_u ;
};

#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry *, unsigned int ) ;
   int (*d_weak_revalidate)(struct dentry *, unsigned int ) ;
   int (*d_hash)(struct dentry const *, struct qstr *) ;
   int (*d_compare)(struct dentry const *, struct dentry const *, unsigned int , char const *, struct qstr const *) ;
   int (*d_delete)(struct dentry const *) ;
   void (*d_release)(struct dentry *) ;
   void (*d_prune)(struct dentry *) ;
   void (*d_iput)(struct dentry *, struct inode *) ;
   char *(*d_dname)(struct dentry *, char *, int ) ;
   struct vfsmount *(*d_automount)(struct path *) ;
   int (*d_manage)(struct dentry *, bool ) ;
   struct inode *(*d_select_inode)(struct dentry *, unsigned int ) ;
};

#line 586  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/path.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};

#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct __anonstruct_289 {
   struct radix_tree_node *parent ;
   void *private_data ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
union __anonunion_288 {
   struct __anonstruct_289 __anonCompField___anonunion_288_78 ;
   struct callback_head callback_head ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion_288 __anonCompField_radix_tree_node_79 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
};

#line 47 
struct block_device;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/fs.h"
struct export_operations;

#line 62 
struct kstatfs;

#line 63 
struct swap_info_struct;

#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};

#line 212  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dqblk_xfs.h"
struct dquot;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
typedef __kernel_uid32_t projid_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
struct __anonstruct_kprojid_t_293 {
   projid_t val ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_293 kprojid_t;

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
typedef long long qsize_t;

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
union __anonunion_294 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct kqid {
   union __anonunion_294 __anonCompField_kqid_81 ;
   enum quota_type type ;
};

#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};

#line 206 
struct quota_format_type;

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};

#line 272  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};

#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *, int ) ;
   int (*read_file_info)(struct super_block *, int ) ;
   int (*write_file_info)(struct super_block *, int ) ;
   int (*free_file_info)(struct super_block *, int ) ;
   int (*read_dqblk)(struct dquot *) ;
   int (*commit_dqblk)(struct dquot *) ;
   int (*release_dqblk)(struct dquot *) ;
};

#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot *) ;
   struct dquot *(*alloc_dquot)(struct super_block *, int ) ;
   void (*destroy_dquot)(struct dquot *) ;
   int (*acquire_dquot)(struct dquot *) ;
   int (*release_dquot)(struct dquot *) ;
   int (*mark_dirty)(struct dquot *) ;
   int (*write_info)(struct super_block *, int ) ;
   qsize_t *(*get_reserved_space)(struct inode *) ;
   int (*get_projid)(struct inode *, kprojid_t *) ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};

#line 348  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};

#line 394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};

#line 405  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};

#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block *, int , int , struct path *) ;
   int (*quota_off)(struct super_block *, int ) ;
   int (*quota_enable)(struct super_block *, unsigned int ) ;
   int (*quota_disable)(struct super_block *, unsigned int ) ;
   int (*quota_sync)(struct super_block *, int ) ;
   int (*set_info)(struct super_block *, int , struct qc_info *) ;
   int (*get_dqblk)(struct super_block *, struct kqid , struct qc_dqblk *) ;
   int (*set_dqblk)(struct super_block *, struct kqid , struct qc_dqblk *) ;
   int (*get_state)(struct super_block *, struct qc_state *) ;
   int (*rm_xquota)(struct super_block *, unsigned int ) ;
};

#line 432  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops const *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};

#line 496  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops const *ops[3U] ;
};

#line 526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb *, long , long ) ;
   void *private ;
   int ki_flags ;
};

#line 366  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page *, struct writeback_control *) ;
   int (*readpage)(struct file *, struct page *) ;
   int (*writepages)(struct address_space *, struct writeback_control *) ;
   int (*set_page_dirty)(struct page *) ;
   int (*readpages)(struct file *, struct address_space *, struct list_head *, unsigned int ) ;
   int (*write_begin)(struct file *, struct address_space *, loff_t , unsigned int , unsigned int , struct page **, void **) ;
   int (*write_end)(struct file *, struct address_space *, loff_t , unsigned int , unsigned int , struct page *, void *) ;
   sector_t (*bmap)(struct address_space *, sector_t ) ;
   void (*invalidatepage)(struct page *, unsigned int , unsigned int ) ;
   int (*releasepage)(struct page *, gfp_t ) ;
   void (*freepage)(struct page *) ;
   ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *, loff_t ) ;
   int (*migratepage)(struct address_space *, struct page *, struct page *, enum migrate_mode ) ;
   int (*launder_page)(struct page *) ;
   int (*is_partially_uptodate)(struct page *, unsigned long , unsigned long ) ;
   void (*is_dirty_writeback)(struct page *, bool *, bool *) ;
   int (*error_remove_page)(struct address_space *, struct page *) ;
   int (*swap_activate)(struct swap_info_struct *, struct file *, sector_t *) ;
   void (*swap_deactivate)(struct file *) ;
};

#line 423  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations const *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};

#line 443 
struct request_queue;

#line 444 
struct hd_struct;

#line 444 
struct gendisk;

#line 444  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};

#line 560 
struct posix_acl;

#line 561 
struct inode_operations;

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_297 {
   unsigned int const i_nlink ;
   unsigned int __i_nlink ;
};

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_298 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};

#line 561 
struct file_lock_context;

#line 561 
struct cdev;

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_299 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations const *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_297 __anonCompField_inode_82 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_298 __anonCompField_inode_83 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations const *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion_299 __anonCompField_inode_84 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};

#line 807  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};

#line 815  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};

#line 838  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_f_u_300 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};

#line 838  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file {
   union __anonunion_f_u_300 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations const *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred const *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};

#line 923  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
typedef void *fl_owner_t;

#line 924 
struct file_lock;

#line 925  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock *, struct file_lock *) ;
   void (*fl_release_private)(struct file_lock *) ;
};

#line 931  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock *, struct file_lock *) ;
   unsigned long (*lm_owner_key)(struct file_lock *) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t ) ;
   void (*lm_put_owner)(fl_owner_t ) ;
   void (*lm_notify)(struct file_lock *) ;
   int (*lm_grant)(struct file_lock *, int ) ;
   bool (*lm_break)(struct file_lock *) ;
   int (*lm_change)(struct file_lock *, int , struct list_head *) ;
   void (*lm_setup)(struct file_lock *, void **) ;
};

#line 952 
struct nlm_lockowner;

#line 953  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct nfs4_lock_state;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct __anonstruct_afs_302 {
   struct list_head link ;
   int state ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
union __anonunion_fl_u_301 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_302 afs ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations const *fl_ops ;
   struct lock_manager_operations const *fl_lmops ;
   union __anonunion_fl_u_301 fl_u ;
};

#line 1005  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};

#line 1221  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};

#line 1256  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};

#line 1287 
struct super_operations;

#line 1287 
struct xattr_handler;

#line 1287 
struct mtd_info;

#line 1287  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations const *s_op ;
   struct dquot_operations const *dq_op ;
   struct quotactl_ops const *s_qcop ;
   struct export_operations const *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler const **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations const *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};

#line 1526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};

#line 1540 
struct dir_context;

#line 1565  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context *, char const *, int , loff_t , u64 , unsigned int ) ;
   loff_t pos ;
};

#line 1572  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file *, loff_t , int ) ;
   ssize_t (*read)(struct file *, char *, size_t , loff_t *) ;
   ssize_t (*write)(struct file *, char const *, size_t , loff_t *) ;
   ssize_t (*read_iter)(struct kiocb *, struct iov_iter *) ;
   ssize_t (*write_iter)(struct kiocb *, struct iov_iter *) ;
   int (*iterate)(struct file *, struct dir_context *) ;
   unsigned int (*poll)(struct file *, struct poll_table_struct *) ;
   long (*unlocked_ioctl)(struct file *, unsigned int , unsigned long ) ;
   long (*compat_ioctl)(struct file *, unsigned int , unsigned long ) ;
   int (*mmap)(struct file *, struct vm_area_struct *) ;
   int (*mremap)(struct file *, struct vm_area_struct *) ;
   int (*open)(struct inode *, struct file *) ;
   int (*flush)(struct file *, fl_owner_t ) ;
   int (*release)(struct inode *, struct file *) ;
   int (*fsync)(struct file *, loff_t , loff_t , int ) ;
   int (*aio_fsync)(struct kiocb *, int ) ;
   int (*fasync)(int , struct file *, int ) ;
   int (*lock)(struct file *, int , struct file_lock *) ;
   ssize_t (*sendpage)(struct file *, struct page *, int , size_t , loff_t *, int ) ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   int (*check_flags)(int ) ;
   int (*flock)(struct file *, int , struct file_lock *) ;
   ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ) ;
   ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ) ;
   int (*setlease)(struct file *, long , struct file_lock **, void **) ;
   long (*fallocate)(struct file *, int , loff_t , loff_t ) ;
   void (*show_fdinfo)(struct seq_file *, struct file *) ;
};

#line 1633  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode *, struct dentry *, unsigned int ) ;
   char const *(*follow_link)(struct dentry *, void **) ;
   int (*permission)(struct inode *, int ) ;
   struct posix_acl *(*get_acl)(struct inode *, int ) ;
   int (*readlink)(struct dentry *, char *, int ) ;
   void (*put_link)(struct inode *, void *) ;
   int (*create)(struct inode *, struct dentry *, umode_t , bool ) ;
   int (*link)(struct dentry *, struct inode *, struct dentry *) ;
   int (*unlink)(struct inode *, struct dentry *) ;
   int (*symlink)(struct inode *, struct dentry *, char const *) ;
   int (*mkdir)(struct inode *, struct dentry *, umode_t ) ;
   int (*rmdir)(struct inode *, struct dentry *) ;
   int (*mknod)(struct inode *, struct dentry *, umode_t , dev_t ) ;
   int (*rename)(struct inode *, struct dentry *, struct inode *, struct dentry *) ;
   int (*rename2)(struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int ) ;
   int (*setattr)(struct dentry *, struct iattr *) ;
   int (*getattr)(struct vfsmount *, struct dentry *, struct kstat *) ;
   int (*setxattr)(struct dentry *, char const *, void const *, size_t , int ) ;
   ssize_t (*getxattr)(struct dentry *, char const *, void *, size_t ) ;
   ssize_t (*listxattr)(struct dentry *, char *, size_t ) ;
   int (*removexattr)(struct dentry *, char const *) ;
   int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 , u64 ) ;
   int (*update_time)(struct inode *, struct timespec *, int ) ;
   int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned int , umode_t , int *) ;
   int (*tmpfile)(struct inode *, struct dentry *, umode_t ) ;
   int (*set_acl)(struct inode *, struct posix_acl *, int ) ;
};

#line 1687  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *) ;
   void (*destroy_inode)(struct inode *) ;
   void (*dirty_inode)(struct inode *, int ) ;
   int (*write_inode)(struct inode *, struct writeback_control *) ;
   int (*drop_inode)(struct inode *) ;
   void (*evict_inode)(struct inode *) ;
   void (*put_super)(struct super_block *) ;
   int (*sync_fs)(struct super_block *, int ) ;
   int (*freeze_super)(struct super_block *) ;
   int (*freeze_fs)(struct super_block *) ;
   int (*thaw_super)(struct super_block *) ;
   int (*unfreeze_fs)(struct super_block *) ;
   int (*statfs)(struct dentry *, struct kstatfs *) ;
   int (*remount_fs)(struct super_block *, int *, char *) ;
   void (*umount_begin)(struct super_block *) ;
   int (*show_options)(struct seq_file *, struct dentry *) ;
   int (*show_devname)(struct seq_file *, struct dentry *) ;
   int (*show_path)(struct seq_file *, struct dentry *) ;
   int (*show_stats)(struct seq_file *, struct dentry *) ;
   ssize_t (*quota_read)(struct super_block *, int , char *, size_t , loff_t ) ;
   ssize_t (*quota_write)(struct super_block *, int , char const *, size_t , loff_t ) ;
   struct dquot **(*get_dquots)(struct inode *) ;
   int (*bdev_try_to_free_page)(struct super_block *, struct page *, gfp_t ) ;
   long (*nr_cached_objects)(struct super_block *, struct shrink_control *) ;
   long (*free_cached_objects)(struct super_block *, struct shrink_control *) ;
};

#line 1926  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_system_type {
   char const *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type *, int , char const *, void *) ;
   void (*kill_sb)(struct super_block *) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};

#line 276  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};

#line 280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};

#line 715  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compat.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};

#line 125  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char erom_version[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};

#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};

#line 233  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_tunable {
   __u32 cmd ;
   __u32 id ;
   __u32 type_id ;
   __u32 len ;
   void *data[0U] ;
};

#line 245  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 267  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 293  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};

#line 322  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};

#line 438  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};

#line 475  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};

#line 503  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};

#line 605  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};

#line 637  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};

#line 679  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};

#line 712  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};

#line 728  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};

#line 748  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};

#line 759  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};

#line 778  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};

#line 828  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};

#line 999  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};

#line 1007  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 1083  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
};

#line 99  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device *, struct ethtool_cmd *) ;
   int (*set_settings)(struct net_device *, struct ethtool_cmd *) ;
   void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *) ;
   int (*get_regs_len)(struct net_device *) ;
   void (*get_regs)(struct net_device *, struct ethtool_regs *, void *) ;
   void (*get_wol)(struct net_device *, struct ethtool_wolinfo *) ;
   int (*set_wol)(struct net_device *, struct ethtool_wolinfo *) ;
   u32 (*get_msglevel)(struct net_device *) ;
   void (*set_msglevel)(struct net_device *, u32 ) ;
   int (*nway_reset)(struct net_device *) ;
   u32 (*get_link)(struct net_device *) ;
   int (*get_eeprom_len)(struct net_device *) ;
   int (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_coalesce)(struct net_device *, struct ethtool_coalesce *) ;
   int (*set_coalesce)(struct net_device *, struct ethtool_coalesce *) ;
   void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *) ;
   int (*set_ringparam)(struct net_device *, struct ethtool_ringparam *) ;
   void (*get_pauseparam)(struct net_device *, struct ethtool_pauseparam *) ;
   int (*set_pauseparam)(struct net_device *, struct ethtool_pauseparam *) ;
   void (*self_test)(struct net_device *, struct ethtool_test *, u64 *) ;
   void (*get_strings)(struct net_device *, u32 , u8 *) ;
   int (*set_phys_id)(struct net_device *, enum ethtool_phys_id_state ) ;
   void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *, u64 *) ;
   int (*begin)(struct net_device *) ;
   void (*complete)(struct net_device *) ;
   u32 (*get_priv_flags)(struct net_device *) ;
   int (*set_priv_flags)(struct net_device *, u32 ) ;
   int (*get_sset_count)(struct net_device *, int ) ;
   int (*get_rxnfc)(struct net_device *, struct ethtool_rxnfc *, u32 *) ;
   int (*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *) ;
   int (*flash_device)(struct net_device *, struct ethtool_flash *) ;
   int (*reset)(struct net_device *, u32 *) ;
   u32 (*get_rxfh_key_size)(struct net_device *) ;
   u32 (*get_rxfh_indir_size)(struct net_device *) ;
   int (*get_rxfh)(struct net_device *, u32 *, u8 *, u8 *) ;
   int (*set_rxfh)(struct net_device *, u32 const *, u8 const *, u8 const ) ;
   void (*get_channels)(struct net_device *, struct ethtool_channels *) ;
   int (*set_channels)(struct net_device *, struct ethtool_channels *) ;
   int (*get_dump_flag)(struct net_device *, struct ethtool_dump *) ;
   int (*get_dump_data)(struct net_device *, struct ethtool_dump *, void *) ;
   int (*set_dump)(struct net_device *, struct ethtool_dump *) ;
   int (*get_ts_info)(struct net_device *, struct ethtool_ts_info *) ;
   int (*get_module_info)(struct net_device *, struct ethtool_modinfo *) ;
   int (*get_module_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_eee)(struct net_device *, struct ethtool_eee *) ;
   int (*set_eee)(struct net_device *, struct ethtool_eee *) ;
   int (*get_tunable)(struct net_device *, struct ethtool_tunable const *, void *) ;
   int (*set_tunable)(struct net_device *, struct ethtool_tunable const *, void const *) ;
};

#line 235  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow.h"
struct prot_inuse;

#line 236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct u64_stats_sync {
   
};

#line 146  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};

#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[9U] ;
};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[115U] ;
};

#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};

#line 118 
struct proc_dir_entry;

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/packet.h"
struct netns_frags {
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};

#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_frag.h"
struct ipv4_devconf;

#line 185 
struct fib_rules_ops;

#line 186 
struct fib_table;

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
   bool warned ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};

#line 29 
struct inet_peer_base;

#line 29 
struct xt_table;

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   bool fib_offload_disabled ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct inet_peer_base *peers ;
   struct sock **tcp_sk ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_tcp_ecn_fallback ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_ip_nonlocal_bind ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   int sysctl_tcp_mtu_probing ;
   int sysctl_tcp_base_mss ;
   int sysctl_tcp_probe_threshold ;
   u32 sysctl_tcp_probe_interval ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};

#line 113 
struct neighbour;

#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops *) ;
   struct dst_entry *(*check)(struct dst_entry *, __u32 ) ;
   unsigned int (*default_advmss)(struct dst_entry const *) ;
   unsigned int (*mtu)(struct dst_entry const *) ;
   u32 *(*cow_metrics)(struct dst_entry *, unsigned long ) ;
   void (*destroy)(struct dst_entry *) ;
   void (*ifdown)(struct dst_entry *, struct net_device *, int ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry *) ;
   void (*link_failure)(struct sk_buff *) ;
   void (*update_pmtu)(struct dst_entry *, struct sock *, struct sk_buff *, u32 ) ;
   void (*redirect)(struct dst_entry *, struct sock *, struct sk_buff *) ;
   int (*local_out)(struct sk_buff *) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry const *, struct sk_buff *, void const *) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int auto_flowlabels ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
   int idgen_retries ;
   int idgen_delay ;
   int flowlabel_state_ranges ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct ipv6_devconf;

#line 39 
struct rt6_info;

#line 39 
struct rt6_statistics;

#line 39 
struct fib6_table;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t fib6_sernum ;
};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
};

#line 20 
struct sctp_mib;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ieee802154_6lowpan.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netfilter.h"
struct nf_logger;

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger const *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/netfilter.h"
struct ebt_table;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   bool clusterip_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_node;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
};

#line 72 
struct ip_conntrack_stat;

#line 72 
struct nf_ct_event_notifier;

#line 72 
struct nf_exp_event_notifier;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct delayed_work ecache_dwork ;
   bool ecache_dwork_pending ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};

#line 114 
struct nft_af_info;

#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   struct nft_af_info *netdev ;
   unsigned int base_seq ;
   u8 gencursor ;
};

#line 465  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long ) ;
   unsigned long data ;
};

#line 672  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flowcache.h"
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flowcache.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
   u8 dbits4 ;
   u8 sbits4 ;
   u8 dbits6 ;
   u8 sbits6 ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct xfrm_policy_hthresh {
   struct work_struct work ;
   seqlock_t lock ;
   u8 lbits4 ;
   u8 rbits4 ;
   u8 lbits6 ;
   u8 rbits6 ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[3U] ;
   struct xfrm_policy_hash policy_bydst[3U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct xfrm_policy_hthresh policy_hthresh ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};

#line 88 
struct mpls_route;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct netns_mpls {
   size_t platform_labels ;
   struct mpls_route **platform_label ;
   struct ctl_table_header *ctl ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mpls.h"
struct proc_ns_operations;

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mpls.h"
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations const *ops ;
   unsigned int inum ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ns_common.h"
struct net_generic;

#line 12 
struct netns_ipvs;

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ns_common.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   atomic64_t cookie_gen ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   spinlock_t nsid_lock ;
   struct idr netns_ids ;
   struct ns_common ns ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct netns_mpls mpls ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};

#line 241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
struct __anonstruct_possible_net_t_333 {
   struct net *net ;
};

#line 241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
typedef struct __anonstruct_possible_net_t_333 possible_net_t;

#line 376 
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2,
    FWNODE_PDATA = 3
};

#line 383  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
struct fwnode_handle {
   enum fwnode_type type ;
   struct fwnode_handle *secondary ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
typedef u32 phandle;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
struct device_node {
   char const *name ;
   char const *type ;
   phandle phandle ;
   char const *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};

#line 338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mii.h"
enum ldv_28420 {
    PHY_INTERFACE_MODE_NA = 0,
    PHY_INTERFACE_MODE_MII = 1,
    PHY_INTERFACE_MODE_GMII = 2,
    PHY_INTERFACE_MODE_SGMII = 3,
    PHY_INTERFACE_MODE_TBI = 4,
    PHY_INTERFACE_MODE_REVMII = 5,
    PHY_INTERFACE_MODE_RMII = 6,
    PHY_INTERFACE_MODE_RGMII = 7,
    PHY_INTERFACE_MODE_RGMII_ID = 8,
    PHY_INTERFACE_MODE_RGMII_RXID = 9,
    PHY_INTERFACE_MODE_RGMII_TXID = 10,
    PHY_INTERFACE_MODE_RTBI = 11,
    PHY_INTERFACE_MODE_SMII = 12,
    PHY_INTERFACE_MODE_XGMII = 13,
    PHY_INTERFACE_MODE_MOCA = 14,
    PHY_INTERFACE_MODE_QSGMII = 15,
    PHY_INTERFACE_MODE_MAX = 16
};

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
typedef enum ldv_28420 phy_interface_t;

#line 126 
enum ldv_28473 {
    MDIOBUS_ALLOCATED = 1,
    MDIOBUS_REGISTERED = 2,
    MDIOBUS_UNREGISTERED = 3,
    MDIOBUS_RELEASED = 4
};

#line 133 
struct phy_device;

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct mii_bus {
   char const *name ;
   char id[17U] ;
   void *priv ;
   int (*read)(struct mii_bus *, int , int ) ;
   int (*write)(struct mii_bus *, int , int , u16 ) ;
   int (*reset)(struct mii_bus *) ;
   struct mutex mdio_lock ;
   struct device *parent ;
   enum ldv_28473 state ;
   struct device dev ;
   struct phy_device *phy_map[32U] ;
   u32 phy_mask ;
   u32 phy_ignore_ta_mask ;
   int *irq ;
};

#line 214 
enum phy_state {
    PHY_DOWN = 0,
    PHY_STARTING = 1,
    PHY_READY = 2,
    PHY_PENDING = 3,
    PHY_UP = 4,
    PHY_AN = 5,
    PHY_RUNNING = 6,
    PHY_NOLINK = 7,
    PHY_FORCING = 8,
    PHY_CHANGELINK = 9,
    PHY_HALTED = 10,
    PHY_RESUMING = 11
};

#line 229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_c45_device_ids {
   u32 devices_in_package ;
   u32 device_ids[8U] ;
};

#line 323 
struct phy_driver;

#line 323  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_device {
   struct phy_driver *drv ;
   struct mii_bus *bus ;
   struct device dev ;
   u32 phy_id ;
   struct phy_c45_device_ids c45_ids ;
   bool is_c45 ;
   bool is_internal ;
   bool has_fixups ;
   bool suspended ;
   enum phy_state state ;
   u32 dev_flags ;
   phy_interface_t interface ;
   int addr ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
   int link ;
   u32 interrupts ;
   u32 supported ;
   u32 advertising ;
   u32 lp_advertising ;
   int autoneg ;
   int link_timeout ;
   int irq ;
   void *priv ;
   struct work_struct phy_queue ;
   struct delayed_work state_queue ;
   atomic_t irq_disable ;
   struct mutex lock ;
   struct net_device *attached_dev ;
   void (*adjust_link)(struct net_device *) ;
};

#line 429  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_driver {
   u32 phy_id ;
   char *name ;
   unsigned int phy_id_mask ;
   u32 features ;
   u32 flags ;
   void const *driver_data ;
   int (*soft_reset)(struct phy_device *) ;
   int (*config_init)(struct phy_device *) ;
   int (*probe)(struct phy_device *) ;
   int (*suspend)(struct phy_device *) ;
   int (*resume)(struct phy_device *) ;
   int (*config_aneg)(struct phy_device *) ;
   int (*aneg_done)(struct phy_device *) ;
   int (*read_status)(struct phy_device *) ;
   int (*ack_interrupt)(struct phy_device *) ;
   int (*config_intr)(struct phy_device *) ;
   int (*did_interrupt)(struct phy_device *) ;
   void (*remove)(struct phy_device *) ;
   int (*match_phy_device)(struct phy_device *) ;
   int (*ts_info)(struct phy_device *, struct ethtool_ts_info *) ;
   int (*hwtstamp)(struct phy_device *, struct ifreq *) ;
   bool (*rxtstamp)(struct phy_device *, struct sk_buff *, int ) ;
   void (*txtstamp)(struct phy_device *, struct sk_buff *, int ) ;
   int (*set_wol)(struct phy_device *, struct ethtool_wolinfo *) ;
   void (*get_wol)(struct phy_device *, struct ethtool_wolinfo *) ;
   void (*link_change_notify)(struct phy_device *) ;
   int (*read_mmd_indirect)(struct phy_device *, int , int , int ) ;
   void (*write_mmd_indirect)(struct phy_device *, int , int , int , u32 ) ;
   int (*module_info)(struct phy_device *, struct ethtool_modinfo *) ;
   int (*module_eeprom)(struct phy_device *, struct ethtool_eeprom *, u8 *) ;
   struct device_driver driver ;
};

#line 803  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct fixed_phy_status {
   int link ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy_fixed.h"
enum dsa_tag_protocol {
    DSA_TAG_PROTO_NONE = 0,
    DSA_TAG_PROTO_DSA = 1,
    DSA_TAG_PROTO_TRAILER = 2,
    DSA_TAG_PROTO_EDSA = 3,
    DSA_TAG_PROTO_BRCM = 4
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy_fixed.h"
struct dsa_chip_data {
   struct device *host_dev ;
   int sw_addr ;
   int eeprom_len ;
   struct device_node *of_node ;
   char *port_names[12U] ;
   struct device_node *port_dn[12U] ;
   s8 *rtable ;
};

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   struct net_device *of_netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};

#line 84 
struct packet_type;

#line 85 
struct dsa_switch;

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   int (*rcv)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *) ;
   enum dsa_tag_protocol tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};

#line 123 
struct dsa_switch_driver;

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   enum dsa_tag_protocol tag_protocol ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct device *master_dev ;
   char hwmon_name[24U] ;
   struct device *hwmon_dev ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   u32 phys_mii_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   enum dsa_tag_protocol tag_protocol ;
   int priv_size ;
   char *(*probe)(struct device *, int ) ;
   int (*setup)(struct dsa_switch *) ;
   int (*set_addr)(struct dsa_switch *, u8 *) ;
   u32 (*get_phy_flags)(struct dsa_switch *, int ) ;
   int (*phy_read)(struct dsa_switch *, int , int ) ;
   int (*phy_write)(struct dsa_switch *, int , int , u16 ) ;
   void (*poll_link)(struct dsa_switch *) ;
   void (*adjust_link)(struct dsa_switch *, int , struct phy_device *) ;
   void (*fixed_link_update)(struct dsa_switch *, int , struct fixed_phy_status *) ;
   void (*get_strings)(struct dsa_switch *, int , uint8_t *) ;
   void (*get_ethtool_stats)(struct dsa_switch *, int , uint64_t *) ;
   int (*get_sset_count)(struct dsa_switch *) ;
   void (*get_wol)(struct dsa_switch *, int , struct ethtool_wolinfo *) ;
   int (*set_wol)(struct dsa_switch *, int , struct ethtool_wolinfo *) ;
   int (*suspend)(struct dsa_switch *) ;
   int (*resume)(struct dsa_switch *) ;
   int (*port_enable)(struct dsa_switch *, int , struct phy_device *) ;
   void (*port_disable)(struct dsa_switch *, int , struct phy_device *) ;
   int (*set_eee)(struct dsa_switch *, int , struct phy_device *, struct ethtool_eee *) ;
   int (*get_eee)(struct dsa_switch *, int , struct ethtool_eee *) ;
   int (*get_temp)(struct dsa_switch *, int *) ;
   int (*get_temp_limit)(struct dsa_switch *, int *) ;
   int (*set_temp_limit)(struct dsa_switch *, int ) ;
   int (*get_temp_alarm)(struct dsa_switch *, bool *) ;
   int (*get_eeprom_len)(struct dsa_switch *) ;
   int (*get_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *) ;
   int (*set_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *) ;
   int (*get_regs_len)(struct dsa_switch *, int ) ;
   void (*get_regs)(struct dsa_switch *, int , struct ethtool_regs *, void *) ;
   int (*port_join_bridge)(struct dsa_switch *, int , u32 ) ;
   int (*port_leave_bridge)(struct dsa_switch *, int , u32 ) ;
   int (*port_stp_update)(struct dsa_switch *, int , u8 ) ;
   int (*fdb_add)(struct dsa_switch *, int , unsigned char const *, u16 ) ;
   int (*fdb_del)(struct dsa_switch *, int , unsigned char const *, u16 ) ;
   int (*fdb_getnext)(struct dsa_switch *, int , unsigned char *, bool *) ;
};

#line 320  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_qcn {
   __u8 rpg_enable[8U] ;
   __u32 rppp_max_rps[8U] ;
   __u32 rpg_time_reset[8U] ;
   __u32 rpg_byte_reset[8U] ;
   __u32 rpg_threshold[8U] ;
   __u32 rpg_max_rate[8U] ;
   __u32 rpg_ai_rate[8U] ;
   __u32 rpg_hai_rate[8U] ;
   __u32 rpg_gd[8U] ;
   __u32 rpg_min_dec_fac[8U] ;
   __u32 rpg_min_rate[8U] ;
   __u32 cndd_state_machine[8U] ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_qcn_stats {
   __u64 rppp_rp_centiseconds[8U] ;
   __u32 rppp_created_rps[8U] ;
};

#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};

#line 164  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};

#line 202  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};

#line 236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_setets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_getmaxrate)(struct net_device *, struct ieee_maxrate *) ;
   int (*ieee_setmaxrate)(struct net_device *, struct ieee_maxrate *) ;
   int (*ieee_getqcn)(struct net_device *, struct ieee_qcn *) ;
   int (*ieee_setqcn)(struct net_device *, struct ieee_qcn *) ;
   int (*ieee_getqcnstats)(struct net_device *, struct ieee_qcn_stats *) ;
   int (*ieee_getpfc)(struct net_device *, struct ieee_pfc *) ;
   int (*ieee_setpfc)(struct net_device *, struct ieee_pfc *) ;
   int (*ieee_getapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_setapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_delapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_peer_getets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_peer_getpfc)(struct net_device *, struct ieee_pfc *) ;
   u8 (*getstate)(struct net_device *) ;
   u8 (*setstate)(struct net_device *, u8 ) ;
   void (*getpermhwaddr)(struct net_device *, u8 *) ;
   void (*setpgtccfgtx)(struct net_device *, int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgtx)(struct net_device *, int , u8 ) ;
   void (*setpgtccfgrx)(struct net_device *, int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgrx)(struct net_device *, int , u8 ) ;
   void (*getpgtccfgtx)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *) ;
   void (*getpgbwgcfgtx)(struct net_device *, int , u8 *) ;
   void (*getpgtccfgrx)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *) ;
   void (*getpgbwgcfgrx)(struct net_device *, int , u8 *) ;
   void (*setpfccfg)(struct net_device *, int , u8 ) ;
   void (*getpfccfg)(struct net_device *, int , u8 *) ;
   u8 (*setall)(struct net_device *) ;
   u8 (*getcap)(struct net_device *, int , u8 *) ;
   int (*getnumtcs)(struct net_device *, int , u8 *) ;
   int (*setnumtcs)(struct net_device *, int , u8 ) ;
   u8 (*getpfcstate)(struct net_device *) ;
   void (*setpfcstate)(struct net_device *, u8 ) ;
   void (*getbcncfg)(struct net_device *, int , u32 *) ;
   void (*setbcncfg)(struct net_device *, int , u32 ) ;
   void (*getbcnrp)(struct net_device *, int , u8 *) ;
   void (*setbcnrp)(struct net_device *, int , u8 ) ;
   int (*setapp)(struct net_device *, u8 , u16 , u8 ) ;
   int (*getapp)(struct net_device *, u8 , u16 ) ;
   u8 (*getfeatcfg)(struct net_device *, int , u8 *) ;
   u8 (*setfeatcfg)(struct net_device *, int , u8 ) ;
   u8 (*getdcbx)(struct net_device *) ;
   u8 (*setdcbx)(struct net_device *, u8 ) ;
   int (*peer_getappinfo)(struct net_device *, struct dcb_peer_app_info *, u16 *) ;
   int (*peer_getapptable)(struct net_device *, struct dcb_app *) ;
   int (*cee_peer_getpg)(struct net_device *, struct cee_pg *) ;
   int (*cee_peer_getpfc)(struct net_device *, struct cee_pfc *) ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};

#line 515  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};

#line 1628  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/security.h"
struct mnt_namespace;

#line 1629 
struct ipc_namespace;

#line 1630  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};

#line 147  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr const *nlh ;
   int (*dump)(struct sk_buff *, struct netlink_callback *) ;
   int (*done)(struct netlink_callback *) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netlink.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};

#line 643  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_link.h"
struct ifla_vf_stats {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 broadcast ;
   __u64 multicast ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
   __u32 rss_query_en ;
};

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_bonding.h"
struct netpoll_info;

#line 119 
struct wireless_dev;

#line 120 
struct wpan_dev;

#line 121 
struct mpls_dev;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = -2147483648,
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;

#line 129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};

#line 190 
struct neigh_parms;

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};

#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};

#line 245  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff *, struct net_device *, unsigned short , void const *, void const *, unsigned int ) ;
   int (*parse)(struct sk_buff const *, unsigned char *) ;
   int (*cache)(struct neighbour const *, struct hh_cache *, __be16 ) ;
   void (*cache_update)(struct hh_cache *, struct net_device const *, unsigned char const *) ;
};

#line 295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct *, int ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct hrtimer timer ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};

#line 340 
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
};

#line 388  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;

#line 389  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff **);

#line 537 
struct Qdisc;

#line 537  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
   unsigned long tx_maxrate ;
};

#line 607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};

#line 619  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};

#line 631  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};

#line 683  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};

#line 706  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};

#line 719  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};

#line 730  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};

#line 741  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};

#line 757  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_phys_item_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};

#line 770  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device *) ;
   void (*ndo_uninit)(struct net_device *) ;
   int (*ndo_open)(struct net_device *) ;
   int (*ndo_stop)(struct net_device *) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff *, struct net_device *) ;
   u16 (*ndo_select_queue)(struct net_device *, struct sk_buff *, void *, u16 (*)(struct net_device *, struct sk_buff *)) ;
   void (*ndo_change_rx_flags)(struct net_device *, int ) ;
   void (*ndo_set_rx_mode)(struct net_device *) ;
   int (*ndo_set_mac_address)(struct net_device *, void *) ;
   int (*ndo_validate_addr)(struct net_device *) ;
   int (*ndo_do_ioctl)(struct net_device *, struct ifreq *, int ) ;
   int (*ndo_set_config)(struct net_device *, struct ifmap *) ;
   int (*ndo_change_mtu)(struct net_device *, int ) ;
   int (*ndo_neigh_setup)(struct net_device *, struct neigh_parms *) ;
   void (*ndo_tx_timeout)(struct net_device *) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device *, struct rtnl_link_stats64 *) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device *) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device *, __be16 , u16 ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device *, __be16 , u16 ) ;
   void (*ndo_poll_controller)(struct net_device *) ;
   int (*ndo_netpoll_setup)(struct net_device *, struct netpoll_info *) ;
   void (*ndo_netpoll_cleanup)(struct net_device *) ;
   int (*ndo_busy_poll)(struct napi_struct *) ;
   int (*ndo_set_vf_mac)(struct net_device *, int , u8 *) ;
   int (*ndo_set_vf_vlan)(struct net_device *, int , u16 , u8 ) ;
   int (*ndo_set_vf_rate)(struct net_device *, int , int , int ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device *, int , bool ) ;
   int (*ndo_get_vf_config)(struct net_device *, int , struct ifla_vf_info *) ;
   int (*ndo_set_vf_link_state)(struct net_device *, int , int ) ;
   int (*ndo_get_vf_stats)(struct net_device *, int , struct ifla_vf_stats *) ;
   int (*ndo_set_vf_port)(struct net_device *, int , struct nlattr **) ;
   int (*ndo_get_vf_port)(struct net_device *, int , struct sk_buff *) ;
   int (*ndo_set_vf_rss_query_en)(struct net_device *, int , bool ) ;
   int (*ndo_setup_tc)(struct net_device *, u8 ) ;
   int (*ndo_fcoe_enable)(struct net_device *) ;
   int (*ndo_fcoe_disable)(struct net_device *) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device *, u16 , struct scatterlist *, unsigned int ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device *, u16 ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device *, u16 , struct scatterlist *, unsigned int ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device *, struct netdev_fcoe_hbainfo *) ;
   int (*ndo_fcoe_get_wwn)(struct net_device *, u64 *, int ) ;
   int (*ndo_rx_flow_steer)(struct net_device *, struct sk_buff const *, u16 , u32 ) ;
   int (*ndo_add_slave)(struct net_device *, struct net_device *) ;
   int (*ndo_del_slave)(struct net_device *, struct net_device *) ;
   netdev_features_t (*ndo_fix_features)(struct net_device *, netdev_features_t ) ;
   int (*ndo_set_features)(struct net_device *, netdev_features_t ) ;
   int (*ndo_neigh_construct)(struct neighbour *) ;
   void (*ndo_neigh_destroy)(struct neighbour *) ;
   int (*ndo_fdb_add)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 , u16 ) ;
   int (*ndo_fdb_del)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 ) ;
   int (*ndo_fdb_dump)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int ) ;
   int (*ndo_bridge_setlink)(struct net_device *, struct nlmsghdr *, u16 ) ;
   int (*ndo_bridge_getlink)(struct sk_buff *, u32 , u32 , struct net_device *, u32 , int ) ;
   int (*ndo_bridge_dellink)(struct net_device *, struct nlmsghdr *, u16 ) ;
   int (*ndo_change_carrier)(struct net_device *, bool ) ;
   int (*ndo_get_phys_port_id)(struct net_device *, struct netdev_phys_item_id *) ;
   int (*ndo_get_phys_port_name)(struct net_device *, char *, size_t ) ;
   void (*ndo_add_vxlan_port)(struct net_device *, sa_family_t , __be16 ) ;
   void (*ndo_del_vxlan_port)(struct net_device *, sa_family_t , __be16 ) ;
   void *(*ndo_dfwd_add_station)(struct net_device *, struct net_device *) ;
   void (*ndo_dfwd_del_station)(struct net_device *, void *) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff *, struct net_device *, void *) ;
   int (*ndo_get_lock_subclass)(struct net_device *) ;
   netdev_features_t (*ndo_features_check)(struct sk_buff *, struct net_device *, netdev_features_t ) ;
   int (*ndo_set_tx_maxrate)(struct net_device *, int , u32 ) ;
   int (*ndo_get_iflink)(struct net_device const *) ;
};

#line 1243 
enum ldv_30185 {
    NETREG_UNINITIALIZED = 0,
    NETREG_REGISTERED = 1,
    NETREG_UNREGISTERING = 2,
    NETREG_UNREGISTERED = 3,
    NETREG_RELEASED = 4,
    NETREG_DUMMY = 5
};

#line 1252 
enum ldv_30186 {
    RTNL_LINK_INITIALIZED = 0,
    RTNL_LINK_INITIALIZING = 1
};

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct __anonstruct_adj_list_343 {
   struct list_head upper ;
   struct list_head lower ;
};

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct __anonstruct_all_adj_list_344 {
   struct list_head upper ;
   struct list_head lower ;
};

#line 1257 
struct iw_handler_def;

#line 1257 
struct iw_public_data;

#line 1257 
struct switchdev_ops;

#line 1257 
struct vlan_info;

#line 1257 
struct tipc_bearer;

#line 1257 
struct in_device;

#line 1257 
struct dn_dev;

#line 1257 
struct inet6_dev;

#line 1257 
struct tcf_proto;

#line 1257 
struct cpu_rmap;

#line 1257 
struct pcpu_lstats;

#line 1257 
struct pcpu_sw_netstats;

#line 1257 
struct pcpu_dstats;

#line 1257 
struct pcpu_vstats;

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
union __anonunion_345 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};

#line 1257 
struct garp_port;

#line 1257 
struct mrp_port;

#line 1257 
struct rtnl_link_ops;

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   atomic_t carrier_changes ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct list_head ptype_all ;
   struct list_head ptype_specific ;
   struct __anonstruct_adj_list_343 adj_list ;
   struct __anonstruct_all_adj_list_344 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int group ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   struct iw_handler_def const *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops const *netdev_ops ;
   struct ethtool_ops const *ethtool_ops ;
   struct switchdev_ops const *switchdev_ops ;
   struct header_ops const *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   unsigned char name_assign_type ;
   bool uc_promisc ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   struct wpan_dev *ieee802154_ptr ;
   struct mpls_dev *mpls_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   unsigned long gro_flush_timeout ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct tcf_proto *ingress_cl_list ;
   struct netdev_queue *ingress_queue ;
   struct list_head nf_hooks_ingress ;
   unsigned char broadcast[32U] ;
   struct cpu_rmap *rx_cpu_rmap ;
   struct hlist_node index_hlist ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   int watchdog_timeo ;
   struct xps_dev_maps *xps_maps ;
   unsigned long trans_start ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct list_head link_watch_list ;
   enum ldv_30185 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) reg_state : 8 ;
   bool dismantle ;
   enum ldv_30186 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) rtnl_link_state : 16 ;
   void (*destructor)(struct net_device *) ;
   struct netpoll_info *npinfo ;
   possible_net_t nd_net ;
   union __anonunion_345 __anonCompField_net_device_94 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group const *sysfs_groups[4U] ;
   struct attribute_group const *sysfs_rx_queue_group ;
   struct rtnl_link_ops const *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   u16 gso_min_segs ;
   struct dcbnl_rtnl_ops const *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
};

#line 1978  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct packet_type {
   __be16 type ;
   struct net_device *dev ;
   int (*func)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *) ;
   bool (*id_match)(struct packet_type *, struct sock *) ;
   void *af_packet_priv ;
   struct list_head list ;
};

#line 2025  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};

#line 470  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debugfs.h"
enum nl80211_iftype {
    NL80211_IFTYPE_UNSPECIFIED = 0,
    NL80211_IFTYPE_ADHOC = 1,
    NL80211_IFTYPE_STATION = 2,
    NL80211_IFTYPE_AP = 3,
    NL80211_IFTYPE_AP_VLAN = 4,
    NL80211_IFTYPE_WDS = 5,
    NL80211_IFTYPE_MONITOR = 6,
    NL80211_IFTYPE_MESH_POINT = 7,
    NL80211_IFTYPE_P2P_CLIENT = 8,
    NL80211_IFTYPE_P2P_GO = 9,
    NL80211_IFTYPE_P2P_DEVICE = 10,
    NL80211_IFTYPE_OCB = 11,
    NUM_NL80211_IFTYPES = 12,
    NL80211_IFTYPE_MAX = 11
};

#line 2431  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/nl80211.h"
enum nl80211_reg_initiator {
    NL80211_REGDOM_SET_BY_CORE = 0,
    NL80211_REGDOM_SET_BY_USER = 1,
    NL80211_REGDOM_SET_BY_DRIVER = 2,
    NL80211_REGDOM_SET_BY_COUNTRY_IE = 3
};

#line 2484 
enum nl80211_dfs_regions {
    NL80211_DFS_UNSET = 0,
    NL80211_DFS_FCC = 1,
    NL80211_DFS_ETSI = 2,
    NL80211_DFS_JP = 3
};

#line 2491 
enum nl80211_user_reg_hint_type {
    NL80211_USER_REG_HINT_USER = 0,
    NL80211_USER_REG_HINT_CELL_BASE = 1,
    NL80211_USER_REG_HINT_INDOOR = 2
};

#line 2600 
enum nl80211_channel_type {
    NL80211_CHAN_NO_HT = 0,
    NL80211_CHAN_HT20 = 1,
    NL80211_CHAN_HT40MINUS = 2,
    NL80211_CHAN_HT40PLUS = 3
};

#line 2607 
enum nl80211_chan_width {
    NL80211_CHAN_WIDTH_20_NOHT = 0,
    NL80211_CHAN_WIDTH_20 = 1,
    NL80211_CHAN_WIDTH_40 = 2,
    NL80211_CHAN_WIDTH_80 = 3,
    NL80211_CHAN_WIDTH_80P80 = 4,
    NL80211_CHAN_WIDTH_160 = 5,
    NL80211_CHAN_WIDTH_5 = 6,
    NL80211_CHAN_WIDTH_10 = 7
};

#line 2618 
enum nl80211_bss_scan_width {
    NL80211_BSS_CHAN_WIDTH_20 = 0,
    NL80211_BSS_CHAN_WIDTH_10 = 1,
    NL80211_BSS_CHAN_WIDTH_5 = 2
};

#line 2650 
enum nl80211_auth_type {
    NL80211_AUTHTYPE_OPEN_SYSTEM = 0,
    NL80211_AUTHTYPE_SHARED_KEY = 1,
    NL80211_AUTHTYPE_FT = 2,
    NL80211_AUTHTYPE_NETWORK_EAP = 3,
    NL80211_AUTHTYPE_SAE = 4,
    __NL80211_AUTHTYPE_NUM = 5,
    NL80211_AUTHTYPE_MAX = 4,
    NL80211_AUTHTYPE_AUTOMATIC = 5
};

#line 2668 
enum nl80211_mfp {
    NL80211_MFP_NO = 0,
    NL80211_MFP_REQUIRED = 1
};

#line 3596 
enum nl80211_tx_power_setting {
    NL80211_TX_POWER_AUTOMATIC = 0,
    NL80211_TX_POWER_LIMITED = 1,
    NL80211_TX_POWER_FIXED = 2
};

#line 3734  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/nl80211.h"
struct nl80211_wowlan_tcp_data_seq {
   __u32 start ;
   __u32 offset ;
   __u32 len ;
};

#line 3871  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/nl80211.h"
struct nl80211_wowlan_tcp_data_token {
   __u32 offset ;
   __u32 len ;
   __u8 token_stream[] ;
};

#line 3883  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/nl80211.h"
struct nl80211_wowlan_tcp_data_token_feature {
   __u32 min_len ;
   __u32 max_len ;
   __u32 bufsize ;
};

#line 4131 
enum nl80211_dfs_state {
    NL80211_DFS_USABLE = 0,
    NL80211_DFS_UNAVAILABLE = 1,
    NL80211_DFS_AVAILABLE = 2
};

#line 4153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/nl80211.h"
struct nl80211_vendor_cmd_info {
   __u32 vendor_id ;
   __u32 subcmd ;
};

#line 4581 
enum environment_cap {
    ENVIRON_ANY = 0,
    ENVIRON_INDOOR = 1,
    ENVIRON_OUTDOOR = 2
};

#line 4587  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/nl80211.h"
struct regulatory_request {
   struct callback_head callback_head ;
   int wiphy_idx ;
   enum nl80211_reg_initiator initiator ;
   enum nl80211_user_reg_hint_type user_reg_hint_type ;
   char alpha2[2U] ;
   enum nl80211_dfs_regions dfs_region ;
   bool intersect ;
   bool processed ;
   enum environment_cap country_ie_env ;
   struct list_head list ;
};

#line 99  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/regulatory.h"
struct ieee80211_freq_range {
   u32 start_freq_khz ;
   u32 end_freq_khz ;
   u32 max_bandwidth_khz ;
};

#line 185  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/regulatory.h"
struct ieee80211_power_rule {
   u32 max_antenna_gain ;
   u32 max_eirp ;
};

#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/regulatory.h"
struct ieee80211_reg_rule {
   struct ieee80211_freq_range freq_range ;
   struct ieee80211_power_rule power_rule ;
   u32 flags ;
   u32 dfs_cac_ms ;
};

#line 197  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/regulatory.h"
struct ieee80211_regdomain {
   struct callback_head callback_head ;
   u32 n_reg_rules ;
   char alpha2[3U] ;
   enum nl80211_dfs_regions dfs_region ;
   struct ieee80211_reg_rule reg_rules[] ;
};

#line 205 
struct wiphy;

#line 206 
enum ieee80211_band {
    IEEE80211_BAND_2GHZ = 0,
    IEEE80211_BAND_5GHZ = 1,
    IEEE80211_BAND_60GHZ = 2,
    IEEE80211_NUM_BANDS = 3
};

#line 228  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/regulatory.h"
struct ieee80211_channel {
   enum ieee80211_band band ;
   u16 center_freq ;
   u16 hw_value ;
   u32 flags ;
   int max_antenna_gain ;
   int max_power ;
   int max_reg_power ;
   bool beacon_found ;
   u32 orig_flags ;
   int orig_mag ;
   int orig_mpwr ;
   enum nl80211_dfs_state dfs_state ;
   unsigned long dfs_state_entered ;
   unsigned int dfs_cac_ms ;
};

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct ieee80211_rate {
   u32 flags ;
   u16 bitrate ;
   u16 hw_value ;
   u16 hw_value_short ;
};

#line 269  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct ieee80211_sta_ht_cap {
   u16 cap ;
   bool ht_supported ;
   u8 ampdu_factor ;
   u8 ampdu_density ;
   struct ieee80211_mcs_info mcs ;
};

#line 289  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct ieee80211_sta_vht_cap {
   bool vht_supported ;
   u32 cap ;
   struct ieee80211_vht_mcs_info vht_mcs ;
};

#line 305  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct ieee80211_supported_band {
   struct ieee80211_channel *channels ;
   struct ieee80211_rate *bitrates ;
   enum ieee80211_band band ;
   int n_channels ;
   int n_bitrates ;
   struct ieee80211_sta_ht_cap ht_cap ;
   struct ieee80211_sta_vht_cap vht_cap ;
};

#line 387  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_chan_def {
   struct ieee80211_channel *chan ;
   enum nl80211_chan_width width ;
   u32 center_freq1 ;
   u32 center_freq2 ;
};

#line 608  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_crypto_settings {
   u32 wpa_versions ;
   u32 cipher_group ;
   int n_ciphers_pairwise ;
   u32 ciphers_pairwise[5U] ;
   int n_akm_suites ;
   u32 akm_suites[2U] ;
   bool control_port ;
   __be16 control_port_ethertype ;
   bool control_port_no_encrypt ;
};

#line 671  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct mac_address {
   u8 addr[6U] ;
};

#line 1395  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_ssid {
   u8 ssid[32U] ;
   u8 ssid_len ;
};

#line 1428  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_scan_request {
   struct cfg80211_ssid *ssids ;
   int n_ssids ;
   u32 n_channels ;
   enum nl80211_bss_scan_width scan_width ;
   u8 const *ie ;
   size_t ie_len ;
   u32 flags ;
   u32 rates[3U] ;
   struct wireless_dev *wdev ;
   u8 mac_addr[6U] ;
   u8 mac_addr_mask[6U] ;
   struct wiphy *wiphy ;
   unsigned long scan_start ;
   bool aborted ;
   bool notified ;
   bool no_cck ;
   struct ieee80211_channel *channels[0U] ;
};

#line 1491  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_match_set {
   struct cfg80211_ssid ssid ;
   s32 rssi_thold ;
};

#line 1499  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_sched_scan_request {
   struct cfg80211_ssid *ssids ;
   int n_ssids ;
   u32 n_channels ;
   enum nl80211_bss_scan_width scan_width ;
   u32 interval ;
   u8 const *ie ;
   size_t ie_len ;
   u32 flags ;
   struct cfg80211_match_set *match_sets ;
   int n_match_sets ;
   s32 min_rssi_thold ;
   u32 delay ;
   u8 mac_addr[6U] ;
   u8 mac_addr_mask[6U] ;
   struct wiphy *wiphy ;
   struct net_device *dev ;
   unsigned long scan_start ;
   struct callback_head callback_head ;
   u32 owner_nlportid ;
   struct ieee80211_channel *channels[0U] ;
};

#line 1561 
enum cfg80211_signal_type {
    CFG80211_SIGNAL_TYPE_NONE = 0,
    CFG80211_SIGNAL_TYPE_MBM = 1,
    CFG80211_SIGNAL_TYPE_UNSPEC = 2
};

#line 1766  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_ibss_params {
   u8 const *ssid ;
   u8 const *bssid ;
   struct cfg80211_chan_def chandef ;
   u8 const *ie ;
   u8 ssid_len ;
   u8 ie_len ;
   u16 beacon_interval ;
   u32 basic_rates ;
   bool channel_fixed ;
   bool privacy ;
   bool control_port ;
   bool userspace_handles_dfs ;
   int mcast_rate[3U] ;
   struct ieee80211_ht_cap ht_capa ;
   struct ieee80211_ht_cap ht_capa_mask ;
};

#line 1814  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_connect_params {
   struct ieee80211_channel *channel ;
   struct ieee80211_channel *channel_hint ;
   u8 const *bssid ;
   u8 const *bssid_hint ;
   u8 const *ssid ;
   size_t ssid_len ;
   enum nl80211_auth_type auth_type ;
   u8 const *ie ;
   size_t ie_len ;
   bool privacy ;
   enum nl80211_mfp mfp ;
   struct cfg80211_crypto_settings crypto ;
   u8 const *key ;
   u8 key_len ;
   u8 key_idx ;
   u32 flags ;
   int bg_scan_period ;
   struct ieee80211_ht_cap ht_capa ;
   struct ieee80211_ht_cap ht_capa_mask ;
   struct ieee80211_vht_cap vht_capa ;
   struct ieee80211_vht_cap vht_capa_mask ;
};

#line 1916  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_pkt_pattern {
   u8 const *mask ;
   u8 const *pattern ;
   int pattern_len ;
   int pkt_offset ;
};

#line 1933  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_wowlan_tcp {
   struct socket *sock ;
   __be32 src ;
   __be32 dst ;
   u16 src_port ;
   u16 dst_port ;
   u8 dst_mac[6U] ;
   int payload_len ;
   u8 const *payload ;
   struct nl80211_wowlan_tcp_data_seq payload_seq ;
   u32 data_interval ;
   u32 wake_len ;
   u8 const *wake_data ;
   u8 const *wake_mask ;
   u32 tokens_size ;
   struct nl80211_wowlan_tcp_data_token payload_tok ;
};

#line 1968  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_wowlan {
   bool any ;
   bool disconnect ;
   bool magic_pkt ;
   bool gtk_rekey_failure ;
   bool eap_identity_req ;
   bool four_way_handshake ;
   bool rfkill_release ;
   struct cfg80211_pkt_pattern *patterns ;
   struct cfg80211_wowlan_tcp *tcp ;
   int n_patterns ;
   struct cfg80211_sched_scan_request *nd_config ;
};

#line 2736  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct ieee80211_iface_limit {
   u16 max ;
   u16 types ;
};

#line 2797  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct ieee80211_iface_combination {
   struct ieee80211_iface_limit const *limits ;
   u32 num_different_channels ;
   u16 max_interfaces ;
   u8 n_limits ;
   bool beacon_int_infra_match ;
   u8 radar_detect_widths ;
   u8 radar_detect_regions ;
};

#line 2869  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct ieee80211_txrx_stypes {
   u16 tx ;
   u16 rx ;
};

#line 2885  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct wiphy_wowlan_tcp_support {
   struct nl80211_wowlan_tcp_data_token_feature const *tok ;
   u32 data_payload_max ;
   u32 data_interval_max ;
   u32 wake_payload_max ;
   bool seq ;
};

#line 2910  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct wiphy_wowlan_support {
   u32 flags ;
   int n_patterns ;
   int pattern_max_len ;
   int pattern_min_len ;
   int max_pkt_offset ;
   int max_nd_match_sets ;
   struct wiphy_wowlan_tcp_support const *tcp ;
};

#line 2935  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct wiphy_coalesce_support {
   int n_rules ;
   int max_delay ;
   int n_patterns ;
   int pattern_max_len ;
   int pattern_min_len ;
   int max_pkt_offset ;
};

#line 2960  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct wiphy_vendor_command {
   struct nl80211_vendor_cmd_info info ;
   u32 flags ;
   int (*doit)(struct wiphy *, struct wireless_dev *, void const *, int ) ;
};

#line 2981  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct wiphy {
   u8 perm_addr[6U] ;
   u8 addr_mask[6U] ;
   struct mac_address *addresses ;
   struct ieee80211_txrx_stypes const *mgmt_stypes ;
   struct ieee80211_iface_combination const *iface_combinations ;
   int n_iface_combinations ;
   u16 software_iftypes ;
   u16 n_addresses ;
   u16 interface_modes ;
   u16 max_acl_mac_addrs ;
   u32 flags ;
   u32 regulatory_flags ;
   u32 features ;
   u8 ext_features[1U] ;
   u32 ap_sme_capa ;
   enum cfg80211_signal_type signal_type ;
   int bss_priv_size ;
   u8 max_scan_ssids ;
   u8 max_sched_scan_ssids ;
   u8 max_match_sets ;
   u16 max_scan_ie_len ;
   u16 max_sched_scan_ie_len ;
   int n_cipher_suites ;
   u32 const *cipher_suites ;
   u8 retry_short ;
   u8 retry_long ;
   u32 frag_threshold ;
   u32 rts_threshold ;
   u8 coverage_class ;
   char fw_version[32U] ;
   u32 hw_version ;
   struct wiphy_wowlan_support const *wowlan ;
   struct cfg80211_wowlan *wowlan_config ;
   u16 max_remain_on_channel_duration ;
   u8 max_num_pmkids ;
   u32 available_antennas_tx ;
   u32 available_antennas_rx ;
   u32 probe_resp_offload ;
   u8 const *extended_capabilities ;
   u8 const *extended_capabilities_mask ;
   u8 extended_capabilities_len ;
   void const *privid ;
   struct ieee80211_supported_band *bands[3U] ;
   void (*reg_notifier)(struct wiphy *, struct regulatory_request *) ;
   struct ieee80211_regdomain const *regd ;
   struct device dev ;
   bool registered ;
   struct dentry *debugfsdir ;
   struct ieee80211_ht_cap const *ht_capa_mod_mask ;
   struct ieee80211_vht_cap const *vht_capa_mod_mask ;
   possible_net_t _net ;
   struct iw_handler_def const *wext ;
   struct wiphy_coalesce_support const *coalesce ;
   struct wiphy_vendor_command const *vendor_commands ;
   struct nl80211_vendor_cmd_info const *vendor_events ;
   int n_vendor_commands ;
   int n_vendor_events ;
   u16 max_ap_assoc_sta ;
   u8 max_num_csa_counters ;
   u8 max_adj_channel_rssi_comp ;
   char priv[0U] ;
};

#line 3369 
struct cfg80211_conn;

#line 3370 
struct cfg80211_internal_bss;

#line 3371 
struct cfg80211_cached_keys;

#line 3372  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct __anonstruct_wext_351 {
   struct cfg80211_ibss_params ibss ;
   struct cfg80211_connect_params connect ;
   struct cfg80211_cached_keys *keys ;
   u8 const *ie ;
   size_t ie_len ;
   u8 bssid[6U] ;
   u8 prev_bssid[6U] ;
   u8 ssid[32U] ;
   s8 default_key ;
   s8 default_mgmt_key ;
   bool prev_bssid_valid ;
};

#line 3372  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct wireless_dev {
   struct wiphy *wiphy ;
   enum nl80211_iftype iftype ;
   struct list_head list ;
   struct net_device *netdev ;
   u32 identifier ;
   struct list_head mgmt_registrations ;
   spinlock_t mgmt_registrations_lock ;
   struct mutex mtx ;
   bool use_4addr ;
   bool p2p_started ;
   u8 address[6U] ;
   u8 ssid[32U] ;
   u8 ssid_len ;
   u8 mesh_id_len ;
   u8 mesh_id_up_len ;
   struct cfg80211_conn *conn ;
   struct cfg80211_cached_keys *connect_keys ;
   struct list_head event_list ;
   spinlock_t event_lock ;
   struct cfg80211_internal_bss *current_bss ;
   struct cfg80211_chan_def preset_chandef ;
   struct cfg80211_chan_def chandef ;
   bool ibss_fixed ;
   bool ibss_dfs_possible ;
   bool ps ;
   int ps_timeout ;
   int beacon_interval ;
   u32 ap_unexpected_nlportid ;
   bool cac_started ;
   unsigned long cac_start_time ;
   unsigned int cac_time_ms ;
   u32 owner_nlportid ;
   struct __anonstruct_wext_351 wext ;
};

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_chanctx_conf {
   struct cfg80211_chan_def def ;
   struct cfg80211_chan_def min_def ;
   u8 rx_chains_static ;
   u8 rx_chains_dynamic ;
   bool radar_enabled ;
   u8 drv_priv[0U] ;
};

#line 229 
struct ieee80211_vif;

#line 407 
struct ieee80211_sta;

#line 436  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_bss_conf {
   u8 const *bssid ;
   bool assoc ;
   bool ibss_joined ;
   bool ibss_creator ;
   u16 aid ;
   bool use_cts_prot ;
   bool use_short_preamble ;
   bool use_short_slot ;
   bool enable_beacon ;
   u8 dtim_period ;
   u16 beacon_int ;
   u16 assoc_capability ;
   u64 sync_tsf ;
   u32 sync_device_ts ;
   u8 sync_dtim_count ;
   u32 basic_rates ;
   struct ieee80211_rate *beacon_rate ;
   int mcast_rate[3U] ;
   u16 ht_operation_mode ;
   s32 cqm_rssi_thold ;
   u32 cqm_rssi_hyst ;
   struct cfg80211_chan_def chandef ;
   __be32 arp_addr_list[4U] ;
   int arp_addr_cnt ;
   bool qos ;
   bool idle ;
   bool ps ;
   u8 ssid[32U] ;
   size_t ssid_len ;
   bool hidden_ssid ;
   int txpower ;
   enum nl80211_tx_power_setting txpower_type ;
   struct ieee80211_p2p_noa_attr p2p_noa_attr ;
};

#line 819 
struct ieee80211_key_conf;

#line 896  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_scan_ies {
   u8 const *ies[3U] ;
   size_t len[3U] ;
   u8 const *common_ies ;
   size_t common_ie_len ;
};

#line 1174 
enum ieee80211_smps_mode {
    IEEE80211_SMPS_AUTOMATIC = 0,
    IEEE80211_SMPS_OFF = 1,
    IEEE80211_SMPS_STATIC = 2,
    IEEE80211_SMPS_DYNAMIC = 3,
    IEEE80211_SMPS_NUM_MODES = 4
};

#line 1182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_conf {
   u32 flags ;
   int power_level ;
   int dynamic_ps_timeout ;
   int max_sleep_period ;
   u16 listen_interval ;
   u8 ps_dtim_period ;
   u8 long_frame_max_tx_count ;
   u8 short_frame_max_tx_count ;
   struct cfg80211_chan_def chandef ;
   bool radar_enabled ;
   enum ieee80211_smps_mode smps_mode ;
};

#line 1285  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_channel_switch {
   u64 timestamp ;
   u32 device_timestamp ;
   bool block_tx ;
   struct cfg80211_chan_def chandef ;
   u8 count ;
};

#line 1316 
struct ieee80211_txq;

#line 1316  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_vif {
   enum nl80211_iftype type ;
   struct ieee80211_bss_conf bss_conf ;
   u8 addr[6U] ;
   bool p2p ;
   bool csa_active ;
   u8 cab_queue ;
   u8 hw_queue[4U] ;
   struct ieee80211_txq *txq ;
   struct ieee80211_chanctx_conf *chanctx_conf ;
   u32 driver_flags ;
   struct dentry *debugfs_dir ;
   u8 drv_priv[0U] ;
};

#line 1432  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_key_conf {
   atomic64_t tx_pn ;
   u32 cipher ;
   u8 icv_len ;
   u8 iv_len ;
   u8 hw_key_idx ;
   u8 flags ;
   s8 keyidx ;
   u8 keylen ;
   u8 key[0U] ;
};

#line 1547  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_cipher_scheme {
   u32 cipher ;
   u16 iftype ;
   u8 hdr_len ;
   u8 pn_len ;
   u8 pn_off ;
   u8 key_idx_off ;
   u8 key_idx_mask ;
   u8 key_idx_shift ;
   u8 mic_len ;
};

#line 1577 
enum set_key_cmd {
    SET_KEY = 0,
    DISABLE_KEY = 1
};

#line 1590 
enum ieee80211_sta_rx_bandwidth {
    IEEE80211_STA_RX_BW_20 = 0,
    IEEE80211_STA_RX_BW_40 = 1,
    IEEE80211_STA_RX_BW_80 = 2,
    IEEE80211_STA_RX_BW_160 = 3
};

#line 1597  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct __anonstruct_rate_367 {
   s8 idx ;
   u8 count ;
   u8 count_cts ;
   u8 count_rts ;
   u16 flags ;
};

#line 1597  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_sta_rates {
   struct callback_head callback_head ;
   struct __anonstruct_rate_367 rate[4U] ;
};

#line 1645  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_sta {
   u32 supp_rates[3U] ;
   u8 addr[6U] ;
   u16 aid ;
   struct ieee80211_sta_ht_cap ht_cap ;
   struct ieee80211_sta_vht_cap vht_cap ;
   bool wme ;
   u8 uapsd_queues ;
   u8 max_sp ;
   u8 rx_nss ;
   enum ieee80211_sta_rx_bandwidth bandwidth ;
   enum ieee80211_smps_mode smps_mode ;
   struct ieee80211_sta_rates *rates ;
   bool tdls ;
   bool tdls_initiator ;
   bool mfp ;
   struct ieee80211_txq *txq[16U] ;
   u8 drv_priv[0U] ;
};

#line 1726  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_txq {
   struct ieee80211_vif *vif ;
   struct ieee80211_sta *sta ;
   u8 tid ;
   u8 ac ;
   u8 drv_priv[0U] ;
};

#line 1781  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_hw {
   struct ieee80211_conf conf ;
   struct wiphy *wiphy ;
   char const *rate_control_algorithm ;
   void *priv ;
   unsigned long flags[1U] ;
   unsigned int extra_tx_headroom ;
   unsigned int extra_beacon_tailroom ;
   int vif_data_size ;
   int sta_data_size ;
   int chanctx_data_size ;
   int txq_data_size ;
   u16 queues ;
   u16 max_listen_interval ;
   s8 max_signal ;
   u8 max_rates ;
   u8 max_report_rates ;
   u8 max_rate_tries ;
   u8 max_rx_aggregation_subframes ;
   u8 max_tx_aggregation_subframes ;
   u8 offchannel_tx_hw_queue ;
   u8 radiotap_mcs_details ;
   u16 radiotap_vht_details ;
   netdev_features_t netdev_features ;
   u8 uapsd_queues ;
   u8 uapsd_max_sp_len ;
   u8 n_cipher_schemes ;
   struct ieee80211_cipher_scheme const *cipher_schemes ;
   int txq_ac_max_pending ;
};

#line 5586  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct conf_sg_settings {
   u32 params[67U] ;
   u8 state ;
};

#line 356  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_rx_settings {
   u32 rx_msdu_life_time ;
   u32 packet_detection_threshold ;
   u16 ps_poll_timeout ;
   u16 upsd_timeout ;
   u16 rts_threshold ;
   u16 rx_cca_threshold ;
   u16 irq_blk_threshold ;
   u16 irq_pkt_threshold ;
   u16 irq_timeout ;
   u8 queue_type ;
};

#line 435  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_tx_rate_class {
   u32 enabled_rates ;
   u8 short_retry_limit ;
   u8 long_retry_limit ;
   u8 aflags ;
};

#line 542  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_tx_ac_category {
   u8 ac ;
   u8 cw_min ;
   u16 cw_max ;
   u8 aifsn ;
   u16 tx_op_limit ;
};

#line 609  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_tx_tid {
   u8 queue_id ;
   u8 channel_type ;
   u8 tsid ;
   u8 ps_scheme ;
   u8 ack_policy ;
   u32 apsd_conf[2U] ;
};

#line 624  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_tx_settings {
   u8 tx_energy_detection ;
   struct conf_tx_rate_class sta_rc_conf ;
   u8 ac_conf_count ;
   struct conf_tx_ac_category ac_conf[4U] ;
   u8 max_tx_retries ;
   u16 ap_aging_period ;
   u8 tid_conf_count ;
   struct conf_tx_tid tid_conf[8U] ;
   u16 frag_threshold ;
   u16 tx_compl_timeout ;
   u16 tx_compl_threshold ;
   u32 basic_rate ;
   u32 basic_rate_5 ;
   u8 tmpl_short_retry_limit ;
   u8 tmpl_long_retry_limit ;
   u32 tx_watchdog_timeout ;
   u8 slow_link_thold ;
   u8 fast_link_thold ;
};

#line 730  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_bcn_filt_rule {
   u8 ie ;
   u8 rule ;
   u8 oui[3U] ;
   u8 type ;
   u8 version[2U] ;
};

#line 787  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_sig_weights {
   u8 rssi_bcn_avg_weight ;
   u8 rssi_pkt_avg_weight ;
   u8 snr_bcn_avg_weight ;
   u8 snr_pkt_avg_weight ;
};

#line 830  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_conn_settings {
   u8 wake_up_event ;
   u8 listen_interval ;
   u8 suspend_wake_up_event ;
   u8 suspend_listen_interval ;
   u8 bcn_filt_mode ;
   u8 bcn_filt_ie_count ;
   struct conf_bcn_filt_rule bcn_filt_ie[32U] ;
   u32 synch_fail_thold ;
   u32 bss_lose_timeout ;
   u32 beacon_rx_timeout ;
   u32 broadcast_timeout ;
   u8 rx_broadcast_in_ps ;
   u8 ps_poll_threshold ;
   struct conf_sig_weights sig_weights ;
   u8 bet_enable ;
   u8 bet_max_consecutive ;
   u8 psm_entry_retries ;
   u8 psm_exit_retries ;
   u8 psm_entry_nullfunc_retries ;
   u16 dynamic_ps_timeout ;
   u8 forced_ps ;
   u32 keep_alive_interval ;
   u8 max_listen_interval ;
   u8 sta_sleep_auth ;
   u8 suspend_rx_ba_activity ;
};

#line 1020  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_itrim_settings {
   u8 enable ;
   u32 timeout ;
};

#line 1039  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_pm_config_settings {
   u32 host_clk_settling_time ;
   u8 host_fast_wakeup_support ;
};

#line 1055  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_roam_trigger_settings {
   u16 trigger_pacing ;
   u8 avg_weight_rssi_beacon ;
   u8 avg_weight_rssi_data ;
   u8 avg_weight_snr_beacon ;
   u8 avg_weight_snr_data ;
};

#line 1092  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_scan_settings {
   u32 min_dwell_time_active ;
   u32 max_dwell_time_active ;
   u32 min_dwell_time_active_long ;
   u32 max_dwell_time_active_long ;
   u32 dwell_time_passive ;
   u32 dwell_time_dfs ;
   u16 num_probe_reqs ;
   u32 split_scan_timeout ;
};

#line 1152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_sched_scan_settings {
   u32 base_dwell_time ;
   u32 max_dwell_time_delta ;
   u32 dwell_time_delta_per_probe ;
   u32 dwell_time_delta_per_probe_5 ;
   u32 dwell_time_passive ;
   u32 dwell_time_dfs ;
   u8 num_probe_reqs ;
   s8 rssi_threshold ;
   s8 snr_threshold ;
};

#line 1190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_ht_setting {
   u8 rx_ba_win_size ;
   u8 tx_ba_win_size ;
   u16 inactivity_timeout ;
   u8 tx_ba_tid_bitmap ;
};

#line 1199  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_memory_settings {
   u8 num_stations ;
   u8 ssid_profiles ;
   u8 rx_block_num ;
   u8 tx_min_block_num ;
   u8 dynamic_memory ;
   u8 min_req_tx_blocks ;
   u8 min_req_rx_blocks ;
   u8 tx_min ;
};

#line 1239  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_fm_coex {
   u8 enable ;
   u8 swallow_period ;
   u8 n_divider_fref_set_1 ;
   u8 n_divider_fref_set_2 ;
   u16 m_divider_fref_set_1 ;
   u16 m_divider_fref_set_2 ;
   u32 coex_pll_stabilization_time ;
   u16 ldo_stabilization_time ;
   u8 fm_disturbed_band_margin ;
   u8 swallow_clk_diff ;
};

#line 1252  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_rx_streaming_settings {
   u32 duration ;
   u8 queues ;
   u8 interval ;
   u8 always ;
};

#line 1281  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_fwlog {
   u8 mode ;
   u8 mem_blocks ;
   u8 severity ;
   u8 timestamp ;
   u8 output ;
   u8 threshold ;
};

#line 1308  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_rate_policy_settings {
   u16 rate_retry_score ;
   u16 per_add ;
   u16 per_th1 ;
   u16 per_th2 ;
   u16 max_per ;
   u8 inverse_curiosity_factor ;
   u8 tx_fail_low_th ;
   u8 tx_fail_high_th ;
   u8 per_alpha_shift ;
   u8 per_add_shift ;
   u8 per_beta1_shift ;
   u8 per_beta2_shift ;
   u8 rate_check_up ;
   u8 rate_check_down ;
   u8 rate_retry_policy[13U] ;
};

#line 1327  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_hangover_settings {
   u32 recover_time ;
   u8 hangover_period ;
   u8 dynamic_mode ;
   u8 early_termination_mode ;
   u8 max_period ;
   u8 min_period ;
   u8 increase_delta ;
   u8 decrease_delta ;
   u8 quiet_time ;
   u8 increase_time ;
   u8 window_size ;
};

#line 1341  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct conf_recovery_settings {
   u8 bug_on_recovery ;
   u8 no_recovery ;
};

#line 1365  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct wlcore_conf {
   struct conf_sg_settings sg ;
   struct conf_rx_settings rx ;
   struct conf_tx_settings tx ;
   struct conf_conn_settings conn ;
   struct conf_itrim_settings itrim ;
   struct conf_pm_config_settings pm_config ;
   struct conf_roam_trigger_settings roam_trigger ;
   struct conf_scan_settings scan ;
   struct conf_sched_scan_settings sched_scan ;
   struct conf_ht_setting ht ;
   struct conf_memory_settings mem ;
   struct conf_fm_coex fm_coex ;
   struct conf_rx_streaming_settings rx_streaming ;
   struct conf_fwlog fwlog ;
   struct conf_rate_policy_settings rate ;
   struct conf_hangover_settings hangover ;
   struct conf_recovery_settings recovery ;
};

#line 232  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/ini.h"
enum wlcore_state {
    WLCORE_STATE_OFF = 0,
    WLCORE_STATE_RESTARTING = 1,
    WLCORE_STATE_ON = 2
};

#line 238 
enum wl12xx_fw_type {
    WL12XX_FW_TYPE_NONE = 0,
    WL12XX_FW_TYPE_NORMAL = 1,
    WL12XX_FW_TYPE_MULTI = 2,
    WL12XX_FW_TYPE_PLT = 3
};

#line 245 
struct wl1271;

#line 255  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/ini.h"
struct wl1271_chip {
   u32 id ;
   char fw_ver_str[32U] ;
   unsigned int fw_ver[5U] ;
   char phy_fw_ver_str[32U] ;
};

#line 126  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore_i.h"
struct __anonstruct_counters_373 {
   u8 *tx_released_pkts ;
   u8 *tx_lnk_free_pkts ;
   u8 tx_voice_released_blks ;
   u8 tx_last_rate ;
};

#line 126  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore_i.h"
struct wl_fw_status {
   u32 intr ;
   u8 fw_rx_counter ;
   u8 drv_rx_counter ;
   u8 tx_results_counter ;
   __le32 *rx_pkt_descs ;
   u32 fw_localtime ;
   u32 link_ps_bitmap ;
   u32 link_fast_bitmap ;
   u32 total_released_blks ;
   u32 tx_total ;
   struct __anonstruct_counters_373 counters ;
   u32 log_start_addr ;
   void *priv ;
};

#line 181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore_i.h"
struct wl1271_scan {
   struct cfg80211_scan_request *req ;
   unsigned long scanned_ch[1U] ;
   bool failed ;
   u8 state ;
   u8 ssid[33U] ;
   size_t ssid_len ;
};

#line 191  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore_i.h"
struct wl1271_if_operations {
   int (*read)(struct device *, int , void *, size_t , bool ) ;
   int (*write)(struct device *, int , void *, size_t , bool ) ;
   void (*reset)(struct device *) ;
   void (*init)(struct device *) ;
   int (*power)(struct device *, bool ) ;
   void (*set_block_size)(struct device *, unsigned int ) ;
};

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore_i.h"
struct wl1271_ap_key {
   u8 id ;
   u8 key_type ;
   u8 key_size ;
   u8 key[32U] ;
   u8 hlid ;
   u32 tx_seq_32 ;
   u16 tx_seq_16 ;
};

#line 260 
struct wl12xx_vif;

#line 261  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore_i.h"
struct wl1271_link {
   struct sk_buff_head tx_queue[4U] ;
   u8 allocated_pkts ;
   u8 prev_freed_pkts ;
   u8 addr[6U] ;
   u8 ba_bitmap ;
   struct wl12xx_vif *wlvif ;
   u64 total_freed_pkts ;
};

#line 292 
enum plt_mode {
    PLT_OFF = 0,
    PLT_ON = 1,
    PLT_FEM_DETECT = 2,
    PLT_CHIP_AWAKE = 3
};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore_i.h"
struct __anonstruct_sta_375 {
   u8 hlid ;
   u8 basic_rate_idx ;
   u8 ap_rate_idx ;
   u8 p2p_rate_idx ;
   u8 klv_template_id ;
   bool qos ;
   enum nl80211_channel_type role_chan_type ;
};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore_i.h"
struct __anonstruct_ap_376 {
   u8 global_hlid ;
   u8 bcast_hlid ;
   unsigned long sta_hlid_map[1U] ;
   struct wl1271_ap_key *recorded_keys[14U] ;
   u8 mgmt_rate_idx ;
   u8 bcast_rate_idx ;
   u8 ucast_rate_idx[4U] ;
};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore_i.h"
union __anonunion_374 {
   struct __anonstruct_sta_375 sta ;
   struct __anonstruct_ap_376 ap ;
};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore_i.h"
struct __anonstruct_377 {
   u8 persistent[0U] ;
};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore_i.h"
struct wl12xx_vif {
   struct wl1271 *wl ;
   struct list_head list ;
   unsigned long flags ;
   u8 bss_type ;
   u8 p2p ;
   u8 role_id ;
   u8 dev_role_id ;
   u8 dev_hlid ;
   union __anonunion_374 __anonCompField_wl12xx_vif_100 ;
   int last_tx_hlid ;
   int tx_queue_count[4U] ;
   unsigned long links_map[1U] ;
   u8 ssid[33U] ;
   u8 ssid_len ;
   enum ieee80211_band band ;
   int channel ;
   enum nl80211_channel_type channel_type ;
   u32 bitrate_masks[2U] ;
   u32 basic_rate_set ;
   u32 basic_rate ;
   u32 rate_set ;
   struct sk_buff *probereq ;
   u32 beacon_int ;
   u32 default_key ;
   u16 aid ;
   u8 psm_entry_retry ;
   int power_level ;
   int rssi_thold ;
   int last_rssi_event ;
   u8 encryption_type ;
   __be32 ip_addr ;
   bool ba_support ;
   bool ba_allowed ;
   bool wmm_enabled ;
   bool radar_enabled ;
   struct work_struct rx_streaming_enable_work ;
   struct work_struct rx_streaming_disable_work ;
   struct timer_list rx_streaming_timer ;
   struct delayed_work channel_switch_work ;
   struct delayed_work connection_loss_work ;
   int inconn_count ;
   int hw_queue_base ;
   bool ap_pending_auth_reply ;
   unsigned long pending_auth_reply_time ;
   struct delayed_work pending_auth_complete_work ;
   enum ieee80211_sta_rx_bandwidth rc_update_bw ;
   struct work_struct rc_update_work ;
   u64 total_freed_pkts ;
   struct __anonstruct_377 __anonCompField_wl12xx_vif_101 ;
};

#line 546 
enum wlcore_wait_event {
    WLCORE_EVENT_ROLE_STOP_COMPLETE = 0,
    WLCORE_EVENT_PEER_REMOVE_COMPLETE = 1,
    WLCORE_EVENT_DFS_CONFIG_COMPLETE = 2
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/boot.h"
struct wl1271_static_data {
   u8 mac_address[6U] ;
   u8 padding[2U] ;
   u8 fw_version[20U] ;
   u32 hw_version ;
   u8 tx_power_table[8U][4U] ;
   u8 priv[0U] ;
};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/boot.h"
struct wlcore_ops {
   int (*setup)(struct wl1271 *) ;
   int (*identify_chip)(struct wl1271 *) ;
   int (*identify_fw)(struct wl1271 *) ;
   int (*boot)(struct wl1271 *) ;
   int (*plt_init)(struct wl1271 *) ;
   int (*trigger_cmd)(struct wl1271 *, int , void *, size_t ) ;
   int (*ack_event)(struct wl1271 *) ;
   int (*wait_for_event)(struct wl1271 *, enum wlcore_wait_event , bool *) ;
   int (*process_mailbox_events)(struct wl1271 *) ;
   u32 (*calc_tx_blocks)(struct wl1271 *, u32 , u32 ) ;
   void (*set_tx_desc_blocks)(struct wl1271 *, struct wl1271_tx_hw_descr *, u32 , u32 ) ;
   void (*set_tx_desc_data_len)(struct wl1271 *, struct wl1271_tx_hw_descr *, struct sk_buff *) ;
   int (*get_rx_buf_align)(struct wl1271 *, u32 ) ;
   int (*prepare_read)(struct wl1271 *, u32 , u32 ) ;
   u32 (*get_rx_packet_len)(struct wl1271 *, void *, u32 ) ;
   int (*tx_delayed_compl)(struct wl1271 *) ;
   void (*tx_immediate_compl)(struct wl1271 *) ;
   int (*hw_init)(struct wl1271 *) ;
   int (*init_vif)(struct wl1271 *, struct wl12xx_vif *) ;
   void (*convert_fw_status)(struct wl1271 *, void *, struct wl_fw_status *) ;
   u32 (*sta_get_ap_rate_mask)(struct wl1271 *, struct wl12xx_vif *) ;
   int (*get_pg_ver)(struct wl1271 *, s8 *) ;
   int (*get_mac)(struct wl1271 *) ;
   void (*set_tx_desc_csum)(struct wl1271 *, struct wl1271_tx_hw_descr *, struct sk_buff *) ;
   void (*set_rx_csum)(struct wl1271 *, struct wl1271_rx_descriptor *, struct sk_buff *) ;
   u32 (*ap_get_mimo_wide_rate_mask)(struct wl1271 *, struct wl12xx_vif *) ;
   int (*debugfs_init)(struct wl1271 *, struct dentry *) ;
   int (*handle_static_data)(struct wl1271 *, struct wl1271_static_data *) ;
   int (*scan_start)(struct wl1271 *, struct wl12xx_vif *, struct cfg80211_scan_request *) ;
   int (*scan_stop)(struct wl1271 *, struct wl12xx_vif *) ;
   int (*sched_scan_start)(struct wl1271 *, struct wl12xx_vif *, struct cfg80211_sched_scan_request *, struct ieee80211_scan_ies *) ;
   void (*sched_scan_stop)(struct wl1271 *, struct wl12xx_vif *) ;
   int (*get_spare_blocks)(struct wl1271 *, bool ) ;
   int (*set_key)(struct wl1271 *, enum set_key_cmd , struct ieee80211_vif *, struct ieee80211_sta *, struct ieee80211_key_conf *) ;
   int (*channel_switch)(struct wl1271 *, struct wl12xx_vif *, struct ieee80211_channel_switch *) ;
   u32 (*pre_pkt_send)(struct wl1271 *, u32 , u32 ) ;
   void (*sta_rc_update)(struct wl1271 *, struct wl12xx_vif *) ;
   int (*set_peer_cap)(struct wl1271 *, struct ieee80211_sta_ht_cap *, bool , u32 , u8 ) ;
   u32 (*convert_hwaddr)(struct wl1271 *, u32 ) ;
   bool (*lnk_high_prio)(struct wl1271 *, u8 , struct wl1271_link *) ;
   bool (*lnk_low_prio)(struct wl1271 *, u8 , struct wl1271_link *) ;
   int (*interrupt_notify)(struct wl1271 *, bool ) ;
   int (*rx_ba_filter)(struct wl1271 *, bool ) ;
   int (*ap_sleep)(struct wl1271 *) ;
   int (*smart_config_start)(struct wl1271 *, u32 ) ;
   int (*smart_config_stop)(struct wl1271 *) ;
   int (*smart_config_set_group_key)(struct wl1271 *, u16 , u8 , u8 *) ;
   int (*set_cac)(struct wl1271 *, struct wl12xx_vif *, bool ) ;
   int (*dfs_master_restart)(struct wl1271 *, struct wl12xx_vif *) ;
};

#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore.h"
struct wlcore_partition {
   u32 size ;
   u32 start ;
};

#line 146  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore.h"
struct wlcore_partition_set {
   struct wlcore_partition mem ;
   struct wlcore_partition reg ;
   struct wlcore_partition mem2 ;
   struct wlcore_partition mem3 ;
};

#line 170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore.h"
struct wl1271_stats {
   void *fw_stats ;
   unsigned long fw_stats_update ;
   size_t fw_stats_len ;
   unsigned int retry_count ;
   unsigned int excessive_retries ;
};

#line 185 
struct wl1271_acx_mem_map;

#line 185  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore.h"
struct wl1271 {
   bool initialized ;
   struct ieee80211_hw *hw ;
   bool mac80211_registered ;
   struct device *dev ;
   struct platform_device *pdev ;
   void *if_priv ;
   struct wl1271_if_operations *if_ops ;
   int irq ;
   int irq_flags ;
   spinlock_t wl_lock ;
   enum wlcore_state state ;
   enum wl12xx_fw_type fw_type ;
   bool plt ;
   enum plt_mode plt_mode ;
   u8 fem_manuf ;
   u8 last_vif_count ;
   struct mutex mutex ;
   unsigned long flags ;
   struct wlcore_partition_set curr_part ;
   struct wl1271_chip chip ;
   int cmd_box_addr ;
   u8 *fw ;
   size_t fw_len ;
   void *nvs ;
   size_t nvs_len ;
   s8 hw_pg_ver ;
   u32 fuse_oui_addr ;
   u32 fuse_nic_addr ;
   struct mac_address addresses[3U] ;
   int channel ;
   u8 system_hlid ;
   unsigned long links_map[1U] ;
   unsigned long roles_map[1U] ;
   unsigned long roc_map[1U] ;
   unsigned long rate_policies_map[1U] ;
   unsigned long klv_templates_map[1U] ;
   u8 session_ids[16U] ;
   struct list_head wlvif_list ;
   u8 sta_count ;
   u8 ap_count ;
   struct wl1271_acx_mem_map *target_mem_map ;
   u32 tx_blocks_freed ;
   u32 tx_blocks_available ;
   u32 tx_allocated_blocks ;
   u32 tx_results_count ;
   u32 tx_pkts_freed[4U] ;
   u32 tx_allocated_pkts[4U] ;
   u32 tx_packets_count ;
   s64 time_offset ;
   int tx_queue_count[4U] ;
   unsigned long queue_stop_reasons[12U] ;
   struct sk_buff_head deferred_rx_queue ;
   struct sk_buff_head deferred_tx_queue ;
   struct work_struct tx_work ;
   struct workqueue_struct *freezable_wq ;
   unsigned long tx_frames_map[1U] ;
   struct sk_buff *tx_frames[32U] ;
   int tx_frames_cnt ;
   u32 rx_counter ;
   u8 *aggr_buf ;
   u32 aggr_buf_size ;
   struct sk_buff *dummy_packet ;
   struct work_struct netstack_work ;
   u8 *fwlog ;
   ssize_t fwlog_size ;
   u32 fwlog_end ;
   u32 fw_mem_block_size ;
   wait_queue_head_t fwlog_waitq ;
   struct work_struct recovery_work ;
   bool watchdog_recovery ;
   u32 reg_ch_conf_last[2U] ;
   u32 reg_ch_conf_pending[2U] ;
   void *mbox ;
   u32 event_mask ;
   u32 ap_event_mask ;
   u32 mbox_size ;
   u32 mbox_ptr[2U] ;
   struct wl12xx_vif *scan_wlvif ;
   struct wl1271_scan scan ;
   struct delayed_work scan_complete_work ;
   struct ieee80211_vif *roc_vif ;
   struct delayed_work roc_complete_work ;
   struct wl12xx_vif *sched_vif ;
   enum ieee80211_band band ;
   struct completion *elp_compl ;
   struct delayed_work elp_work ;
   int power_level ;
   struct wl1271_stats stats ;
   __le32 *buffer_32 ;
   u32 buffer_cmd ;
   u32 buffer_busyword[1U] ;
   void *raw_fw_status ;
   struct wl_fw_status *fw_status ;
   struct wl1271_tx_hw_res_if *tx_res_if ;
   struct wlcore_conf conf ;
   bool sg_enabled ;
   bool enable_11a ;
   int recovery_count ;
   s8 noise ;
   struct ieee80211_supported_band bands[2U] ;
   bool wow_enabled ;
   bool irq_wake_enabled ;
   struct wl1271_link links[16U] ;
   int active_link_count ;
   unsigned long fw_fast_lnk_map ;
   unsigned long ap_fw_ps_map ;
   unsigned long ap_ps_map ;
   unsigned int quirks ;
   int ba_rx_session_count ;
   int ba_rx_session_count_max ;
   int active_sta_count ;
   bool ofdm_only_ap ;
   struct wl12xx_vif *last_wlvif ;
   struct delayed_work tx_watchdog_work ;
   struct wlcore_ops *ops ;
   struct wlcore_partition_set const *ptable ;
   int const *rtable ;
   char const *plt_fw_name ;
   char const *sr_fw_name ;
   char const *mr_fw_name ;
   u8 scan_templ_id_2_4 ;
   u8 scan_templ_id_5 ;
   u8 sched_scan_templ_id_2_4 ;
   u8 sched_scan_templ_id_5 ;
   u8 max_channels_5 ;
   void *priv ;
   u32 num_tx_desc ;
   u32 num_rx_desc ;
   u8 num_links ;
   u8 max_ap_stations ;
   u8 const **band_rate_to_idx ;
   u8 hw_tx_rate_tbl_size ;
   u8 hw_min_ht_rate ;
   struct ieee80211_sta_ht_cap ht_cap[2U] ;
   enum nl80211_dfs_regions dfs_region ;
   size_t fw_status_len ;
   size_t fw_status_priv_len ;
   unsigned long rx_filter_enabled[1U] ;
   size_t static_data_priv_len ;
   enum nl80211_channel_type channel_type ;
   struct mutex flush_mutex ;
   int sleep_auth ;
   int num_mac_addr ;
   unsigned int min_sr_fw_ver[5U] ;
   unsigned int min_mr_fw_ver[5U] ;
   struct completion nvs_loading_complete ;
   struct ieee80211_iface_combination const *iface_combinations ;
   u8 n_iface_combinations ;
};

#line 547 
struct acx_header;

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/cmd.h"
struct wl1271_cmd_header {
   __le16 id ;
   __le16 status ;
   u8 data[0U] ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/debug.h"
struct acx_header {
   struct wl1271_cmd_header cmd ;
   __le16 id ;
   __le16 len ;
};

#line 486  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/acx.h"
struct wl1271_acx_mem_map {
   struct acx_header header ;
   __le32 code_start ;
   __le32 code_end ;
   __le32 wep_defkey_start ;
   __le32 wep_defkey_end ;
   __le32 sta_table_start ;
   __le32 sta_table_end ;
   __le32 packet_template_start ;
   __le32 packet_template_end ;
   __le32 tx_result ;
   __le32 tx_result_queue_start ;
   __le32 queue_memory_start ;
   __le32 queue_memory_end ;
   __le32 packet_memory_pool_start ;
   __le32 packet_memory_pool_end ;
   __le32 debug_buffer1_start ;
   __le32 debug_buffer1_end ;
   __le32 debug_buffer2_start ;
   __le32 debug_buffer2_end ;
   __le32 num_tx_mem_blocks ;
   __le32 num_rx_mem_blocks ;
   u8 *tx_cbuf ;
   u8 *rx_cbuf ;
   __le32 rx_ctrl ;
   __le32 tx_ctrl ;
};

#line 1147  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/acx.h"
struct wl18xx_acx_host_config_bitmap {
   struct acx_header header ;
   __le32 host_cfg_bitmap ;
   __le32 host_sdio_block_size ;
   __le32 extra_mem_blocks ;
   __le32 length_field_size ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.h"
struct wl18xx_acx_checksum_state {
   struct acx_header header ;
   u8 checksum_state ;
   u8 pad[3U] ;
};

#line 285  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.h"
struct wl18xx_acx_clear_statistics {
   struct acx_header header ;
};

#line 294  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.h"
struct wlcore_peer_ht_operation_mode {
   struct acx_header header ;
   u8 hlid ;
   u8 bandwidth ;
   u8 padding[2U] ;
};

#line 302  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.h"
struct wlcore_acx_peer_cap {
   struct acx_header header ;
   __le32 ht_capabilites ;
   __le32 supported_rates ;
   u8 hlid ;
   u8 ampdu_max_length ;
   u8 ampdu_min_spacing ;
   u8 padding ;
};

#line 331  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.h"
struct wl18xx_acx_interrupt_notify {
   struct acx_header header ;
   u32 enable ;
};

#line 340  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.h"
struct wl18xx_acx_rx_ba_filter {
   struct acx_header header ;
   u32 enable ;
};

#line 349  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.h"
struct acx_ap_sleep_cfg {
   struct acx_header header ;
   u8 idle_duty_cycle ;
   u8 connected_duty_cycle ;
   u8 max_stations_thresh ;
   u8 idle_conn_thresh ;
};

#line 383  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.h"
struct wl18xx_mac_and_phy_params {
   u8 phy_standalone ;
   u8 spare0 ;
   u8 enable_clpc ;
   u8 enable_tx_low_pwr_on_siso_rdl ;
   u8 auto_detect ;
   u8 dedicated_fem ;
   u8 low_band_component ;
   u8 low_band_component_type ;
   u8 high_band_component ;
   u8 high_band_component_type ;
   u8 number_of_assembled_ant2_4 ;
   u8 number_of_assembled_ant5 ;
   u8 pin_muxing_platform_options[2U] ;
   u8 external_pa_dc2dc ;
   u8 tcxo_ldo_voltage ;
   u8 xtal_itrim_val ;
   u8 srf_state ;
   u8 srf1[16U] ;
   u8 srf2[16U] ;
   u8 srf3[16U] ;
   u8 io_configuration ;
   u8 sdio_configuration ;
   u8 settings ;
   u8 rx_profile ;
   u8 per_chan_pwr_limit_arr_11abg[150U] ;
   u8 pwr_limit_reference_11_abg ;
   u8 per_chan_pwr_limit_arr_11p[7U] ;
   u8 pwr_limit_reference_11p ;
   u8 spare1 ;
   u8 per_chan_bo_mode_11_abg[13U] ;
   u8 per_chan_bo_mode_11_p[4U] ;
   u8 primary_clock_setting_time ;
   u8 clock_valid_on_wake_up ;
   u8 secondary_clock_setting_time ;
   u8 board_type ;
   u8 psat ;
   s8 low_power_val ;
   s8 med_power_val ;
   s8 high_power_val ;
   s8 per_sub_band_tx_trace_loss[10U] ;
   s8 per_sub_band_rx_trace_loss[18U] ;
   u8 tx_rf_margin ;
   s8 low_power_val_2nd ;
   s8 med_power_val_2nd ;
   s8 high_power_val_2nd ;
   u8 padding[1U] ;
};

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/conf.h"
struct wl18xx_ht_settings {
   u8 mode ;
};

#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/conf.h"
struct conf_ap_sleep_settings {
   u8 idle_duty_cycle ;
   u8 connected_duty_cycle ;
   u8 max_stations_thresh ;
   u8 idle_conn_thresh ;
};

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/conf.h"
struct wl18xx_priv_conf {
   struct wl18xx_ht_settings ht ;
   struct wl18xx_mac_and_phy_params phy ;
   struct conf_ap_sleep_settings ap_sleep ;
};

#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/conf.h"
struct wl18xx_priv {
   u8 cmd_buf[740U] ;
   struct wl18xx_priv_conf conf ;
   u8 last_fw_rls_idx ;
   int extra_spare_key_count ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/debug.h"
struct wl1271_rx_descriptor {
   __le16 length ;
   u8 status ;
   u8 flags ;
   u8 rate ;
   u8 channel ;
   s8 rssi ;
   u8 snr ;
   __le32 timestamp ;
   u8 packet_class ;
   u8 hlid ;
   u8 pad_len ;
   u8 reserved ;
};

#line 1134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/acx.h"
struct wl18xx_cmd_channel_switch {
   struct wl1271_cmd_header header ;
   u8 role_id ;
   u8 channel ;
   u8 switch_time ;
   u8 stop_tx ;
   __le32 local_supported_rates ;
   u8 channel_type ;
   u8 band ;
   u8 padding[2U] ;
};

#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/cmd.h"
struct wl18xx_cmd_smart_config_start {
   struct wl1271_cmd_header header ;
   __le32 group_id_bitmask ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/cmd.h"
struct wl18xx_cmd_smart_config_set_group_key {
   struct wl1271_cmd_header header ;
   __le32 group_id ;
   u8 key[16U] ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/cmd.h"
struct wl18xx_cmd_dfs_radar_debug {
   struct wl1271_cmd_header header ;
   u8 channel ;
   u8 padding[3U] ;
};

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/cmd.h"
struct wl18xx_cmd_dfs_master_restart {
   struct wl1271_cmd_header header ;
   u8 role_id ;
   u8 padding[3U] ;
};

#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/cmd.h"
struct wlcore_cmd_cac_start {
   struct wl1271_cmd_header header ;
   u8 role_id ;
   u8 channel ;
   u8 band ;
   u8 bandwidth ;
};

#line 598  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_tx_rate {
   s8 idx ;
   u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(5))) count : 5 ;
   u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(11))) flags : 11 ;
};

#line 819  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct __anonstruct_1497 {
   struct ieee80211_tx_rate rates[4U] ;
   s8 rts_cts_rate_idx ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) use_rts : 1 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) use_cts_prot : 1 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) short_preamble : 1 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) skip_table : 1 ;
};

#line 819  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
union __anonunion_1496 {
   struct __anonstruct_1497 __anonCompField___anonunion_1496_95 ;
   unsigned long jiffies ;
};

#line 819  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct __anonstruct_control_1495 {
   union __anonunion_1496 __anonCompField___anonstruct_control_1495_96 ;
   struct ieee80211_vif *vif ;
   struct ieee80211_key_conf *hw_key ;
   u32 flags ;
};

#line 819  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct __anonstruct_ack_1498 {
   u64 cookie ;
};

#line 819  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct __anonstruct_status_1499 {
   struct ieee80211_tx_rate rates[4U] ;
   s32 ack_signal ;
   u8 ampdu_ack_len ;
   u8 ampdu_len ;
   u8 antenna ;
   u16 tx_time ;
   void *status_driver_data[2U] ;
};

#line 819  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct __anonstruct_1500 {
   struct ieee80211_tx_rate driver_rates[4U] ;
   u8 pad[4U] ;
   void *rate_driver_data[3U] ;
};

#line 819  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
union __anonunion_1494 {
   struct __anonstruct_control_1495 control ;
   struct __anonstruct_ack_1498 ack ;
   struct __anonstruct_status_1499 status ;
   struct __anonstruct_1500 __anonCompField___anonunion_1494_97 ;
   void *driver_data[5U] ;
};

#line 819  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_tx_info {
   u32 flags ;
   u8 band ;
   u8 hw_queue ;
   u16 ack_frame_id ;
   union __anonunion_1494 __anonCompField_ieee80211_tx_info_98 ;
};

#line 1134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/acx.h"
struct wl127x_tx_mem {
   u8 extra_blocks ;
   u8 total_mem_blocks ;
};

#line 77  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/tx.h"
struct wl128x_tx_mem {
   u8 total_mem_blocks ;
   u8 extra_bytes ;
};

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/tx.h"
struct wl18xx_tx_mem {
   u8 total_mem_blocks ;
   u8 ctrl ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/tx.h"
union __anonunion_1524 {
   struct wl127x_tx_mem wl127x_mem ;
   struct wl128x_tx_mem wl128x_mem ;
   struct wl18xx_tx_mem wl18xx_mem ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/tx.h"
union __anonunion_1525 {
   u8 wl12xx_reserved ;
   u8 wl18xx_checksum_data ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/tx.h"
struct wl1271_tx_hw_descr {
   __le16 length ;
   union __anonunion_1524 __anonCompField_wl1271_tx_hw_descr_103 ;
   __le32 start_time ;
   __le16 life_time ;
   __le16 tx_attr ;
   u8 id ;
   u8 tid ;
   u8 hlid ;
   union __anonunion_1525 __anonCompField_wl1271_tx_hw_descr_104 ;
};

#line 160  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/tx.h"
struct wl1271_tx_hw_res_descr {
   u8 id ;
   u8 status ;
   __le16 medium_usage ;
   __le32 fw_handling_time ;
   __le32 medium_delay ;
   u8 tx_security_sequence_number_lsb ;
   u8 ack_failures ;
   u8 rate_class_index ;
   u8 spare ;
};

#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/tx.h"
struct wl1271_tx_hw_res_if {
   __le32 tx_result_fw_counter ;
   __le32 tx_result_host_counter ;
   struct wl1271_tx_hw_res_descr tx_results_queue[16U] ;
};

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/wl18xx.h"
struct wl18xx_fw_status_priv {
   u8 fw_release_idx ;
   u8 released_tx_desc[33U] ;
   __le32 link_suspend_bitmap ;
   u8 tx_ac_threshold ;
   u8 tx_ps_threshold ;
   u8 tx_suspend_threshold ;
   u8 tx_slow_link_prio_threshold ;
   u8 tx_fast_link_prio_threshold ;
   u8 tx_slow_stop_threshold ;
   u8 tx_fast_stop_threshold ;
   u8 padding[3U] ;
};

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debugfs.h"
enum nl80211_commands {
    NL80211_CMD_UNSPEC = 0,
    NL80211_CMD_GET_WIPHY = 1,
    NL80211_CMD_SET_WIPHY = 2,
    NL80211_CMD_NEW_WIPHY = 3,
    NL80211_CMD_DEL_WIPHY = 4,
    NL80211_CMD_GET_INTERFACE = 5,
    NL80211_CMD_SET_INTERFACE = 6,
    NL80211_CMD_NEW_INTERFACE = 7,
    NL80211_CMD_DEL_INTERFACE = 8,
    NL80211_CMD_GET_KEY = 9,
    NL80211_CMD_SET_KEY = 10,
    NL80211_CMD_NEW_KEY = 11,
    NL80211_CMD_DEL_KEY = 12,
    NL80211_CMD_GET_BEACON = 13,
    NL80211_CMD_SET_BEACON = 14,
    NL80211_CMD_START_AP = 15,
    NL80211_CMD_NEW_BEACON = 15,
    NL80211_CMD_STOP_AP = 16,
    NL80211_CMD_DEL_BEACON = 16,
    NL80211_CMD_GET_STATION = 17,
    NL80211_CMD_SET_STATION = 18,
    NL80211_CMD_NEW_STATION = 19,
    NL80211_CMD_DEL_STATION = 20,
    NL80211_CMD_GET_MPATH = 21,
    NL80211_CMD_SET_MPATH = 22,
    NL80211_CMD_NEW_MPATH = 23,
    NL80211_CMD_DEL_MPATH = 24,
    NL80211_CMD_SET_BSS = 25,
    NL80211_CMD_SET_REG = 26,
    NL80211_CMD_REQ_SET_REG = 27,
    NL80211_CMD_GET_MESH_CONFIG = 28,
    NL80211_CMD_SET_MESH_CONFIG = 29,
    NL80211_CMD_SET_MGMT_EXTRA_IE = 30,
    NL80211_CMD_GET_REG = 31,
    NL80211_CMD_GET_SCAN = 32,
    NL80211_CMD_TRIGGER_SCAN = 33,
    NL80211_CMD_NEW_SCAN_RESULTS = 34,
    NL80211_CMD_SCAN_ABORTED = 35,
    NL80211_CMD_REG_CHANGE = 36,
    NL80211_CMD_AUTHENTICATE = 37,
    NL80211_CMD_ASSOCIATE = 38,
    NL80211_CMD_DEAUTHENTICATE = 39,
    NL80211_CMD_DISASSOCIATE = 40,
    NL80211_CMD_MICHAEL_MIC_FAILURE = 41,
    NL80211_CMD_REG_BEACON_HINT = 42,
    NL80211_CMD_JOIN_IBSS = 43,
    NL80211_CMD_LEAVE_IBSS = 44,
    NL80211_CMD_TESTMODE = 45,
    NL80211_CMD_CONNECT = 46,
    NL80211_CMD_ROAM = 47,
    NL80211_CMD_DISCONNECT = 48,
    NL80211_CMD_SET_WIPHY_NETNS = 49,
    NL80211_CMD_GET_SURVEY = 50,
    NL80211_CMD_NEW_SURVEY_RESULTS = 51,
    NL80211_CMD_SET_PMKSA = 52,
    NL80211_CMD_DEL_PMKSA = 53,
    NL80211_CMD_FLUSH_PMKSA = 54,
    NL80211_CMD_REMAIN_ON_CHANNEL = 55,
    NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL = 56,
    NL80211_CMD_SET_TX_BITRATE_MASK = 57,
    NL80211_CMD_REGISTER_FRAME = 58,
    NL80211_CMD_REGISTER_ACTION = 58,
    NL80211_CMD_FRAME = 59,
    NL80211_CMD_ACTION = 59,
    NL80211_CMD_FRAME_TX_STATUS = 60,
    NL80211_CMD_ACTION_TX_STATUS = 60,
    NL80211_CMD_SET_POWER_SAVE = 61,
    NL80211_CMD_GET_POWER_SAVE = 62,
    NL80211_CMD_SET_CQM = 63,
    NL80211_CMD_NOTIFY_CQM = 64,
    NL80211_CMD_SET_CHANNEL = 65,
    NL80211_CMD_SET_WDS_PEER = 66,
    NL80211_CMD_FRAME_WAIT_CANCEL = 67,
    NL80211_CMD_JOIN_MESH = 68,
    NL80211_CMD_LEAVE_MESH = 69,
    NL80211_CMD_UNPROT_DEAUTHENTICATE = 70,
    NL80211_CMD_UNPROT_DISASSOCIATE = 71,
    NL80211_CMD_NEW_PEER_CANDIDATE = 72,
    NL80211_CMD_GET_WOWLAN = 73,
    NL80211_CMD_SET_WOWLAN = 74,
    NL80211_CMD_START_SCHED_SCAN = 75,
    NL80211_CMD_STOP_SCHED_SCAN = 76,
    NL80211_CMD_SCHED_SCAN_RESULTS = 77,
    NL80211_CMD_SCHED_SCAN_STOPPED = 78,
    NL80211_CMD_SET_REKEY_OFFLOAD = 79,
    NL80211_CMD_PMKSA_CANDIDATE = 80,
    NL80211_CMD_TDLS_OPER = 81,
    NL80211_CMD_TDLS_MGMT = 82,
    NL80211_CMD_UNEXPECTED_FRAME = 83,
    NL80211_CMD_PROBE_CLIENT = 84,
    NL80211_CMD_REGISTER_BEACONS = 85,
    NL80211_CMD_UNEXPECTED_4ADDR_FRAME = 86,
    NL80211_CMD_SET_NOACK_MAP = 87,
    NL80211_CMD_CH_SWITCH_NOTIFY = 88,
    NL80211_CMD_START_P2P_DEVICE = 89,
    NL80211_CMD_STOP_P2P_DEVICE = 90,
    NL80211_CMD_CONN_FAILED = 91,
    NL80211_CMD_SET_MCAST_RATE = 92,
    NL80211_CMD_SET_MAC_ACL = 93,
    NL80211_CMD_RADAR_DETECT = 94,
    NL80211_CMD_GET_PROTOCOL_FEATURES = 95,
    NL80211_CMD_UPDATE_FT_IES = 96,
    NL80211_CMD_FT_EVENT = 97,
    NL80211_CMD_CRIT_PROTOCOL_START = 98,
    NL80211_CMD_CRIT_PROTOCOL_STOP = 99,
    NL80211_CMD_GET_COALESCE = 100,
    NL80211_CMD_SET_COALESCE = 101,
    NL80211_CMD_CHANNEL_SWITCH = 102,
    NL80211_CMD_VENDOR = 103,
    NL80211_CMD_SET_QOS_MAP = 104,
    NL80211_CMD_ADD_TX_TS = 105,
    NL80211_CMD_DEL_TX_TS = 106,
    NL80211_CMD_GET_MPP = 107,
    NL80211_CMD_JOIN_OCB = 108,
    NL80211_CMD_LEAVE_OCB = 109,
    NL80211_CMD_CH_SWITCH_STARTED_NOTIFY = 110,
    NL80211_CMD_TDLS_CHANNEL_SWITCH = 111,
    NL80211_CMD_TDLS_CANCEL_CHANNEL_SWITCH = 112,
    NL80211_CMD_WIPHY_REG_CHANGE = 113,
    __NL80211_CMD_AFTER_LAST = 114,
    NL80211_CMD_MAX = 113
};

#line 242 
enum nl80211_attrs {
    NL80211_ATTR_UNSPEC = 0,
    NL80211_ATTR_WIPHY = 1,
    NL80211_ATTR_WIPHY_NAME = 2,
    NL80211_ATTR_IFINDEX = 3,
    NL80211_ATTR_IFNAME = 4,
    NL80211_ATTR_IFTYPE = 5,
    NL80211_ATTR_MAC = 6,
    NL80211_ATTR_KEY_DATA = 7,
    NL80211_ATTR_KEY_IDX = 8,
    NL80211_ATTR_KEY_CIPHER = 9,
    NL80211_ATTR_KEY_SEQ = 10,
    NL80211_ATTR_KEY_DEFAULT = 11,
    NL80211_ATTR_BEACON_INTERVAL = 12,
    NL80211_ATTR_DTIM_PERIOD = 13,
    NL80211_ATTR_BEACON_HEAD = 14,
    NL80211_ATTR_BEACON_TAIL = 15,
    NL80211_ATTR_STA_AID = 16,
    NL80211_ATTR_STA_FLAGS = 17,
    NL80211_ATTR_STA_LISTEN_INTERVAL = 18,
    NL80211_ATTR_STA_SUPPORTED_RATES = 19,
    NL80211_ATTR_STA_VLAN = 20,
    NL80211_ATTR_STA_INFO = 21,
    NL80211_ATTR_WIPHY_BANDS = 22,
    NL80211_ATTR_MNTR_FLAGS = 23,
    NL80211_ATTR_MESH_ID = 24,
    NL80211_ATTR_STA_PLINK_ACTION = 25,
    NL80211_ATTR_MPATH_NEXT_HOP = 26,
    NL80211_ATTR_MPATH_INFO = 27,
    NL80211_ATTR_BSS_CTS_PROT = 28,
    NL80211_ATTR_BSS_SHORT_PREAMBLE = 29,
    NL80211_ATTR_BSS_SHORT_SLOT_TIME = 30,
    NL80211_ATTR_HT_CAPABILITY = 31,
    NL80211_ATTR_SUPPORTED_IFTYPES = 32,
    NL80211_ATTR_REG_ALPHA2 = 33,
    NL80211_ATTR_REG_RULES = 34,
    NL80211_ATTR_MESH_CONFIG = 35,
    NL80211_ATTR_BSS_BASIC_RATES = 36,
    NL80211_ATTR_WIPHY_TXQ_PARAMS = 37,
    NL80211_ATTR_WIPHY_FREQ = 38,
    NL80211_ATTR_WIPHY_CHANNEL_TYPE = 39,
    NL80211_ATTR_KEY_DEFAULT_MGMT = 40,
    NL80211_ATTR_MGMT_SUBTYPE = 41,
    NL80211_ATTR_IE = 42,
    NL80211_ATTR_MAX_NUM_SCAN_SSIDS = 43,
    NL80211_ATTR_SCAN_FREQUENCIES = 44,
    NL80211_ATTR_SCAN_SSIDS = 45,
    NL80211_ATTR_GENERATION = 46,
    NL80211_ATTR_BSS = 47,
    NL80211_ATTR_REG_INITIATOR = 48,
    NL80211_ATTR_REG_TYPE = 49,
    NL80211_ATTR_SUPPORTED_COMMANDS = 50,
    NL80211_ATTR_FRAME = 51,
    NL80211_ATTR_SSID = 52,
    NL80211_ATTR_AUTH_TYPE = 53,
    NL80211_ATTR_REASON_CODE = 54,
    NL80211_ATTR_KEY_TYPE = 55,
    NL80211_ATTR_MAX_SCAN_IE_LEN = 56,
    NL80211_ATTR_CIPHER_SUITES = 57,
    NL80211_ATTR_FREQ_BEFORE = 58,
    NL80211_ATTR_FREQ_AFTER = 59,
    NL80211_ATTR_FREQ_FIXED = 60,
    NL80211_ATTR_WIPHY_RETRY_SHORT = 61,
    NL80211_ATTR_WIPHY_RETRY_LONG = 62,
    NL80211_ATTR_WIPHY_FRAG_THRESHOLD = 63,
    NL80211_ATTR_WIPHY_RTS_THRESHOLD = 64,
    NL80211_ATTR_TIMED_OUT = 65,
    NL80211_ATTR_USE_MFP = 66,
    NL80211_ATTR_STA_FLAGS2 = 67,
    NL80211_ATTR_CONTROL_PORT = 68,
    NL80211_ATTR_TESTDATA = 69,
    NL80211_ATTR_PRIVACY = 70,
    NL80211_ATTR_DISCONNECTED_BY_AP = 71,
    NL80211_ATTR_STATUS_CODE = 72,
    NL80211_ATTR_CIPHER_SUITES_PAIRWISE = 73,
    NL80211_ATTR_CIPHER_SUITE_GROUP = 74,
    NL80211_ATTR_WPA_VERSIONS = 75,
    NL80211_ATTR_AKM_SUITES = 76,
    NL80211_ATTR_REQ_IE = 77,
    NL80211_ATTR_RESP_IE = 78,
    NL80211_ATTR_PREV_BSSID = 79,
    NL80211_ATTR_KEY = 80,
    NL80211_ATTR_KEYS = 81,
    NL80211_ATTR_PID = 82,
    NL80211_ATTR_4ADDR = 83,
    NL80211_ATTR_SURVEY_INFO = 84,
    NL80211_ATTR_PMKID = 85,
    NL80211_ATTR_MAX_NUM_PMKIDS = 86,
    NL80211_ATTR_DURATION = 87,
    NL80211_ATTR_COOKIE = 88,
    NL80211_ATTR_WIPHY_COVERAGE_CLASS = 89,
    NL80211_ATTR_TX_RATES = 90,
    NL80211_ATTR_FRAME_MATCH = 91,
    NL80211_ATTR_ACK = 92,
    NL80211_ATTR_PS_STATE = 93,
    NL80211_ATTR_CQM = 94,
    NL80211_ATTR_LOCAL_STATE_CHANGE = 95,
    NL80211_ATTR_AP_ISOLATE = 96,
    NL80211_ATTR_WIPHY_TX_POWER_SETTING = 97,
    NL80211_ATTR_WIPHY_TX_POWER_LEVEL = 98,
    NL80211_ATTR_TX_FRAME_TYPES = 99,
    NL80211_ATTR_RX_FRAME_TYPES = 100,
    NL80211_ATTR_FRAME_TYPE = 101,
    NL80211_ATTR_CONTROL_PORT_ETHERTYPE = 102,
    NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT = 103,
    NL80211_ATTR_SUPPORT_IBSS_RSN = 104,
    NL80211_ATTR_WIPHY_ANTENNA_TX = 105,
    NL80211_ATTR_WIPHY_ANTENNA_RX = 106,
    NL80211_ATTR_MCAST_RATE = 107,
    NL80211_ATTR_OFFCHANNEL_TX_OK = 108,
    NL80211_ATTR_BSS_HT_OPMODE = 109,
    NL80211_ATTR_KEY_DEFAULT_TYPES = 110,
    NL80211_ATTR_MAX_REMAIN_ON_CHANNEL_DURATION = 111,
    NL80211_ATTR_MESH_SETUP = 112,
    NL80211_ATTR_WIPHY_ANTENNA_AVAIL_TX = 113,
    NL80211_ATTR_WIPHY_ANTENNA_AVAIL_RX = 114,
    NL80211_ATTR_SUPPORT_MESH_AUTH = 115,
    NL80211_ATTR_STA_PLINK_STATE = 116,
    NL80211_ATTR_WOWLAN_TRIGGERS = 117,
    NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED = 118,
    NL80211_ATTR_SCHED_SCAN_INTERVAL = 119,
    NL80211_ATTR_INTERFACE_COMBINATIONS = 120,
    NL80211_ATTR_SOFTWARE_IFTYPES = 121,
    NL80211_ATTR_REKEY_DATA = 122,
    NL80211_ATTR_MAX_NUM_SCHED_SCAN_SSIDS = 123,
    NL80211_ATTR_MAX_SCHED_SCAN_IE_LEN = 124,
    NL80211_ATTR_SCAN_SUPP_RATES = 125,
    NL80211_ATTR_HIDDEN_SSID = 126,
    NL80211_ATTR_IE_PROBE_RESP = 127,
    NL80211_ATTR_IE_ASSOC_RESP = 128,
    NL80211_ATTR_STA_WME = 129,
    NL80211_ATTR_SUPPORT_AP_UAPSD = 130,
    NL80211_ATTR_ROAM_SUPPORT = 131,
    NL80211_ATTR_SCHED_SCAN_MATCH = 132,
    NL80211_ATTR_MAX_MATCH_SETS = 133,
    NL80211_ATTR_PMKSA_CANDIDATE = 134,
    NL80211_ATTR_TX_NO_CCK_RATE = 135,
    NL80211_ATTR_TDLS_ACTION = 136,
    NL80211_ATTR_TDLS_DIALOG_TOKEN = 137,
    NL80211_ATTR_TDLS_OPERATION = 138,
    NL80211_ATTR_TDLS_SUPPORT = 139,
    NL80211_ATTR_TDLS_EXTERNAL_SETUP = 140,
    NL80211_ATTR_DEVICE_AP_SME = 141,
    NL80211_ATTR_DONT_WAIT_FOR_ACK = 142,
    NL80211_ATTR_FEATURE_FLAGS = 143,
    NL80211_ATTR_PROBE_RESP_OFFLOAD = 144,
    NL80211_ATTR_PROBE_RESP = 145,
    NL80211_ATTR_DFS_REGION = 146,
    NL80211_ATTR_DISABLE_HT = 147,
    NL80211_ATTR_HT_CAPABILITY_MASK = 148,
    NL80211_ATTR_NOACK_MAP = 149,
    NL80211_ATTR_INACTIVITY_TIMEOUT = 150,
    NL80211_ATTR_RX_SIGNAL_DBM = 151,
    NL80211_ATTR_BG_SCAN_PERIOD = 152,
    NL80211_ATTR_WDEV = 153,
    NL80211_ATTR_USER_REG_HINT_TYPE = 154,
    NL80211_ATTR_CONN_FAILED_REASON = 155,
    NL80211_ATTR_SAE_DATA = 156,
    NL80211_ATTR_VHT_CAPABILITY = 157,
    NL80211_ATTR_SCAN_FLAGS = 158,
    NL80211_ATTR_CHANNEL_WIDTH = 159,
    NL80211_ATTR_CENTER_FREQ1 = 160,
    NL80211_ATTR_CENTER_FREQ2 = 161,
    NL80211_ATTR_P2P_CTWINDOW = 162,
    NL80211_ATTR_P2P_OPPPS = 163,
    NL80211_ATTR_LOCAL_MESH_POWER_MODE = 164,
    NL80211_ATTR_ACL_POLICY = 165,
    NL80211_ATTR_MAC_ADDRS = 166,
    NL80211_ATTR_MAC_ACL_MAX = 167,
    NL80211_ATTR_RADAR_EVENT = 168,
    NL80211_ATTR_EXT_CAPA = 169,
    NL80211_ATTR_EXT_CAPA_MASK = 170,
    NL80211_ATTR_STA_CAPABILITY = 171,
    NL80211_ATTR_STA_EXT_CAPABILITY = 172,
    NL80211_ATTR_PROTOCOL_FEATURES = 173,
    NL80211_ATTR_SPLIT_WIPHY_DUMP = 174,
    NL80211_ATTR_DISABLE_VHT = 175,
    NL80211_ATTR_VHT_CAPABILITY_MASK = 176,
    NL80211_ATTR_MDID = 177,
    NL80211_ATTR_IE_RIC = 178,
    NL80211_ATTR_CRIT_PROT_ID = 179,
    NL80211_ATTR_MAX_CRIT_PROT_DURATION = 180,
    NL80211_ATTR_PEER_AID = 181,
    NL80211_ATTR_COALESCE_RULE = 182,
    NL80211_ATTR_CH_SWITCH_COUNT = 183,
    NL80211_ATTR_CH_SWITCH_BLOCK_TX = 184,
    NL80211_ATTR_CSA_IES = 185,
    NL80211_ATTR_CSA_C_OFF_BEACON = 186,
    NL80211_ATTR_CSA_C_OFF_PRESP = 187,
    NL80211_ATTR_RXMGMT_FLAGS = 188,
    NL80211_ATTR_STA_SUPPORTED_CHANNELS = 189,
    NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES = 190,
    NL80211_ATTR_HANDLE_DFS = 191,
    NL80211_ATTR_SUPPORT_5_MHZ = 192,
    NL80211_ATTR_SUPPORT_10_MHZ = 193,
    NL80211_ATTR_OPMODE_NOTIF = 194,
    NL80211_ATTR_VENDOR_ID = 195,
    NL80211_ATTR_VENDOR_SUBCMD = 196,
    NL80211_ATTR_VENDOR_DATA = 197,
    NL80211_ATTR_VENDOR_EVENTS = 198,
    NL80211_ATTR_QOS_MAP = 199,
    NL80211_ATTR_MAC_HINT = 200,
    NL80211_ATTR_WIPHY_FREQ_HINT = 201,
    NL80211_ATTR_MAX_AP_ASSOC_STA = 202,
    NL80211_ATTR_TDLS_PEER_CAPABILITY = 203,
    NL80211_ATTR_SOCKET_OWNER = 204,
    NL80211_ATTR_CSA_C_OFFSETS_TX = 205,
    NL80211_ATTR_MAX_CSA_COUNTERS = 206,
    NL80211_ATTR_TDLS_INITIATOR = 207,
    NL80211_ATTR_USE_RRM = 208,
    NL80211_ATTR_WIPHY_DYN_ACK = 209,
    NL80211_ATTR_TSID = 210,
    NL80211_ATTR_USER_PRIO = 211,
    NL80211_ATTR_ADMITTED_TIME = 212,
    NL80211_ATTR_SMPS_MODE = 213,
    NL80211_ATTR_OPER_CLASS = 214,
    NL80211_ATTR_MAC_MASK = 215,
    NL80211_ATTR_WIPHY_SELF_MANAGED_REG = 216,
    NL80211_ATTR_EXT_FEATURES = 217,
    NL80211_ATTR_SURVEY_RADIO_STATS = 218,
    NL80211_ATTR_NETNS_FD = 219,
    NL80211_ATTR_SCHED_SCAN_DELAY = 220,
    NL80211_ATTR_REG_INDOOR = 221,
    __NL80211_ATTR_AFTER_LAST = 222,
    NUM_NL80211_ATTR = 222,
    NL80211_ATTR_MAX = 221
};

#line 571  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore.h"
struct wl18xx_event_mailbox {
   __le32 events_vector ;
   u8 number_of_scan_results ;
   u8 number_of_sched_scan_results ;
   __le16 channel_switch_role_id_bitmap ;
   s8 rssi_snr_trigger_metric[8U] ;
   __le32 hlid_removed_bitmap ;
   __le16 rx_ba_role_id_bitmap ;
   __le16 rx_ba_allowed_bitmap ;
   __le16 roc_completed_bitmap ;
   __le16 bss_loss_bitmap ;
   __le32 tx_retry_exceeded_bitmap ;
   __le32 inactive_sta_bitmap ;
   u8 rx_ba_role_id ;
   u8 rx_ba_link_id ;
   u8 rx_ba_win_size ;
   u8 padding ;
   u8 sc_ssid_len ;
   u8 sc_pwd_len ;
   u8 sc_token_len ;
   u8 padding1 ;
   u8 sc_ssid[32U] ;
   u8 sc_pwd[64U] ;
   u8 sc_token[32U] ;
   u8 sc_sync_channel ;
   u8 sc_sync_band ;
   u8 padding2[2U] ;
   u8 radar_channel ;
   u8 radar_type ;
   u8 padding3[2U] ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u16 __sum16;

#line 14  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
struct kernel_symbol {
   unsigned long value ;
   char const *name ;
};

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/init.h"
typedef void (*ctor_fn_t)(void);

#line 555  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/percpu.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jump_label.h"
struct jump_entry;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/jump_label.h"
typedef u64 jump_label_t;

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/jump_label.h"
struct jump_entry {
   jump_label_t code ;
   jump_label_t target ;
   jump_label_t key ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;

#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};

#line 198  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;

#line 223  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kernel_param;

#line 228  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const *, struct kernel_param const *) ;
   int (*get)(char *, struct kernel_param const *) ;
   void (*free)(void *) ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_string;

#line 62 
struct kparam_array;

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
union __anonunion_2081 {
   void *arg ;
   struct kparam_string const *str ;
   struct kparam_array const *arr ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kernel_param {
   char const *name ;
   struct module *mod ;
   struct kernel_param_ops const *ops ;
   u16 const perm ;
   s8 level ;
   u8 flags ;
   union __anonunion_2081 __anonCompField_kernel_param_49 ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops const *ops ;
   void *elem ;
};

#line 469  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rbtree_latch.h"
struct mod_arch_specific {
   
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_param_attrs;

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute *, struct module_kobject *, char *) ;
   ssize_t (*store)(struct module_attribute *, struct module_kobject *, char const *, size_t ) ;
   void (*setup)(struct module *, char const *) ;
   int (*test)(struct module *) ;
   void (*free)(struct module *) ;
};

#line 74 
struct exception_table_entry;

#line 290 
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
};

#line 297  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};

#line 304 
struct module_sect_attrs;

#line 304 
struct module_notes_attrs;

#line 304 
struct tracepoint;

#line 304 
struct trace_event_call;

#line 304 
struct trace_enum_map;

#line 304  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const *version ;
   char const *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol const *syms ;
   unsigned long const *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol const *gpl_syms ;
   unsigned long const *gpl_crcs ;
   struct kernel_symbol const *unused_syms ;
   unsigned long const *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol const *unused_gpl_syms ;
   unsigned long const *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol const *gpl_future_syms ;
   unsigned long const *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const *tracepoints_ptrs ;
   struct jump_entry *jump_entries ;
   unsigned int num_jump_entries ;
   unsigned int num_trace_bprintk_fmt ;
   char const **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};

#line 173  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/platform_device.h"
struct platform_driver {
   int (*probe)(struct platform_device *) ;
   int (*remove)(struct platform_device *) ;
   void (*shutdown)(struct platform_device *) ;
   int (*suspend)(struct platform_device *, pm_message_t ) ;
   int (*resume)(struct platform_device *) ;
   struct device_driver driver ;
   struct platform_device_id const *id_table ;
   bool prevent_deferred_probe ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};

#line 3470  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct iphdr {
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) ihl : 4 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) version : 4 ;
   __u8 tos ;
   __be16 tot_len ;
   __be16 id ;
   __be16 frag_off ;
   __u8 ttl ;
   __u8 protocol ;
   __sum16 check ;
   __be32 saddr ;
   __be32 daddr ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ip.h"
struct firmware {
   size_t size ;
   u8 const *data ;
   struct page **pages ;
   void *priv ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/vtime.h"
struct irq_data;

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/irq_regs.h"
struct msi_msg;

#line 31 
enum irqchip_irq_state;

#line 31 
enum irqchip_irq_state;

#line 62 
struct msi_desc;

#line 63 
struct irq_domain;

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/irq_regs.h"
struct irq_common_data {
   unsigned int state_use_accessors ;
};

#line 136  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/irq.h"
struct irq_chip;

#line 136  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/irq.h"
struct irq_data {
   u32 mask ;
   unsigned int irq ;
   unsigned long hwirq ;
   unsigned int node ;
   struct irq_common_data *common ;
   struct irq_chip *chip ;
   struct irq_domain *domain ;
   struct irq_data *parent_data ;
   void *handler_data ;
   void *chip_data ;
   struct msi_desc *msi_desc ;
   cpumask_var_t affinity ;
};

#line 305  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/irq.h"
struct irq_chip {
   char const *name ;
   unsigned int (*irq_startup)(struct irq_data *) ;
   void (*irq_shutdown)(struct irq_data *) ;
   void (*irq_enable)(struct irq_data *) ;
   void (*irq_disable)(struct irq_data *) ;
   void (*irq_ack)(struct irq_data *) ;
   void (*irq_mask)(struct irq_data *) ;
   void (*irq_mask_ack)(struct irq_data *) ;
   void (*irq_unmask)(struct irq_data *) ;
   void (*irq_eoi)(struct irq_data *) ;
   int (*irq_set_affinity)(struct irq_data *, struct cpumask const *, bool ) ;
   int (*irq_retrigger)(struct irq_data *) ;
   int (*irq_set_type)(struct irq_data *, unsigned int ) ;
   int (*irq_set_wake)(struct irq_data *, unsigned int ) ;
   void (*irq_bus_lock)(struct irq_data *) ;
   void (*irq_bus_sync_unlock)(struct irq_data *) ;
   void (*irq_cpu_online)(struct irq_data *) ;
   void (*irq_cpu_offline)(struct irq_data *) ;
   void (*irq_suspend)(struct irq_data *) ;
   void (*irq_resume)(struct irq_data *) ;
   void (*irq_pm_shutdown)(struct irq_data *) ;
   void (*irq_calc_mask)(struct irq_data *) ;
   void (*irq_print_chip)(struct irq_data *, struct seq_file *) ;
   int (*irq_request_resources)(struct irq_data *) ;
   void (*irq_release_resources)(struct irq_data *) ;
   void (*irq_compose_msi_msg)(struct irq_data *, struct msi_msg *) ;
   void (*irq_write_msi_msg)(struct irq_data *, struct msi_msg *) ;
   int (*irq_get_irqchip_state)(struct irq_data *, enum irqchip_irq_state , bool *) ;
   int (*irq_set_irqchip_state)(struct irq_data *, enum irqchip_irq_state , bool ) ;
   int (*irq_set_vcpu_affinity)(struct irq_data *, void *) ;
   unsigned long flags ;
};

#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
enum irqchip_irq_state {
    IRQCHIP_STATE_PENDING = 0,
    IRQCHIP_STATE_ACTIVE = 1,
    IRQCHIP_STATE_MASKED = 2,
    IRQCHIP_STATE_LINE_LEVEL = 3
};

#line 1349  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct wlcore_conf_header {
   __le32 magic ;
   __le32 version ;
   __le32 checksum ;
};

#line 1385  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/conf.h"
struct wlcore_conf_file {
   struct wlcore_conf_header header ;
   struct wlcore_conf core ;
   u8 priv[0U] ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/rx.h"
enum wl18xx_rdl_num {
    RDL_NONE = 0,
    RDL_1_HP = 1,
    RDL_2_SP = 2,
    RDL_3_HP = 3,
    RDL_4_SP = 4,
    RDL_5_SP = 17,
    RDL_6_SP = 18,
    RDL_7_SP = 19,
    RDL_8_SP = 20,
    _RDL_LAST = 21,
    RDL_MAX = 20
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/wl18xx.h"
struct wl18xx_fw_packet_counters {
   u8 tx_released_pkts[4U] ;
   u8 tx_lnk_free_pkts[16U] ;
   u8 tx_voice_released_blks ;
   u8 tx_last_rate ;
   u8 padding[2U] ;
};

#line 130  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/wl18xx.h"
struct wl18xx_fw_status {
   __le32 intr ;
   u8 fw_rx_counter ;
   u8 drv_rx_counter ;
   u8 reserved ;
   u8 tx_results_counter ;
   __le32 rx_pkt_descs[32U] ;
   __le32 fw_localtime ;
   __le32 link_ps_bitmap ;
   __le32 link_fast_bitmap ;
   __le32 total_released_blks ;
   __le32 tx_total ;
   struct wl18xx_fw_packet_counters counters ;
   __le32 log_start_addr ;
   struct wl18xx_fw_status_priv priv ;
};

#line 167  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/wl18xx.h"
struct wl18xx_static_data_priv {
   char phy_version[20U] ;
};

#line 173  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/wl18xx.h"
struct wl18xx_clk_cfg {
   u32 n ;
   u32 m ;
   u32 p ;
   u32 q ;
   bool swallow ;
};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/scan.h"
struct conn_scan_ch_params {
   __le16 min_duration ;
   __le16 max_duration ;
   __le16 passive_duration ;
   u8 channel ;
   u8 tx_power_att ;
   u8 flags ;
   u8 padding[3U] ;
};

#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/scan.h"
struct wlcore_scan_channels {
   u8 passive[3U] ;
   u8 active[3U] ;
   u8 dfs ;
   u8 passive_active ;
   struct conn_scan_ch_params channels_2[14U] ;
   struct conn_scan_ch_params channels_5[42U] ;
   struct conn_scan_ch_params channels_4[4U] ;
};

#line 169  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/scan.h"
struct tracking_ch_params {
   struct conn_scan_ch_params channel ;
   __le32 bssid_lsb ;
   __le16 bssid_msb ;
   u8 padding[2U] ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/scan.h"
struct __anonstruct_2695 {
   struct conn_scan_ch_params channels_2[14U] ;
   struct conn_scan_ch_params channels_5[32U] ;
   struct conn_scan_ch_params channels_4[4U] ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/scan.h"
union __anonunion_2694 {
   struct __anonstruct_2695 __anonCompField___anonunion_2694_103 ;
   struct tracking_ch_params channels_tracking[24U] ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/scan.h"
struct wl18xx_cmd_scan_params {
   struct wl1271_cmd_header header ;
   u8 role_id ;
   u8 scan_type ;
   s8 rssi_threshold ;
   s8 snr_threshold ;
   u8 bss_type ;
   u8 ssid_from_list ;
   u8 filter ;
   u8 add_broadcast ;
   u8 urgency ;
   u8 protect ;
   u8 n_probe_reqs ;
   u8 terminate_after ;
   u8 passive[3U] ;
   u8 active[3U] ;
   u8 dfs ;
   u8 passive_active ;
   __le16 short_cycles_sec ;
   __le16 long_cycles_sec ;
   u8 short_cycles_count ;
   u8 total_cycles ;
   u8 padding[2U] ;
   union __anonunion_2694 __anonCompField_wl18xx_cmd_scan_params_104 ;
   u8 ssid[32U] ;
   u8 ssid_len ;
   u8 tag ;
   u8 rate ;
   u8 report_threshold ;
   u8 terminate_on_report ;
   u8 padding1[3U] ;
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/scan.h"
struct wl18xx_cmd_scan_stop {
   struct wl1271_cmd_header header ;
   u8 role_id ;
   u8 scan_type ;
   u8 padding[2U] ;
};

#line 92  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.h"
struct wl18xx_acx_error_stats {
   u32 error_frame ;
   u32 error_null_Frame_tx_start ;
   u32 error_numll_frame_cts_start ;
   u32 error_bar_retry ;
   u32 error_frame_cts_nul_flid ;
};

#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.h"
struct wl18xx_acx_debug_stats {
   u32 debug1 ;
   u32 debug2 ;
   u32 debug3 ;
   u32 debug4 ;
   u32 debug5 ;
   u32 debug6 ;
};

#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.h"
struct wl18xx_acx_tx_stats {
   u32 tx_prepared_descs ;
   u32 tx_cmplt ;
   u32 tx_template_prepared ;
   u32 tx_data_prepared ;
   u32 tx_template_programmed ;
   u32 tx_data_programmed ;
   u32 tx_burst_programmed ;
   u32 tx_starts ;
   u32 tx_imm_resp ;
   u32 tx_start_templates ;
   u32 tx_start_int_templates ;
   u32 tx_start_fw_gen ;
   u32 tx_start_data ;
   u32 tx_start_null_frame ;
   u32 tx_exch ;
   u32 tx_retry_template ;
   u32 tx_retry_data ;
   u32 tx_exch_pending ;
   u32 tx_exch_expiry ;
   u32 tx_done_template ;
   u32 tx_done_data ;
   u32 tx_done_int_template ;
   u32 tx_frame_checksum ;
   u32 tx_checksum_result ;
   u32 frag_called ;
   u32 frag_mpdu_alloc_failed ;
   u32 frag_init_called ;
   u32 frag_in_process_called ;
   u32 frag_tkip_called ;
   u32 frag_key_not_found ;
   u32 frag_need_fragmentation ;
   u32 frag_bad_mblk_num ;
   u32 frag_failed ;
   u32 frag_cache_hit ;
   u32 frag_cache_miss ;
};

#line 153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.h"
struct wl18xx_acx_rx_stats {
   u32 rx_beacon_early_term ;
   u32 rx_out_of_mpdu_nodes ;
   u32 rx_hdr_overflow ;
   u32 rx_dropped_frame ;
   u32 rx_done_stage ;
   u32 rx_done ;
   u32 rx_defrag ;
   u32 rx_defrag_end ;
   u32 rx_cmplt ;
   u32 rx_pre_complt ;
   u32 rx_cmplt_task ;
   u32 rx_phy_hdr ;
   u32 rx_timeout ;
   u32 rx_timeout_wa ;
   u32 rx_wa_density_dropped_frame ;
   u32 rx_wa_ba_not_expected ;
   u32 rx_frame_checksum ;
   u32 rx_checksum_result ;
   u32 defrag_called ;
   u32 defrag_init_called ;
   u32 defrag_in_process_called ;
   u32 defrag_tkip_called ;
   u32 defrag_need_defrag ;
   u32 defrag_decrypt_failed ;
   u32 decrypt_key_not_found ;
   u32 defrag_need_decrypt ;
   u32 rx_tkip_replays ;
};

#line 183  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.h"
struct wl18xx_acx_isr_stats {
   u32 irqs ;
};

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.h"
struct wl18xx_acx_pwr_stats {
   u32 missing_bcns_cnt ;
   u32 rcvd_bcns_cnt ;
   u32 connection_out_of_sync ;
   u32 cont_miss_bcns_spread[10U] ;
   u32 rcvd_awake_bcns_cnt ;
};

#line 203  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.h"
struct wl18xx_acx_ps_poll_stats {
   u32 ps_poll_timeouts ;
   u32 upsd_timeouts ;
   u32 upsd_max_ap_turn ;
   u32 ps_poll_max_ap_turn ;
   u32 ps_poll_utilization ;
   u32 upsd_utilization ;
};

#line 212  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.h"
struct wl18xx_acx_rx_filter_stats {
   u32 beacon_filter ;
   u32 arp_filter ;
   u32 mc_filter ;
   u32 dup_filter ;
   u32 data_filter ;
   u32 ibss_filter ;
   u32 protection_filter ;
   u32 accum_arp_pend_requests ;
   u32 max_arp_queue_dep ;
};

#line 224  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.h"
struct wl18xx_acx_rx_rate_stats {
   u32 rx_frames_per_rates[50U] ;
};

#line 228  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.h"
struct wl18xx_acx_aggr_stats {
   u32 tx_agg_vs_rate[256U] ;
   u32 rx_size[16U] ;
};

#line 237  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.h"
struct wl18xx_acx_pipeline_stats {
   u32 hs_tx_stat_fifo_int ;
   u32 hs_rx_stat_fifo_int ;
   u32 tcp_tx_stat_fifo_int ;
   u32 tcp_rx_stat_fifo_int ;
   u32 enc_tx_stat_fifo_int ;
   u32 enc_rx_stat_fifo_int ;
   u32 rx_complete_stat_fifo_int ;
   u32 pre_proc_swi ;
   u32 post_proc_swi ;
   u32 sec_frag_swi ;
   u32 pre_to_defrag_swi ;
   u32 defrag_to_csum_swi ;
   u32 csum_to_rx_xfer_swi ;
   u32 dec_packet_in ;
   u32 dec_packet_in_fifo_full ;
   u32 dec_packet_out ;
   u32 cs_rx_packet_in ;
   u32 cs_rx_packet_out ;
   u16 pipeline_fifo_full[11U] ;
};

#line 261  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.h"
struct wl18xx_acx_mem_stats {
   u32 rx_free_mem_blks ;
   u32 tx_free_mem_blks ;
   u32 fwlog_free_mem_blks ;
   u32 fw_gen_free_mem_blks ;
};

#line 268  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.h"
struct wl18xx_acx_statistics {
   struct acx_header header ;
   struct wl18xx_acx_error_stats error ;
   struct wl18xx_acx_debug_stats debug ;
   struct wl18xx_acx_tx_stats tx ;
   struct wl18xx_acx_rx_stats rx ;
   struct wl18xx_acx_isr_stats isr ;
   struct wl18xx_acx_pwr_stats pwr ;
   struct wl18xx_acx_ps_poll_stats ps_poll ;
   struct wl18xx_acx_rx_filter_stats rx_filter ;
   struct wl18xx_acx_rx_rate_stats rx_rate ;
   struct wl18xx_acx_aggr_stats aggr_size ;
   struct wl18xx_acx_pipeline_stats pipeline ;
   struct wl18xx_acx_mem_stats mem ;
};

#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
struct ldv_list_element {
   void *data ;
   struct ldv_list_element *next ;
};

#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
typedef struct ldv_list_element *ldv_list_ptr;

#line 41  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
struct device_private {
   void *driver_data ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef short s16;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_work;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_worker {
   spinlock_t lock ;
   struct list_head work_list ;
   struct task_struct *task ;
   struct kthread_work *current_work ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_work {
   struct list_head node ;
   void (*func)(struct kthread_work *) ;
   struct kthread_worker *worker ;
};

#line 380  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct dma_chan;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_master;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_device {
   struct device dev ;
   struct spi_master *master ;
   u32 max_speed_hz ;
   u8 chip_select ;
   u8 bits_per_word ;
   u16 mode ;
   int irq ;
   void *controller_state ;
   void *controller_data ;
   char modalias[32U] ;
   int cs_gpio ;
};

#line 151 
struct spi_message;

#line 152 
struct spi_transfer;

#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_master {
   struct device dev ;
   struct list_head list ;
   s16 bus_num ;
   u16 num_chipselect ;
   u16 dma_alignment ;
   u16 mode_bits ;
   u32 bits_per_word_mask ;
   u32 min_speed_hz ;
   u32 max_speed_hz ;
   u16 flags ;
   spinlock_t bus_lock_spinlock ;
   struct mutex bus_lock_mutex ;
   bool bus_lock_flag ;
   int (*setup)(struct spi_device *) ;
   int (*transfer)(struct spi_device *, struct spi_message *) ;
   void (*cleanup)(struct spi_device *) ;
   bool (*can_dma)(struct spi_master *, struct spi_device *, struct spi_transfer *) ;
   bool queued ;
   struct kthread_worker kworker ;
   struct task_struct *kworker_task ;
   struct kthread_work pump_messages ;
   spinlock_t queue_lock ;
   struct list_head queue ;
   struct spi_message *cur_msg ;
   bool idling ;
   bool busy ;
   bool running ;
   bool rt ;
   bool auto_runtime_pm ;
   bool cur_msg_prepared ;
   bool cur_msg_mapped ;
   struct completion xfer_completion ;
   size_t max_dma_len ;
   int (*prepare_transfer_hardware)(struct spi_master *) ;
   int (*transfer_one_message)(struct spi_master *, struct spi_message *) ;
   int (*unprepare_transfer_hardware)(struct spi_master *) ;
   int (*prepare_message)(struct spi_master *, struct spi_message *) ;
   int (*unprepare_message)(struct spi_master *, struct spi_message *) ;
   void (*set_cs)(struct spi_device *, bool ) ;
   int (*transfer_one)(struct spi_master *, struct spi_device *, struct spi_transfer *) ;
   void (*handle_err)(struct spi_master *, struct spi_message *) ;
   int *cs_gpios ;
   struct dma_chan *dma_tx ;
   struct dma_chan *dma_rx ;
   void *dummy_rx ;
   void *dummy_tx ;
};

#line 506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_transfer {
   void const *tx_buf ;
   void *rx_buf ;
   unsigned int len ;
   dma_addr_t tx_dma ;
   dma_addr_t rx_dma ;
   struct sg_table tx_sg ;
   struct sg_table rx_sg ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cs_change : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) tx_nbits : 3 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) rx_nbits : 3 ;
   u8 bits_per_word ;
   u16 delay_usecs ;
   u32 speed_hz ;
   struct list_head transfer_list ;
};

#line 630  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_message {
   struct list_head transfers ;
   struct spi_device *spi ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_dma_mapped : 1 ;
   void (*complete)(void *) ;
   void *context ;
   unsigned int frame_length ;
   unsigned int actual_length ;
   int status ;
   struct list_head queue ;
   void *state ;
};

#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
typedef unsigned long pthread_t;

#line 22  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
union pthread_attr_t {
   char __size[56U] ;
   long __align ;
};

#line 29  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
typedef union pthread_attr_t pthread_attr_t;

#line 678  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pagemap.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file *, wait_queue_head_t *, struct poll_table_struct *) ;
   unsigned long _key ;
};

#line 338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/platform_device.h"
struct ldv_struct_character_driver_scenario_6 {
   struct file_operations *arg0 ;
   int signal_pending ;
};

#line 19  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_platform_instance_108 {
   struct platform_driver *arg0 ;
   int signal_pending ;
};

#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
int printk(char const * , ...);


#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_debug.h"
void __dynamic_pr_debug(struct _ddebug *, char const * , ...);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kzalloc(size_t size, gfp_t flags);


#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
void kfree(void const *);


#line 581 
static void *kzalloc(size_t size, gfp_t flags);


#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/cmd.h"
int wl1271_cmd_configure(struct wl1271 *, u16, void *, size_t);


#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/debug.h"
extern u32 wl12xx_debug_level;


#line 370  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.h"
int wl18xx_acx_host_if_cfg_bitmap(struct wl1271 *wl, u32 host_cfg_bitmap, u32 sdio_blk_size, u32 extra_mem_blks, u32 len_field_size);


#line 373 
int wl18xx_acx_set_checksum_state(struct wl1271 *wl);


#line 374 
int wl18xx_acx_clear_statistics(struct wl1271 *wl);


#line 375 
int wl18xx_acx_peer_ht_operation_mode(struct wl1271 *wl, u8 hlid, bool wide);


#line 376 
int wl18xx_acx_set_peer_cap(struct wl1271 *wl, struct ieee80211_sta_ht_cap *ht_cap, bool allow_ht_operation, u32 rate_set, u8 hlid);


#line 380 
int wl18xx_acx_interrupt_notify_config(struct wl1271 *wl, bool action);


#line 381 
int wl18xx_acx_rx_ba_filter(struct wl1271 *wl, bool action);


#line 382 
int wl18xx_acx_ap_sleep(struct wl1271 *wl);


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.c"
int wl18xx_acx_host_if_cfg_bitmap(struct wl1271 *wl, u32 host_cfg_bitmap, u32 sdio_blk_size, u32 extra_mem_blks, u32 len_field_size)
{
  struct wl18xx_acx_host_config_bitmap *bitmap_conf;
  int ret;
  
#line 36 
  if ((long)((wl12xx_debug_level & 8192U) != 0U) != 0L) {
    
#line 36 
    struct _ddebug descriptor = {.modname = "wl18xx", .function = "wl18xx_acx_host_if_cfg_bitmap", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))38U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 36 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 36 
                                                        __dynamic_pr_debug(& descriptor,"wlcore",host_cfg_bitmap,sdio_blk_size,extra_mem_blks,len_field_size); else ;
  }
  else ;
  
#line 40 
  bitmap_conf = (struct wl18xx_acx_host_config_bitmap *)kzalloc(24UL,208U);
  
#line 41 
  if (bitmap_conf == (struct wl18xx_acx_host_config_bitmap *)0) {
    
#line 42 
    ret = -12;
    
#line 43 
    goto out;
  }
  else ;
  
#line 46 
  bitmap_conf->host_cfg_bitmap = host_cfg_bitmap;
  
#line 47 
  bitmap_conf->host_sdio_block_size = sdio_blk_size;
  
#line 48 
  bitmap_conf->extra_mem_blocks = extra_mem_blks;
  
#line 49 
  bitmap_conf->length_field_size = len_field_size;
  
#line 51 
  ret = wl1271_cmd_configure(wl,(unsigned short)57,(void *)bitmap_conf,24UL);
  
#line 53 
  if (ret < 0) {
    
#line 54 
    printk("\001",ret);
    
#line 55 
    goto out;
  }
  else ;
  out: 
#line 58 
  ;
  
#line 59 
  kfree((void const *)bitmap_conf);
  
#line 61 
  return ret;
}


#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.c"
int wl18xx_acx_set_checksum_state(struct wl1271 *wl)
{
  struct wl18xx_acx_checksum_state *acx;
  int ret;
  
#line 69 
  if ((long)((wl12xx_debug_level & 8192U) != 0U) != 0L) {
    
#line 69 
    struct _ddebug descriptor = {.modname = "wl18xx", .function = "wl18xx_acx_set_checksum_state", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))69U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 69 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 69 
                                                        __dynamic_pr_debug(& descriptor,"wlcore"); else ;
  }
  else ;
  
#line 71 
  acx = (struct wl18xx_acx_checksum_state *)kzalloc(12UL,208U);
  
#line 72 
  if (acx == (struct wl18xx_acx_checksum_state *)0) {
    
#line 73 
    ret = -12;
    
#line 74 
    goto out;
  }
  else ;
  
#line 77 
  acx->checksum_state = (unsigned char)1U;
  
#line 79 
  ret = wl1271_cmd_configure(wl,(unsigned short)82,(void *)acx,12UL);
  
#line 80 
  if (ret < 0) {
    
#line 81 
    printk("\001",ret);
    
#line 82 
    goto out;
  }
  else ;
  out: 
#line 85 
  ;
  
#line 86 
  kfree((void const *)acx);
  
#line 87 
  return ret;
}


#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.c"
int wl18xx_acx_clear_statistics(struct wl1271 *wl)
{
  struct wl18xx_acx_clear_statistics *acx;
  
#line 93 
  int ret = 0;
  
#line 95 
  if ((long)((wl12xx_debug_level & 8192U) != 0U) != 0L) {
    
#line 95 
    struct _ddebug descriptor = {.modname = "wl18xx", .function = "wl18xx_acx_clear_statistics", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))95U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 95 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 95 
                                                        __dynamic_pr_debug(& descriptor,"wlcore"); else ;
  }
  else ;
  
#line 97 
  acx = (struct wl18xx_acx_clear_statistics *)kzalloc(8UL,208U);
  
#line 98 
  if (acx == (struct wl18xx_acx_clear_statistics *)0) {
    
#line 99 
    ret = -12;
    
#line 100 
    goto out;
  }
  else ;
  
#line 103 
  ret = wl1271_cmd_configure(wl,(unsigned short)84,(void *)acx,8UL);
  
#line 104 
  if (ret < 0) {
    
#line 105 
    printk("\001",ret);
    
#line 106 
    goto out;
  }
  else ;
  out: 
#line 109 
  ;
  
#line 110 
  kfree((void const *)acx);
  
#line 111 
  return ret;
}


#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.c"
int wl18xx_acx_peer_ht_operation_mode(struct wl1271 *wl, u8 hlid, bool wide)
{
  struct wlcore_peer_ht_operation_mode *acx;
  int ret;
  
#line 119 
  if ((long)((wl12xx_debug_level & 8192U) != 0U) != 0L) {
    
#line 119 
    struct _ddebug descriptor = {.modname = "wl18xx", .function = "wl18xx_acx_peer_ht_operation_mode", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))120U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 119 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 119 
                                                        __dynamic_pr_debug(& descriptor,"wlcore",(int)hlid,(int)wide); else ;
  }
  else ;
  
#line 122 
  acx = (struct wlcore_peer_ht_operation_mode *)kzalloc(12UL,208U);
  
#line 123 
  if (acx == (struct wlcore_peer_ht_operation_mode *)0) {
    
#line 124 
    ret = -12;
    
#line 125 
    goto out;
  }
  else ;
  
#line 128 
  acx->hlid = hlid;
  
#line 129 
  acx->bandwidth = (unsigned char)((int)wide != 0);
  
#line 131 
  ret = wl1271_cmd_configure(wl,(unsigned short)81,(void *)acx,12UL);
  
#line 134 
  if (ret < 0) {
    
#line 135 
    printk("\001",ret);
    
#line 136 
    goto out;
  }
  else ;
  out: 
#line 139 
  ;
  
#line 140 
  kfree((void const *)acx);
  
#line 141 
  return ret;
}


#line 150  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.c"
int wl18xx_acx_set_peer_cap(struct wl1271 *wl, struct ieee80211_sta_ht_cap *ht_cap, bool allow_ht_operation, u32 rate_set, u8 hlid)
{
  struct wlcore_acx_peer_cap *acx;
  
#line 156 
  int ret = 0;
  
#line 157 
  u32 ht_capabilites = 0U;
  
#line 159 
  if ((long)((wl12xx_debug_level & 8192U) != 0U) != 0L) {
    
#line 159 
    struct _ddebug descriptor = {.modname = "wl18xx", .function = "wl18xx_acx_set_peer_cap", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))161U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 159 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 159 
                                                        __dynamic_pr_debug(& descriptor,"wlcore",(int)ht_cap->ht_supported,(int)ht_cap->cap,rate_set); else ;
  }
  else ;
  
#line 163 
  acx = (struct wlcore_acx_peer_cap *)kzalloc(20UL,208U);
  
#line 164 
  if (acx == (struct wlcore_acx_peer_cap *)0) {
    
#line 165 
    ret = -12;
    
#line 166 
    goto out;
  }
  else ;
  
#line 169 
  if ((int)allow_ht_operation != 0 && (int)ht_cap->ht_supported != 0) {
    
#line 171 
    ht_capabilites = (unsigned int)ht_cap->cap;
    
#line 177 
    ht_capabilites |= 65536U;
    
#line 180 
    acx->ampdu_max_length = ht_cap->ampdu_factor;
    
#line 181 
    acx->ampdu_min_spacing = ht_cap->ampdu_density;
  }
  else ;
  
#line 184 
  acx->hlid = hlid;
  
#line 185 
  acx->ht_capabilites = ht_capabilites;
  
#line 186 
  acx->supported_rates = rate_set;
  
#line 188 
  ret = wl1271_cmd_configure(wl,(unsigned short)86,(void *)acx,20UL);
  
#line 189 
  if (ret < 0) {
    
#line 190 
    printk("\001",ret);
    
#line 191 
    goto out;
  }
  else ;
  out: 
#line 194 
  ;
  
#line 195 
  kfree((void const *)acx);
  
#line 196 
  return ret;
}


#line 203  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.c"
int wl18xx_acx_interrupt_notify_config(struct wl1271 *wl, bool action)
{
  struct wl18xx_acx_interrupt_notify *acx;
  
#line 207 
  int ret = 0;
  
#line 209 
  acx = (struct wl18xx_acx_interrupt_notify *)kzalloc(12UL,208U);
  
#line 210 
  if (acx == (struct wl18xx_acx_interrupt_notify *)0) {
    
#line 211 
    ret = -12;
    
#line 212 
    goto out;
  }
  else ;
  
#line 215 
  acx->enable = (unsigned int)action;
  
#line 216 
  ret = wl1271_cmd_configure(wl,(unsigned short)87,(void *)acx,12UL);
  
#line 217 
  if (ret < 0) {
    
#line 218 
    printk("\001",ret);
    
#line 219 
    goto out;
  }
  else ;
  out: 
#line 222 
  ;
  
#line 223 
  kfree((void const *)acx);
  
#line 224 
  return ret;
}


#line 231  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.c"
int wl18xx_acx_rx_ba_filter(struct wl1271 *wl, bool action)
{
  struct wl18xx_acx_rx_ba_filter *acx;
  
#line 234 
  int ret = 0;
  
#line 236 
  acx = (struct wl18xx_acx_rx_ba_filter *)kzalloc(12UL,208U);
  
#line 237 
  if (acx == (struct wl18xx_acx_rx_ba_filter *)0) {
    
#line 238 
    ret = -12;
    
#line 239 
    goto out;
  }
  else ;
  
#line 242 
  acx->enable = (unsigned int)action;
  
#line 243 
  ret = wl1271_cmd_configure(wl,(unsigned short)88,(void *)acx,12UL);
  
#line 244 
  if (ret < 0) {
    
#line 245 
    printk("\001",ret);
    
#line 247 
    goto out;
  }
  else ;
  out: 
#line 250 
  ;
  
#line 251 
  kfree((void const *)acx);
  
#line 252 
  return ret;
}


#line 255  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.c"
int wl18xx_acx_ap_sleep(struct wl1271 *wl)
{
  struct acx_ap_sleep_cfg *acx;
  int ret;
  
#line 257 
  struct wl18xx_priv *priv = (struct wl18xx_priv *)wl->priv;
  
#line 259 
  struct conf_ap_sleep_settings *conf = & priv->conf.ap_sleep;
  
#line 262 
  if ((long)((wl12xx_debug_level & 8192U) != 0U) != 0L) {
    
#line 262 
    struct _ddebug descriptor = {.modname = "wl18xx", .function = "wl18xx_acx_ap_sleep", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/acx.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))262U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 262 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 262 
                                                        __dynamic_pr_debug(& descriptor,"wlcore"); else ;
  }
  else ;
  
#line 264 
  acx = (struct acx_ap_sleep_cfg *)kzalloc(12UL,208U);
  
#line 265 
  if (acx == (struct acx_ap_sleep_cfg *)0) {
    
#line 266 
    ret = -12;
    
#line 267 
    goto out;
  }
  else ;
  
#line 270 
  acx->idle_duty_cycle = conf->idle_duty_cycle;
  
#line 271 
  acx->connected_duty_cycle = conf->connected_duty_cycle;
  
#line 272 
  acx->max_stations_thresh = conf->max_stations_thresh;
  
#line 273 
  acx->idle_conn_thresh = conf->idle_conn_thresh;
  
#line 275 
  ret = wl1271_cmd_configure(wl,(unsigned short)89,(void *)acx,12UL);
  
#line 276 
  if (ret < 0) {
    
#line 277 
    printk("\001",ret);
    
#line 278 
    goto out;
  }
  else ;
  out: 
#line 281 
  ;
  
#line 282 
  kfree((void const *)acx);
  
#line 283 
  return ret;
}


#line 494  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_acx.c.aux"
static void *kzalloc(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 497 
  tmp = ldv_kzalloc(size,flags);
  
#line 497 
  return tmp;
}


#line 7  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/fvtp/.tmp_io.c"
void ldv_inline_asm(void);


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr, unsigned long volatile *addr)
{
  
#line 74 
  if (0 != 0) 
#line 76 
              ldv_inline_asm(); else 
#line 79 
                                     ldv_inline_asm();
  
#line 80 
  return;
}


#line 308  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr, unsigned long const volatile *addr)
{
  int __retres;
  
#line 311 
  __retres = ((*(addr + (nr >> 6)) >> (nr & 63L)) & 1UL) != 0UL;
  
#line 311 
  return __retres;
}


#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/bug.h"
void warn_slowpath_null(char const *, int const);


#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/io.h"
int wlcore_translate_addr(struct wl1271 *, int);


#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/io.h"
__inline static int wlcore_raw_write(struct wl1271 *wl, int addr, void *buf, size_t len, bool fixed)
{
  int __retres;
  int ret;
  int tmp;
  
#line 63 
  tmp = constant_test_bit(14L,(unsigned long const volatile *)(& wl->flags));
  
#line 63 
  if (tmp != 0) {
    
#line 66 
    __retres = -5;
    
#line 66 
    goto return_label;
  }
  else {
    int tmp_2;
    {
      int tmp_1;
      int tmp_0;
      
#line 64 
      tmp_0 = constant_test_bit(3L,(unsigned long const volatile *)(& wl->flags));
      
#line 64 
      if (tmp_0 != 0) 
        
#line 64 
        if (addr != 131068) 
#line 64 
                            tmp_1 = 1; else 
#line 64 
                                            tmp_1 = 0;
      else 
#line 64 
           tmp_1 = 0;
      
#line 64 
      int __ret_warn_on = tmp_1;
      
#line 64 
      if ((long)(__ret_warn_on != 0) != 0L) 
#line 64 
                                            warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/../wlcore/io.h",65); else ;
      
#line 64 
      tmp_2 = (long)(__ret_warn_on != 0);
    }
    
#line 63 
    if ((long)tmp_2 != 0L) {
      
#line 66 
      __retres = -5;
      
#line 66 
      goto return_label;
    }
    else ;
  }
  
#line 68 
  ret = (*((wl->if_ops)->write))(wl->dev,addr,buf,len,(_Bool)((bool)((int)fixed) != 0));
  
#line 69 
  if (ret != 0 && wl->state != (unsigned int)WLCORE_STATE_OFF) 
#line 70 
                                                               set_bit(14L,(unsigned long volatile *)(& wl->flags)); else ;
  
#line 72 
  __retres = ret;
  return_label: 
#line 72 
                return __retres;
}


#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/io.h"
__inline static int wlcore_raw_read(struct wl1271 *wl, int addr, void *buf, size_t len, bool fixed)
{
  int __retres;
  int ret;
  int tmp;
  
#line 81 
  tmp = constant_test_bit(14L,(unsigned long const volatile *)(& wl->flags));
  
#line 81 
  if (tmp != 0) {
    
#line 84 
    __retres = -5;
    
#line 84 
    goto return_label;
  }
  else {
    int tmp_2;
    {
      int tmp_1;
      int tmp_0;
      
#line 82 
      tmp_0 = constant_test_bit(3L,(unsigned long const volatile *)(& wl->flags));
      
#line 82 
      if (tmp_0 != 0) 
        
#line 82 
        if (addr != 131068) 
#line 82 
                            tmp_1 = 1; else 
#line 82 
                                            tmp_1 = 0;
      else 
#line 82 
           tmp_1 = 0;
      
#line 82 
      int __ret_warn_on = tmp_1;
      
#line 82 
      if ((long)(__ret_warn_on != 0) != 0L) 
#line 82 
                                            warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/../wlcore/io.h",83); else ;
      
#line 82 
      tmp_2 = (long)(__ret_warn_on != 0);
    }
    
#line 81 
    if ((long)tmp_2 != 0L) {
      
#line 84 
      __retres = -5;
      
#line 84 
      goto return_label;
    }
    else ;
  }
  
#line 86 
  ret = (*((wl->if_ops)->read))(wl->dev,addr,buf,len,(_Bool)((bool)((int)fixed) != 0));
  
#line 87 
  if (ret != 0 && wl->state != (unsigned int)WLCORE_STATE_OFF) 
#line 88 
                                                               set_bit(14L,(unsigned long volatile *)(& wl->flags)); else ;
  
#line 90 
  __retres = ret;
  return_label: 
#line 90 
                return __retres;
}


#line 107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/io.h"
__inline static int wlcore_raw_read32(struct wl1271 *wl, int addr, u32 *val)
{
  int __retres;
  int ret;
  
#line 112 
  ret = wlcore_raw_read(wl,addr,(void *)wl->buffer_32,4UL,(_Bool)0);
  
#line 114 
  if (ret < 0) {
    
#line 115 
    __retres = ret;
    
#line 115 
    goto return_label;
  }
  else ;
  
#line 117 
  if (val != (u32 *)0U) 
#line 118 
                        *val = *(wl->buffer_32); else ;
  
#line 120 
  __retres = 0;
  return_label: 
#line 120 
                return __retres;
}


#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/io.h"
__inline static int wlcore_raw_write32(struct wl1271 *wl, int addr, u32 val)
{
  int tmp;
  
#line 126 
  *(wl->buffer_32) = val;
  
#line 127 
  tmp = wlcore_raw_write(wl,addr,(void *)wl->buffer_32,4UL,(_Bool)0);
  
#line 127 
  return tmp;
}


#line 180  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/io.h"
__inline static int wlcore_read32(struct wl1271 *wl, int addr, u32 *val)
{
  int tmp_0;
  int tmp;
  
#line 183 
  ;
  
#line 183 
  tmp = wlcore_translate_addr(wl,addr);
  
#line 183 
  ;
  
#line 183 
  tmp_0 = wlcore_raw_read32(wl,tmp,val);
  
#line 183 
  return tmp_0;
}


#line 186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/io.h"
__inline static int wlcore_write32(struct wl1271 *wl, int addr, u32 val)
{
  int tmp_0;
  int tmp;
  
#line 189 
  ;
  
#line 189 
  tmp = wlcore_translate_addr(wl,addr);
  
#line 189 
  ;
  
#line 189 
  tmp_0 = wlcore_raw_write32(wl,tmp,val);
  
#line 189 
  return tmp_0;
}


#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/io.h"
int wl18xx_top_reg_write(struct wl1271 *wl, int addr, u16 val);


#line 26 
int wl18xx_top_reg_read(struct wl1271 *wl, int addr, u16 *out);


#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/io.h"
int wl18xx_top_reg_write(struct wl1271 *wl, int addr, u16 val)
{
  int __retres;
  u32 tmp;
  int ret;
  int tmp_0;
  {
    
#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/io.c"
    int __ret_warn_on = ((unsigned int)addr & 1U) != 0U;
    
#line 32 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 32 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/io.c",32); else ;
    
#line 32 
    tmp_0 = (long)(__ret_warn_on != 0);
  }
  
#line 32 
  if ((long)tmp_0 != 0L) {
    
#line 33 
    __retres = -22;
    
#line 33 
    goto return_label;
  }
  else ;
  
#line 35 
  if (((unsigned int)addr & 3U) == 0U) {
    
#line 36 
    ret = wlcore_read32(wl,addr,& tmp);
    
#line 37 
    if (ret < 0) 
#line 38 
                 goto out; else ;
    
#line 40 
    tmp = (tmp & 4294901760U) | (unsigned int)val;
    
#line 41 
    ret = wlcore_write32(wl,addr,tmp);
  }
  else {
    
#line 43 
    ret = wlcore_read32(wl,addr + -2,& tmp);
    
#line 44 
    if (ret < 0) 
#line 45 
                 goto out; else ;
    
#line 47 
    tmp = (tmp & 65535U) | (unsigned int)((int)val << 16);
    
#line 48 
    ret = wlcore_write32(wl,addr + -2,tmp);
  }
  out: 
#line 51 
  ;
  
#line 52 
  __retres = ret;
  return_label: 
#line 52 
                return __retres;
}


#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/io.c"
int wl18xx_top_reg_read(struct wl1271 *wl, int addr, u16 *out)
{
  int __retres;
  int ret;
  int tmp;
  
#line 57 
  u32 val = 0U;
  {
    
#line 60 
    int __ret_warn_on = ((unsigned int)addr & 1U) != 0U;
    
#line 60 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 60 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/io.c",60); else ;
    
#line 60 
    tmp = (long)(__ret_warn_on != 0);
  }
  
#line 60 
  if ((long)tmp != 0L) {
    
#line 61 
    __retres = -22;
    
#line 61 
    goto return_label;
  }
  else ;
  
#line 63 
  if (((unsigned int)addr & 3U) == 0U) {
    
#line 65 
    ret = wlcore_read32(wl,addr,& val);
    
#line 66 
    if (ret >= 0 && out != (u16 *)0U) 
#line 67 
                                      *out = (unsigned short)val; else ;
  }
  else {
    
#line 69 
    ret = wlcore_read32(wl,addr + -2,& val);
    
#line 70 
    if (ret >= 0 && out != (u16 *)0U) 
#line 71 
                                      *out = (unsigned short)(val >> 16); else ;
  }
  
#line 74 
  __retres = ret;
  return_label: 
#line 74 
                return __retres;
}

void __builtin_unreachable(void);


#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
void *memcpy(void *, void const *, size_t);


#line 581  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kzalloc_0(size_t size, gfp_t flags);


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/cmd.h"
int wl1271_cmd_send(struct wl1271 *, u16, void *, size_t, size_t);


#line 108 
u8 wlcore_get_native_channel_type(u8);


#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/hw_ops.h"
__inline static u32 wlcore_hw_sta_get_ap_rate_mask(struct wl1271 *wl, struct wl12xx_vif *wlvif)
{
  u32 tmp;
  
#line 121 
  if ((wl->ops)->sta_get_ap_rate_mask == (u32 (*)(struct wl1271 *, struct wl12xx_vif *))0) {
    
#line 124 
    ldv_inline_asm();
    
#line 122 
    ;
  }
  else ;
  
#line 124 
  tmp = (*((wl->ops)->sta_get_ap_rate_mask))(wl,wlvif);
  
#line 124 
  return tmp;
}


#line 156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/hw_ops.h"
__inline static u32 wlcore_hw_ap_get_mimo_wide_rate_mask(struct wl1271 *wl, struct wl12xx_vif *wlvif)
{
  u32 __retres;
  
#line 159 
  if ((wl->ops)->ap_get_mimo_wide_rate_mask != (u32 (*)(struct wl1271 *, struct wl12xx_vif *))0) {
    u32 tmp;
    
#line 160 
    tmp = (*((wl->ops)->ap_get_mimo_wide_rate_mask))(wl,wlvif);
    
#line 160 
    __retres = tmp;
    
#line 160 
    goto return_label;
  }
  else ;
  
#line 162 
  __retres = 0U;
  return_label: 
#line 162 
                return __retres;
}


#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/cmd.h"
int wl18xx_cmd_channel_switch(struct wl1271 *wl, struct wl12xx_vif *wlvif, struct ieee80211_channel_switch *ch_switch);


#line 89 
int wl18xx_cmd_smart_config_start(struct wl1271 *wl, u32 group_bitmap);


#line 90 
int wl18xx_cmd_smart_config_stop(struct wl1271 *wl);


#line 91 
int wl18xx_cmd_smart_config_set_group_key(struct wl1271 *wl, u16 group_id, u8 key_len, u8 *key);


#line 93 
int wl18xx_cmd_set_cac(struct wl1271 *wl, struct wl12xx_vif *wlvif, bool start);


#line 94 
int wl18xx_cmd_radar_detection_debug(struct wl1271 *wl, u8 channel);


#line 95 
int wl18xx_cmd_dfs_master_restart(struct wl1271 *wl, struct wl12xx_vif *wlvif);


#line 28  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/cmd.c"
int wl18xx_cmd_channel_switch(struct wl1271 *wl, struct wl12xx_vif *wlvif, struct ieee80211_channel_switch *ch_switch)
{
  struct wl18xx_cmd_channel_switch *cmd;
  u32 supported_rates;
  int ret;
  
#line 36 
  if ((long)((wl12xx_debug_level & 8192U) != 0U) != 0L) {
    
#line 36 
    struct _ddebug descriptor = {.modname = "wl18xx", .function = "wl18xx_cmd_channel_switch", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/cmd.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))37U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 36 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 36 
                                                        __dynamic_pr_debug(& descriptor,"wlcore",(int)ch_switch->count); else ;
  }
  else ;
  
#line 39 
  cmd = (struct wl18xx_cmd_channel_switch *)kzalloc_0(16UL,208U);
  
#line 40 
  if (cmd == (struct wl18xx_cmd_channel_switch *)0) {
    
#line 41 
    ret = -12;
    
#line 42 
    goto out;
  }
  else ;
  
#line 45 
  cmd->role_id = wlvif->role_id;
  
#line 46 
  cmd->channel = (unsigned char)(ch_switch->chandef.chan)->hw_value;
  
#line 47 
  cmd->switch_time = ch_switch->count;
  
#line 48 
  cmd->stop_tx = (unsigned char)ch_switch->block_tx;
  
#line 50 
  switch ((unsigned int)(ch_switch->chandef.chan)->band) {
    case (unsigned int)0: 
#line 51 
    ;
    
#line 52 
    cmd->band = (unsigned char)0U;
    
#line 53 
    goto ldv_51913;
    case (unsigned int)1: 
#line 54 
    ;
    
#line 55 
    cmd->band = (unsigned char)1U;
    
#line 56 
    goto ldv_51913;
    default: 
#line 57 
    ;
    
#line 58 
    printk("\001",(unsigned int)(ch_switch->chandef.chan)->band);
    
#line 60 
    ret = -22;
    
#line 61 
    goto out_free;
  }
  ldv_51913: 
#line 64 
  ;
  
#line 64 
  supported_rates = 2096895U;
  
#line 65 
  if ((unsigned int)wlvif->bss_type == 2U) {
    u32 tmp_0;
    
#line 66 
    tmp_0 = wlcore_hw_sta_get_ap_rate_mask(wl,wlvif);
    
#line 66 
    supported_rates = tmp_0 | supported_rates;
  }
  else {
    u32 tmp_1;
    
#line 68 
    tmp_1 = wlcore_hw_ap_get_mimo_wide_rate_mask(wl,wlvif);
    
#line 69 
    supported_rates = tmp_1 | supported_rates;
  }
  
#line 70 
  if ((unsigned int)wlvif->p2p != 0U) 
#line 71 
                                      supported_rates &= 4294967256U; else ;
  
#line 72 
  cmd->local_supported_rates = supported_rates;
  
#line 73 
  cmd->channel_type = (unsigned char)wlvif->channel_type;
  
#line 75 
  ret = wl1271_cmd_send(wl,(unsigned short)20,(void *)cmd,16UL,0UL);
  
#line 76 
  if (ret < 0) {
    
#line 77 
    printk("\001");
    
#line 78 
    goto out_free;
  }
  else ;
  out_free: 
#line 81 
  ;
  
#line 82 
  kfree((void const *)cmd);
  out: 
#line 83 
  ;
  
#line 84 
  return ret;
}


#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/cmd.c"
int wl18xx_cmd_smart_config_start(struct wl1271 *wl, u32 group_bitmap)
{
  struct wl18xx_cmd_smart_config_start *cmd;
  
#line 90 
  int ret = 0;
  
#line 92 
  if ((long)((wl12xx_debug_level & 4096U) != 0U) != 0L) {
    
#line 92 
    struct _ddebug descriptor = {.modname = "wl18xx", .function = "wl18xx_cmd_smart_config_start", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/cmd.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))93U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 92 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 92 
                                                        __dynamic_pr_debug(& descriptor,"wlcore",group_bitmap); else ;
  }
  else ;
  
#line 95 
  cmd = (struct wl18xx_cmd_smart_config_start *)kzalloc_0(8UL,208U);
  
#line 96 
  if (cmd == (struct wl18xx_cmd_smart_config_start *)0) {
    
#line 97 
    ret = -12;
    
#line 98 
    goto out;
  }
  else ;
  
#line 101 
  cmd->group_id_bitmask = group_bitmap;
  
#line 103 
  ret = wl1271_cmd_send(wl,(unsigned short)61,(void *)cmd,8UL,0UL);
  
#line 104 
  if (ret < 0) {
    
#line 105 
    printk("\001");
    
#line 106 
    goto out_free;
  }
  else ;
  out_free: 
#line 109 
  ;
  
#line 110 
  kfree((void const *)cmd);
  out: 
#line 111 
  ;
  
#line 112 
  return ret;
}


#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/cmd.c"
int wl18xx_cmd_smart_config_stop(struct wl1271 *wl)
{
  struct wl1271_cmd_header *cmd;
  
#line 118 
  int ret = 0;
  
#line 120 
  if ((long)((wl12xx_debug_level & 4096U) != 0U) != 0L) {
    
#line 120 
    struct _ddebug descriptor = {.modname = "wl18xx", .function = "wl18xx_cmd_smart_config_stop", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/cmd.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))120U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 120 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 120 
                                                        __dynamic_pr_debug(& descriptor,"wlcore"); else ;
  }
  else ;
  
#line 122 
  cmd = (struct wl1271_cmd_header *)kzalloc_0(4UL,208U);
  
#line 123 
  if (cmd == (struct wl1271_cmd_header *)0) {
    
#line 124 
    ret = -12;
    
#line 125 
    goto out;
  }
  else ;
  
#line 128 
  ret = wl1271_cmd_send(wl,(unsigned short)62,(void *)cmd,4UL,0UL);
  
#line 129 
  if (ret < 0) {
    
#line 130 
    printk("\001");
    
#line 131 
    goto out_free;
  }
  else ;
  out_free: 
#line 134 
  ;
  
#line 135 
  kfree((void const *)cmd);
  out: 
#line 136 
  ;
  
#line 137 
  return ret;
}


#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/cmd.c"
int wl18xx_cmd_smart_config_set_group_key(struct wl1271 *wl, u16 group_id, u8 key_len, u8 *key)
{
  int __retres;
  struct wl18xx_cmd_smart_config_set_group_key *cmd;
  
#line 144 
  int ret = 0;
  
#line 146 
  if ((long)((wl12xx_debug_level & 4096U) != 0U) != 0L) {
    
#line 146 
    struct _ddebug descriptor = {.modname = "wl18xx", .function = "wl18xx_cmd_smart_config_set_group_key", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/cmd.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))147U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 146 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 146 
                                                        __dynamic_pr_debug(& descriptor,"wlcore",(int)group_id); else ;
  }
  else ;
  
#line 149 
  if ((unsigned int)key_len != 16U) {
    
#line 150 
    printk("\001",(int)key_len);
    
#line 151 
    __retres = -7;
    
#line 151 
    goto return_label;
  }
  else ;
  
#line 154 
  cmd = (struct wl18xx_cmd_smart_config_set_group_key *)kzalloc_0(24UL,208U);
  
#line 155 
  if (cmd == (struct wl18xx_cmd_smart_config_set_group_key *)0) {
    
#line 156 
    ret = -12;
    
#line 157 
    goto out;
  }
  else ;
  
#line 160 
  cmd->group_id = (unsigned int)group_id;
  
#line 161 
  memcpy((void *)(& cmd->key),(void const *)key,(unsigned long)key_len);
  
#line 163 
  ret = wl1271_cmd_send(wl,(unsigned short)63,(void *)cmd,24UL,0UL);
  
#line 165 
  if (ret < 0) {
    
#line 166 
    printk("\001");
    
#line 167 
    goto out_free;
  }
  else ;
  out_free: 
#line 170 
  ;
  
#line 171 
  kfree((void const *)cmd);
  out: 
#line 172 
  ;
  
#line 173 
  __retres = ret;
  return_label: 
#line 173 
                return __retres;
}


#line 176  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/cmd.c"
int wl18xx_cmd_set_cac(struct wl1271 *wl, struct wl12xx_vif *wlvif, bool start)
{
  int __retres;
  struct wlcore_cmd_cac_start *cmd;
  unsigned int tmp_1;
  
#line 179 
  int ret = 0;
  
#line 181 
  if ((long)((wl12xx_debug_level & 4096U) != 0U) != 0L) {
    
#line 181 
    struct _ddebug descriptor = {.modname = "wl18xx", .function = "wl18xx_cmd_set_cac", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/cmd.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))182U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 181 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      char *tmp;
      
#line 181 
      if ((int)start != 0) 
#line 181 
                           tmp = (char *)"start"; else 
#line 181 
                                                       tmp = (char *)"stop";
      
#line 181 
      ;
      
#line 181 
      __dynamic_pr_debug(& descriptor,"wlcore",wlvif->channel,tmp);
    }
    else ;
  }
  else ;
  
#line 184 
  cmd = (struct wlcore_cmd_cac_start *)kzalloc_0(8UL,208U);
  
#line 185 
  if (cmd == (struct wlcore_cmd_cac_start *)0) {
    
#line 186 
    __retres = -12;
    
#line 186 
    goto return_label;
  }
  else ;
  
#line 188 
  cmd->role_id = wlvif->role_id;
  
#line 189 
  cmd->channel = (unsigned char)wlvif->channel;
  
#line 190 
  if (wlvif->band == (unsigned int)IEEE80211_BAND_5GHZ) 
#line 191 
                                                        cmd->band = (unsigned char)1U; else ;
  
#line 192 
  cmd->bandwidth = wlcore_get_native_channel_type((unsigned char)((int)((unsigned char)wlvif->channel_type)));
  
#line 194 
  ;
  
#line 194 
  if ((int)start != 0) 
#line 194 
                       tmp_1 = 64U; else 
#line 194 
                                         tmp_1 = 65U;
  
#line 194 
  ;
  
#line 194 
  ret = wl1271_cmd_send(wl,(unsigned short)((int)tmp_1),(void *)cmd,8UL,0UL);
  
#line 197 
  if (ret < 0) {
    
#line 198 
    printk("\001");
    
#line 199 
    goto out_free;
  }
  else ;
  out_free: 
#line 202 
  ;
  
#line 203 
  kfree((void const *)cmd);
  
#line 204 
  __retres = ret;
  return_label: 
#line 204 
                return __retres;
}


#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/cmd.c"
int wl18xx_cmd_radar_detection_debug(struct wl1271 *wl, u8 channel)
{
  int __retres;
  struct wl18xx_cmd_dfs_radar_debug *cmd;
  
#line 210 
  int ret = 0;
  
#line 212 
  if ((long)((wl12xx_debug_level & 4096U) != 0U) != 0L) {
    
#line 212 
    struct _ddebug descriptor = {.modname = "wl18xx", .function = "wl18xx_cmd_radar_detection_debug", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/cmd.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))213U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 212 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 212 
                                                        __dynamic_pr_debug(& descriptor,"wlcore",(int)channel); else ;
  }
  else ;
  
#line 215 
  cmd = (struct wl18xx_cmd_dfs_radar_debug *)kzalloc_0(8UL,208U);
  
#line 216 
  if (cmd == (struct wl18xx_cmd_dfs_radar_debug *)0) {
    
#line 217 
    __retres = -12;
    
#line 217 
    goto return_label;
  }
  else ;
  
#line 219 
  cmd->channel = channel;
  
#line 221 
  ret = wl1271_cmd_send(wl,(unsigned short)67,(void *)cmd,8UL,0UL);
  
#line 223 
  if (ret < 0) {
    
#line 224 
    printk("\001");
    
#line 225 
    goto out_free;
  }
  else ;
  out_free: 
#line 228 
  ;
  
#line 229 
  kfree((void const *)cmd);
  
#line 230 
  __retres = ret;
  return_label: 
#line 230 
                return __retres;
}


#line 233  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/cmd.c"
int wl18xx_cmd_dfs_master_restart(struct wl1271 *wl, struct wl12xx_vif *wlvif)
{
  int __retres;
  struct wl18xx_cmd_dfs_master_restart *cmd;
  
#line 236 
  int ret = 0;
  
#line 238 
  if ((long)((wl12xx_debug_level & 4096U) != 0U) != 0L) {
    
#line 238 
    struct _ddebug descriptor = {.modname = "wl18xx", .function = "wl18xx_cmd_dfs_master_restart", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/cmd.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))239U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 238 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 238 
                                                        __dynamic_pr_debug(& descriptor,"wlcore",(int)wlvif->role_id); else ;
  }
  else ;
  
#line 241 
  cmd = (struct wl18xx_cmd_dfs_master_restart *)kzalloc_0(8UL,208U);
  
#line 242 
  if (cmd == (struct wl18xx_cmd_dfs_master_restart *)0) {
    
#line 243 
    __retres = -12;
    
#line 243 
    goto return_label;
  }
  else ;
  
#line 245 
  cmd->role_id = wlvif->role_id;
  
#line 247 
  ret = wl1271_cmd_send(wl,(unsigned short)66,(void *)cmd,8UL,0UL);
  
#line 249 
  if (ret < 0) {
    
#line 250 
    printk("\001");
    
#line 251 
    goto out_free;
  }
  else ;
  out_free: 
#line 253 
  ;
  
#line 254 
  kfree((void const *)cmd);
  
#line 255 
  __retres = ret;
  return_label: 
#line 255 
                return __retres;
}


#line 494  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_cmd.c.aux"
static void *kzalloc_0(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 497 
  tmp = ldv_kzalloc(size,flags);
  
#line 497 
  return tmp;
}


#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
void *memmove(void *, void const *, size_t);


#line 490  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
static bool ldv_queue_work_73(struct workqueue_struct *wq, struct work_struct *work);


#line 1508  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
void skb_queue_tail(struct sk_buff_head *, struct sk_buff *);


#line 1706 
unsigned char *skb_pull(struct sk_buff *, unsigned int);


#line 3682  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
unsigned int ieee80211_get_hdrlen_from_skb(struct sk_buff const *);


#line 918  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
__inline static struct ieee80211_tx_info *IEEE80211_SKB_CB(struct sk_buff *skb)
{
  struct ieee80211_tx_info *__retres;
  
#line 920 
  __retres = (struct ieee80211_tx_info *)(& skb->cb);
  
#line 920 
  return __retres;
}


#line 494  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore_i.h"
__inline static struct wl12xx_vif *wl12xx_vif_to_data(struct ieee80211_vif *vif)
{
  struct wl12xx_vif *__retres;
  {
    
#line 496 
    int __ret_warn_on = vif == (struct ieee80211_vif *)0;
    
#line 496 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 496 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/../wlcore/wlcore_i.h",496); else ;
    
#line 496 
    long tmp = (long)(__ret_warn_on != 0);
  }
  
#line 497 
  __retres = (struct wl12xx_vif *)(& vif->drv_priv);
  
#line 497 
  return __retres;
}


#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/tx.h"
bool wl12xx_is_dummy_packet(struct wl1271 *, struct sk_buff *);


#line 261 
void wl1271_free_tx_id(struct wl1271 *, int);


#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/tx.h"
void wl18xx_tx_immediate_complete(struct wl1271 *wl);


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/tx.c"
static void wl18xx_get_last_tx_rate(struct wl1271 *wl, struct ieee80211_vif *vif, u8 band, struct ieee80211_tx_rate *rate)
{
  
#line 35 
  u8 fw_rate = (wl->fw_status)->counters.tx_last_rate;
  
#line 37 
  if ((unsigned int)fw_rate > 29U) {
    
#line 38 
    printk("\001",(int)fw_rate);
    
#line 39 
    rate->idx = (signed char)0;
    
#line 40 
    rate->flags = (unsigned short __attribute__((__FRAMA_C_BITFIELD_SIZE__(11))))0U;
    
#line 41 
    goto return_label;
  }
  else ;
  
#line 44 
  if ((unsigned int)fw_rate <= 11U) {
    
#line 45 
    rate->idx = (signed char)fw_rate;
    
#line 46 
    if ((unsigned int)band == 1U) 
#line 47 
                                  rate->idx = (signed char)((unsigned int)rate->idx + 252U); else ;
    
#line 48 
    rate->flags = (unsigned short __attribute__((__FRAMA_C_BITFIELD_SIZE__(11))))0U;
  }
  else {
    
#line 50 
    rate->flags = (unsigned short __attribute__((__FRAMA_C_BITFIELD_SIZE__(11))))8U;
    
#line 51 
    rate->idx = (signed char)((unsigned int)fw_rate + 244U);
    
#line 54 
    if ((unsigned int)fw_rate > 19U) 
#line 55 
                                     rate->idx = (s8)((int)rate->idx - 1); else ;
    
#line 56 
    if ((unsigned int)fw_rate == 29U) 
#line 57 
                                      rate->idx = (s8)((int)rate->idx - 1); else ;
    
#line 60 
    if ((unsigned int)fw_rate == 20U || (unsigned int)fw_rate == 29U) 
      
#line 62 
      rate->flags = (unsigned short __attribute__((__FRAMA_C_BITFIELD_SIZE__(11))))((unsigned int)rate->flags | 128U); else ;
    
#line 64 
    if ((unsigned int)fw_rate > 20U && vif != (struct ieee80211_vif *)0) {
      
#line 65 
      struct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);
      
#line 66 
      if ((unsigned int)wlvif->channel_type + 4294967294U <= 1U) {
        
#line 69 
        rate->idx = (signed char)((unsigned int)rate->idx + 248U);
        
#line 70 
        rate->flags = (unsigned short __attribute__((__FRAMA_C_BITFIELD_SIZE__(11))))((unsigned int)rate->flags | 32U);
      }
      else ;
    }
    else ;
  }
  return_label: 
#line 74 
                return;
}


#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/tx.c"
static void wl18xx_tx_complete_packet(struct wl1271 *wl, u8 tx_stat_byte)
{
  struct ieee80211_tx_info *info;
  struct sk_buff *skb;
  bool tx_success;
  bool tmp;
  
#line 80 
  int id = (int)tx_stat_byte & 127;
  
#line 84 
  if ((long)(wl->num_tx_desc <= (unsigned int)id) != 0L || (long)(wl->tx_frames[id] == (struct sk_buff *)0) != 0L) {
    
#line 85 
    printk("\001",id);
    
#line 86 
    goto return_label;
  }
  else ;
  
#line 90 
  tx_success = (_Bool)((int)tx_stat_byte >= 0);
  
#line 92 
  skb = wl->tx_frames[id];
  
#line 93 
  info = IEEE80211_SKB_CB(skb);
  
#line 95 
  tmp = wl12xx_is_dummy_packet(wl,skb);
  
#line 95 
  if ((int)tmp != 0) {
    
#line 96 
    wl1271_free_tx_id(wl,id);
    
#line 97 
    goto return_label;
  }
  else ;
  
#line 101 
  if ((int)tx_success != 0 && (info->flags & 4U) == 0U) 
#line 102 
                                                        info->flags |= 512U; else ;
  
#line 107 
  wl18xx_get_last_tx_rate(wl,info->__anonCompField_ieee80211_tx_info_98.control.vif,(unsigned char)((int)info->band),& info->__anonCompField_ieee80211_tx_info_98.status.rates[0]);
  
#line 110 
  info->__anonCompField_ieee80211_tx_info_98.status.rates[0].count = (unsigned short __attribute__((__FRAMA_C_BITFIELD_SIZE__(5))))1U;
  
#line 111 
  info->__anonCompField_ieee80211_tx_info_98.status.ack_signal = -1;
  
#line 113 
  if (! tx_success) 
#line 114 
                    wl->stats.retry_count += 1U; else ;
  
#line 122 
  skb_pull(skb,16U);
  
#line 125 
  if ((((unsigned long)wl->quirks & 256UL) != 0UL && info->__anonCompField_ieee80211_tx_info_98.control.hw_key != (struct ieee80211_key_conf *)0) && (info->__anonCompField_ieee80211_tx_info_98.control.hw_key)->cipher == 1027074U) {
    unsigned int tmp_0;
    
#line 128 
    tmp_0 = ieee80211_get_hdrlen_from_skb((struct sk_buff const *)skb);
    
#line 128 
    int hdrlen = (int)tmp_0;
    
#line 129 
    memmove((void *)(skb->data + 4U),(void const *)skb->data,(unsigned long)hdrlen);
    
#line 130 
    skb_pull(skb,4U);
  }
  else ;
  
#line 133 
  if ((long)((wl12xx_debug_level & 64U) != 0U) != 0L) {
    
#line 133 
    struct _ddebug descriptor = {.modname = "wl18xx", .function = "wl18xx_tx_complete_packet", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/tx.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))134U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 133 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 133 
                                                        __dynamic_pr_debug(& descriptor,"wlcore",id,skb,(int)tx_success); else ;
  }
  else ;
  
#line 137 
  skb_queue_tail(& wl->deferred_tx_queue,skb);
  
#line 138 
  ldv_queue_work_73(wl->freezable_wq,& wl->netstack_work);
  
#line 139 
  wl1271_free_tx_id(wl,id);
  return_label: 
#line 140 
                return;
}


#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/tx.c"
void wl18xx_tx_immediate_complete(struct wl1271 *wl)
{
  u8 i;
  
#line 144 
  struct wl18xx_fw_status_priv *status_priv = (struct wl18xx_fw_status_priv *)(wl->fw_status)->priv;
  
#line 146 
  struct wl18xx_priv *priv = (struct wl18xx_priv *)wl->priv;
  
#line 150 
  if ((int)priv->last_fw_rls_idx == (int)status_priv->fw_release_idx) 
    
#line 151 
    goto return_label; else ;
  
#line 154 
  if ((long)((wl12xx_debug_level & 64U) != 0U) != 0L) {
    
#line 154 
    struct _ddebug descriptor = {.modname = "wl18xx", .function = "wl18xx_tx_immediate_complete", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/tx.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))155U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 154 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 154 
                                                        __dynamic_pr_debug(& descriptor,"wlcore",(int)priv->last_fw_rls_idx,(int)status_priv->fw_release_idx); else ;
  }
  else ;
  
#line 157 
  if ((unsigned int)status_priv->fw_release_idx > 32U) {
    
#line 158 
    printk("\001",(int)status_priv->fw_release_idx);
    {
      
#line 160 
      int __ret_warn_on = 1;
      
#line 160 
      if ((long)(__ret_warn_on != 0) != 0L) 
#line 160 
                                            warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/tx.c",160); else ;
      
#line 160 
      long tmp = (long)(__ret_warn_on != 0);
    }
    
#line 161 
    goto return_label;
  }
  else ;
  
#line 164 
  i = priv->last_fw_rls_idx;
  
#line 164 
  goto ldv_51985;
  ldv_51984: 
#line 165 
  ;
  
#line 167 
  wl18xx_tx_complete_packet(wl,(unsigned char)((int)status_priv->released_tx_desc[(int)i]));
  
#line 170 
  wl->tx_results_count += 1U;
  
#line 166 
  i = (unsigned char)(((int)i + 1) % 33);
  ldv_51985: 
#line 167 
  ;
  
#line 164 
  if ((int)status_priv->fw_release_idx != (int)i) 
#line 167 
                                                  goto ldv_51984; else 
                                                                    
#line 170 
                                                                    goto ldv_51986;
  ldv_51986: 
#line 171 
  ;
  
#line 173 
  priv->last_fw_rls_idx = status_priv->fw_release_idx;
  return_label: 
#line 174 
                return;
}


#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
_Bool ldv_emg_queue_work(struct workqueue_struct *arg0, struct work_struct *arg1);


#line 740  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static bool ldv_queue_work_73(struct workqueue_struct *wq, struct work_struct *work)
{
  bool __retres;
  bool tmp;
  
#line 744 
  tmp = ldv_emg_queue_work(wq,work);
  
#line 744 
  __retres = tmp != 0;
  
#line 744 
  return __retres;
}


#line 431  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
void print_hex_dump(char const *, char const *, int, int, int, void const *, size_t, bool);


#line 772  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
void kfree_skb(struct sk_buff *);


#line 253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netlink.h"
int nla_put(struct sk_buff *, int, int, void const *);


#line 801  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netlink.h"
__inline static int nla_put_u32(struct sk_buff *skb, int attrtype, u32 value)
{
  int tmp;
  
#line 803 
  tmp = nla_put(skb,attrtype,4,(void const *)(& value));
  
#line 803 
  return tmp;
}


#line 3528  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
int ieee80211_channel_to_frequency(int, enum ieee80211_band);


#line 4296 
struct sk_buff *__cfg80211_alloc_event_skb(struct wiphy *, struct wireless_dev *, enum nl80211_commands, enum nl80211_attrs, int, int, gfp_t);


#line 4303 
void __cfg80211_send_event_skb(struct sk_buff *, gfp_t);


#line 4371  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
__inline static struct sk_buff *cfg80211_vendor_event_alloc(struct wiphy *wiphy, struct wireless_dev *wdev, int approxlen, int event_idx, gfp_t gfp)
{
  struct sk_buff *tmp;
  
#line 4374 
  tmp = __cfg80211_alloc_event_skb(wiphy,wdev,(enum nl80211_commands)NL80211_CMD_VENDOR,(enum nl80211_attrs)NL80211_ATTR_VENDOR_DATA,event_idx,approxlen,gfp);
  
#line 4374 
  return tmp;
}


#line 4387  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
__inline static void cfg80211_vendor_event(struct sk_buff *skb, gfp_t gfp)
{
  
#line 4389 
  __cfg80211_send_event_skb(skb,gfp);
  
#line 4390 
  return;
}


#line 4978  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
void ieee80211_radar_detected(struct ieee80211_hw *);


#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/event.h"
void wlcore_event_sched_scan_completed(struct wl1271 *, u8);


#line 75 
void wlcore_event_ba_rx_constraint(struct wl1271 *, unsigned long, unsigned long);


#line 78 
void wlcore_event_channel_switch(struct wl1271 *, unsigned long, bool);


#line 81 
void wlcore_event_beacon_loss(struct wl1271 *, unsigned long);


#line 82 
void wlcore_event_dummy_packet(struct wl1271 *);


#line 83 
void wlcore_event_max_tx_failure(struct wl1271 *, unsigned long);


#line 84 
void wlcore_event_inactive_sta(struct wl1271 *, unsigned long);


#line 85 
void wlcore_event_roc_complete(struct wl1271 *);


#line 86 
void wlcore_event_rssi_trigger(struct wl1271 *, s8 *);


#line 107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/event.h"
int wl18xx_wait_for_event(struct wl1271 *wl, enum wlcore_wait_event event, bool *timeout);


#line 109 
int wl18xx_process_mailbox_events(struct wl1271 *wl);


#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/cmd.h"
int wlcore_cmd_wait_for_event_or_timeout(struct wl1271 *, u32, bool *);


#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/scan.h"
void wlcore_scan_sched_scan_results(struct wl1271 *);


#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/scan.h"
void wl18xx_scan_completed(struct wl1271 *wl, struct wl12xx_vif *wlvif);


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/event.c"
int wl18xx_wait_for_event(struct wl1271 *wl, enum wlcore_wait_event event, bool *timeout)
{
  int __retres;
  u32 local_event;
  int tmp;
  
#line 34 
  switch ((unsigned int)event) {
    case (unsigned int)1: 
#line 35 
    ;
    
#line 36 
    local_event = 32768U;
    
#line 37 
    goto ldv_51874;
    case (unsigned int)2: 
#line 39 
    ;
    
#line 40 
    local_event = 524288U;
    
#line 41 
    goto ldv_51874;
    default: 
#line 43 
    ;
    
#line 45 
    __retres = 0;
    
#line 45 
    goto return_label;
  }
  ldv_51874: 
#line 47 
  ;
  
#line 47 
  tmp = wlcore_cmd_wait_for_event_or_timeout(wl,local_event,timeout);
  
#line 47 
  __retres = tmp;
  return_label: 
#line 47 
                return __retres;
}


#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/event.c"
static char const *wl18xx_radar_type_decode(u8 radar_type)
{
  char const *__retres;
  
#line 52 
  switch ((int)radar_type) {
    case 1: 
#line 53 
    ;
    
#line 54 
    __retres = "REGULAR";
    
#line 54 
    goto return_label;
    case 2: 
#line 55 
    ;
    
#line 56 
    __retres = "CHIRP";
    
#line 56 
    goto return_label;
    case 0: 
#line 57 
    ;
    default: 
#line 58 
    ;
    
#line 59 
    __retres = "N/A";
    
#line 59 
    goto return_label;
  }
  return_label: 
#line 52 
                return __retres;
}


#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/event.c"
static int wlcore_smart_config_sync_event(struct wl1271 *wl, u8 sync_channel, u8 sync_band)
{
  int __retres;
  struct sk_buff *skb;
  enum ieee80211_band band;
  int freq;
  int tmp;
  
#line 70 
  if ((unsigned int)sync_band == 1U) 
#line 71 
                                     band = IEEE80211_BAND_5GHZ; else 
                                                                   
#line 73 
                                                                   band = IEEE80211_BAND_2GHZ;
  
#line 75 
  freq = ieee80211_channel_to_frequency((int)sync_channel,band);
  
#line 77 
  if ((long)((wl12xx_debug_level & 32U) != 0U) != 0L) {
    
#line 77 
    struct _ddebug descriptor = {.modname = "wl18xx", .function = "wlcore_smart_config_sync_event", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/event.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))79U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 77 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 77 
                                                        __dynamic_pr_debug(& descriptor,"wlcore",freq,(int)sync_channel,(int)sync_band); else ;
  }
  else ;
  
#line 80 
  skb = cfg80211_vendor_event_alloc((wl->hw)->wiphy,(struct wireless_dev *)0,20,0,208U);
  
#line 84 
  tmp = nla_put_u32(skb,0,(unsigned int)freq);
  
#line 84 
  if (tmp != 0) {
    
#line 85 
    kfree_skb(skb);
    
#line 86 
    __retres = -90;
    
#line 86 
    goto return_label;
  }
  else ;
  
#line 88 
  cfg80211_vendor_event(skb,208U);
  
#line 89 
  __retres = 0;
  return_label: 
#line 89 
                return __retres;
}


#line 92  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/event.c"
static int wlcore_smart_config_decode_event(struct wl1271 *wl, u8 ssid_len, u8 *ssid, u8 pwd_len, u8 *pwd)
{
  int __retres;
  struct sk_buff *skb;
  int tmp_1;
  
#line 98 
  if ((long)((wl12xx_debug_level & 32U) != 0U) != 0L) {
    
#line 98 
    struct _ddebug descriptor = {.modname = "wl18xx", .function = "wlcore_smart_config_decode_event", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/event.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))98U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 98 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 98 
                                                        __dynamic_pr_debug(& descriptor,"wlcore"); else ;
  }
  else ;
  
#line 99 
  if ((wl12xx_debug_level & 32U) != 0U) {
    
#line 99 
    struct _ddebug descriptor_0 = {.modname = "wl18xx", .function = "wlcore_smart_config_decode_event", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/event.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))99U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 99 
    if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) {
      size_t tmp_0;
      {
        size_t tmp;
        
#line 99 
        size_t __min1 = (unsigned long)ssid_len;
        
#line 99 
        size_t __min2 = 1024UL;
        
#line 99 
        if (__min1 < __min2) 
#line 99 
                             tmp = __min1; else 
#line 99 
                                                tmp = __min2;
        
#line 99 
        tmp_0 = tmp;
      }
      
#line 99 
      ;
      
#line 99 
      print_hex_dump("\001","wlcore",2,16,1,(void const *)ssid,tmp_0,(_Bool)1);
    }
    else ;
  }
  else ;
  
#line 101 
  skb = cfg80211_vendor_event_alloc((wl->hw)->wiphy,(struct wireless_dev *)0,((int)ssid_len + (int)pwd_len) + 20,1,208U);
  
#line 106 
  tmp_1 = nla_put(skb,2,(int)ssid_len,(void const *)ssid);
  
#line 106 
  if (tmp_1 != 0) 
#line 106 
                  goto _LOR;
  else {
    int tmp_2;
    
#line 106 
    tmp_2 = nla_put(skb,1,(int)pwd_len,(void const *)pwd);
    
#line 106 
    if (tmp_2 != 0) {
      _LOR: {
              
#line 108 
              kfree_skb(skb);
              
#line 109 
              __retres = -90;
              
#line 109 
              goto return_label;
            }
    }
    else ;
  }
  
#line 111 
  cfg80211_vendor_event(skb,208U);
  
#line 112 
  __retres = 0;
  return_label: 
#line 112 
                return __retres;
}


#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/event.c"
int wl18xx_process_mailbox_events(struct wl1271 *wl)
{
  int __retres;
  u32 vector;
  
#line 117 
  struct wl18xx_event_mailbox *mbox = (struct wl18xx_event_mailbox *)wl->mbox;
  
#line 120 
  vector = mbox->events_vector;
  
#line 121 
  if ((long)((wl12xx_debug_level & 32U) != 0U) != 0L) {
    
#line 121 
    struct _ddebug descriptor = {.modname = "wl18xx", .function = "wl18xx_process_mailbox_events", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/event.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))121U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 121 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 121 
                                                        __dynamic_pr_debug(& descriptor,"wlcore",vector); else ;
  }
  else ;
  
#line 123 
  if ((vector & 256U) != 0U) {
    
#line 124 
    if ((long)((wl12xx_debug_level & 32U) != 0U) != 0L) {
      
#line 124 
      struct _ddebug descriptor_0 = {.modname = "wl18xx", .function = "wl18xx_process_mailbox_events", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/event.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))125U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 124 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 124 
                                                            __dynamic_pr_debug(& descriptor_0,"wlcore",(int)mbox->number_of_scan_results); else ;
    }
    else ;
    
#line 127 
    if (wl->scan_wlvif != (struct wl12xx_vif *)0) 
#line 128 
                                                  wl18xx_scan_completed(wl,wl->scan_wlvif); else ;
  }
  else ;
  
#line 131 
  if ((vector & 512U) != 0U) {
    char const *tmp;
    
#line 132 
    tmp = wl18xx_radar_type_decode((unsigned char)((int)mbox->radar_type));
    
#line 132 
    ;
    
#line 132 
    printk("\001",(int)mbox->radar_channel,tmp);
    
#line 136 
    ieee80211_radar_detected(wl->hw);
  }
  else ;
  
#line 139 
  if ((vector & 1048576U) != 0U) {
    
#line 140 
    if ((long)((wl12xx_debug_level & 32U) != 0U) != 0L) {
      
#line 140 
      struct _ddebug descriptor_1 = {.modname = "wl18xx", .function = "wl18xx_process_mailbox_events", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/event.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))142U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 140 
      if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) 
#line 140 
                                                            __dynamic_pr_debug(& descriptor_1,"wlcore",(int)mbox->number_of_sched_scan_results); else ;
    }
    else ;
    
#line 144 
    wlcore_scan_sched_scan_results(wl);
  }
  else ;
  
#line 147 
  if ((vector & 65536U) != 0U) 
#line 148 
                               wlcore_event_sched_scan_completed(wl,(unsigned char)1); else ;
  
#line 150 
  if ((vector & 1U) != 0U) 
#line 151 
                           wlcore_event_rssi_trigger(wl,(s8 *)(& mbox->rssi_snr_trigger_metric)); else ;
  
#line 153 
  if ((vector & 131072U) != 0U) 
#line 154 
                                wlcore_event_ba_rx_constraint(wl,(unsigned long)mbox->rx_ba_role_id_bitmap,(unsigned long)mbox->rx_ba_allowed_bitmap); else ;
  
#line 158 
  if ((vector & 2048U) != 0U) 
#line 159 
                              wlcore_event_beacon_loss(wl,(unsigned long)mbox->bss_loss_bitmap); else ;
  
#line 162 
  if ((vector & 1024U) != 0U) 
#line 163 
                              wlcore_event_channel_switch(wl,(unsigned long)mbox->channel_switch_role_id_bitmap,(_Bool)1); else ;
  
#line 167 
  if ((vector & 8192U) != 0U) 
#line 168 
                              wlcore_event_dummy_packet(wl); else ;
  
#line 174 
  if ((vector & 4096U) != 0U) 
#line 175 
                              wlcore_event_max_tx_failure(wl,(unsigned long)mbox->tx_retry_exceeded_bitmap); else ;
  
#line 178 
  if ((vector & 16384U) != 0U) 
#line 179 
                               wlcore_event_inactive_sta(wl,(unsigned long)mbox->inactive_sta_bitmap); else ;
  
#line 182 
  if ((vector & 262144U) != 0U) 
#line 183 
                                wlcore_event_roc_complete(wl); else ;
  
#line 185 
  if ((vector & 4194304U) != 0U) 
#line 186 
                                 wlcore_smart_config_sync_event(wl,(unsigned char)((int)mbox->sc_sync_channel),(unsigned char)((int)mbox->sc_sync_band)); else ;
  
#line 189 
  if ((vector & 8388608U) != 0U) 
#line 190 
                                 wlcore_smart_config_decode_event(wl,(unsigned char)((int)mbox->sc_ssid_len),(u8 *)(& mbox->sc_ssid),(unsigned char)((int)mbox->sc_pwd_len),(u8 *)(& mbox->sc_pwd)); else ;
  
#line 196 
  __retres = 0;
  
#line 196 
  return __retres;
}


#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/export.h"
extern struct module __this_module;


#line 314  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(long nr, unsigned long const volatile *addr)
{
  int oldbit;
  
#line 317 
  ldv_inline_asm();
  
#line 323 
  return oldbit;
}


#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
void *memset(void *, int, size_t);


#line 67 
int strcmp(char const *, char const *);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/string.h"
char *strncpy(char *, char const *, __kernel_size_t);


#line 121 
void *kmemdup(void const *, size_t, gfp_t);


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/err.h"
static long PTR_ERR(void const *ptr);


#line 41 
static bool IS_ERR(void const *ptr);


#line 27  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/err.h"
long ldv_is_err(void const *ptr);


#line 30 
long ldv_ptr_err(void const *ptr);


#line 197  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/platform_device.h"
static int ldv___platform_driver_register_73(struct platform_driver *ldv_func_arg1, struct module *ldv_func_arg2);


#line 202 
static void ldv_platform_driver_unregister_74(struct platform_driver *ldv_func_arg1);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/random.h"
void get_random_bytes(void *, int);


#line 1897  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_network_header(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 1899 
  __retres = skb->head + (int)skb->network_header;
  
#line 1899 
  return __retres;
}


#line 1913  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_mac_header(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 1915 
  __retres = skb->head + (int)skb->mac_header;
  
#line 1915 
  return __retres;
}


#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/firmware.h"
int request_firmware(struct firmware const **, char const *, struct device *);


#line 51 
void release_firmware(struct firmware const *);


#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/delay.h"
void __const_udelay(unsigned long);


#line 236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/irq.h"
__inline static u32 irqd_get_trigger_type(struct irq_data *d)
{
  u32 __retres;
  
#line 238 
  __retres = (d->common)->state_use_accessors & 15U;
  
#line 238 
  return __retres;
}


#line 602 
struct irq_data *irq_get_irq_data(unsigned int);


#line 648  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/irq.h"
__inline static u32 irq_get_trigger_type(unsigned int irq)
{
  u32 tmp_1;
  
#line 650 
  struct irq_data *d = irq_get_irq_data(irq);
  
#line 651 
  if (d != (struct irq_data *)0) 
#line 651 
                                 tmp_1 = irqd_get_trigger_type(d); else 
                                                                    
#line 651 
                                                                    tmp_1 = 0U;
  
#line 651 
  return tmp_1;
}


#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static void eth_random_addr(u8 *addr)
{
  
#line 220 
  get_random_bytes((void *)addr,6);
  
#line 221 
  *addr = (unsigned char)((unsigned int)*addr & 254U);
  
#line 222 
  *addr = (unsigned char)((unsigned int)*addr | 2U);
  
#line 223 
  return;
}


#line 4924  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
void ieee80211_connection_loss(struct ieee80211_vif *);


#line 501  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore_i.h"
__inline static struct ieee80211_vif *wl12xx_wlvif_to_vif(struct wl12xx_vif *wlvif)
{
  struct ieee80211_vif *tmp;
  {
    
#line 503 
    u8 const (*__mptr)[0U] = (u8 const (*)[0U])wlvif;
    
#line 503 
    tmp = (struct ieee80211_vif *)__mptr + 18446744073709551320U;
  }
  
#line 503 
  return tmp;
}


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/boot.h"
int wlcore_boot_upload_firmware(struct wl1271 *);


#line 31 
int wlcore_boot_run_firmware(struct wl1271 *);


#line 505  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore.h"
int wlcore_probe(struct wl1271 *, struct platform_device *);


#line 506 
int wlcore_remove(struct platform_device *);


#line 507 
struct ieee80211_hw *wlcore_alloc_hw(size_t, u32, u32);


#line 509 
int wlcore_free_hw(struct wl1271 *);


#line 510 
int wlcore_set_key(struct wl1271 *, enum set_key_cmd, struct ieee80211_vif *, struct ieee80211_sta *, struct ieee80211_key_conf *);


#line 519  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore.h"
__inline static void wlcore_set_ht_cap(struct wl1271 *wl, enum ieee80211_band band, struct ieee80211_sta_ht_cap *ht_cap)
{
  
#line 522 
  memcpy((void *)(& wl->ht_cap[(unsigned int)band]),(void const *)ht_cap,22UL);
  
#line 523 
  return;
}


#line 529  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/wlcore.h"
__inline static void wlcore_set_min_fw_ver(struct wl1271 *wl, unsigned int chip, unsigned int iftype_sr, unsigned int major_sr, unsigned int subtype_sr, unsigned int minor_sr, unsigned int iftype_mr, unsigned int major_mr, unsigned int subtype_mr, unsigned int minor_mr)
{
  
#line 535 
  wl->min_sr_fw_ver[0] = chip;
  
#line 536 
  wl->min_sr_fw_ver[1] = iftype_sr;
  
#line 537 
  wl->min_sr_fw_ver[2] = major_sr;
  
#line 538 
  wl->min_sr_fw_ver[3] = subtype_sr;
  
#line 539 
  wl->min_sr_fw_ver[4] = minor_sr;
  
#line 541 
  wl->min_mr_fw_ver[0] = chip;
  
#line 542 
  wl->min_mr_fw_ver[1] = iftype_mr;
  
#line 543 
  wl->min_mr_fw_ver[2] = major_mr;
  
#line 544 
  wl->min_mr_fw_ver[3] = subtype_mr;
  
#line 545 
  wl->min_mr_fw_ver[4] = minor_mr;
  
#line 546 
  return;
}


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/io.h"
void wlcore_disable_interrupts(struct wl1271 *);


#line 49 
void wlcore_enable_interrupts(struct wl1271 *);


#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/io.h"
__inline static int wlcore_write(struct wl1271 *wl, int addr, void *buf, size_t len, bool fixed)
{
  int physical;
  int tmp;
  
#line 146 
  physical = wlcore_translate_addr(wl,addr);
  
#line 148 
  tmp = wlcore_raw_write(wl,physical,buf,len,(_Bool)((bool)((int)fixed) != 0));
  
#line 148 
  return tmp;
}


#line 192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/io.h"
__inline static int wlcore_read_reg(struct wl1271 *wl, int reg, u32 *val)
{
  int tmp_0;
  int tmp;
  
#line 195 
  ;
  
#line 195 
  tmp = wlcore_translate_addr(wl,*(wl->rtable + reg));
  
#line 195 
  ;
  
#line 195 
  tmp_0 = wlcore_raw_read32(wl,tmp,val);
  
#line 195 
  return tmp_0;
}


#line 200  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/io.h"
__inline static int wlcore_write_reg(struct wl1271 *wl, int reg, u32 val)
{
  int tmp_0;
  int tmp;
  
#line 203 
  ;
  
#line 203 
  tmp = wlcore_translate_addr(wl,*(wl->rtable + reg));
  
#line 203 
  ;
  
#line 203 
  tmp_0 = wlcore_raw_write32(wl,tmp,val);
  
#line 203 
  return tmp_0;
}


#line 229 
int wlcore_set_partition(struct wl1271 *, struct wlcore_partition_set const *);


#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/scan.h"
int wl18xx_scan_start(struct wl1271 *wl, struct wl12xx_vif *wlvif, struct cfg80211_scan_request *req);


#line 121 
int wl18xx_scan_stop(struct wl1271 *wl, struct wl12xx_vif *wlvif);


#line 123 
int wl18xx_sched_scan_start(struct wl1271 *wl, struct wl12xx_vif *wlvif, struct cfg80211_sched_scan_request *req, struct ieee80211_scan_ies *ies);


#line 126 
void wl18xx_scan_sched_scan_stop(struct wl1271 *wl, struct wl12xx_vif *wlvif);


#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.h"
int wl18xx_debugfs_add_files(struct wl1271 *wl, struct dentry *rootdir);


#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static char *ht_mode_param = (char *)0;

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static char *board_type_param = (char *)0;

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static bool checksum_param = (_Bool)0;

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int num_rx_desc_param = -1;

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int dc2dc_param = -1;

#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int n_antennas_2_param = -1;

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int n_antennas_5_param = -1;

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int low_band_component_param = -1;

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int low_band_component_type_param = -1;

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int high_band_component_param = -1;

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int high_band_component_type_param = -1;

#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int pwr_limit_reference_11_abg_param = -1;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static u8 const wl18xx_rate_to_idx_2ghz[29U] = {(unsigned char)15U, (unsigned char)14U, (unsigned char)13U, (unsigned char)12U, (unsigned char)11U, (unsigned char)10U, (unsigned char)9U, (unsigned char)8U, (unsigned char)7U, (unsigned char)6U, (unsigned char)5U, (unsigned char)4U, (unsigned char)3U, (unsigned char)2U, (unsigned char)1U, (unsigned char)0U, (unsigned char)11U, (unsigned char)10U, (unsigned char)9U, (unsigned char)8U, (unsigned char)255U, (unsigned char)7U, (unsigned char)6U, (unsigned char)3U, (unsigned char)5U, (unsigned char)4U, (unsigned char)2U, (unsigned char)1U, (unsigned char)0U};

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static u8 const wl18xx_rate_to_idx_5ghz[29U] = {(unsigned char)15U, (unsigned char)14U, (unsigned char)13U, (unsigned char)12U, (unsigned char)11U, (unsigned char)10U, (unsigned char)9U, (unsigned char)8U, (unsigned char)7U, (unsigned char)6U, (unsigned char)5U, (unsigned char)4U, (unsigned char)3U, (unsigned char)2U, (unsigned char)1U, (unsigned char)0U, (unsigned char)7U, (unsigned char)6U, (unsigned char)5U, (unsigned char)4U, (unsigned char)255U, (unsigned char)3U, (unsigned char)2U, (unsigned char)255U, (unsigned char)1U, (unsigned char)0U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U};

#line 139  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static u8 const *wl18xx_band_rate_to_idx[2U] = {(u8 const *)(& wl18xx_rate_to_idx_2ghz), (u8 const *)(& wl18xx_rate_to_idx_5ghz)};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static struct wlcore_conf wl18xx_conf = {.sg = {.params = {10U, 180U, 10U, 180U, 10U, 80U, 10U, 80U, 8U, 8U, 20U, 20U, 20U, 35U, 16U, 35U, 32U, 50U, 28U, 50U, 10U, 20U, 75U, 15U, 27U, 17U, 170U, 50U, 100U, 800U, 200U, 200U, 0U, 0U, 0U, 1U, 0U, 60U, 5000U, 1200U, 1000U, 1U, 3U, 6U, 10U, 10U, 2U, 5U, 30U, 3U, 10U, 2U, 0U, 25U, 25U, 0U, 0U}, .state = (unsigned char)1U}, .rx = {.rx_msdu_life_time = 512000U, .packet_detection_threshold = 0U, .ps_poll_timeout = (unsigned short)15U, .upsd_timeout = (unsigned short)15U, .rts_threshold = (unsigned short)2353U, .rx_cca_threshold = (unsigned short)0U, .irq_blk_threshold = (unsigned short)65535U, .irq_pkt_threshold = (unsigned short)0U, .irq_timeout = (unsigned short)600U, .queue_type = (unsigned char)0U}, .tx = {.tx_energy_detection = (unsigned char)0U, .sta_rc_conf = {.enabled_rates = 0U, .short_retry_limit = (unsigned char)10U, .long_retry_limit = (unsigned char)10U, .aflags = (unsigned char)0U}, .ac_conf_count = (unsigned char)4U, .ac_conf = {{.ac = (unsigned char)0U, .cw_min = (unsigned char)15U, .cw_max = (unsigned short)63U, .aifsn = (unsigned char)3U, .tx_op_limit = (unsigned short)0U}, {.ac = (unsigned char)1U, .cw_min = (unsigned char)15U, .cw_max = (unsigned short)63U, .aifsn = (unsigned char)7U, .tx_op_limit = (unsigned short)0U}, {.ac = (unsigned char)2U, .cw_min = (unsigned char)15U, .cw_max = (unsigned short)63U, .aifsn = (unsigned char)1U, .tx_op_limit = (unsigned short)3008U}, {.ac = (unsigned char)3U, .cw_min = (unsigned char)15U, .cw_max = (unsigned short)63U, .aifsn = (unsigned char)1U, .tx_op_limit = (unsigned short)1504U}}, .max_tx_retries = (unsigned char)100U, .ap_aging_period = (unsigned short)300U, .tid_conf_count = (unsigned char)4U, .tid_conf = {{.queue_id = (unsigned char)0U, .channel_type = (unsigned char)1U, .tsid = (unsigned char)0U, .ps_scheme = (unsigned char)0U, .ack_policy = (unsigned char)0U, .apsd_conf = {0U, 0U}}, {.queue_id = (unsigned char)1U, .channel_type = (unsigned char)1U, .tsid = (unsigned char)1U, .ps_scheme = (unsigned char)0U, .ack_policy = (unsigned char)0U, .apsd_conf = {0U, 0U}}, {.queue_id = (unsigned char)2U, .channel_type = (unsigned char)1U, .tsid = (unsigned char)2U, .ps_scheme = (unsigned char)0U, .ack_policy = (unsigned char)0U, .apsd_conf = {0U, 0U}}, {.queue_id = (unsigned char)3U, .channel_type = (unsigned char)1U, .tsid = (unsigned char)3U, .ps_scheme = (unsigned char)0U, .ack_policy = (unsigned char)0U, .apsd_conf = {0U, 0U}}}, .frag_threshold = (unsigned short)2352U, .tx_compl_timeout = (unsigned short)350U, .tx_compl_threshold = (unsigned short)10U, .basic_rate = 1U, .basic_rate_5 = 8U, .tmpl_short_retry_limit = (unsigned char)10U, .tmpl_long_retry_limit = (unsigned char)10U, .tx_watchdog_timeout = 5000U, .slow_link_thold = (unsigned char)3U, .fast_link_thold = (unsigned char)30U}, .conn = {.wake_up_event = (unsigned char)2U, .listen_interval = (unsigned char)1U, .suspend_wake_up_event = (unsigned char)4U, .suspend_listen_interval = (unsigned char)3U, .bcn_filt_mode = (unsigned char)1U, .bcn_filt_ie_count = (unsigned char)3U, .bcn_filt_ie = {{.ie = (unsigned char)37U, .rule = (unsigned char)2U, .oui = {(unsigned char)0, (unsigned char)0, (unsigned char)0}, .type = (unsigned char)0, .version = {(unsigned char)0, (unsigned char)0}}, {.ie = (unsigned char)61U, .rule = (unsigned char)1U, .oui = {(unsigned char)0, (unsigned char)0, (unsigned char)0}, .type = (unsigned char)0, .version = {(unsigned char)0, (unsigned char)0}}, {.ie = (unsigned char)42U, .rule = (unsigned char)1U, .oui = {(unsigned char)0, (unsigned char)0, (unsigned char)0}, .type = (unsigned char)0, .version = {(unsigned char)0, (unsigned char)0}}}, .synch_fail_thold = 12U, .bss_lose_timeout = 400U, .beacon_rx_timeout = 10000U, .broadcast_timeout = 20000U, .rx_broadcast_in_ps = (unsigned char)1U, .ps_poll_threshold = (unsigned char)10U, .sig_weights = {.rssi_bcn_avg_weight = (unsigned char)0, .rssi_pkt_avg_weight = (unsigned char)0, .snr_bcn_avg_weight = (unsigned char)0, .snr_pkt_avg_weight = (unsigned char)0}, .bet_enable = (unsigned char)1U, .bet_max_consecutive = (unsigned char)50U, .psm_entry_retries = (unsigned char)8U, .psm_exit_retries = (unsigned char)16U, .psm_entry_nullfunc_retries = (unsigned char)3U, .dynamic_ps_timeout = (unsigned short)1500U, .forced_ps = (unsigned char)0U, .keep_alive_interval = 55000U, .max_listen_interval = (unsigned char)20U, .sta_sleep_auth = (unsigned char)255U, .suspend_rx_ba_activity = (unsigned char)0U}, .itrim = {.enable = (unsigned char)0U, .timeout = 50000U}, .pm_config = {.host_clk_settling_time = 5000U, .host_fast_wakeup_support = (unsigned char)1U}, .roam_trigger = {.trigger_pacing = (unsigned short)1U, .avg_weight_rssi_beacon = (unsigned char)20U, .avg_weight_rssi_data = (unsigned char)10U, .avg_weight_snr_beacon = (unsigned char)20U, .avg_weight_snr_data = (unsigned char)10U}, .scan = {.min_dwell_time_active = 7500U, .max_dwell_time_active = 30000U, .min_dwell_time_active_long = 25000U, .max_dwell_time_active_long = 50000U, .dwell_time_passive = 100000U, .dwell_time_dfs = 150000U, .num_probe_reqs = (unsigned short)2U, .split_scan_timeout = 50000U}, .sched_scan = {.base_dwell_time = 7500U, .max_dwell_time_delta = 22500U, .dwell_time_delta_per_probe = 2000U, .dwell_time_delta_per_probe_5 = 350U, .dwell_time_passive = 100000U, .dwell_time_dfs = 150000U, .num_probe_reqs = (unsigned char)2U, .rssi_threshold = (signed char)(-90), .snr_threshold = (signed char)0}, .ht = {.rx_ba_win_size = (unsigned char)32U, .tx_ba_win_size = (unsigned char)64U, .inactivity_timeout = (unsigned short)10000U, .tx_ba_tid_bitmap = (unsigned char)63U}, .mem = {.num_stations = (unsigned char)1U, .ssid_profiles = (unsigned char)1U, .rx_block_num = (unsigned char)40U, .tx_min_block_num = (unsigned char)40U, .dynamic_memory = (unsigned char)1U, .min_req_tx_blocks = (unsigned char)45U, .min_req_rx_blocks = (unsigned char)22U, .tx_min = (unsigned char)27U}, .fm_coex = {.enable = (unsigned char)1U, .swallow_period = (unsigned char)5U, .n_divider_fref_set_1 = (unsigned char)255U, .n_divider_fref_set_2 = (unsigned char)12U, .m_divider_fref_set_1 = (unsigned short)65535U, .m_divider_fref_set_2 = (unsigned short)148U, .coex_pll_stabilization_time = 4294967295U, .ldo_stabilization_time = (unsigned short)65535U, .fm_disturbed_band_margin = (unsigned char)255U, .swallow_clk_diff = (unsigned char)255U}, .rx_streaming = {.duration = 150U, .queues = (unsigned char)1U, .interval = (unsigned char)20U, .always = (unsigned char)0U}, .fwlog = {.mode = (unsigned char)0U, .mem_blocks = (unsigned char)2U, .severity = (unsigned char)0U, .timestamp = (unsigned char)0U, .output = (unsigned char)1U, .threshold = (unsigned char)0U}, .rate = {.rate_retry_score = (unsigned short)32000U, .per_add = (unsigned short)8192U, .per_th1 = (unsigned short)2048U, .per_th2 = (unsigned short)4096U, .max_per = (unsigned short)8100U, .inverse_curiosity_factor = (unsigned char)5U, .tx_fail_low_th = (unsigned char)4U, .tx_fail_high_th = (unsigned char)10U, .per_alpha_shift = (unsigned char)4U, .per_add_shift = (unsigned char)13U, .per_beta1_shift = (unsigned char)10U, .per_beta2_shift = (unsigned char)8U, .rate_check_up = (unsigned char)2U, .rate_check_down = (unsigned char)12U, .rate_retry_policy = {(unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U}}, .hangover = {.recover_time = 0U, .hangover_period = (unsigned char)20U, .dynamic_mode = (unsigned char)1U, .early_termination_mode = (unsigned char)1U, .max_period = (unsigned char)20U, .min_period = (unsigned char)1U, .increase_delta = (unsigned char)1U, .decrease_delta = (unsigned char)2U, .quiet_time = (unsigned char)4U, .increase_time = (unsigned char)1U, .window_size = (unsigned char)16U}, .recovery = {.bug_on_recovery = (unsigned char)0U, .no_recovery = (unsigned char)0U}};

#line 508  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static struct wl18xx_priv_conf wl18xx_default_priv_conf = {.ht = {.mode = (unsigned char)1U}, .phy = {.phy_standalone = (unsigned char)0U, .spare0 = (unsigned char)0, .enable_clpc = (unsigned char)0U, .enable_tx_low_pwr_on_siso_rdl = (unsigned char)0U, .auto_detect = (unsigned char)0U, .dedicated_fem = (unsigned char)0U, .low_band_component = (unsigned char)2U, .low_band_component_type = (unsigned char)5U, .high_band_component = (unsigned char)1U, .high_band_component_type = (unsigned char)9U, .number_of_assembled_ant2_4 = (unsigned char)2U, .number_of_assembled_ant5 = (unsigned char)1U, .pin_muxing_platform_options = {(unsigned char)0, (unsigned char)0}, .external_pa_dc2dc = (unsigned char)0U, .tcxo_ldo_voltage = (unsigned char)0U, .xtal_itrim_val = (unsigned char)4U, .srf_state = (unsigned char)0U, .srf1 = {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}, .srf2 = {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}, .srf3 = {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}, .io_configuration = (unsigned char)1U, .sdio_configuration = (unsigned char)0U, .settings = (unsigned char)0U, .rx_profile = (unsigned char)0U, .per_chan_pwr_limit_arr_11abg = {(unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U}, .pwr_limit_reference_11_abg = (unsigned char)100U, .per_chan_pwr_limit_arr_11p = {(unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U}, .pwr_limit_reference_11p = (unsigned char)100U, .spare1 = (unsigned char)0, .per_chan_bo_mode_11_abg = {(unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U}, .per_chan_bo_mode_11_p = {(unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U}, .primary_clock_setting_time = (unsigned char)5U, .clock_valid_on_wake_up = (unsigned char)0U, .secondary_clock_setting_time = (unsigned char)5U, .board_type = (unsigned char)2U, .psat = (unsigned char)0U, .low_power_val = (signed char)(-1), .med_power_val = (signed char)(-1), .high_power_val = (signed char)(-1), .per_sub_band_tx_trace_loss = {(signed char)0, (signed char)0, (signed char)0, (signed char)0, (signed char)0, (signed char)0, (signed char)0, (signed char)0, (signed char)0, (signed char)0}, .per_sub_band_rx_trace_loss = {(signed char)0, (signed char)0, (signed char)0, (signed char)0, (signed char)0, (signed char)0, (signed char)0, (signed char)0, (signed char)0, (signed char)0, (signed char)0, (signed char)0, (signed char)0, (signed char)0, (signed char)0, (signed char)0, (signed char)0, (signed char)0}, .tx_rf_margin = (unsigned char)1U, .low_power_val_2nd = (signed char)(-1), .med_power_val_2nd = (signed char)(-1), .high_power_val_2nd = (signed char)(-1), .padding = {(unsigned char)0}}, .ap_sleep = {.idle_duty_cycle = (unsigned char)0U, .connected_duty_cycle = (unsigned char)0U, .max_stations_thresh = (unsigned char)0U, .idle_conn_thresh = (unsigned char)0U}};

#line 580  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static struct wlcore_partition_set const wl18xx_ptable[6U] = {{.mem = {.size = 81920U, .start = 0U}, .reg = {.size = 49151U, .start = 8454144U}, .mem2 = {.size = 0U, .start = 0U}, .mem3 = {.size = 0U, .start = 0U}}, {.mem = {.size = 20732U, .start = 8388608U}, .reg = {.size = 4096U, .start = 11535364U}, .mem2 = {.size = 1024U, .start = 12582912U}, .mem3 = {.size = 0U, .start = 0U}}, {.mem = {.size = 780U, .start = 7340032U}, .reg = {.size = 83320U, .start = 8396800U}, .mem2 = {.size = 4096U, .start = 11535364U}, .mem3 = {.size = 1024U, .start = 12582912U}}, [4] = {.mem = {.size = 73728U, .start = 10485760U}, .reg = {.size = 20480U, .start = 8417280U}, .mem2 = {.size = 45056U, .start = 8388608U}, .mem3 = {.size = 0U, .start = 0U}}, {.mem = {.size = 92740U, .start = 2157076480U}, .reg = {.size = 0U, .start = 0U}, .mem2 = {.size = 0U, .start = 0U}, .mem3 = {.size = 0U, .start = 0U}}};

#line 614  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int const wl18xx_rtable[13U] = {8396804, 8409320, 8409328, 8475884, 8475888, 8409208, 8409308, 8475900, 8475692, 11536308, 12582936, 12582920, 20728};

#line 634  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static struct wl18xx_clk_cfg const wl18xx_clk_table_coex[10U] = {[1] = {.n = 8U, .m = 121U, .p = 0U, .q = 0U, .swallow = (_Bool)0}, {.n = 8U, .m = 120U, .p = 0U, .q = 0U, .swallow = (_Bool)0}, {.n = 8U, .m = 117U, .p = 0U, .q = 0U, .swallow = (_Bool)0}, {.n = 10U, .m = 128U, .p = 0U, .q = 0U, .swallow = (_Bool)0}, {.n = 11U, .m = 104U, .p = 0U, .q = 0U, .swallow = (_Bool)0}, {.n = 8U, .m = 120U, .p = 0U, .q = 0U, .swallow = (_Bool)0}, {.n = 8U, .m = 117U, .p = 0U, .q = 0U, .swallow = (_Bool)0}, {.n = 10U, .m = 128U, .p = 0U, .q = 0U, .swallow = (_Bool)0}, {.n = 11U, .m = 104U, .p = 0U, .q = 0U, .swallow = (_Bool)0}};

#line 646  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static struct wl18xx_clk_cfg const wl18xx_clk_table[10U] = {[1] = {.n = 7U, .m = 104U, .p = 801U, .q = 4U, .swallow = (_Bool)1}, {.n = 9U, .m = 132U, .p = 3751U, .q = 4U, .swallow = (_Bool)1}, {.n = 7U, .m = 100U, .p = 0U, .q = 0U, .swallow = (_Bool)0}, {.n = 8U, .m = 100U, .p = 0U, .q = 0U, .swallow = (_Bool)0}, {.n = 13U, .m = 120U, .p = 0U, .q = 0U, .swallow = (_Bool)0}, {.n = 9U, .m = 132U, .p = 3751U, .q = 4U, .swallow = (_Bool)1}, {.n = 7U, .m = 100U, .p = 0U, .q = 0U, .swallow = (_Bool)0}, {.n = 8U, .m = 100U, .p = 0U, .q = 0U, .swallow = (_Bool)0}, {.n = 13U, .m = 120U, .p = 0U, .q = 0U, .swallow = (_Bool)0}};

#line 661  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int wl18xx_identify_chip(struct wl1271 *wl)
{
  
#line 663 
  int ret = 0;
  
#line 665 
  switch (wl->chip.id) {
    case (u32)100860177: 
#line 666 
    ;
    
#line 667 
    if ((long)((wl12xx_debug_level & 4U) != 0U) != 0L) {
      
#line 667 
      struct _ddebug descriptor = {.modname = "wl18xx", .function = "wl18xx_identify_chip", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))668U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 667 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 667 
                                                          __dynamic_pr_debug(& descriptor,"wlcore",wl->chip.id); else ;
    }
    else ;
    
#line 669 
    wl->sr_fw_name = "ti-connectivity/wl18xx-fw-4.bin";
    
#line 671 
    wl->plt_fw_name = "ti-connectivity/wl18xx-fw-4.bin";
    
#line 672 
    wl->quirks |= 3724U;
    
#line 679 
    wlcore_set_min_fw_ver(wl,8U,9U,4294967295U,4294967295U,11U,0U,0U,0U,0U);
    
#line 684 
    goto ldv_53898;
    case (u32)100860161: 
#line 685 
    ;
    
#line 686 
    printk("\001",wl->chip.id);
    
#line 688 
    ret = -19;
    
#line 689 
    goto out;
    default: 
#line 691 
    ;
    
#line 692 
    printk("\001",wl->chip.id);
    
#line 693 
    ret = -19;
    
#line 694 
    goto out;
  }
  ldv_53898: 
#line 697 
  ;
  
#line 697 
  wl->fw_mem_block_size = 272U;
  
#line 698 
  wl->fwlog_end = 1073741824U;
  
#line 700 
  wl->scan_templ_id_2_4 = (unsigned char)2U;
  
#line 701 
  wl->scan_templ_id_5 = (unsigned char)3U;
  
#line 702 
  wl->sched_scan_templ_id_2_4 = (unsigned char)19U;
  
#line 703 
  wl->sched_scan_templ_id_5 = (unsigned char)20U;
  
#line 704 
  wl->max_channels_5 = (unsigned char)32U;
  
#line 705 
  wl->ba_rx_session_count_max = 13;
  out: 
#line 706 
  ;
  
#line 707 
  return ret;
}


#line 710  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int wl18xx_set_clk(struct wl1271 *wl)
{
  u16 clk_freq;
  int ret;
  
#line 715 
  ret = wlcore_set_partition(wl,wl->ptable + 4U);
  
#line 716 
  if (ret < 0) 
#line 717 
               goto out; else ;
  
#line 721 
  ret = wl18xx_top_reg_read(wl,10494118,& clk_freq);
  
#line 722 
  if (ret < 0) 
#line 723 
               goto out; else ;
  
#line 725 
  if ((long)((wl12xx_debug_level & 4U) != 0U) != 0L) {
    
#line 725 
    struct _ddebug descriptor = {.modname = "wl18xx", .function = "wl18xx_set_clk", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))728U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 725 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      char *tmp;
      
#line 725 
      if ((int)wl18xx_clk_table[(int)clk_freq].swallow != 0) 
#line 725 
                                                             tmp = (char *)"swallow"; else 
                                                                    
#line 725 
                                                                    tmp = (char *)"spit";
      
#line 725 
      ;
      
#line 725 
      ;
      
#line 725 
      ;
      
#line 725 
      ;
      
#line 725 
      ;
      
#line 725 
      __dynamic_pr_debug(& descriptor,"wlcore",(int)clk_freq,wl18xx_clk_table[(int)clk_freq].n,wl18xx_clk_table[(int)clk_freq].m,wl18xx_clk_table[(int)clk_freq].p,wl18xx_clk_table[(int)clk_freq].q,tmp);
    }
    else ;
  }
  else ;
  
#line 731 
  ret = wl18xx_top_reg_write(wl,10494852,(unsigned short)((int)((unsigned short)wl18xx_clk_table_coex[(int)clk_freq].n)));
  
#line 733 
  if (ret < 0) 
#line 734 
               goto out; else ;
  
#line 736 
  ret = wl18xx_top_reg_write(wl,10494850,(unsigned short)((int)((unsigned short)wl18xx_clk_table_coex[(int)clk_freq].m)));
  
#line 738 
  if (ret < 0) 
#line 739 
               goto out; else ;
  
#line 742 
  ret = wl18xx_top_reg_write(wl,10494862,(unsigned short)2);
  
#line 744 
  if (ret < 0) 
#line 745 
               goto out; else ;
  
#line 747 
  ret = wl18xx_top_reg_write(wl,10494818,(unsigned short)((int)((unsigned short)wl18xx_clk_table[(int)clk_freq].n)));
  
#line 749 
  if (ret < 0) 
#line 750 
               goto out; else ;
  
#line 752 
  ret = wl18xx_top_reg_write(wl,10494816,(unsigned short)((int)((unsigned short)wl18xx_clk_table[(int)clk_freq].m)));
  
#line 754 
  if (ret < 0) 
#line 755 
               goto out; else ;
  
#line 757 
  if ((int)wl18xx_clk_table[(int)clk_freq].swallow != 0) {
    
#line 759 
    ret = wl18xx_top_reg_write(wl,10494820,(unsigned short)((int)((unsigned short)wl18xx_clk_table[(int)clk_freq].q)));
    
#line 762 
    if (ret < 0) 
#line 763 
                 goto out; else ;
    
#line 766 
    ret = wl18xx_top_reg_write(wl,10494822,(unsigned short)((int)((unsigned short)(wl18xx_clk_table[(int)clk_freq].q >> 16)) & 127));
    
#line 769 
    if (ret < 0) 
#line 770 
                 goto out; else ;
    
#line 773 
    ret = wl18xx_top_reg_write(wl,10494824,(unsigned short)((int)((unsigned short)wl18xx_clk_table[(int)clk_freq].p)));
    
#line 776 
    if (ret < 0) 
#line 777 
                 goto out; else ;
    
#line 780 
    ret = wl18xx_top_reg_write(wl,10494826,(unsigned short)((int)((unsigned short)(wl18xx_clk_table[(int)clk_freq].p >> 16)) & 15));
  }
  else 
#line 784 
       ret = wl18xx_top_reg_write(wl,10494828,(unsigned short)18);
  
#line 789 
  ret = wl18xx_top_reg_write(wl,10494872,(unsigned short)0);
  
#line 791 
  if (ret < 0) 
#line 792 
               goto out; else ;
  
#line 795 
  ret = wl18xx_top_reg_write(wl,10494866,(unsigned short)7);
  
#line 796 
  if (ret < 0) 
#line 797 
               goto out; else ;
  
#line 799 
  __const_udelay(4295000UL);
  
#line 802 
  ret = wl18xx_top_reg_write(wl,10494866,(unsigned short)2);
  
#line 803 
  if (ret < 0) 
#line 804 
               goto out; else ;
  
#line 807 
  ret = wl18xx_top_reg_write(wl,10494862,(unsigned short)17);
  
#line 809 
  if (ret < 0) 
#line 810 
               goto out; else ;
  out: 
#line 812 
  ;
  
#line 813 
  return ret;
}


#line 816  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int wl18xx_boot_soft_reset(struct wl1271 *wl)
{
  int ret;
  
#line 821 
  ret = wlcore_write32(wl,8475708,0U);
  
#line 822 
  if (ret < 0) 
#line 823 
               goto out; else ;
  
#line 826 
  ret = wlcore_write32(wl,8397208,65535U);
  out: 
#line 828 
  ;
  
#line 829 
  return ret;
}


#line 832  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int wl18xx_pre_boot(struct wl1271 *wl)
{
  int ret;
  
#line 836 
  ret = wl18xx_set_clk(wl);
  
#line 837 
  if (ret < 0) 
#line 838 
               goto out; else ;
  
#line 841 
  ret = wlcore_write32(wl,8417536,4U);
  
#line 842 
  if (ret < 0) 
#line 843 
               goto out; else ;
  
#line 845 
  __const_udelay(2147500UL);
  
#line 847 
  ret = wlcore_set_partition(wl,wl->ptable + 2U);
  
#line 848 
  if (ret < 0) 
#line 849 
               goto out; else ;
  
#line 852 
  ret = wlcore_write_reg(wl,6,4294967295U);
  
#line 853 
  if (ret < 0) 
#line 854 
               goto out; else ;
  
#line 856 
  ret = wl18xx_boot_soft_reset(wl);
  out: 
#line 858 
  ;
  
#line 859 
  return ret;
}


#line 868 
void __compiletime_assert_869(void);


#line 862  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int wl18xx_pre_upload(struct wl1271 *wl)
{
  u32 tmp;
  int ret;
  u16 irq_invert;
  u32 tmp_0;
  {
    
#line 868 
    bool __cond = (_Bool)0;
    
#line 868 
    if ((int)__cond != 0) 
#line 868 
                          __compiletime_assert_869(); else ;
  }
  
#line 871 
  ret = wlcore_set_partition(wl,wl->ptable + 2U);
  
#line 872 
  if (ret < 0) 
#line 873 
               goto out; else ;
  
#line 876 
  ret = wlcore_write32(wl,8475900,8475900U);
  
#line 877 
  if (ret < 0) 
#line 878 
               goto out; else ;
  
#line 880 
  ret = wlcore_read_reg(wl,8,& tmp);
  
#line 881 
  if (ret < 0) 
#line 882 
               goto out; else ;
  
#line 884 
  if ((long)((wl12xx_debug_level & 4U) != 0U) != 0L) {
    
#line 884 
    struct _ddebug descriptor = {.modname = "wl18xx", .function = "wl18xx_pre_upload", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))884U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 884 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 884 
                                                        __dynamic_pr_debug(& descriptor,"wlcore",tmp); else ;
  }
  else ;
  
#line 886 
  ret = wlcore_read32(wl,8475892,& tmp);
  
#line 887 
  if (ret < 0) 
#line 888 
               goto out; else ;
  
#line 897 
  ret = wlcore_set_partition(wl,wl->ptable + 5U);
  
#line 898 
  if (ret < 0) 
#line 899 
               goto out; else ;
  
#line 902 
  ret = wlcore_write32(wl,-2137798080,2147483648U);
  
#line 904 
  if (ret < 0) 
#line 905 
               goto out; else ;
  
#line 908 
  ret = wlcore_write32(wl,-2137798080,3221225472U);
  
#line 910 
  if (ret < 0) 
#line 911 
               goto out; else ;
  
#line 914 
  ret = wlcore_write32(wl,-2137798080,1073741824U);
  
#line 916 
  if (ret < 0) 
#line 917 
               goto out; else ;
  
#line 919 
  tmp_0 = irq_get_trigger_type((unsigned int)wl->irq);
  
#line 919 
  ret = (int)tmp_0;
  
#line 920 
  if (ret == 8 || ret == 2) {
    
#line 921 
    printk("\001",ret);
    
#line 922 
    ret = wlcore_set_partition(wl,wl->ptable + 4U);
    
#line 924 
    if (ret < 0) 
#line 925 
                 goto out; else ;
    
#line 927 
    ret = wl18xx_top_reg_read(wl,10485860,& irq_invert);
    
#line 928 
    if (ret < 0) 
#line 929 
                 goto out; else ;
    
#line 931 
    irq_invert = (unsigned short)((unsigned int)irq_invert | 2U);
    
#line 932 
    ret = wl18xx_top_reg_write(wl,10485860,(unsigned short)((int)irq_invert));
    
#line 933 
    if (ret < 0) 
#line 934 
                 goto out; else ;
    
#line 936 
    ret = wlcore_set_partition(wl,wl->ptable + 5U);
  }
  else ;
  out: 
#line 939 
  ;
  
#line 940 
  return ret;
}


#line 943  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int wl18xx_set_mac_and_phy(struct wl1271 *wl)
{
  struct wl18xx_mac_and_phy_params *params;
  int ret;
  
#line 945 
  struct wl18xx_priv *priv = (struct wl18xx_priv *)wl->priv;
  
#line 949 
  params = (struct wl18xx_mac_and_phy_params *)kmemdup((void const *)(& priv->conf.phy),288UL,208U);
  
#line 950 
  if (params == (struct wl18xx_mac_and_phy_params *)0) {
    
#line 951 
    ret = -12;
    
#line 952 
    goto out;
  }
  else ;
  
#line 955 
  ret = wlcore_set_partition(wl,wl->ptable + 5U);
  
#line 956 
  if (ret < 0) 
#line 957 
               goto out; else ;
  
#line 959 
  ret = wlcore_write(wl,-2137890816,(void *)params,288UL,(_Bool)0);
  out: 
#line 962 
  ;
  
#line 963 
  kfree((void const *)params);
  
#line 964 
  return ret;
}


#line 967  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int wl18xx_enable_interrupts(struct wl1271 *wl)
{
  int __retres;
  u32 event_mask;
  u32 intr_mask;
  int ret;
  
#line 972 
  event_mask = 639U;
  
#line 973 
  intr_mask = 621U;
  
#line 975 
  ret = wlcore_write_reg(wl,6,event_mask);
  
#line 976 
  if (ret < 0) 
#line 977 
               goto out; else ;
  
#line 979 
  wlcore_enable_interrupts(wl);
  
#line 981 
  ret = wlcore_write_reg(wl,6,~ intr_mask);
  
#line 983 
  if (ret < 0) 
#line 984 
               goto disable_interrupts; else ;
  
#line 986 
  __retres = ret;
  
#line 986 
  goto return_label;
  disable_interrupts: 
#line 988 
  ;
  
#line 989 
  wlcore_disable_interrupts(wl);
  out: 
#line 991 
  ;
  
#line 992 
  __retres = ret;
  return_label: 
#line 992 
                return __retres;
}


#line 995  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int wl18xx_boot(struct wl1271 *wl)
{
  int ret;
  
#line 999 
  ret = wl18xx_pre_boot(wl);
  
#line 1000 
  if (ret < 0) 
#line 1001 
               goto out; else ;
  
#line 1003 
  ret = wl18xx_pre_upload(wl);
  
#line 1004 
  if (ret < 0) 
#line 1005 
               goto out; else ;
  
#line 1007 
  ret = wlcore_boot_upload_firmware(wl);
  
#line 1008 
  if (ret < 0) 
#line 1009 
               goto out; else ;
  
#line 1011 
  ret = wl18xx_set_mac_and_phy(wl);
  
#line 1012 
  if (ret < 0) 
#line 1013 
               goto out; else ;
  
#line 1015 
  wl->event_mask = 14675713U;
  
#line 1032 
  wl->ap_event_mask = 4096U;
  
#line 1034 
  ret = wlcore_boot_run_firmware(wl);
  
#line 1035 
  if (ret < 0) 
#line 1036 
               goto out; else ;
  
#line 1038 
  ret = wl18xx_enable_interrupts(wl);
  out: 
#line 1040 
  ;
  
#line 1041 
  return ret;
}


#line 1044  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int wl18xx_trigger_cmd(struct wl1271 *wl, int cmd_box_addr, void *buf, size_t len)
{
  int tmp;
  
#line 1047 
  struct wl18xx_priv *priv = (struct wl18xx_priv *)wl->priv;
  
#line 1049 
  memcpy((void *)(& priv->cmd_buf),(void const *)buf,len);
  
#line 1050 
  memset((void *)(& priv->cmd_buf) + len,0,740UL - len);
  
#line 1052 
  tmp = wlcore_write(wl,cmd_box_addr,(void *)(& priv->cmd_buf),740UL,(_Bool)0);
  
#line 1052 
  return tmp;
}


#line 1056  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int wl18xx_ack_event(struct wl1271 *wl)
{
  int tmp;
  
#line 1058 
  tmp = wlcore_write_reg(wl,5,536870912U);
  
#line 1058 
  return tmp;
}


#line 1062  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static u32 wl18xx_calc_tx_blocks(struct wl1271 *wl, u32 len, u32 spare_blks)
{
  u32 __retres;
  
#line 1064 
  u32 blk_size = 268U;
  
#line 1065 
  __retres = ((len + blk_size) + 4294967295U) / blk_size + spare_blks;
  
#line 1065 
  return __retres;
}


#line 1069  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static void wl18xx_set_tx_desc_blocks(struct wl1271 *wl, struct wl1271_tx_hw_descr *desc, u32 blks, u32 spare_blks)
{
  
#line 1072 
  desc->__anonCompField_wl1271_tx_hw_descr_103.wl18xx_mem.total_mem_blocks = (unsigned char)blks;
  
#line 1073 
  return;
}


#line 1076  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static void wl18xx_set_tx_desc_data_len(struct wl1271 *wl, struct wl1271_tx_hw_descr *desc, struct sk_buff *skb)
{
  
#line 1079 
  desc->length = (unsigned short)skb->len;
  
#line 1082 
  if (((unsigned long)wl->quirks & 128UL) != 0UL) 
#line 1083 
                                                  desc->__anonCompField_wl1271_tx_hw_descr_103.wl18xx_mem.ctrl = (unsigned char)128U; else 
                                                                    
#line 1085 
                                                                    desc->__anonCompField_wl1271_tx_hw_descr_103.wl18xx_mem.ctrl = (unsigned char)0U;
  
#line 1087 
  if ((long)((wl12xx_debug_level & 64U) != 0U) != 0L) {
    
#line 1087 
    struct _ddebug descriptor = {.modname = "wl18xx", .function = "wl18xx_set_tx_desc_data_len", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1091U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1087 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1087 
                                                        __dynamic_pr_debug(& descriptor,"wlcore",(int)desc->hlid,(int)desc->length,(int)desc->life_time,(int)desc->__anonCompField_wl1271_tx_hw_descr_103.wl18xx_mem.total_mem_blocks); else ;
  }
  else ;
  
#line 1089 
  return;
}


#line 1095  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int wl18xx_get_rx_buf_align(struct wl1271 *wl, u32 rx_desc)
{
  int __retres;
  
#line 1097 
  if (((unsigned long)rx_desc & 1073741824UL) != 0UL) {
    
#line 1098 
    __retres = 2;
    
#line 1098 
    goto return_label;
  }
  else ;
  
#line 1100 
  __retres = 0;
  return_label: 
#line 1100 
                return __retres;
}


#line 1103  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static u32 wl18xx_get_rx_packet_len(struct wl1271 *wl, void *rx_data, u32 data_len)
{
  u32 __retres;
  
#line 1106 
  struct wl1271_rx_descriptor *desc = (struct wl1271_rx_descriptor *)rx_data;
  
#line 1109 
  if (data_len <= 15U) {
    
#line 1110 
    __retres = 0U;
    
#line 1110 
    goto return_label;
  }
  else ;
  
#line 1112 
  __retres = data_len + 4294967280U;
  return_label: 
#line 1112 
                return __retres;
}


#line 1115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static void wl18xx_tx_immediate_completion(struct wl1271 *wl)
{
  
#line 1117 
  wl18xx_tx_immediate_complete(wl);
  
#line 1118 
  return;
}


#line 1120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int wl18xx_set_host_cfg_bitmap(struct wl1271 *wl, u32 extra_mem_blk)
{
  int __retres;
  int ret;
  
#line 1123 
  u32 sdio_align_size = 0U;
  
#line 1124 
  u32 host_cfg_bitmap = 65U;
  
#line 1128 
  if (((unsigned long)wl->quirks & 4UL) != 0UL) {
    unsigned int tmp_0;
    
#line 1129 
    host_cfg_bitmap |= 8U;
    {
      unsigned int tmp;
      
#line 1130 
      unsigned int _min1 = 512U;
      
#line 1130 
      unsigned int _min2 = 256U;
      
#line 1130 
      if (_min1 < _min2) 
#line 1130 
                         tmp = _min1; else 
#line 1130 
                                           tmp = _min2;
      
#line 1130 
      tmp_0 = tmp;
    }
    
#line 1130 
    sdio_align_size = tmp_0;
  }
  else ;
  
#line 1134 
  if (((unsigned long)wl->quirks & 8UL) != 0UL) {
    unsigned int tmp_2;
    
#line 1135 
    host_cfg_bitmap |= 16U;
    {
      unsigned int tmp_1;
      
#line 1136 
      unsigned int _min1_0 = 512U;
      
#line 1136 
      unsigned int _min2_0 = 256U;
      
#line 1136 
      if (_min1_0 < _min2_0) 
#line 1136 
                             tmp_1 = _min1_0; else 
#line 1136 
                                                   tmp_1 = _min2_0;
      
#line 1136 
      tmp_2 = tmp_1;
    }
    
#line 1136 
    sdio_align_size = tmp_2;
  }
  else ;
  
#line 1139 
  ret = wl18xx_acx_host_if_cfg_bitmap(wl,host_cfg_bitmap,sdio_align_size,extra_mem_blk,15U);
  
#line 1142 
  if (ret < 0) {
    
#line 1143 
    __retres = ret;
    
#line 1143 
    goto return_label;
  }
  else ;
  
#line 1145 
  __retres = 0;
  return_label: 
#line 1145 
                return __retres;
}


#line 1148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int wl18xx_hw_init(struct wl1271 *wl)
{
  int __retres;
  int ret;
  
#line 1151 
  struct wl18xx_priv *priv = (struct wl18xx_priv *)wl->priv;
  
#line 1154 
  priv->last_fw_rls_idx = (unsigned char)0U;
  
#line 1155 
  priv->extra_spare_key_count = 0;
  
#line 1158 
  ret = wl18xx_set_host_cfg_bitmap(wl,1U);
  
#line 1159 
  if (ret < 0) {
    
#line 1160 
    __retres = ret;
    
#line 1160 
    goto return_label;
  }
  else ;
  
#line 1162 
  if ((int)checksum_param != 0) {
    
#line 1163 
    ret = wl18xx_acx_set_checksum_state(wl);
    
#line 1164 
    if (ret != 0) {
      
#line 1165 
      __retres = ret;
      
#line 1165 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 1168 
  __retres = ret;
  return_label: 
#line 1168 
                return __retres;
}


#line 1171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static void wl18xx_convert_fw_status(struct wl1271 *wl, void *raw_fw_status, struct wl_fw_status *fw_status)
{
  
#line 1174 
  struct wl18xx_fw_status *int_fw_status = (struct wl18xx_fw_status *)raw_fw_status;
  
#line 1176 
  fw_status->intr = int_fw_status->intr;
  
#line 1177 
  fw_status->fw_rx_counter = int_fw_status->fw_rx_counter;
  
#line 1178 
  fw_status->drv_rx_counter = int_fw_status->drv_rx_counter;
  
#line 1179 
  fw_status->tx_results_counter = int_fw_status->tx_results_counter;
  
#line 1180 
  fw_status->rx_pkt_descs = (__le32 *)(& int_fw_status->rx_pkt_descs);
  
#line 1182 
  fw_status->fw_localtime = int_fw_status->fw_localtime;
  
#line 1183 
  fw_status->link_ps_bitmap = int_fw_status->link_ps_bitmap;
  
#line 1184 
  fw_status->link_fast_bitmap = int_fw_status->link_fast_bitmap;
  
#line 1186 
  fw_status->total_released_blks = int_fw_status->total_released_blks;
  
#line 1188 
  fw_status->tx_total = int_fw_status->tx_total;
  
#line 1190 
  fw_status->counters.tx_released_pkts = (u8 *)(& int_fw_status->counters.tx_released_pkts);
  
#line 1192 
  fw_status->counters.tx_lnk_free_pkts = (u8 *)(& int_fw_status->counters.tx_lnk_free_pkts);
  
#line 1194 
  fw_status->counters.tx_voice_released_blks = int_fw_status->counters.tx_voice_released_blks;
  
#line 1196 
  fw_status->counters.tx_last_rate = int_fw_status->counters.tx_last_rate;
  
#line 1199 
  fw_status->log_start_addr = int_fw_status->log_start_addr;
  
#line 1201 
  fw_status->priv = (void *)(& int_fw_status->priv);
  
#line 1202 
  return;
}


#line 1204  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static void wl18xx_set_tx_desc_csum(struct wl1271 *wl, struct wl1271_tx_hw_descr *desc, struct sk_buff *skb)
{
  u32 ip_hdr_offset;
  struct iphdr *ip_hdr_0;
  unsigned char *tmp;
  unsigned char *tmp_0;
  int tmp_1;
  
#line 1211 
  if (! checksum_param) {
    
#line 1212 
    desc->__anonCompField_wl1271_tx_hw_descr_104.wl18xx_checksum_data = (unsigned char)0U;
    
#line 1213 
    goto return_label;
  }
  else ;
  
#line 1216 
  if ((unsigned int)*((unsigned char *)skb + 145UL) != 6U) {
    
#line 1217 
    desc->__anonCompField_wl1271_tx_hw_descr_104.wl18xx_checksum_data = (unsigned char)0U;
    
#line 1218 
    goto return_label;
  }
  else ;
  
#line 1221 
  tmp = skb_network_header((struct sk_buff const *)skb);
  
#line 1221 
  tmp_0 = skb_mac_header((struct sk_buff const *)skb);
  
#line 1221 
  ip_hdr_offset = (unsigned int)((long)tmp - (long)tmp_0);
  {
    
#line 1222 
    int __ret_warn_on = ip_hdr_offset > 127U;
    
#line 1222 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 1222 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c",1222); else ;
    
#line 1222 
    tmp_1 = (long)(__ret_warn_on != 0);
  }
  
#line 1222 
  if ((long)tmp_1 != 0L) {
    
#line 1223 
    desc->__anonCompField_wl1271_tx_hw_descr_104.wl18xx_checksum_data = (unsigned char)0U;
    
#line 1224 
    goto return_label;
  }
  else ;
  
#line 1227 
  desc->__anonCompField_wl1271_tx_hw_descr_104.wl18xx_checksum_data = (unsigned char)((int)((unsigned char)ip_hdr_offset) << 1U);
  
#line 1230 
  ip_hdr_0 = (struct iphdr *)skb_network_header((struct sk_buff const *)skb);
  
#line 1231 
  desc->__anonCompField_wl1271_tx_hw_descr_104.wl18xx_checksum_data = (unsigned char)((int)desc->__anonCompField_wl1271_tx_hw_descr_104.wl18xx_checksum_data | ((int)ip_hdr_0->protocol & 1));
  return_label: 
#line 1232 
                return;
}


#line 1234  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static void wl18xx_set_rx_csum(struct wl1271 *wl, struct wl1271_rx_descriptor *desc, struct sk_buff *skb)
{
  
#line 1238 
  if (((int)desc->status & 64) != 0) 
#line 1239 
                                     skb->ip_summed = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U; else ;
  
#line 1240 
  return;
}


#line 1242  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static bool wl18xx_is_mimo_supported(struct wl1271 *wl)
{
  bool __retres;
  
#line 1244 
  struct wl18xx_priv *priv = (struct wl18xx_priv *)wl->priv;
  
#line 1250 
  __retres = (_Bool)((((unsigned int)priv->conf.phy.number_of_assembled_ant2_4 > 1U && (unsigned int)priv->conf.ht.mode != 1U) && (unsigned int)priv->conf.ht.mode != 2U) != 0);
  
#line 1250 
  return __retres;
}


#line 1258  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static u32 wl18xx_sta_get_ap_rate_mask(struct wl1271 *wl, struct wl12xx_vif *wlvif)
{
  
#line 1261 
  u32 hw_rate_set = wlvif->rate_set;
  
#line 1263 
  if ((unsigned int)wlvif->channel_type + 4294967294U <= 1U) {
    
#line 1265 
    if ((long)((wl12xx_debug_level & 8192U) != 0U) != 0L) {
      
#line 1265 
      struct _ddebug descriptor = {.modname = "wl18xx", .function = "wl18xx_sta_get_ap_rate_mask", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1265U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1265 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1265 
                                                          __dynamic_pr_debug(& descriptor,"wlcore"); else ;
    }
    else ;
    
#line 1266 
    hw_rate_set |= 2147483648U;
    
#line 1269 
    hw_rate_set &= 3760193535U;
  }
  else {
    bool tmp;
    
#line 1270 
    tmp = wl18xx_is_mimo_supported(wl);
    
#line 1270 
    if ((int)tmp != 0) {
      
#line 1271 
      if ((long)((wl12xx_debug_level & 8192U) != 0U) != 0L) {
        
#line 1271 
        struct _ddebug descriptor_0 = {.modname = "wl18xx", .function = "wl18xx_sta_get_ap_rate_mask", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1271U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 1271 
        if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 1271 
                                                              __dynamic_pr_debug(& descriptor_0,"wlcore"); else ;
      }
      else ;
      
#line 1272 
      hw_rate_set |= 534773760U;
    }
    else ;
  }
  
#line 1275 
  return hw_rate_set;
}


#line 1278  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static u32 wl18xx_ap_get_mimo_wide_rate_mask(struct wl1271 *wl, struct wl12xx_vif *wlvif)
{
  u32 __retres;
  
#line 1281 
  if ((unsigned int)wlvif->channel_type + 4294967294U <= 1U) {
    int tmp;
    
#line 1283 
    if ((long)((wl12xx_debug_level & 8192U) != 0U) != 0L) {
      
#line 1283 
      struct _ddebug descriptor = {.modname = "wl18xx", .function = "wl18xx_ap_get_mimo_wide_rate_mask", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1283U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1283 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1283 
                                                          __dynamic_pr_debug(& descriptor,"wlcore"); else ;
    }
    else ;
    {
      
#line 1286 
      int __ret_warn_on = wlvif->band != (unsigned int)IEEE80211_BAND_5GHZ;
      
#line 1286 
      if ((long)(__ret_warn_on != 0) != 0L) 
#line 1286 
                                            warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c",1286); else ;
      
#line 1286 
      tmp = (long)(__ret_warn_on != 0);
    }
    
#line 1286 
    if ((long)tmp != 0L) {
      
#line 1287 
      __retres = 0U;
      
#line 1287 
      goto return_label;
    }
    else ;
    
#line 1289 
    __retres = 2147483648U;
    
#line 1289 
    goto return_label;
  }
  else {
    bool tmp_0;
    
#line 1290 
    tmp_0 = wl18xx_is_mimo_supported(wl);
    
#line 1290 
    if ((int)tmp_0 != 0) 
      
#line 1290 
      if (wlvif->band == (unsigned int)IEEE80211_BAND_2GHZ) {
        
#line 1292 
        if ((long)((wl12xx_debug_level & 8192U) != 0U) != 0L) {
          
#line 1292 
          struct _ddebug descriptor_0 = {.modname = "wl18xx", .function = "wl18xx_ap_get_mimo_wide_rate_mask", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1292U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
          
#line 1292 
          if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 1292 
                                                                __dynamic_pr_debug(& descriptor_0,"wlcore"); else ;
        }
        else ;
        
#line 1297 
        __retres = 534773760U;
        
#line 1297 
        goto return_label;
      }
      else {
        
#line 1299 
        __retres = 0U;
        
#line 1299 
        goto return_label;
      }
    else {
      
#line 1299 
      __retres = 0U;
      
#line 1299 
      goto return_label;
    }
  }
  return_label: 
#line 1281 
                return __retres;
}


#line 1303  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static char const *wl18xx_rdl_name(enum wl18xx_rdl_num rdl_num)
{
  char const *__retres;
  
#line 1305 
  switch ((unsigned int)rdl_num) {
    case (unsigned int)1: 
#line 1306 
    ;
    
#line 1307 
    __retres = "183xH";
    
#line 1307 
    goto return_label;
    case (unsigned int)2: 
#line 1308 
    ;
    
#line 1309 
    __retres = "183x or 180x";
    
#line 1309 
    goto return_label;
    case (unsigned int)3: 
#line 1310 
    ;
    
#line 1311 
    __retres = "187xH";
    
#line 1311 
    goto return_label;
    case (unsigned int)4: 
#line 1312 
    ;
    
#line 1313 
    __retres = "187x";
    
#line 1313 
    goto return_label;
    case (unsigned int)17: 
#line 1314 
    ;
    
#line 1315 
    __retres = "RDL11 - Not Supported";
    
#line 1315 
    goto return_label;
    case (unsigned int)18: 
#line 1316 
    ;
    
#line 1317 
    __retres = "180xD";
    
#line 1317 
    goto return_label;
    case (unsigned int)19: 
#line 1318 
    ;
    
#line 1319 
    __retres = "RDL13 - Not Supported (1893Q)";
    
#line 1319 
    goto return_label;
    case (unsigned int)20: 
#line 1320 
    ;
    
#line 1321 
    __retres = "18xxQ";
    
#line 1321 
    goto return_label;
    case (unsigned int)0: 
#line 1322 
    ;
    
#line 1323 
    __retres = "UNTRIMMED";
    
#line 1323 
    goto return_label;
    default: 
#line 1324 
    ;
    
#line 1325 
    __retres = "UNKNOWN";
    
#line 1325 
    goto return_label;
  }
  return_label: 
#line 1305 
                return __retres;
}


#line 1329  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int wl18xx_get_pg_ver(struct wl1271 *wl, s8 *ver)
{
  u32 fuse;
  int ret;
  char const *tmp;
  
#line 1332 
  s8 rom = (signed char)0;
  
#line 1332 
  s8 metal = (signed char)0;
  
#line 1332 
  s8 pg_ver = (signed char)0;
  
#line 1332 
  s8 rdl_ver = (signed char)0;
  
#line 1332 
  s8 package_type = (signed char)0;
  
#line 1335 
  ret = wlcore_set_partition(wl,wl->ptable + 4U);
  
#line 1336 
  if (ret < 0) 
#line 1337 
               goto out; else ;
  
#line 1339 
  ret = wlcore_read32(wl,10495508,& fuse);
  
#line 1340 
  if (ret < 0) 
#line 1341 
               goto out; else ;
  
#line 1343 
  package_type = (signed char)((int)((signed char)(fuse >> 13)) & 1);
  
#line 1345 
  ret = wlcore_read32(wl,10495500,& fuse);
  
#line 1346 
  if (ret < 0) 
#line 1347 
               goto out; else ;
  
#line 1349 
  pg_ver = (signed char)((int)((signed char)(fuse >> 4)) & 7);
  
#line 1350 
  rom = (signed char)((int)((signed char)(fuse >> 9)) & 31);
  
#line 1352 
  if ((int)rom <= 14 && (int)package_type == 0) 
#line 1353 
                                                metal = (signed char)((int)((signed char)(fuse >> 2)) & 3); else 
                                                                    
#line 1356 
                                                                    metal = (signed char)((int)((signed char)(fuse >> 7)) & 3);
  
#line 1359 
  ret = wlcore_read32(wl,10495508,& fuse);
  
#line 1360 
  if (ret < 0) 
#line 1361 
               goto out; else ;
  
#line 1363 
  rdl_ver = (signed char)((int)((signed char)(fuse >> 8)) & 31);
  
#line 1365 
  ;
  
#line 1365 
  ;
  
#line 1365 
  ;
  
#line 1365 
  tmp = wl18xx_rdl_name((enum wl18xx_rdl_num)rdl_ver);
  
#line 1365 
  printk("\001",tmp,(int)pg_ver,(int)metal,(int)rom);
  
#line 1368 
  if (ver != (s8 *)0) 
#line 1369 
                      *ver = pg_ver; else ;
  
#line 1371 
  ret = wlcore_set_partition(wl,wl->ptable + 2U);
  out: 
#line 1373 
  ;
  
#line 1374 
  return ret;
}


#line 1379  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int wl18xx_load_conf_file(struct device *dev, struct wlcore_conf *conf, struct wl18xx_priv_conf *priv_conf)
{
  int __retres;
  struct wlcore_conf_file *conf_file;
  struct firmware const *fw;
  int ret;
  
#line 1386 
  ret = request_firmware(& fw,"ti-connectivity/wl18xx-conf.bin",dev);
  
#line 1387 
  if (ret < 0) {
    
#line 1388 
    printk("\001",(char *)"ti-connectivity/wl18xx-conf.bin",ret);
    
#line 1390 
    __retres = ret;
    
#line 1390 
    goto return_label;
  }
  else ;
  
#line 1393 
  if (fw->size != 1226UL) {
    
#line 1394 
    printk("\001",1226UL,fw->size);
    
#line 1396 
    ret = -22;
    
#line 1397 
    goto out_release;
  }
  else ;
  
#line 1400 
  conf_file = (struct wlcore_conf_file *)fw->data;
  
#line 1402 
  if (conf_file->header.magic != 283181258U) {
    
#line 1403 
    printk("\001",283181258,conf_file->header.magic);
    
#line 1406 
    ret = -22;
    
#line 1407 
    goto out_release;
  }
  else ;
  
#line 1410 
  if (conf_file->header.version != 393223U) {
    
#line 1411 
    printk("\001",393223,conf_file->header.version);
    
#line 1414 
    ret = -22;
    
#line 1415 
    goto out_release;
  }
  else ;
  
#line 1418 
  memcpy((void *)conf,(void const *)(& conf_file->core),921UL);
  
#line 1419 
  memcpy((void *)priv_conf,(void const *)(& conf_file->priv),293UL);
  out_release: 
#line 1421 
  ;
  
#line 1422 
  release_firmware(fw);
  
#line 1423 
  __retres = ret;
  return_label: 
#line 1423 
                return __retres;
}


#line 1426  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int wl18xx_conf_init(struct wl1271 *wl, struct device *dev)
{
  int __retres;
  int tmp;
  
#line 1428 
  struct wl18xx_priv *priv = (struct wl18xx_priv *)wl->priv;
  
#line 1430 
  tmp = wl18xx_load_conf_file(dev,& wl->conf,& priv->conf);
  
#line 1430 
  if (tmp < 0) {
    
#line 1431 
    printk("\001");
    
#line 1434 
    memcpy((void *)(& wl->conf),(void const *)(& wl18xx_conf),921UL);
    
#line 1436 
    memcpy((void *)(& priv->conf),(void const *)(& wl18xx_default_priv_conf),293UL);
  }
  else ;
  
#line 1440 
  __retres = 0;
  
#line 1440 
  return __retres;
}


#line 1443  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int wl18xx_plt_init(struct wl1271 *wl)
{
  int __retres;
  int ret;
  int tmp;
  
#line 1448 
  if (wl->plt_mode == (unsigned int)PLT_FEM_DETECT) {
    
#line 1449 
    printk("\001");
    
#line 1450 
    __retres = -22;
    
#line 1450 
    goto return_label;
  }
  else ;
  
#line 1453 
  ret = wlcore_write32(wl,8475932,3132800702U);
  
#line 1454 
  if (ret < 0) {
    
#line 1455 
    __retres = ret;
    
#line 1455 
    goto return_label;
  }
  else ;
  
#line 1457 
  tmp = (*((wl->ops)->boot))(wl);
  
#line 1457 
  __retres = tmp;
  return_label: 
#line 1457 
                return __retres;
}


#line 1460  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int wl18xx_get_mac(struct wl1271 *wl)
{
  u32 mac1;
  u32 mac2;
  int ret;
  
#line 1465 
  ret = wlcore_set_partition(wl,wl->ptable + 4U);
  
#line 1466 
  if (ret < 0) 
#line 1467 
               goto out; else ;
  
#line 1469 
  ret = wlcore_read32(wl,10495490,& mac1);
  
#line 1470 
  if (ret < 0) 
#line 1471 
               goto out; else ;
  
#line 1473 
  ret = wlcore_read32(wl,10495494,& mac2);
  
#line 1474 
  if (ret < 0) 
#line 1475 
               goto out; else ;
  
#line 1478 
  wl->fuse_oui_addr = ((mac2 << 8) & 16776960U) + (mac1 >> 24);
  
#line 1480 
  wl->fuse_nic_addr = mac1 & 16777215U;
  
#line 1482 
  if (wl->fuse_oui_addr == 0U && wl->fuse_nic_addr == 0U) {
    u8 mac[6U];
    
#line 1485 
    eth_random_addr((u8 *)(& mac));
    
#line 1487 
    wl->fuse_oui_addr = (unsigned int)((((int)mac[0] << 16) + ((int)mac[1] << 8)) + (int)mac[2]);
    
#line 1488 
    wl->fuse_nic_addr = (unsigned int)((((int)mac[3] << 16) + ((int)mac[4] << 8)) + (int)mac[5]);
    
#line 1489 
    printk("\001");
  }
  else ;
  
#line 1492 
  ret = wlcore_set_partition(wl,wl->ptable);
  out: 
#line 1494 
  ;
  
#line 1495 
  return ret;
}


#line 1498  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int wl18xx_handle_static_data(struct wl1271 *wl, struct wl1271_static_data *static_data)
{
  int __retres;
  
#line 1501 
  struct wl18xx_static_data_priv *static_data_priv = (struct wl18xx_static_data_priv *)(& static_data->priv);
  
#line 1504 
  strncpy((char *)(& wl->chip.phy_fw_ver_str),(char const *)(& static_data_priv->phy_version),32UL);
  
#line 1508 
  wl->chip.phy_fw_ver_str[31UL] = (char)0;
  
#line 1510 
  printk("\001",(char *)(& static_data_priv->phy_version));
  
#line 1512 
  __retres = 0;
  
#line 1512 
  return __retres;
}


#line 1515  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int wl18xx_get_spare_blocks(struct wl1271 *wl, bool is_gem)
{
  int __retres;
  
#line 1517 
  struct wl18xx_priv *priv = (struct wl18xx_priv *)wl->priv;
  
#line 1520 
  if (priv->extra_spare_key_count != 0) {
    
#line 1521 
    __retres = 2;
    
#line 1521 
    goto return_label;
  }
  else ;
  
#line 1523 
  __retres = 1;
  return_label: 
#line 1523 
                return __retres;
}


#line 1526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int wl18xx_set_key(struct wl1271 *wl, enum set_key_cmd cmd, struct ieee80211_vif *vif, struct ieee80211_sta *sta, struct ieee80211_key_conf *key_conf)
{
  bool special_enc;
  int ret;
  
#line 1531 
  struct wl18xx_priv *priv = (struct wl18xx_priv *)wl->priv;
  
#line 1532 
  bool change_spare = (_Bool)0;
  
#line 1535 
  if ((long)((wl12xx_debug_level & 512U) != 0U) != 0L) {
    
#line 1535 
    struct _ddebug descriptor = {.modname = "wl18xx", .function = "wl18xx_set_key", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1536U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1535 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1535 
                                                        __dynamic_pr_debug(& descriptor,"wlcore",priv->extra_spare_key_count); else ;
  }
  else ;
  
#line 1538 
  special_enc = (_Bool)((key_conf->cipher == 1339905U || key_conf->cipher == 1027074U) != 0);
  
#line 1541 
  ret = wlcore_set_key(wl,cmd,vif,sta,key_conf);
  
#line 1542 
  if (ret < 0) 
#line 1543 
               goto out; else ;
  
#line 1549 
  if ((int)special_enc != 0) {
    
#line 1550 
    if (cmd == (unsigned int)SET_KEY) {
      
#line 1552 
      change_spare = (_Bool)(priv->extra_spare_key_count == 0);
      
#line 1553 
      priv->extra_spare_key_count += 1;
    }
    else 
      
#line 1554 
      if (cmd == (unsigned int)DISABLE_KEY) {
        
#line 1556 
        change_spare = (_Bool)(priv->extra_spare_key_count == 1);
        
#line 1557 
        priv->extra_spare_key_count -= 1;
      }
      else ;
  }
  else ;
  
#line 1561 
  if ((long)((wl12xx_debug_level & 512U) != 0U) != 0L) {
    
#line 1561 
    struct _ddebug descriptor_0 = {.modname = "wl18xx", .function = "wl18xx_set_key", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1562U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1561 
    if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 1561 
                                                          __dynamic_pr_debug(& descriptor_0,"wlcore",priv->extra_spare_key_count); else ;
  }
  else ;
  
#line 1564 
  if (! change_spare) 
#line 1565 
                      goto out; else ;
  
#line 1568 
  if (priv->extra_spare_key_count != 0) 
#line 1569 
                                        ret = wl18xx_set_host_cfg_bitmap(wl,2U); else 
                                                                    
#line 1572 
                                                                    ret = wl18xx_set_host_cfg_bitmap(wl,1U);
  out: 
#line 1575 
  ;
  
#line 1576 
  return ret;
}


#line 1579  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static u32 wl18xx_pre_pkt_send(struct wl1271 *wl, u32 buf_offset, u32 last_len)
{
  u32 __retres;
  
#line 1582 
  if (((unsigned long)wl->quirks & 128UL) != 0UL) {
    struct wl1271_tx_hw_descr *last_desc;
    unsigned int tmp_0;
    unsigned int tmp_2;
    
#line 1586 
    last_desc = (struct wl1271_tx_hw_descr *)(wl->aggr_buf + (buf_offset + - last_len));
    
#line 1590 
    last_desc->__anonCompField_wl1271_tx_hw_descr_103.wl18xx_mem.ctrl = (unsigned char)((unsigned int)last_desc->__anonCompField_wl1271_tx_hw_descr_103.wl18xx_mem.ctrl & 127U);
    {
      unsigned int tmp;
      
#line 1591 
      unsigned int _min1 = 512U;
      
#line 1591 
      unsigned int _min2 = 256U;
      
#line 1591 
      if (_min1 < _min2) 
#line 1591 
                         tmp = _min1; else 
#line 1591 
                                           tmp = _min2;
      
#line 1591 
      tmp_0 = tmp;
    }
    {
      unsigned int tmp_1;
      
#line 1591 
      unsigned int _min1_0 = 512U;
      
#line 1591 
      unsigned int _min2_0 = 256U;
      
#line 1591 
      if (_min1_0 < _min2_0) 
#line 1591 
                             tmp_1 = _min1_0; else 
#line 1591 
                                                   tmp_1 = _min2_0;
      
#line 1591 
      tmp_2 = tmp_1;
    }
    
#line 1591 
    ;
    
#line 1591 
    __retres = ((tmp_0 + buf_offset) + 4294967295U) & ~ (tmp_2 + 4294967295U);
    
#line 1591 
    goto return_label;
  }
  else ;
  
#line 1595 
  __retres = buf_offset;
  return_label: 
#line 1595 
                return __retres;
}


#line 1598  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static void wl18xx_sta_rc_update(struct wl1271 *wl, struct wl12xx_vif *wlvif)
{
  int tmp;
  int tmp_0;
  
#line 1601 
  bool wide = (_Bool)(wlvif->rc_update_bw != (unsigned int)IEEE80211_STA_RX_BW_20);
  
#line 1603 
  if ((long)((wl12xx_debug_level & 2048U) != 0U) != 0L) {
    
#line 1603 
    struct _ddebug descriptor = {.modname = "wl18xx", .function = "wl18xx_sta_rc_update", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1603U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1603 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1603 
                                                        __dynamic_pr_debug(& descriptor,"wlcore",(int)wide); else ;
  }
  else ;
  {
    
#line 1606 
    int __ret_warn_on = (unsigned int)wlvif->bss_type != 2U;
    
#line 1606 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 1606 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c",1606); else ;
    
#line 1606 
    tmp = (long)(__ret_warn_on != 0);
  }
  
#line 1606 
  if ((long)tmp != 0L) 
#line 1607 
                       goto return_label; else ;
  
#line 1610 
  tmp_0 = constant_test_bit(1L,(unsigned long const volatile *)(& wlvif->flags));
  
#line 1610 
  if (tmp_0 == 0) 
#line 1611 
                  goto return_label; else ;
  
#line 1617 
  if ((unsigned int)wlvif->__anonCompField_wl12xx_vif_100.sta.role_chan_type + 4294967294U <= 1U) 
    
#line 1619 
    wl18xx_acx_peer_ht_operation_mode(wl,(unsigned char)((int)wlvif->__anonCompField_wl12xx_vif_100.sta.hlid),(_Bool)((bool)((int)wide) != 0));
  else {
    struct ieee80211_vif *tmp_1;
    
#line 1621 
    tmp_1 = wl12xx_wlvif_to_vif(wlvif);
    
#line 1621 
    ieee80211_connection_loss(tmp_1);
  }
  return_label: 
#line 1622 
                return;
}


#line 1624  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int wl18xx_set_peer_cap(struct wl1271 *wl, struct ieee80211_sta_ht_cap *ht_cap, bool allow_ht_operation, u32 rate_set, u8 hlid)
{
  int tmp;
  
#line 1629 
  tmp = wl18xx_acx_set_peer_cap(wl,ht_cap,(_Bool)((bool)((int)allow_ht_operation) != 0),rate_set,(unsigned char)((int)hlid));
  
#line 1629 
  return tmp;
}


#line 1633  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static bool wl18xx_lnk_high_prio(struct wl1271 *wl, u8 hlid, struct wl1271_link *lnk)
{
  bool __retres;
  u8 thold;
  unsigned long suspend_bitmap;
  int tmp_1;
  int tmp_4;
  
#line 1637 
  struct wl18xx_fw_status_priv *status_priv = (struct wl18xx_fw_status_priv *)(wl->fw_status)->priv;
  
#line 1642 
  if (status_priv == (struct wl18xx_fw_status_priv *)0) {
    
#line 1643 
    __retres = (_Bool)0;
    
#line 1643 
    goto return_label;
  }
  else ;
  
#line 1646 
  suspend_bitmap = (unsigned long)status_priv->link_suspend_bitmap;
  
#line 1647 
  if (0 != 0) {
    int tmp;
    
#line 1647 
    tmp = constant_test_bit((long)hlid,(unsigned long const volatile *)(& suspend_bitmap));
    
#line 1647 
    tmp_1 = tmp != 0;
  }
  else {
    int tmp_0;
    
#line 1647 
    tmp_0 = variable_test_bit((long)hlid,(unsigned long const volatile *)(& suspend_bitmap));
    
#line 1647 
    tmp_1 = tmp_0 != 0;
  }
  
#line 1647 
  if (tmp_1) {
    
#line 1648 
    __retres = (_Bool)0;
    
#line 1648 
    goto return_label;
  }
  else ;
  
#line 1651 
  if (0 != 0) {
    int tmp_2;
    
#line 1651 
    tmp_2 = constant_test_bit((long)hlid,(unsigned long const volatile *)(& wl->fw_fast_lnk_map));
    
#line 1651 
    tmp_4 = tmp_2 != 0;
  }
  else {
    int tmp_3;
    
#line 1651 
    tmp_3 = variable_test_bit((long)hlid,(unsigned long const volatile *)(& wl->fw_fast_lnk_map));
    
#line 1651 
    tmp_4 = tmp_3 != 0;
  }
  
#line 1651 
  if (tmp_4) {
    int tmp_7;
    
#line 1651 
    if (0 != 0) {
      int tmp_5;
      
#line 1652 
      tmp_5 = constant_test_bit((long)hlid,(unsigned long const volatile *)(& wl->ap_fw_ps_map));
      
#line 1651 
      tmp_7 = tmp_5 == 0;
    }
    else {
      int tmp_6;
      
#line 1651 
      tmp_6 = variable_test_bit((long)hlid,(unsigned long const volatile *)(& wl->ap_fw_ps_map));
      
#line 1651 
      tmp_7 = tmp_6 == 0;
    }
    
#line 1651 
    if (tmp_7) 
#line 1653 
               thold = status_priv->tx_fast_link_prio_threshold; else 
                                                                   
#line 1655 
                                                                   thold = status_priv->tx_slow_link_prio_threshold;
  }
  else 
#line 1655 
       thold = status_priv->tx_slow_link_prio_threshold;
  
#line 1657 
  __retres = (_Bool)((int)lnk->allocated_pkts < (int)thold);
  return_label: 
#line 1657 
                return __retres;
}


#line 1660  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static bool wl18xx_lnk_low_prio(struct wl1271 *wl, u8 hlid, struct wl1271_link *lnk)
{
  bool __retres;
  u8 thold;
  unsigned long suspend_bitmap;
  int tmp_7;
  
#line 1664 
  struct wl18xx_fw_status_priv *status_priv = (struct wl18xx_fw_status_priv *)(wl->fw_status)->priv;
  
#line 1669 
  if (status_priv == (struct wl18xx_fw_status_priv *)0) {
    
#line 1670 
    __retres = (_Bool)1;
    
#line 1670 
    goto return_label;
  }
  else ;
  
#line 1672 
  suspend_bitmap = (unsigned long)status_priv->link_suspend_bitmap;
  
#line 1673 
  if (0 != 0) {
    int tmp_5;
    
#line 1673 
    tmp_5 = constant_test_bit((long)hlid,(unsigned long const volatile *)(& suspend_bitmap));
    
#line 1673 
    tmp_7 = tmp_5 != 0;
  }
  else {
    int tmp_6;
    
#line 1673 
    tmp_6 = variable_test_bit((long)hlid,(unsigned long const volatile *)(& suspend_bitmap));
    
#line 1673 
    tmp_7 = tmp_6 != 0;
  }
  
#line 1673 
  if (tmp_7) 
#line 1674 
             thold = status_priv->tx_suspend_threshold;
  else {
    int tmp_1;
    
#line 1675 
    if (0 != 0) {
      int tmp;
      
#line 1675 
      tmp = constant_test_bit((long)hlid,(unsigned long const volatile *)(& wl->fw_fast_lnk_map));
      
#line 1675 
      tmp_1 = tmp != 0;
    }
    else {
      int tmp_0;
      
#line 1675 
      tmp_0 = variable_test_bit((long)hlid,(unsigned long const volatile *)(& wl->fw_fast_lnk_map));
      
#line 1675 
      tmp_1 = tmp_0 != 0;
    }
    
#line 1675 
    if (tmp_1) {
      int tmp_4;
      
#line 1675 
      if (0 != 0) {
        int tmp_2;
        
#line 1676 
        tmp_2 = constant_test_bit((long)hlid,(unsigned long const volatile *)(& wl->ap_fw_ps_map));
        
#line 1675 
        tmp_4 = tmp_2 == 0;
      }
      else {
        int tmp_3;
        
#line 1675 
        tmp_3 = variable_test_bit((long)hlid,(unsigned long const volatile *)(& wl->ap_fw_ps_map));
        
#line 1675 
        tmp_4 = tmp_3 == 0;
      }
      
#line 1675 
      if (tmp_4) 
#line 1677 
                 thold = status_priv->tx_fast_stop_threshold; else 
#line 1679 
                                                                   thold = status_priv->tx_slow_stop_threshold;
    }
    else 
#line 1679 
         thold = status_priv->tx_slow_stop_threshold;
  }
  
#line 1681 
  __retres = (_Bool)((int)lnk->allocated_pkts < (int)thold);
  return_label: 
#line 1681 
                return __retres;
}


#line 1684  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static u32 wl18xx_convert_hwaddr(struct wl1271 *wl, u32 hwaddr)
{
  u32 __retres;
  
#line 1686 
  __retres = hwaddr & 2147483647U;
  
#line 1686 
  return __retres;
}


#line 1689 
static int wl18xx_setup(struct wl1271 *wl);


#line 1691  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static struct wlcore_ops wl18xx_ops = {.setup = & wl18xx_setup, .identify_chip = & wl18xx_identify_chip, .identify_fw = (int (*)(struct wl1271 *))0, .boot = & wl18xx_boot, .plt_init = & wl18xx_plt_init, .trigger_cmd = & wl18xx_trigger_cmd, .ack_event = & wl18xx_ack_event, .wait_for_event = & wl18xx_wait_for_event, .process_mailbox_events = & wl18xx_process_mailbox_events, .calc_tx_blocks = & wl18xx_calc_tx_blocks, .set_tx_desc_blocks = & wl18xx_set_tx_desc_blocks, .set_tx_desc_data_len = & wl18xx_set_tx_desc_data_len, .get_rx_buf_align = & wl18xx_get_rx_buf_align, .prepare_read = (int (*)(struct wl1271 *, u32 , u32 ))0, .get_rx_packet_len = & wl18xx_get_rx_packet_len, .tx_delayed_compl = (int (*)(struct wl1271 *))0, .tx_immediate_compl = & wl18xx_tx_immediate_completion, .hw_init = & wl18xx_hw_init, .init_vif = (int (*)(struct wl1271 *, struct wl12xx_vif *))0, .convert_fw_status = & wl18xx_convert_fw_status, .sta_get_ap_rate_mask = & wl18xx_sta_get_ap_rate_mask, .get_pg_ver = & wl18xx_get_pg_ver, .get_mac = & wl18xx_get_mac, .set_tx_desc_csum = & wl18xx_set_tx_desc_csum, .set_rx_csum = & wl18xx_set_rx_csum, .ap_get_mimo_wide_rate_mask = & wl18xx_ap_get_mimo_wide_rate_mask, .debugfs_init = & wl18xx_debugfs_add_files, .handle_static_data = & wl18xx_handle_static_data, .scan_start = & wl18xx_scan_start, .scan_stop = & wl18xx_scan_stop, .sched_scan_start = & wl18xx_sched_scan_start, .sched_scan_stop = & wl18xx_scan_sched_scan_stop, .get_spare_blocks = & wl18xx_get_spare_blocks, .set_key = & wl18xx_set_key, .channel_switch = & wl18xx_cmd_channel_switch, .pre_pkt_send = & wl18xx_pre_pkt_send, .sta_rc_update = & wl18xx_sta_rc_update, .set_peer_cap = & wl18xx_set_peer_cap, .convert_hwaddr = & wl18xx_convert_hwaddr, .lnk_high_prio = & wl18xx_lnk_high_prio, .lnk_low_prio = & wl18xx_lnk_low_prio, .interrupt_notify = & wl18xx_acx_interrupt_notify_config, .rx_ba_filter = & wl18xx_acx_rx_ba_filter, .ap_sleep = & wl18xx_acx_ap_sleep, .smart_config_start = & wl18xx_cmd_smart_config_start, .smart_config_stop = & wl18xx_cmd_smart_config_stop, .smart_config_set_group_key = & wl18xx_cmd_smart_config_set_group_key, .set_cac = & wl18xx_cmd_set_cac, .dfs_master_restart = & wl18xx_cmd_dfs_master_restart};

#line 1741  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static struct ieee80211_sta_ht_cap wl18xx_siso40_ht_cap_2ghz = {.cap = (unsigned short)4210U, .ht_supported = (_Bool)1, .ampdu_factor = (unsigned char)1U, .ampdu_density = (unsigned char)7U, .mcs = {.rx_mask = {(unsigned char)255U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U}, .rx_highest = (unsigned short)150U, .tx_params = (unsigned char)1U, .reserved = {(unsigned char)0, (unsigned char)0, (unsigned char)0}}};

#line 1756  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static struct ieee80211_sta_ht_cap wl18xx_siso40_ht_cap_5ghz = {.cap = (unsigned short)114U, .ht_supported = (_Bool)1, .ampdu_factor = (unsigned char)1U, .ampdu_density = (unsigned char)7U, .mcs = {.rx_mask = {(unsigned char)255U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U}, .rx_highest = (unsigned short)150U, .tx_params = (unsigned char)1U, .reserved = {(unsigned char)0, (unsigned char)0, (unsigned char)0}}};

#line 1771  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static struct ieee80211_sta_ht_cap wl18xx_siso20_ht_cap = {.cap = (unsigned short)48U, .ht_supported = (_Bool)1, .ampdu_factor = (unsigned char)1U, .ampdu_density = (unsigned char)7U, .mcs = {.rx_mask = {(unsigned char)255U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U}, .rx_highest = (unsigned short)72U, .tx_params = (unsigned char)1U, .reserved = {(unsigned char)0, (unsigned char)0, (unsigned char)0}}};

#line 1785  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static struct ieee80211_sta_ht_cap wl18xx_mimo_ht_cap_2ghz = {.cap = (unsigned short)48U, .ht_supported = (_Bool)1, .ampdu_factor = (unsigned char)1U, .ampdu_density = (unsigned char)7U, .mcs = {.rx_mask = {(unsigned char)255U, (unsigned char)255U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U}, .rx_highest = (unsigned short)144U, .tx_params = (unsigned char)1U, .reserved = {(unsigned char)0, (unsigned char)0, (unsigned char)0}}};

#line 1798  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static struct ieee80211_iface_limit const wl18xx_iface_limits[2U] = {{.max = (unsigned short)3U, .types = (unsigned short)4U}, {.max = (unsigned short)1U, .types = (unsigned short)776U}};

#line 1811  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static struct ieee80211_iface_limit const wl18xx_iface_ap_limits[1U] = {{.max = (unsigned short)2U, .types = (unsigned short)8U}};

#line 1819  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static struct ieee80211_iface_combination const wl18xx_iface_combinations[2U] = {{.limits = (struct ieee80211_iface_limit const *)(& wl18xx_iface_limits), .num_different_channels = 2U, .max_interfaces = (unsigned short)3U, .n_limits = (unsigned char)2U, .beacon_int_infra_match = (_Bool)0, .radar_detect_widths = (unsigned char)0, .radar_detect_regions = (unsigned char)0}, {.limits = (struct ieee80211_iface_limit const *)(& wl18xx_iface_ap_limits), .num_different_channels = 1U, .max_interfaces = (unsigned short)2U, .n_limits = (unsigned char)1U, .beacon_int_infra_match = (_Bool)0, .radar_detect_widths = (unsigned char)15U, .radar_detect_regions = (unsigned char)0}};

#line 1843 
void __compiletime_assert_1843(void);


#line 1844 
void __compiletime_assert_1844(void);


#line 1838  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int wl18xx_setup(struct wl1271 *wl)
{
  int __retres;
  int ret;
  
#line 1840 
  struct wl18xx_priv *priv = (struct wl18xx_priv *)wl->priv;
  {
    
#line 1843 
    bool __cond = (_Bool)0;
    
#line 1843 
    if ((int)__cond != 0) 
#line 1843 
                          __compiletime_assert_1843(); else ;
  }
  {
    
#line 1844 
    bool __cond_0 = (_Bool)0;
    
#line 1844 
    if ((int)__cond_0 != 0) 
#line 1844 
                            __compiletime_assert_1844(); else ;
  }
  
#line 1846 
  wl->rtable = (int const *)(& wl18xx_rtable);
  
#line 1847 
  wl->num_tx_desc = 32U;
  
#line 1848 
  wl->num_rx_desc = 32U;
  
#line 1849 
  wl->num_links = (unsigned char)16U;
  
#line 1850 
  wl->max_ap_stations = (unsigned char)10U;
  
#line 1851 
  wl->iface_combinations = (struct ieee80211_iface_combination const *)(& wl18xx_iface_combinations);
  
#line 1852 
  wl->n_iface_combinations = (unsigned char)2U;
  
#line 1853 
  wl->num_mac_addr = 2;
  
#line 1854 
  wl->band_rate_to_idx = (u8 const **)(& wl18xx_band_rate_to_idx);
  
#line 1855 
  wl->hw_tx_rate_tbl_size = (unsigned char)29U;
  
#line 1856 
  wl->hw_min_ht_rate = (unsigned char)15U;
  
#line 1857 
  wl->fw_status_len = 236UL;
  
#line 1858 
  wl->fw_status_priv_len = 52UL;
  
#line 1859 
  wl->stats.fw_stats_len = 1818UL;
  
#line 1860 
  wl->static_data_priv_len = 20UL;
  
#line 1862 
  if (num_rx_desc_param != -1) 
#line 1863 
                               wl->num_rx_desc = (unsigned int)num_rx_desc_param; else ;
  
#line 1865 
  ret = wl18xx_conf_init(wl,wl->dev);
  
#line 1866 
  if (ret < 0) {
    
#line 1867 
    __retres = ret;
    
#line 1867 
    goto return_label;
  }
  else ;
  
#line 1870 
  if (board_type_param != (char *)0) {
    int tmp_3;
    
#line 1871 
    tmp_3 = strcmp((char const *)board_type_param,"fpga");
    
#line 1871 
    if (tmp_3 == 0) 
#line 1872 
                    priv->conf.phy.board_type = (unsigned char)3U;
    else {
      int tmp_2;
      
#line 1873 
      tmp_2 = strcmp((char const *)board_type_param,"hdk");
      
#line 1873 
      if (tmp_2 == 0) 
#line 1874 
                      priv->conf.phy.board_type = (unsigned char)2U;
      else {
        int tmp_1;
        
#line 1875 
        tmp_1 = strcmp((char const *)board_type_param,"dvp");
        
#line 1875 
        if (tmp_1 == 0) 
#line 1876 
                        priv->conf.phy.board_type = (unsigned char)1U;
        else {
          int tmp_0;
          
#line 1877 
          tmp_0 = strcmp((char const *)board_type_param,"evb");
          
#line 1877 
          if (tmp_0 == 0) 
#line 1878 
                          priv->conf.phy.board_type = (unsigned char)0U;
          else {
            int tmp;
            
#line 1879 
            tmp = strcmp((char const *)board_type_param,"com8");
            
#line 1879 
            if (tmp == 0) 
#line 1880 
                          priv->conf.phy.board_type = (unsigned char)4U;
            else {
              
#line 1882 
              printk("\001",board_type_param);
              
#line 1884 
              __retres = -22;
              
#line 1884 
              goto return_label;
            }
          }
        }
      }
    }
  }
  else ;
  
#line 1888 
  if ((unsigned int)priv->conf.phy.board_type > 4U) {
    
#line 1889 
    printk("\001",(int)priv->conf.phy.board_type);
    
#line 1891 
    __retres = -22;
    
#line 1891 
    goto return_label;
  }
  else ;
  
#line 1894 
  if (low_band_component_param != -1) 
#line 1895 
                                      priv->conf.phy.low_band_component = (unsigned char)low_band_component_param; else ;
  
#line 1896 
  if (low_band_component_type_param != -1) 
#line 1897 
                                           priv->conf.phy.low_band_component_type = (unsigned char)low_band_component_type_param; else ;
  
#line 1899 
  if (high_band_component_param != -1) 
#line 1900 
                                       priv->conf.phy.high_band_component = (unsigned char)high_band_component_param; else ;
  
#line 1901 
  if (high_band_component_type_param != -1) 
#line 1902 
                                            priv->conf.phy.high_band_component_type = (unsigned char)high_band_component_type_param; else ;
  
#line 1904 
  if (pwr_limit_reference_11_abg_param != -1) 
#line 1905 
                                              priv->conf.phy.pwr_limit_reference_11_abg = (unsigned char)pwr_limit_reference_11_abg_param; else ;
  
#line 1907 
  if (n_antennas_2_param != -1) 
#line 1908 
                                priv->conf.phy.number_of_assembled_ant2_4 = (unsigned char)n_antennas_2_param; else ;
  
#line 1909 
  if (n_antennas_5_param != -1) 
#line 1910 
                                priv->conf.phy.number_of_assembled_ant5 = (unsigned char)n_antennas_5_param; else ;
  
#line 1911 
  if (dc2dc_param != -1) 
#line 1912 
                         priv->conf.phy.external_pa_dc2dc = (unsigned char)dc2dc_param; else ;
  
#line 1914 
  if (ht_mode_param != (char *)0) {
    int tmp_6;
    
#line 1915 
    tmp_6 = strcmp((char const *)ht_mode_param,"default");
    
#line 1915 
    if (tmp_6 == 0) 
#line 1916 
                    priv->conf.ht.mode = (unsigned char)0U;
    else {
      int tmp_5;
      
#line 1917 
      tmp_5 = strcmp((char const *)ht_mode_param,"wide");
      
#line 1917 
      if (tmp_5 == 0) 
#line 1918 
                      priv->conf.ht.mode = (unsigned char)1U;
      else {
        int tmp_4;
        
#line 1919 
        tmp_4 = strcmp((char const *)ht_mode_param,"siso20");
        
#line 1919 
        if (tmp_4 == 0) 
#line 1920 
                        priv->conf.ht.mode = (unsigned char)2U;
        else {
          
#line 1922 
          printk("\001",ht_mode_param);
          
#line 1923 
          __retres = -22;
          
#line 1923 
          goto return_label;
        }
      }
    }
  }
  else ;
  
#line 1927 
  if ((unsigned int)priv->conf.ht.mode == 0U) {
    bool tmp_7;
    
#line 1932 
    tmp_7 = wl18xx_is_mimo_supported(wl);
    
#line 1932 
    if ((int)tmp_7 != 0) 
#line 1933 
                         wlcore_set_ht_cap(wl,(enum ieee80211_band)IEEE80211_BAND_2GHZ,& wl18xx_mimo_ht_cap_2ghz); else 
                                                                    
#line 1936 
                                                                    wlcore_set_ht_cap(wl,(enum ieee80211_band)IEEE80211_BAND_2GHZ,& wl18xx_siso40_ht_cap_2ghz);
    
#line 1940 
    wlcore_set_ht_cap(wl,(enum ieee80211_band)IEEE80211_BAND_5GHZ,& wl18xx_siso40_ht_cap_5ghz);
  }
  else 
    
#line 1942 
    if ((unsigned int)priv->conf.ht.mode == 1U) {
      
#line 1943 
      wlcore_set_ht_cap(wl,(enum ieee80211_band)IEEE80211_BAND_2GHZ,& wl18xx_siso40_ht_cap_2ghz);
      
#line 1945 
      wlcore_set_ht_cap(wl,(enum ieee80211_band)IEEE80211_BAND_5GHZ,& wl18xx_siso40_ht_cap_5ghz);
    }
    else 
      
#line 1947 
      if ((unsigned int)priv->conf.ht.mode == 2U) {
        
#line 1948 
        wlcore_set_ht_cap(wl,(enum ieee80211_band)IEEE80211_BAND_2GHZ,& wl18xx_siso20_ht_cap);
        
#line 1950 
        wlcore_set_ht_cap(wl,(enum ieee80211_band)IEEE80211_BAND_5GHZ,& wl18xx_siso20_ht_cap);
      }
      else ;
  
#line 1954 
  if (! checksum_param) {
    
#line 1955 
    wl18xx_ops.set_rx_csum = (void (*)(struct wl1271 *, struct wl1271_rx_descriptor *, struct sk_buff *))0;
    
#line 1956 
    wl18xx_ops.init_vif = (int (*)(struct wl1271 *, struct wl12xx_vif *))0;
  }
  else ;
  
#line 1960 
  wl->enable_11a = (_Bool)((unsigned int)priv->conf.phy.number_of_assembled_ant5 != 0U);
  
#line 1962 
  __retres = 0;
  return_label: 
#line 1962 
                return __retres;
}


#line 1965  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int wl18xx_probe(struct platform_device *pdev)
{
  int __retres;
  struct wl1271 *wl;
  struct ieee80211_hw *hw;
  int ret;
  bool tmp_0;
  
#line 1971 
  hw = wlcore_alloc_hw(1040UL,53248U,180U);
  
#line 1974 
  tmp_0 = IS_ERR((void const *)hw);
  
#line 1974 
  if ((int)tmp_0 != 0) {
    long tmp;
    
#line 1975 
    printk("\001");
    
#line 1976 
    tmp = PTR_ERR((void const *)hw);
    
#line 1976 
    ret = (int)tmp;
    
#line 1977 
    goto out;
  }
  else ;
  
#line 1980 
  wl = (struct wl1271 *)hw->priv;
  
#line 1981 
  wl->ops = & wl18xx_ops;
  
#line 1982 
  wl->ptable = (struct wlcore_partition_set const *)(& wl18xx_ptable);
  
#line 1983 
  ret = wlcore_probe(wl,pdev);
  
#line 1984 
  if (ret != 0) 
#line 1985 
                goto out_free; else ;
  
#line 1987 
  __retres = ret;
  
#line 1987 
  goto return_label;
  out_free: 
#line 1989 
  ;
  
#line 1990 
  wlcore_free_hw(wl);
  out: 
#line 1991 
  ;
  
#line 1992 
  __retres = ret;
  return_label: 
#line 1992 
                return __retres;
}


#line 1995  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static struct platform_device_id const wl18xx_id_table[2U] = {{.name = {(char)'w', (char)'l', (char)'1', (char)'8', (char)'x', (char)'x', (char)'\000'}, .driver_data = 0UL}, {.name = {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0}, .driver_data = 0UL}};

#line 1999  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
struct platform_device_id const __mod_platform__wl18xx_id_table_device_table[2U];

#line 2001  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static struct platform_driver wl18xx_driver = {.probe = & wl18xx_probe, .remove = & wlcore_remove, .shutdown = (void (*)(struct platform_device *))0, .suspend = (int (*)(struct platform_device *, pm_message_t ))0, .resume = (int (*)(struct platform_device *))0, .driver = {.name = "wl18xx_driver", .bus = (struct bus_type *)0, .owner = (struct module *)0, .mod_name = (char const *)0, .suppress_bind_attrs = (_Bool)0, .probe_type = 0, .of_match_table = (struct of_device_id const *)0, .acpi_match_table = (struct acpi_device_id const *)0, .probe = (int (*)(struct device *))0, .remove = (int (*)(struct device *))0, .shutdown = (void (*)(struct device *))0, .suspend = (int (*)(struct device *, pm_message_t ))0, .resume = (int (*)(struct device *))0, .groups = (struct attribute_group const **)0, .pm = (struct dev_pm_ops const *)0, .p = (struct driver_private *)0}, .id_table = (struct platform_device_id const *)(& wl18xx_id_table), .prevent_deferred_probe = (_Bool)0};

#line 2010  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static int wl18xx_driver_init(void)
{
  int tmp;
  
#line 2010 
  tmp = ldv___platform_driver_register_73(& wl18xx_driver,& __this_module);
  
#line 2010 
  return tmp;
}


#line 2010  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/main.c"
static void wl18xx_driver_exit(void)
{
  
#line 2010 
  ldv_platform_driver_unregister_74(& wl18xx_driver);
  
#line 2011 
  return;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
struct platform_driver *ldv_emg_alias_wl18xx_driver_2 = & wl18xx_driver;

#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
int (*ldv_emg_alias_wlcore_remove_3)(struct platform_device *) = & wlcore_remove;

#line 60 
int ldv_emg___platform_driver_register(struct platform_driver *arg0, struct module *arg1);


#line 62 
void ldv_emg_platform_driver_unregister(struct platform_driver *arg0);


#line 67  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
void ldv_emg_wl18xx_driver_exit(void)
{
  
#line 68 
  wl18xx_driver_exit();
  
#line 69 
  return;
}


#line 71  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
int ldv_emg_wl18xx_driver_init(void)
{
  int tmp;
  
#line 72 
  tmp = wl18xx_driver_init();
  
#line 72 
  return tmp;
}


#line 75  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
int ldv_emg_wrapper_wl18xx_probe_2(struct platform_device *arg0)
{
  int tmp;
  
#line 76 
  tmp = wl18xx_probe(arg0);
  
#line 76 
  return tmp;
}


#line 88  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static long PTR_ERR(void const *ptr)
{
  long tmp;
  
#line 91 
  tmp = ldv_ptr_err(ptr);
  
#line 91 
  return tmp;
}


#line 95  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static bool IS_ERR(void const *ptr)
{
  bool __retres;
  long ret;
  
#line 99 
  ret = ldv_is_err(ptr);
  
#line 100 
  __retres = (_Bool)(ret != 0L);
  
#line 100 
  return __retres;
}


#line 759  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static int ldv___platform_driver_register_73(struct platform_driver *ldv_func_arg1, struct module *ldv_func_arg2)
{
  int tmp;
  
#line 763 
  tmp = ldv_emg___platform_driver_register(ldv_func_arg1,ldv_func_arg2);
  
#line 763 
  return tmp;
}


#line 767  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_main.c.aux"
static void ldv_platform_driver_unregister_74(struct platform_driver *ldv_func_arg1)
{
  
#line 771 
  ldv_emg_platform_driver_unregister(ldv_func_arg1);
  
#line 772 
  return;
}


#line 292  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
unsigned long __msecs_to_jiffies(unsigned int const);


#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
__inline static unsigned long _msecs_to_jiffies(unsigned int const m)
{
  unsigned long __retres;
  
#line 301 
  __retres = (unsigned long)(((long)m + 3L) / 4L);
  
#line 301 
  return __retres;
}


#line 354  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
__inline static unsigned long msecs_to_jiffies(unsigned int const m)
{
  unsigned long __retres;
  
#line 356 
  if (0 != 0) {
    unsigned long tmp;
    
#line 357 
    if ((int)m < 0) {
      
#line 358 
      __retres = 4611686018427387902UL;
      
#line 358 
      goto return_label;
    }
    else ;
    
#line 359 
    tmp = _msecs_to_jiffies(m);
    
#line 359 
    __retres = tmp;
    
#line 359 
    goto return_label;
  }
  else {
    unsigned long tmp_0;
    
#line 361 
    tmp_0 = __msecs_to_jiffies(m);
    
#line 361 
    __retres = tmp_0;
    
#line 361 
    goto return_label;
  }
  return_label: 
#line 356 
                return __retres;
}


#line 447  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
bool cancel_delayed_work(struct delayed_work *);


#line 581  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kzalloc_1(size_t size, gfp_t flags);


#line 4678  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
void ieee80211_queue_delayed_work(struct ieee80211_hw *, struct delayed_work *, unsigned long);


#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/cmd.h"
int wl12xx_cmd_build_probe_req(struct wl1271 *, struct wl12xx_vif *, u8, u8, u8 const *, size_t, u8 const *, size_t, u8 const *, size_t, bool);


#line 160  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/scan.h"
bool wlcore_set_scan_chan_params(struct wl1271 *, struct wlcore_scan_channels *, struct ieee80211_channel **, u32, u32, int);


#line 168 
int wlcore_scan_sched_scan_ssid_list(struct wl1271 *, struct wl12xx_vif *, struct cfg80211_sched_scan_request *);


#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/scan.c"
static void wl18xx_adjust_channels(struct wl18xx_cmd_scan_params *cmd, struct wlcore_scan_channels *cmd_channels)
{
  
#line 29 
  memcpy((void *)(& cmd->passive),(void const *)(& cmd_channels->passive),3UL);
  
#line 30 
  memcpy((void *)(& cmd->active),(void const *)(& cmd_channels->active),3UL);
  
#line 31 
  cmd->dfs = cmd_channels->dfs;
  
#line 32 
  cmd->passive_active = cmd_channels->passive_active;
  
#line 34 
  memcpy((void *)(& cmd->__anonCompField_wl18xx_cmd_scan_params_104.__anonCompField___anonunion_2694_103.channels_2),(void const *)(& cmd_channels->channels_2),168UL);
  
#line 36 
  memcpy((void *)(& cmd->__anonCompField_wl18xx_cmd_scan_params_104.__anonCompField___anonunion_2694_103.channels_5),(void const *)(& cmd_channels->channels_5),384UL);
  
#line 37 
  return;
}


#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/scan.c"
static int wl18xx_scan_send(struct wl1271 *wl, struct wl12xx_vif *wlvif, struct cfg80211_scan_request *req)
{
  struct wl18xx_cmd_scan_params *cmd;
  int ret;
  int tmp_0;
  
#line 45 
  struct wlcore_scan_channels *cmd_channels = (struct wlcore_scan_channels *)0;
  
#line 48 
  cmd = (struct wl18xx_cmd_scan_params *)kzalloc_1(672UL,208U);
  
#line 49 
  if (cmd == (struct wl18xx_cmd_scan_params *)0) {
    
#line 50 
    ret = -12;
    
#line 51 
    goto out;
  }
  else ;
  
#line 54 
  cmd->role_id = wlvif->role_id;
  {
    
#line 56 
    int __ret_warn_on = (unsigned int)cmd->role_id == 255U;
    
#line 56 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 56 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/scan.c",56); else ;
    
#line 56 
    tmp_0 = (long)(__ret_warn_on != 0);
  }
  
#line 56 
  if ((long)tmp_0 != 0L) {
    
#line 57 
    ret = -22;
    
#line 58 
    goto out;
  }
  else ;
  
#line 61 
  cmd->scan_type = (unsigned char)0U;
  
#line 62 
  cmd->rssi_threshold = (signed char)(-127);
  
#line 63 
  cmd->snr_threshold = (signed char)0;
  
#line 65 
  cmd->bss_type = (unsigned char)2U;
  
#line 67 
  cmd->ssid_from_list = (unsigned char)0U;
  
#line 68 
  cmd->filter = (unsigned char)0U;
  
#line 69 
  cmd->add_broadcast = (unsigned char)0U;
  
#line 71 
  cmd->urgency = (unsigned char)0U;
  
#line 72 
  cmd->protect = (unsigned char)0U;
  
#line 74 
  cmd->n_probe_reqs = (unsigned char)wl->conf.scan.num_probe_reqs;
  
#line 75 
  cmd->terminate_after = (unsigned char)0U;
  {
    
#line 78 
    int __ret_warn_on_0 = req->n_ssids > 1;
    
#line 78 
    if ((long)(__ret_warn_on_0 != 0) != 0L) 
#line 78 
                                            warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/scan.c",78); else ;
    
#line 78 
    long tmp_2 = (long)(__ret_warn_on_0 != 0);
  }
  
#line 80 
  cmd_channels = (struct wlcore_scan_channels *)kzalloc_1(728UL,208U);
  
#line 81 
  if (cmd_channels == (struct wlcore_scan_channels *)0) {
    
#line 82 
    ret = -12;
    
#line 83 
    goto out;
  }
  else ;
  
#line 86 
  wlcore_set_scan_chan_params(wl,cmd_channels,(struct ieee80211_channel **)(& req->channels),req->n_channels,(unsigned int)req->n_ssids,0);
  
#line 89 
  wl18xx_adjust_channels(cmd,cmd_channels);
  
#line 95 
  cmd->total_cycles = (unsigned char)1U;
  
#line 97 
  if ((int)req->no_cck != 0) 
#line 98 
                             cmd->rate = (unsigned char)2U; else ;
  
#line 100 
  cmd->tag = (unsigned char)1U;
  
#line 102 
  if (req->n_ssids != 0) {
    
#line 103 
    cmd->ssid_len = (req->ssids)->ssid_len;
    
#line 104 
    memcpy((void *)(& cmd->ssid),(void const *)(& (req->ssids)->ssid),(unsigned long)cmd->ssid_len);
  }
  else ;
  
#line 108 
  if ((unsigned int)cmd->active[0] != 0U) {
    int tmp_2_0;
    u8 *tmp_3;
    
#line 109 
    u8 band = (unsigned char)0U;
    
#line 110 
    ;
    
#line 110 
    ;
    
#line 113 
    if (req->ssids != (struct cfg80211_ssid *)0) 
#line 113 
                                                 tmp_2_0 = (int)(req->ssids)->ssid_len; else 
                                                                    
#line 113 
                                                                    tmp_2_0 = 0;
    
#line 112 
    if (req->ssids != (struct cfg80211_ssid *)0) 
#line 112 
                                                 tmp_3 = (u8 *)(& (req->ssids)->ssid); else 
                                                                    
#line 112 
                                                                    tmp_3 = (u8 *)0U;
    
#line 110 
    ;
    
#line 110 
    ;
    
#line 110 
    ;
    
#line 110 
    ;
    
#line 110 
    ret = wl12xx_cmd_build_probe_req(wl,wlvif,(unsigned char)((int)cmd->role_id),(unsigned char)((int)band),(u8 const *)tmp_3,(unsigned long)tmp_2_0,req->ie,req->ie_len,(u8 const *)0U,0UL,(_Bool)0);
    
#line 119 
    if (ret < 0) {
      
#line 120 
      printk("\001");
      
#line 121 
      goto out;
    }
    else ;
  }
  else ;
  
#line 125 
  if ((unsigned int)cmd->active[1] != 0U || (unsigned int)cmd->dfs != 0U) {
    int tmp_4;
    u8 *tmp_5;
    
#line 126 
    u8 band_0 = (unsigned char)1U;
    
#line 127 
    ;
    
#line 127 
    ;
    
#line 130 
    if (req->ssids != (struct cfg80211_ssid *)0) 
#line 130 
                                                 tmp_4 = (int)(req->ssids)->ssid_len; else 
                                                                    
#line 130 
                                                                    tmp_4 = 0;
    
#line 129 
    if (req->ssids != (struct cfg80211_ssid *)0) 
#line 129 
                                                 tmp_5 = (u8 *)(& (req->ssids)->ssid); else 
                                                                    
#line 129 
                                                                    tmp_5 = (u8 *)0U;
    
#line 127 
    ;
    
#line 127 
    ;
    
#line 127 
    ;
    
#line 127 
    ;
    
#line 127 
    ret = wl12xx_cmd_build_probe_req(wl,wlvif,(unsigned char)((int)cmd->role_id),(unsigned char)((int)band_0),(u8 const *)tmp_5,(unsigned long)tmp_4,req->ie,req->ie_len,(u8 const *)0U,0UL,(_Bool)0);
    
#line 136 
    if (ret < 0) {
      
#line 137 
      printk("\001");
      
#line 138 
      goto out;
    }
    else ;
  }
  else ;
  
#line 142 
  if ((wl12xx_debug_level & 256U) != 0U) {
    
#line 142 
    struct _ddebug descriptor = {.modname = "wl18xx", .function = "wl18xx_scan_send", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/scan.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))142U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 142 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      size_t tmp_7;
      {
        size_t tmp_6;
        
#line 142 
        size_t __min1 = 672UL;
        
#line 142 
        size_t __min2 = 1024UL;
        
#line 142 
        if (__min1 < __min2) 
#line 142 
                             tmp_6 = __min1; else 
#line 142 
                                                  tmp_6 = __min2;
        
#line 142 
        tmp_7 = tmp_6;
      }
      
#line 142 
      ;
      
#line 142 
      print_hex_dump("\001","wlcore",2,16,1,(void const *)cmd,tmp_7,(_Bool)0);
    }
    else ;
  }
  else ;
  
#line 144 
  ret = wl1271_cmd_send(wl,(unsigned short)7,(void *)cmd,672UL,0UL);
  
#line 145 
  if (ret < 0) {
    
#line 146 
    printk("\001");
    
#line 147 
    goto out;
  }
  else ;
  out: 
#line 150 
  ;
  
#line 151 
  kfree((void const *)cmd_channels);
  
#line 152 
  kfree((void const *)cmd);
  
#line 153 
  return ret;
}


#line 156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/scan.c"
void wl18xx_scan_completed(struct wl1271 *wl, struct wl12xx_vif *wlvif)
{
  unsigned long tmp;
  
#line 158 
  wl->scan.failed = (_Bool)0;
  
#line 159 
  cancel_delayed_work(& wl->scan_complete_work);
  
#line 160 
  tmp = msecs_to_jiffies(0U);
  
#line 160 
  ;
  
#line 160 
  ;
  
#line 160 
  ieee80211_queue_delayed_work(wl->hw,& wl->scan_complete_work,tmp);
  
#line 162 
  return;
}


#line 165  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/scan.c"
static int wl18xx_scan_sched_scan_config(struct wl1271 *wl, struct wl12xx_vif *wlvif, struct cfg80211_sched_scan_request *req, struct ieee80211_scan_ies *ies)
{
  int __retres;
  struct wl18xx_cmd_scan_params *cmd;
  int ret;
  int filter_type;
  int tmp_0;
  
#line 171 
  struct wlcore_scan_channels *cmd_channels = (struct wlcore_scan_channels *)0;
  
#line 172 
  struct conf_sched_scan_settings *c = & wl->conf.sched_scan;
  
#line 176 
  if ((long)((wl12xx_debug_level & 4096U) != 0U) != 0L) {
    
#line 176 
    struct _ddebug descriptor = {.modname = "wl18xx", .function = "wl18xx_scan_sched_scan_config", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/scan.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))176U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 176 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 176 
                                                        __dynamic_pr_debug(& descriptor,"wlcore"); else ;
  }
  else ;
  
#line 178 
  filter_type = wlcore_scan_sched_scan_ssid_list(wl,wlvif,req);
  
#line 179 
  if (filter_type < 0) {
    
#line 180 
    __retres = filter_type;
    
#line 180 
    goto return_label;
  }
  else ;
  
#line 182 
  cmd = (struct wl18xx_cmd_scan_params *)kzalloc_1(672UL,208U);
  
#line 183 
  if (cmd == (struct wl18xx_cmd_scan_params *)0) {
    
#line 184 
    ret = -12;
    
#line 185 
    goto out;
  }
  else ;
  
#line 188 
  cmd->role_id = wlvif->role_id;
  {
    
#line 190 
    int __ret_warn_on = (unsigned int)cmd->role_id == 255U;
    
#line 190 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 190 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/scan.c",190); else ;
    
#line 190 
    tmp_0 = (long)(__ret_warn_on != 0);
  }
  
#line 190 
  if ((long)tmp_0 != 0L) {
    
#line 191 
    ret = -22;
    
#line 192 
    goto out;
  }
  else ;
  
#line 195 
  cmd->scan_type = (unsigned char)1U;
  
#line 196 
  cmd->rssi_threshold = c->rssi_threshold;
  
#line 197 
  cmd->snr_threshold = c->snr_threshold;
  
#line 200 
  cmd->bss_type = (unsigned char)2U;
  
#line 202 
  cmd->ssid_from_list = (unsigned char)1U;
  
#line 203 
  if (filter_type == 2) 
#line 204 
                        cmd->filter = (unsigned char)1U; else ;
  
#line 205 
  cmd->add_broadcast = (unsigned char)0U;
  
#line 207 
  cmd->urgency = (unsigned char)0U;
  
#line 208 
  cmd->protect = (unsigned char)0U;
  
#line 210 
  cmd->n_probe_reqs = c->num_probe_reqs;
  
#line 212 
  cmd->terminate_after = (unsigned char)0U;
  
#line 214 
  cmd_channels = (struct wlcore_scan_channels *)kzalloc_1(728UL,208U);
  
#line 215 
  if (cmd_channels == (struct wlcore_scan_channels *)0) {
    
#line 216 
    ret = -12;
    
#line 217 
    goto out;
  }
  else ;
  
#line 221 
  wlcore_set_scan_chan_params(wl,cmd_channels,(struct ieee80211_channel **)(& req->channels),req->n_channels,(unsigned int)req->n_ssids,1);
  
#line 224 
  wl18xx_adjust_channels(cmd,cmd_channels);
  
#line 226 
  cmd->short_cycles_sec = (unsigned short)0U;
  
#line 227 
  cmd->long_cycles_sec = (unsigned short)req->interval;
  
#line 228 
  cmd->short_cycles_count = (unsigned char)0U;
  
#line 230 
  cmd->total_cycles = (unsigned char)0U;
  
#line 232 
  cmd->tag = (unsigned char)1U;
  
#line 235 
  cmd->report_threshold = (unsigned char)1U;
  
#line 236 
  cmd->terminate_on_report = (unsigned char)0U;
  
#line 238 
  if ((unsigned int)cmd->active[0] != 0U) {
    int tmp_2;
    u8 *tmp_3;
    
#line 239 
    u8 band = (unsigned char)0U;
    
#line 240 
    ;
    
#line 240 
    ;
    
#line 240 
    ;
    
#line 240 
    ;
    
#line 243 
    if (req->ssids != (struct cfg80211_ssid *)0) 
#line 243 
                                                 tmp_2 = (int)(req->ssids)->ssid_len; else 
                                                                    
#line 243 
                                                                    tmp_2 = 0;
    
#line 242 
    if (req->ssids != (struct cfg80211_ssid *)0) 
#line 242 
                                                 tmp_3 = (u8 *)(& (req->ssids)->ssid); else 
                                                                    
#line 242 
                                                                    tmp_3 = (u8 *)0U;
    
#line 240 
    ;
    
#line 240 
    ;
    
#line 240 
    ;
    
#line 240 
    ;
    
#line 240 
    ret = wl12xx_cmd_build_probe_req(wl,wlvif,(unsigned char)((int)cmd->role_id),(unsigned char)((int)band),(u8 const *)tmp_3,(unsigned long)tmp_2,ies->ies[(int)band],ies->len[(int)band],ies->common_ies,ies->common_ie_len,(_Bool)1);
    
#line 249 
    if (ret < 0) {
      
#line 250 
      printk("\001");
      
#line 251 
      goto out;
    }
    else ;
  }
  else ;
  
#line 255 
  if ((unsigned int)cmd->active[1] != 0U || (unsigned int)cmd->dfs != 0U) {
    int tmp_4;
    u8 *tmp_5;
    
#line 256 
    u8 band_0 = (unsigned char)1U;
    
#line 257 
    ;
    
#line 257 
    ;
    
#line 257 
    ;
    
#line 257 
    ;
    
#line 260 
    if (req->ssids != (struct cfg80211_ssid *)0) 
#line 260 
                                                 tmp_4 = (int)(req->ssids)->ssid_len; else 
                                                                    
#line 260 
                                                                    tmp_4 = 0;
    
#line 259 
    if (req->ssids != (struct cfg80211_ssid *)0) 
#line 259 
                                                 tmp_5 = (u8 *)(& (req->ssids)->ssid); else 
                                                                    
#line 259 
                                                                    tmp_5 = (u8 *)0U;
    
#line 257 
    ;
    
#line 257 
    ;
    
#line 257 
    ;
    
#line 257 
    ;
    
#line 257 
    ret = wl12xx_cmd_build_probe_req(wl,wlvif,(unsigned char)((int)cmd->role_id),(unsigned char)((int)band_0),(u8 const *)tmp_5,(unsigned long)tmp_4,ies->ies[(int)band_0],ies->len[(int)band_0],ies->common_ies,ies->common_ie_len,(_Bool)1);
    
#line 266 
    if (ret < 0) {
      
#line 267 
      printk("\001");
      
#line 268 
      goto out;
    }
    else ;
  }
  else ;
  
#line 272 
  if ((wl12xx_debug_level & 256U) != 0U) {
    
#line 272 
    struct _ddebug descriptor_0 = {.modname = "wl18xx", .function = "wl18xx_scan_sched_scan_config", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/scan.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))272U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 272 
    if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) {
      size_t tmp_7;
      {
        size_t tmp_6;
        
#line 272 
        size_t __min1 = 672UL;
        
#line 272 
        size_t __min2 = 1024UL;
        
#line 272 
        if (__min1 < __min2) 
#line 272 
                             tmp_6 = __min1; else 
#line 272 
                                                  tmp_6 = __min2;
        
#line 272 
        tmp_7 = tmp_6;
      }
      
#line 272 
      ;
      
#line 272 
      print_hex_dump("\001","wlcore",2,16,1,(void const *)cmd,tmp_7,(_Bool)0);
    }
    else ;
  }
  else ;
  
#line 274 
  ret = wl1271_cmd_send(wl,(unsigned short)7,(void *)cmd,672UL,0UL);
  
#line 275 
  if (ret < 0) {
    
#line 276 
    printk("\001");
    
#line 277 
    goto out;
  }
  else ;
  out: 
#line 280 
  ;
  
#line 281 
  kfree((void const *)cmd_channels);
  
#line 282 
  kfree((void const *)cmd);
  
#line 283 
  __retres = ret;
  return_label: 
#line 283 
                return __retres;
}


#line 286  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/scan.c"
int wl18xx_sched_scan_start(struct wl1271 *wl, struct wl12xx_vif *wlvif, struct cfg80211_sched_scan_request *req, struct ieee80211_scan_ies *ies)
{
  int tmp;
  
#line 290 
  tmp = wl18xx_scan_sched_scan_config(wl,wlvif,req,ies);
  
#line 290 
  return tmp;
}


#line 293  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/scan.c"
static int __wl18xx_scan_stop(struct wl1271 *wl, struct wl12xx_vif *wlvif, u8 scan_type)
{
  int __retres;
  struct wl18xx_cmd_scan_stop *stop;
  int ret;
  
#line 299 
  if ((long)((wl12xx_debug_level & 4096U) != 0U) != 0L) {
    
#line 299 
    struct _ddebug descriptor = {.modname = "wl18xx", .function = "__wl18xx_scan_stop", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/scan.c", .format = "wlcore", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))299U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 299 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 299 
                                                        __dynamic_pr_debug(& descriptor,"wlcore"); else ;
  }
  else ;
  
#line 301 
  stop = (struct wl18xx_cmd_scan_stop *)kzalloc_1(8UL,208U);
  
#line 302 
  if (stop == (struct wl18xx_cmd_scan_stop *)0) {
    
#line 303 
    printk("\001");
    
#line 304 
    __retres = -12;
    
#line 304 
    goto return_label;
  }
  else ;
  
#line 307 
  stop->role_id = wlvif->role_id;
  
#line 308 
  stop->scan_type = scan_type;
  
#line 310 
  ret = wl1271_cmd_send(wl,(unsigned short)8,(void *)stop,8UL,0UL);
  
#line 311 
  if (ret < 0) {
    
#line 312 
    printk("\001");
    
#line 313 
    goto out_free;
  }
  else ;
  out_free: 
#line 316 
  ;
  
#line 317 
  kfree((void const *)stop);
  
#line 318 
  __retres = ret;
  return_label: 
#line 318 
                return __retres;
}


#line 321  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/scan.c"
void wl18xx_scan_sched_scan_stop(struct wl1271 *wl, struct wl12xx_vif *wlvif)
{
  
#line 323 
  __wl18xx_scan_stop(wl,wlvif,(unsigned char)1);
  
#line 324 
  return;
}


#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/scan.c"
int wl18xx_scan_start(struct wl1271 *wl, struct wl12xx_vif *wlvif, struct cfg80211_scan_request *req)
{
  int tmp;
  
#line 328 
  tmp = wl18xx_scan_send(wl,wlvif,req);
  
#line 328 
  return tmp;
}


#line 331  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/scan.c"
int wl18xx_scan_stop(struct wl1271 *wl, struct wl12xx_vif *wlvif)
{
  int tmp;
  
#line 333 
  tmp = __wl18xx_scan_stop(wl,wlvif,(unsigned char)0);
  
#line 333 
  return tmp;
}


#line 423  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_scan.c.aux"
static void *kzalloc_1(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 426 
  tmp = ldv_kzalloc(size,flags);
  
#line 426 
  return tmp;
}


#line 368  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
int kstrtou8_from_user(char const *, size_t, unsigned int, u8 *);


#line 405 
int snprintf(char *, size_t, char const * , ...);


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/err.h"
static long PTR_ERR_0(void const *ptr);


#line 41 
static bool IS_ERR_0(void const *ptr);


#line 37  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static void ldv_mutex_lock_73(struct mutex *ldv_func_arg1);


#line 41 
static void ldv_mutex_lock_75(struct mutex *ldv_func_arg1);


#line 45 
static void ldv_mutex_lock_77(struct mutex *ldv_func_arg1);


#line 51 
void ldv_mutex_model_lock(struct mutex *, char *);


#line 53 
void ldv_mutex_model_unlock(struct mutex *, char *);


#line 24  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kmalloc(size_t size, gfp_t flags);


#line 193  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
static void ldv_mutex_unlock_74(struct mutex *ldv_func_arg1);


#line 197 
static void ldv_mutex_unlock_76(struct mutex *ldv_func_arg1);


#line 201 
static void ldv_mutex_unlock_78(struct mutex *ldv_func_arg1);


#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kmalloc(size_t size, gfp_t flags);


#line 2547  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
loff_t default_llseek(struct file *, loff_t, int);


#line 2662 
loff_t generic_file_llseek(struct file *, loff_t, int);


#line 2812 
int simple_open(struct inode *, struct file *);


#line 2843 
ssize_t simple_read_from_buffer(void *, size_t, loff_t *, void const *, size_t);


#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debugfs.h"
static struct dentry *ldv_debugfs_create_file_79(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 58 
static struct dentry *ldv_debugfs_create_file_80(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 62 
static struct dentry *ldv_debugfs_create_file_81(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 66 
static struct dentry *ldv_debugfs_create_file_82(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 70 
static struct dentry *ldv_debugfs_create_file_83(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 74 
static struct dentry *ldv_debugfs_create_file_84(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 78 
static struct dentry *ldv_debugfs_create_file_85(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 82 
static struct dentry *ldv_debugfs_create_file_86(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 86 
static struct dentry *ldv_debugfs_create_file_87(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 90 
static struct dentry *ldv_debugfs_create_file_88(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 94 
static struct dentry *ldv_debugfs_create_file_89(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 98 
static struct dentry *ldv_debugfs_create_file_90(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 102 
static struct dentry *ldv_debugfs_create_file_91(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 106 
static struct dentry *ldv_debugfs_create_file_92(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 110 
static struct dentry *ldv_debugfs_create_file_93(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 114 
static struct dentry *ldv_debugfs_create_file_94(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 118 
static struct dentry *ldv_debugfs_create_file_95(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 122 
static struct dentry *ldv_debugfs_create_file_96(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 126 
static struct dentry *ldv_debugfs_create_file_97(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 130 
static struct dentry *ldv_debugfs_create_file_98(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 134 
static struct dentry *ldv_debugfs_create_file_99(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 138 
static struct dentry *ldv_debugfs_create_file_100(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 142 
static struct dentry *ldv_debugfs_create_file_101(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 146 
static struct dentry *ldv_debugfs_create_file_102(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 150 
static struct dentry *ldv_debugfs_create_file_103(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 154 
static struct dentry *ldv_debugfs_create_file_104(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 158 
static struct dentry *ldv_debugfs_create_file_105(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 162 
static struct dentry *ldv_debugfs_create_file_106(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 166 
static struct dentry *ldv_debugfs_create_file_107(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 170 
static struct dentry *ldv_debugfs_create_file_108(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 174 
static struct dentry *ldv_debugfs_create_file_109(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 178 
static struct dentry *ldv_debugfs_create_file_110(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 182 
static struct dentry *ldv_debugfs_create_file_111(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 186 
static struct dentry *ldv_debugfs_create_file_112(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 190 
static struct dentry *ldv_debugfs_create_file_113(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 194 
static struct dentry *ldv_debugfs_create_file_114(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 198 
static struct dentry *ldv_debugfs_create_file_115(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 202 
static struct dentry *ldv_debugfs_create_file_116(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 206 
static struct dentry *ldv_debugfs_create_file_117(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 210 
static struct dentry *ldv_debugfs_create_file_118(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 214 
static struct dentry *ldv_debugfs_create_file_119(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 218 
static struct dentry *ldv_debugfs_create_file_120(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 222 
static struct dentry *ldv_debugfs_create_file_121(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 226 
static struct dentry *ldv_debugfs_create_file_122(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 230 
static struct dentry *ldv_debugfs_create_file_123(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 234 
static struct dentry *ldv_debugfs_create_file_124(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 238 
static struct dentry *ldv_debugfs_create_file_125(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 242 
static struct dentry *ldv_debugfs_create_file_126(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 246 
static struct dentry *ldv_debugfs_create_file_127(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 250 
static struct dentry *ldv_debugfs_create_file_128(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 254 
static struct dentry *ldv_debugfs_create_file_129(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 258 
static struct dentry *ldv_debugfs_create_file_130(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 262 
static struct dentry *ldv_debugfs_create_file_131(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 266 
static struct dentry *ldv_debugfs_create_file_132(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 270 
static struct dentry *ldv_debugfs_create_file_133(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 274 
static struct dentry *ldv_debugfs_create_file_134(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 278 
static struct dentry *ldv_debugfs_create_file_135(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 282 
static struct dentry *ldv_debugfs_create_file_136(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 286 
static struct dentry *ldv_debugfs_create_file_137(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 290 
static struct dentry *ldv_debugfs_create_file_138(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 294 
static struct dentry *ldv_debugfs_create_file_139(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 298 
static struct dentry *ldv_debugfs_create_file_140(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 302 
static struct dentry *ldv_debugfs_create_file_141(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 306 
static struct dentry *ldv_debugfs_create_file_142(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 310 
static struct dentry *ldv_debugfs_create_file_143(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 314 
static struct dentry *ldv_debugfs_create_file_144(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 318 
static struct dentry *ldv_debugfs_create_file_145(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 322 
static struct dentry *ldv_debugfs_create_file_146(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 326 
static struct dentry *ldv_debugfs_create_file_147(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 330 
static struct dentry *ldv_debugfs_create_file_148(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 334 
static struct dentry *ldv_debugfs_create_file_149(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 338 
static struct dentry *ldv_debugfs_create_file_150(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 342 
static struct dentry *ldv_debugfs_create_file_151(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 346 
static struct dentry *ldv_debugfs_create_file_152(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 350 
static struct dentry *ldv_debugfs_create_file_153(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 354 
static struct dentry *ldv_debugfs_create_file_154(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 358 
static struct dentry *ldv_debugfs_create_file_155(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 362 
static struct dentry *ldv_debugfs_create_file_156(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 366 
static struct dentry *ldv_debugfs_create_file_157(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 370 
static struct dentry *ldv_debugfs_create_file_158(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 374 
static struct dentry *ldv_debugfs_create_file_159(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 378 
static struct dentry *ldv_debugfs_create_file_160(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 382 
static struct dentry *ldv_debugfs_create_file_161(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 386 
static struct dentry *ldv_debugfs_create_file_162(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 390 
static struct dentry *ldv_debugfs_create_file_163(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 394 
static struct dentry *ldv_debugfs_create_file_164(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 398 
static struct dentry *ldv_debugfs_create_file_165(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 402 
static struct dentry *ldv_debugfs_create_file_166(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 406 
static struct dentry *ldv_debugfs_create_file_167(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 410 
static struct dentry *ldv_debugfs_create_file_168(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 414 
static struct dentry *ldv_debugfs_create_file_169(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 418 
static struct dentry *ldv_debugfs_create_file_170(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 422 
static struct dentry *ldv_debugfs_create_file_171(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 426 
static struct dentry *ldv_debugfs_create_file_172(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 430 
static struct dentry *ldv_debugfs_create_file_173(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 434 
static struct dentry *ldv_debugfs_create_file_174(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 438 
static struct dentry *ldv_debugfs_create_file_175(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 442 
static struct dentry *ldv_debugfs_create_file_176(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 446 
static struct dentry *ldv_debugfs_create_file_177(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 450 
static struct dentry *ldv_debugfs_create_file_178(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 454 
static struct dentry *ldv_debugfs_create_file_179(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 458 
static struct dentry *ldv_debugfs_create_file_180(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 462 
static struct dentry *ldv_debugfs_create_file_181(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 466 
static struct dentry *ldv_debugfs_create_file_182(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 470 
static struct dentry *ldv_debugfs_create_file_183(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 474 
static struct dentry *ldv_debugfs_create_file_184(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 478 
static struct dentry *ldv_debugfs_create_file_185(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 482 
static struct dentry *ldv_debugfs_create_file_186(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 486 
static struct dentry *ldv_debugfs_create_file_187(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 490 
static struct dentry *ldv_debugfs_create_file_188(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 494 
static struct dentry *ldv_debugfs_create_file_189(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 498 
static struct dentry *ldv_debugfs_create_file_190(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 502 
static struct dentry *ldv_debugfs_create_file_191(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 506 
static struct dentry *ldv_debugfs_create_file_192(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 510 
static struct dentry *ldv_debugfs_create_file_193(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 514 
static struct dentry *ldv_debugfs_create_file_194(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 518 
static struct dentry *ldv_debugfs_create_file_195(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 522 
static struct dentry *ldv_debugfs_create_file_196(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 526 
static struct dentry *ldv_debugfs_create_file_197(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 530 
static struct dentry *ldv_debugfs_create_file_198(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 534 
static struct dentry *ldv_debugfs_create_file_199(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 542 
struct dentry *debugfs_create_dir(char const *, struct dentry *);


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/debugfs.h"
int wl1271_format_buffer(char *, size_t, loff_t *, char * , ...);


#line 35 
void wl1271_debugfs_update_stats(struct wl1271 *);


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wlcore/ps.h"
void wl1271_ps_elp_sleep(struct wl1271 *);


#line 33 
int wl1271_ps_elp_wakeup(struct wl1271 *);


#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t debug_debug1_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 39 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 39 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 39 
  wl1271_debugfs_update_stats(wl);
  
#line 39 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->debug.debug1);
  
#line 39 
  __retres = (long)tmp;
  
#line 39 
  return __retres;
}


#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const debug_debug1_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & debug_debug1_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t debug_debug2_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 40 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 40 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 40 
  wl1271_debugfs_update_stats(wl);
  
#line 40 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->debug.debug2);
  
#line 40 
  __retres = (long)tmp;
  
#line 40 
  return __retres;
}


#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const debug_debug2_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & debug_debug2_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t debug_debug3_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 41 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 41 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 41 
  wl1271_debugfs_update_stats(wl);
  
#line 41 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->debug.debug3);
  
#line 41 
  __retres = (long)tmp;
  
#line 41 
  return __retres;
}


#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const debug_debug3_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & debug_debug3_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t debug_debug4_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 42 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 42 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 42 
  wl1271_debugfs_update_stats(wl);
  
#line 42 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->debug.debug4);
  
#line 42 
  __retres = (long)tmp;
  
#line 42 
  return __retres;
}


#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const debug_debug4_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & debug_debug4_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t debug_debug5_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 43 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 43 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 43 
  wl1271_debugfs_update_stats(wl);
  
#line 43 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->debug.debug5);
  
#line 43 
  __retres = (long)tmp;
  
#line 43 
  return __retres;
}


#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const debug_debug5_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & debug_debug5_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t debug_debug6_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 44 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 44 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 44 
  wl1271_debugfs_update_stats(wl);
  
#line 44 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->debug.debug6);
  
#line 44 
  __retres = (long)tmp;
  
#line 44 
  return __retres;
}


#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const debug_debug6_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & debug_debug6_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t error_error_frame_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 46 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 46 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 46 
  wl1271_debugfs_update_stats(wl);
  
#line 46 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->error.error_frame);
  
#line 46 
  __retres = (long)tmp;
  
#line 46 
  return __retres;
}


#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const error_error_frame_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & error_error_frame_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t error_error_null_Frame_tx_start_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 47 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 47 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 47 
  wl1271_debugfs_update_stats(wl);
  
#line 47 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->error.error_null_Frame_tx_start);
  
#line 47 
  __retres = (long)tmp;
  
#line 47 
  return __retres;
}


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const error_error_null_Frame_tx_start_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & error_error_null_Frame_tx_start_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t error_error_numll_frame_cts_start_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 48 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 48 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 48 
  wl1271_debugfs_update_stats(wl);
  
#line 48 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->error.error_numll_frame_cts_start);
  
#line 48 
  __retres = (long)tmp;
  
#line 48 
  return __retres;
}


#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const error_error_numll_frame_cts_start_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & error_error_numll_frame_cts_start_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t error_error_bar_retry_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 49 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 49 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 49 
  wl1271_debugfs_update_stats(wl);
  
#line 49 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->error.error_bar_retry);
  
#line 49 
  __retres = (long)tmp;
  
#line 49 
  return __retres;
}


#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const error_error_bar_retry_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & error_error_bar_retry_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t error_error_frame_cts_nul_flid_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 50 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 50 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 50 
  wl1271_debugfs_update_stats(wl);
  
#line 50 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->error.error_frame_cts_nul_flid);
  
#line 50 
  __retres = (long)tmp;
  
#line 50 
  return __retres;
}


#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const error_error_frame_cts_nul_flid_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & error_error_frame_cts_nul_flid_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_tx_prepared_descs_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 52 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 52 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 52 
  wl1271_debugfs_update_stats(wl);
  
#line 52 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.tx_prepared_descs);
  
#line 52 
  __retres = (long)tmp;
  
#line 52 
  return __retres;
}


#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_tx_prepared_descs_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_tx_prepared_descs_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_tx_cmplt_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 53 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 53 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 53 
  wl1271_debugfs_update_stats(wl);
  
#line 53 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.tx_cmplt);
  
#line 53 
  __retres = (long)tmp;
  
#line 53 
  return __retres;
}


#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_tx_cmplt_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_tx_cmplt_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_tx_template_prepared_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 54 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 54 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 54 
  wl1271_debugfs_update_stats(wl);
  
#line 54 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.tx_template_prepared);
  
#line 54 
  __retres = (long)tmp;
  
#line 54 
  return __retres;
}


#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_tx_template_prepared_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_tx_template_prepared_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_tx_data_prepared_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 55 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 55 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 55 
  wl1271_debugfs_update_stats(wl);
  
#line 55 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.tx_data_prepared);
  
#line 55 
  __retres = (long)tmp;
  
#line 55 
  return __retres;
}


#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_tx_data_prepared_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_tx_data_prepared_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_tx_template_programmed_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 56 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 56 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 56 
  wl1271_debugfs_update_stats(wl);
  
#line 56 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.tx_template_programmed);
  
#line 56 
  __retres = (long)tmp;
  
#line 56 
  return __retres;
}


#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_tx_template_programmed_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_tx_template_programmed_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_tx_data_programmed_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 57 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 57 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 57 
  wl1271_debugfs_update_stats(wl);
  
#line 57 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.tx_data_programmed);
  
#line 57 
  __retres = (long)tmp;
  
#line 57 
  return __retres;
}


#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_tx_data_programmed_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_tx_data_programmed_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_tx_burst_programmed_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 58 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 58 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 58 
  wl1271_debugfs_update_stats(wl);
  
#line 58 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.tx_burst_programmed);
  
#line 58 
  __retres = (long)tmp;
  
#line 58 
  return __retres;
}


#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_tx_burst_programmed_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_tx_burst_programmed_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_tx_starts_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 59 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 59 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 59 
  wl1271_debugfs_update_stats(wl);
  
#line 59 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.tx_starts);
  
#line 59 
  __retres = (long)tmp;
  
#line 59 
  return __retres;
}


#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_tx_starts_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_tx_starts_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_tx_imm_resp_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 60 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 60 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 60 
  wl1271_debugfs_update_stats(wl);
  
#line 60 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.tx_imm_resp);
  
#line 60 
  __retres = (long)tmp;
  
#line 60 
  return __retres;
}


#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_tx_imm_resp_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_tx_imm_resp_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_tx_start_templates_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 61 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 61 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 61 
  wl1271_debugfs_update_stats(wl);
  
#line 61 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.tx_start_templates);
  
#line 61 
  __retres = (long)tmp;
  
#line 61 
  return __retres;
}


#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_tx_start_templates_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_tx_start_templates_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_tx_start_int_templates_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 62 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 62 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 62 
  wl1271_debugfs_update_stats(wl);
  
#line 62 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.tx_start_int_templates);
  
#line 62 
  __retres = (long)tmp;
  
#line 62 
  return __retres;
}


#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_tx_start_int_templates_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_tx_start_int_templates_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_tx_start_fw_gen_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 63 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 63 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 63 
  wl1271_debugfs_update_stats(wl);
  
#line 63 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.tx_start_fw_gen);
  
#line 63 
  __retres = (long)tmp;
  
#line 63 
  return __retres;
}


#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_tx_start_fw_gen_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_tx_start_fw_gen_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_tx_start_data_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 64 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 64 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 64 
  wl1271_debugfs_update_stats(wl);
  
#line 64 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.tx_start_data);
  
#line 64 
  __retres = (long)tmp;
  
#line 64 
  return __retres;
}


#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_tx_start_data_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_tx_start_data_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_tx_start_null_frame_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 65 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 65 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 65 
  wl1271_debugfs_update_stats(wl);
  
#line 65 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.tx_start_null_frame);
  
#line 65 
  __retres = (long)tmp;
  
#line 65 
  return __retres;
}


#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_tx_start_null_frame_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_tx_start_null_frame_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_tx_exch_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 66 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 66 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 66 
  wl1271_debugfs_update_stats(wl);
  
#line 66 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.tx_exch);
  
#line 66 
  __retres = (long)tmp;
  
#line 66 
  return __retres;
}


#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_tx_exch_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_tx_exch_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_tx_retry_template_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 67 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 67 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 67 
  wl1271_debugfs_update_stats(wl);
  
#line 67 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.tx_retry_template);
  
#line 67 
  __retres = (long)tmp;
  
#line 67 
  return __retres;
}


#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_tx_retry_template_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_tx_retry_template_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_tx_retry_data_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 68 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 68 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 68 
  wl1271_debugfs_update_stats(wl);
  
#line 68 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.tx_retry_data);
  
#line 68 
  __retres = (long)tmp;
  
#line 68 
  return __retres;
}


#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_tx_retry_data_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_tx_retry_data_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_tx_exch_pending_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 69 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 69 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 69 
  wl1271_debugfs_update_stats(wl);
  
#line 69 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.tx_exch_pending);
  
#line 69 
  __retres = (long)tmp;
  
#line 69 
  return __retres;
}


#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_tx_exch_pending_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_tx_exch_pending_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_tx_exch_expiry_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 70 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 70 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 70 
  wl1271_debugfs_update_stats(wl);
  
#line 70 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.tx_exch_expiry);
  
#line 70 
  __retres = (long)tmp;
  
#line 70 
  return __retres;
}


#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_tx_exch_expiry_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_tx_exch_expiry_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_tx_done_template_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 71 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 71 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 71 
  wl1271_debugfs_update_stats(wl);
  
#line 71 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.tx_done_template);
  
#line 71 
  __retres = (long)tmp;
  
#line 71 
  return __retres;
}


#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_tx_done_template_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_tx_done_template_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_tx_done_data_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 72 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 72 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 72 
  wl1271_debugfs_update_stats(wl);
  
#line 72 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.tx_done_data);
  
#line 72 
  __retres = (long)tmp;
  
#line 72 
  return __retres;
}


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_tx_done_data_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_tx_done_data_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_tx_done_int_template_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 73 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 73 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 73 
  wl1271_debugfs_update_stats(wl);
  
#line 73 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.tx_done_int_template);
  
#line 73 
  __retres = (long)tmp;
  
#line 73 
  return __retres;
}


#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_tx_done_int_template_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_tx_done_int_template_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_tx_frame_checksum_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 74 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 74 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 74 
  wl1271_debugfs_update_stats(wl);
  
#line 74 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.tx_frame_checksum);
  
#line 74 
  __retres = (long)tmp;
  
#line 74 
  return __retres;
}


#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_tx_frame_checksum_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_tx_frame_checksum_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_tx_checksum_result_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 75 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 75 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 75 
  wl1271_debugfs_update_stats(wl);
  
#line 75 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.tx_checksum_result);
  
#line 75 
  __retres = (long)tmp;
  
#line 75 
  return __retres;
}


#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_tx_checksum_result_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_tx_checksum_result_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_frag_called_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 76 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 76 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 76 
  wl1271_debugfs_update_stats(wl);
  
#line 76 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.frag_called);
  
#line 76 
  __retres = (long)tmp;
  
#line 76 
  return __retres;
}


#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_frag_called_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_frag_called_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 77  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_frag_mpdu_alloc_failed_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 77 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 77 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 77 
  wl1271_debugfs_update_stats(wl);
  
#line 77 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.frag_mpdu_alloc_failed);
  
#line 77 
  __retres = (long)tmp;
  
#line 77 
  return __retres;
}


#line 77  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_frag_mpdu_alloc_failed_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_frag_mpdu_alloc_failed_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_frag_init_called_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 78 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 78 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 78 
  wl1271_debugfs_update_stats(wl);
  
#line 78 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.frag_init_called);
  
#line 78 
  __retres = (long)tmp;
  
#line 78 
  return __retres;
}


#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_frag_init_called_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_frag_init_called_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_frag_in_process_called_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 79 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 79 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 79 
  wl1271_debugfs_update_stats(wl);
  
#line 79 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.frag_in_process_called);
  
#line 79 
  __retres = (long)tmp;
  
#line 79 
  return __retres;
}


#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_frag_in_process_called_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_frag_in_process_called_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_frag_tkip_called_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 80 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 80 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 80 
  wl1271_debugfs_update_stats(wl);
  
#line 80 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.frag_tkip_called);
  
#line 80 
  __retres = (long)tmp;
  
#line 80 
  return __retres;
}


#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_frag_tkip_called_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_frag_tkip_called_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_frag_key_not_found_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 81 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 81 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 81 
  wl1271_debugfs_update_stats(wl);
  
#line 81 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.frag_key_not_found);
  
#line 81 
  __retres = (long)tmp;
  
#line 81 
  return __retres;
}


#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_frag_key_not_found_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_frag_key_not_found_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 82  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_frag_need_fragmentation_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 82 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 82 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 82 
  wl1271_debugfs_update_stats(wl);
  
#line 82 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.frag_need_fragmentation);
  
#line 82 
  __retres = (long)tmp;
  
#line 82 
  return __retres;
}


#line 82  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_frag_need_fragmentation_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_frag_need_fragmentation_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_frag_bad_mblk_num_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 83 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 83 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 83 
  wl1271_debugfs_update_stats(wl);
  
#line 83 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.frag_bad_mblk_num);
  
#line 83 
  __retres = (long)tmp;
  
#line 83 
  return __retres;
}


#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_frag_bad_mblk_num_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_frag_bad_mblk_num_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 84  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_frag_failed_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 84 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 84 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 84 
  wl1271_debugfs_update_stats(wl);
  
#line 84 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.frag_failed);
  
#line 84 
  __retres = (long)tmp;
  
#line 84 
  return __retres;
}


#line 84  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_frag_failed_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_frag_failed_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_frag_cache_hit_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 85 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 85 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 85 
  wl1271_debugfs_update_stats(wl);
  
#line 85 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.frag_cache_hit);
  
#line 85 
  __retres = (long)tmp;
  
#line 85 
  return __retres;
}


#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_frag_cache_hit_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_frag_cache_hit_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t tx_frag_cache_miss_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 86 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 86 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 86 
  wl1271_debugfs_update_stats(wl);
  
#line 86 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->tx.frag_cache_miss);
  
#line 86 
  __retres = (long)tmp;
  
#line 86 
  return __retres;
}


#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const tx_frag_cache_miss_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & tx_frag_cache_miss_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_rx_beacon_early_term_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 88 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 88 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 88 
  wl1271_debugfs_update_stats(wl);
  
#line 88 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.rx_beacon_early_term);
  
#line 88 
  __retres = (long)tmp;
  
#line 88 
  return __retres;
}


#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_rx_beacon_early_term_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_rx_beacon_early_term_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_rx_out_of_mpdu_nodes_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 89 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 89 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 89 
  wl1271_debugfs_update_stats(wl);
  
#line 89 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.rx_out_of_mpdu_nodes);
  
#line 89 
  __retres = (long)tmp;
  
#line 89 
  return __retres;
}


#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_rx_out_of_mpdu_nodes_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_rx_out_of_mpdu_nodes_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_rx_hdr_overflow_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 90 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 90 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 90 
  wl1271_debugfs_update_stats(wl);
  
#line 90 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.rx_hdr_overflow);
  
#line 90 
  __retres = (long)tmp;
  
#line 90 
  return __retres;
}


#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_rx_hdr_overflow_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_rx_hdr_overflow_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_rx_dropped_frame_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 91 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 91 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 91 
  wl1271_debugfs_update_stats(wl);
  
#line 91 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.rx_dropped_frame);
  
#line 91 
  __retres = (long)tmp;
  
#line 91 
  return __retres;
}


#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_rx_dropped_frame_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_rx_dropped_frame_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 92  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_rx_done_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 92 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 92 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 92 
  wl1271_debugfs_update_stats(wl);
  
#line 92 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.rx_done);
  
#line 92 
  __retres = (long)tmp;
  
#line 92 
  return __retres;
}


#line 92  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_rx_done_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_rx_done_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_rx_defrag_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 93 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 93 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 93 
  wl1271_debugfs_update_stats(wl);
  
#line 93 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.rx_defrag);
  
#line 93 
  __retres = (long)tmp;
  
#line 93 
  return __retres;
}


#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_rx_defrag_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_rx_defrag_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 94  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_rx_defrag_end_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 94 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 94 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 94 
  wl1271_debugfs_update_stats(wl);
  
#line 94 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.rx_defrag_end);
  
#line 94 
  __retres = (long)tmp;
  
#line 94 
  return __retres;
}


#line 94  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_rx_defrag_end_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_rx_defrag_end_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_rx_cmplt_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 95 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 95 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 95 
  wl1271_debugfs_update_stats(wl);
  
#line 95 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.rx_cmplt);
  
#line 95 
  __retres = (long)tmp;
  
#line 95 
  return __retres;
}


#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_rx_cmplt_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_rx_cmplt_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_rx_pre_complt_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 96 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 96 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 96 
  wl1271_debugfs_update_stats(wl);
  
#line 96 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.rx_pre_complt);
  
#line 96 
  __retres = (long)tmp;
  
#line 96 
  return __retres;
}


#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_rx_pre_complt_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_rx_pre_complt_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 97  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_rx_cmplt_task_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 97 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 97 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 97 
  wl1271_debugfs_update_stats(wl);
  
#line 97 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.rx_cmplt_task);
  
#line 97 
  __retres = (long)tmp;
  
#line 97 
  return __retres;
}


#line 97  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_rx_cmplt_task_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_rx_cmplt_task_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 98  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_rx_phy_hdr_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 98 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 98 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 98 
  wl1271_debugfs_update_stats(wl);
  
#line 98 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.rx_phy_hdr);
  
#line 98 
  __retres = (long)tmp;
  
#line 98 
  return __retres;
}


#line 98  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_rx_phy_hdr_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_rx_phy_hdr_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 99  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_rx_timeout_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 99 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 99 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 99 
  wl1271_debugfs_update_stats(wl);
  
#line 99 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.rx_timeout);
  
#line 99 
  __retres = (long)tmp;
  
#line 99 
  return __retres;
}


#line 99  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_rx_timeout_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_rx_timeout_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_rx_timeout_wa_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 100 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 100 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 100 
  wl1271_debugfs_update_stats(wl);
  
#line 100 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.rx_timeout_wa);
  
#line 100 
  __retres = (long)tmp;
  
#line 100 
  return __retres;
}


#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_rx_timeout_wa_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_rx_timeout_wa_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_rx_wa_density_dropped_frame_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 101 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 101 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 101 
  wl1271_debugfs_update_stats(wl);
  
#line 101 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.rx_wa_density_dropped_frame);
  
#line 101 
  __retres = (long)tmp;
  
#line 101 
  return __retres;
}


#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_rx_wa_density_dropped_frame_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_rx_wa_density_dropped_frame_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_rx_wa_ba_not_expected_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 102 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 102 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 102 
  wl1271_debugfs_update_stats(wl);
  
#line 102 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.rx_wa_ba_not_expected);
  
#line 102 
  __retres = (long)tmp;
  
#line 102 
  return __retres;
}


#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_rx_wa_ba_not_expected_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_rx_wa_ba_not_expected_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 103  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_rx_frame_checksum_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 103 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 103 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 103 
  wl1271_debugfs_update_stats(wl);
  
#line 103 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.rx_frame_checksum);
  
#line 103 
  __retres = (long)tmp;
  
#line 103 
  return __retres;
}


#line 103  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_rx_frame_checksum_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_rx_frame_checksum_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_rx_checksum_result_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 104 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 104 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 104 
  wl1271_debugfs_update_stats(wl);
  
#line 104 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.rx_checksum_result);
  
#line 104 
  __retres = (long)tmp;
  
#line 104 
  return __retres;
}


#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_rx_checksum_result_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_rx_checksum_result_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_defrag_called_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 105 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 105 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 105 
  wl1271_debugfs_update_stats(wl);
  
#line 105 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.defrag_called);
  
#line 105 
  __retres = (long)tmp;
  
#line 105 
  return __retres;
}


#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_defrag_called_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_defrag_called_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_defrag_init_called_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 106 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 106 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 106 
  wl1271_debugfs_update_stats(wl);
  
#line 106 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.defrag_init_called);
  
#line 106 
  __retres = (long)tmp;
  
#line 106 
  return __retres;
}


#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_defrag_init_called_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_defrag_init_called_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_defrag_in_process_called_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 107 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 107 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 107 
  wl1271_debugfs_update_stats(wl);
  
#line 107 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.defrag_in_process_called);
  
#line 107 
  __retres = (long)tmp;
  
#line 107 
  return __retres;
}


#line 107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_defrag_in_process_called_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_defrag_in_process_called_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 108  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_defrag_tkip_called_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 108 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 108 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 108 
  wl1271_debugfs_update_stats(wl);
  
#line 108 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.defrag_tkip_called);
  
#line 108 
  __retres = (long)tmp;
  
#line 108 
  return __retres;
}


#line 108  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_defrag_tkip_called_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_defrag_tkip_called_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 109  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_defrag_need_defrag_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 109 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 109 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 109 
  wl1271_debugfs_update_stats(wl);
  
#line 109 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.defrag_need_defrag);
  
#line 109 
  __retres = (long)tmp;
  
#line 109 
  return __retres;
}


#line 109  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_defrag_need_defrag_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_defrag_need_defrag_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_defrag_decrypt_failed_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 110 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 110 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 110 
  wl1271_debugfs_update_stats(wl);
  
#line 110 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.defrag_decrypt_failed);
  
#line 110 
  __retres = (long)tmp;
  
#line 110 
  return __retres;
}


#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_defrag_decrypt_failed_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_defrag_decrypt_failed_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_decrypt_key_not_found_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 111 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 111 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 111 
  wl1271_debugfs_update_stats(wl);
  
#line 111 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.decrypt_key_not_found);
  
#line 111 
  __retres = (long)tmp;
  
#line 111 
  return __retres;
}


#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_decrypt_key_not_found_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_decrypt_key_not_found_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_defrag_need_decrypt_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 112 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 112 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 112 
  wl1271_debugfs_update_stats(wl);
  
#line 112 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.defrag_need_decrypt);
  
#line 112 
  __retres = (long)tmp;
  
#line 112 
  return __retres;
}


#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_defrag_need_decrypt_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_defrag_need_decrypt_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_rx_tkip_replays_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 113 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 113 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 113 
  wl1271_debugfs_update_stats(wl);
  
#line 113 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx.rx_tkip_replays);
  
#line 113 
  __retres = (long)tmp;
  
#line 113 
  return __retres;
}


#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_rx_tkip_replays_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_rx_tkip_replays_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t isr_irqs_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 115 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 115 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 115 
  wl1271_debugfs_update_stats(wl);
  
#line 115 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->isr.irqs);
  
#line 115 
  __retres = (long)tmp;
  
#line 115 
  return __retres;
}


#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const isr_irqs_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & isr_irqs_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t pwr_missing_bcns_cnt_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 117 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 117 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 117 
  wl1271_debugfs_update_stats(wl);
  
#line 117 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pwr.missing_bcns_cnt);
  
#line 117 
  __retres = (long)tmp;
  
#line 117 
  return __retres;
}


#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const pwr_missing_bcns_cnt_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pwr_missing_bcns_cnt_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t pwr_rcvd_bcns_cnt_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 118 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 118 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 118 
  wl1271_debugfs_update_stats(wl);
  
#line 118 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pwr.rcvd_bcns_cnt);
  
#line 118 
  __retres = (long)tmp;
  
#line 118 
  return __retres;
}


#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const pwr_rcvd_bcns_cnt_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pwr_rcvd_bcns_cnt_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t pwr_connection_out_of_sync_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 119 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 119 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 119 
  wl1271_debugfs_update_stats(wl);
  
#line 119 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pwr.connection_out_of_sync);
  
#line 119 
  __retres = (long)tmp;
  
#line 119 
  return __retres;
}


#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const pwr_connection_out_of_sync_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pwr_connection_out_of_sync_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t pwr_cont_miss_bcns_spread_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int res;
  int i;
  int tmp;
  
#line 120 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 120 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 120 
  char buf[256U] = {(char)'\000'};
  
#line 120 
  wl1271_debugfs_update_stats(wl);
  
#line 120 
  i = 0;
  
#line 120 
  goto ldv_54278;
  ldv_54277: 
#line 121 
  ;
  
#line 120 
  res = snprintf((char *)(& buf),256UL,"%s[%d] = %d\n",(char *)(& buf),i,stats->pwr.cont_miss_bcns_spread[i]);
  
#line 120 
  i += 1;
  ldv_54278: 
#line 121 
  ;
  
#line 120 
  if (i <= 9) 
#line 122 
              goto ldv_54277; else 
#line 125 
                                   goto ldv_54279;
  ldv_54279: 
#line 126 
  ;
  
#line 120 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%s",(char *)(& buf));
  
#line 120 
  __retres = (long)tmp;
  
#line 120 
  return __retres;
}


#line 120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const pwr_cont_miss_bcns_spread_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pwr_cont_miss_bcns_spread_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t pwr_rcvd_awake_bcns_cnt_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 122 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 122 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 122 
  wl1271_debugfs_update_stats(wl);
  
#line 122 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pwr.rcvd_awake_bcns_cnt);
  
#line 122 
  __retres = (long)tmp;
  
#line 122 
  return __retres;
}


#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const pwr_rcvd_awake_bcns_cnt_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pwr_rcvd_awake_bcns_cnt_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 125  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t ps_poll_ps_poll_timeouts_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 125 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 125 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 125 
  wl1271_debugfs_update_stats(wl);
  
#line 125 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->ps_poll.ps_poll_timeouts);
  
#line 125 
  __retres = (long)tmp;
  
#line 125 
  return __retres;
}


#line 125  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const ps_poll_ps_poll_timeouts_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & ps_poll_ps_poll_timeouts_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 126  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t ps_poll_upsd_timeouts_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 126 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 126 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 126 
  wl1271_debugfs_update_stats(wl);
  
#line 126 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->ps_poll.upsd_timeouts);
  
#line 126 
  __retres = (long)tmp;
  
#line 126 
  return __retres;
}


#line 126  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const ps_poll_upsd_timeouts_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & ps_poll_upsd_timeouts_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t ps_poll_upsd_max_ap_turn_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 127 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 127 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 127 
  wl1271_debugfs_update_stats(wl);
  
#line 127 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->ps_poll.upsd_max_ap_turn);
  
#line 127 
  __retres = (long)tmp;
  
#line 127 
  return __retres;
}


#line 127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const ps_poll_upsd_max_ap_turn_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & ps_poll_upsd_max_ap_turn_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 128  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t ps_poll_ps_poll_max_ap_turn_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 128 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 128 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 128 
  wl1271_debugfs_update_stats(wl);
  
#line 128 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->ps_poll.ps_poll_max_ap_turn);
  
#line 128 
  __retres = (long)tmp;
  
#line 128 
  return __retres;
}


#line 128  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const ps_poll_ps_poll_max_ap_turn_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & ps_poll_ps_poll_max_ap_turn_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t ps_poll_ps_poll_utilization_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 129 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 129 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 129 
  wl1271_debugfs_update_stats(wl);
  
#line 129 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->ps_poll.ps_poll_utilization);
  
#line 129 
  __retres = (long)tmp;
  
#line 129 
  return __retres;
}


#line 129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const ps_poll_ps_poll_utilization_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & ps_poll_ps_poll_utilization_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 130  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t ps_poll_upsd_utilization_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 130 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 130 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 130 
  wl1271_debugfs_update_stats(wl);
  
#line 130 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->ps_poll.upsd_utilization);
  
#line 130 
  __retres = (long)tmp;
  
#line 130 
  return __retres;
}


#line 130  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const ps_poll_upsd_utilization_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & ps_poll_upsd_utilization_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_filter_beacon_filter_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 132 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 132 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 132 
  wl1271_debugfs_update_stats(wl);
  
#line 132 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx_filter.beacon_filter);
  
#line 132 
  __retres = (long)tmp;
  
#line 132 
  return __retres;
}


#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_filter_beacon_filter_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_filter_beacon_filter_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_filter_arp_filter_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 133 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 133 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 133 
  wl1271_debugfs_update_stats(wl);
  
#line 133 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx_filter.arp_filter);
  
#line 133 
  __retres = (long)tmp;
  
#line 133 
  return __retres;
}


#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_filter_arp_filter_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_filter_arp_filter_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_filter_mc_filter_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 134 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 134 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 134 
  wl1271_debugfs_update_stats(wl);
  
#line 134 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx_filter.mc_filter);
  
#line 134 
  __retres = (long)tmp;
  
#line 134 
  return __retres;
}


#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_filter_mc_filter_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_filter_mc_filter_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 135  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_filter_dup_filter_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 135 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 135 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 135 
  wl1271_debugfs_update_stats(wl);
  
#line 135 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx_filter.dup_filter);
  
#line 135 
  __retres = (long)tmp;
  
#line 135 
  return __retres;
}


#line 135  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_filter_dup_filter_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_filter_dup_filter_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 136  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_filter_data_filter_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 136 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 136 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 136 
  wl1271_debugfs_update_stats(wl);
  
#line 136 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx_filter.data_filter);
  
#line 136 
  __retres = (long)tmp;
  
#line 136 
  return __retres;
}


#line 136  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_filter_data_filter_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_filter_data_filter_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 137  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_filter_ibss_filter_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 137 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 137 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 137 
  wl1271_debugfs_update_stats(wl);
  
#line 137 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx_filter.ibss_filter);
  
#line 137 
  __retres = (long)tmp;
  
#line 137 
  return __retres;
}


#line 137  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_filter_ibss_filter_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_filter_ibss_filter_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 138  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_filter_protection_filter_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 138 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 138 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 138 
  wl1271_debugfs_update_stats(wl);
  
#line 138 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx_filter.protection_filter);
  
#line 138 
  __retres = (long)tmp;
  
#line 138 
  return __retres;
}


#line 138  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_filter_protection_filter_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_filter_protection_filter_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 139  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_filter_accum_arp_pend_requests_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 139 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 139 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 139 
  wl1271_debugfs_update_stats(wl);
  
#line 139 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx_filter.accum_arp_pend_requests);
  
#line 139 
  __retres = (long)tmp;
  
#line 139 
  return __retres;
}


#line 139  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_filter_accum_arp_pend_requests_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_filter_accum_arp_pend_requests_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_filter_max_arp_queue_dep_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 140 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 140 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 140 
  wl1271_debugfs_update_stats(wl);
  
#line 140 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->rx_filter.max_arp_queue_dep);
  
#line 140 
  __retres = (long)tmp;
  
#line 140 
  return __retres;
}


#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_filter_max_arp_queue_dep_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_filter_max_arp_queue_dep_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t rx_rate_rx_frames_per_rates_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int res;
  int i;
  int tmp;
  
#line 142 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 142 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 142 
  char buf[256U] = {(char)'\000'};
  
#line 142 
  wl1271_debugfs_update_stats(wl);
  
#line 142 
  i = 0;
  
#line 142 
  goto ldv_54437;
  ldv_54436: 
#line 143 
  ;
  
#line 142 
  res = snprintf((char *)(& buf),256UL,"%s[%d] = %d\n",(char *)(& buf),i,stats->rx_rate.rx_frames_per_rates[i]);
  
#line 142 
  i += 1;
  ldv_54437: 
#line 143 
  ;
  
#line 142 
  if (i <= 49) 
#line 144 
               goto ldv_54436; else 
#line 147 
                                    goto ldv_54438;
  ldv_54438: 
#line 148 
  ;
  
#line 142 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%s",(char *)(& buf));
  
#line 142 
  __retres = (long)tmp;
  
#line 142 
  return __retres;
}


#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const rx_rate_rx_frames_per_rates_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & rx_rate_rx_frames_per_rates_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t aggr_size_tx_agg_vs_rate_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int res;
  int i;
  int tmp;
  
#line 144 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 144 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 144 
  char buf[256U] = {(char)'\000'};
  
#line 144 
  wl1271_debugfs_update_stats(wl);
  
#line 144 
  i = 0;
  
#line 144 
  goto ldv_54452;
  ldv_54451: 
#line 145 
  ;
  
#line 144 
  res = snprintf((char *)(& buf),256UL,"%s[%d] = %d\n",(char *)(& buf),i,stats->aggr_size.tx_agg_vs_rate[i]);
  
#line 144 
  i += 1;
  ldv_54452: 
#line 145 
  ;
  
#line 144 
  if (i <= 255) 
#line 146 
                goto ldv_54451; else 
#line 149 
                                     goto ldv_54453;
  ldv_54453: 
#line 150 
  ;
  
#line 144 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%s",(char *)(& buf));
  
#line 144 
  __retres = (long)tmp;
  
#line 144 
  return __retres;
}


#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const aggr_size_tx_agg_vs_rate_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & aggr_size_tx_agg_vs_rate_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 146  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t aggr_size_rx_size_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int res;
  int i;
  int tmp;
  
#line 146 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 146 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 146 
  char buf[256U] = {(char)'\000'};
  
#line 146 
  wl1271_debugfs_update_stats(wl);
  
#line 146 
  i = 0;
  
#line 146 
  goto ldv_54467;
  ldv_54466: 
#line 147 
  ;
  
#line 146 
  res = snprintf((char *)(& buf),256UL,"%s[%d] = %d\n",(char *)(& buf),i,stats->aggr_size.rx_size[i]);
  
#line 146 
  i += 1;
  ldv_54467: 
#line 147 
  ;
  
#line 146 
  if (i <= 15) 
#line 148 
               goto ldv_54466; else 
#line 151 
                                    goto ldv_54468;
  ldv_54468: 
#line 152 
  ;
  
#line 146 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%s",(char *)(& buf));
  
#line 146 
  __retres = (long)tmp;
  
#line 146 
  return __retres;
}


#line 146  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const aggr_size_rx_size_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & aggr_size_rx_size_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t pipeline_hs_tx_stat_fifo_int_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 149 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 149 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 149 
  wl1271_debugfs_update_stats(wl);
  
#line 149 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pipeline.hs_tx_stat_fifo_int);
  
#line 149 
  __retres = (long)tmp;
  
#line 149 
  return __retres;
}


#line 149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const pipeline_hs_tx_stat_fifo_int_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pipeline_hs_tx_stat_fifo_int_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 150  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t pipeline_tcp_tx_stat_fifo_int_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 150 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 150 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 150 
  wl1271_debugfs_update_stats(wl);
  
#line 150 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pipeline.tcp_tx_stat_fifo_int);
  
#line 150 
  __retres = (long)tmp;
  
#line 150 
  return __retres;
}


#line 150  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const pipeline_tcp_tx_stat_fifo_int_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pipeline_tcp_tx_stat_fifo_int_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 151  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t pipeline_tcp_rx_stat_fifo_int_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 151 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 151 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 151 
  wl1271_debugfs_update_stats(wl);
  
#line 151 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pipeline.tcp_rx_stat_fifo_int);
  
#line 151 
  __retres = (long)tmp;
  
#line 151 
  return __retres;
}


#line 151  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const pipeline_tcp_rx_stat_fifo_int_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pipeline_tcp_rx_stat_fifo_int_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t pipeline_enc_tx_stat_fifo_int_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 152 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 152 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 152 
  wl1271_debugfs_update_stats(wl);
  
#line 152 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pipeline.enc_tx_stat_fifo_int);
  
#line 152 
  __retres = (long)tmp;
  
#line 152 
  return __retres;
}


#line 152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const pipeline_enc_tx_stat_fifo_int_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pipeline_enc_tx_stat_fifo_int_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t pipeline_enc_rx_stat_fifo_int_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 153 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 153 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 153 
  wl1271_debugfs_update_stats(wl);
  
#line 153 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pipeline.enc_rx_stat_fifo_int);
  
#line 153 
  __retres = (long)tmp;
  
#line 153 
  return __retres;
}


#line 153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const pipeline_enc_rx_stat_fifo_int_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pipeline_enc_rx_stat_fifo_int_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 154  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t pipeline_rx_complete_stat_fifo_int_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 154 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 154 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 154 
  wl1271_debugfs_update_stats(wl);
  
#line 154 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pipeline.rx_complete_stat_fifo_int);
  
#line 154 
  __retres = (long)tmp;
  
#line 154 
  return __retres;
}


#line 154  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const pipeline_rx_complete_stat_fifo_int_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pipeline_rx_complete_stat_fifo_int_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t pipeline_pre_proc_swi_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 155 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 155 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 155 
  wl1271_debugfs_update_stats(wl);
  
#line 155 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pipeline.pre_proc_swi);
  
#line 155 
  __retres = (long)tmp;
  
#line 155 
  return __retres;
}


#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const pipeline_pre_proc_swi_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pipeline_pre_proc_swi_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t pipeline_post_proc_swi_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 156 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 156 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 156 
  wl1271_debugfs_update_stats(wl);
  
#line 156 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pipeline.post_proc_swi);
  
#line 156 
  __retres = (long)tmp;
  
#line 156 
  return __retres;
}


#line 156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const pipeline_post_proc_swi_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pipeline_post_proc_swi_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 157  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t pipeline_sec_frag_swi_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 157 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 157 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 157 
  wl1271_debugfs_update_stats(wl);
  
#line 157 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pipeline.sec_frag_swi);
  
#line 157 
  __retres = (long)tmp;
  
#line 157 
  return __retres;
}


#line 157  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const pipeline_sec_frag_swi_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pipeline_sec_frag_swi_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t pipeline_pre_to_defrag_swi_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 158 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 158 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 158 
  wl1271_debugfs_update_stats(wl);
  
#line 158 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pipeline.pre_to_defrag_swi);
  
#line 158 
  __retres = (long)tmp;
  
#line 158 
  return __retres;
}


#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const pipeline_pre_to_defrag_swi_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pipeline_pre_to_defrag_swi_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 159  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t pipeline_defrag_to_csum_swi_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 159 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 159 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 159 
  wl1271_debugfs_update_stats(wl);
  
#line 159 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pipeline.defrag_to_csum_swi);
  
#line 159 
  __retres = (long)tmp;
  
#line 159 
  return __retres;
}


#line 159  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const pipeline_defrag_to_csum_swi_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pipeline_defrag_to_csum_swi_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 160  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t pipeline_csum_to_rx_xfer_swi_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 160 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 160 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 160 
  wl1271_debugfs_update_stats(wl);
  
#line 160 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pipeline.csum_to_rx_xfer_swi);
  
#line 160 
  __retres = (long)tmp;
  
#line 160 
  return __retres;
}


#line 160  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const pipeline_csum_to_rx_xfer_swi_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pipeline_csum_to_rx_xfer_swi_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t pipeline_dec_packet_in_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 161 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 161 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 161 
  wl1271_debugfs_update_stats(wl);
  
#line 161 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pipeline.dec_packet_in);
  
#line 161 
  __retres = (long)tmp;
  
#line 161 
  return __retres;
}


#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const pipeline_dec_packet_in_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pipeline_dec_packet_in_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t pipeline_dec_packet_in_fifo_full_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 162 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 162 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 162 
  wl1271_debugfs_update_stats(wl);
  
#line 162 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pipeline.dec_packet_in_fifo_full);
  
#line 162 
  __retres = (long)tmp;
  
#line 162 
  return __retres;
}


#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const pipeline_dec_packet_in_fifo_full_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pipeline_dec_packet_in_fifo_full_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t pipeline_dec_packet_out_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 163 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 163 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 163 
  wl1271_debugfs_update_stats(wl);
  
#line 163 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pipeline.dec_packet_out);
  
#line 163 
  __retres = (long)tmp;
  
#line 163 
  return __retres;
}


#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const pipeline_dec_packet_out_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pipeline_dec_packet_out_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 164  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t pipeline_cs_rx_packet_in_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 164 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 164 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 164 
  wl1271_debugfs_update_stats(wl);
  
#line 164 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pipeline.cs_rx_packet_in);
  
#line 164 
  __retres = (long)tmp;
  
#line 164 
  return __retres;
}


#line 164  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const pipeline_cs_rx_packet_in_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pipeline_cs_rx_packet_in_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 165  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t pipeline_cs_rx_packet_out_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 165 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 165 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 165 
  wl1271_debugfs_update_stats(wl);
  
#line 165 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->pipeline.cs_rx_packet_out);
  
#line 165 
  __retres = (long)tmp;
  
#line 165 
  return __retres;
}


#line 165  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const pipeline_cs_rx_packet_out_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pipeline_cs_rx_packet_out_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 167  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t pipeline_pipeline_fifo_full_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int res;
  int i;
  int tmp;
  
#line 167 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 167 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 167 
  char buf[256U] = {(char)'\000'};
  
#line 167 
  wl1271_debugfs_update_stats(wl);
  
#line 167 
  i = 0;
  
#line 167 
  goto ldv_54635;
  ldv_54634: 
#line 168 
  ;
  
#line 167 
  res = snprintf((char *)(& buf),256UL,"%s[%d] = %d\n",(char *)(& buf),i,(int)stats->pipeline.pipeline_fifo_full[i]);
  
#line 167 
  i += 1;
  ldv_54635: 
#line 168 
  ;
  
#line 167 
  if (i <= 10) 
#line 169 
               goto ldv_54634; else 
#line 172 
                                    goto ldv_54636;
  ldv_54636: 
#line 173 
  ;
  
#line 167 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%s",(char *)(& buf));
  
#line 167 
  __retres = (long)tmp;
  
#line 167 
  return __retres;
}


#line 167  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const pipeline_pipeline_fifo_full_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & pipeline_pipeline_fifo_full_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t mem_rx_free_mem_blks_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 170 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 170 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 170 
  wl1271_debugfs_update_stats(wl);
  
#line 170 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->mem.rx_free_mem_blks);
  
#line 170 
  __retres = (long)tmp;
  
#line 170 
  return __retres;
}


#line 170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const mem_rx_free_mem_blks_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & mem_rx_free_mem_blks_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t mem_tx_free_mem_blks_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 171 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 171 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 171 
  wl1271_debugfs_update_stats(wl);
  
#line 171 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->mem.tx_free_mem_blks);
  
#line 171 
  __retres = (long)tmp;
  
#line 171 
  return __retres;
}


#line 171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const mem_tx_free_mem_blks_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & mem_tx_free_mem_blks_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t mem_fwlog_free_mem_blks_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 172 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 172 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 172 
  wl1271_debugfs_update_stats(wl);
  
#line 172 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->mem.fwlog_free_mem_blks);
  
#line 172 
  __retres = (long)tmp;
  
#line 172 
  return __retres;
}


#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const mem_fwlog_free_mem_blks_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & mem_fwlog_free_mem_blks_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 173  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t mem_fw_gen_free_mem_blks_read(struct file *file, char *userbuf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int tmp;
  
#line 173 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 173 
  struct wl18xx_acx_statistics *stats = (struct wl18xx_acx_statistics *)wl->stats.fw_stats;
  
#line 173 
  wl1271_debugfs_update_stats(wl);
  
#line 173 
  tmp = wl1271_format_buffer(userbuf,count,ppos,(char *)"%u",stats->mem.fw_gen_free_mem_blks);
  
#line 173 
  __retres = (long)tmp;
  
#line 173 
  return __retres;
}


#line 173  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const mem_fw_gen_free_mem_blks_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & mem_fw_gen_free_mem_blks_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 175  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t conf_read(struct file *file, char *user_buf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  struct wlcore_conf_header header;
  char *buf;
  char *pos;
  size_t len;
  int ret;
  ssize_t tmp_0;
  
#line 178 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 179 
  struct wl18xx_priv *priv = (struct wl18xx_priv *)wl->priv;
  
#line 185 
  len = 1226UL;
  
#line 186 
  buf = (char *)kmalloc(len,208U);
  
#line 187 
  if (buf == (char *)0) {
    
#line 188 
    __retres = -12L;
    
#line 188 
    goto return_label;
  }
  else ;
  
#line 190 
  header.magic = 283181258U;
  
#line 191 
  header.version = 393223U;
  
#line 192 
  header.checksum = 0U;
  
#line 194 
  ldv_mutex_lock_73(& wl->mutex);
  
#line 196 
  pos = buf;
  
#line 197 
  memcpy((void *)pos,(void const *)(& header),12UL);
  
#line 198 
  pos += 12U;
  
#line 199 
  memcpy((void *)pos,(void const *)(& wl->conf),921UL);
  
#line 200 
  pos += 921U;
  
#line 201 
  memcpy((void *)pos,(void const *)(& priv->conf),293UL);
  
#line 203 
  ldv_mutex_unlock_74(& wl->mutex);
  
#line 205 
  tmp_0 = simple_read_from_buffer((void *)user_buf,count,ppos,(void const *)buf,len);
  
#line 205 
  ret = (int)tmp_0;
  
#line 207 
  kfree((void const *)buf);
  
#line 208 
  __retres = (long)ret;
  return_label: 
#line 208 
                return __retres;
}


#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const conf_ops = {.owner = (struct module *)0, .llseek = & default_llseek, .read = & conf_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 217  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t clear_fw_stats_write(struct file *file, char const *user_buf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int ret;
  
#line 221 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 224 
  ldv_mutex_lock_75(& wl->mutex);
  
#line 226 
  if ((long)(wl->state != (unsigned int)WLCORE_STATE_ON) != 0L) 
#line 227 
                                                                goto out; else ;
  
#line 229 
  ret = wl18xx_acx_clear_statistics(wl);
  
#line 230 
  if (ret < 0) {
    
#line 231 
    count = (unsigned long)ret;
    
#line 232 
    goto out;
  }
  else ;
  out: 
#line 234 
  ;
  
#line 235 
  ldv_mutex_unlock_76(& wl->mutex);
  
#line 236 
  __retres = (long)count;
  
#line 236 
  return __retres;
}


#line 239  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const clear_fw_stats_ops = {.owner = (struct module *)0, .llseek = & default_llseek, .read = (ssize_t (*)(struct file *, char *, size_t , loff_t *))0, .write = & clear_fw_stats_write, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 245  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static ssize_t radar_detection_write(struct file *file, char const *user_buf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int ret;
  u8 channel;
  
#line 249 
  struct wl1271 *wl = (struct wl1271 *)file->private_data;
  
#line 253 
  ret = kstrtou8_from_user(user_buf,count,10U,& channel);
  
#line 254 
  if (ret < 0) {
    
#line 255 
    printk("\001");
    
#line 256 
    __retres = -22L;
    
#line 256 
    goto return_label;
  }
  else ;
  
#line 259 
  ldv_mutex_lock_77(& wl->mutex);
  
#line 261 
  if ((long)(wl->state != (unsigned int)WLCORE_STATE_ON) != 0L) 
#line 262 
                                                                goto out; else ;
  
#line 264 
  ret = wl1271_ps_elp_wakeup(wl);
  
#line 265 
  if (ret < 0) 
#line 266 
               goto out; else ;
  
#line 268 
  ret = wl18xx_cmd_radar_detection_debug(wl,(unsigned char)((int)channel));
  
#line 269 
  if (ret < 0) 
#line 270 
               count = (unsigned long)ret; else ;
  
#line 272 
  wl1271_ps_elp_sleep(wl);
  out: 
#line 273 
  ;
  
#line 274 
  ldv_mutex_unlock_78(& wl->mutex);
  
#line 275 
  __retres = (long)count;
  return_label: 
#line 275 
                return __retres;
}


#line 278  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
static struct file_operations const radar_detection_ops = {.owner = (struct module *)0, .llseek = & default_llseek, .read = (ssize_t (*)(struct file *, char *, size_t , loff_t *))0, .write = & radar_detection_write, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 284  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/ti/wl18xx/debugfs.c"
int wl18xx_debugfs_add_files(struct wl1271 *wl, struct dentry *rootdir)
{
  int __retres;
  struct dentry *entry;
  struct dentry *stats;
  struct dentry *moddir;
  bool tmp_123;
  
#line 287 
  int ret = 0;
  
#line 290 
  moddir = debugfs_create_dir("wl18xx",rootdir);
  
#line 291 
  if (moddir == (struct dentry *)0) 
#line 291 
                                    goto _LOR;
  else {
    bool tmp;
    
#line 291 
    tmp = IS_ERR_0((void const *)moddir);
    
#line 291 
    if ((int)tmp != 0) {
      _LOR: {
              
#line 292 
              entry = moddir;
              
#line 293 
              goto err;
            }
    }
    else ;
  }
  
#line 296 
  stats = debugfs_create_dir("fw_stats",moddir);
  
#line 297 
  if (stats == (struct dentry *)0) 
#line 297 
                                   goto _LOR_0;
  else {
    bool tmp_0;
    
#line 297 
    tmp_0 = IS_ERR_0((void const *)stats);
    
#line 297 
    if ((int)tmp_0 != 0) {
      _LOR_0: {
                
#line 298 
                entry = stats;
                
#line 299 
                goto err;
              }
    }
    else ;
  }
  
#line 302 
  entry = ldv_debugfs_create_file_79("clear_fw_stats",(unsigned short)256,stats,(void *)wl,& clear_fw_stats_ops);
  
#line 302 
  if (entry == (struct dentry *)0) 
#line 302 
                                   goto err;
  else {
    bool tmp_1;
    
#line 302 
    tmp_1 = IS_ERR_0((void const *)entry);
    
#line 302 
    if ((int)tmp_1 != 0) 
#line 302 
                         goto err; else ;
  }
  
#line 304 
  entry = ldv_debugfs_create_file_80("debug_debug1",(unsigned short)256,stats,(void *)wl,& debug_debug1_ops);
  
#line 304 
  if (entry == (struct dentry *)0) 
#line 304 
                                   goto err;
  else {
    bool tmp_2;
    
#line 304 
    tmp_2 = IS_ERR_0((void const *)entry);
    
#line 304 
    if ((int)tmp_2 != 0) 
#line 304 
                         goto err; else ;
  }
  
#line 305 
  entry = ldv_debugfs_create_file_81("debug_debug2",(unsigned short)256,stats,(void *)wl,& debug_debug2_ops);
  
#line 305 
  if (entry == (struct dentry *)0) 
#line 305 
                                   goto err;
  else {
    bool tmp_3;
    
#line 305 
    tmp_3 = IS_ERR_0((void const *)entry);
    
#line 305 
    if ((int)tmp_3 != 0) 
#line 305 
                         goto err; else ;
  }
  
#line 306 
  entry = ldv_debugfs_create_file_82("debug_debug3",(unsigned short)256,stats,(void *)wl,& debug_debug3_ops);
  
#line 306 
  if (entry == (struct dentry *)0) 
#line 306 
                                   goto err;
  else {
    bool tmp_4;
    
#line 306 
    tmp_4 = IS_ERR_0((void const *)entry);
    
#line 306 
    if ((int)tmp_4 != 0) 
#line 306 
                         goto err; else ;
  }
  
#line 307 
  entry = ldv_debugfs_create_file_83("debug_debug4",(unsigned short)256,stats,(void *)wl,& debug_debug4_ops);
  
#line 307 
  if (entry == (struct dentry *)0) 
#line 307 
                                   goto err;
  else {
    bool tmp_5;
    
#line 307 
    tmp_5 = IS_ERR_0((void const *)entry);
    
#line 307 
    if ((int)tmp_5 != 0) 
#line 307 
                         goto err; else ;
  }
  
#line 308 
  entry = ldv_debugfs_create_file_84("debug_debug5",(unsigned short)256,stats,(void *)wl,& debug_debug5_ops);
  
#line 308 
  if (entry == (struct dentry *)0) 
#line 308 
                                   goto err;
  else {
    bool tmp_6;
    
#line 308 
    tmp_6 = IS_ERR_0((void const *)entry);
    
#line 308 
    if ((int)tmp_6 != 0) 
#line 308 
                         goto err; else ;
  }
  
#line 309 
  entry = ldv_debugfs_create_file_85("debug_debug6",(unsigned short)256,stats,(void *)wl,& debug_debug6_ops);
  
#line 309 
  if (entry == (struct dentry *)0) 
#line 309 
                                   goto err;
  else {
    bool tmp_7;
    
#line 309 
    tmp_7 = IS_ERR_0((void const *)entry);
    
#line 309 
    if ((int)tmp_7 != 0) 
#line 309 
                         goto err; else ;
  }
  
#line 311 
  entry = ldv_debugfs_create_file_86("error_error_frame",(unsigned short)256,stats,(void *)wl,& error_error_frame_ops);
  
#line 311 
  if (entry == (struct dentry *)0) 
#line 311 
                                   goto err;
  else {
    bool tmp_8;
    
#line 311 
    tmp_8 = IS_ERR_0((void const *)entry);
    
#line 311 
    if ((int)tmp_8 != 0) 
#line 311 
                         goto err; else ;
  }
  
#line 312 
  entry = ldv_debugfs_create_file_87("error_error_null_Frame_tx_start",(unsigned short)256,stats,(void *)wl,& error_error_null_Frame_tx_start_ops);
  
#line 312 
  if (entry == (struct dentry *)0) 
#line 312 
                                   goto err;
  else {
    bool tmp_9;
    
#line 312 
    tmp_9 = IS_ERR_0((void const *)entry);
    
#line 312 
    if ((int)tmp_9 != 0) 
#line 312 
                         goto err; else ;
  }
  
#line 313 
  entry = ldv_debugfs_create_file_88("error_error_numll_frame_cts_start",(unsigned short)256,stats,(void *)wl,& error_error_numll_frame_cts_start_ops);
  
#line 313 
  if (entry == (struct dentry *)0) 
#line 313 
                                   goto err;
  else {
    bool tmp_10;
    
#line 313 
    tmp_10 = IS_ERR_0((void const *)entry);
    
#line 313 
    if ((int)tmp_10 != 0) 
#line 313 
                          goto err; else ;
  }
  
#line 314 
  entry = ldv_debugfs_create_file_89("error_error_bar_retry",(unsigned short)256,stats,(void *)wl,& error_error_bar_retry_ops);
  
#line 314 
  if (entry == (struct dentry *)0) 
#line 314 
                                   goto err;
  else {
    bool tmp_11;
    
#line 314 
    tmp_11 = IS_ERR_0((void const *)entry);
    
#line 314 
    if ((int)tmp_11 != 0) 
#line 314 
                          goto err; else ;
  }
  
#line 315 
  entry = ldv_debugfs_create_file_90("error_error_frame_cts_nul_flid",(unsigned short)256,stats,(void *)wl,& error_error_frame_cts_nul_flid_ops);
  
#line 315 
  if (entry == (struct dentry *)0) 
#line 315 
                                   goto err;
  else {
    bool tmp_12;
    
#line 315 
    tmp_12 = IS_ERR_0((void const *)entry);
    
#line 315 
    if ((int)tmp_12 != 0) 
#line 315 
                          goto err; else ;
  }
  
#line 317 
  entry = ldv_debugfs_create_file_91("tx_tx_prepared_descs",(unsigned short)256,stats,(void *)wl,& tx_tx_prepared_descs_ops);
  
#line 317 
  if (entry == (struct dentry *)0) 
#line 317 
                                   goto err;
  else {
    bool tmp_13;
    
#line 317 
    tmp_13 = IS_ERR_0((void const *)entry);
    
#line 317 
    if ((int)tmp_13 != 0) 
#line 317 
                          goto err; else ;
  }
  
#line 318 
  entry = ldv_debugfs_create_file_92("tx_tx_cmplt",(unsigned short)256,stats,(void *)wl,& tx_tx_cmplt_ops);
  
#line 318 
  if (entry == (struct dentry *)0) 
#line 318 
                                   goto err;
  else {
    bool tmp_14;
    
#line 318 
    tmp_14 = IS_ERR_0((void const *)entry);
    
#line 318 
    if ((int)tmp_14 != 0) 
#line 318 
                          goto err; else ;
  }
  
#line 319 
  entry = ldv_debugfs_create_file_93("tx_tx_template_prepared",(unsigned short)256,stats,(void *)wl,& tx_tx_template_prepared_ops);
  
#line 319 
  if (entry == (struct dentry *)0) 
#line 319 
                                   goto err;
  else {
    bool tmp_15;
    
#line 319 
    tmp_15 = IS_ERR_0((void const *)entry);
    
#line 319 
    if ((int)tmp_15 != 0) 
#line 319 
                          goto err; else ;
  }
  
#line 320 
  entry = ldv_debugfs_create_file_94("tx_tx_data_prepared",(unsigned short)256,stats,(void *)wl,& tx_tx_data_prepared_ops);
  
#line 320 
  if (entry == (struct dentry *)0) 
#line 320 
                                   goto err;
  else {
    bool tmp_16;
    
#line 320 
    tmp_16 = IS_ERR_0((void const *)entry);
    
#line 320 
    if ((int)tmp_16 != 0) 
#line 320 
                          goto err; else ;
  }
  
#line 321 
  entry = ldv_debugfs_create_file_95("tx_tx_template_programmed",(unsigned short)256,stats,(void *)wl,& tx_tx_template_programmed_ops);
  
#line 321 
  if (entry == (struct dentry *)0) 
#line 321 
                                   goto err;
  else {
    bool tmp_17;
    
#line 321 
    tmp_17 = IS_ERR_0((void const *)entry);
    
#line 321 
    if ((int)tmp_17 != 0) 
#line 321 
                          goto err; else ;
  }
  
#line 322 
  entry = ldv_debugfs_create_file_96("tx_tx_data_programmed",(unsigned short)256,stats,(void *)wl,& tx_tx_data_programmed_ops);
  
#line 322 
  if (entry == (struct dentry *)0) 
#line 322 
                                   goto err;
  else {
    bool tmp_18;
    
#line 322 
    tmp_18 = IS_ERR_0((void const *)entry);
    
#line 322 
    if ((int)tmp_18 != 0) 
#line 322 
                          goto err; else ;
  }
  
#line 323 
  entry = ldv_debugfs_create_file_97("tx_tx_burst_programmed",(unsigned short)256,stats,(void *)wl,& tx_tx_burst_programmed_ops);
  
#line 323 
  if (entry == (struct dentry *)0) 
#line 323 
                                   goto err;
  else {
    bool tmp_19;
    
#line 323 
    tmp_19 = IS_ERR_0((void const *)entry);
    
#line 323 
    if ((int)tmp_19 != 0) 
#line 323 
                          goto err; else ;
  }
  
#line 324 
  entry = ldv_debugfs_create_file_98("tx_tx_starts",(unsigned short)256,stats,(void *)wl,& tx_tx_starts_ops);
  
#line 324 
  if (entry == (struct dentry *)0) 
#line 324 
                                   goto err;
  else {
    bool tmp_20;
    
#line 324 
    tmp_20 = IS_ERR_0((void const *)entry);
    
#line 324 
    if ((int)tmp_20 != 0) 
#line 324 
                          goto err; else ;
  }
  
#line 325 
  entry = ldv_debugfs_create_file_99("tx_tx_imm_resp",(unsigned short)256,stats,(void *)wl,& tx_tx_imm_resp_ops);
  
#line 325 
  if (entry == (struct dentry *)0) 
#line 325 
                                   goto err;
  else {
    bool tmp_21;
    
#line 325 
    tmp_21 = IS_ERR_0((void const *)entry);
    
#line 325 
    if ((int)tmp_21 != 0) 
#line 325 
                          goto err; else ;
  }
  
#line 326 
  entry = ldv_debugfs_create_file_100("tx_tx_start_templates",(unsigned short)256,stats,(void *)wl,& tx_tx_start_templates_ops);
  
#line 326 
  if (entry == (struct dentry *)0) 
#line 326 
                                   goto err;
  else {
    bool tmp_22;
    
#line 326 
    tmp_22 = IS_ERR_0((void const *)entry);
    
#line 326 
    if ((int)tmp_22 != 0) 
#line 326 
                          goto err; else ;
  }
  
#line 327 
  entry = ldv_debugfs_create_file_101("tx_tx_start_int_templates",(unsigned short)256,stats,(void *)wl,& tx_tx_start_int_templates_ops);
  
#line 327 
  if (entry == (struct dentry *)0) 
#line 327 
                                   goto err;
  else {
    bool tmp_23;
    
#line 327 
    tmp_23 = IS_ERR_0((void const *)entry);
    
#line 327 
    if ((int)tmp_23 != 0) 
#line 327 
                          goto err; else ;
  }
  
#line 328 
  entry = ldv_debugfs_create_file_102("tx_tx_start_fw_gen",(unsigned short)256,stats,(void *)wl,& tx_tx_start_fw_gen_ops);
  
#line 328 
  if (entry == (struct dentry *)0) 
#line 328 
                                   goto err;
  else {
    bool tmp_24;
    
#line 328 
    tmp_24 = IS_ERR_0((void const *)entry);
    
#line 328 
    if ((int)tmp_24 != 0) 
#line 328 
                          goto err; else ;
  }
  
#line 329 
  entry = ldv_debugfs_create_file_103("tx_tx_start_data",(unsigned short)256,stats,(void *)wl,& tx_tx_start_data_ops);
  
#line 329 
  if (entry == (struct dentry *)0) 
#line 329 
                                   goto err;
  else {
    bool tmp_25;
    
#line 329 
    tmp_25 = IS_ERR_0((void const *)entry);
    
#line 329 
    if ((int)tmp_25 != 0) 
#line 329 
                          goto err; else ;
  }
  
#line 330 
  entry = ldv_debugfs_create_file_104("tx_tx_start_null_frame",(unsigned short)256,stats,(void *)wl,& tx_tx_start_null_frame_ops);
  
#line 330 
  if (entry == (struct dentry *)0) 
#line 330 
                                   goto err;
  else {
    bool tmp_26;
    
#line 330 
    tmp_26 = IS_ERR_0((void const *)entry);
    
#line 330 
    if ((int)tmp_26 != 0) 
#line 330 
                          goto err; else ;
  }
  
#line 331 
  entry = ldv_debugfs_create_file_105("tx_tx_exch",(unsigned short)256,stats,(void *)wl,& tx_tx_exch_ops);
  
#line 331 
  if (entry == (struct dentry *)0) 
#line 331 
                                   goto err;
  else {
    bool tmp_27;
    
#line 331 
    tmp_27 = IS_ERR_0((void const *)entry);
    
#line 331 
    if ((int)tmp_27 != 0) 
#line 331 
                          goto err; else ;
  }
  
#line 332 
  entry = ldv_debugfs_create_file_106("tx_tx_retry_template",(unsigned short)256,stats,(void *)wl,& tx_tx_retry_template_ops);
  
#line 332 
  if (entry == (struct dentry *)0) 
#line 332 
                                   goto err;
  else {
    bool tmp_28;
    
#line 332 
    tmp_28 = IS_ERR_0((void const *)entry);
    
#line 332 
    if ((int)tmp_28 != 0) 
#line 332 
                          goto err; else ;
  }
  
#line 333 
  entry = ldv_debugfs_create_file_107("tx_tx_retry_data",(unsigned short)256,stats,(void *)wl,& tx_tx_retry_data_ops);
  
#line 333 
  if (entry == (struct dentry *)0) 
#line 333 
                                   goto err;
  else {
    bool tmp_29;
    
#line 333 
    tmp_29 = IS_ERR_0((void const *)entry);
    
#line 333 
    if ((int)tmp_29 != 0) 
#line 333 
                          goto err; else ;
  }
  
#line 334 
  entry = ldv_debugfs_create_file_108("tx_tx_exch_pending",(unsigned short)256,stats,(void *)wl,& tx_tx_exch_pending_ops);
  
#line 334 
  if (entry == (struct dentry *)0) 
#line 334 
                                   goto err;
  else {
    bool tmp_30;
    
#line 334 
    tmp_30 = IS_ERR_0((void const *)entry);
    
#line 334 
    if ((int)tmp_30 != 0) 
#line 334 
                          goto err; else ;
  }
  
#line 335 
  entry = ldv_debugfs_create_file_109("tx_tx_exch_expiry",(unsigned short)256,stats,(void *)wl,& tx_tx_exch_expiry_ops);
  
#line 335 
  if (entry == (struct dentry *)0) 
#line 335 
                                   goto err;
  else {
    bool tmp_31;
    
#line 335 
    tmp_31 = IS_ERR_0((void const *)entry);
    
#line 335 
    if ((int)tmp_31 != 0) 
#line 335 
                          goto err; else ;
  }
  
#line 336 
  entry = ldv_debugfs_create_file_110("tx_tx_done_template",(unsigned short)256,stats,(void *)wl,& tx_tx_done_template_ops);
  
#line 336 
  if (entry == (struct dentry *)0) 
#line 336 
                                   goto err;
  else {
    bool tmp_32;
    
#line 336 
    tmp_32 = IS_ERR_0((void const *)entry);
    
#line 336 
    if ((int)tmp_32 != 0) 
#line 336 
                          goto err; else ;
  }
  
#line 337 
  entry = ldv_debugfs_create_file_111("tx_tx_done_data",(unsigned short)256,stats,(void *)wl,& tx_tx_done_data_ops);
  
#line 337 
  if (entry == (struct dentry *)0) 
#line 337 
                                   goto err;
  else {
    bool tmp_33;
    
#line 337 
    tmp_33 = IS_ERR_0((void const *)entry);
    
#line 337 
    if ((int)tmp_33 != 0) 
#line 337 
                          goto err; else ;
  }
  
#line 338 
  entry = ldv_debugfs_create_file_112("tx_tx_done_int_template",(unsigned short)256,stats,(void *)wl,& tx_tx_done_int_template_ops);
  
#line 338 
  if (entry == (struct dentry *)0) 
#line 338 
                                   goto err;
  else {
    bool tmp_34;
    
#line 338 
    tmp_34 = IS_ERR_0((void const *)entry);
    
#line 338 
    if ((int)tmp_34 != 0) 
#line 338 
                          goto err; else ;
  }
  
#line 339 
  entry = ldv_debugfs_create_file_113("tx_tx_frame_checksum",(unsigned short)256,stats,(void *)wl,& tx_tx_frame_checksum_ops);
  
#line 339 
  if (entry == (struct dentry *)0) 
#line 339 
                                   goto err;
  else {
    bool tmp_35;
    
#line 339 
    tmp_35 = IS_ERR_0((void const *)entry);
    
#line 339 
    if ((int)tmp_35 != 0) 
#line 339 
                          goto err; else ;
  }
  
#line 340 
  entry = ldv_debugfs_create_file_114("tx_tx_checksum_result",(unsigned short)256,stats,(void *)wl,& tx_tx_checksum_result_ops);
  
#line 340 
  if (entry == (struct dentry *)0) 
#line 340 
                                   goto err;
  else {
    bool tmp_36;
    
#line 340 
    tmp_36 = IS_ERR_0((void const *)entry);
    
#line 340 
    if ((int)tmp_36 != 0) 
#line 340 
                          goto err; else ;
  }
  
#line 341 
  entry = ldv_debugfs_create_file_115("tx_frag_called",(unsigned short)256,stats,(void *)wl,& tx_frag_called_ops);
  
#line 341 
  if (entry == (struct dentry *)0) 
#line 341 
                                   goto err;
  else {
    bool tmp_37;
    
#line 341 
    tmp_37 = IS_ERR_0((void const *)entry);
    
#line 341 
    if ((int)tmp_37 != 0) 
#line 341 
                          goto err; else ;
  }
  
#line 342 
  entry = ldv_debugfs_create_file_116("tx_frag_mpdu_alloc_failed",(unsigned short)256,stats,(void *)wl,& tx_frag_mpdu_alloc_failed_ops);
  
#line 342 
  if (entry == (struct dentry *)0) 
#line 342 
                                   goto err;
  else {
    bool tmp_38;
    
#line 342 
    tmp_38 = IS_ERR_0((void const *)entry);
    
#line 342 
    if ((int)tmp_38 != 0) 
#line 342 
                          goto err; else ;
  }
  
#line 343 
  entry = ldv_debugfs_create_file_117("tx_frag_init_called",(unsigned short)256,stats,(void *)wl,& tx_frag_init_called_ops);
  
#line 343 
  if (entry == (struct dentry *)0) 
#line 343 
                                   goto err;
  else {
    bool tmp_39;
    
#line 343 
    tmp_39 = IS_ERR_0((void const *)entry);
    
#line 343 
    if ((int)tmp_39 != 0) 
#line 343 
                          goto err; else ;
  }
  
#line 344 
  entry = ldv_debugfs_create_file_118("tx_frag_in_process_called",(unsigned short)256,stats,(void *)wl,& tx_frag_in_process_called_ops);
  
#line 344 
  if (entry == (struct dentry *)0) 
#line 344 
                                   goto err;
  else {
    bool tmp_40;
    
#line 344 
    tmp_40 = IS_ERR_0((void const *)entry);
    
#line 344 
    if ((int)tmp_40 != 0) 
#line 344 
                          goto err; else ;
  }
  
#line 345 
  entry = ldv_debugfs_create_file_119("tx_frag_tkip_called",(unsigned short)256,stats,(void *)wl,& tx_frag_tkip_called_ops);
  
#line 345 
  if (entry == (struct dentry *)0) 
#line 345 
                                   goto err;
  else {
    bool tmp_41;
    
#line 345 
    tmp_41 = IS_ERR_0((void const *)entry);
    
#line 345 
    if ((int)tmp_41 != 0) 
#line 345 
                          goto err; else ;
  }
  
#line 346 
  entry = ldv_debugfs_create_file_120("tx_frag_key_not_found",(unsigned short)256,stats,(void *)wl,& tx_frag_key_not_found_ops);
  
#line 346 
  if (entry == (struct dentry *)0) 
#line 346 
                                   goto err;
  else {
    bool tmp_42;
    
#line 346 
    tmp_42 = IS_ERR_0((void const *)entry);
    
#line 346 
    if ((int)tmp_42 != 0) 
#line 346 
                          goto err; else ;
  }
  
#line 347 
  entry = ldv_debugfs_create_file_121("tx_frag_need_fragmentation",(unsigned short)256,stats,(void *)wl,& tx_frag_need_fragmentation_ops);
  
#line 347 
  if (entry == (struct dentry *)0) 
#line 347 
                                   goto err;
  else {
    bool tmp_43;
    
#line 347 
    tmp_43 = IS_ERR_0((void const *)entry);
    
#line 347 
    if ((int)tmp_43 != 0) 
#line 347 
                          goto err; else ;
  }
  
#line 348 
  entry = ldv_debugfs_create_file_122("tx_frag_bad_mblk_num",(unsigned short)256,stats,(void *)wl,& tx_frag_bad_mblk_num_ops);
  
#line 348 
  if (entry == (struct dentry *)0) 
#line 348 
                                   goto err;
  else {
    bool tmp_44;
    
#line 348 
    tmp_44 = IS_ERR_0((void const *)entry);
    
#line 348 
    if ((int)tmp_44 != 0) 
#line 348 
                          goto err; else ;
  }
  
#line 349 
  entry = ldv_debugfs_create_file_123("tx_frag_failed",(unsigned short)256,stats,(void *)wl,& tx_frag_failed_ops);
  
#line 349 
  if (entry == (struct dentry *)0) 
#line 349 
                                   goto err;
  else {
    bool tmp_45;
    
#line 349 
    tmp_45 = IS_ERR_0((void const *)entry);
    
#line 349 
    if ((int)tmp_45 != 0) 
#line 349 
                          goto err; else ;
  }
  
#line 350 
  entry = ldv_debugfs_create_file_124("tx_frag_cache_hit",(unsigned short)256,stats,(void *)wl,& tx_frag_cache_hit_ops);
  
#line 350 
  if (entry == (struct dentry *)0) 
#line 350 
                                   goto err;
  else {
    bool tmp_46;
    
#line 350 
    tmp_46 = IS_ERR_0((void const *)entry);
    
#line 350 
    if ((int)tmp_46 != 0) 
#line 350 
                          goto err; else ;
  }
  
#line 351 
  entry = ldv_debugfs_create_file_125("tx_frag_cache_miss",(unsigned short)256,stats,(void *)wl,& tx_frag_cache_miss_ops);
  
#line 351 
  if (entry == (struct dentry *)0) 
#line 351 
                                   goto err;
  else {
    bool tmp_47;
    
#line 351 
    tmp_47 = IS_ERR_0((void const *)entry);
    
#line 351 
    if ((int)tmp_47 != 0) 
#line 351 
                          goto err; else ;
  }
  
#line 353 
  entry = ldv_debugfs_create_file_126("rx_rx_beacon_early_term",(unsigned short)256,stats,(void *)wl,& rx_rx_beacon_early_term_ops);
  
#line 353 
  if (entry == (struct dentry *)0) 
#line 353 
                                   goto err;
  else {
    bool tmp_48;
    
#line 353 
    tmp_48 = IS_ERR_0((void const *)entry);
    
#line 353 
    if ((int)tmp_48 != 0) 
#line 353 
                          goto err; else ;
  }
  
#line 354 
  entry = ldv_debugfs_create_file_127("rx_rx_out_of_mpdu_nodes",(unsigned short)256,stats,(void *)wl,& rx_rx_out_of_mpdu_nodes_ops);
  
#line 354 
  if (entry == (struct dentry *)0) 
#line 354 
                                   goto err;
  else {
    bool tmp_49;
    
#line 354 
    tmp_49 = IS_ERR_0((void const *)entry);
    
#line 354 
    if ((int)tmp_49 != 0) 
#line 354 
                          goto err; else ;
  }
  
#line 355 
  entry = ldv_debugfs_create_file_128("rx_rx_hdr_overflow",(unsigned short)256,stats,(void *)wl,& rx_rx_hdr_overflow_ops);
  
#line 355 
  if (entry == (struct dentry *)0) 
#line 355 
                                   goto err;
  else {
    bool tmp_50;
    
#line 355 
    tmp_50 = IS_ERR_0((void const *)entry);
    
#line 355 
    if ((int)tmp_50 != 0) 
#line 355 
                          goto err; else ;
  }
  
#line 356 
  entry = ldv_debugfs_create_file_129("rx_rx_dropped_frame",(unsigned short)256,stats,(void *)wl,& rx_rx_dropped_frame_ops);
  
#line 356 
  if (entry == (struct dentry *)0) 
#line 356 
                                   goto err;
  else {
    bool tmp_51;
    
#line 356 
    tmp_51 = IS_ERR_0((void const *)entry);
    
#line 356 
    if ((int)tmp_51 != 0) 
#line 356 
                          goto err; else ;
  }
  
#line 357 
  entry = ldv_debugfs_create_file_130("rx_rx_done",(unsigned short)256,stats,(void *)wl,& rx_rx_done_ops);
  
#line 357 
  if (entry == (struct dentry *)0) 
#line 357 
                                   goto err;
  else {
    bool tmp_52;
    
#line 357 
    tmp_52 = IS_ERR_0((void const *)entry);
    
#line 357 
    if ((int)tmp_52 != 0) 
#line 357 
                          goto err; else ;
  }
  
#line 358 
  entry = ldv_debugfs_create_file_131("rx_rx_defrag",(unsigned short)256,stats,(void *)wl,& rx_rx_defrag_ops);
  
#line 358 
  if (entry == (struct dentry *)0) 
#line 358 
                                   goto err;
  else {
    bool tmp_53;
    
#line 358 
    tmp_53 = IS_ERR_0((void const *)entry);
    
#line 358 
    if ((int)tmp_53 != 0) 
#line 358 
                          goto err; else ;
  }
  
#line 359 
  entry = ldv_debugfs_create_file_132("rx_rx_defrag_end",(unsigned short)256,stats,(void *)wl,& rx_rx_defrag_end_ops);
  
#line 359 
  if (entry == (struct dentry *)0) 
#line 359 
                                   goto err;
  else {
    bool tmp_54;
    
#line 359 
    tmp_54 = IS_ERR_0((void const *)entry);
    
#line 359 
    if ((int)tmp_54 != 0) 
#line 359 
                          goto err; else ;
  }
  
#line 360 
  entry = ldv_debugfs_create_file_133("rx_rx_cmplt",(unsigned short)256,stats,(void *)wl,& rx_rx_cmplt_ops);
  
#line 360 
  if (entry == (struct dentry *)0) 
#line 360 
                                   goto err;
  else {
    bool tmp_55;
    
#line 360 
    tmp_55 = IS_ERR_0((void const *)entry);
    
#line 360 
    if ((int)tmp_55 != 0) 
#line 360 
                          goto err; else ;
  }
  
#line 361 
  entry = ldv_debugfs_create_file_134("rx_rx_pre_complt",(unsigned short)256,stats,(void *)wl,& rx_rx_pre_complt_ops);
  
#line 361 
  if (entry == (struct dentry *)0) 
#line 361 
                                   goto err;
  else {
    bool tmp_56;
    
#line 361 
    tmp_56 = IS_ERR_0((void const *)entry);
    
#line 361 
    if ((int)tmp_56 != 0) 
#line 361 
                          goto err; else ;
  }
  
#line 362 
  entry = ldv_debugfs_create_file_135("rx_rx_cmplt_task",(unsigned short)256,stats,(void *)wl,& rx_rx_cmplt_task_ops);
  
#line 362 
  if (entry == (struct dentry *)0) 
#line 362 
                                   goto err;
  else {
    bool tmp_57;
    
#line 362 
    tmp_57 = IS_ERR_0((void const *)entry);
    
#line 362 
    if ((int)tmp_57 != 0) 
#line 362 
                          goto err; else ;
  }
  
#line 363 
  entry = ldv_debugfs_create_file_136("rx_rx_phy_hdr",(unsigned short)256,stats,(void *)wl,& rx_rx_phy_hdr_ops);
  
#line 363 
  if (entry == (struct dentry *)0) 
#line 363 
                                   goto err;
  else {
    bool tmp_58;
    
#line 363 
    tmp_58 = IS_ERR_0((void const *)entry);
    
#line 363 
    if ((int)tmp_58 != 0) 
#line 363 
                          goto err; else ;
  }
  
#line 364 
  entry = ldv_debugfs_create_file_137("rx_rx_timeout",(unsigned short)256,stats,(void *)wl,& rx_rx_timeout_ops);
  
#line 364 
  if (entry == (struct dentry *)0) 
#line 364 
                                   goto err;
  else {
    bool tmp_59;
    
#line 364 
    tmp_59 = IS_ERR_0((void const *)entry);
    
#line 364 
    if ((int)tmp_59 != 0) 
#line 364 
                          goto err; else ;
  }
  
#line 365 
  entry = ldv_debugfs_create_file_138("rx_rx_timeout_wa",(unsigned short)256,stats,(void *)wl,& rx_rx_timeout_wa_ops);
  
#line 365 
  if (entry == (struct dentry *)0) 
#line 365 
                                   goto err;
  else {
    bool tmp_60;
    
#line 365 
    tmp_60 = IS_ERR_0((void const *)entry);
    
#line 365 
    if ((int)tmp_60 != 0) 
#line 365 
                          goto err; else ;
  }
  
#line 366 
  entry = ldv_debugfs_create_file_139("rx_rx_wa_density_dropped_frame",(unsigned short)256,stats,(void *)wl,& rx_rx_wa_density_dropped_frame_ops);
  
#line 366 
  if (entry == (struct dentry *)0) 
#line 366 
                                   goto err;
  else {
    bool tmp_61;
    
#line 366 
    tmp_61 = IS_ERR_0((void const *)entry);
    
#line 366 
    if ((int)tmp_61 != 0) 
#line 366 
                          goto err; else ;
  }
  
#line 367 
  entry = ldv_debugfs_create_file_140("rx_rx_wa_ba_not_expected",(unsigned short)256,stats,(void *)wl,& rx_rx_wa_ba_not_expected_ops);
  
#line 367 
  if (entry == (struct dentry *)0) 
#line 367 
                                   goto err;
  else {
    bool tmp_62;
    
#line 367 
    tmp_62 = IS_ERR_0((void const *)entry);
    
#line 367 
    if ((int)tmp_62 != 0) 
#line 367 
                          goto err; else ;
  }
  
#line 368 
  entry = ldv_debugfs_create_file_141("rx_rx_frame_checksum",(unsigned short)256,stats,(void *)wl,& rx_rx_frame_checksum_ops);
  
#line 368 
  if (entry == (struct dentry *)0) 
#line 368 
                                   goto err;
  else {
    bool tmp_63;
    
#line 368 
    tmp_63 = IS_ERR_0((void const *)entry);
    
#line 368 
    if ((int)tmp_63 != 0) 
#line 368 
                          goto err; else ;
  }
  
#line 369 
  entry = ldv_debugfs_create_file_142("rx_rx_checksum_result",(unsigned short)256,stats,(void *)wl,& rx_rx_checksum_result_ops);
  
#line 369 
  if (entry == (struct dentry *)0) 
#line 369 
                                   goto err;
  else {
    bool tmp_64;
    
#line 369 
    tmp_64 = IS_ERR_0((void const *)entry);
    
#line 369 
    if ((int)tmp_64 != 0) 
#line 369 
                          goto err; else ;
  }
  
#line 370 
  entry = ldv_debugfs_create_file_143("rx_defrag_called",(unsigned short)256,stats,(void *)wl,& rx_defrag_called_ops);
  
#line 370 
  if (entry == (struct dentry *)0) 
#line 370 
                                   goto err;
  else {
    bool tmp_65;
    
#line 370 
    tmp_65 = IS_ERR_0((void const *)entry);
    
#line 370 
    if ((int)tmp_65 != 0) 
#line 370 
                          goto err; else ;
  }
  
#line 371 
  entry = ldv_debugfs_create_file_144("rx_defrag_init_called",(unsigned short)256,stats,(void *)wl,& rx_defrag_init_called_ops);
  
#line 371 
  if (entry == (struct dentry *)0) 
#line 371 
                                   goto err;
  else {
    bool tmp_66;
    
#line 371 
    tmp_66 = IS_ERR_0((void const *)entry);
    
#line 371 
    if ((int)tmp_66 != 0) 
#line 371 
                          goto err; else ;
  }
  
#line 372 
  entry = ldv_debugfs_create_file_145("rx_defrag_in_process_called",(unsigned short)256,stats,(void *)wl,& rx_defrag_in_process_called_ops);
  
#line 372 
  if (entry == (struct dentry *)0) 
#line 372 
                                   goto err;
  else {
    bool tmp_67;
    
#line 372 
    tmp_67 = IS_ERR_0((void const *)entry);
    
#line 372 
    if ((int)tmp_67 != 0) 
#line 372 
                          goto err; else ;
  }
  
#line 373 
  entry = ldv_debugfs_create_file_146("rx_defrag_tkip_called",(unsigned short)256,stats,(void *)wl,& rx_defrag_tkip_called_ops);
  
#line 373 
  if (entry == (struct dentry *)0) 
#line 373 
                                   goto err;
  else {
    bool tmp_68;
    
#line 373 
    tmp_68 = IS_ERR_0((void const *)entry);
    
#line 373 
    if ((int)tmp_68 != 0) 
#line 373 
                          goto err; else ;
  }
  
#line 374 
  entry = ldv_debugfs_create_file_147("rx_defrag_need_defrag",(unsigned short)256,stats,(void *)wl,& rx_defrag_need_defrag_ops);
  
#line 374 
  if (entry == (struct dentry *)0) 
#line 374 
                                   goto err;
  else {
    bool tmp_69;
    
#line 374 
    tmp_69 = IS_ERR_0((void const *)entry);
    
#line 374 
    if ((int)tmp_69 != 0) 
#line 374 
                          goto err; else ;
  }
  
#line 375 
  entry = ldv_debugfs_create_file_148("rx_defrag_decrypt_failed",(unsigned short)256,stats,(void *)wl,& rx_defrag_decrypt_failed_ops);
  
#line 375 
  if (entry == (struct dentry *)0) 
#line 375 
                                   goto err;
  else {
    bool tmp_70;
    
#line 375 
    tmp_70 = IS_ERR_0((void const *)entry);
    
#line 375 
    if ((int)tmp_70 != 0) 
#line 375 
                          goto err; else ;
  }
  
#line 376 
  entry = ldv_debugfs_create_file_149("rx_decrypt_key_not_found",(unsigned short)256,stats,(void *)wl,& rx_decrypt_key_not_found_ops);
  
#line 376 
  if (entry == (struct dentry *)0) 
#line 376 
                                   goto err;
  else {
    bool tmp_71;
    
#line 376 
    tmp_71 = IS_ERR_0((void const *)entry);
    
#line 376 
    if ((int)tmp_71 != 0) 
#line 376 
                          goto err; else ;
  }
  
#line 377 
  entry = ldv_debugfs_create_file_150("rx_defrag_need_decrypt",(unsigned short)256,stats,(void *)wl,& rx_defrag_need_decrypt_ops);
  
#line 377 
  if (entry == (struct dentry *)0) 
#line 377 
                                   goto err;
  else {
    bool tmp_72;
    
#line 377 
    tmp_72 = IS_ERR_0((void const *)entry);
    
#line 377 
    if ((int)tmp_72 != 0) 
#line 377 
                          goto err; else ;
  }
  
#line 378 
  entry = ldv_debugfs_create_file_151("rx_rx_tkip_replays",(unsigned short)256,stats,(void *)wl,& rx_rx_tkip_replays_ops);
  
#line 378 
  if (entry == (struct dentry *)0) 
#line 378 
                                   goto err;
  else {
    bool tmp_73;
    
#line 378 
    tmp_73 = IS_ERR_0((void const *)entry);
    
#line 378 
    if ((int)tmp_73 != 0) 
#line 378 
                          goto err; else ;
  }
  
#line 380 
  entry = ldv_debugfs_create_file_152("isr_irqs",(unsigned short)256,stats,(void *)wl,& isr_irqs_ops);
  
#line 380 
  if (entry == (struct dentry *)0) 
#line 380 
                                   goto err;
  else {
    bool tmp_74;
    
#line 380 
    tmp_74 = IS_ERR_0((void const *)entry);
    
#line 380 
    if ((int)tmp_74 != 0) 
#line 380 
                          goto err; else ;
  }
  
#line 382 
  entry = ldv_debugfs_create_file_153("pwr_missing_bcns_cnt",(unsigned short)256,stats,(void *)wl,& pwr_missing_bcns_cnt_ops);
  
#line 382 
  if (entry == (struct dentry *)0) 
#line 382 
                                   goto err;
  else {
    bool tmp_75;
    
#line 382 
    tmp_75 = IS_ERR_0((void const *)entry);
    
#line 382 
    if ((int)tmp_75 != 0) 
#line 382 
                          goto err; else ;
  }
  
#line 383 
  entry = ldv_debugfs_create_file_154("pwr_rcvd_bcns_cnt",(unsigned short)256,stats,(void *)wl,& pwr_rcvd_bcns_cnt_ops);
  
#line 383 
  if (entry == (struct dentry *)0) 
#line 383 
                                   goto err;
  else {
    bool tmp_76;
    
#line 383 
    tmp_76 = IS_ERR_0((void const *)entry);
    
#line 383 
    if ((int)tmp_76 != 0) 
#line 383 
                          goto err; else ;
  }
  
#line 384 
  entry = ldv_debugfs_create_file_155("pwr_connection_out_of_sync",(unsigned short)256,stats,(void *)wl,& pwr_connection_out_of_sync_ops);
  
#line 384 
  if (entry == (struct dentry *)0) 
#line 384 
                                   goto err;
  else {
    bool tmp_77;
    
#line 384 
    tmp_77 = IS_ERR_0((void const *)entry);
    
#line 384 
    if ((int)tmp_77 != 0) 
#line 384 
                          goto err; else ;
  }
  
#line 385 
  entry = ldv_debugfs_create_file_156("pwr_cont_miss_bcns_spread",(unsigned short)256,stats,(void *)wl,& pwr_cont_miss_bcns_spread_ops);
  
#line 385 
  if (entry == (struct dentry *)0) 
#line 385 
                                   goto err;
  else {
    bool tmp_78;
    
#line 385 
    tmp_78 = IS_ERR_0((void const *)entry);
    
#line 385 
    if ((int)tmp_78 != 0) 
#line 385 
                          goto err; else ;
  }
  
#line 386 
  entry = ldv_debugfs_create_file_157("pwr_rcvd_awake_bcns_cnt",(unsigned short)256,stats,(void *)wl,& pwr_rcvd_awake_bcns_cnt_ops);
  
#line 386 
  if (entry == (struct dentry *)0) 
#line 386 
                                   goto err;
  else {
    bool tmp_79;
    
#line 386 
    tmp_79 = IS_ERR_0((void const *)entry);
    
#line 386 
    if ((int)tmp_79 != 0) 
#line 386 
                          goto err; else ;
  }
  
#line 388 
  entry = ldv_debugfs_create_file_158("ps_poll_ps_poll_timeouts",(unsigned short)256,stats,(void *)wl,& ps_poll_ps_poll_timeouts_ops);
  
#line 388 
  if (entry == (struct dentry *)0) 
#line 388 
                                   goto err;
  else {
    bool tmp_80;
    
#line 388 
    tmp_80 = IS_ERR_0((void const *)entry);
    
#line 388 
    if ((int)tmp_80 != 0) 
#line 388 
                          goto err; else ;
  }
  
#line 389 
  entry = ldv_debugfs_create_file_159("ps_poll_upsd_timeouts",(unsigned short)256,stats,(void *)wl,& ps_poll_upsd_timeouts_ops);
  
#line 389 
  if (entry == (struct dentry *)0) 
#line 389 
                                   goto err;
  else {
    bool tmp_81;
    
#line 389 
    tmp_81 = IS_ERR_0((void const *)entry);
    
#line 389 
    if ((int)tmp_81 != 0) 
#line 389 
                          goto err; else ;
  }
  
#line 390 
  entry = ldv_debugfs_create_file_160("ps_poll_upsd_max_ap_turn",(unsigned short)256,stats,(void *)wl,& ps_poll_upsd_max_ap_turn_ops);
  
#line 390 
  if (entry == (struct dentry *)0) 
#line 390 
                                   goto err;
  else {
    bool tmp_82;
    
#line 390 
    tmp_82 = IS_ERR_0((void const *)entry);
    
#line 390 
    if ((int)tmp_82 != 0) 
#line 390 
                          goto err; else ;
  }
  
#line 391 
  entry = ldv_debugfs_create_file_161("ps_poll_ps_poll_max_ap_turn",(unsigned short)256,stats,(void *)wl,& ps_poll_ps_poll_max_ap_turn_ops);
  
#line 391 
  if (entry == (struct dentry *)0) 
#line 391 
                                   goto err;
  else {
    bool tmp_83;
    
#line 391 
    tmp_83 = IS_ERR_0((void const *)entry);
    
#line 391 
    if ((int)tmp_83 != 0) 
#line 391 
                          goto err; else ;
  }
  
#line 392 
  entry = ldv_debugfs_create_file_162("ps_poll_ps_poll_utilization",(unsigned short)256,stats,(void *)wl,& ps_poll_ps_poll_utilization_ops);
  
#line 392 
  if (entry == (struct dentry *)0) 
#line 392 
                                   goto err;
  else {
    bool tmp_84;
    
#line 392 
    tmp_84 = IS_ERR_0((void const *)entry);
    
#line 392 
    if ((int)tmp_84 != 0) 
#line 392 
                          goto err; else ;
  }
  
#line 393 
  entry = ldv_debugfs_create_file_163("ps_poll_upsd_utilization",(unsigned short)256,stats,(void *)wl,& ps_poll_upsd_utilization_ops);
  
#line 393 
  if (entry == (struct dentry *)0) 
#line 393 
                                   goto err;
  else {
    bool tmp_85;
    
#line 393 
    tmp_85 = IS_ERR_0((void const *)entry);
    
#line 393 
    if ((int)tmp_85 != 0) 
#line 393 
                          goto err; else ;
  }
  
#line 395 
  entry = ldv_debugfs_create_file_164("rx_filter_beacon_filter",(unsigned short)256,stats,(void *)wl,& rx_filter_beacon_filter_ops);
  
#line 395 
  if (entry == (struct dentry *)0) 
#line 395 
                                   goto err;
  else {
    bool tmp_86;
    
#line 395 
    tmp_86 = IS_ERR_0((void const *)entry);
    
#line 395 
    if ((int)tmp_86 != 0) 
#line 395 
                          goto err; else ;
  }
  
#line 396 
  entry = ldv_debugfs_create_file_165("rx_filter_arp_filter",(unsigned short)256,stats,(void *)wl,& rx_filter_arp_filter_ops);
  
#line 396 
  if (entry == (struct dentry *)0) 
#line 396 
                                   goto err;
  else {
    bool tmp_87;
    
#line 396 
    tmp_87 = IS_ERR_0((void const *)entry);
    
#line 396 
    if ((int)tmp_87 != 0) 
#line 396 
                          goto err; else ;
  }
  
#line 397 
  entry = ldv_debugfs_create_file_166("rx_filter_mc_filter",(unsigned short)256,stats,(void *)wl,& rx_filter_mc_filter_ops);
  
#line 397 
  if (entry == (struct dentry *)0) 
#line 397 
                                   goto err;
  else {
    bool tmp_88;
    
#line 397 
    tmp_88 = IS_ERR_0((void const *)entry);
    
#line 397 
    if ((int)tmp_88 != 0) 
#line 397 
                          goto err; else ;
  }
  
#line 398 
  entry = ldv_debugfs_create_file_167("rx_filter_dup_filter",(unsigned short)256,stats,(void *)wl,& rx_filter_dup_filter_ops);
  
#line 398 
  if (entry == (struct dentry *)0) 
#line 398 
                                   goto err;
  else {
    bool tmp_89;
    
#line 398 
    tmp_89 = IS_ERR_0((void const *)entry);
    
#line 398 
    if ((int)tmp_89 != 0) 
#line 398 
                          goto err; else ;
  }
  
#line 399 
  entry = ldv_debugfs_create_file_168("rx_filter_data_filter",(unsigned short)256,stats,(void *)wl,& rx_filter_data_filter_ops);
  
#line 399 
  if (entry == (struct dentry *)0) 
#line 399 
                                   goto err;
  else {
    bool tmp_90;
    
#line 399 
    tmp_90 = IS_ERR_0((void const *)entry);
    
#line 399 
    if ((int)tmp_90 != 0) 
#line 399 
                          goto err; else ;
  }
  
#line 400 
  entry = ldv_debugfs_create_file_169("rx_filter_ibss_filter",(unsigned short)256,stats,(void *)wl,& rx_filter_ibss_filter_ops);
  
#line 400 
  if (entry == (struct dentry *)0) 
#line 400 
                                   goto err;
  else {
    bool tmp_91;
    
#line 400 
    tmp_91 = IS_ERR_0((void const *)entry);
    
#line 400 
    if ((int)tmp_91 != 0) 
#line 400 
                          goto err; else ;
  }
  
#line 401 
  entry = ldv_debugfs_create_file_170("rx_filter_protection_filter",(unsigned short)256,stats,(void *)wl,& rx_filter_protection_filter_ops);
  
#line 401 
  if (entry == (struct dentry *)0) 
#line 401 
                                   goto err;
  else {
    bool tmp_92;
    
#line 401 
    tmp_92 = IS_ERR_0((void const *)entry);
    
#line 401 
    if ((int)tmp_92 != 0) 
#line 401 
                          goto err; else ;
  }
  
#line 402 
  entry = ldv_debugfs_create_file_171("rx_filter_accum_arp_pend_requests",(unsigned short)256,stats,(void *)wl,& rx_filter_accum_arp_pend_requests_ops);
  
#line 402 
  if (entry == (struct dentry *)0) 
#line 402 
                                   goto err;
  else {
    bool tmp_93;
    
#line 402 
    tmp_93 = IS_ERR_0((void const *)entry);
    
#line 402 
    if ((int)tmp_93 != 0) 
#line 402 
                          goto err; else ;
  }
  
#line 403 
  entry = ldv_debugfs_create_file_172("rx_filter_max_arp_queue_dep",(unsigned short)256,stats,(void *)wl,& rx_filter_max_arp_queue_dep_ops);
  
#line 403 
  if (entry == (struct dentry *)0) 
#line 403 
                                   goto err;
  else {
    bool tmp_94;
    
#line 403 
    tmp_94 = IS_ERR_0((void const *)entry);
    
#line 403 
    if ((int)tmp_94 != 0) 
#line 403 
                          goto err; else ;
  }
  
#line 405 
  entry = ldv_debugfs_create_file_173("rx_rate_rx_frames_per_rates",(unsigned short)256,stats,(void *)wl,& rx_rate_rx_frames_per_rates_ops);
  
#line 405 
  if (entry == (struct dentry *)0) 
#line 405 
                                   goto err;
  else {
    bool tmp_95;
    
#line 405 
    tmp_95 = IS_ERR_0((void const *)entry);
    
#line 405 
    if ((int)tmp_95 != 0) 
#line 405 
                          goto err; else ;
  }
  
#line 407 
  entry = ldv_debugfs_create_file_174("aggr_size_tx_agg_vs_rate",(unsigned short)256,stats,(void *)wl,& aggr_size_tx_agg_vs_rate_ops);
  
#line 407 
  if (entry == (struct dentry *)0) 
#line 407 
                                   goto err;
  else {
    bool tmp_96;
    
#line 407 
    tmp_96 = IS_ERR_0((void const *)entry);
    
#line 407 
    if ((int)tmp_96 != 0) 
#line 407 
                          goto err; else ;
  }
  
#line 408 
  entry = ldv_debugfs_create_file_175("aggr_size_rx_size",(unsigned short)256,stats,(void *)wl,& aggr_size_rx_size_ops);
  
#line 408 
  if (entry == (struct dentry *)0) 
#line 408 
                                   goto err;
  else {
    bool tmp_97;
    
#line 408 
    tmp_97 = IS_ERR_0((void const *)entry);
    
#line 408 
    if ((int)tmp_97 != 0) 
#line 408 
                          goto err; else ;
  }
  
#line 410 
  entry = ldv_debugfs_create_file_176("pipeline_hs_tx_stat_fifo_int",(unsigned short)256,stats,(void *)wl,& pipeline_hs_tx_stat_fifo_int_ops);
  
#line 410 
  if (entry == (struct dentry *)0) 
#line 410 
                                   goto err;
  else {
    bool tmp_98;
    
#line 410 
    tmp_98 = IS_ERR_0((void const *)entry);
    
#line 410 
    if ((int)tmp_98 != 0) 
#line 410 
                          goto err; else ;
  }
  
#line 411 
  entry = ldv_debugfs_create_file_177("pipeline_tcp_tx_stat_fifo_int",(unsigned short)256,stats,(void *)wl,& pipeline_tcp_tx_stat_fifo_int_ops);
  
#line 411 
  if (entry == (struct dentry *)0) 
#line 411 
                                   goto err;
  else {
    bool tmp_99;
    
#line 411 
    tmp_99 = IS_ERR_0((void const *)entry);
    
#line 411 
    if ((int)tmp_99 != 0) 
#line 411 
                          goto err; else ;
  }
  
#line 412 
  entry = ldv_debugfs_create_file_178("pipeline_tcp_rx_stat_fifo_int",(unsigned short)256,stats,(void *)wl,& pipeline_tcp_rx_stat_fifo_int_ops);
  
#line 412 
  if (entry == (struct dentry *)0) 
#line 412 
                                   goto err;
  else {
    bool tmp_100;
    
#line 412 
    tmp_100 = IS_ERR_0((void const *)entry);
    
#line 412 
    if ((int)tmp_100 != 0) 
#line 412 
                           goto err; else ;
  }
  
#line 413 
  entry = ldv_debugfs_create_file_179("pipeline_enc_tx_stat_fifo_int",(unsigned short)256,stats,(void *)wl,& pipeline_enc_tx_stat_fifo_int_ops);
  
#line 413 
  if (entry == (struct dentry *)0) 
#line 413 
                                   goto err;
  else {
    bool tmp_101;
    
#line 413 
    tmp_101 = IS_ERR_0((void const *)entry);
    
#line 413 
    if ((int)tmp_101 != 0) 
#line 413 
                           goto err; else ;
  }
  
#line 414 
  entry = ldv_debugfs_create_file_180("pipeline_enc_rx_stat_fifo_int",(unsigned short)256,stats,(void *)wl,& pipeline_enc_rx_stat_fifo_int_ops);
  
#line 414 
  if (entry == (struct dentry *)0) 
#line 414 
                                   goto err;
  else {
    bool tmp_102;
    
#line 414 
    tmp_102 = IS_ERR_0((void const *)entry);
    
#line 414 
    if ((int)tmp_102 != 0) 
#line 414 
                           goto err; else ;
  }
  
#line 415 
  entry = ldv_debugfs_create_file_181("pipeline_rx_complete_stat_fifo_int",(unsigned short)256,stats,(void *)wl,& pipeline_rx_complete_stat_fifo_int_ops);
  
#line 415 
  if (entry == (struct dentry *)0) 
#line 415 
                                   goto err;
  else {
    bool tmp_103;
    
#line 415 
    tmp_103 = IS_ERR_0((void const *)entry);
    
#line 415 
    if ((int)tmp_103 != 0) 
#line 415 
                           goto err; else ;
  }
  
#line 416 
  entry = ldv_debugfs_create_file_182("pipeline_pre_proc_swi",(unsigned short)256,stats,(void *)wl,& pipeline_pre_proc_swi_ops);
  
#line 416 
  if (entry == (struct dentry *)0) 
#line 416 
                                   goto err;
  else {
    bool tmp_104;
    
#line 416 
    tmp_104 = IS_ERR_0((void const *)entry);
    
#line 416 
    if ((int)tmp_104 != 0) 
#line 416 
                           goto err; else ;
  }
  
#line 417 
  entry = ldv_debugfs_create_file_183("pipeline_post_proc_swi",(unsigned short)256,stats,(void *)wl,& pipeline_post_proc_swi_ops);
  
#line 417 
  if (entry == (struct dentry *)0) 
#line 417 
                                   goto err;
  else {
    bool tmp_105;
    
#line 417 
    tmp_105 = IS_ERR_0((void const *)entry);
    
#line 417 
    if ((int)tmp_105 != 0) 
#line 417 
                           goto err; else ;
  }
  
#line 418 
  entry = ldv_debugfs_create_file_184("pipeline_sec_frag_swi",(unsigned short)256,stats,(void *)wl,& pipeline_sec_frag_swi_ops);
  
#line 418 
  if (entry == (struct dentry *)0) 
#line 418 
                                   goto err;
  else {
    bool tmp_106;
    
#line 418 
    tmp_106 = IS_ERR_0((void const *)entry);
    
#line 418 
    if ((int)tmp_106 != 0) 
#line 418 
                           goto err; else ;
  }
  
#line 419 
  entry = ldv_debugfs_create_file_185("pipeline_pre_to_defrag_swi",(unsigned short)256,stats,(void *)wl,& pipeline_pre_to_defrag_swi_ops);
  
#line 419 
  if (entry == (struct dentry *)0) 
#line 419 
                                   goto err;
  else {
    bool tmp_107;
    
#line 419 
    tmp_107 = IS_ERR_0((void const *)entry);
    
#line 419 
    if ((int)tmp_107 != 0) 
#line 419 
                           goto err; else ;
  }
  
#line 420 
  entry = ldv_debugfs_create_file_186("pipeline_defrag_to_csum_swi",(unsigned short)256,stats,(void *)wl,& pipeline_defrag_to_csum_swi_ops);
  
#line 420 
  if (entry == (struct dentry *)0) 
#line 420 
                                   goto err;
  else {
    bool tmp_108;
    
#line 420 
    tmp_108 = IS_ERR_0((void const *)entry);
    
#line 420 
    if ((int)tmp_108 != 0) 
#line 420 
                           goto err; else ;
  }
  
#line 421 
  entry = ldv_debugfs_create_file_187("pipeline_csum_to_rx_xfer_swi",(unsigned short)256,stats,(void *)wl,& pipeline_csum_to_rx_xfer_swi_ops);
  
#line 421 
  if (entry == (struct dentry *)0) 
#line 421 
                                   goto err;
  else {
    bool tmp_109;
    
#line 421 
    tmp_109 = IS_ERR_0((void const *)entry);
    
#line 421 
    if ((int)tmp_109 != 0) 
#line 421 
                           goto err; else ;
  }
  
#line 422 
  entry = ldv_debugfs_create_file_188("pipeline_dec_packet_in",(unsigned short)256,stats,(void *)wl,& pipeline_dec_packet_in_ops);
  
#line 422 
  if (entry == (struct dentry *)0) 
#line 422 
                                   goto err;
  else {
    bool tmp_110;
    
#line 422 
    tmp_110 = IS_ERR_0((void const *)entry);
    
#line 422 
    if ((int)tmp_110 != 0) 
#line 422 
                           goto err; else ;
  }
  
#line 423 
  entry = ldv_debugfs_create_file_189("pipeline_dec_packet_in_fifo_full",(unsigned short)256,stats,(void *)wl,& pipeline_dec_packet_in_fifo_full_ops);
  
#line 423 
  if (entry == (struct dentry *)0) 
#line 423 
                                   goto err;
  else {
    bool tmp_111;
    
#line 423 
    tmp_111 = IS_ERR_0((void const *)entry);
    
#line 423 
    if ((int)tmp_111 != 0) 
#line 423 
                           goto err; else ;
  }
  
#line 424 
  entry = ldv_debugfs_create_file_190("pipeline_dec_packet_out",(unsigned short)256,stats,(void *)wl,& pipeline_dec_packet_out_ops);
  
#line 424 
  if (entry == (struct dentry *)0) 
#line 424 
                                   goto err;
  else {
    bool tmp_112;
    
#line 424 
    tmp_112 = IS_ERR_0((void const *)entry);
    
#line 424 
    if ((int)tmp_112 != 0) 
#line 424 
                           goto err; else ;
  }
  
#line 425 
  entry = ldv_debugfs_create_file_191("pipeline_cs_rx_packet_in",(unsigned short)256,stats,(void *)wl,& pipeline_cs_rx_packet_in_ops);
  
#line 425 
  if (entry == (struct dentry *)0) 
#line 425 
                                   goto err;
  else {
    bool tmp_113;
    
#line 425 
    tmp_113 = IS_ERR_0((void const *)entry);
    
#line 425 
    if ((int)tmp_113 != 0) 
#line 425 
                           goto err; else ;
  }
  
#line 426 
  entry = ldv_debugfs_create_file_192("pipeline_cs_rx_packet_out",(unsigned short)256,stats,(void *)wl,& pipeline_cs_rx_packet_out_ops);
  
#line 426 
  if (entry == (struct dentry *)0) 
#line 426 
                                   goto err;
  else {
    bool tmp_114;
    
#line 426 
    tmp_114 = IS_ERR_0((void const *)entry);
    
#line 426 
    if ((int)tmp_114 != 0) 
#line 426 
                           goto err; else ;
  }
  
#line 427 
  entry = ldv_debugfs_create_file_193("pipeline_pipeline_fifo_full",(unsigned short)256,stats,(void *)wl,& pipeline_pipeline_fifo_full_ops);
  
#line 427 
  if (entry == (struct dentry *)0) 
#line 427 
                                   goto err;
  else {
    bool tmp_115;
    
#line 427 
    tmp_115 = IS_ERR_0((void const *)entry);
    
#line 427 
    if ((int)tmp_115 != 0) 
#line 427 
                           goto err; else ;
  }
  
#line 429 
  entry = ldv_debugfs_create_file_194("mem_rx_free_mem_blks",(unsigned short)256,stats,(void *)wl,& mem_rx_free_mem_blks_ops);
  
#line 429 
  if (entry == (struct dentry *)0) 
#line 429 
                                   goto err;
  else {
    bool tmp_116;
    
#line 429 
    tmp_116 = IS_ERR_0((void const *)entry);
    
#line 429 
    if ((int)tmp_116 != 0) 
#line 429 
                           goto err; else ;
  }
  
#line 430 
  entry = ldv_debugfs_create_file_195("mem_tx_free_mem_blks",(unsigned short)256,stats,(void *)wl,& mem_tx_free_mem_blks_ops);
  
#line 430 
  if (entry == (struct dentry *)0) 
#line 430 
                                   goto err;
  else {
    bool tmp_117;
    
#line 430 
    tmp_117 = IS_ERR_0((void const *)entry);
    
#line 430 
    if ((int)tmp_117 != 0) 
#line 430 
                           goto err; else ;
  }
  
#line 431 
  entry = ldv_debugfs_create_file_196("mem_fwlog_free_mem_blks",(unsigned short)256,stats,(void *)wl,& mem_fwlog_free_mem_blks_ops);
  
#line 431 
  if (entry == (struct dentry *)0) 
#line 431 
                                   goto err;
  else {
    bool tmp_118;
    
#line 431 
    tmp_118 = IS_ERR_0((void const *)entry);
    
#line 431 
    if ((int)tmp_118 != 0) 
#line 431 
                           goto err; else ;
  }
  
#line 432 
  entry = ldv_debugfs_create_file_197("mem_fw_gen_free_mem_blks",(unsigned short)256,stats,(void *)wl,& mem_fw_gen_free_mem_blks_ops);
  
#line 432 
  if (entry == (struct dentry *)0) 
#line 432 
                                   goto err;
  else {
    bool tmp_119;
    
#line 432 
    tmp_119 = IS_ERR_0((void const *)entry);
    
#line 432 
    if ((int)tmp_119 != 0) 
#line 432 
                           goto err; else ;
  }
  
#line 434 
  entry = ldv_debugfs_create_file_198("conf",(unsigned short)256,moddir,(void *)wl,& conf_ops);
  
#line 434 
  if (entry == (struct dentry *)0) 
#line 434 
                                   goto err;
  else {
    bool tmp_120;
    
#line 434 
    tmp_120 = IS_ERR_0((void const *)entry);
    
#line 434 
    if ((int)tmp_120 != 0) 
#line 434 
                           goto err; else ;
  }
  
#line 435 
  entry = ldv_debugfs_create_file_199("radar_detection",(unsigned short)256,moddir,(void *)wl,& radar_detection_ops);
  
#line 435 
  if (entry == (struct dentry *)0) 
#line 435 
                                   goto err;
  else {
    bool tmp_121;
    
#line 435 
    tmp_121 = IS_ERR_0((void const *)entry);
    
#line 435 
    if ((int)tmp_121 != 0) 
#line 435 
                           goto err; else ;
  }
  
#line 437 
  __retres = 0;
  
#line 437 
  goto return_label;
  err: 
#line 439 
  ;
  
#line 440 
  tmp_123 = IS_ERR_0((void const *)entry);
  
#line 440 
  if ((int)tmp_123 != 0) {
    long tmp_122;
    
#line 441 
    tmp_122 = PTR_ERR_0((void const *)entry);
    
#line 441 
    ret = (int)tmp_122;
  }
  else 
#line 443 
       ret = -12;
  
#line 445 
  __retres = ret;
  return_label: 
#line 445 
                return __retres;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_debug_debug4_ops_2 = (struct file_operations *)(& debug_debug4_ops);

#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_aggr_size_tx_agg_vs_rate_ops_2 = (struct file_operations *)(& aggr_size_tx_agg_vs_rate_ops);

#line 58  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_decrypt_key_not_found_ops_2 = (struct file_operations *)(& rx_decrypt_key_not_found_ops);

#line 59  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pipeline_tcp_tx_stat_fifo_int_ops_2 = (struct file_operations *)(& pipeline_tcp_tx_stat_fifo_int_ops);

#line 60  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_filter_accum_arp_pend_requests_ops_2 = (struct file_operations *)(& rx_filter_accum_arp_pend_requests_ops);

#line 61  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_frag_bad_mblk_num_ops_2 = (struct file_operations *)(& tx_frag_bad_mblk_num_ops);

#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_defrag_decrypt_failed_ops_2 = (struct file_operations *)(& rx_defrag_decrypt_failed_ops);

#line 63  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_tx_start_null_frame_ops_2 = (struct file_operations *)(& tx_tx_start_null_frame_ops);

#line 64  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_rx_phy_hdr_ops_2 = (struct file_operations *)(& rx_rx_phy_hdr_ops);

#line 65  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pwr_connection_out_of_sync_ops_2 = (struct file_operations *)(& pwr_connection_out_of_sync_ops);

#line 66  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_error_error_numll_frame_cts_start_ops_2 = (struct file_operations *)(& error_error_numll_frame_cts_start_ops);

#line 67  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_error_error_null_Frame_tx_start_ops_2 = (struct file_operations *)(& error_error_null_Frame_tx_start_ops);

#line 68  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_tx_data_prepared_ops_2 = (struct file_operations *)(& tx_tx_data_prepared_ops);

#line 69  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
int (*ldv_emg_alias_simple_open_5)(struct inode *, struct file *) = & simple_open;

#line 70  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_rx_checksum_result_ops_2 = (struct file_operations *)(& rx_rx_checksum_result_ops);

#line 71  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_ps_poll_ps_poll_max_ap_turn_ops_2 = (struct file_operations *)(& ps_poll_ps_poll_max_ap_turn_ops);

#line 72  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_rx_cmplt_ops_2 = (struct file_operations *)(& rx_rx_cmplt_ops);

#line 73  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_tx_retry_template_ops_2 = (struct file_operations *)(& tx_tx_retry_template_ops);

#line 74  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_filter_mc_filter_ops_2 = (struct file_operations *)(& rx_filter_mc_filter_ops);

#line 75  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pwr_rcvd_bcns_cnt_ops_2 = (struct file_operations *)(& pwr_rcvd_bcns_cnt_ops);

#line 76  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pipeline_pipeline_fifo_full_ops_2 = (struct file_operations *)(& pipeline_pipeline_fifo_full_ops);

#line 77  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_tx_checksum_result_ops_2 = (struct file_operations *)(& tx_tx_checksum_result_ops);

#line 78  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_error_error_frame_ops_2 = (struct file_operations *)(& error_error_frame_ops);

#line 79  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_tx_done_int_template_ops_2 = (struct file_operations *)(& tx_tx_done_int_template_ops);

#line 80  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_rx_frame_checksum_ops_2 = (struct file_operations *)(& rx_rx_frame_checksum_ops);

#line 81  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_debug_debug1_ops_2 = (struct file_operations *)(& debug_debug1_ops);

#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_tx_template_prepared_ops_2 = (struct file_operations *)(& tx_tx_template_prepared_ops);

#line 83  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_mem_fwlog_free_mem_blks_ops_2 = (struct file_operations *)(& mem_fwlog_free_mem_blks_ops);

#line 84  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_frag_cache_miss_ops_2 = (struct file_operations *)(& tx_frag_cache_miss_ops);

#line 85  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pipeline_sec_frag_swi_ops_2 = (struct file_operations *)(& pipeline_sec_frag_swi_ops);

#line 86  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_rx_pre_complt_ops_2 = (struct file_operations *)(& rx_rx_pre_complt_ops);

#line 87  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_tx_done_data_ops_2 = (struct file_operations *)(& tx_tx_done_data_ops);

#line 88  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pipeline_defrag_to_csum_swi_ops_2 = (struct file_operations *)(& pipeline_defrag_to_csum_swi_ops);

#line 89  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_frag_failed_ops_2 = (struct file_operations *)(& tx_frag_failed_ops);

#line 90  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_defrag_init_called_ops_2 = (struct file_operations *)(& rx_defrag_init_called_ops);

#line 91  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_defrag_in_process_called_ops_2 = (struct file_operations *)(& rx_defrag_in_process_called_ops);

#line 92  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_tx_data_programmed_ops_2 = (struct file_operations *)(& tx_tx_data_programmed_ops);

#line 93  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_filter_data_filter_ops_2 = (struct file_operations *)(& rx_filter_data_filter_ops);

#line 94  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_rx_timeout_ops_2 = (struct file_operations *)(& rx_rx_timeout_ops);

#line 95  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_ps_poll_ps_poll_utilization_ops_2 = (struct file_operations *)(& ps_poll_ps_poll_utilization_ops);

#line 96  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pipeline_cs_rx_packet_out_ops_2 = (struct file_operations *)(& pipeline_cs_rx_packet_out_ops);

#line 97  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_filter_max_arp_queue_dep_ops_2 = (struct file_operations *)(& rx_filter_max_arp_queue_dep_ops);

#line 98  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_tx_retry_data_ops_2 = (struct file_operations *)(& tx_tx_retry_data_ops);

#line 99  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pipeline_cs_rx_packet_in_ops_2 = (struct file_operations *)(& pipeline_cs_rx_packet_in_ops);

#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pipeline_dec_packet_in_fifo_full_ops_2 = (struct file_operations *)(& pipeline_dec_packet_in_fifo_full_ops);

#line 101  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_debug_debug6_ops_2 = (struct file_operations *)(& debug_debug6_ops);

#line 102  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_frag_cache_hit_ops_2 = (struct file_operations *)(& tx_frag_cache_hit_ops);

#line 103  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_rate_rx_frames_per_rates_ops_2 = (struct file_operations *)(& rx_rate_rx_frames_per_rates_ops);

#line 104  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_defrag_need_defrag_ops_2 = (struct file_operations *)(& rx_defrag_need_defrag_ops);

#line 105  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pipeline_rx_complete_stat_fifo_int_ops_2 = (struct file_operations *)(& pipeline_rx_complete_stat_fifo_int_ops);

#line 106  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pwr_missing_bcns_cnt_ops_2 = (struct file_operations *)(& pwr_missing_bcns_cnt_ops);

#line 107  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pipeline_pre_to_defrag_swi_ops_2 = (struct file_operations *)(& pipeline_pre_to_defrag_swi_ops);

#line 108  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_rx_wa_ba_not_expected_ops_2 = (struct file_operations *)(& rx_rx_wa_ba_not_expected_ops);

#line 109  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_mem_fw_gen_free_mem_blks_ops_2 = (struct file_operations *)(& mem_fw_gen_free_mem_blks_ops);

#line 110  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_filter_beacon_filter_ops_2 = (struct file_operations *)(& rx_filter_beacon_filter_ops);

#line 111  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_rx_timeout_wa_ops_2 = (struct file_operations *)(& rx_rx_timeout_wa_ops);

#line 112  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_radar_detection_ops_2 = (struct file_operations *)(& radar_detection_ops);

#line 113  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_frag_called_ops_2 = (struct file_operations *)(& tx_frag_called_ops);

#line 114  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_tx_starts_ops_2 = (struct file_operations *)(& tx_tx_starts_ops);

#line 115  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_tx_start_fw_gen_ops_2 = (struct file_operations *)(& tx_tx_start_fw_gen_ops);

#line 116  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_tx_start_int_templates_ops_2 = (struct file_operations *)(& tx_tx_start_int_templates_ops);

#line 117  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_frag_tkip_called_ops_2 = (struct file_operations *)(& tx_frag_tkip_called_ops);

#line 118  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_frag_in_process_called_ops_2 = (struct file_operations *)(& tx_frag_in_process_called_ops);

#line 119  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_defrag_tkip_called_ops_2 = (struct file_operations *)(& rx_defrag_tkip_called_ops);

#line 120  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_rx_tkip_replays_ops_2 = (struct file_operations *)(& rx_rx_tkip_replays_ops);

#line 121  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_frag_init_called_ops_2 = (struct file_operations *)(& tx_frag_init_called_ops);

#line 122  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long long (*ldv_emg_alias_default_llseek_3)(struct file *, long long , int ) = & default_llseek;

#line 123  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pipeline_enc_rx_stat_fifo_int_ops_2 = (struct file_operations *)(& pipeline_enc_rx_stat_fifo_int_ops);

#line 124  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_tx_cmplt_ops_2 = (struct file_operations *)(& tx_tx_cmplt_ops);

#line 125  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_conf_ops_2 = (struct file_operations *)(& conf_ops);

#line 126  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_debug_debug2_ops_2 = (struct file_operations *)(& debug_debug2_ops);

#line 127  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_filter_ibss_filter_ops_2 = (struct file_operations *)(& rx_filter_ibss_filter_ops);

#line 128  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_ps_poll_upsd_timeouts_ops_2 = (struct file_operations *)(& ps_poll_upsd_timeouts_ops);

#line 129  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_tx_prepared_descs_ops_2 = (struct file_operations *)(& tx_tx_prepared_descs_ops);

#line 130  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_ps_poll_upsd_utilization_ops_2 = (struct file_operations *)(& ps_poll_upsd_utilization_ops);

#line 131  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_rx_wa_density_dropped_frame_ops_2 = (struct file_operations *)(& rx_rx_wa_density_dropped_frame_ops);

#line 132  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_defrag_need_decrypt_ops_2 = (struct file_operations *)(& rx_defrag_need_decrypt_ops);

#line 133  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pwr_rcvd_awake_bcns_cnt_ops_2 = (struct file_operations *)(& pwr_rcvd_awake_bcns_cnt_ops);

#line 134  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_isr_irqs_ops_2 = (struct file_operations *)(& isr_irqs_ops);

#line 135  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_mem_tx_free_mem_blks_ops_2 = (struct file_operations *)(& mem_tx_free_mem_blks_ops);

#line 136  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_aggr_size_rx_size_ops_2 = (struct file_operations *)(& aggr_size_rx_size_ops);

#line 137  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_tx_frame_checksum_ops_2 = (struct file_operations *)(& tx_tx_frame_checksum_ops);

#line 138  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_frag_need_fragmentation_ops_2 = (struct file_operations *)(& tx_frag_need_fragmentation_ops);

#line 139  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pwr_cont_miss_bcns_spread_ops_2 = (struct file_operations *)(& pwr_cont_miss_bcns_spread_ops);

#line 140  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_error_error_bar_retry_ops_2 = (struct file_operations *)(& error_error_bar_retry_ops);

#line 141  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pipeline_enc_tx_stat_fifo_int_ops_2 = (struct file_operations *)(& pipeline_enc_tx_stat_fifo_int_ops);

#line 142  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_tx_exch_pending_ops_2 = (struct file_operations *)(& tx_tx_exch_pending_ops);

#line 143  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pipeline_tcp_rx_stat_fifo_int_ops_2 = (struct file_operations *)(& pipeline_tcp_rx_stat_fifo_int_ops);

#line 144  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pipeline_pre_proc_swi_ops_2 = (struct file_operations *)(& pipeline_pre_proc_swi_ops);

#line 145  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_ps_poll_ps_poll_timeouts_ops_2 = (struct file_operations *)(& ps_poll_ps_poll_timeouts_ops);

#line 146  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_filter_dup_filter_ops_2 = (struct file_operations *)(& rx_filter_dup_filter_ops);

#line 147  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pipeline_csum_to_rx_xfer_swi_ops_2 = (struct file_operations *)(& pipeline_csum_to_rx_xfer_swi_ops);

#line 148  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pipeline_post_proc_swi_ops_2 = (struct file_operations *)(& pipeline_post_proc_swi_ops);

#line 149  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_debug_debug3_ops_2 = (struct file_operations *)(& debug_debug3_ops);

#line 150  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_rx_defrag_ops_2 = (struct file_operations *)(& rx_rx_defrag_ops);

#line 151  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_tx_start_templates_ops_2 = (struct file_operations *)(& tx_tx_start_templates_ops);

#line 152  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_rx_defrag_end_ops_2 = (struct file_operations *)(& rx_rx_defrag_end_ops);

#line 153  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_rx_beacon_early_term_ops_2 = (struct file_operations *)(& rx_rx_beacon_early_term_ops);

#line 154  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pipeline_dec_packet_out_ops_2 = (struct file_operations *)(& pipeline_dec_packet_out_ops);

#line 155  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_mem_rx_free_mem_blks_ops_2 = (struct file_operations *)(& mem_rx_free_mem_blks_ops);

#line 156  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_rx_hdr_overflow_ops_2 = (struct file_operations *)(& rx_rx_hdr_overflow_ops);

#line 157  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_ps_poll_upsd_max_ap_turn_ops_2 = (struct file_operations *)(& ps_poll_upsd_max_ap_turn_ops);

#line 158  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_rx_out_of_mpdu_nodes_ops_2 = (struct file_operations *)(& rx_rx_out_of_mpdu_nodes_ops);

#line 159  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_rx_done_ops_2 = (struct file_operations *)(& rx_rx_done_ops);

#line 160  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_tx_exch_ops_2 = (struct file_operations *)(& tx_tx_exch_ops);

#line 161  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_error_error_frame_cts_nul_flid_ops_2 = (struct file_operations *)(& error_error_frame_cts_nul_flid_ops);

#line 162  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long long (*ldv_emg_alias_generic_file_llseek_3)(struct file *, long long , int ) = & generic_file_llseek;

#line 163  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pipeline_dec_packet_in_ops_2 = (struct file_operations *)(& pipeline_dec_packet_in_ops);

#line 164  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_defrag_called_ops_2 = (struct file_operations *)(& rx_defrag_called_ops);

#line 165  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_tx_done_template_ops_2 = (struct file_operations *)(& tx_tx_done_template_ops);

#line 166  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_rx_dropped_frame_ops_2 = (struct file_operations *)(& rx_rx_dropped_frame_ops);

#line 167  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_filter_protection_filter_ops_2 = (struct file_operations *)(& rx_filter_protection_filter_ops);

#line 168  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_filter_arp_filter_ops_2 = (struct file_operations *)(& rx_filter_arp_filter_ops);

#line 169  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_rx_rx_cmplt_task_ops_2 = (struct file_operations *)(& rx_rx_cmplt_task_ops);

#line 170  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_pipeline_hs_tx_stat_fifo_int_ops_2 = (struct file_operations *)(& pipeline_hs_tx_stat_fifo_int_ops);

#line 171  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_tx_imm_resp_ops_2 = (struct file_operations *)(& tx_tx_imm_resp_ops);

#line 172  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_tx_burst_programmed_ops_2 = (struct file_operations *)(& tx_tx_burst_programmed_ops);

#line 173  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_tx_template_programmed_ops_2 = (struct file_operations *)(& tx_tx_template_programmed_ops);

#line 174  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_tx_exch_expiry_ops_2 = (struct file_operations *)(& tx_tx_exch_expiry_ops);

#line 175  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_tx_start_data_ops_2 = (struct file_operations *)(& tx_tx_start_data_ops);

#line 176  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_debug_debug5_ops_2 = (struct file_operations *)(& debug_debug5_ops);

#line 177  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_frag_key_not_found_ops_2 = (struct file_operations *)(& tx_frag_key_not_found_ops);

#line 178  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_tx_frag_mpdu_alloc_failed_ops_2 = (struct file_operations *)(& tx_frag_mpdu_alloc_failed_ops);

#line 179  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
struct file_operations *ldv_emg_alias_clear_fw_stats_ops_2 = (struct file_operations *)(& clear_fw_stats_ops);

#line 185 
struct dentry *ldv_emg_debugfs_create_file(char *arg0, unsigned short arg1, struct dentry *arg2, void *arg3, struct file_operations *arg4);


#line 189  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_rx_out_of_mpdu_nodes_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 190 
  tmp = rx_rx_out_of_mpdu_nodes_read(arg0,arg1,arg2,arg3);
  
#line 190 
  return tmp;
}


#line 194  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_error_error_frame_cts_nul_flid_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 195 
  tmp = error_error_frame_cts_nul_flid_read(arg0,arg1,arg2,arg3);
  
#line 195 
  return tmp;
}


#line 199  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_clear_fw_stats_write_4(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 200 
  tmp = clear_fw_stats_write(arg0,(char const *)arg1,arg2,arg3);
  
#line 200 
  return tmp;
}


#line 204  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_ps_poll_upsd_max_ap_turn_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 205 
  tmp = ps_poll_upsd_max_ap_turn_read(arg0,arg1,arg2,arg3);
  
#line 205 
  return tmp;
}


#line 209  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_defrag_called_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 210 
  tmp = rx_defrag_called_read(arg0,arg1,arg2,arg3);
  
#line 210 
  return tmp;
}


#line 214  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pwr_rcvd_bcns_cnt_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 215 
  tmp = pwr_rcvd_bcns_cnt_read(arg0,arg1,arg2,arg3);
  
#line 215 
  return tmp;
}


#line 219  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pipeline_dec_packet_in_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 220 
  tmp = pipeline_dec_packet_in_read(arg0,arg1,arg2,arg3);
  
#line 220 
  return tmp;
}


#line 224  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_ps_poll_ps_poll_utilization_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 225 
  tmp = ps_poll_ps_poll_utilization_read(arg0,arg1,arg2,arg3);
  
#line 225 
  return tmp;
}


#line 229  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_rx_pre_complt_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 230 
  tmp = rx_rx_pre_complt_read(arg0,arg1,arg2,arg3);
  
#line 230 
  return tmp;
}


#line 234  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_debug_debug6_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 235 
  tmp = debug_debug6_read(arg0,arg1,arg2,arg3);
  
#line 235 
  return tmp;
}


#line 239  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_filter_accum_arp_pend_requests_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 240 
  tmp = rx_filter_accum_arp_pend_requests_read(arg0,arg1,arg2,arg3);
  
#line 240 
  return tmp;
}


#line 244  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pipeline_hs_tx_stat_fifo_int_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 245 
  tmp = pipeline_hs_tx_stat_fifo_int_read(arg0,arg1,arg2,arg3);
  
#line 245 
  return tmp;
}


#line 249  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_rate_rx_frames_per_rates_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 250 
  tmp = rx_rate_rx_frames_per_rates_read(arg0,arg1,arg2,arg3);
  
#line 250 
  return tmp;
}


#line 254  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_tx_data_programmed_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 255 
  tmp = tx_tx_data_programmed_read(arg0,arg1,arg2,arg3);
  
#line 255 
  return tmp;
}


#line 259  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_mem_tx_free_mem_blks_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 260 
  tmp = mem_tx_free_mem_blks_read(arg0,arg1,arg2,arg3);
  
#line 260 
  return tmp;
}


#line 264  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_ps_poll_ps_poll_timeouts_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 265 
  tmp = ps_poll_ps_poll_timeouts_read(arg0,arg1,arg2,arg3);
  
#line 265 
  return tmp;
}


#line 269  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_defrag_tkip_called_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 270 
  tmp = rx_defrag_tkip_called_read(arg0,arg1,arg2,arg3);
  
#line 270 
  return tmp;
}


#line 274  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pipeline_csum_to_rx_xfer_swi_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 275 
  tmp = pipeline_csum_to_rx_xfer_swi_read(arg0,arg1,arg2,arg3);
  
#line 275 
  return tmp;
}


#line 279  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pipeline_enc_tx_stat_fifo_int_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 280 
  tmp = pipeline_enc_tx_stat_fifo_int_read(arg0,arg1,arg2,arg3);
  
#line 280 
  return tmp;
}


#line 284  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_frag_bad_mblk_num_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 285 
  tmp = tx_frag_bad_mblk_num_read(arg0,arg1,arg2,arg3);
  
#line 285 
  return tmp;
}


#line 289  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_decrypt_key_not_found_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 290 
  tmp = rx_decrypt_key_not_found_read(arg0,arg1,arg2,arg3);
  
#line 290 
  return tmp;
}


#line 294  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_tx_exch_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 295 
  tmp = tx_tx_exch_read(arg0,arg1,arg2,arg3);
  
#line 295 
  return tmp;
}


#line 299  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_defrag_need_defrag_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 300 
  tmp = rx_defrag_need_defrag_read(arg0,arg1,arg2,arg3);
  
#line 300 
  return tmp;
}


#line 304  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_frag_cache_miss_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 305 
  tmp = tx_frag_cache_miss_read(arg0,arg1,arg2,arg3);
  
#line 305 
  return tmp;
}


#line 309  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_aggr_size_tx_agg_vs_rate_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 310 
  tmp = aggr_size_tx_agg_vs_rate_read(arg0,arg1,arg2,arg3);
  
#line 310 
  return tmp;
}


#line 314  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_rx_hdr_overflow_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 315 
  tmp = rx_rx_hdr_overflow_read(arg0,arg1,arg2,arg3);
  
#line 315 
  return tmp;
}


#line 319  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_tx_retry_template_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 320 
  tmp = tx_tx_retry_template_read(arg0,arg1,arg2,arg3);
  
#line 320 
  return tmp;
}


#line 324  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_tx_done_int_template_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 325 
  tmp = tx_tx_done_int_template_read(arg0,arg1,arg2,arg3);
  
#line 325 
  return tmp;
}


#line 329  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_debug_debug3_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 330 
  tmp = debug_debug3_read(arg0,arg1,arg2,arg3);
  
#line 330 
  return tmp;
}


#line 334  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_rx_tkip_replays_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 335 
  tmp = rx_rx_tkip_replays_read(arg0,arg1,arg2,arg3);
  
#line 335 
  return tmp;
}


#line 339  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pwr_missing_bcns_cnt_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 340 
  tmp = pwr_missing_bcns_cnt_read(arg0,arg1,arg2,arg3);
  
#line 340 
  return tmp;
}


#line 344  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_ps_poll_upsd_utilization_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 345 
  tmp = ps_poll_upsd_utilization_read(arg0,arg1,arg2,arg3);
  
#line 345 
  return tmp;
}


#line 349  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_frag_mpdu_alloc_failed_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 350 
  tmp = tx_frag_mpdu_alloc_failed_read(arg0,arg1,arg2,arg3);
  
#line 350 
  return tmp;
}


#line 354  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_frag_called_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 355 
  tmp = tx_frag_called_read(arg0,arg1,arg2,arg3);
  
#line 355 
  return tmp;
}


#line 359  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_conf_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 360 
  tmp = conf_read(arg0,arg1,arg2,arg3);
  
#line 360 
  return tmp;
}


#line 364  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_debug_debug2_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 365 
  tmp = debug_debug2_read(arg0,arg1,arg2,arg3);
  
#line 365 
  return tmp;
}


#line 369  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_debug_debug4_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 370 
  tmp = debug_debug4_read(arg0,arg1,arg2,arg3);
  
#line 370 
  return tmp;
}


#line 374  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_tx_burst_programmed_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 375 
  tmp = tx_tx_burst_programmed_read(arg0,arg1,arg2,arg3);
  
#line 375 
  return tmp;
}


#line 379  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_defrag_need_decrypt_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 380 
  tmp = rx_defrag_need_decrypt_read(arg0,arg1,arg2,arg3);
  
#line 380 
  return tmp;
}


#line 384  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_error_error_null_Frame_tx_start_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 385 
  tmp = error_error_null_Frame_tx_start_read(arg0,arg1,arg2,arg3);
  
#line 385 
  return tmp;
}


#line 389  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_rx_wa_ba_not_expected_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 390 
  tmp = rx_rx_wa_ba_not_expected_read(arg0,arg1,arg2,arg3);
  
#line 390 
  return tmp;
}


#line 394  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_rx_timeout_wa_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 395 
  tmp = rx_rx_timeout_wa_read(arg0,arg1,arg2,arg3);
  
#line 395 
  return tmp;
}


#line 399  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_filter_beacon_filter_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 400 
  tmp = rx_filter_beacon_filter_read(arg0,arg1,arg2,arg3);
  
#line 400 
  return tmp;
}


#line 404  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_defrag_in_process_called_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 405 
  tmp = rx_defrag_in_process_called_read(arg0,arg1,arg2,arg3);
  
#line 405 
  return tmp;
}


#line 409  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_error_error_bar_retry_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 410 
  tmp = error_error_bar_retry_read(arg0,arg1,arg2,arg3);
  
#line 410 
  return tmp;
}


#line 414  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_filter_arp_filter_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 415 
  tmp = rx_filter_arp_filter_read(arg0,arg1,arg2,arg3);
  
#line 415 
  return tmp;
}


#line 419  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_tx_exch_pending_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 420 
  tmp = tx_tx_exch_pending_read(arg0,arg1,arg2,arg3);
  
#line 420 
  return tmp;
}


#line 424  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pipeline_pipeline_fifo_full_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 425 
  tmp = pipeline_pipeline_fifo_full_read(arg0,arg1,arg2,arg3);
  
#line 425 
  return tmp;
}


#line 429  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_error_error_numll_frame_cts_start_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 430 
  tmp = error_error_numll_frame_cts_start_read(arg0,arg1,arg2,arg3);
  
#line 430 
  return tmp;
}


#line 434  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_rx_cmplt_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 435 
  tmp = rx_rx_cmplt_read(arg0,arg1,arg2,arg3);
  
#line 435 
  return tmp;
}


#line 439  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_mem_rx_free_mem_blks_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 440 
  tmp = mem_rx_free_mem_blks_read(arg0,arg1,arg2,arg3);
  
#line 440 
  return tmp;
}


#line 444  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_frag_key_not_found_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 445 
  tmp = tx_frag_key_not_found_read(arg0,arg1,arg2,arg3);
  
#line 445 
  return tmp;
}


#line 449  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_rx_cmplt_task_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 450 
  tmp = rx_rx_cmplt_task_read(arg0,arg1,arg2,arg3);
  
#line 450 
  return tmp;
}


#line 454  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pipeline_defrag_to_csum_swi_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 455 
  tmp = pipeline_defrag_to_csum_swi_read(arg0,arg1,arg2,arg3);
  
#line 455 
  return tmp;
}


#line 459  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_rx_beacon_early_term_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 460 
  tmp = rx_rx_beacon_early_term_read(arg0,arg1,arg2,arg3);
  
#line 460 
  return tmp;
}


#line 464  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_radar_detection_write_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 465 
  tmp = radar_detection_write(arg0,(char const *)arg1,arg2,arg3);
  
#line 465 
  return tmp;
}


#line 469  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_tx_done_template_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 470 
  tmp = tx_tx_done_template_read(arg0,arg1,arg2,arg3);
  
#line 470 
  return tmp;
}


#line 474  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_tx_template_programmed_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 475 
  tmp = tx_tx_template_programmed_read(arg0,arg1,arg2,arg3);
  
#line 475 
  return tmp;
}


#line 479  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_rx_checksum_result_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 480 
  tmp = rx_rx_checksum_result_read(arg0,arg1,arg2,arg3);
  
#line 480 
  return tmp;
}


#line 484  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pipeline_tcp_rx_stat_fifo_int_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 485 
  tmp = pipeline_tcp_rx_stat_fifo_int_read(arg0,arg1,arg2,arg3);
  
#line 485 
  return tmp;
}


#line 489  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pipeline_dec_packet_out_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 490 
  tmp = pipeline_dec_packet_out_read(arg0,arg1,arg2,arg3);
  
#line 490 
  return tmp;
}


#line 494  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_tx_imm_resp_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 495 
  tmp = tx_tx_imm_resp_read(arg0,arg1,arg2,arg3);
  
#line 495 
  return tmp;
}


#line 499  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_isr_irqs_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 500 
  tmp = isr_irqs_read(arg0,arg1,arg2,arg3);
  
#line 500 
  return tmp;
}


#line 504  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pipeline_pre_proc_swi_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 505 
  tmp = pipeline_pre_proc_swi_read(arg0,arg1,arg2,arg3);
  
#line 505 
  return tmp;
}


#line 509  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pipeline_cs_rx_packet_out_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 510 
  tmp = pipeline_cs_rx_packet_out_read(arg0,arg1,arg2,arg3);
  
#line 510 
  return tmp;
}


#line 514  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_rx_frame_checksum_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 515 
  tmp = rx_rx_frame_checksum_read(arg0,arg1,arg2,arg3);
  
#line 515 
  return tmp;
}


#line 519  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_rx_wa_density_dropped_frame_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 520 
  tmp = rx_rx_wa_density_dropped_frame_read(arg0,arg1,arg2,arg3);
  
#line 520 
  return tmp;
}


#line 524  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_mem_fw_gen_free_mem_blks_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 525 
  tmp = mem_fw_gen_free_mem_blks_read(arg0,arg1,arg2,arg3);
  
#line 525 
  return tmp;
}


#line 529  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_rx_done_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 530 
  tmp = rx_rx_done_read(arg0,arg1,arg2,arg3);
  
#line 530 
  return tmp;
}


#line 534  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_rx_defrag_end_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 535 
  tmp = rx_rx_defrag_end_read(arg0,arg1,arg2,arg3);
  
#line 535 
  return tmp;
}


#line 539  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_defrag_decrypt_failed_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 540 
  tmp = rx_defrag_decrypt_failed_read(arg0,arg1,arg2,arg3);
  
#line 540 
  return tmp;
}


#line 544  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_debug_debug5_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 545 
  tmp = debug_debug5_read(arg0,arg1,arg2,arg3);
  
#line 545 
  return tmp;
}


#line 549  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_filter_dup_filter_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 550 
  tmp = rx_filter_dup_filter_read(arg0,arg1,arg2,arg3);
  
#line 550 
  return tmp;
}


#line 554  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_frag_tkip_called_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 555 
  tmp = tx_frag_tkip_called_read(arg0,arg1,arg2,arg3);
  
#line 555 
  return tmp;
}


#line 559  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_tx_starts_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 560 
  tmp = tx_tx_starts_read(arg0,arg1,arg2,arg3);
  
#line 560 
  return tmp;
}


#line 564  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_filter_mc_filter_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 565 
  tmp = rx_filter_mc_filter_read(arg0,arg1,arg2,arg3);
  
#line 565 
  return tmp;
}


#line 569  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_ps_poll_upsd_timeouts_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 570 
  tmp = ps_poll_upsd_timeouts_read(arg0,arg1,arg2,arg3);
  
#line 570 
  return tmp;
}


#line 574  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_tx_checksum_result_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 575 
  tmp = tx_tx_checksum_result_read(arg0,arg1,arg2,arg3);
  
#line 575 
  return tmp;
}


#line 579  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pwr_connection_out_of_sync_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 580 
  tmp = pwr_connection_out_of_sync_read(arg0,arg1,arg2,arg3);
  
#line 580 
  return tmp;
}


#line 584  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_tx_prepared_descs_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 585 
  tmp = tx_tx_prepared_descs_read(arg0,arg1,arg2,arg3);
  
#line 585 
  return tmp;
}


#line 589  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pipeline_rx_complete_stat_fifo_int_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 590 
  tmp = pipeline_rx_complete_stat_fifo_int_read(arg0,arg1,arg2,arg3);
  
#line 590 
  return tmp;
}


#line 594  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_tx_template_prepared_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 595 
  tmp = tx_tx_template_prepared_read(arg0,arg1,arg2,arg3);
  
#line 595 
  return tmp;
}


#line 599  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_tx_done_data_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 600 
  tmp = tx_tx_done_data_read(arg0,arg1,arg2,arg3);
  
#line 600 
  return tmp;
}


#line 604  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_tx_start_data_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 605 
  tmp = tx_tx_start_data_read(arg0,arg1,arg2,arg3);
  
#line 605 
  return tmp;
}


#line 609  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_frag_init_called_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 610 
  tmp = tx_frag_init_called_read(arg0,arg1,arg2,arg3);
  
#line 610 
  return tmp;
}


#line 614  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pipeline_enc_rx_stat_fifo_int_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 615 
  tmp = pipeline_enc_rx_stat_fifo_int_read(arg0,arg1,arg2,arg3);
  
#line 615 
  return tmp;
}


#line 619  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_frag_cache_hit_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 620 
  tmp = tx_frag_cache_hit_read(arg0,arg1,arg2,arg3);
  
#line 620 
  return tmp;
}


#line 624  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_frag_in_process_called_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 625 
  tmp = tx_frag_in_process_called_read(arg0,arg1,arg2,arg3);
  
#line 625 
  return tmp;
}


#line 629  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_frag_failed_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 630 
  tmp = tx_frag_failed_read(arg0,arg1,arg2,arg3);
  
#line 630 
  return tmp;
}


#line 634  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_tx_start_null_frame_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 635 
  tmp = tx_tx_start_null_frame_read(arg0,arg1,arg2,arg3);
  
#line 635 
  return tmp;
}


#line 639  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_tx_start_fw_gen_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 640 
  tmp = tx_tx_start_fw_gen_read(arg0,arg1,arg2,arg3);
  
#line 640 
  return tmp;
}


#line 644  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pipeline_pre_to_defrag_swi_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 645 
  tmp = pipeline_pre_to_defrag_swi_read(arg0,arg1,arg2,arg3);
  
#line 645 
  return tmp;
}


#line 649  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pwr_cont_miss_bcns_spread_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 650 
  tmp = pwr_cont_miss_bcns_spread_read(arg0,arg1,arg2,arg3);
  
#line 650 
  return tmp;
}


#line 654  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pipeline_dec_packet_in_fifo_full_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 655 
  tmp = pipeline_dec_packet_in_fifo_full_read(arg0,arg1,arg2,arg3);
  
#line 655 
  return tmp;
}


#line 659  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_frag_need_fragmentation_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 660 
  tmp = tx_frag_need_fragmentation_read(arg0,arg1,arg2,arg3);
  
#line 660 
  return tmp;
}


#line 664  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_tx_cmplt_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 665 
  tmp = tx_tx_cmplt_read(arg0,arg1,arg2,arg3);
  
#line 665 
  return tmp;
}


#line 669  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_tx_start_templates_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 670 
  tmp = tx_tx_start_templates_read(arg0,arg1,arg2,arg3);
  
#line 670 
  return tmp;
}


#line 674  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_tx_start_int_templates_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 675 
  tmp = tx_tx_start_int_templates_read(arg0,arg1,arg2,arg3);
  
#line 675 
  return tmp;
}


#line 679  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_filter_protection_filter_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 680 
  tmp = rx_filter_protection_filter_read(arg0,arg1,arg2,arg3);
  
#line 680 
  return tmp;
}


#line 684  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_tx_data_prepared_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 685 
  tmp = tx_tx_data_prepared_read(arg0,arg1,arg2,arg3);
  
#line 685 
  return tmp;
}


#line 689  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pipeline_post_proc_swi_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 690 
  tmp = pipeline_post_proc_swi_read(arg0,arg1,arg2,arg3);
  
#line 690 
  return tmp;
}


#line 694  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_aggr_size_rx_size_read_4(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 695 
  tmp = aggr_size_rx_size_read(arg0,arg1,arg2,arg3);
  
#line 695 
  return tmp;
}


#line 699  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pipeline_sec_frag_swi_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 700 
  tmp = pipeline_sec_frag_swi_read(arg0,arg1,arg2,arg3);
  
#line 700 
  return tmp;
}


#line 704  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pipeline_cs_rx_packet_in_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 705 
  tmp = pipeline_cs_rx_packet_in_read(arg0,arg1,arg2,arg3);
  
#line 705 
  return tmp;
}


#line 709  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_ps_poll_ps_poll_max_ap_turn_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 710 
  tmp = ps_poll_ps_poll_max_ap_turn_read(arg0,arg1,arg2,arg3);
  
#line 710 
  return tmp;
}


#line 714  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_rx_timeout_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 715 
  tmp = rx_rx_timeout_read(arg0,arg1,arg2,arg3);
  
#line 715 
  return tmp;
}


#line 719  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_rx_phy_hdr_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 720 
  tmp = rx_rx_phy_hdr_read(arg0,arg1,arg2,arg3);
  
#line 720 
  return tmp;
}


#line 724  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pipeline_tcp_tx_stat_fifo_int_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 725 
  tmp = pipeline_tcp_tx_stat_fifo_int_read(arg0,arg1,arg2,arg3);
  
#line 725 
  return tmp;
}


#line 729  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_defrag_init_called_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 730 
  tmp = rx_defrag_init_called_read(arg0,arg1,arg2,arg3);
  
#line 730 
  return tmp;
}


#line 734  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_pwr_rcvd_awake_bcns_cnt_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 735 
  tmp = pwr_rcvd_awake_bcns_cnt_read(arg0,arg1,arg2,arg3);
  
#line 735 
  return tmp;
}


#line 739  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_tx_frame_checksum_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 740 
  tmp = tx_tx_frame_checksum_read(arg0,arg1,arg2,arg3);
  
#line 740 
  return tmp;
}


#line 744  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_filter_ibss_filter_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 745 
  tmp = rx_filter_ibss_filter_read(arg0,arg1,arg2,arg3);
  
#line 745 
  return tmp;
}


#line 749  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_filter_data_filter_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 750 
  tmp = rx_filter_data_filter_read(arg0,arg1,arg2,arg3);
  
#line 750 
  return tmp;
}


#line 754  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_filter_max_arp_queue_dep_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 755 
  tmp = rx_filter_max_arp_queue_dep_read(arg0,arg1,arg2,arg3);
  
#line 755 
  return tmp;
}


#line 759  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_rx_dropped_frame_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 760 
  tmp = rx_rx_dropped_frame_read(arg0,arg1,arg2,arg3);
  
#line 760 
  return tmp;
}


#line 764  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_mem_fwlog_free_mem_blks_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 765 
  tmp = mem_fwlog_free_mem_blks_read(arg0,arg1,arg2,arg3);
  
#line 765 
  return tmp;
}


#line 769  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_debug_debug1_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 770 
  tmp = debug_debug1_read(arg0,arg1,arg2,arg3);
  
#line 770 
  return tmp;
}


#line 774  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_rx_rx_defrag_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 775 
  tmp = rx_rx_defrag_read(arg0,arg1,arg2,arg3);
  
#line 775 
  return tmp;
}


#line 779  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_tx_retry_data_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 780 
  tmp = tx_tx_retry_data_read(arg0,arg1,arg2,arg3);
  
#line 780 
  return tmp;
}


#line 784  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_tx_tx_exch_expiry_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 785 
  tmp = tx_tx_exch_expiry_read(arg0,arg1,arg2,arg3);
  
#line 785 
  return tmp;
}


#line 789  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
long ldv_emg_wrapper_error_error_frame_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 790 
  tmp = error_error_frame_read(arg0,arg1,arg2,arg3);
  
#line 790 
  return tmp;
}


#line 802  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static long PTR_ERR_0(void const *ptr)
{
  long tmp;
  
#line 805 
  tmp = ldv_ptr_err(ptr);
  
#line 805 
  return tmp;
}


#line 809  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static bool IS_ERR_0(void const *ptr)
{
  bool __retres;
  long ret;
  
#line 813 
  ret = ldv_is_err(ptr);
  
#line 814 
  __retres = (_Bool)(ret != 0L);
  
#line 814 
  return __retres;
}


#line 1206  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static void *kmalloc(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 1209 
  tmp = ldv_kmalloc(size,flags);
  
#line 1209 
  return tmp;
}


#line 1473  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static void ldv_mutex_lock_73(struct mutex *ldv_func_arg1)
{
  
#line 1477 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_wl1271");
  
#line 1478 
  return;
}


#line 1481  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static void ldv_mutex_unlock_74(struct mutex *ldv_func_arg1)
{
  
#line 1485 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_wl1271");
  
#line 1486 
  return;
}


#line 1489  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static void ldv_mutex_lock_75(struct mutex *ldv_func_arg1)
{
  
#line 1493 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_wl1271");
  
#line 1494 
  return;
}


#line 1497  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static void ldv_mutex_unlock_76(struct mutex *ldv_func_arg1)
{
  
#line 1501 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_wl1271");
  
#line 1502 
  return;
}


#line 1505  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static void ldv_mutex_lock_77(struct mutex *ldv_func_arg1)
{
  
#line 1509 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"mutex_of_wl1271");
  
#line 1510 
  return;
}


#line 1513  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static void ldv_mutex_unlock_78(struct mutex *ldv_func_arg1)
{
  
#line 1517 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"mutex_of_wl1271");
  
#line 1518 
  return;
}


#line 1521  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_79(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1525 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1525 
  return tmp;
}


#line 1529  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_80(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1533 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1533 
  return tmp;
}


#line 1537  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_81(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1541 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1541 
  return tmp;
}


#line 1545  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_82(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1549 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1549 
  return tmp;
}


#line 1553  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_83(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1557 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1557 
  return tmp;
}


#line 1561  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_84(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1565 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1565 
  return tmp;
}


#line 1569  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_85(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1573 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1573 
  return tmp;
}


#line 1577  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_86(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1581 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1581 
  return tmp;
}


#line 1585  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_87(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1589 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1589 
  return tmp;
}


#line 1593  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_88(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1597 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1597 
  return tmp;
}


#line 1601  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_89(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1605 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1605 
  return tmp;
}


#line 1609  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_90(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1613 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1613 
  return tmp;
}


#line 1617  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_91(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1621 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1621 
  return tmp;
}


#line 1625  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_92(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1629 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1629 
  return tmp;
}


#line 1633  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_93(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1637 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1637 
  return tmp;
}


#line 1641  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_94(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1645 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1645 
  return tmp;
}


#line 1649  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_95(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1653 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1653 
  return tmp;
}


#line 1657  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_96(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1661 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1661 
  return tmp;
}


#line 1665  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_97(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1669 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1669 
  return tmp;
}


#line 1673  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_98(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1677 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1677 
  return tmp;
}


#line 1681  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_99(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1685 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1685 
  return tmp;
}


#line 1689  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_100(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1693 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1693 
  return tmp;
}


#line 1697  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_101(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1701 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1701 
  return tmp;
}


#line 1705  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_102(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1709 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1709 
  return tmp;
}


#line 1713  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_103(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1717 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1717 
  return tmp;
}


#line 1721  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_104(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1725 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1725 
  return tmp;
}


#line 1729  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_105(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1733 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1733 
  return tmp;
}


#line 1737  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_106(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1741 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1741 
  return tmp;
}


#line 1745  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_107(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1749 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1749 
  return tmp;
}


#line 1753  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_108(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1757 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1757 
  return tmp;
}


#line 1761  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_109(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1765 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1765 
  return tmp;
}


#line 1769  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_110(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1773 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1773 
  return tmp;
}


#line 1777  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_111(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1781 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1781 
  return tmp;
}


#line 1785  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_112(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1789 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1789 
  return tmp;
}


#line 1793  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_113(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1797 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1797 
  return tmp;
}


#line 1801  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_114(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1805 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1805 
  return tmp;
}


#line 1809  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_115(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1813 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1813 
  return tmp;
}


#line 1817  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_116(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1821 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1821 
  return tmp;
}


#line 1825  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_117(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1829 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1829 
  return tmp;
}


#line 1833  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_118(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1837 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1837 
  return tmp;
}


#line 1841  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_119(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1845 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1845 
  return tmp;
}


#line 1849  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_120(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1853 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1853 
  return tmp;
}


#line 1857  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_121(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1861 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1861 
  return tmp;
}


#line 1865  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_122(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1869 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1869 
  return tmp;
}


#line 1873  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_123(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1877 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1877 
  return tmp;
}


#line 1881  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_124(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1885 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1885 
  return tmp;
}


#line 1889  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_125(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1893 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1893 
  return tmp;
}


#line 1897  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_126(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1901 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1901 
  return tmp;
}


#line 1905  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_127(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1909 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1909 
  return tmp;
}


#line 1913  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_128(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1917 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1917 
  return tmp;
}


#line 1921  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_129(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1925 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1925 
  return tmp;
}


#line 1929  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_130(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1933 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1933 
  return tmp;
}


#line 1937  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_131(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1941 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1941 
  return tmp;
}


#line 1945  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_132(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1949 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1949 
  return tmp;
}


#line 1953  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_133(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1957 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1957 
  return tmp;
}


#line 1961  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_134(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1965 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1965 
  return tmp;
}


#line 1969  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_135(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1973 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1973 
  return tmp;
}


#line 1977  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_136(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1981 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1981 
  return tmp;
}


#line 1985  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_137(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1989 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1989 
  return tmp;
}


#line 1993  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_138(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1997 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1997 
  return tmp;
}


#line 2001  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_139(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2005 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2005 
  return tmp;
}


#line 2009  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_140(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2013 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2013 
  return tmp;
}


#line 2017  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_141(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2021 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2021 
  return tmp;
}


#line 2025  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_142(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2029 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2029 
  return tmp;
}


#line 2033  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_143(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2037 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2037 
  return tmp;
}


#line 2041  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_144(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2045 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2045 
  return tmp;
}


#line 2049  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_145(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2053 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2053 
  return tmp;
}


#line 2057  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_146(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2061 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2061 
  return tmp;
}


#line 2065  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_147(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2069 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2069 
  return tmp;
}


#line 2073  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_148(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2077 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2077 
  return tmp;
}


#line 2081  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_149(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2085 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2085 
  return tmp;
}


#line 2089  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_150(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2093 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2093 
  return tmp;
}


#line 2097  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_151(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2101 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2101 
  return tmp;
}


#line 2105  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_152(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2109 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2109 
  return tmp;
}


#line 2113  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_153(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2117 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2117 
  return tmp;
}


#line 2121  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_154(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2125 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2125 
  return tmp;
}


#line 2129  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_155(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2133 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2133 
  return tmp;
}


#line 2137  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_156(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2141 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2141 
  return tmp;
}


#line 2145  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_157(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2149 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2149 
  return tmp;
}


#line 2153  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_158(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2157 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2157 
  return tmp;
}


#line 2161  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_159(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2165 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2165 
  return tmp;
}


#line 2169  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_160(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2173 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2173 
  return tmp;
}


#line 2177  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_161(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2181 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2181 
  return tmp;
}


#line 2185  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_162(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2189 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2189 
  return tmp;
}


#line 2193  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_163(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2197 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2197 
  return tmp;
}


#line 2201  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_164(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2205 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2205 
  return tmp;
}


#line 2209  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_165(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2213 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2213 
  return tmp;
}


#line 2217  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_166(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2221 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2221 
  return tmp;
}


#line 2225  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_167(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2229 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2229 
  return tmp;
}


#line 2233  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_168(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2237 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2237 
  return tmp;
}


#line 2241  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_169(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2245 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2245 
  return tmp;
}


#line 2249  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_170(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2253 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2253 
  return tmp;
}


#line 2257  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_171(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2261 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2261 
  return tmp;
}


#line 2265  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_172(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2269 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2269 
  return tmp;
}


#line 2273  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_173(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2277 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2277 
  return tmp;
}


#line 2281  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_174(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2285 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2285 
  return tmp;
}


#line 2289  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_175(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2293 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2293 
  return tmp;
}


#line 2297  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_176(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2301 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2301 
  return tmp;
}


#line 2305  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_177(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2309 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2309 
  return tmp;
}


#line 2313  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_178(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2317 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2317 
  return tmp;
}


#line 2321  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_179(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2325 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2325 
  return tmp;
}


#line 2329  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_180(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2333 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2333 
  return tmp;
}


#line 2337  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_181(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2341 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2341 
  return tmp;
}


#line 2345  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_182(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2349 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2349 
  return tmp;
}


#line 2353  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_183(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2357 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2357 
  return tmp;
}


#line 2361  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_184(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2365 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2365 
  return tmp;
}


#line 2369  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_185(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2373 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2373 
  return tmp;
}


#line 2377  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_186(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2381 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2381 
  return tmp;
}


#line 2385  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_187(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2389 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2389 
  return tmp;
}


#line 2393  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_188(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2397 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2397 
  return tmp;
}


#line 2401  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_189(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2405 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2405 
  return tmp;
}


#line 2409  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_190(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2413 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2413 
  return tmp;
}


#line 2417  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_191(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2421 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2421 
  return tmp;
}


#line 2425  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_192(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2429 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2429 
  return tmp;
}


#line 2433  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_193(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2437 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2437 
  return tmp;
}


#line 2441  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_194(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2445 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2445 
  return tmp;
}


#line 2449  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_195(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2453 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2453 
  return tmp;
}


#line 2457  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_196(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2461 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2461 
  return tmp;
}


#line 2465  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_197(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2469 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2469 
  return tmp;
}


#line 2473  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_198(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2477 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2477 
  return tmp;
}


#line 2481  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/weaver/.tmp_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_199(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 2485 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 2485 
  return tmp;
}


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_add(int i, atomic_t *v)
{
  
#line 23 
  v->counter += i;
  
#line 24 
  return;
}


#line 27  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_sub(int i, atomic_t *v)
{
  
#line 29 
  v->counter -= i;
  
#line 30 
  return;
}


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_sub_and_test(int i, atomic_t *v)
{
  int __retres;
  
#line 35 
  v->counter -= i;
  
#line 36 
  if (v->counter != 0) {
    
#line 37 
    __retres = 0;
    
#line 37 
    goto return_label;
  }
  else ;
  
#line 39 
  __retres = 1;
  return_label: 
#line 39 
                return __retres;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_inc(atomic_t *v)
{
  
#line 45 
  v->counter += 1;
  
#line 46 
  return;
}


#line 49  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_dec(atomic_t *v)
{
  
#line 51 
  v->counter -= 1;
  
#line 52 
  return;
}


#line 55  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_dec_and_test(atomic_t *v)
{
  int __retres;
  
#line 57 
  v->counter -= 1;
  
#line 58 
  if (v->counter != 0) {
    
#line 59 
    __retres = 0;
    
#line 59 
    goto return_label;
  }
  else ;
  
#line 61 
  __retres = 1;
  return_label: 
#line 61 
                return __retres;
}


#line 65  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_inc_and_test(atomic_t *v)
{
  int __retres;
  
#line 67 
  v->counter += 1;
  
#line 68 
  if (v->counter != 0) {
    
#line 69 
    __retres = 0;
    
#line 69 
    goto return_label;
  }
  else ;
  
#line 71 
  __retres = 1;
  return_label: 
#line 71 
                return __retres;
}


#line 75  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_add_return(int i, atomic_t *v)
{
  int __retres;
  
#line 77 
  v->counter += i;
  
#line 78 
  __retres = v->counter;
  
#line 78 
  return __retres;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_add_negative(int i, atomic_t *v)
{
  int __retres;
  
#line 84 
  v->counter += i;
  
#line 85 
  __retres = v->counter < 0;
  
#line 85 
  return __retres;
}


#line 89  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_inc_short(short *v)
{
  int __retres;
  
#line 91 
  *v = (short)((unsigned int)*v + 1U);
  
#line 92 
  __retres = (int)*v;
  
#line 92 
  return __retres;
}


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/device.h"
void *ldv_dev_get_drvdata(struct device const *dev);


#line 24 
int ldv_dev_set_drvdata(struct device *dev, void *data);


#line 30  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_xmalloc(size_t size);


#line 31 
void *ldv_xzalloc(size_t size);


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
struct ldv_list_element global_list = {.data = (void *)0, .next = (struct ldv_list_element *)0};

#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
__inline static ldv_list_ptr ldv_list_create(void *data)
{
  
#line 35 
  ldv_list_ptr list = (struct ldv_list_element *)0;
  
#line 37 
  list = (ldv_list_ptr)ldv_xmalloc(16UL);
  
#line 39 
  list->data = data;
  
#line 40 
  list->next = (struct ldv_list_element *)0;
  
#line 42 
  return list;
}


#line 45  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
__inline static void ldv_save_pointer(void *data)
{
  ldv_list_ptr element;
  ldv_list_ptr cached;
  
#line 50 
  if (global_list.data == (void *)0) {
    
#line 51 
    element = & global_list;
    
#line 52 
    element->data = data;
  }
  else {
    
#line 54 
    element = ldv_list_create(data);
    
#line 55 
    cached = global_list.next;
    
#line 56 
    global_list.next = element;
    
#line 57 
    element->next = cached;
  }
  
#line 60 
  return;
}


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
void *ldv_dev_get_drvdata(struct device const *dev)
{
  void *__retres;
  
#line 30 
  if (dev != (struct device const *)0 && dev->p != (struct device_private *)0) {
    
#line 31 
    __retres = (dev->p)->driver_data;
    
#line 31 
    goto return_label;
  }
  else ;
  
#line 33 
  __retres = (void *)0;
  return_label: 
#line 33 
                return __retres;
}


#line 42  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
int ldv_dev_set_drvdata(struct device *dev, void *data)
{
  int __retres;
  
#line 44 
  dev->p = (struct device_private *)ldv_xzalloc(8UL);
  
#line 45 
  ldv_save_pointer((void *)dev->p);
  
#line 46 
  (dev->p)->driver_data = data;
  
#line 48 
  __retres = 0;
  
#line 48 
  return __retres;
}


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_zalloc(size_t size);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/spi.c"
struct spi_master *ldv_spi_alloc_master(struct device *host, unsigned int size)
{
  struct spi_master *__retres;
  struct spi_master *master;
  
#line 27 
  master = (struct spi_master *)ldv_zalloc((unsigned long)size + 2192UL);
  
#line 29 
  if (master == (struct spi_master *)0) {
    
#line 30 
    __retres = (struct spi_master *)0;
    
#line 30 
    goto return_label;
  }
  else ;
  
#line 32 
  ldv_dev_set_drvdata(& master->dev,(void *)(master + 1U));
  
#line 34 
  __retres = master;
  return_label: 
#line 34 
                return __retres;
}


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/err.h"
long ldv_is_err_or_null(void const *ptr);


#line 29 
void *ldv_err_ptr(long error);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/common.h"
void __VERIFIER_assume(int);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_is_err(void const *ptr)
{
  long __retres;
  
#line 23 
  __retres = (long)((unsigned long)ptr > 4294967295UL);
  
#line 23 
  return __retres;
}


#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
void *ldv_err_ptr(long error)
{
  void *__retres;
  
#line 28 
  __VERIFIER_assume(error < 0L);
  
#line 29 
  __retres = (void *)(4294967295L - error);
  
#line 29 
  return __retres;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_ptr_err(void const *ptr)
{
  long __retres;
  
#line 34 
  __VERIFIER_assume((unsigned long)ptr > 4294967295UL);
  
#line 35 
  __retres = (long)(4294967295UL - (unsigned long)ptr);
  
#line 35 
  return __retres;
}


#line 38  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_is_err_or_null(void const *ptr)
{
  long __retres;
  int tmp_0;
  
#line 40 
  if (ptr == (void const *)0) 
#line 40 
                              tmp_0 = 1;
  else {
    long tmp;
    
#line 40 
    tmp = ldv_is_err(ptr);
    
#line 40 
    if (tmp != 0L) 
#line 40 
                   tmp_0 = 1; else 
#line 40 
                                   tmp_0 = 0;
  }
  
#line 40 
  __retres = (long)tmp_0;
  
#line 40 
  return __retres;
}


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/panic.h"
void ldv_panic(void);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/kernel/panic.c"
void ldv_panic(void)
{
  
#line 23 
  __VERIFIER_assume(0);
  
#line 24 
  return;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.h"
void ldv_switch_to_interrupt_context(void);


#line 42 
void ldv_switch_to_process_context(void);


#line 50 
bool ldv_in_interrupt_context(void);


#line 112 
int ldv_post_init(int init_ret_val);


#line 132 
int ldv_post_probe(int probe_ret_val);


#line 133 
void ldv_check_return_value_probe(int);


#line 141 
int ldv_filter_err_code(int ret_val);


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
static bool __ldv_in_interrupt_context = (_Bool)0;

#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
void ldv_switch_to_interrupt_context(void)
{
  
#line 30 
  __ldv_in_interrupt_context = (_Bool)1;
  
#line 31 
  return;
}


#line 34  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
void ldv_switch_to_process_context(void)
{
  
#line 36 
  __ldv_in_interrupt_context = (_Bool)0;
  
#line 37 
  return;
}


#line 39  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
bool ldv_in_interrupt_context(void)
{
  
#line 41 
  return __ldv_in_interrupt_context;
}


#line 44  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
static int ldv_filter_positive_int(int val)
{
  
#line 46 
  __VERIFIER_assume(val <= 0);
  
#line 47 
  return val;
}


#line 54  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_post_init(int init_ret_val)
{
  int tmp;
  
#line 56 
  tmp = ldv_filter_positive_int(init_ret_val);
  
#line 56 
  return tmp;
}


#line 60  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_post_probe(int probe_ret_val)
{
  int tmp;
  
#line 62 
  ldv_check_return_value_probe(probe_ret_val);
  
#line 63 
  tmp = ldv_filter_positive_int(probe_ret_val);
  
#line 63 
  return tmp;
}


#line 67  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_filter_err_code(int ret_val)
{
  int tmp;
  
#line 69 
  tmp = ldv_filter_positive_int(ret_val);
  
#line 69 
  return tmp;
}


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kcalloc(size_t n, size_t size, gfp_t flags);


#line 26 
void *ldv_kmalloc_array(size_t n, size_t size, gfp_t flags);


#line 28 
void ldv_check_alloc_flags(gfp_t);


#line 29 
void ldv_after_alloc(void *);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_malloc(size_t size);


#line 24 
void *ldv_calloc(size_t nmemb, size_t size);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc(size_t size, gfp_t flags)
{
  void *res;
  
#line 25 
  ldv_check_alloc_flags(flags);
  
#line 26 
  res = ldv_malloc(size);
  
#line 27 
  ldv_after_alloc(res);
  
#line 29 
  return res;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kcalloc(size_t n, size_t size, gfp_t flags)
{
  void *res;
  
#line 36 
  ldv_check_alloc_flags(flags);
  
#line 37 
  res = ldv_calloc(n,size);
  
#line 38 
  ldv_after_alloc(res);
  
#line 40 
  return res;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kzalloc(size_t size, gfp_t flags)
{
  void *res;
  
#line 47 
  ldv_check_alloc_flags(flags);
  
#line 48 
  res = ldv_zalloc(size);
  
#line 49 
  ldv_after_alloc(res);
  
#line 51 
  return res;
}


#line 54  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc_array(size_t n, size_t size, gfp_t flags)
{
  void *res;
  
#line 58 
  ldv_check_alloc_flags(flags);
  
#line 59 
  res = ldv_malloc(n * size);
  
#line 60 
  ldv_after_alloc(res);
  
#line 62 
  return res;
}


#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void ldv_free(void *s);


#line 35 
void *ldv_malloc_unknown_size(void);


#line 36 
void *ldv_calloc_unknown_size(void);


#line 37 
void *ldv_zalloc_unknown_size(void);


#line 40 
void *ldv_reference_malloc(size_t size);


#line 41 
void *ldv_reference_calloc(size_t nmemb, size_t size);


#line 42 
void *ldv_reference_zalloc(size_t size);


#line 43 
void ldv_reference_free(void *s);


#line 47 
void *ldv_reference_xmalloc(size_t size);


#line 48 
void *ldv_reference_xzalloc(size_t size);


#line 52 
void *ldv_reference_malloc_unknown_size(void);


#line 53 
void *ldv_reference_calloc_unknown_size(void);


#line 54 
void *ldv_reference_zalloc_unknown_size(void);


#line 61 
void *ldv_xmalloc_unknown_size(size_t size);


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_reference_xmalloc_unknown_size(size_t size);


#line 34  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_malloc(size_t size)
{
  void *res;
  
#line 37 
  res = ldv_reference_malloc(size);
  
#line 38 
  if (res != (void *)0) {
    long tmp;
    
#line 39 
    tmp = ldv_is_err((void const *)res);
    
#line 39 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 40 
  return res;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc(size_t nmemb, size_t size)
{
  void *res;
  
#line 46 
  res = ldv_reference_calloc(nmemb,size);
  
#line 47 
  if (res != (void *)0) {
    long tmp;
    
#line 48 
    tmp = ldv_is_err((void const *)res);
    
#line 48 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 49 
  return res;
}


#line 52  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc(size_t size)
{
  void *res;
  
#line 55 
  res = ldv_reference_zalloc(size);
  
#line 56 
  if (res != (void *)0) {
    long tmp;
    
#line 57 
    tmp = ldv_is_err((void const *)res);
    
#line 57 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 58 
  return res;
}


#line 61  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void ldv_free(void *s)
{
  
#line 63 
  ldv_reference_free(s);
  
#line 64 
  return;
}


#line 66  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc(size_t size)
{
  void *res;
  long tmp;
  
#line 69 
  res = ldv_reference_xmalloc(size);
  
#line 70 
  tmp = ldv_is_err((void const *)res);
  
#line 70 
  __VERIFIER_assume(tmp == 0L);
  
#line 71 
  return res;
}


#line 74  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xzalloc(size_t size)
{
  void *res;
  long tmp;
  
#line 77 
  res = ldv_reference_xzalloc(size);
  
#line 78 
  tmp = ldv_is_err((void const *)res);
  
#line 78 
  __VERIFIER_assume(tmp == 0L);
  
#line 79 
  return res;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_malloc_unknown_size(void)
{
  void *res;
  
#line 85 
  res = ldv_reference_malloc_unknown_size();
  
#line 86 
  if (res != (void *)0) {
    long tmp;
    
#line 87 
    tmp = ldv_is_err((void const *)res);
    
#line 87 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 88 
  return res;
}


#line 91  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc_unknown_size(void)
{
  void *res;
  
#line 94 
  res = ldv_reference_calloc_unknown_size();
  
#line 95 
  if (res != (void *)0) {
    long tmp;
    
#line 96 
    tmp = ldv_is_err((void const *)res);
    
#line 96 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 97 
  return res;
}


#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc_unknown_size(void)
{
  void *res;
  
#line 103 
  res = ldv_reference_zalloc_unknown_size();
  
#line 104 
  if (res != (void *)0) {
    long tmp;
    
#line 105 
    tmp = ldv_is_err((void const *)res);
    
#line 105 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 106 
  return res;
}


#line 109  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc_unknown_size(size_t size)
{
  void *res;
  long tmp;
  
#line 112 
  res = ldv_reference_xmalloc_unknown_size(size);
  
#line 113 
  tmp = ldv_is_err((void const *)res);
  
#line 113 
  __VERIFIER_assume(tmp == 0L);
  
#line 114 
  return res;
}

long __builtin_expect(long exp, long c);


#line 22  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/common.h"
void __VERIFIER_error(void);


#line 24  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/gcc.c"
long __builtin_expect(long exp, long c)
{
  
#line 26 
  return exp;
}


#line 35  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/gcc.c"
void __builtin_trap(void)
{
  
#line 37 
  __VERIFIER_error();
  
#line 38 
  return;
}


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
int ldv_undef_int(void);


#line 24 
int ldv_undef_long(void);


#line 25 
unsigned int ldv_undef_uint(void);


#line 26 
unsigned long ldv_undef_ulong(void);


#line 27 
unsigned long long ldv_undef_ulonglong(void);


#line 28 
void *ldv_undef_ptr(void);


#line 31 
int ldv_undef_int_positive(void);


#line 34 
int ldv_undef_int_negative(void);


#line 37 
int ldv_undef_int_nonpositive(void);


#line 40 
void *ldv_undef_ptr_non_null(void);


#line 29  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int __VERIFIER_nondet_int(void);


#line 31 
long __VERIFIER_nondet_long(void);


#line 38 
unsigned int __VERIFIER_nondet_uint(void);


#line 41 
unsigned long __VERIFIER_nondet_ulong(void);


#line 42 
unsigned long long __VERIFIER_nondet_ulonglong(void);


#line 43 
void *__VERIFIER_nondet_pointer(void);


#line 46  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int(void)
{
  int tmp;
  
#line 48 
  tmp = __VERIFIER_nondet_int();
  
#line 48 
  return tmp;
}


#line 51  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_long(void)
{
  int __retres;
  long tmp;
  
#line 53 
  tmp = __VERIFIER_nondet_long();
  
#line 53 
  __retres = (int)tmp;
  
#line 53 
  return __retres;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned int ldv_undef_uint(void)
{
  unsigned int tmp;
  
#line 58 
  tmp = __VERIFIER_nondet_uint();
  
#line 58 
  return tmp;
}


#line 61  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr(void)
{
  void *tmp;
  
#line 63 
  tmp = __VERIFIER_nondet_pointer();
  
#line 63 
  return tmp;
}


#line 66  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long ldv_undef_ulong(void)
{
  unsigned long tmp;
  
#line 68 
  tmp = __VERIFIER_nondet_ulong();
  
#line 68 
  return tmp;
}


#line 71  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long long ldv_undef_ulonglong(void)
{
  unsigned long long tmp;
  
#line 73 
  tmp = __VERIFIER_nondet_ulonglong();
  
#line 73 
  return tmp;
}


#line 76  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_positive(void)
{
  
#line 78 
  int ret = ldv_undef_int();
  
#line 80 
  __VERIFIER_assume(ret > 0);
  
#line 82 
  return ret;
}


#line 85  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_negative(void)
{
  
#line 87 
  int ret = ldv_undef_int();
  
#line 89 
  __VERIFIER_assume(ret < 0);
  
#line 91 
  return ret;
}


#line 94  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_nonpositive(void)
{
  
#line 96 
  int ret = ldv_undef_int();
  
#line 98 
  __VERIFIER_assume(ret <= 0);
  
#line 100 
  return ret;
}


#line 103  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr_non_null(void)
{
  
#line 105 
  void *ret = ldv_undef_ptr();
  
#line 107 
  __VERIFIER_assume(ret != (void *)0);
  
#line 109 
  return ret;
}


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *external_allocated_data(void);


#line 45 
void *ldv_reference_realloc(void *ptr, size_t size);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *malloc(size_t);


#line 24 
void *calloc(size_t, size_t);


#line 25 
void free(void *);


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc(size_t size)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 37 
  tmp = ldv_undef_int();
  
#line 37 
  if (tmp != 0) {
    
#line 39 
    res = malloc(size);
    
#line 40 
    __VERIFIER_assume(res != (void *)0);
    
#line 41 
    __retres = res;
    
#line 41 
    goto return_label;
  }
  else {
    
#line 44 
    __retres = (void *)0;
    
#line 44 
    goto return_label;
  }
  return_label: 
#line 37 
                return __retres;
}


#line 47  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc(size_t nmemb, size_t size)
{
  void *tmp;
  
#line 49 
  tmp = calloc(nmemb,size);
  
#line 49 
  return tmp;
}


#line 52  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc(size_t size)
{
  void *tmp;
  
#line 54 
  tmp = calloc(1UL,size);
  
#line 54 
  return tmp;
}


#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void ldv_reference_free(void *s)
{
  
#line 59 
  free(s);
  
#line 60 
  return;
}


#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_realloc(void *ptr, size_t size)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 66 
  if (ptr != (void *)0 && size == 0UL) {
    
#line 67 
    free(ptr);
    
#line 68 
    __retres = (void *)0;
    
#line 68 
    goto return_label;
  }
  else ;
  
#line 71 
  if (ptr == (void *)0) {
    
#line 72 
    res = malloc(size);
    
#line 73 
    __retres = res;
    
#line 73 
    goto return_label;
  }
  else ;
  
#line 76 
  tmp = ldv_undef_int();
  
#line 76 
  if (tmp != 0) {
    
#line 78 
    res = malloc(size);
    
#line 79 
    __VERIFIER_assume(res != (void *)0);
    
#line 81 
    memcpy(res,(void const *)ptr,size);
    
#line 82 
    free(ptr);
    
#line 84 
    __retres = res;
    
#line 84 
    goto return_label;
  }
  else {
    
#line 87 
    __retres = (void *)0;
    
#line 87 
    goto return_label;
  }
  return_label: 
#line 76 
                return __retres;
}


#line 90  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc(size_t size)
{
  void *res;
  
#line 94 
  res = malloc(size);
  
#line 95 
  __VERIFIER_assume(res != (void *)0);
  
#line 97 
  return res;
}


#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xzalloc(size_t size)
{
  void *res;
  
#line 104 
  res = calloc(1UL,size);
  
#line 105 
  __VERIFIER_assume(res != (void *)0);
  
#line 107 
  return res;
}


#line 110  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc_unknown_size(void)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 114 
  tmp = ldv_undef_int();
  
#line 114 
  if (tmp != 0) {
    
#line 115 
    res = external_allocated_data();
    
#line 116 
    __VERIFIER_assume(res != (void *)0);
    
#line 117 
    __retres = res;
    
#line 117 
    goto return_label;
  }
  else {
    
#line 120 
    __retres = (void *)0;
    
#line 120 
    goto return_label;
  }
  return_label: 
#line 114 
                return __retres;
}


#line 123  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc_unknown_size(void)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 127 
  tmp = ldv_undef_int();
  
#line 127 
  if (tmp != 0) {
    
#line 128 
    res = external_allocated_data();
    
#line 129 
    memset(res,0,8UL);
    
#line 130 
    __VERIFIER_assume(res != (void *)0);
    
#line 131 
    __retres = res;
    
#line 131 
    goto return_label;
  }
  else {
    
#line 134 
    __retres = (void *)0;
    
#line 134 
    goto return_label;
  }
  return_label: 
#line 127 
                return __retres;
}


#line 137  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc_unknown_size(void)
{
  void *tmp;
  
#line 139 
  tmp = ldv_reference_calloc_unknown_size();
  
#line 139 
  return tmp;
}


#line 142  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc_unknown_size(size_t size)
{
  void *res;
  
#line 146 
  res = external_allocated_data();
  
#line 147 
  __VERIFIER_assume(res != (void *)0);
  
#line 149 
  return res;
}


#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.h"
void ldv_initialize(void);


#line 123 
void ldv_pre_probe(void);


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
int pthread_create(pthread_t *, pthread_attr_t const *, void *(*)(void *), void *);


#line 37 
int pthread_join(pthread_t, void **);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/err.h"
__inline static void *ERR_PTR(long error)
{
  void *__retres;
  
#line 25 
  __retres = (void *)error;
  
#line 25 
  return __retres;
}


#line 279  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
int main(void);


#line 280 
void *ldv_character_driver_scenario_15(void *arg0);


#line 281 
void *ldv_character_driver_scenario_11(void *arg0);


#line 282 
void *ldv_character_driver_scenario_75(void *arg0);


#line 283 
void *ldv_character_driver_scenario_69(void *arg0);


#line 284 
void *ldv_character_driver_scenario_34(void *arg0);


#line 285 
void *ldv_character_driver_scenario_41(void *arg0);


#line 286 
void *ldv_character_driver_scenario_92(void *arg0);


#line 287 
void *ldv_character_driver_scenario_48(void *arg0);


#line 288 
void *ldv_character_driver_scenario_121(void *arg0);


#line 289 
void *ldv_character_driver_scenario_17(void *arg0);


#line 290 
void *ldv_character_driver_scenario_44(void *arg0);


#line 291 
void *ldv_character_driver_scenario_51(void *arg0);


#line 292 
void *ldv_character_driver_scenario_29(void *arg0);


#line 293 
void *ldv_character_driver_scenario_114(void *arg0);


#line 294 
void *ldv_character_driver_scenario_37(void *arg0);


#line 295 
void *ldv_character_driver_scenario_83(void *arg0);


#line 296 
void *ldv_character_driver_scenario_10(void *arg0);


#line 297 
void *ldv_character_driver_scenario_40(void *arg0);


#line 298 
void *ldv_initialization_1(void *arg0);


#line 299 
void *ldv_character_driver_scenario_65(void *arg0);


#line 300 
void *ldv_character_driver_scenario_107(void *arg0);


#line 301 
void *ldv_character_driver_scenario_93(void *arg0);


#line 302 
void *ldv_character_driver_scenario_111(void *arg0);


#line 303 
void ldv_dispatch_register_2_3(struct platform_driver *arg0);


#line 304 
void *ldv_character_driver_scenario_73(void *arg0);


#line 305 
void *ldv_character_driver_scenario_67(void *arg0);


#line 307 
void *ldv_character_driver_scenario_104(void *arg0);


#line 308 
void *ldv_character_driver_scenario_53(void *arg0);


#line 309 
void *ldv_character_driver_scenario_106(void *arg0);


#line 310 
void *ldv_character_driver_scenario_117(void *arg0);


#line 311 
void *ldv_character_driver_scenario_122(void *arg0);


#line 312 
void *ldv_character_driver_scenario_95(void *arg0);


#line 313 
void *ldv_character_driver_scenario_25(void *arg0);


#line 314 
void *ldv_character_driver_scenario_49(void *arg0);


#line 315 
void *ldv_character_driver_scenario_55(void *arg0);


#line 316 
void *ldv_character_driver_scenario_116(void *arg0);


#line 317 
void *ldv_character_driver_scenario_113(void *arg0);


#line 318 
void *ldv_character_driver_scenario_35(void *arg0);


#line 319 
void *ldv_character_driver_scenario_84(void *arg0);


#line 320 
void *ldv_character_driver_scenario_86(void *arg0);


#line 321 
void *ldv_character_driver_scenario_26(void *arg0);


#line 322 
void *ldv_character_driver_scenario_91(void *arg0);


#line 323 
void *ldv_character_driver_scenario_103(void *arg0);


#line 324 
void *ldv_character_driver_scenario_101(void *arg0);


#line 325 
void *ldv_character_driver_scenario_19(void *arg0);


#line 326 
void *ldv_character_driver_scenario_109(void *arg0);


#line 327 
void *ldv_pm_ops_scenario_81(void *arg0);


#line 328 
void *ldv_character_driver_scenario_42(void *arg0);


#line 329 
void *ldv_character_driver_scenario_94(void *arg0);


#line 330 
void *ldv_character_driver_scenario_68(void *arg0);


#line 331 
void *ldv_character_driver_scenario_71(void *arg0);


#line 332 
void *ldv_character_driver_scenario_80(void *arg0);


#line 333 
void *ldv_character_driver_scenario_90(void *arg0);


#line 334 
void *ldv_character_driver_scenario_18(void *arg0);


#line 335 
void *ldv_character_driver_scenario_77(void *arg0);


#line 336 
void *ldv_character_driver_scenario_13(void *arg0);


#line 337 
void *ldv_character_driver_scenario_32(void *arg0);


#line 338 
void *ldv_character_driver_scenario_100(void *arg0);


#line 339 
void *ldv_character_driver_scenario_24(void *arg0);


#line 340 
void *ldv_character_driver_scenario_8(void *arg0);


#line 341 
void *ldv_character_driver_scenario_59(void *arg0);


#line 342 
void *ldv_character_driver_scenario_31(void *arg0);


#line 343 
void *ldv_character_driver_scenario_118(void *arg0);


#line 344 
void *ldv_character_driver_scenario_52(void *arg0);


#line 345 
void *ldv_character_driver_scenario_96(void *arg0);


#line 346 
void *ldv_character_driver_scenario_119(void *arg0);


#line 348 
void *ldv_character_driver_scenario_46(void *arg0);


#line 349 
void *ldv_character_driver_scenario_87(void *arg0);


#line 350 
void ldv_dispatch_deregister_3_1(struct platform_driver *arg0);


#line 351 
void *ldv_character_driver_scenario_128(void *arg0);


#line 352 
void *ldv_character_driver_scenario_12(void *arg0);


#line 353 
void *ldv_character_driver_scenario_79(void *arg0);


#line 354 
void *ldv_character_driver_scenario_22(void *arg0);


#line 355 
void *ldv_character_driver_scenario_82(void *arg0);


#line 356 
void *ldv_character_driver_scenario_43(void *arg0);


#line 357 
void *ldv_character_driver_scenario_72(void *arg0);


#line 358 
void *ldv_character_driver_scenario_20(void *arg0);


#line 359 
void *ldv_character_driver_scenario_63(void *arg0);


#line 360 
void *ldv_character_driver_scenario_125(void *arg0);


#line 361 
void *ldv_character_driver_scenario_99(void *arg0);


#line 362 
void ldv_dispatch_pm_deregister_108_12(void);


#line 363 
void *ldv_character_driver_scenario_120(void *arg0);


#line 364 
void ldv_dispatch_register_4_3(struct file_operations *arg0);


#line 365 
void *ldv_character_driver_scenario_64(void *arg0);


#line 366 
void *ldv_character_driver_scenario_78(void *arg0);


#line 367 
void *ldv_character_driver_scenario_105(void *arg0);


#line 368 
void *ldv_character_driver_scenario_112(void *arg0);


#line 370 
void ldv_dispatch_pm_register_108_13(void);


#line 371 
void *ldv_character_driver_scenario_14(void *arg0);


#line 372 
void *ldv_character_driver_scenario_127(void *arg0);


#line 373 
void *ldv_character_driver_scenario_47(void *arg0);


#line 374 
void *ldv_character_driver_scenario_58(void *arg0);


#line 375 
void *ldv_character_driver_scenario_9(void *arg0);


#line 376 
void *ldv_character_driver_scenario_61(void *arg0);


#line 377 
void *ldv_character_driver_scenario_76(void *arg0);


#line 378 
void *ldv_character_driver_scenario_85(void *arg0);


#line 379 
void *ldv_character_driver_scenario_21(void *arg0);


#line 381 
void *ldv_character_driver_scenario_110(void *arg0);


#line 382 
void *ldv_character_driver_scenario_6(void *arg0);


#line 383 
void *ldv_character_driver_scenario_50(void *arg0);


#line 384 
void *ldv_character_driver_scenario_16(void *arg0);


#line 385 
void *ldv_character_driver_scenario_74(void *arg0);


#line 386 
void *ldv_character_driver_scenario_30(void *arg0);


#line 387 
void *ldv_character_driver_scenario_39(void *arg0);


#line 388 
void *ldv_character_driver_scenario_62(void *arg0);


#line 389 
void *ldv_character_driver_scenario_115(void *arg0);


#line 390 
void *ldv_character_driver_scenario_124(void *arg0);


#line 391 
void *ldv_character_driver_scenario_45(void *arg0);


#line 392 
void *ldv_character_driver_scenario_89(void *arg0);


#line 393 
void *ldv_character_driver_scenario_36(void *arg0);


#line 394 
void *ldv_platform_instance_108(void *arg0);


#line 395 
void *ldv_character_driver_scenario_38(void *arg0);


#line 396 
void *ldv_character_driver_scenario_66(void *arg0);


#line 397 
void *ldv_character_driver_scenario_7(void *arg0);


#line 398 
void *ldv_character_driver_scenario_102(void *arg0);


#line 399 
void *ldv_character_driver_scenario_126(void *arg0);


#line 400 
void *ldv_character_driver_scenario_54(void *arg0);


#line 401 
void *ldv_character_driver_scenario_28(void *arg0);


#line 402 
void *ldv_character_driver_scenario_56(void *arg0);


#line 403 
void *ldv_character_driver_scenario_23(void *arg0);


#line 404 
void *ldv_character_driver_scenario_27(void *arg0);


#line 405 
void *ldv_character_driver_scenario_33(void *arg0);


#line 406 
void *ldv_character_driver_scenario_98(void *arg0);


#line 407 
void *ldv_character_driver_scenario_97(void *arg0);


#line 408 
void *ldv_character_driver_scenario_123(void *arg0);


#line 409 
void *ldv_character_driver_scenario_57(void *arg0);


#line 410 
void *ldv_character_driver_scenario_60(void *arg0);


#line 411 
void *ldv_character_driver_scenario_70(void *arg0);


#line 412 
void *ldv_character_driver_scenario_88(void *arg0);


#line 415  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_73;

#line 416  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_33;

#line 417  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_21;

#line 418  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_11;

#line 419  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_92;

#line 420  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_10;

#line 421  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_118;

#line 422  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_42;

#line 423  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_37;

#line 424  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_9;

#line 425  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_51;

#line 426  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_119;

#line 427  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_101;

#line 428  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_53;

#line 429  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_17;

#line 430  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_28;

#line 431  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_20;

#line 432  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_66;

#line 433  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_85;

#line 434  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_64;

#line 435  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_107;

#line 436  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_89;

#line 437  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_56;

#line 438  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_15;

#line 439  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_65;

#line 440  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_99;

#line 441  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_76;

#line 442  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_91;

#line 443  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_103;

#line 444  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_116;

#line 445  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_128;

#line 446  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_109;

#line 447  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_121;

#line 448  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_44;

#line 449  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_98;

#line 450  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_95;

#line 451  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_115;

#line 452  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_86;

#line 453  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_36;

#line 454  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_59;

#line 455  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_78;

#line 456  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_13;

#line 457  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_39;

#line 458  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_16;

#line 459  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_35;

#line 460  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_48;

#line 461  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_105;

#line 462  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_29;

#line 463  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_75;

#line 464  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_30;

#line 465  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_97;

#line 466  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_7;

#line 467  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_72;

#line 468  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_24;

#line 469  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_12;

#line 470  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_60;

#line 471  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_32;

#line 472  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_26;

#line 473  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_82;

#line 474  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_110;

#line 475  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_106;

#line 476  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_8;

#line 477  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_46;

#line 478  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_81;

#line 479  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_62;

#line 480  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_47;

#line 481  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_70;

#line 482  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_94;

#line 483  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_6;

#line 484  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_55;

#line 485  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_31;

#line 486  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_125;

#line 487  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_40;

#line 488  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_77;

#line 489  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_114;

#line 490  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_108;

#line 491  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_68;

#line 492  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_38;

#line 493  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_57;

#line 494  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_25;

#line 495  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_87;

#line 496  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_63;

#line 497  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_19;

#line 498  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_41;

#line 499  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_84;

#line 500  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_18;

#line 501  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_45;

#line 502  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_117;

#line 503  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_61;

#line 504  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_74;

#line 505  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_90;

#line 506  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_102;

#line 507  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_124;

#line 508  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_80;

#line 509  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_122;

#line 510  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_123;

#line 511  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_54;

#line 512  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_14;

#line 513  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_127;

#line 514  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_58;

#line 515  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_100;

#line 516  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_112;

#line 517  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_83;

#line 518  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_50;

#line 519  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_22;

#line 520  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_34;

#line 521  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_79;

#line 522  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_67;

#line 523  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_71;

#line 524  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_49;

#line 525  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_126;

#line 526  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_23;

#line 527  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_69;

#line 528  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_96;

#line 529  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_93;

#line 530  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_52;

#line 531  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_104;

#line 532  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_43;

#line 533  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_113;

#line 534  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_27;

#line 535  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_88;

#line 536  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_111;

#line 537  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_120;

#line 541  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
int main(void)
{
  int __retres;
  
#line 544 
  ldv_initialize();
  
#line 547 
  ldv_initialization_1((void *)0);
  
#line 549 
  __retres = 0;
  
#line 549 
  return __retres;
}


#line 554  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_15(void *arg0)
{
  void *__retres;
  struct file *ldv_15_resource_1;
  int ldv_15_ldv_param_2_3;
  long long ldv_15_ldv_param_1_2;
  char *ldv_15_ldv_param_1_4;
  struct inode *ldv_15_resource_0;
  unsigned long ldv_15_size_cnt;
  long long *ldv_15_ldv_param_3_5;
  char *ldv_15_ldv_param_1_6;
  long long *ldv_15_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 565 
  struct file_operations *ldv_15_container = ldv_emg_alias_ps_poll_upsd_utilization_ops_2;
  
#line 566 
  int ldv_15_ret = ldv_undef_int();
  
#line 569 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 573 
  ldv_15_ret = ldv_undef_int();
  
#line 576 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 577 
    ldv_15_container = data->arg0;
    
#line 578 
    ldv_free((void *)data);
  }
  else ;
  
#line 583 
  ldv_15_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 584 
  tmp_1 = ldv_undef_int();
  
#line 584 
  ldv_15_size_cnt = (unsigned long)tmp_1;
  
#line 591 
  goto ldv_main_15;
  
#line 593 
  __retres = (void *)0;
  
#line 593 
  goto return_label;
  ldv_main_15: 
#line 596 
  ;
  
#line 599 
  tmp_3 = ldv_undef_int();
  
#line 599 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 602 
    ldv_15_ret = (*ldv_emg_alias_simple_open_5)(ldv_15_resource_0,ldv_15_resource_1);
    
#line 604 
    ldv_15_ret = ldv_filter_err_code(ldv_15_ret);
    
#line 607 
    tmp_2 = ldv_undef_int();
    
#line 607 
    if (tmp_2 != 0) {
      
#line 609 
      __VERIFIER_assume(ldv_15_ret == 0);
      
#line 616 
      goto ldv_call_15;
    }
    else {
      
#line 620 
      __VERIFIER_assume(ldv_15_ret != 0);
      
#line 627 
      goto ldv_main_15;
    }
  }
  else {
    
#line 632 
    ldv_free((void *)ldv_15_resource_0);
    
#line 640 
    __retres = (void *)0;
    
#line 640 
    goto return_label;
  }
  
#line 643 
  __retres = (void *)0;
  
#line 643 
  goto return_label;
  ldv_call_15: 
#line 646 
  ;
  
#line 649 
  tmp_4 = ldv_undef_int();
  
#line 649 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 650 
    ;
    
#line 652 
    ldv_15_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 653 
    ldv_15_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 657 
    if (ldv_15_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 663 
      __VERIFIER_assume(ldv_15_size_cnt <= 2147479552UL);
      
#line 665 
      (*(ldv_15_container->write))(ldv_15_resource_1,(char const *)ldv_15_ldv_param_1_6,ldv_15_size_cnt,ldv_15_ldv_param_3_7);
    }
    else ;
    
#line 670 
    ldv_free((void *)ldv_15_ldv_param_1_6);
    
#line 671 
    ldv_free((void *)ldv_15_ldv_param_3_7);
    
#line 678 
    goto ldv_call_15;
    case 2: 
#line 681 
    ;
    
#line 683 
    if (ldv_15_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 685 
      (*(ldv_15_container->release))(ldv_15_resource_0,ldv_15_resource_1); else ;
    
#line 693 
    goto ldv_main_15;
    case 3: 
#line 696 
    ;
    
#line 700 
    tmp_9 = ldv_undef_int();
    
#line 700 
    if (tmp_9 != 0) 
#line 703 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_15_resource_1,ldv_15_ldv_param_1_2,ldv_15_ldv_param_2_3);
    else {
      
#line 709 
      ldv_15_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 710 
      ldv_15_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 715 
      ldv_emg_wrapper_ps_poll_upsd_utilization_read_3(ldv_15_resource_1,ldv_15_ldv_param_1_4,ldv_15_size_cnt,ldv_15_ldv_param_3_5);
      
#line 719 
      ldv_free((void *)ldv_15_ldv_param_1_4);
      
#line 720 
      ldv_free((void *)ldv_15_ldv_param_3_5);
    }
    
#line 724 
    goto ldv_30643;
    default: 
#line 726 
    ;
    
#line 726 
    __VERIFIER_assume(0);
  }
  ldv_30643: 
#line 735 
  ;
  
#line 735 
  goto ldv_call_15;
  
#line 737 
  __retres = (void *)0;
  return_label: 
#line 737 
                return __retres;
}


#line 742  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_11(void *arg0)
{
  void *__retres;
  struct file *ldv_11_resource_1;
  int ldv_11_ldv_param_2_3;
  long long ldv_11_ldv_param_1_2;
  char *ldv_11_ldv_param_1_4;
  struct inode *ldv_11_resource_0;
  unsigned long ldv_11_size_cnt;
  long long *ldv_11_ldv_param_3_5;
  char *ldv_11_ldv_param_1_6;
  long long *ldv_11_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 753 
  struct file_operations *ldv_11_container = ldv_emg_alias_error_error_bar_retry_ops_2;
  
#line 754 
  int ldv_11_ret = ldv_undef_int();
  
#line 757 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 761 
  ldv_11_ret = ldv_undef_int();
  
#line 764 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 765 
    ldv_11_container = data->arg0;
    
#line 766 
    ldv_free((void *)data);
  }
  else ;
  
#line 771 
  ldv_11_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 772 
  tmp_1 = ldv_undef_int();
  
#line 772 
  ldv_11_size_cnt = (unsigned long)tmp_1;
  
#line 779 
  goto ldv_main_11;
  
#line 781 
  __retres = (void *)0;
  
#line 781 
  goto return_label;
  ldv_main_11: 
#line 784 
  ;
  
#line 787 
  tmp_3 = ldv_undef_int();
  
#line 787 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 790 
    ldv_11_ret = (*ldv_emg_alias_simple_open_5)(ldv_11_resource_0,ldv_11_resource_1);
    
#line 792 
    ldv_11_ret = ldv_filter_err_code(ldv_11_ret);
    
#line 795 
    tmp_2 = ldv_undef_int();
    
#line 795 
    if (tmp_2 != 0) {
      
#line 797 
      __VERIFIER_assume(ldv_11_ret == 0);
      
#line 804 
      goto ldv_call_11;
    }
    else {
      
#line 808 
      __VERIFIER_assume(ldv_11_ret != 0);
      
#line 815 
      goto ldv_main_11;
    }
  }
  else {
    
#line 820 
    ldv_free((void *)ldv_11_resource_0);
    
#line 828 
    __retres = (void *)0;
    
#line 828 
    goto return_label;
  }
  
#line 831 
  __retres = (void *)0;
  
#line 831 
  goto return_label;
  ldv_call_11: 
#line 834 
  ;
  
#line 837 
  tmp_4 = ldv_undef_int();
  
#line 837 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 838 
    ;
    
#line 840 
    ldv_11_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 841 
    ldv_11_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 845 
    if (ldv_11_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 851 
      __VERIFIER_assume(ldv_11_size_cnt <= 2147479552UL);
      
#line 853 
      (*(ldv_11_container->write))(ldv_11_resource_1,(char const *)ldv_11_ldv_param_1_6,ldv_11_size_cnt,ldv_11_ldv_param_3_7);
    }
    else ;
    
#line 858 
    ldv_free((void *)ldv_11_ldv_param_1_6);
    
#line 859 
    ldv_free((void *)ldv_11_ldv_param_3_7);
    
#line 866 
    goto ldv_call_11;
    case 2: 
#line 869 
    ;
    
#line 871 
    if (ldv_11_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 873 
      (*(ldv_11_container->release))(ldv_11_resource_0,ldv_11_resource_1); else ;
    
#line 881 
    goto ldv_main_11;
    case 3: 
#line 884 
    ;
    
#line 888 
    tmp_9 = ldv_undef_int();
    
#line 888 
    if (tmp_9 != 0) 
#line 891 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_11_resource_1,ldv_11_ldv_param_1_2,ldv_11_ldv_param_2_3);
    else {
      
#line 897 
      ldv_11_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 898 
      ldv_11_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 903 
      ldv_emg_wrapper_error_error_bar_retry_read_3(ldv_11_resource_1,ldv_11_ldv_param_1_4,ldv_11_size_cnt,ldv_11_ldv_param_3_5);
      
#line 907 
      ldv_free((void *)ldv_11_ldv_param_1_4);
      
#line 908 
      ldv_free((void *)ldv_11_ldv_param_3_5);
    }
    
#line 912 
    goto ldv_30665;
    default: 
#line 914 
    ;
    
#line 914 
    __VERIFIER_assume(0);
  }
  ldv_30665: 
#line 923 
  ;
  
#line 923 
  goto ldv_call_11;
  
#line 925 
  __retres = (void *)0;
  return_label: 
#line 925 
                return __retres;
}


#line 930  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_75(void *arg0)
{
  void *__retres;
  struct file *ldv_75_resource_1;
  int ldv_75_ldv_param_2_3;
  long long ldv_75_ldv_param_1_2;
  char *ldv_75_ldv_param_1_4;
  struct inode *ldv_75_resource_0;
  unsigned long ldv_75_size_cnt;
  long long *ldv_75_ldv_param_3_5;
  char *ldv_75_ldv_param_1_6;
  long long *ldv_75_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 941 
  struct file_operations *ldv_75_container = ldv_emg_alias_tx_frag_cache_hit_ops_2;
  
#line 942 
  int ldv_75_ret = ldv_undef_int();
  
#line 945 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 949 
  ldv_75_ret = ldv_undef_int();
  
#line 952 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 953 
    ldv_75_container = data->arg0;
    
#line 954 
    ldv_free((void *)data);
  }
  else ;
  
#line 959 
  ldv_75_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 960 
  tmp_1 = ldv_undef_int();
  
#line 960 
  ldv_75_size_cnt = (unsigned long)tmp_1;
  
#line 967 
  goto ldv_main_75;
  
#line 969 
  __retres = (void *)0;
  
#line 969 
  goto return_label;
  ldv_main_75: 
#line 972 
  ;
  
#line 975 
  tmp_3 = ldv_undef_int();
  
#line 975 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 978 
    ldv_75_ret = (*ldv_emg_alias_simple_open_5)(ldv_75_resource_0,ldv_75_resource_1);
    
#line 980 
    ldv_75_ret = ldv_filter_err_code(ldv_75_ret);
    
#line 983 
    tmp_2 = ldv_undef_int();
    
#line 983 
    if (tmp_2 != 0) {
      
#line 985 
      __VERIFIER_assume(ldv_75_ret == 0);
      
#line 992 
      goto ldv_call_75;
    }
    else {
      
#line 996 
      __VERIFIER_assume(ldv_75_ret != 0);
      
#line 1003 
      goto ldv_main_75;
    }
  }
  else {
    
#line 1008 
    ldv_free((void *)ldv_75_resource_0);
    
#line 1016 
    __retres = (void *)0;
    
#line 1016 
    goto return_label;
  }
  
#line 1019 
  __retres = (void *)0;
  
#line 1019 
  goto return_label;
  ldv_call_75: 
#line 1022 
  ;
  
#line 1025 
  tmp_4 = ldv_undef_int();
  
#line 1025 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 1026 
    ;
    
#line 1028 
    ldv_75_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 1029 
    ldv_75_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 1033 
    if (ldv_75_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 1039 
      __VERIFIER_assume(ldv_75_size_cnt <= 2147479552UL);
      
#line 1041 
      (*(ldv_75_container->write))(ldv_75_resource_1,(char const *)ldv_75_ldv_param_1_6,ldv_75_size_cnt,ldv_75_ldv_param_3_7);
    }
    else ;
    
#line 1046 
    ldv_free((void *)ldv_75_ldv_param_1_6);
    
#line 1047 
    ldv_free((void *)ldv_75_ldv_param_3_7);
    
#line 1054 
    goto ldv_call_75;
    case 2: 
#line 1057 
    ;
    
#line 1059 
    if (ldv_75_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 1061 
      (*(ldv_75_container->release))(ldv_75_resource_0,ldv_75_resource_1); else ;
    
#line 1069 
    goto ldv_main_75;
    case 3: 
#line 1072 
    ;
    
#line 1076 
    tmp_9 = ldv_undef_int();
    
#line 1076 
    if (tmp_9 != 0) 
#line 1079 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_75_resource_1,ldv_75_ldv_param_1_2,ldv_75_ldv_param_2_3);
    else {
      
#line 1085 
      ldv_75_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 1086 
      ldv_75_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 1091 
      ldv_emg_wrapper_tx_frag_cache_hit_read_3(ldv_75_resource_1,ldv_75_ldv_param_1_4,ldv_75_size_cnt,ldv_75_ldv_param_3_5);
      
#line 1095 
      ldv_free((void *)ldv_75_ldv_param_3_5);
      
#line 1096 
      ldv_free((void *)ldv_75_ldv_param_1_4);
    }
    
#line 1100 
    goto ldv_30687;
    default: 
#line 1102 
    ;
    
#line 1102 
    __VERIFIER_assume(0);
  }
  ldv_30687: 
#line 1111 
  ;
  
#line 1111 
  goto ldv_call_75;
  
#line 1113 
  __retres = (void *)0;
  return_label: 
#line 1113 
                return __retres;
}


#line 1118  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_69(void *arg0)
{
  void *__retres;
  struct file *ldv_69_resource_1;
  int ldv_69_ldv_param_2_3;
  long long ldv_69_ldv_param_1_2;
  char *ldv_69_ldv_param_1_4;
  struct inode *ldv_69_resource_0;
  unsigned long ldv_69_size_cnt;
  long long *ldv_69_ldv_param_3_5;
  char *ldv_69_ldv_param_1_6;
  long long *ldv_69_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 1129 
  struct file_operations *ldv_69_container = ldv_emg_alias_rx_rx_cmplt_ops_2;
  
#line 1130 
  int ldv_69_ret = ldv_undef_int();
  
#line 1133 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 1137 
  ldv_69_ret = ldv_undef_int();
  
#line 1140 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 1141 
    ldv_69_container = data->arg0;
    
#line 1142 
    ldv_free((void *)data);
  }
  else ;
  
#line 1147 
  ldv_69_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 1148 
  tmp_1 = ldv_undef_int();
  
#line 1148 
  ldv_69_size_cnt = (unsigned long)tmp_1;
  
#line 1155 
  goto ldv_main_69;
  
#line 1157 
  __retres = (void *)0;
  
#line 1157 
  goto return_label;
  ldv_main_69: 
#line 1160 
  ;
  
#line 1163 
  tmp_3 = ldv_undef_int();
  
#line 1163 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 1166 
    ldv_69_ret = (*ldv_emg_alias_simple_open_5)(ldv_69_resource_0,ldv_69_resource_1);
    
#line 1168 
    ldv_69_ret = ldv_filter_err_code(ldv_69_ret);
    
#line 1171 
    tmp_2 = ldv_undef_int();
    
#line 1171 
    if (tmp_2 != 0) {
      
#line 1173 
      __VERIFIER_assume(ldv_69_ret == 0);
      
#line 1180 
      goto ldv_call_69;
    }
    else {
      
#line 1184 
      __VERIFIER_assume(ldv_69_ret != 0);
      
#line 1191 
      goto ldv_main_69;
    }
  }
  else {
    
#line 1196 
    ldv_free((void *)ldv_69_resource_0);
    
#line 1204 
    __retres = (void *)0;
    
#line 1204 
    goto return_label;
  }
  
#line 1207 
  __retres = (void *)0;
  
#line 1207 
  goto return_label;
  ldv_call_69: 
#line 1210 
  ;
  
#line 1213 
  tmp_4 = ldv_undef_int();
  
#line 1213 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 1214 
    ;
    
#line 1216 
    ldv_69_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 1217 
    ldv_69_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 1221 
    if (ldv_69_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 1227 
      __VERIFIER_assume(ldv_69_size_cnt <= 2147479552UL);
      
#line 1229 
      (*(ldv_69_container->write))(ldv_69_resource_1,(char const *)ldv_69_ldv_param_1_6,ldv_69_size_cnt,ldv_69_ldv_param_3_7);
    }
    else ;
    
#line 1234 
    ldv_free((void *)ldv_69_ldv_param_3_7);
    
#line 1235 
    ldv_free((void *)ldv_69_ldv_param_1_6);
    
#line 1242 
    goto ldv_call_69;
    case 2: 
#line 1245 
    ;
    
#line 1247 
    if (ldv_69_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 1249 
      (*(ldv_69_container->release))(ldv_69_resource_0,ldv_69_resource_1); else ;
    
#line 1257 
    goto ldv_main_69;
    case 3: 
#line 1260 
    ;
    
#line 1264 
    tmp_9 = ldv_undef_int();
    
#line 1264 
    if (tmp_9 != 0) 
#line 1267 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_69_resource_1,ldv_69_ldv_param_1_2,ldv_69_ldv_param_2_3);
    else {
      
#line 1273 
      ldv_69_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 1274 
      ldv_69_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 1279 
      ldv_emg_wrapper_rx_rx_cmplt_read_3(ldv_69_resource_1,ldv_69_ldv_param_1_4,ldv_69_size_cnt,ldv_69_ldv_param_3_5);
      
#line 1283 
      ldv_free((void *)ldv_69_ldv_param_1_4);
      
#line 1284 
      ldv_free((void *)ldv_69_ldv_param_3_5);
    }
    
#line 1288 
    goto ldv_30709;
    default: 
#line 1290 
    ;
    
#line 1290 
    __VERIFIER_assume(0);
  }
  ldv_30709: 
#line 1299 
  ;
  
#line 1299 
  goto ldv_call_69;
  
#line 1301 
  __retres = (void *)0;
  return_label: 
#line 1301 
                return __retres;
}


#line 1306  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_34(void *arg0)
{
  void *__retres;
  struct file *ldv_34_resource_1;
  int ldv_34_ldv_param_2_3;
  long long ldv_34_ldv_param_1_2;
  char *ldv_34_ldv_param_1_4;
  struct inode *ldv_34_resource_0;
  unsigned long ldv_34_size_cnt;
  long long *ldv_34_ldv_param_3_5;
  char *ldv_34_ldv_param_1_6;
  long long *ldv_34_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 1317 
  struct file_operations *ldv_34_container = ldv_emg_alias_error_error_frame_cts_nul_flid_ops_2;
  
#line 1318 
  int ldv_34_ret = ldv_undef_int();
  
#line 1321 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 1325 
  ldv_34_ret = ldv_undef_int();
  
#line 1328 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 1329 
    ldv_34_container = data->arg0;
    
#line 1330 
    ldv_free((void *)data);
  }
  else ;
  
#line 1335 
  ldv_34_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 1336 
  tmp_1 = ldv_undef_int();
  
#line 1336 
  ldv_34_size_cnt = (unsigned long)tmp_1;
  
#line 1343 
  goto ldv_main_34;
  
#line 1345 
  __retres = (void *)0;
  
#line 1345 
  goto return_label;
  ldv_main_34: 
#line 1348 
  ;
  
#line 1351 
  tmp_3 = ldv_undef_int();
  
#line 1351 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 1354 
    ldv_34_ret = (*ldv_emg_alias_simple_open_5)(ldv_34_resource_0,ldv_34_resource_1);
    
#line 1356 
    ldv_34_ret = ldv_filter_err_code(ldv_34_ret);
    
#line 1359 
    tmp_2 = ldv_undef_int();
    
#line 1359 
    if (tmp_2 != 0) {
      
#line 1361 
      __VERIFIER_assume(ldv_34_ret == 0);
      
#line 1368 
      goto ldv_call_34;
    }
    else {
      
#line 1372 
      __VERIFIER_assume(ldv_34_ret != 0);
      
#line 1379 
      goto ldv_main_34;
    }
  }
  else {
    
#line 1384 
    ldv_free((void *)ldv_34_resource_0);
    
#line 1392 
    __retres = (void *)0;
    
#line 1392 
    goto return_label;
  }
  
#line 1395 
  __retres = (void *)0;
  
#line 1395 
  goto return_label;
  ldv_call_34: 
#line 1398 
  ;
  
#line 1401 
  tmp_4 = ldv_undef_int();
  
#line 1401 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 1402 
    ;
    
#line 1404 
    ldv_34_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 1405 
    ldv_34_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 1409 
    if (ldv_34_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 1415 
      __VERIFIER_assume(ldv_34_size_cnt <= 2147479552UL);
      
#line 1417 
      (*(ldv_34_container->write))(ldv_34_resource_1,(char const *)ldv_34_ldv_param_1_6,ldv_34_size_cnt,ldv_34_ldv_param_3_7);
    }
    else ;
    
#line 1422 
    ldv_free((void *)ldv_34_ldv_param_3_7);
    
#line 1423 
    ldv_free((void *)ldv_34_ldv_param_1_6);
    
#line 1430 
    goto ldv_call_34;
    case 2: 
#line 1433 
    ;
    
#line 1435 
    if (ldv_34_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 1437 
      (*(ldv_34_container->release))(ldv_34_resource_0,ldv_34_resource_1); else ;
    
#line 1445 
    goto ldv_main_34;
    case 3: 
#line 1448 
    ;
    
#line 1452 
    tmp_9 = ldv_undef_int();
    
#line 1452 
    if (tmp_9 != 0) 
#line 1455 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_34_resource_1,ldv_34_ldv_param_1_2,ldv_34_ldv_param_2_3);
    else {
      
#line 1461 
      ldv_34_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 1462 
      ldv_34_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 1467 
      ldv_emg_wrapper_error_error_frame_cts_nul_flid_read_3(ldv_34_resource_1,ldv_34_ldv_param_1_4,ldv_34_size_cnt,ldv_34_ldv_param_3_5);
      
#line 1471 
      ldv_free((void *)ldv_34_ldv_param_3_5);
      
#line 1472 
      ldv_free((void *)ldv_34_ldv_param_1_4);
    }
    
#line 1476 
    goto ldv_30731;
    default: 
#line 1478 
    ;
    
#line 1478 
    __VERIFIER_assume(0);
  }
  ldv_30731: 
#line 1487 
  ;
  
#line 1487 
  goto ldv_call_34;
  
#line 1489 
  __retres = (void *)0;
  return_label: 
#line 1489 
                return __retres;
}


#line 1494  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_41(void *arg0)
{
  void *__retres;
  struct file *ldv_41_resource_1;
  int ldv_41_ldv_param_2_3;
  long long ldv_41_ldv_param_1_2;
  char *ldv_41_ldv_param_1_4;
  struct inode *ldv_41_resource_0;
  unsigned long ldv_41_size_cnt;
  long long *ldv_41_ldv_param_3_5;
  char *ldv_41_ldv_param_1_6;
  long long *ldv_41_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 1505 
  struct file_operations *ldv_41_container = ldv_emg_alias_pwr_missing_bcns_cnt_ops_2;
  
#line 1506 
  int ldv_41_ret = ldv_undef_int();
  
#line 1509 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 1513 
  ldv_41_ret = ldv_undef_int();
  
#line 1516 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 1517 
    ldv_41_container = data->arg0;
    
#line 1518 
    ldv_free((void *)data);
  }
  else ;
  
#line 1523 
  ldv_41_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 1524 
  tmp_1 = ldv_undef_int();
  
#line 1524 
  ldv_41_size_cnt = (unsigned long)tmp_1;
  
#line 1531 
  goto ldv_main_41;
  
#line 1533 
  __retres = (void *)0;
  
#line 1533 
  goto return_label;
  ldv_main_41: 
#line 1536 
  ;
  
#line 1539 
  tmp_3 = ldv_undef_int();
  
#line 1539 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 1542 
    ldv_41_ret = (*ldv_emg_alias_simple_open_5)(ldv_41_resource_0,ldv_41_resource_1);
    
#line 1544 
    ldv_41_ret = ldv_filter_err_code(ldv_41_ret);
    
#line 1547 
    tmp_2 = ldv_undef_int();
    
#line 1547 
    if (tmp_2 != 0) {
      
#line 1549 
      __VERIFIER_assume(ldv_41_ret == 0);
      
#line 1556 
      goto ldv_call_41;
    }
    else {
      
#line 1560 
      __VERIFIER_assume(ldv_41_ret != 0);
      
#line 1567 
      goto ldv_main_41;
    }
  }
  else {
    
#line 1572 
    ldv_free((void *)ldv_41_resource_0);
    
#line 1580 
    __retres = (void *)0;
    
#line 1580 
    goto return_label;
  }
  
#line 1583 
  __retres = (void *)0;
  
#line 1583 
  goto return_label;
  ldv_call_41: 
#line 1586 
  ;
  
#line 1589 
  tmp_4 = ldv_undef_int();
  
#line 1589 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 1590 
    ;
    
#line 1592 
    ldv_41_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 1593 
    ldv_41_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 1597 
    if (ldv_41_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 1603 
      __VERIFIER_assume(ldv_41_size_cnt <= 2147479552UL);
      
#line 1605 
      (*(ldv_41_container->write))(ldv_41_resource_1,(char const *)ldv_41_ldv_param_1_6,ldv_41_size_cnt,ldv_41_ldv_param_3_7);
    }
    else ;
    
#line 1610 
    ldv_free((void *)ldv_41_ldv_param_1_6);
    
#line 1611 
    ldv_free((void *)ldv_41_ldv_param_3_7);
    
#line 1618 
    goto ldv_call_41;
    case 2: 
#line 1621 
    ;
    
#line 1623 
    if (ldv_41_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 1625 
      (*(ldv_41_container->release))(ldv_41_resource_0,ldv_41_resource_1); else ;
    
#line 1633 
    goto ldv_main_41;
    case 3: 
#line 1636 
    ;
    
#line 1640 
    tmp_9 = ldv_undef_int();
    
#line 1640 
    if (tmp_9 != 0) 
#line 1643 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_41_resource_1,ldv_41_ldv_param_1_2,ldv_41_ldv_param_2_3);
    else {
      
#line 1649 
      ldv_41_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 1650 
      ldv_41_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 1655 
      ldv_emg_wrapper_pwr_missing_bcns_cnt_read_3(ldv_41_resource_1,ldv_41_ldv_param_1_4,ldv_41_size_cnt,ldv_41_ldv_param_3_5);
      
#line 1659 
      ldv_free((void *)ldv_41_ldv_param_1_4);
      
#line 1660 
      ldv_free((void *)ldv_41_ldv_param_3_5);
    }
    
#line 1664 
    goto ldv_30753;
    default: 
#line 1666 
    ;
    
#line 1666 
    __VERIFIER_assume(0);
  }
  ldv_30753: 
#line 1675 
  ;
  
#line 1675 
  goto ldv_call_41;
  
#line 1677 
  __retres = (void *)0;
  return_label: 
#line 1677 
                return __retres;
}


#line 1682  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_92(void *arg0)
{
  void *__retres;
  struct file *ldv_92_resource_1;
  int ldv_92_ldv_param_2_3;
  long long ldv_92_ldv_param_1_2;
  char *ldv_92_ldv_param_1_4;
  struct inode *ldv_92_resource_0;
  unsigned long ldv_92_size_cnt;
  long long *ldv_92_ldv_param_3_5;
  char *ldv_92_ldv_param_1_6;
  long long *ldv_92_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 1693 
  struct file_operations *ldv_92_container = ldv_emg_alias_rx_filter_data_filter_ops_2;
  
#line 1694 
  int ldv_92_ret = ldv_undef_int();
  
#line 1697 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 1701 
  ldv_92_ret = ldv_undef_int();
  
#line 1704 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 1705 
    ldv_92_container = data->arg0;
    
#line 1706 
    ldv_free((void *)data);
  }
  else ;
  
#line 1711 
  ldv_92_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 1712 
  tmp_1 = ldv_undef_int();
  
#line 1712 
  ldv_92_size_cnt = (unsigned long)tmp_1;
  
#line 1719 
  goto ldv_main_92;
  
#line 1721 
  __retres = (void *)0;
  
#line 1721 
  goto return_label;
  ldv_main_92: 
#line 1724 
  ;
  
#line 1727 
  tmp_3 = ldv_undef_int();
  
#line 1727 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 1730 
    ldv_92_ret = (*ldv_emg_alias_simple_open_5)(ldv_92_resource_0,ldv_92_resource_1);
    
#line 1732 
    ldv_92_ret = ldv_filter_err_code(ldv_92_ret);
    
#line 1735 
    tmp_2 = ldv_undef_int();
    
#line 1735 
    if (tmp_2 != 0) {
      
#line 1737 
      __VERIFIER_assume(ldv_92_ret == 0);
      
#line 1744 
      goto ldv_call_92;
    }
    else {
      
#line 1748 
      __VERIFIER_assume(ldv_92_ret != 0);
      
#line 1755 
      goto ldv_main_92;
    }
  }
  else {
    
#line 1760 
    ldv_free((void *)ldv_92_resource_0);
    
#line 1768 
    __retres = (void *)0;
    
#line 1768 
    goto return_label;
  }
  
#line 1771 
  __retres = (void *)0;
  
#line 1771 
  goto return_label;
  ldv_call_92: 
#line 1774 
  ;
  
#line 1777 
  tmp_4 = ldv_undef_int();
  
#line 1777 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 1778 
    ;
    
#line 1780 
    ldv_92_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 1781 
    ldv_92_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 1785 
    if (ldv_92_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 1791 
      __VERIFIER_assume(ldv_92_size_cnt <= 2147479552UL);
      
#line 1793 
      (*(ldv_92_container->write))(ldv_92_resource_1,(char const *)ldv_92_ldv_param_1_6,ldv_92_size_cnt,ldv_92_ldv_param_3_7);
    }
    else ;
    
#line 1798 
    ldv_free((void *)ldv_92_ldv_param_3_7);
    
#line 1799 
    ldv_free((void *)ldv_92_ldv_param_1_6);
    
#line 1806 
    goto ldv_call_92;
    case 2: 
#line 1809 
    ;
    
#line 1811 
    if (ldv_92_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 1813 
      (*(ldv_92_container->release))(ldv_92_resource_0,ldv_92_resource_1); else ;
    
#line 1821 
    goto ldv_main_92;
    case 3: 
#line 1824 
    ;
    
#line 1828 
    tmp_9 = ldv_undef_int();
    
#line 1828 
    if (tmp_9 != 0) 
#line 1831 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_92_resource_1,ldv_92_ldv_param_1_2,ldv_92_ldv_param_2_3);
    else {
      
#line 1837 
      ldv_92_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 1838 
      ldv_92_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 1843 
      ldv_emg_wrapper_rx_filter_data_filter_read_3(ldv_92_resource_1,ldv_92_ldv_param_1_4,ldv_92_size_cnt,ldv_92_ldv_param_3_5);
      
#line 1847 
      ldv_free((void *)ldv_92_ldv_param_1_4);
      
#line 1848 
      ldv_free((void *)ldv_92_ldv_param_3_5);
    }
    
#line 1852 
    goto ldv_30775;
    default: 
#line 1854 
    ;
    
#line 1854 
    __VERIFIER_assume(0);
  }
  ldv_30775: 
#line 1863 
  ;
  
#line 1863 
  goto ldv_call_92;
  
#line 1865 
  __retres = (void *)0;
  return_label: 
#line 1865 
                return __retres;
}


#line 1870  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_48(void *arg0)
{
  void *__retres;
  struct file *ldv_48_resource_1;
  int ldv_48_ldv_param_2_3;
  long long ldv_48_ldv_param_1_2;
  char *ldv_48_ldv_param_1_4;
  struct inode *ldv_48_resource_0;
  unsigned long ldv_48_size_cnt;
  long long *ldv_48_ldv_param_3_5;
  char *ldv_48_ldv_param_1_6;
  long long *ldv_48_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 1881 
  struct file_operations *ldv_48_container = ldv_emg_alias_tx_tx_start_int_templates_ops_2;
  
#line 1882 
  int ldv_48_ret = ldv_undef_int();
  
#line 1885 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 1889 
  ldv_48_ret = ldv_undef_int();
  
#line 1892 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 1893 
    ldv_48_container = data->arg0;
    
#line 1894 
    ldv_free((void *)data);
  }
  else ;
  
#line 1899 
  ldv_48_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 1900 
  tmp_1 = ldv_undef_int();
  
#line 1900 
  ldv_48_size_cnt = (unsigned long)tmp_1;
  
#line 1907 
  goto ldv_main_48;
  
#line 1909 
  __retres = (void *)0;
  
#line 1909 
  goto return_label;
  ldv_main_48: 
#line 1912 
  ;
  
#line 1915 
  tmp_3 = ldv_undef_int();
  
#line 1915 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 1918 
    ldv_48_ret = (*ldv_emg_alias_simple_open_5)(ldv_48_resource_0,ldv_48_resource_1);
    
#line 1920 
    ldv_48_ret = ldv_filter_err_code(ldv_48_ret);
    
#line 1923 
    tmp_2 = ldv_undef_int();
    
#line 1923 
    if (tmp_2 != 0) {
      
#line 1925 
      __VERIFIER_assume(ldv_48_ret == 0);
      
#line 1932 
      goto ldv_call_48;
    }
    else {
      
#line 1936 
      __VERIFIER_assume(ldv_48_ret != 0);
      
#line 1943 
      goto ldv_main_48;
    }
  }
  else {
    
#line 1948 
    ldv_free((void *)ldv_48_resource_0);
    
#line 1956 
    __retres = (void *)0;
    
#line 1956 
    goto return_label;
  }
  
#line 1959 
  __retres = (void *)0;
  
#line 1959 
  goto return_label;
  ldv_call_48: 
#line 1962 
  ;
  
#line 1965 
  tmp_4 = ldv_undef_int();
  
#line 1965 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 1966 
    ;
    
#line 1968 
    ldv_48_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 1969 
    ldv_48_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 1973 
    if (ldv_48_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 1979 
      __VERIFIER_assume(ldv_48_size_cnt <= 2147479552UL);
      
#line 1981 
      (*(ldv_48_container->write))(ldv_48_resource_1,(char const *)ldv_48_ldv_param_1_6,ldv_48_size_cnt,ldv_48_ldv_param_3_7);
    }
    else ;
    
#line 1986 
    ldv_free((void *)ldv_48_ldv_param_3_7);
    
#line 1987 
    ldv_free((void *)ldv_48_ldv_param_1_6);
    
#line 1994 
    goto ldv_call_48;
    case 2: 
#line 1997 
    ;
    
#line 1999 
    if (ldv_48_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 2001 
      (*(ldv_48_container->release))(ldv_48_resource_0,ldv_48_resource_1); else ;
    
#line 2009 
    goto ldv_main_48;
    case 3: 
#line 2012 
    ;
    
#line 2016 
    tmp_9 = ldv_undef_int();
    
#line 2016 
    if (tmp_9 != 0) 
#line 2019 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_48_resource_1,ldv_48_ldv_param_1_2,ldv_48_ldv_param_2_3);
    else {
      
#line 2025 
      ldv_48_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 2026 
      ldv_48_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 2031 
      ldv_emg_wrapper_tx_tx_start_int_templates_read_3(ldv_48_resource_1,ldv_48_ldv_param_1_4,ldv_48_size_cnt,ldv_48_ldv_param_3_5);
      
#line 2035 
      ldv_free((void *)ldv_48_ldv_param_1_4);
      
#line 2036 
      ldv_free((void *)ldv_48_ldv_param_3_5);
    }
    
#line 2040 
    goto ldv_30797;
    default: 
#line 2042 
    ;
    
#line 2042 
    __VERIFIER_assume(0);
  }
  ldv_30797: 
#line 2051 
  ;
  
#line 2051 
  goto ldv_call_48;
  
#line 2053 
  __retres = (void *)0;
  return_label: 
#line 2053 
                return __retres;
}


#line 2058  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_121(void *arg0)
{
  void *__retres;
  struct file *ldv_121_resource_1;
  int ldv_121_ldv_param_2_3;
  long long ldv_121_ldv_param_1_2;
  char *ldv_121_ldv_param_1_4;
  struct inode *ldv_121_resource_0;
  unsigned long ldv_121_size_cnt;
  long long *ldv_121_ldv_param_3_5;
  char *ldv_121_ldv_param_1_6;
  long long *ldv_121_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 2069 
  struct file_operations *ldv_121_container = ldv_emg_alias_pipeline_sec_frag_swi_ops_2;
  
#line 2070 
  int ldv_121_ret = ldv_undef_int();
  
#line 2073 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 2077 
  ldv_121_ret = ldv_undef_int();
  
#line 2080 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 2081 
    ldv_121_container = data->arg0;
    
#line 2082 
    ldv_free((void *)data);
  }
  else ;
  
#line 2087 
  ldv_121_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 2088 
  tmp_1 = ldv_undef_int();
  
#line 2088 
  ldv_121_size_cnt = (unsigned long)tmp_1;
  
#line 2095 
  goto ldv_main_121;
  
#line 2097 
  __retres = (void *)0;
  
#line 2097 
  goto return_label;
  ldv_main_121: 
#line 2100 
  ;
  
#line 2103 
  tmp_3 = ldv_undef_int();
  
#line 2103 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 2106 
    ldv_121_ret = (*ldv_emg_alias_simple_open_5)(ldv_121_resource_0,ldv_121_resource_1);
    
#line 2108 
    ldv_121_ret = ldv_filter_err_code(ldv_121_ret);
    
#line 2111 
    tmp_2 = ldv_undef_int();
    
#line 2111 
    if (tmp_2 != 0) {
      
#line 2113 
      __VERIFIER_assume(ldv_121_ret == 0);
      
#line 2120 
      goto ldv_call_121;
    }
    else {
      
#line 2124 
      __VERIFIER_assume(ldv_121_ret != 0);
      
#line 2131 
      goto ldv_main_121;
    }
  }
  else {
    
#line 2136 
    ldv_free((void *)ldv_121_resource_0);
    
#line 2144 
    __retres = (void *)0;
    
#line 2144 
    goto return_label;
  }
  
#line 2147 
  __retres = (void *)0;
  
#line 2147 
  goto return_label;
  ldv_call_121: 
#line 2150 
  ;
  
#line 2153 
  tmp_4 = ldv_undef_int();
  
#line 2153 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 2154 
    ;
    
#line 2156 
    ldv_121_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 2157 
    ldv_121_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 2161 
    if (ldv_121_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 2167 
      __VERIFIER_assume(ldv_121_size_cnt <= 2147479552UL);
      
#line 2169 
      (*(ldv_121_container->write))(ldv_121_resource_1,(char const *)ldv_121_ldv_param_1_6,ldv_121_size_cnt,ldv_121_ldv_param_3_7);
    }
    else ;
    
#line 2174 
    ldv_free((void *)ldv_121_ldv_param_3_7);
    
#line 2175 
    ldv_free((void *)ldv_121_ldv_param_1_6);
    
#line 2182 
    goto ldv_call_121;
    case 2: 
#line 2185 
    ;
    
#line 2187 
    if (ldv_121_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 2189 
      (*(ldv_121_container->release))(ldv_121_resource_0,ldv_121_resource_1); else ;
    
#line 2197 
    goto ldv_main_121;
    case 3: 
#line 2200 
    ;
    
#line 2204 
    tmp_9 = ldv_undef_int();
    
#line 2204 
    if (tmp_9 != 0) 
#line 2207 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_121_resource_1,ldv_121_ldv_param_1_2,ldv_121_ldv_param_2_3);
    else {
      
#line 2213 
      ldv_121_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 2214 
      ldv_121_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 2219 
      ldv_emg_wrapper_pipeline_sec_frag_swi_read_3(ldv_121_resource_1,ldv_121_ldv_param_1_4,ldv_121_size_cnt,ldv_121_ldv_param_3_5);
      
#line 2223 
      ldv_free((void *)ldv_121_ldv_param_1_4);
      
#line 2224 
      ldv_free((void *)ldv_121_ldv_param_3_5);
    }
    
#line 2228 
    goto ldv_30819;
    default: 
#line 2230 
    ;
    
#line 2230 
    __VERIFIER_assume(0);
  }
  ldv_30819: 
#line 2239 
  ;
  
#line 2239 
  goto ldv_call_121;
  
#line 2241 
  __retres = (void *)0;
  return_label: 
#line 2241 
                return __retres;
}


#line 2246  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_17(void *arg0)
{
  void *__retres;
  struct file *ldv_17_resource_1;
  int ldv_17_ldv_param_2_3;
  long long ldv_17_ldv_param_1_2;
  char *ldv_17_ldv_param_1_4;
  struct inode *ldv_17_resource_0;
  unsigned long ldv_17_size_cnt;
  long long *ldv_17_ldv_param_3_5;
  char *ldv_17_ldv_param_1_6;
  long long *ldv_17_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 2257 
  struct file_operations *ldv_17_container = ldv_emg_alias_rx_filter_arp_filter_ops_2;
  
#line 2258 
  int ldv_17_ret = ldv_undef_int();
  
#line 2261 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 2265 
  ldv_17_ret = ldv_undef_int();
  
#line 2268 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 2269 
    ldv_17_container = data->arg0;
    
#line 2270 
    ldv_free((void *)data);
  }
  else ;
  
#line 2275 
  ldv_17_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 2276 
  tmp_1 = ldv_undef_int();
  
#line 2276 
  ldv_17_size_cnt = (unsigned long)tmp_1;
  
#line 2283 
  goto ldv_main_17;
  
#line 2285 
  __retres = (void *)0;
  
#line 2285 
  goto return_label;
  ldv_main_17: 
#line 2288 
  ;
  
#line 2291 
  tmp_3 = ldv_undef_int();
  
#line 2291 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 2294 
    ldv_17_ret = (*ldv_emg_alias_simple_open_5)(ldv_17_resource_0,ldv_17_resource_1);
    
#line 2296 
    ldv_17_ret = ldv_filter_err_code(ldv_17_ret);
    
#line 2299 
    tmp_2 = ldv_undef_int();
    
#line 2299 
    if (tmp_2 != 0) {
      
#line 2301 
      __VERIFIER_assume(ldv_17_ret == 0);
      
#line 2308 
      goto ldv_call_17;
    }
    else {
      
#line 2312 
      __VERIFIER_assume(ldv_17_ret != 0);
      
#line 2319 
      goto ldv_main_17;
    }
  }
  else {
    
#line 2324 
    ldv_free((void *)ldv_17_resource_0);
    
#line 2332 
    __retres = (void *)0;
    
#line 2332 
    goto return_label;
  }
  
#line 2335 
  __retres = (void *)0;
  
#line 2335 
  goto return_label;
  ldv_call_17: 
#line 2338 
  ;
  
#line 2341 
  tmp_4 = ldv_undef_int();
  
#line 2341 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 2342 
    ;
    
#line 2344 
    ldv_17_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 2345 
    ldv_17_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 2349 
    if (ldv_17_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 2355 
      __VERIFIER_assume(ldv_17_size_cnt <= 2147479552UL);
      
#line 2357 
      (*(ldv_17_container->write))(ldv_17_resource_1,(char const *)ldv_17_ldv_param_1_6,ldv_17_size_cnt,ldv_17_ldv_param_3_7);
    }
    else ;
    
#line 2362 
    ldv_free((void *)ldv_17_ldv_param_3_7);
    
#line 2363 
    ldv_free((void *)ldv_17_ldv_param_1_6);
    
#line 2370 
    goto ldv_call_17;
    case 2: 
#line 2373 
    ;
    
#line 2375 
    if (ldv_17_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 2377 
      (*(ldv_17_container->release))(ldv_17_resource_0,ldv_17_resource_1); else ;
    
#line 2385 
    goto ldv_main_17;
    case 3: 
#line 2388 
    ;
    
#line 2392 
    tmp_9 = ldv_undef_int();
    
#line 2392 
    if (tmp_9 != 0) 
#line 2395 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_17_resource_1,ldv_17_ldv_param_1_2,ldv_17_ldv_param_2_3);
    else {
      
#line 2401 
      ldv_17_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 2402 
      ldv_17_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 2407 
      ldv_emg_wrapper_rx_filter_arp_filter_read_3(ldv_17_resource_1,ldv_17_ldv_param_1_4,ldv_17_size_cnt,ldv_17_ldv_param_3_5);
      
#line 2411 
      ldv_free((void *)ldv_17_ldv_param_3_5);
      
#line 2412 
      ldv_free((void *)ldv_17_ldv_param_1_4);
    }
    
#line 2416 
    goto ldv_30841;
    default: 
#line 2418 
    ;
    
#line 2418 
    __VERIFIER_assume(0);
  }
  ldv_30841: 
#line 2427 
  ;
  
#line 2427 
  goto ldv_call_17;
  
#line 2429 
  __retres = (void *)0;
  return_label: 
#line 2429 
                return __retres;
}


#line 2434  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_44(void *arg0)
{
  void *__retres;
  struct file *ldv_44_resource_1;
  int ldv_44_ldv_param_2_3;
  long long ldv_44_ldv_param_1_2;
  char *ldv_44_ldv_param_1_4;
  struct inode *ldv_44_resource_0;
  unsigned long ldv_44_size_cnt;
  long long *ldv_44_ldv_param_3_5;
  char *ldv_44_ldv_param_1_6;
  long long *ldv_44_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 2445 
  struct file_operations *ldv_44_container = ldv_emg_alias_rx_rx_beacon_early_term_ops_2;
  
#line 2446 
  int ldv_44_ret = ldv_undef_int();
  
#line 2449 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 2453 
  ldv_44_ret = ldv_undef_int();
  
#line 2456 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 2457 
    ldv_44_container = data->arg0;
    
#line 2458 
    ldv_free((void *)data);
  }
  else ;
  
#line 2463 
  ldv_44_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 2464 
  tmp_1 = ldv_undef_int();
  
#line 2464 
  ldv_44_size_cnt = (unsigned long)tmp_1;
  
#line 2471 
  goto ldv_main_44;
  
#line 2473 
  __retres = (void *)0;
  
#line 2473 
  goto return_label;
  ldv_main_44: 
#line 2476 
  ;
  
#line 2479 
  tmp_3 = ldv_undef_int();
  
#line 2479 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 2482 
    ldv_44_ret = (*ldv_emg_alias_simple_open_5)(ldv_44_resource_0,ldv_44_resource_1);
    
#line 2484 
    ldv_44_ret = ldv_filter_err_code(ldv_44_ret);
    
#line 2487 
    tmp_2 = ldv_undef_int();
    
#line 2487 
    if (tmp_2 != 0) {
      
#line 2489 
      __VERIFIER_assume(ldv_44_ret == 0);
      
#line 2496 
      goto ldv_call_44;
    }
    else {
      
#line 2500 
      __VERIFIER_assume(ldv_44_ret != 0);
      
#line 2507 
      goto ldv_main_44;
    }
  }
  else {
    
#line 2512 
    ldv_free((void *)ldv_44_resource_0);
    
#line 2520 
    __retres = (void *)0;
    
#line 2520 
    goto return_label;
  }
  
#line 2523 
  __retres = (void *)0;
  
#line 2523 
  goto return_label;
  ldv_call_44: 
#line 2526 
  ;
  
#line 2529 
  tmp_4 = ldv_undef_int();
  
#line 2529 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 2530 
    ;
    
#line 2532 
    ldv_44_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 2533 
    ldv_44_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 2537 
    if (ldv_44_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 2543 
      __VERIFIER_assume(ldv_44_size_cnt <= 2147479552UL);
      
#line 2545 
      (*(ldv_44_container->write))(ldv_44_resource_1,(char const *)ldv_44_ldv_param_1_6,ldv_44_size_cnt,ldv_44_ldv_param_3_7);
    }
    else ;
    
#line 2550 
    ldv_free((void *)ldv_44_ldv_param_3_7);
    
#line 2551 
    ldv_free((void *)ldv_44_ldv_param_1_6);
    
#line 2558 
    goto ldv_call_44;
    case 2: 
#line 2561 
    ;
    
#line 2563 
    if (ldv_44_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 2565 
      (*(ldv_44_container->release))(ldv_44_resource_0,ldv_44_resource_1); else ;
    
#line 2573 
    goto ldv_main_44;
    case 3: 
#line 2576 
    ;
    
#line 2580 
    tmp_9 = ldv_undef_int();
    
#line 2580 
    if (tmp_9 != 0) 
#line 2583 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_44_resource_1,ldv_44_ldv_param_1_2,ldv_44_ldv_param_2_3);
    else {
      
#line 2589 
      ldv_44_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 2590 
      ldv_44_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 2595 
      ldv_emg_wrapper_rx_rx_beacon_early_term_read_3(ldv_44_resource_1,ldv_44_ldv_param_1_4,ldv_44_size_cnt,ldv_44_ldv_param_3_5);
      
#line 2599 
      ldv_free((void *)ldv_44_ldv_param_3_5);
      
#line 2600 
      ldv_free((void *)ldv_44_ldv_param_1_4);
    }
    
#line 2604 
    goto ldv_30863;
    default: 
#line 2606 
    ;
    
#line 2606 
    __VERIFIER_assume(0);
  }
  ldv_30863: 
#line 2615 
  ;
  
#line 2615 
  goto ldv_call_44;
  
#line 2617 
  __retres = (void *)0;
  return_label: 
#line 2617 
                return __retres;
}


#line 2622  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_51(void *arg0)
{
  void *__retres;
  struct file *ldv_51_resource_1;
  int ldv_51_ldv_param_2_3;
  long long ldv_51_ldv_param_1_2;
  char *ldv_51_ldv_param_1_4;
  struct inode *ldv_51_resource_0;
  unsigned long ldv_51_size_cnt;
  long long *ldv_51_ldv_param_3_5;
  char *ldv_51_ldv_param_1_6;
  long long *ldv_51_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 2633 
  struct file_operations *ldv_51_container = ldv_emg_alias_pwr_rcvd_awake_bcns_cnt_ops_2;
  
#line 2634 
  int ldv_51_ret = ldv_undef_int();
  
#line 2637 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 2641 
  ldv_51_ret = ldv_undef_int();
  
#line 2644 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 2645 
    ldv_51_container = data->arg0;
    
#line 2646 
    ldv_free((void *)data);
  }
  else ;
  
#line 2651 
  ldv_51_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 2652 
  tmp_1 = ldv_undef_int();
  
#line 2652 
  ldv_51_size_cnt = (unsigned long)tmp_1;
  
#line 2659 
  goto ldv_main_51;
  
#line 2661 
  __retres = (void *)0;
  
#line 2661 
  goto return_label;
  ldv_main_51: 
#line 2664 
  ;
  
#line 2667 
  tmp_3 = ldv_undef_int();
  
#line 2667 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 2670 
    ldv_51_ret = (*ldv_emg_alias_simple_open_5)(ldv_51_resource_0,ldv_51_resource_1);
    
#line 2672 
    ldv_51_ret = ldv_filter_err_code(ldv_51_ret);
    
#line 2675 
    tmp_2 = ldv_undef_int();
    
#line 2675 
    if (tmp_2 != 0) {
      
#line 2677 
      __VERIFIER_assume(ldv_51_ret == 0);
      
#line 2684 
      goto ldv_call_51;
    }
    else {
      
#line 2688 
      __VERIFIER_assume(ldv_51_ret != 0);
      
#line 2695 
      goto ldv_main_51;
    }
  }
  else {
    
#line 2700 
    ldv_free((void *)ldv_51_resource_0);
    
#line 2708 
    __retres = (void *)0;
    
#line 2708 
    goto return_label;
  }
  
#line 2711 
  __retres = (void *)0;
  
#line 2711 
  goto return_label;
  ldv_call_51: 
#line 2714 
  ;
  
#line 2717 
  tmp_4 = ldv_undef_int();
  
#line 2717 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 2718 
    ;
    
#line 2720 
    ldv_51_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 2721 
    ldv_51_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 2725 
    if (ldv_51_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 2731 
      __VERIFIER_assume(ldv_51_size_cnt <= 2147479552UL);
      
#line 2733 
      (*(ldv_51_container->write))(ldv_51_resource_1,(char const *)ldv_51_ldv_param_1_6,ldv_51_size_cnt,ldv_51_ldv_param_3_7);
    }
    else ;
    
#line 2738 
    ldv_free((void *)ldv_51_ldv_param_3_7);
    
#line 2739 
    ldv_free((void *)ldv_51_ldv_param_1_6);
    
#line 2746 
    goto ldv_call_51;
    case 2: 
#line 2749 
    ;
    
#line 2751 
    if (ldv_51_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 2753 
      (*(ldv_51_container->release))(ldv_51_resource_0,ldv_51_resource_1); else ;
    
#line 2761 
    goto ldv_main_51;
    case 3: 
#line 2764 
    ;
    
#line 2768 
    tmp_9 = ldv_undef_int();
    
#line 2768 
    if (tmp_9 != 0) 
#line 2771 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_51_resource_1,ldv_51_ldv_param_1_2,ldv_51_ldv_param_2_3);
    else {
      
#line 2777 
      ldv_51_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 2778 
      ldv_51_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 2783 
      ldv_emg_wrapper_pwr_rcvd_awake_bcns_cnt_read_3(ldv_51_resource_1,ldv_51_ldv_param_1_4,ldv_51_size_cnt,ldv_51_ldv_param_3_5);
      
#line 2787 
      ldv_free((void *)ldv_51_ldv_param_3_5);
      
#line 2788 
      ldv_free((void *)ldv_51_ldv_param_1_4);
    }
    
#line 2792 
    goto ldv_30885;
    default: 
#line 2794 
    ;
    
#line 2794 
    __VERIFIER_assume(0);
  }
  ldv_30885: 
#line 2803 
  ;
  
#line 2803 
  goto ldv_call_51;
  
#line 2805 
  __retres = (void *)0;
  return_label: 
#line 2805 
                return __retres;
}


#line 2810  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_29(void *arg0)
{
  void *__retres;
  struct file *ldv_29_resource_1;
  int ldv_29_ldv_param_2_3;
  long long ldv_29_ldv_param_1_2;
  char *ldv_29_ldv_param_1_4;
  struct inode *ldv_29_resource_0;
  unsigned long ldv_29_size_cnt;
  long long *ldv_29_ldv_param_3_5;
  char *ldv_29_ldv_param_1_6;
  long long *ldv_29_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 2821 
  struct file_operations *ldv_29_container = ldv_emg_alias_error_error_numll_frame_cts_start_ops_2;
  
#line 2822 
  int ldv_29_ret = ldv_undef_int();
  
#line 2825 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 2829 
  ldv_29_ret = ldv_undef_int();
  
#line 2832 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 2833 
    ldv_29_container = data->arg0;
    
#line 2834 
    ldv_free((void *)data);
  }
  else ;
  
#line 2839 
  ldv_29_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 2840 
  tmp_1 = ldv_undef_int();
  
#line 2840 
  ldv_29_size_cnt = (unsigned long)tmp_1;
  
#line 2847 
  goto ldv_main_29;
  
#line 2849 
  __retres = (void *)0;
  
#line 2849 
  goto return_label;
  ldv_main_29: 
#line 2852 
  ;
  
#line 2855 
  tmp_3 = ldv_undef_int();
  
#line 2855 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 2858 
    ldv_29_ret = (*ldv_emg_alias_simple_open_5)(ldv_29_resource_0,ldv_29_resource_1);
    
#line 2860 
    ldv_29_ret = ldv_filter_err_code(ldv_29_ret);
    
#line 2863 
    tmp_2 = ldv_undef_int();
    
#line 2863 
    if (tmp_2 != 0) {
      
#line 2865 
      __VERIFIER_assume(ldv_29_ret == 0);
      
#line 2872 
      goto ldv_call_29;
    }
    else {
      
#line 2876 
      __VERIFIER_assume(ldv_29_ret != 0);
      
#line 2883 
      goto ldv_main_29;
    }
  }
  else {
    
#line 2888 
    ldv_free((void *)ldv_29_resource_0);
    
#line 2896 
    __retres = (void *)0;
    
#line 2896 
    goto return_label;
  }
  
#line 2899 
  __retres = (void *)0;
  
#line 2899 
  goto return_label;
  ldv_call_29: 
#line 2902 
  ;
  
#line 2905 
  tmp_4 = ldv_undef_int();
  
#line 2905 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 2906 
    ;
    
#line 2908 
    ldv_29_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 2909 
    ldv_29_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 2913 
    if (ldv_29_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 2919 
      __VERIFIER_assume(ldv_29_size_cnt <= 2147479552UL);
      
#line 2921 
      (*(ldv_29_container->write))(ldv_29_resource_1,(char const *)ldv_29_ldv_param_1_6,ldv_29_size_cnt,ldv_29_ldv_param_3_7);
    }
    else ;
    
#line 2926 
    ldv_free((void *)ldv_29_ldv_param_3_7);
    
#line 2927 
    ldv_free((void *)ldv_29_ldv_param_1_6);
    
#line 2934 
    goto ldv_call_29;
    case 2: 
#line 2937 
    ;
    
#line 2939 
    if (ldv_29_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 2941 
      (*(ldv_29_container->release))(ldv_29_resource_0,ldv_29_resource_1); else ;
    
#line 2949 
    goto ldv_main_29;
    case 3: 
#line 2952 
    ;
    
#line 2956 
    tmp_9 = ldv_undef_int();
    
#line 2956 
    if (tmp_9 != 0) 
#line 2959 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_29_resource_1,ldv_29_ldv_param_1_2,ldv_29_ldv_param_2_3);
    else {
      
#line 2965 
      ldv_29_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 2966 
      ldv_29_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 2971 
      ldv_emg_wrapper_error_error_numll_frame_cts_start_read_3(ldv_29_resource_1,ldv_29_ldv_param_1_4,ldv_29_size_cnt,ldv_29_ldv_param_3_5);
      
#line 2975 
      ldv_free((void *)ldv_29_ldv_param_3_5);
      
#line 2976 
      ldv_free((void *)ldv_29_ldv_param_1_4);
    }
    
#line 2980 
    goto ldv_30907;
    default: 
#line 2982 
    ;
    
#line 2982 
    __VERIFIER_assume(0);
  }
  ldv_30907: 
#line 2991 
  ;
  
#line 2991 
  goto ldv_call_29;
  
#line 2993 
  __retres = (void *)0;
  return_label: 
#line 2993 
                return __retres;
}


#line 2998  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_114(void *arg0)
{
  void *__retres;
  struct file *ldv_114_resource_1;
  int ldv_114_ldv_param_2_3;
  long long ldv_114_ldv_param_1_2;
  char *ldv_114_ldv_param_1_4;
  struct inode *ldv_114_resource_0;
  unsigned long ldv_114_size_cnt;
  long long *ldv_114_ldv_param_3_5;
  char *ldv_114_ldv_param_1_6;
  long long *ldv_114_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 3009 
  struct file_operations *ldv_114_container = ldv_emg_alias_pipeline_rx_complete_stat_fifo_int_ops_2;
  
#line 3010 
  int ldv_114_ret = ldv_undef_int();
  
#line 3013 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 3017 
  ldv_114_ret = ldv_undef_int();
  
#line 3020 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 3021 
    ldv_114_container = data->arg0;
    
#line 3022 
    ldv_free((void *)data);
  }
  else ;
  
#line 3027 
  ldv_114_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 3028 
  tmp_1 = ldv_undef_int();
  
#line 3028 
  ldv_114_size_cnt = (unsigned long)tmp_1;
  
#line 3035 
  goto ldv_main_114;
  
#line 3037 
  __retres = (void *)0;
  
#line 3037 
  goto return_label;
  ldv_main_114: 
#line 3040 
  ;
  
#line 3043 
  tmp_3 = ldv_undef_int();
  
#line 3043 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 3046 
    ldv_114_ret = (*ldv_emg_alias_simple_open_5)(ldv_114_resource_0,ldv_114_resource_1);
    
#line 3048 
    ldv_114_ret = ldv_filter_err_code(ldv_114_ret);
    
#line 3051 
    tmp_2 = ldv_undef_int();
    
#line 3051 
    if (tmp_2 != 0) {
      
#line 3053 
      __VERIFIER_assume(ldv_114_ret == 0);
      
#line 3060 
      goto ldv_call_114;
    }
    else {
      
#line 3064 
      __VERIFIER_assume(ldv_114_ret != 0);
      
#line 3071 
      goto ldv_main_114;
    }
  }
  else {
    
#line 3076 
    ldv_free((void *)ldv_114_resource_0);
    
#line 3084 
    __retres = (void *)0;
    
#line 3084 
    goto return_label;
  }
  
#line 3087 
  __retres = (void *)0;
  
#line 3087 
  goto return_label;
  ldv_call_114: 
#line 3090 
  ;
  
#line 3093 
  tmp_4 = ldv_undef_int();
  
#line 3093 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 3094 
    ;
    
#line 3096 
    ldv_114_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 3097 
    ldv_114_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 3101 
    if (ldv_114_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 3107 
      __VERIFIER_assume(ldv_114_size_cnt <= 2147479552UL);
      
#line 3109 
      (*(ldv_114_container->write))(ldv_114_resource_1,(char const *)ldv_114_ldv_param_1_6,ldv_114_size_cnt,ldv_114_ldv_param_3_7);
    }
    else ;
    
#line 3114 
    ldv_free((void *)ldv_114_ldv_param_1_6);
    
#line 3115 
    ldv_free((void *)ldv_114_ldv_param_3_7);
    
#line 3122 
    goto ldv_call_114;
    case 2: 
#line 3125 
    ;
    
#line 3127 
    if (ldv_114_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 3129 
      (*(ldv_114_container->release))(ldv_114_resource_0,ldv_114_resource_1); else ;
    
#line 3137 
    goto ldv_main_114;
    case 3: 
#line 3140 
    ;
    
#line 3144 
    tmp_9 = ldv_undef_int();
    
#line 3144 
    if (tmp_9 != 0) 
#line 3147 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_114_resource_1,ldv_114_ldv_param_1_2,ldv_114_ldv_param_2_3);
    else {
      
#line 3153 
      ldv_114_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 3154 
      ldv_114_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 3159 
      ldv_emg_wrapper_pipeline_rx_complete_stat_fifo_int_read_3(ldv_114_resource_1,ldv_114_ldv_param_1_4,ldv_114_size_cnt,ldv_114_ldv_param_3_5);
      
#line 3163 
      ldv_free((void *)ldv_114_ldv_param_1_4);
      
#line 3164 
      ldv_free((void *)ldv_114_ldv_param_3_5);
    }
    
#line 3168 
    goto ldv_30929;
    default: 
#line 3170 
    ;
    
#line 3170 
    __VERIFIER_assume(0);
  }
  ldv_30929: 
#line 3179 
  ;
  
#line 3179 
  goto ldv_call_114;
  
#line 3181 
  __retres = (void *)0;
  return_label: 
#line 3181 
                return __retres;
}


#line 3186  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_37(void *arg0)
{
  void *__retres;
  struct file *ldv_37_resource_1;
  int ldv_37_ldv_param_2_3;
  long long ldv_37_ldv_param_1_2;
  char *ldv_37_ldv_param_1_4;
  struct inode *ldv_37_resource_0;
  unsigned long ldv_37_size_cnt;
  long long *ldv_37_ldv_param_3_5;
  char *ldv_37_ldv_param_1_6;
  long long *ldv_37_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 3197 
  struct file_operations *ldv_37_container = ldv_emg_alias_pwr_connection_out_of_sync_ops_2;
  
#line 3198 
  int ldv_37_ret = ldv_undef_int();
  
#line 3201 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 3205 
  ldv_37_ret = ldv_undef_int();
  
#line 3208 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 3209 
    ldv_37_container = data->arg0;
    
#line 3210 
    ldv_free((void *)data);
  }
  else ;
  
#line 3215 
  ldv_37_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 3216 
  tmp_1 = ldv_undef_int();
  
#line 3216 
  ldv_37_size_cnt = (unsigned long)tmp_1;
  
#line 3223 
  goto ldv_main_37;
  
#line 3225 
  __retres = (void *)0;
  
#line 3225 
  goto return_label;
  ldv_main_37: 
#line 3228 
  ;
  
#line 3231 
  tmp_3 = ldv_undef_int();
  
#line 3231 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 3234 
    ldv_37_ret = (*ldv_emg_alias_simple_open_5)(ldv_37_resource_0,ldv_37_resource_1);
    
#line 3236 
    ldv_37_ret = ldv_filter_err_code(ldv_37_ret);
    
#line 3239 
    tmp_2 = ldv_undef_int();
    
#line 3239 
    if (tmp_2 != 0) {
      
#line 3241 
      __VERIFIER_assume(ldv_37_ret == 0);
      
#line 3248 
      goto ldv_call_37;
    }
    else {
      
#line 3252 
      __VERIFIER_assume(ldv_37_ret != 0);
      
#line 3259 
      goto ldv_main_37;
    }
  }
  else {
    
#line 3264 
    ldv_free((void *)ldv_37_resource_0);
    
#line 3272 
    __retres = (void *)0;
    
#line 3272 
    goto return_label;
  }
  
#line 3275 
  __retres = (void *)0;
  
#line 3275 
  goto return_label;
  ldv_call_37: 
#line 3278 
  ;
  
#line 3281 
  tmp_4 = ldv_undef_int();
  
#line 3281 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 3282 
    ;
    
#line 3284 
    ldv_37_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 3285 
    ldv_37_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 3289 
    if (ldv_37_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 3295 
      __VERIFIER_assume(ldv_37_size_cnt <= 2147479552UL);
      
#line 3297 
      (*(ldv_37_container->write))(ldv_37_resource_1,(char const *)ldv_37_ldv_param_1_6,ldv_37_size_cnt,ldv_37_ldv_param_3_7);
    }
    else ;
    
#line 3302 
    ldv_free((void *)ldv_37_ldv_param_1_6);
    
#line 3303 
    ldv_free((void *)ldv_37_ldv_param_3_7);
    
#line 3310 
    goto ldv_call_37;
    case 2: 
#line 3313 
    ;
    
#line 3315 
    if (ldv_37_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 3317 
      (*(ldv_37_container->release))(ldv_37_resource_0,ldv_37_resource_1); else ;
    
#line 3325 
    goto ldv_main_37;
    case 3: 
#line 3328 
    ;
    
#line 3332 
    tmp_9 = ldv_undef_int();
    
#line 3332 
    if (tmp_9 != 0) 
#line 3335 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_37_resource_1,ldv_37_ldv_param_1_2,ldv_37_ldv_param_2_3);
    else {
      
#line 3341 
      ldv_37_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 3342 
      ldv_37_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 3347 
      ldv_emg_wrapper_pwr_connection_out_of_sync_read_3(ldv_37_resource_1,ldv_37_ldv_param_1_4,ldv_37_size_cnt,ldv_37_ldv_param_3_5);
      
#line 3351 
      ldv_free((void *)ldv_37_ldv_param_3_5);
      
#line 3352 
      ldv_free((void *)ldv_37_ldv_param_1_4);
    }
    
#line 3356 
    goto ldv_30951;
    default: 
#line 3358 
    ;
    
#line 3358 
    __VERIFIER_assume(0);
  }
  ldv_30951: 
#line 3367 
  ;
  
#line 3367 
  goto ldv_call_37;
  
#line 3369 
  __retres = (void *)0;
  return_label: 
#line 3369 
                return __retres;
}


#line 3374  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_83(void *arg0)
{
  void *__retres;
  struct file *ldv_83_resource_1;
  int ldv_83_ldv_param_2_3;
  long long ldv_83_ldv_param_1_2;
  char *ldv_83_ldv_param_1_4;
  struct inode *ldv_83_resource_0;
  unsigned long ldv_83_size_cnt;
  long long *ldv_83_ldv_param_3_5;
  char *ldv_83_ldv_param_1_6;
  long long *ldv_83_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 3385 
  struct file_operations *ldv_83_container = ldv_emg_alias_tx_tx_starts_ops_2;
  
#line 3386 
  int ldv_83_ret = ldv_undef_int();
  
#line 3389 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 3393 
  ldv_83_ret = ldv_undef_int();
  
#line 3396 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 3397 
    ldv_83_container = data->arg0;
    
#line 3398 
    ldv_free((void *)data);
  }
  else ;
  
#line 3403 
  ldv_83_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 3404 
  tmp_1 = ldv_undef_int();
  
#line 3404 
  ldv_83_size_cnt = (unsigned long)tmp_1;
  
#line 3411 
  goto ldv_main_83;
  
#line 3413 
  __retres = (void *)0;
  
#line 3413 
  goto return_label;
  ldv_main_83: 
#line 3416 
  ;
  
#line 3419 
  tmp_3 = ldv_undef_int();
  
#line 3419 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 3422 
    ldv_83_ret = (*ldv_emg_alias_simple_open_5)(ldv_83_resource_0,ldv_83_resource_1);
    
#line 3424 
    ldv_83_ret = ldv_filter_err_code(ldv_83_ret);
    
#line 3427 
    tmp_2 = ldv_undef_int();
    
#line 3427 
    if (tmp_2 != 0) {
      
#line 3429 
      __VERIFIER_assume(ldv_83_ret == 0);
      
#line 3436 
      goto ldv_call_83;
    }
    else {
      
#line 3440 
      __VERIFIER_assume(ldv_83_ret != 0);
      
#line 3447 
      goto ldv_main_83;
    }
  }
  else {
    
#line 3452 
    ldv_free((void *)ldv_83_resource_0);
    
#line 3460 
    __retres = (void *)0;
    
#line 3460 
    goto return_label;
  }
  
#line 3463 
  __retres = (void *)0;
  
#line 3463 
  goto return_label;
  ldv_call_83: 
#line 3466 
  ;
  
#line 3469 
  tmp_4 = ldv_undef_int();
  
#line 3469 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 3470 
    ;
    
#line 3472 
    ldv_83_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 3473 
    ldv_83_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 3477 
    if (ldv_83_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 3483 
      __VERIFIER_assume(ldv_83_size_cnt <= 2147479552UL);
      
#line 3485 
      (*(ldv_83_container->write))(ldv_83_resource_1,(char const *)ldv_83_ldv_param_1_6,ldv_83_size_cnt,ldv_83_ldv_param_3_7);
    }
    else ;
    
#line 3490 
    ldv_free((void *)ldv_83_ldv_param_1_6);
    
#line 3491 
    ldv_free((void *)ldv_83_ldv_param_3_7);
    
#line 3498 
    goto ldv_call_83;
    case 2: 
#line 3501 
    ;
    
#line 3503 
    if (ldv_83_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 3505 
      (*(ldv_83_container->release))(ldv_83_resource_0,ldv_83_resource_1); else ;
    
#line 3513 
    goto ldv_main_83;
    case 3: 
#line 3516 
    ;
    
#line 3520 
    tmp_9 = ldv_undef_int();
    
#line 3520 
    if (tmp_9 != 0) 
#line 3523 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_83_resource_1,ldv_83_ldv_param_1_2,ldv_83_ldv_param_2_3);
    else {
      
#line 3529 
      ldv_83_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 3530 
      ldv_83_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 3535 
      ldv_emg_wrapper_tx_tx_starts_read_3(ldv_83_resource_1,ldv_83_ldv_param_1_4,ldv_83_size_cnt,ldv_83_ldv_param_3_5);
      
#line 3539 
      ldv_free((void *)ldv_83_ldv_param_3_5);
      
#line 3540 
      ldv_free((void *)ldv_83_ldv_param_1_4);
    }
    
#line 3544 
    goto ldv_30973;
    default: 
#line 3546 
    ;
    
#line 3546 
    __VERIFIER_assume(0);
  }
  ldv_30973: 
#line 3555 
  ;
  
#line 3555 
  goto ldv_call_83;
  
#line 3557 
  __retres = (void *)0;
  return_label: 
#line 3557 
                return __retres;
}


#line 3562  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_10(void *arg0)
{
  void *__retres;
  struct file *ldv_10_resource_1;
  int ldv_10_ldv_param_2_3;
  long long ldv_10_ldv_param_1_2;
  char *ldv_10_ldv_param_1_4;
  struct inode *ldv_10_resource_0;
  unsigned long ldv_10_size_cnt;
  long long *ldv_10_ldv_param_3_5;
  char *ldv_10_ldv_param_1_6;
  long long *ldv_10_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 3573 
  struct file_operations *ldv_10_container = ldv_emg_alias_isr_irqs_ops_2;
  
#line 3574 
  int ldv_10_ret = ldv_undef_int();
  
#line 3577 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 3581 
  ldv_10_ret = ldv_undef_int();
  
#line 3584 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 3585 
    ldv_10_container = data->arg0;
    
#line 3586 
    ldv_free((void *)data);
  }
  else ;
  
#line 3591 
  ldv_10_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 3592 
  tmp_1 = ldv_undef_int();
  
#line 3592 
  ldv_10_size_cnt = (unsigned long)tmp_1;
  
#line 3599 
  goto ldv_main_10;
  
#line 3601 
  __retres = (void *)0;
  
#line 3601 
  goto return_label;
  ldv_main_10: 
#line 3604 
  ;
  
#line 3607 
  tmp_3 = ldv_undef_int();
  
#line 3607 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 3610 
    ldv_10_ret = (*ldv_emg_alias_simple_open_5)(ldv_10_resource_0,ldv_10_resource_1);
    
#line 3612 
    ldv_10_ret = ldv_filter_err_code(ldv_10_ret);
    
#line 3615 
    tmp_2 = ldv_undef_int();
    
#line 3615 
    if (tmp_2 != 0) {
      
#line 3617 
      __VERIFIER_assume(ldv_10_ret == 0);
      
#line 3624 
      goto ldv_call_10;
    }
    else {
      
#line 3628 
      __VERIFIER_assume(ldv_10_ret != 0);
      
#line 3635 
      goto ldv_main_10;
    }
  }
  else {
    
#line 3640 
    ldv_free((void *)ldv_10_resource_0);
    
#line 3648 
    __retres = (void *)0;
    
#line 3648 
    goto return_label;
  }
  
#line 3651 
  __retres = (void *)0;
  
#line 3651 
  goto return_label;
  ldv_call_10: 
#line 3654 
  ;
  
#line 3657 
  tmp_4 = ldv_undef_int();
  
#line 3657 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 3658 
    ;
    
#line 3660 
    ldv_10_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 3661 
    ldv_10_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 3665 
    if (ldv_10_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 3671 
      __VERIFIER_assume(ldv_10_size_cnt <= 2147479552UL);
      
#line 3673 
      (*(ldv_10_container->write))(ldv_10_resource_1,(char const *)ldv_10_ldv_param_1_6,ldv_10_size_cnt,ldv_10_ldv_param_3_7);
    }
    else ;
    
#line 3678 
    ldv_free((void *)ldv_10_ldv_param_1_6);
    
#line 3679 
    ldv_free((void *)ldv_10_ldv_param_3_7);
    
#line 3686 
    goto ldv_call_10;
    case 2: 
#line 3689 
    ;
    
#line 3691 
    if (ldv_10_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 3693 
      (*(ldv_10_container->release))(ldv_10_resource_0,ldv_10_resource_1); else ;
    
#line 3701 
    goto ldv_main_10;
    case 3: 
#line 3704 
    ;
    
#line 3708 
    tmp_9 = ldv_undef_int();
    
#line 3708 
    if (tmp_9 != 0) 
#line 3711 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_10_resource_1,ldv_10_ldv_param_1_2,ldv_10_ldv_param_2_3);
    else {
      
#line 3717 
      ldv_10_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 3718 
      ldv_10_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 3723 
      ldv_emg_wrapper_isr_irqs_read_3(ldv_10_resource_1,ldv_10_ldv_param_1_4,ldv_10_size_cnt,ldv_10_ldv_param_3_5);
      
#line 3727 
      ldv_free((void *)ldv_10_ldv_param_3_5);
      
#line 3728 
      ldv_free((void *)ldv_10_ldv_param_1_4);
    }
    
#line 3732 
    goto ldv_30995;
    default: 
#line 3734 
    ;
    
#line 3734 
    __VERIFIER_assume(0);
  }
  ldv_30995: 
#line 3743 
  ;
  
#line 3743 
  goto ldv_call_10;
  
#line 3745 
  __retres = (void *)0;
  return_label: 
#line 3745 
                return __retres;
}


#line 3750  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_40(void *arg0)
{
  void *__retres;
  struct file *ldv_40_resource_1;
  int ldv_40_ldv_param_2_3;
  long long ldv_40_ldv_param_1_2;
  char *ldv_40_ldv_param_1_4;
  struct inode *ldv_40_resource_0;
  unsigned long ldv_40_size_cnt;
  long long *ldv_40_ldv_param_3_5;
  char *ldv_40_ldv_param_1_6;
  long long *ldv_40_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 3761 
  struct file_operations *ldv_40_container = ldv_emg_alias_tx_tx_template_programmed_ops_2;
  
#line 3762 
  int ldv_40_ret = ldv_undef_int();
  
#line 3765 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 3769 
  ldv_40_ret = ldv_undef_int();
  
#line 3772 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 3773 
    ldv_40_container = data->arg0;
    
#line 3774 
    ldv_free((void *)data);
  }
  else ;
  
#line 3779 
  ldv_40_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 3780 
  tmp_1 = ldv_undef_int();
  
#line 3780 
  ldv_40_size_cnt = (unsigned long)tmp_1;
  
#line 3787 
  goto ldv_main_40;
  
#line 3789 
  __retres = (void *)0;
  
#line 3789 
  goto return_label;
  ldv_main_40: 
#line 3792 
  ;
  
#line 3795 
  tmp_3 = ldv_undef_int();
  
#line 3795 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 3798 
    ldv_40_ret = (*ldv_emg_alias_simple_open_5)(ldv_40_resource_0,ldv_40_resource_1);
    
#line 3800 
    ldv_40_ret = ldv_filter_err_code(ldv_40_ret);
    
#line 3803 
    tmp_2 = ldv_undef_int();
    
#line 3803 
    if (tmp_2 != 0) {
      
#line 3805 
      __VERIFIER_assume(ldv_40_ret == 0);
      
#line 3812 
      goto ldv_call_40;
    }
    else {
      
#line 3816 
      __VERIFIER_assume(ldv_40_ret != 0);
      
#line 3823 
      goto ldv_main_40;
    }
  }
  else {
    
#line 3828 
    ldv_free((void *)ldv_40_resource_0);
    
#line 3836 
    __retres = (void *)0;
    
#line 3836 
    goto return_label;
  }
  
#line 3839 
  __retres = (void *)0;
  
#line 3839 
  goto return_label;
  ldv_call_40: 
#line 3842 
  ;
  
#line 3845 
  tmp_4 = ldv_undef_int();
  
#line 3845 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 3846 
    ;
    
#line 3848 
    ldv_40_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 3849 
    ldv_40_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 3853 
    if (ldv_40_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 3859 
      __VERIFIER_assume(ldv_40_size_cnt <= 2147479552UL);
      
#line 3861 
      (*(ldv_40_container->write))(ldv_40_resource_1,(char const *)ldv_40_ldv_param_1_6,ldv_40_size_cnt,ldv_40_ldv_param_3_7);
    }
    else ;
    
#line 3866 
    ldv_free((void *)ldv_40_ldv_param_3_7);
    
#line 3867 
    ldv_free((void *)ldv_40_ldv_param_1_6);
    
#line 3874 
    goto ldv_call_40;
    case 2: 
#line 3877 
    ;
    
#line 3879 
    if (ldv_40_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 3881 
      (*(ldv_40_container->release))(ldv_40_resource_0,ldv_40_resource_1); else ;
    
#line 3889 
    goto ldv_main_40;
    case 3: 
#line 3892 
    ;
    
#line 3896 
    tmp_9 = ldv_undef_int();
    
#line 3896 
    if (tmp_9 != 0) 
#line 3899 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_40_resource_1,ldv_40_ldv_param_1_2,ldv_40_ldv_param_2_3);
    else {
      
#line 3905 
      ldv_40_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 3906 
      ldv_40_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 3911 
      ldv_emg_wrapper_tx_tx_template_programmed_read_3(ldv_40_resource_1,ldv_40_ldv_param_1_4,ldv_40_size_cnt,ldv_40_ldv_param_3_5);
      
#line 3915 
      ldv_free((void *)ldv_40_ldv_param_3_5);
      
#line 3916 
      ldv_free((void *)ldv_40_ldv_param_1_4);
    }
    
#line 3920 
    goto ldv_31017;
    default: 
#line 3922 
    ;
    
#line 3922 
    __VERIFIER_assume(0);
  }
  ldv_31017: 
#line 3931 
  ;
  
#line 3931 
  goto ldv_call_40;
  
#line 3933 
  __retres = (void *)0;
  return_label: 
#line 3933 
                return __retres;
}


#line 3938  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_initialization_1(void *arg0)
{
  void *__retres;
  int ldv_1_ret;
  int tmp;
  
#line 3945 
  ldv_1_ret = ldv_emg_wl18xx_driver_init();
  
#line 3946 
  ldv_1_ret = ldv_post_init(ldv_1_ret);
  
#line 3949 
  tmp = ldv_undef_int();
  
#line 3949 
  if (tmp != 0) {
    
#line 3951 
    __VERIFIER_assume(ldv_1_ret != 0);
    
#line 3955 
    __retres = (void *)0;
    
#line 3955 
    goto return_label;
  }
  else {
    
#line 3959 
    __VERIFIER_assume(ldv_1_ret == 0);
    
#line 3964 
    ldv_emg_wl18xx_driver_exit();
    
#line 3968 
    __retres = (void *)0;
    
#line 3968 
    goto return_label;
  }
  
#line 3971 
  __retres = (void *)0;
  return_label: 
#line 3971 
                return __retres;
}


#line 3976  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_65(void *arg0)
{
  void *__retres;
  struct file *ldv_65_resource_1;
  int ldv_65_ldv_param_2_3;
  long long ldv_65_ldv_param_1_2;
  char *ldv_65_ldv_param_1_4;
  struct inode *ldv_65_resource_0;
  unsigned long ldv_65_size_cnt;
  long long *ldv_65_ldv_param_3_5;
  char *ldv_65_ldv_param_1_6;
  long long *ldv_65_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 3987 
  struct file_operations *ldv_65_container = ldv_emg_alias_pipeline_tcp_rx_stat_fifo_int_ops_2;
  
#line 3988 
  int ldv_65_ret = ldv_undef_int();
  
#line 3991 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 3995 
  ldv_65_ret = ldv_undef_int();
  
#line 3998 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 3999 
    ldv_65_container = data->arg0;
    
#line 4000 
    ldv_free((void *)data);
  }
  else ;
  
#line 4005 
  ldv_65_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 4006 
  tmp_1 = ldv_undef_int();
  
#line 4006 
  ldv_65_size_cnt = (unsigned long)tmp_1;
  
#line 4013 
  goto ldv_main_65;
  
#line 4015 
  __retres = (void *)0;
  
#line 4015 
  goto return_label;
  ldv_main_65: 
#line 4018 
  ;
  
#line 4021 
  tmp_3 = ldv_undef_int();
  
#line 4021 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 4024 
    ldv_65_ret = (*ldv_emg_alias_simple_open_5)(ldv_65_resource_0,ldv_65_resource_1);
    
#line 4026 
    ldv_65_ret = ldv_filter_err_code(ldv_65_ret);
    
#line 4029 
    tmp_2 = ldv_undef_int();
    
#line 4029 
    if (tmp_2 != 0) {
      
#line 4031 
      __VERIFIER_assume(ldv_65_ret == 0);
      
#line 4038 
      goto ldv_call_65;
    }
    else {
      
#line 4042 
      __VERIFIER_assume(ldv_65_ret != 0);
      
#line 4049 
      goto ldv_main_65;
    }
  }
  else {
    
#line 4054 
    ldv_free((void *)ldv_65_resource_0);
    
#line 4062 
    __retres = (void *)0;
    
#line 4062 
    goto return_label;
  }
  
#line 4065 
  __retres = (void *)0;
  
#line 4065 
  goto return_label;
  ldv_call_65: 
#line 4068 
  ;
  
#line 4071 
  tmp_4 = ldv_undef_int();
  
#line 4071 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 4072 
    ;
    
#line 4074 
    ldv_65_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 4075 
    ldv_65_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 4079 
    if (ldv_65_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 4085 
      __VERIFIER_assume(ldv_65_size_cnt <= 2147479552UL);
      
#line 4087 
      (*(ldv_65_container->write))(ldv_65_resource_1,(char const *)ldv_65_ldv_param_1_6,ldv_65_size_cnt,ldv_65_ldv_param_3_7);
    }
    else ;
    
#line 4092 
    ldv_free((void *)ldv_65_ldv_param_1_6);
    
#line 4093 
    ldv_free((void *)ldv_65_ldv_param_3_7);
    
#line 4100 
    goto ldv_call_65;
    case 2: 
#line 4103 
    ;
    
#line 4105 
    if (ldv_65_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 4107 
      (*(ldv_65_container->release))(ldv_65_resource_0,ldv_65_resource_1); else ;
    
#line 4115 
    goto ldv_main_65;
    case 3: 
#line 4118 
    ;
    
#line 4122 
    tmp_9 = ldv_undef_int();
    
#line 4122 
    if (tmp_9 != 0) 
#line 4125 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_65_resource_1,ldv_65_ldv_param_1_2,ldv_65_ldv_param_2_3);
    else {
      
#line 4131 
      ldv_65_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 4132 
      ldv_65_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 4137 
      ldv_emg_wrapper_pipeline_tcp_rx_stat_fifo_int_read_3(ldv_65_resource_1,ldv_65_ldv_param_1_4,ldv_65_size_cnt,ldv_65_ldv_param_3_5);
      
#line 4141 
      ldv_free((void *)ldv_65_ldv_param_1_4);
      
#line 4142 
      ldv_free((void *)ldv_65_ldv_param_3_5);
    }
    
#line 4146 
    goto ldv_31043;
    default: 
#line 4148 
    ;
    
#line 4148 
    __VERIFIER_assume(0);
  }
  ldv_31043: 
#line 4157 
  ;
  
#line 4157 
  goto ldv_call_65;
  
#line 4159 
  __retres = (void *)0;
  return_label: 
#line 4159 
                return __retres;
}


#line 4164  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_107(void *arg0)
{
  void *__retres;
  struct file *ldv_107_resource_1;
  int ldv_107_ldv_param_2_3;
  long long ldv_107_ldv_param_1_2;
  char *ldv_107_ldv_param_1_4;
  struct inode *ldv_107_resource_0;
  unsigned long ldv_107_size_cnt;
  long long *ldv_107_ldv_param_3_5;
  char *ldv_107_ldv_param_1_6;
  long long *ldv_107_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 4175 
  struct file_operations *ldv_107_container = ldv_emg_alias_rx_filter_dup_filter_ops_2;
  
#line 4176 
  int ldv_107_ret = ldv_undef_int();
  
#line 4179 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 4183 
  ldv_107_ret = ldv_undef_int();
  
#line 4186 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 4187 
    ldv_107_container = data->arg0;
    
#line 4188 
    ldv_free((void *)data);
  }
  else ;
  
#line 4193 
  ldv_107_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 4194 
  tmp_1 = ldv_undef_int();
  
#line 4194 
  ldv_107_size_cnt = (unsigned long)tmp_1;
  
#line 4201 
  goto ldv_main_107;
  
#line 4203 
  __retres = (void *)0;
  
#line 4203 
  goto return_label;
  ldv_main_107: 
#line 4206 
  ;
  
#line 4209 
  tmp_3 = ldv_undef_int();
  
#line 4209 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 4212 
    ldv_107_ret = (*ldv_emg_alias_simple_open_5)(ldv_107_resource_0,ldv_107_resource_1);
    
#line 4214 
    ldv_107_ret = ldv_filter_err_code(ldv_107_ret);
    
#line 4217 
    tmp_2 = ldv_undef_int();
    
#line 4217 
    if (tmp_2 != 0) {
      
#line 4219 
      __VERIFIER_assume(ldv_107_ret == 0);
      
#line 4226 
      goto ldv_call_107;
    }
    else {
      
#line 4230 
      __VERIFIER_assume(ldv_107_ret != 0);
      
#line 4237 
      goto ldv_main_107;
    }
  }
  else {
    
#line 4242 
    ldv_free((void *)ldv_107_resource_0);
    
#line 4250 
    __retres = (void *)0;
    
#line 4250 
    goto return_label;
  }
  
#line 4253 
  __retres = (void *)0;
  
#line 4253 
  goto return_label;
  ldv_call_107: 
#line 4256 
  ;
  
#line 4259 
  tmp_4 = ldv_undef_int();
  
#line 4259 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 4260 
    ;
    
#line 4262 
    ldv_107_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 4263 
    ldv_107_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 4267 
    if (ldv_107_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 4273 
      __VERIFIER_assume(ldv_107_size_cnt <= 2147479552UL);
      
#line 4275 
      (*(ldv_107_container->write))(ldv_107_resource_1,(char const *)ldv_107_ldv_param_1_6,ldv_107_size_cnt,ldv_107_ldv_param_3_7);
    }
    else ;
    
#line 4280 
    ldv_free((void *)ldv_107_ldv_param_1_6);
    
#line 4281 
    ldv_free((void *)ldv_107_ldv_param_3_7);
    
#line 4288 
    goto ldv_call_107;
    case 2: 
#line 4291 
    ;
    
#line 4293 
    if (ldv_107_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 4295 
      (*(ldv_107_container->release))(ldv_107_resource_0,ldv_107_resource_1); else ;
    
#line 4303 
    goto ldv_main_107;
    case 3: 
#line 4306 
    ;
    
#line 4310 
    tmp_9 = ldv_undef_int();
    
#line 4310 
    if (tmp_9 != 0) 
#line 4313 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_107_resource_1,ldv_107_ldv_param_1_2,ldv_107_ldv_param_2_3);
    else {
      
#line 4319 
      ldv_107_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 4320 
      ldv_107_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 4325 
      ldv_emg_wrapper_rx_filter_dup_filter_read_3(ldv_107_resource_1,ldv_107_ldv_param_1_4,ldv_107_size_cnt,ldv_107_ldv_param_3_5);
      
#line 4329 
      ldv_free((void *)ldv_107_ldv_param_1_4);
      
#line 4330 
      ldv_free((void *)ldv_107_ldv_param_3_5);
    }
    
#line 4334 
    goto ldv_31065;
    default: 
#line 4336 
    ;
    
#line 4336 
    __VERIFIER_assume(0);
  }
  ldv_31065: 
#line 4345 
  ;
  
#line 4345 
  goto ldv_call_107;
  
#line 4347 
  __retres = (void *)0;
  return_label: 
#line 4347 
                return __retres;
}


#line 4352  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_93(void *arg0)
{
  void *__retres;
  struct file *ldv_93_resource_1;
  int ldv_93_ldv_param_2_3;
  long long ldv_93_ldv_param_1_2;
  char *ldv_93_ldv_param_1_4;
  struct inode *ldv_93_resource_0;
  unsigned long ldv_93_size_cnt;
  long long *ldv_93_ldv_param_3_5;
  char *ldv_93_ldv_param_1_6;
  long long *ldv_93_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 4363 
  struct file_operations *ldv_93_container = ldv_emg_alias_ps_poll_ps_poll_timeouts_ops_2;
  
#line 4364 
  int ldv_93_ret = ldv_undef_int();
  
#line 4367 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 4371 
  ldv_93_ret = ldv_undef_int();
  
#line 4374 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 4375 
    ldv_93_container = data->arg0;
    
#line 4376 
    ldv_free((void *)data);
  }
  else ;
  
#line 4381 
  ldv_93_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 4382 
  tmp_1 = ldv_undef_int();
  
#line 4382 
  ldv_93_size_cnt = (unsigned long)tmp_1;
  
#line 4389 
  goto ldv_main_93;
  
#line 4391 
  __retres = (void *)0;
  
#line 4391 
  goto return_label;
  ldv_main_93: 
#line 4394 
  ;
  
#line 4397 
  tmp_3 = ldv_undef_int();
  
#line 4397 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 4400 
    ldv_93_ret = (*ldv_emg_alias_simple_open_5)(ldv_93_resource_0,ldv_93_resource_1);
    
#line 4402 
    ldv_93_ret = ldv_filter_err_code(ldv_93_ret);
    
#line 4405 
    tmp_2 = ldv_undef_int();
    
#line 4405 
    if (tmp_2 != 0) {
      
#line 4407 
      __VERIFIER_assume(ldv_93_ret == 0);
      
#line 4414 
      goto ldv_call_93;
    }
    else {
      
#line 4418 
      __VERIFIER_assume(ldv_93_ret != 0);
      
#line 4425 
      goto ldv_main_93;
    }
  }
  else {
    
#line 4430 
    ldv_free((void *)ldv_93_resource_0);
    
#line 4438 
    __retres = (void *)0;
    
#line 4438 
    goto return_label;
  }
  
#line 4441 
  __retres = (void *)0;
  
#line 4441 
  goto return_label;
  ldv_call_93: 
#line 4444 
  ;
  
#line 4447 
  tmp_4 = ldv_undef_int();
  
#line 4447 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 4448 
    ;
    
#line 4450 
    ldv_93_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 4451 
    ldv_93_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 4455 
    if (ldv_93_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 4461 
      __VERIFIER_assume(ldv_93_size_cnt <= 2147479552UL);
      
#line 4463 
      (*(ldv_93_container->write))(ldv_93_resource_1,(char const *)ldv_93_ldv_param_1_6,ldv_93_size_cnt,ldv_93_ldv_param_3_7);
    }
    else ;
    
#line 4468 
    ldv_free((void *)ldv_93_ldv_param_1_6);
    
#line 4469 
    ldv_free((void *)ldv_93_ldv_param_3_7);
    
#line 4476 
    goto ldv_call_93;
    case 2: 
#line 4479 
    ;
    
#line 4481 
    if (ldv_93_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 4483 
      (*(ldv_93_container->release))(ldv_93_resource_0,ldv_93_resource_1); else ;
    
#line 4491 
    goto ldv_main_93;
    case 3: 
#line 4494 
    ;
    
#line 4498 
    tmp_9 = ldv_undef_int();
    
#line 4498 
    if (tmp_9 != 0) 
#line 4501 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_93_resource_1,ldv_93_ldv_param_1_2,ldv_93_ldv_param_2_3);
    else {
      
#line 4507 
      ldv_93_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 4508 
      ldv_93_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 4513 
      ldv_emg_wrapper_ps_poll_ps_poll_timeouts_read_3(ldv_93_resource_1,ldv_93_ldv_param_1_4,ldv_93_size_cnt,ldv_93_ldv_param_3_5);
      
#line 4517 
      ldv_free((void *)ldv_93_ldv_param_3_5);
      
#line 4518 
      ldv_free((void *)ldv_93_ldv_param_1_4);
    }
    
#line 4522 
    goto ldv_31087;
    default: 
#line 4524 
    ;
    
#line 4524 
    __VERIFIER_assume(0);
  }
  ldv_31087: 
#line 4533 
  ;
  
#line 4533 
  goto ldv_call_93;
  
#line 4535 
  __retres = (void *)0;
  return_label: 
#line 4535 
                return __retres;
}


#line 4540  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_111(void *arg0)
{
  void *__retres;
  struct file *ldv_111_resource_1;
  int ldv_111_ldv_param_2_3;
  long long ldv_111_ldv_param_1_2;
  char *ldv_111_ldv_param_1_4;
  struct inode *ldv_111_resource_0;
  unsigned long ldv_111_size_cnt;
  long long *ldv_111_ldv_param_3_5;
  char *ldv_111_ldv_param_1_6;
  long long *ldv_111_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 4551 
  struct file_operations *ldv_111_container = ldv_emg_alias_rx_rx_checksum_result_ops_2;
  
#line 4552 
  int ldv_111_ret = ldv_undef_int();
  
#line 4555 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 4559 
  ldv_111_ret = ldv_undef_int();
  
#line 4562 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 4563 
    ldv_111_container = data->arg0;
    
#line 4564 
    ldv_free((void *)data);
  }
  else ;
  
#line 4569 
  ldv_111_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 4570 
  tmp_1 = ldv_undef_int();
  
#line 4570 
  ldv_111_size_cnt = (unsigned long)tmp_1;
  
#line 4577 
  goto ldv_main_111;
  
#line 4579 
  __retres = (void *)0;
  
#line 4579 
  goto return_label;
  ldv_main_111: 
#line 4582 
  ;
  
#line 4585 
  tmp_3 = ldv_undef_int();
  
#line 4585 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 4588 
    ldv_111_ret = (*ldv_emg_alias_simple_open_5)(ldv_111_resource_0,ldv_111_resource_1);
    
#line 4590 
    ldv_111_ret = ldv_filter_err_code(ldv_111_ret);
    
#line 4593 
    tmp_2 = ldv_undef_int();
    
#line 4593 
    if (tmp_2 != 0) {
      
#line 4595 
      __VERIFIER_assume(ldv_111_ret == 0);
      
#line 4602 
      goto ldv_call_111;
    }
    else {
      
#line 4606 
      __VERIFIER_assume(ldv_111_ret != 0);
      
#line 4613 
      goto ldv_main_111;
    }
  }
  else {
    
#line 4618 
    ldv_free((void *)ldv_111_resource_0);
    
#line 4626 
    __retres = (void *)0;
    
#line 4626 
    goto return_label;
  }
  
#line 4629 
  __retres = (void *)0;
  
#line 4629 
  goto return_label;
  ldv_call_111: 
#line 4632 
  ;
  
#line 4635 
  tmp_4 = ldv_undef_int();
  
#line 4635 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 4636 
    ;
    
#line 4638 
    ldv_111_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 4639 
    ldv_111_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 4643 
    if (ldv_111_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 4649 
      __VERIFIER_assume(ldv_111_size_cnt <= 2147479552UL);
      
#line 4651 
      (*(ldv_111_container->write))(ldv_111_resource_1,(char const *)ldv_111_ldv_param_1_6,ldv_111_size_cnt,ldv_111_ldv_param_3_7);
    }
    else ;
    
#line 4656 
    ldv_free((void *)ldv_111_ldv_param_1_6);
    
#line 4657 
    ldv_free((void *)ldv_111_ldv_param_3_7);
    
#line 4664 
    goto ldv_call_111;
    case 2: 
#line 4667 
    ;
    
#line 4669 
    if (ldv_111_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 4671 
      (*(ldv_111_container->release))(ldv_111_resource_0,ldv_111_resource_1); else ;
    
#line 4679 
    goto ldv_main_111;
    case 3: 
#line 4682 
    ;
    
#line 4686 
    tmp_9 = ldv_undef_int();
    
#line 4686 
    if (tmp_9 != 0) 
#line 4689 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_111_resource_1,ldv_111_ldv_param_1_2,ldv_111_ldv_param_2_3);
    else {
      
#line 4695 
      ldv_111_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 4696 
      ldv_111_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 4701 
      ldv_emg_wrapper_rx_rx_checksum_result_read_3(ldv_111_resource_1,ldv_111_ldv_param_1_4,ldv_111_size_cnt,ldv_111_ldv_param_3_5);
      
#line 4705 
      ldv_free((void *)ldv_111_ldv_param_3_5);
      
#line 4706 
      ldv_free((void *)ldv_111_ldv_param_1_4);
    }
    
#line 4710 
    goto ldv_31109;
    default: 
#line 4712 
    ;
    
#line 4712 
    __VERIFIER_assume(0);
  }
  ldv_31109: 
#line 4721 
  ;
  
#line 4721 
  goto ldv_call_111;
  
#line 4723 
  __retres = (void *)0;
  return_label: 
#line 4723 
                return __retres;
}


#line 4728  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_register_2_3(struct platform_driver *arg0)
{
  int ret;
  struct ldv_struct_platform_instance_108 *cf_arg_108;
  int tmp;
  
#line 4731 
  tmp = ldv_undef_int();
  
#line 4731 
  switch (tmp) {
    case 0: 
#line 4732 
    ;
    
#line 4733 
    cf_arg_108 = (struct ldv_struct_platform_instance_108 *)ldv_xmalloc(16UL);
    
#line 4734 
    cf_arg_108->arg0 = arg0;
    
#line 4735 
    ret = pthread_create(& ldv_thread_108,(pthread_attr_t const *)0,& ldv_platform_instance_108,(void *)cf_arg_108);
    
#line 4736 
    __VERIFIER_assume(ret == 0);
    
#line 4737 
    goto ldv_31117;
    default: 
#line 4739 
    ;
    
#line 4739 
    __VERIFIER_assume(0);
  }
  ldv_31117: 
#line 4740 
  ;
  
#line 4741 
  return;
}


#line 4745  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_73(void *arg0)
{
  void *__retres;
  struct file *ldv_73_resource_1;
  int ldv_73_ldv_param_2_3;
  long long ldv_73_ldv_param_1_2;
  char *ldv_73_ldv_param_1_4;
  struct inode *ldv_73_resource_0;
  unsigned long ldv_73_size_cnt;
  long long *ldv_73_ldv_param_3_5;
  char *ldv_73_ldv_param_1_6;
  long long *ldv_73_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 4756 
  struct file_operations *ldv_73_container = ldv_emg_alias_rx_filter_max_arp_queue_dep_ops_2;
  
#line 4757 
  int ldv_73_ret = ldv_undef_int();
  
#line 4760 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 4764 
  ldv_73_ret = ldv_undef_int();
  
#line 4767 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 4768 
    ldv_73_container = data->arg0;
    
#line 4769 
    ldv_free((void *)data);
  }
  else ;
  
#line 4774 
  ldv_73_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 4775 
  tmp_1 = ldv_undef_int();
  
#line 4775 
  ldv_73_size_cnt = (unsigned long)tmp_1;
  
#line 4782 
  goto ldv_main_73;
  
#line 4784 
  __retres = (void *)0;
  
#line 4784 
  goto return_label;
  ldv_main_73: 
#line 4787 
  ;
  
#line 4790 
  tmp_3 = ldv_undef_int();
  
#line 4790 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 4793 
    ldv_73_ret = (*ldv_emg_alias_simple_open_5)(ldv_73_resource_0,ldv_73_resource_1);
    
#line 4795 
    ldv_73_ret = ldv_filter_err_code(ldv_73_ret);
    
#line 4798 
    tmp_2 = ldv_undef_int();
    
#line 4798 
    if (tmp_2 != 0) {
      
#line 4800 
      __VERIFIER_assume(ldv_73_ret == 0);
      
#line 4807 
      goto ldv_call_73;
    }
    else {
      
#line 4811 
      __VERIFIER_assume(ldv_73_ret != 0);
      
#line 4818 
      goto ldv_main_73;
    }
  }
  else {
    
#line 4823 
    ldv_free((void *)ldv_73_resource_0);
    
#line 4831 
    __retres = (void *)0;
    
#line 4831 
    goto return_label;
  }
  
#line 4834 
  __retres = (void *)0;
  
#line 4834 
  goto return_label;
  ldv_call_73: 
#line 4837 
  ;
  
#line 4840 
  tmp_4 = ldv_undef_int();
  
#line 4840 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 4841 
    ;
    
#line 4843 
    ldv_73_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 4844 
    ldv_73_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 4848 
    if (ldv_73_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 4854 
      __VERIFIER_assume(ldv_73_size_cnt <= 2147479552UL);
      
#line 4856 
      (*(ldv_73_container->write))(ldv_73_resource_1,(char const *)ldv_73_ldv_param_1_6,ldv_73_size_cnt,ldv_73_ldv_param_3_7);
    }
    else ;
    
#line 4861 
    ldv_free((void *)ldv_73_ldv_param_3_7);
    
#line 4862 
    ldv_free((void *)ldv_73_ldv_param_1_6);
    
#line 4869 
    goto ldv_call_73;
    case 2: 
#line 4872 
    ;
    
#line 4874 
    if (ldv_73_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 4876 
      (*(ldv_73_container->release))(ldv_73_resource_0,ldv_73_resource_1); else ;
    
#line 4884 
    goto ldv_main_73;
    case 3: 
#line 4887 
    ;
    
#line 4891 
    tmp_9 = ldv_undef_int();
    
#line 4891 
    if (tmp_9 != 0) 
#line 4894 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_73_resource_1,ldv_73_ldv_param_1_2,ldv_73_ldv_param_2_3);
    else {
      
#line 4900 
      ldv_73_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 4901 
      ldv_73_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 4906 
      ldv_emg_wrapper_rx_filter_max_arp_queue_dep_read_3(ldv_73_resource_1,ldv_73_ldv_param_1_4,ldv_73_size_cnt,ldv_73_ldv_param_3_5);
      
#line 4910 
      ldv_free((void *)ldv_73_ldv_param_1_4);
      
#line 4911 
      ldv_free((void *)ldv_73_ldv_param_3_5);
    }
    
#line 4915 
    goto ldv_31139;
    default: 
#line 4917 
    ;
    
#line 4917 
    __VERIFIER_assume(0);
  }
  ldv_31139: 
#line 4926 
  ;
  
#line 4926 
  goto ldv_call_73;
  
#line 4928 
  __retres = (void *)0;
  return_label: 
#line 4928 
                return __retres;
}


#line 4933  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_67(void *arg0)
{
  void *__retres;
  struct file *ldv_67_resource_1;
  int ldv_67_ldv_param_2_3;
  long long ldv_67_ldv_param_1_2;
  char *ldv_67_ldv_param_1_4;
  struct inode *ldv_67_resource_0;
  unsigned long ldv_67_size_cnt;
  long long *ldv_67_ldv_param_3_5;
  char *ldv_67_ldv_param_1_6;
  long long *ldv_67_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 4944 
  struct file_operations *ldv_67_container = ldv_emg_alias_rx_rx_phy_hdr_ops_2;
  
#line 4945 
  int ldv_67_ret = ldv_undef_int();
  
#line 4948 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 4952 
  ldv_67_ret = ldv_undef_int();
  
#line 4955 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 4956 
    ldv_67_container = data->arg0;
    
#line 4957 
    ldv_free((void *)data);
  }
  else ;
  
#line 4962 
  ldv_67_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 4963 
  tmp_1 = ldv_undef_int();
  
#line 4963 
  ldv_67_size_cnt = (unsigned long)tmp_1;
  
#line 4970 
  goto ldv_main_67;
  
#line 4972 
  __retres = (void *)0;
  
#line 4972 
  goto return_label;
  ldv_main_67: 
#line 4975 
  ;
  
#line 4978 
  tmp_3 = ldv_undef_int();
  
#line 4978 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 4981 
    ldv_67_ret = (*ldv_emg_alias_simple_open_5)(ldv_67_resource_0,ldv_67_resource_1);
    
#line 4983 
    ldv_67_ret = ldv_filter_err_code(ldv_67_ret);
    
#line 4986 
    tmp_2 = ldv_undef_int();
    
#line 4986 
    if (tmp_2 != 0) {
      
#line 4988 
      __VERIFIER_assume(ldv_67_ret == 0);
      
#line 4995 
      goto ldv_call_67;
    }
    else {
      
#line 4999 
      __VERIFIER_assume(ldv_67_ret != 0);
      
#line 5006 
      goto ldv_main_67;
    }
  }
  else {
    
#line 5011 
    ldv_free((void *)ldv_67_resource_0);
    
#line 5019 
    __retres = (void *)0;
    
#line 5019 
    goto return_label;
  }
  
#line 5022 
  __retres = (void *)0;
  
#line 5022 
  goto return_label;
  ldv_call_67: 
#line 5025 
  ;
  
#line 5028 
  tmp_4 = ldv_undef_int();
  
#line 5028 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 5029 
    ;
    
#line 5031 
    ldv_67_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 5032 
    ldv_67_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 5036 
    if (ldv_67_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 5042 
      __VERIFIER_assume(ldv_67_size_cnt <= 2147479552UL);
      
#line 5044 
      (*(ldv_67_container->write))(ldv_67_resource_1,(char const *)ldv_67_ldv_param_1_6,ldv_67_size_cnt,ldv_67_ldv_param_3_7);
    }
    else ;
    
#line 5049 
    ldv_free((void *)ldv_67_ldv_param_3_7);
    
#line 5050 
    ldv_free((void *)ldv_67_ldv_param_1_6);
    
#line 5057 
    goto ldv_call_67;
    case 2: 
#line 5060 
    ;
    
#line 5062 
    if (ldv_67_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 5064 
      (*(ldv_67_container->release))(ldv_67_resource_0,ldv_67_resource_1); else ;
    
#line 5072 
    goto ldv_main_67;
    case 3: 
#line 5075 
    ;
    
#line 5079 
    tmp_9 = ldv_undef_int();
    
#line 5079 
    if (tmp_9 != 0) 
#line 5082 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_67_resource_1,ldv_67_ldv_param_1_2,ldv_67_ldv_param_2_3);
    else {
      
#line 5088 
      ldv_67_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 5089 
      ldv_67_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 5094 
      ldv_emg_wrapper_rx_rx_phy_hdr_read_3(ldv_67_resource_1,ldv_67_ldv_param_1_4,ldv_67_size_cnt,ldv_67_ldv_param_3_5);
      
#line 5098 
      ldv_free((void *)ldv_67_ldv_param_1_4);
      
#line 5099 
      ldv_free((void *)ldv_67_ldv_param_3_5);
    }
    
#line 5103 
    goto ldv_31161;
    default: 
#line 5105 
    ;
    
#line 5105 
    __VERIFIER_assume(0);
  }
  ldv_31161: 
#line 5114 
  ;
  
#line 5114 
  goto ldv_call_67;
  
#line 5116 
  __retres = (void *)0;
  return_label: 
#line 5116 
                return __retres;
}


#line 5121  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg___platform_driver_register(struct platform_driver *arg0, struct module *arg1)
{
  int __retres;
  int tmp_0;
  
#line 5124 
  struct platform_driver *ldv_2_platform_driver = ldv_emg_alias_wl18xx_driver_2;
  
#line 5128 
  tmp_0 = ldv_undef_int();
  
#line 5128 
  if (tmp_0 != 0) {
    
#line 5130 
    ldv_2_platform_driver = arg0;
    
#line 5134 
    ldv_dispatch_register_2_3(ldv_2_platform_driver);
    
#line 5138 
    __retres = 0;
    
#line 5138 
    goto return_label;
  }
  else {
    int tmp;
    
#line 5145 
    tmp = ldv_undef_int_negative();
    
#line 5145 
    __retres = tmp;
    
#line 5145 
    goto return_label;
  }
  return_label: 
#line 5128 
                return __retres;
}


#line 5155  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_104(void *arg0)
{
  void *__retres;
  struct file *ldv_104_resource_1;
  int ldv_104_ldv_param_2_3;
  long long ldv_104_ldv_param_1_2;
  char *ldv_104_ldv_param_1_4;
  struct inode *ldv_104_resource_0;
  unsigned long ldv_104_size_cnt;
  long long *ldv_104_ldv_param_3_5;
  char *ldv_104_ldv_param_1_6;
  long long *ldv_104_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 5166 
  struct file_operations *ldv_104_container = ldv_emg_alias_tx_tx_start_fw_gen_ops_2;
  
#line 5167 
  int ldv_104_ret = ldv_undef_int();
  
#line 5170 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 5174 
  ldv_104_ret = ldv_undef_int();
  
#line 5177 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 5178 
    ldv_104_container = data->arg0;
    
#line 5179 
    ldv_free((void *)data);
  }
  else ;
  
#line 5184 
  ldv_104_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 5185 
  tmp_1 = ldv_undef_int();
  
#line 5185 
  ldv_104_size_cnt = (unsigned long)tmp_1;
  
#line 5192 
  goto ldv_main_104;
  
#line 5194 
  __retres = (void *)0;
  
#line 5194 
  goto return_label;
  ldv_main_104: 
#line 5197 
  ;
  
#line 5200 
  tmp_3 = ldv_undef_int();
  
#line 5200 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 5203 
    ldv_104_ret = (*ldv_emg_alias_simple_open_5)(ldv_104_resource_0,ldv_104_resource_1);
    
#line 5205 
    ldv_104_ret = ldv_filter_err_code(ldv_104_ret);
    
#line 5208 
    tmp_2 = ldv_undef_int();
    
#line 5208 
    if (tmp_2 != 0) {
      
#line 5210 
      __VERIFIER_assume(ldv_104_ret == 0);
      
#line 5217 
      goto ldv_call_104;
    }
    else {
      
#line 5221 
      __VERIFIER_assume(ldv_104_ret != 0);
      
#line 5228 
      goto ldv_main_104;
    }
  }
  else {
    
#line 5233 
    ldv_free((void *)ldv_104_resource_0);
    
#line 5241 
    __retres = (void *)0;
    
#line 5241 
    goto return_label;
  }
  
#line 5244 
  __retres = (void *)0;
  
#line 5244 
  goto return_label;
  ldv_call_104: 
#line 5247 
  ;
  
#line 5250 
  tmp_4 = ldv_undef_int();
  
#line 5250 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 5251 
    ;
    
#line 5253 
    ldv_104_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 5254 
    ldv_104_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 5258 
    if (ldv_104_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 5264 
      __VERIFIER_assume(ldv_104_size_cnt <= 2147479552UL);
      
#line 5266 
      (*(ldv_104_container->write))(ldv_104_resource_1,(char const *)ldv_104_ldv_param_1_6,ldv_104_size_cnt,ldv_104_ldv_param_3_7);
    }
    else ;
    
#line 5271 
    ldv_free((void *)ldv_104_ldv_param_1_6);
    
#line 5272 
    ldv_free((void *)ldv_104_ldv_param_3_7);
    
#line 5279 
    goto ldv_call_104;
    case 2: 
#line 5282 
    ;
    
#line 5284 
    if (ldv_104_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 5286 
      (*(ldv_104_container->release))(ldv_104_resource_0,ldv_104_resource_1); else ;
    
#line 5294 
    goto ldv_main_104;
    case 3: 
#line 5297 
    ;
    
#line 5301 
    tmp_9 = ldv_undef_int();
    
#line 5301 
    if (tmp_9 != 0) 
#line 5304 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_104_resource_1,ldv_104_ldv_param_1_2,ldv_104_ldv_param_2_3);
    else {
      
#line 5310 
      ldv_104_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 5311 
      ldv_104_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 5316 
      ldv_emg_wrapper_tx_tx_start_fw_gen_read_3(ldv_104_resource_1,ldv_104_ldv_param_1_4,ldv_104_size_cnt,ldv_104_ldv_param_3_5);
      
#line 5320 
      ldv_free((void *)ldv_104_ldv_param_3_5);
      
#line 5321 
      ldv_free((void *)ldv_104_ldv_param_1_4);
    }
    
#line 5325 
    goto ldv_31188;
    default: 
#line 5327 
    ;
    
#line 5327 
    __VERIFIER_assume(0);
  }
  ldv_31188: 
#line 5336 
  ;
  
#line 5336 
  goto ldv_call_104;
  
#line 5338 
  __retres = (void *)0;
  return_label: 
#line 5338 
                return __retres;
}


#line 5343  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_53(void *arg0)
{
  void *__retres;
  struct file *ldv_53_resource_1;
  int ldv_53_ldv_param_2_3;
  long long ldv_53_ldv_param_1_2;
  char *ldv_53_ldv_param_1_4;
  struct inode *ldv_53_resource_0;
  unsigned long ldv_53_size_cnt;
  long long *ldv_53_ldv_param_3_5;
  char *ldv_53_ldv_param_1_6;
  long long *ldv_53_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 5354 
  struct file_operations *ldv_53_container = ldv_emg_alias_rx_rx_hdr_overflow_ops_2;
  
#line 5355 
  int ldv_53_ret = ldv_undef_int();
  
#line 5358 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 5362 
  ldv_53_ret = ldv_undef_int();
  
#line 5365 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 5366 
    ldv_53_container = data->arg0;
    
#line 5367 
    ldv_free((void *)data);
  }
  else ;
  
#line 5372 
  ldv_53_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 5373 
  tmp_1 = ldv_undef_int();
  
#line 5373 
  ldv_53_size_cnt = (unsigned long)tmp_1;
  
#line 5380 
  goto ldv_main_53;
  
#line 5382 
  __retres = (void *)0;
  
#line 5382 
  goto return_label;
  ldv_main_53: 
#line 5385 
  ;
  
#line 5388 
  tmp_3 = ldv_undef_int();
  
#line 5388 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 5391 
    ldv_53_ret = (*ldv_emg_alias_simple_open_5)(ldv_53_resource_0,ldv_53_resource_1);
    
#line 5393 
    ldv_53_ret = ldv_filter_err_code(ldv_53_ret);
    
#line 5396 
    tmp_2 = ldv_undef_int();
    
#line 5396 
    if (tmp_2 != 0) {
      
#line 5398 
      __VERIFIER_assume(ldv_53_ret == 0);
      
#line 5405 
      goto ldv_call_53;
    }
    else {
      
#line 5409 
      __VERIFIER_assume(ldv_53_ret != 0);
      
#line 5416 
      goto ldv_main_53;
    }
  }
  else {
    
#line 5421 
    ldv_free((void *)ldv_53_resource_0);
    
#line 5429 
    __retres = (void *)0;
    
#line 5429 
    goto return_label;
  }
  
#line 5432 
  __retres = (void *)0;
  
#line 5432 
  goto return_label;
  ldv_call_53: 
#line 5435 
  ;
  
#line 5438 
  tmp_4 = ldv_undef_int();
  
#line 5438 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 5439 
    ;
    
#line 5441 
    ldv_53_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 5442 
    ldv_53_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 5446 
    if (ldv_53_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 5452 
      __VERIFIER_assume(ldv_53_size_cnt <= 2147479552UL);
      
#line 5454 
      (*(ldv_53_container->write))(ldv_53_resource_1,(char const *)ldv_53_ldv_param_1_6,ldv_53_size_cnt,ldv_53_ldv_param_3_7);
    }
    else ;
    
#line 5459 
    ldv_free((void *)ldv_53_ldv_param_3_7);
    
#line 5460 
    ldv_free((void *)ldv_53_ldv_param_1_6);
    
#line 5467 
    goto ldv_call_53;
    case 2: 
#line 5470 
    ;
    
#line 5472 
    if (ldv_53_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 5474 
      (*(ldv_53_container->release))(ldv_53_resource_0,ldv_53_resource_1); else ;
    
#line 5482 
    goto ldv_main_53;
    case 3: 
#line 5485 
    ;
    
#line 5489 
    tmp_9 = ldv_undef_int();
    
#line 5489 
    if (tmp_9 != 0) 
#line 5492 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_53_resource_1,ldv_53_ldv_param_1_2,ldv_53_ldv_param_2_3);
    else {
      
#line 5498 
      ldv_53_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 5499 
      ldv_53_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 5504 
      ldv_emg_wrapper_rx_rx_hdr_overflow_read_3(ldv_53_resource_1,ldv_53_ldv_param_1_4,ldv_53_size_cnt,ldv_53_ldv_param_3_5);
      
#line 5508 
      ldv_free((void *)ldv_53_ldv_param_3_5);
      
#line 5509 
      ldv_free((void *)ldv_53_ldv_param_1_4);
    }
    
#line 5513 
    goto ldv_31210;
    default: 
#line 5515 
    ;
    
#line 5515 
    __VERIFIER_assume(0);
  }
  ldv_31210: 
#line 5524 
  ;
  
#line 5524 
  goto ldv_call_53;
  
#line 5526 
  __retres = (void *)0;
  return_label: 
#line 5526 
                return __retres;
}


#line 5531  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_register_4_3(struct file_operations *arg0)
{
  int ret;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_6;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_7;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_8;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_9;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_10;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_11;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_12;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_13;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_14;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_15;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_16;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_17;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_18;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_19;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_20;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_21;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_22;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_23;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_24;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_25;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_26;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_27;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_28;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_29;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_30;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_31;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_32;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_33;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_34;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_35;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_36;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_37;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_38;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_39;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_40;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_41;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_42;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_43;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_44;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_45;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_46;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_47;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_48;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_49;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_50;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_51;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_52;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_53;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_54;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_55;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_56;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_57;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_58;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_59;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_60;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_61;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_62;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_63;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_64;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_65;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_66;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_67;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_68;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_69;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_70;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_71;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_72;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_73;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_74;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_75;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_76;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_77;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_78;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_79;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_80;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_82;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_83;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_84;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_85;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_86;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_87;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_88;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_89;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_90;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_91;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_92;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_93;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_94;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_95;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_96;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_97;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_98;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_99;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_100;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_101;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_102;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_103;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_104;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_105;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_106;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_107;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_109;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_110;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_111;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_112;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_113;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_114;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_115;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_116;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_117;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_118;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_119;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_120;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_121;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_122;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_123;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_124;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_125;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_126;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_127;
  struct ldv_struct_character_driver_scenario_6 *cf_arg_128;
  int tmp;
  
#line 5654 
  tmp = ldv_undef_int();
  
#line 5654 
  switch (tmp) {
    case 0: 
#line 5655 
    ;
    
#line 5656 
    cf_arg_6 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5657 
    cf_arg_6->arg0 = arg0;
    
#line 5658 
    ret = pthread_create(& ldv_thread_6,(pthread_attr_t const *)0,& ldv_character_driver_scenario_6,(void *)cf_arg_6);
    
#line 5659 
    __VERIFIER_assume(ret == 0);
    
#line 5660 
    goto ldv_31338;
    case 1: 
#line 5662 
    ;
    
#line 5663 
    cf_arg_7 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5664 
    cf_arg_7->arg0 = arg0;
    
#line 5665 
    ret = pthread_create(& ldv_thread_7,(pthread_attr_t const *)0,& ldv_character_driver_scenario_7,(void *)cf_arg_7);
    
#line 5666 
    __VERIFIER_assume(ret == 0);
    
#line 5667 
    goto ldv_31338;
    case 2: 
#line 5669 
    ;
    
#line 5670 
    cf_arg_8 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5671 
    cf_arg_8->arg0 = arg0;
    
#line 5672 
    ret = pthread_create(& ldv_thread_8,(pthread_attr_t const *)0,& ldv_character_driver_scenario_8,(void *)cf_arg_8);
    
#line 5673 
    __VERIFIER_assume(ret == 0);
    
#line 5674 
    goto ldv_31338;
    case 3: 
#line 5676 
    ;
    
#line 5677 
    cf_arg_9 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5678 
    cf_arg_9->arg0 = arg0;
    
#line 5679 
    ret = pthread_create(& ldv_thread_9,(pthread_attr_t const *)0,& ldv_character_driver_scenario_9,(void *)cf_arg_9);
    
#line 5680 
    __VERIFIER_assume(ret == 0);
    
#line 5681 
    goto ldv_31338;
    case 4: 
#line 5683 
    ;
    
#line 5684 
    cf_arg_10 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5685 
    cf_arg_10->arg0 = arg0;
    
#line 5686 
    ret = pthread_create(& ldv_thread_10,(pthread_attr_t const *)0,& ldv_character_driver_scenario_10,(void *)cf_arg_10);
    
#line 5687 
    __VERIFIER_assume(ret == 0);
    
#line 5688 
    goto ldv_31338;
    case 5: 
#line 5690 
    ;
    
#line 5691 
    cf_arg_11 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5692 
    cf_arg_11->arg0 = arg0;
    
#line 5693 
    ret = pthread_create(& ldv_thread_11,(pthread_attr_t const *)0,& ldv_character_driver_scenario_11,(void *)cf_arg_11);
    
#line 5694 
    __VERIFIER_assume(ret == 0);
    
#line 5695 
    goto ldv_31338;
    case 6: 
#line 5697 
    ;
    
#line 5698 
    cf_arg_12 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5699 
    cf_arg_12->arg0 = arg0;
    
#line 5700 
    ret = pthread_create(& ldv_thread_12,(pthread_attr_t const *)0,& ldv_character_driver_scenario_12,(void *)cf_arg_12);
    
#line 5701 
    __VERIFIER_assume(ret == 0);
    
#line 5702 
    goto ldv_31338;
    case 7: 
#line 5704 
    ;
    
#line 5705 
    cf_arg_13 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5706 
    cf_arg_13->arg0 = arg0;
    
#line 5707 
    ret = pthread_create(& ldv_thread_13,(pthread_attr_t const *)0,& ldv_character_driver_scenario_13,(void *)cf_arg_13);
    
#line 5708 
    __VERIFIER_assume(ret == 0);
    
#line 5709 
    goto ldv_31338;
    case 8: 
#line 5711 
    ;
    
#line 5712 
    cf_arg_14 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5713 
    cf_arg_14->arg0 = arg0;
    
#line 5714 
    ret = pthread_create(& ldv_thread_14,(pthread_attr_t const *)0,& ldv_character_driver_scenario_14,(void *)cf_arg_14);
    
#line 5715 
    __VERIFIER_assume(ret == 0);
    
#line 5716 
    goto ldv_31338;
    case 9: 
#line 5718 
    ;
    
#line 5719 
    cf_arg_15 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5720 
    cf_arg_15->arg0 = arg0;
    
#line 5721 
    ret = pthread_create(& ldv_thread_15,(pthread_attr_t const *)0,& ldv_character_driver_scenario_15,(void *)cf_arg_15);
    
#line 5722 
    __VERIFIER_assume(ret == 0);
    
#line 5723 
    goto ldv_31338;
    case 10: 
#line 5725 
    ;
    
#line 5726 
    cf_arg_16 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5727 
    cf_arg_16->arg0 = arg0;
    
#line 5728 
    ret = pthread_create(& ldv_thread_16,(pthread_attr_t const *)0,& ldv_character_driver_scenario_16,(void *)cf_arg_16);
    
#line 5729 
    __VERIFIER_assume(ret == 0);
    
#line 5730 
    goto ldv_31338;
    case 11: 
#line 5732 
    ;
    
#line 5733 
    cf_arg_17 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5734 
    cf_arg_17->arg0 = arg0;
    
#line 5735 
    ret = pthread_create(& ldv_thread_17,(pthread_attr_t const *)0,& ldv_character_driver_scenario_17,(void *)cf_arg_17);
    
#line 5736 
    __VERIFIER_assume(ret == 0);
    
#line 5737 
    goto ldv_31338;
    case 12: 
#line 5739 
    ;
    
#line 5740 
    cf_arg_18 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5741 
    cf_arg_18->arg0 = arg0;
    
#line 5742 
    ret = pthread_create(& ldv_thread_18,(pthread_attr_t const *)0,& ldv_character_driver_scenario_18,(void *)cf_arg_18);
    
#line 5743 
    __VERIFIER_assume(ret == 0);
    
#line 5744 
    goto ldv_31338;
    case 13: 
#line 5746 
    ;
    
#line 5747 
    cf_arg_19 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5748 
    cf_arg_19->arg0 = arg0;
    
#line 5749 
    ret = pthread_create(& ldv_thread_19,(pthread_attr_t const *)0,& ldv_character_driver_scenario_19,(void *)cf_arg_19);
    
#line 5750 
    __VERIFIER_assume(ret == 0);
    
#line 5751 
    goto ldv_31338;
    case 14: 
#line 5753 
    ;
    
#line 5754 
    cf_arg_20 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5755 
    cf_arg_20->arg0 = arg0;
    
#line 5756 
    ret = pthread_create(& ldv_thread_20,(pthread_attr_t const *)0,& ldv_character_driver_scenario_20,(void *)cf_arg_20);
    
#line 5757 
    __VERIFIER_assume(ret == 0);
    
#line 5758 
    goto ldv_31338;
    case 15: 
#line 5760 
    ;
    
#line 5761 
    cf_arg_21 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5762 
    cf_arg_21->arg0 = arg0;
    
#line 5763 
    ret = pthread_create(& ldv_thread_21,(pthread_attr_t const *)0,& ldv_character_driver_scenario_21,(void *)cf_arg_21);
    
#line 5764 
    __VERIFIER_assume(ret == 0);
    
#line 5765 
    goto ldv_31338;
    case 16: 
#line 5767 
    ;
    
#line 5768 
    cf_arg_22 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5769 
    cf_arg_22->arg0 = arg0;
    
#line 5770 
    ret = pthread_create(& ldv_thread_22,(pthread_attr_t const *)0,& ldv_character_driver_scenario_22,(void *)cf_arg_22);
    
#line 5771 
    __VERIFIER_assume(ret == 0);
    
#line 5772 
    goto ldv_31338;
    case 17: 
#line 5774 
    ;
    
#line 5775 
    cf_arg_23 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5776 
    cf_arg_23->arg0 = arg0;
    
#line 5777 
    ret = pthread_create(& ldv_thread_23,(pthread_attr_t const *)0,& ldv_character_driver_scenario_23,(void *)cf_arg_23);
    
#line 5778 
    __VERIFIER_assume(ret == 0);
    
#line 5779 
    goto ldv_31338;
    case 18: 
#line 5781 
    ;
    
#line 5782 
    cf_arg_24 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5783 
    cf_arg_24->arg0 = arg0;
    
#line 5784 
    ret = pthread_create(& ldv_thread_24,(pthread_attr_t const *)0,& ldv_character_driver_scenario_24,(void *)cf_arg_24);
    
#line 5785 
    __VERIFIER_assume(ret == 0);
    
#line 5786 
    goto ldv_31338;
    case 19: 
#line 5788 
    ;
    
#line 5789 
    cf_arg_25 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5790 
    cf_arg_25->arg0 = arg0;
    
#line 5791 
    ret = pthread_create(& ldv_thread_25,(pthread_attr_t const *)0,& ldv_character_driver_scenario_25,(void *)cf_arg_25);
    
#line 5792 
    __VERIFIER_assume(ret == 0);
    
#line 5793 
    goto ldv_31338;
    case 20: 
#line 5795 
    ;
    
#line 5796 
    cf_arg_26 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5797 
    cf_arg_26->arg0 = arg0;
    
#line 5798 
    ret = pthread_create(& ldv_thread_26,(pthread_attr_t const *)0,& ldv_character_driver_scenario_26,(void *)cf_arg_26);
    
#line 5799 
    __VERIFIER_assume(ret == 0);
    
#line 5800 
    goto ldv_31338;
    case 21: 
#line 5802 
    ;
    
#line 5803 
    cf_arg_27 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5804 
    cf_arg_27->arg0 = arg0;
    
#line 5805 
    ret = pthread_create(& ldv_thread_27,(pthread_attr_t const *)0,& ldv_character_driver_scenario_27,(void *)cf_arg_27);
    
#line 5806 
    __VERIFIER_assume(ret == 0);
    
#line 5807 
    goto ldv_31338;
    case 22: 
#line 5809 
    ;
    
#line 5810 
    cf_arg_28 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5811 
    cf_arg_28->arg0 = arg0;
    
#line 5812 
    ret = pthread_create(& ldv_thread_28,(pthread_attr_t const *)0,& ldv_character_driver_scenario_28,(void *)cf_arg_28);
    
#line 5813 
    __VERIFIER_assume(ret == 0);
    
#line 5814 
    goto ldv_31338;
    case 23: 
#line 5816 
    ;
    
#line 5817 
    cf_arg_29 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5818 
    cf_arg_29->arg0 = arg0;
    
#line 5819 
    ret = pthread_create(& ldv_thread_29,(pthread_attr_t const *)0,& ldv_character_driver_scenario_29,(void *)cf_arg_29);
    
#line 5820 
    __VERIFIER_assume(ret == 0);
    
#line 5821 
    goto ldv_31338;
    case 24: 
#line 5823 
    ;
    
#line 5824 
    cf_arg_30 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5825 
    cf_arg_30->arg0 = arg0;
    
#line 5826 
    ret = pthread_create(& ldv_thread_30,(pthread_attr_t const *)0,& ldv_character_driver_scenario_30,(void *)cf_arg_30);
    
#line 5827 
    __VERIFIER_assume(ret == 0);
    
#line 5828 
    goto ldv_31338;
    case 25: 
#line 5830 
    ;
    
#line 5831 
    cf_arg_31 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5832 
    cf_arg_31->arg0 = arg0;
    
#line 5833 
    ret = pthread_create(& ldv_thread_31,(pthread_attr_t const *)0,& ldv_character_driver_scenario_31,(void *)cf_arg_31);
    
#line 5834 
    __VERIFIER_assume(ret == 0);
    
#line 5835 
    goto ldv_31338;
    case 26: 
#line 5837 
    ;
    
#line 5838 
    cf_arg_32 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5839 
    cf_arg_32->arg0 = arg0;
    
#line 5840 
    ret = pthread_create(& ldv_thread_32,(pthread_attr_t const *)0,& ldv_character_driver_scenario_32,(void *)cf_arg_32);
    
#line 5841 
    __VERIFIER_assume(ret == 0);
    
#line 5842 
    goto ldv_31338;
    case 27: 
#line 5844 
    ;
    
#line 5845 
    cf_arg_33 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5846 
    cf_arg_33->arg0 = arg0;
    
#line 5847 
    ret = pthread_create(& ldv_thread_33,(pthread_attr_t const *)0,& ldv_character_driver_scenario_33,(void *)cf_arg_33);
    
#line 5848 
    __VERIFIER_assume(ret == 0);
    
#line 5849 
    goto ldv_31338;
    case 28: 
#line 5851 
    ;
    
#line 5852 
    cf_arg_34 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5853 
    cf_arg_34->arg0 = arg0;
    
#line 5854 
    ret = pthread_create(& ldv_thread_34,(pthread_attr_t const *)0,& ldv_character_driver_scenario_34,(void *)cf_arg_34);
    
#line 5855 
    __VERIFIER_assume(ret == 0);
    
#line 5856 
    goto ldv_31338;
    case 29: 
#line 5858 
    ;
    
#line 5859 
    cf_arg_35 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5860 
    cf_arg_35->arg0 = arg0;
    
#line 5861 
    ret = pthread_create(& ldv_thread_35,(pthread_attr_t const *)0,& ldv_character_driver_scenario_35,(void *)cf_arg_35);
    
#line 5862 
    __VERIFIER_assume(ret == 0);
    
#line 5863 
    goto ldv_31338;
    case 30: 
#line 5865 
    ;
    
#line 5866 
    cf_arg_36 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5867 
    cf_arg_36->arg0 = arg0;
    
#line 5868 
    ret = pthread_create(& ldv_thread_36,(pthread_attr_t const *)0,& ldv_character_driver_scenario_36,(void *)cf_arg_36);
    
#line 5869 
    __VERIFIER_assume(ret == 0);
    
#line 5870 
    goto ldv_31338;
    case 31: 
#line 5872 
    ;
    
#line 5873 
    cf_arg_37 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5874 
    cf_arg_37->arg0 = arg0;
    
#line 5875 
    ret = pthread_create(& ldv_thread_37,(pthread_attr_t const *)0,& ldv_character_driver_scenario_37,(void *)cf_arg_37);
    
#line 5876 
    __VERIFIER_assume(ret == 0);
    
#line 5877 
    goto ldv_31338;
    case 32: 
#line 5879 
    ;
    
#line 5880 
    cf_arg_38 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5881 
    cf_arg_38->arg0 = arg0;
    
#line 5882 
    ret = pthread_create(& ldv_thread_38,(pthread_attr_t const *)0,& ldv_character_driver_scenario_38,(void *)cf_arg_38);
    
#line 5883 
    __VERIFIER_assume(ret == 0);
    
#line 5884 
    goto ldv_31338;
    case 33: 
#line 5886 
    ;
    
#line 5887 
    cf_arg_39 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5888 
    cf_arg_39->arg0 = arg0;
    
#line 5889 
    ret = pthread_create(& ldv_thread_39,(pthread_attr_t const *)0,& ldv_character_driver_scenario_39,(void *)cf_arg_39);
    
#line 5890 
    __VERIFIER_assume(ret == 0);
    
#line 5891 
    goto ldv_31338;
    case 34: 
#line 5893 
    ;
    
#line 5894 
    cf_arg_40 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5895 
    cf_arg_40->arg0 = arg0;
    
#line 5896 
    ret = pthread_create(& ldv_thread_40,(pthread_attr_t const *)0,& ldv_character_driver_scenario_40,(void *)cf_arg_40);
    
#line 5897 
    __VERIFIER_assume(ret == 0);
    
#line 5898 
    goto ldv_31338;
    case 35: 
#line 5900 
    ;
    
#line 5901 
    cf_arg_41 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5902 
    cf_arg_41->arg0 = arg0;
    
#line 5903 
    ret = pthread_create(& ldv_thread_41,(pthread_attr_t const *)0,& ldv_character_driver_scenario_41,(void *)cf_arg_41);
    
#line 5904 
    __VERIFIER_assume(ret == 0);
    
#line 5905 
    goto ldv_31338;
    case 36: 
#line 5907 
    ;
    
#line 5908 
    cf_arg_42 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5909 
    cf_arg_42->arg0 = arg0;
    
#line 5910 
    ret = pthread_create(& ldv_thread_42,(pthread_attr_t const *)0,& ldv_character_driver_scenario_42,(void *)cf_arg_42);
    
#line 5911 
    __VERIFIER_assume(ret == 0);
    
#line 5912 
    goto ldv_31338;
    case 37: 
#line 5914 
    ;
    
#line 5915 
    cf_arg_43 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5916 
    cf_arg_43->arg0 = arg0;
    
#line 5917 
    ret = pthread_create(& ldv_thread_43,(pthread_attr_t const *)0,& ldv_character_driver_scenario_43,(void *)cf_arg_43);
    
#line 5918 
    __VERIFIER_assume(ret == 0);
    
#line 5919 
    goto ldv_31338;
    case 38: 
#line 5921 
    ;
    
#line 5922 
    cf_arg_44 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5923 
    cf_arg_44->arg0 = arg0;
    
#line 5924 
    ret = pthread_create(& ldv_thread_44,(pthread_attr_t const *)0,& ldv_character_driver_scenario_44,(void *)cf_arg_44);
    
#line 5925 
    __VERIFIER_assume(ret == 0);
    
#line 5926 
    goto ldv_31338;
    case 39: 
#line 5928 
    ;
    
#line 5929 
    cf_arg_45 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5930 
    cf_arg_45->arg0 = arg0;
    
#line 5931 
    ret = pthread_create(& ldv_thread_45,(pthread_attr_t const *)0,& ldv_character_driver_scenario_45,(void *)cf_arg_45);
    
#line 5932 
    __VERIFIER_assume(ret == 0);
    
#line 5933 
    goto ldv_31338;
    case 40: 
#line 5935 
    ;
    
#line 5936 
    cf_arg_46 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5937 
    cf_arg_46->arg0 = arg0;
    
#line 5938 
    ret = pthread_create(& ldv_thread_46,(pthread_attr_t const *)0,& ldv_character_driver_scenario_46,(void *)cf_arg_46);
    
#line 5939 
    __VERIFIER_assume(ret == 0);
    
#line 5940 
    goto ldv_31338;
    case 41: 
#line 5942 
    ;
    
#line 5943 
    cf_arg_47 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5944 
    cf_arg_47->arg0 = arg0;
    
#line 5945 
    ret = pthread_create(& ldv_thread_47,(pthread_attr_t const *)0,& ldv_character_driver_scenario_47,(void *)cf_arg_47);
    
#line 5946 
    __VERIFIER_assume(ret == 0);
    
#line 5947 
    goto ldv_31338;
    case 42: 
#line 5949 
    ;
    
#line 5950 
    cf_arg_48 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5951 
    cf_arg_48->arg0 = arg0;
    
#line 5952 
    ret = pthread_create(& ldv_thread_48,(pthread_attr_t const *)0,& ldv_character_driver_scenario_48,(void *)cf_arg_48);
    
#line 5953 
    __VERIFIER_assume(ret == 0);
    
#line 5954 
    goto ldv_31338;
    case 43: 
#line 5956 
    ;
    
#line 5957 
    cf_arg_49 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5958 
    cf_arg_49->arg0 = arg0;
    
#line 5959 
    ret = pthread_create(& ldv_thread_49,(pthread_attr_t const *)0,& ldv_character_driver_scenario_49,(void *)cf_arg_49);
    
#line 5960 
    __VERIFIER_assume(ret == 0);
    
#line 5961 
    goto ldv_31338;
    case 44: 
#line 5963 
    ;
    
#line 5964 
    cf_arg_50 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5965 
    cf_arg_50->arg0 = arg0;
    
#line 5966 
    ret = pthread_create(& ldv_thread_50,(pthread_attr_t const *)0,& ldv_character_driver_scenario_50,(void *)cf_arg_50);
    
#line 5967 
    __VERIFIER_assume(ret == 0);
    
#line 5968 
    goto ldv_31338;
    case 45: 
#line 5970 
    ;
    
#line 5971 
    cf_arg_51 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5972 
    cf_arg_51->arg0 = arg0;
    
#line 5973 
    ret = pthread_create(& ldv_thread_51,(pthread_attr_t const *)0,& ldv_character_driver_scenario_51,(void *)cf_arg_51);
    
#line 5974 
    __VERIFIER_assume(ret == 0);
    
#line 5975 
    goto ldv_31338;
    case 46: 
#line 5977 
    ;
    
#line 5978 
    cf_arg_52 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5979 
    cf_arg_52->arg0 = arg0;
    
#line 5980 
    ret = pthread_create(& ldv_thread_52,(pthread_attr_t const *)0,& ldv_character_driver_scenario_52,(void *)cf_arg_52);
    
#line 5981 
    __VERIFIER_assume(ret == 0);
    
#line 5982 
    goto ldv_31338;
    case 47: 
#line 5984 
    ;
    
#line 5985 
    cf_arg_53 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5986 
    cf_arg_53->arg0 = arg0;
    
#line 5987 
    ret = pthread_create(& ldv_thread_53,(pthread_attr_t const *)0,& ldv_character_driver_scenario_53,(void *)cf_arg_53);
    
#line 5988 
    __VERIFIER_assume(ret == 0);
    
#line 5989 
    goto ldv_31338;
    case 48: 
#line 5991 
    ;
    
#line 5992 
    cf_arg_54 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 5993 
    cf_arg_54->arg0 = arg0;
    
#line 5994 
    ret = pthread_create(& ldv_thread_54,(pthread_attr_t const *)0,& ldv_character_driver_scenario_54,(void *)cf_arg_54);
    
#line 5995 
    __VERIFIER_assume(ret == 0);
    
#line 5996 
    goto ldv_31338;
    case 49: 
#line 5998 
    ;
    
#line 5999 
    cf_arg_55 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6000 
    cf_arg_55->arg0 = arg0;
    
#line 6001 
    ret = pthread_create(& ldv_thread_55,(pthread_attr_t const *)0,& ldv_character_driver_scenario_55,(void *)cf_arg_55);
    
#line 6002 
    __VERIFIER_assume(ret == 0);
    
#line 6003 
    goto ldv_31338;
    case 50: 
#line 6005 
    ;
    
#line 6006 
    cf_arg_56 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6007 
    cf_arg_56->arg0 = arg0;
    
#line 6008 
    ret = pthread_create(& ldv_thread_56,(pthread_attr_t const *)0,& ldv_character_driver_scenario_56,(void *)cf_arg_56);
    
#line 6009 
    __VERIFIER_assume(ret == 0);
    
#line 6010 
    goto ldv_31338;
    case 51: 
#line 6012 
    ;
    
#line 6013 
    cf_arg_57 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6014 
    cf_arg_57->arg0 = arg0;
    
#line 6015 
    ret = pthread_create(& ldv_thread_57,(pthread_attr_t const *)0,& ldv_character_driver_scenario_57,(void *)cf_arg_57);
    
#line 6016 
    __VERIFIER_assume(ret == 0);
    
#line 6017 
    goto ldv_31338;
    case 52: 
#line 6019 
    ;
    
#line 6020 
    cf_arg_58 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6021 
    cf_arg_58->arg0 = arg0;
    
#line 6022 
    ret = pthread_create(& ldv_thread_58,(pthread_attr_t const *)0,& ldv_character_driver_scenario_58,(void *)cf_arg_58);
    
#line 6023 
    __VERIFIER_assume(ret == 0);
    
#line 6024 
    goto ldv_31338;
    case 53: 
#line 6026 
    ;
    
#line 6027 
    cf_arg_59 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6028 
    cf_arg_59->arg0 = arg0;
    
#line 6029 
    ret = pthread_create(& ldv_thread_59,(pthread_attr_t const *)0,& ldv_character_driver_scenario_59,(void *)cf_arg_59);
    
#line 6030 
    __VERIFIER_assume(ret == 0);
    
#line 6031 
    goto ldv_31338;
    case 54: 
#line 6033 
    ;
    
#line 6034 
    cf_arg_60 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6035 
    cf_arg_60->arg0 = arg0;
    
#line 6036 
    ret = pthread_create(& ldv_thread_60,(pthread_attr_t const *)0,& ldv_character_driver_scenario_60,(void *)cf_arg_60);
    
#line 6037 
    __VERIFIER_assume(ret == 0);
    
#line 6038 
    goto ldv_31338;
    case 55: 
#line 6040 
    ;
    
#line 6041 
    cf_arg_61 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6042 
    cf_arg_61->arg0 = arg0;
    
#line 6043 
    ret = pthread_create(& ldv_thread_61,(pthread_attr_t const *)0,& ldv_character_driver_scenario_61,(void *)cf_arg_61);
    
#line 6044 
    __VERIFIER_assume(ret == 0);
    
#line 6045 
    goto ldv_31338;
    case 56: 
#line 6047 
    ;
    
#line 6048 
    cf_arg_62 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6049 
    cf_arg_62->arg0 = arg0;
    
#line 6050 
    ret = pthread_create(& ldv_thread_62,(pthread_attr_t const *)0,& ldv_character_driver_scenario_62,(void *)cf_arg_62);
    
#line 6051 
    __VERIFIER_assume(ret == 0);
    
#line 6052 
    goto ldv_31338;
    case 57: 
#line 6054 
    ;
    
#line 6055 
    cf_arg_63 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6056 
    cf_arg_63->arg0 = arg0;
    
#line 6057 
    ret = pthread_create(& ldv_thread_63,(pthread_attr_t const *)0,& ldv_character_driver_scenario_63,(void *)cf_arg_63);
    
#line 6058 
    __VERIFIER_assume(ret == 0);
    
#line 6059 
    goto ldv_31338;
    case 58: 
#line 6061 
    ;
    
#line 6062 
    cf_arg_64 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6063 
    cf_arg_64->arg0 = arg0;
    
#line 6064 
    ret = pthread_create(& ldv_thread_64,(pthread_attr_t const *)0,& ldv_character_driver_scenario_64,(void *)cf_arg_64);
    
#line 6065 
    __VERIFIER_assume(ret == 0);
    
#line 6066 
    goto ldv_31338;
    case 59: 
#line 6068 
    ;
    
#line 6069 
    cf_arg_65 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6070 
    cf_arg_65->arg0 = arg0;
    
#line 6071 
    ret = pthread_create(& ldv_thread_65,(pthread_attr_t const *)0,& ldv_character_driver_scenario_65,(void *)cf_arg_65);
    
#line 6072 
    __VERIFIER_assume(ret == 0);
    
#line 6073 
    goto ldv_31338;
    case 60: 
#line 6075 
    ;
    
#line 6076 
    cf_arg_66 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6077 
    cf_arg_66->arg0 = arg0;
    
#line 6078 
    ret = pthread_create(& ldv_thread_66,(pthread_attr_t const *)0,& ldv_character_driver_scenario_66,(void *)cf_arg_66);
    
#line 6079 
    __VERIFIER_assume(ret == 0);
    
#line 6080 
    goto ldv_31338;
    case 61: 
#line 6082 
    ;
    
#line 6083 
    cf_arg_67 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6084 
    cf_arg_67->arg0 = arg0;
    
#line 6085 
    ret = pthread_create(& ldv_thread_67,(pthread_attr_t const *)0,& ldv_character_driver_scenario_67,(void *)cf_arg_67);
    
#line 6086 
    __VERIFIER_assume(ret == 0);
    
#line 6087 
    goto ldv_31338;
    case 62: 
#line 6089 
    ;
    
#line 6090 
    cf_arg_68 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6091 
    cf_arg_68->arg0 = arg0;
    
#line 6092 
    ret = pthread_create(& ldv_thread_68,(pthread_attr_t const *)0,& ldv_character_driver_scenario_68,(void *)cf_arg_68);
    
#line 6093 
    __VERIFIER_assume(ret == 0);
    
#line 6094 
    goto ldv_31338;
    case 63: 
#line 6096 
    ;
    
#line 6097 
    cf_arg_69 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6098 
    cf_arg_69->arg0 = arg0;
    
#line 6099 
    ret = pthread_create(& ldv_thread_69,(pthread_attr_t const *)0,& ldv_character_driver_scenario_69,(void *)cf_arg_69);
    
#line 6100 
    __VERIFIER_assume(ret == 0);
    
#line 6101 
    goto ldv_31338;
    case 64: 
#line 6103 
    ;
    
#line 6104 
    cf_arg_70 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6105 
    cf_arg_70->arg0 = arg0;
    
#line 6106 
    ret = pthread_create(& ldv_thread_70,(pthread_attr_t const *)0,& ldv_character_driver_scenario_70,(void *)cf_arg_70);
    
#line 6107 
    __VERIFIER_assume(ret == 0);
    
#line 6108 
    goto ldv_31338;
    case 65: 
#line 6110 
    ;
    
#line 6111 
    cf_arg_71 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6112 
    cf_arg_71->arg0 = arg0;
    
#line 6113 
    ret = pthread_create(& ldv_thread_71,(pthread_attr_t const *)0,& ldv_character_driver_scenario_71,(void *)cf_arg_71);
    
#line 6114 
    __VERIFIER_assume(ret == 0);
    
#line 6115 
    goto ldv_31338;
    case 66: 
#line 6117 
    ;
    
#line 6118 
    cf_arg_72 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6119 
    cf_arg_72->arg0 = arg0;
    
#line 6120 
    ret = pthread_create(& ldv_thread_72,(pthread_attr_t const *)0,& ldv_character_driver_scenario_72,(void *)cf_arg_72);
    
#line 6121 
    __VERIFIER_assume(ret == 0);
    
#line 6122 
    goto ldv_31338;
    case 67: 
#line 6124 
    ;
    
#line 6125 
    cf_arg_73 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6126 
    cf_arg_73->arg0 = arg0;
    
#line 6127 
    ret = pthread_create(& ldv_thread_73,(pthread_attr_t const *)0,& ldv_character_driver_scenario_73,(void *)cf_arg_73);
    
#line 6128 
    __VERIFIER_assume(ret == 0);
    
#line 6129 
    goto ldv_31338;
    case 68: 
#line 6131 
    ;
    
#line 6132 
    cf_arg_74 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6133 
    cf_arg_74->arg0 = arg0;
    
#line 6134 
    ret = pthread_create(& ldv_thread_74,(pthread_attr_t const *)0,& ldv_character_driver_scenario_74,(void *)cf_arg_74);
    
#line 6135 
    __VERIFIER_assume(ret == 0);
    
#line 6136 
    goto ldv_31338;
    case 69: 
#line 6138 
    ;
    
#line 6139 
    cf_arg_75 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6140 
    cf_arg_75->arg0 = arg0;
    
#line 6141 
    ret = pthread_create(& ldv_thread_75,(pthread_attr_t const *)0,& ldv_character_driver_scenario_75,(void *)cf_arg_75);
    
#line 6142 
    __VERIFIER_assume(ret == 0);
    
#line 6143 
    goto ldv_31338;
    case 70: 
#line 6145 
    ;
    
#line 6146 
    cf_arg_76 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6147 
    cf_arg_76->arg0 = arg0;
    
#line 6148 
    ret = pthread_create(& ldv_thread_76,(pthread_attr_t const *)0,& ldv_character_driver_scenario_76,(void *)cf_arg_76);
    
#line 6149 
    __VERIFIER_assume(ret == 0);
    
#line 6150 
    goto ldv_31338;
    case 71: 
#line 6152 
    ;
    
#line 6153 
    cf_arg_77 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6154 
    cf_arg_77->arg0 = arg0;
    
#line 6155 
    ret = pthread_create(& ldv_thread_77,(pthread_attr_t const *)0,& ldv_character_driver_scenario_77,(void *)cf_arg_77);
    
#line 6156 
    __VERIFIER_assume(ret == 0);
    
#line 6157 
    goto ldv_31338;
    case 72: 
#line 6159 
    ;
    
#line 6160 
    cf_arg_78 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6161 
    cf_arg_78->arg0 = arg0;
    
#line 6162 
    ret = pthread_create(& ldv_thread_78,(pthread_attr_t const *)0,& ldv_character_driver_scenario_78,(void *)cf_arg_78);
    
#line 6163 
    __VERIFIER_assume(ret == 0);
    
#line 6164 
    goto ldv_31338;
    case 73: 
#line 6166 
    ;
    
#line 6167 
    cf_arg_79 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6168 
    cf_arg_79->arg0 = arg0;
    
#line 6169 
    ret = pthread_create(& ldv_thread_79,(pthread_attr_t const *)0,& ldv_character_driver_scenario_79,(void *)cf_arg_79);
    
#line 6170 
    __VERIFIER_assume(ret == 0);
    
#line 6171 
    goto ldv_31338;
    case 74: 
#line 6173 
    ;
    
#line 6174 
    cf_arg_80 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6175 
    cf_arg_80->arg0 = arg0;
    
#line 6176 
    ret = pthread_create(& ldv_thread_80,(pthread_attr_t const *)0,& ldv_character_driver_scenario_80,(void *)cf_arg_80);
    
#line 6177 
    __VERIFIER_assume(ret == 0);
    
#line 6178 
    goto ldv_31338;
    case 75: 
#line 6180 
    ;
    
#line 6181 
    cf_arg_82 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6182 
    cf_arg_82->arg0 = arg0;
    
#line 6183 
    ret = pthread_create(& ldv_thread_82,(pthread_attr_t const *)0,& ldv_character_driver_scenario_82,(void *)cf_arg_82);
    
#line 6184 
    __VERIFIER_assume(ret == 0);
    
#line 6185 
    goto ldv_31338;
    case 76: 
#line 6187 
    ;
    
#line 6188 
    cf_arg_83 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6189 
    cf_arg_83->arg0 = arg0;
    
#line 6190 
    ret = pthread_create(& ldv_thread_83,(pthread_attr_t const *)0,& ldv_character_driver_scenario_83,(void *)cf_arg_83);
    
#line 6191 
    __VERIFIER_assume(ret == 0);
    
#line 6192 
    goto ldv_31338;
    case 77: 
#line 6194 
    ;
    
#line 6195 
    cf_arg_84 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6196 
    cf_arg_84->arg0 = arg0;
    
#line 6197 
    ret = pthread_create(& ldv_thread_84,(pthread_attr_t const *)0,& ldv_character_driver_scenario_84,(void *)cf_arg_84);
    
#line 6198 
    __VERIFIER_assume(ret == 0);
    
#line 6199 
    goto ldv_31338;
    case 78: 
#line 6201 
    ;
    
#line 6202 
    cf_arg_85 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6203 
    cf_arg_85->arg0 = arg0;
    
#line 6204 
    ret = pthread_create(& ldv_thread_85,(pthread_attr_t const *)0,& ldv_character_driver_scenario_85,(void *)cf_arg_85);
    
#line 6205 
    __VERIFIER_assume(ret == 0);
    
#line 6206 
    goto ldv_31338;
    case 79: 
#line 6208 
    ;
    
#line 6209 
    cf_arg_86 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6210 
    cf_arg_86->arg0 = arg0;
    
#line 6211 
    ret = pthread_create(& ldv_thread_86,(pthread_attr_t const *)0,& ldv_character_driver_scenario_86,(void *)cf_arg_86);
    
#line 6212 
    __VERIFIER_assume(ret == 0);
    
#line 6213 
    goto ldv_31338;
    case 80: 
#line 6215 
    ;
    
#line 6216 
    cf_arg_87 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6217 
    cf_arg_87->arg0 = arg0;
    
#line 6218 
    ret = pthread_create(& ldv_thread_87,(pthread_attr_t const *)0,& ldv_character_driver_scenario_87,(void *)cf_arg_87);
    
#line 6219 
    __VERIFIER_assume(ret == 0);
    
#line 6220 
    goto ldv_31338;
    case 81: 
#line 6222 
    ;
    
#line 6223 
    cf_arg_88 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6224 
    cf_arg_88->arg0 = arg0;
    
#line 6225 
    ret = pthread_create(& ldv_thread_88,(pthread_attr_t const *)0,& ldv_character_driver_scenario_88,(void *)cf_arg_88);
    
#line 6226 
    __VERIFIER_assume(ret == 0);
    
#line 6227 
    goto ldv_31338;
    case 82: 
#line 6229 
    ;
    
#line 6230 
    cf_arg_89 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6231 
    cf_arg_89->arg0 = arg0;
    
#line 6232 
    ret = pthread_create(& ldv_thread_89,(pthread_attr_t const *)0,& ldv_character_driver_scenario_89,(void *)cf_arg_89);
    
#line 6233 
    __VERIFIER_assume(ret == 0);
    
#line 6234 
    goto ldv_31338;
    case 83: 
#line 6236 
    ;
    
#line 6237 
    cf_arg_90 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6238 
    cf_arg_90->arg0 = arg0;
    
#line 6239 
    ret = pthread_create(& ldv_thread_90,(pthread_attr_t const *)0,& ldv_character_driver_scenario_90,(void *)cf_arg_90);
    
#line 6240 
    __VERIFIER_assume(ret == 0);
    
#line 6241 
    goto ldv_31338;
    case 84: 
#line 6243 
    ;
    
#line 6244 
    cf_arg_91 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6245 
    cf_arg_91->arg0 = arg0;
    
#line 6246 
    ret = pthread_create(& ldv_thread_91,(pthread_attr_t const *)0,& ldv_character_driver_scenario_91,(void *)cf_arg_91);
    
#line 6247 
    __VERIFIER_assume(ret == 0);
    
#line 6248 
    goto ldv_31338;
    case 85: 
#line 6250 
    ;
    
#line 6251 
    cf_arg_92 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6252 
    cf_arg_92->arg0 = arg0;
    
#line 6253 
    ret = pthread_create(& ldv_thread_92,(pthread_attr_t const *)0,& ldv_character_driver_scenario_92,(void *)cf_arg_92);
    
#line 6254 
    __VERIFIER_assume(ret == 0);
    
#line 6255 
    goto ldv_31338;
    case 86: 
#line 6257 
    ;
    
#line 6258 
    cf_arg_93 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6259 
    cf_arg_93->arg0 = arg0;
    
#line 6260 
    ret = pthread_create(& ldv_thread_93,(pthread_attr_t const *)0,& ldv_character_driver_scenario_93,(void *)cf_arg_93);
    
#line 6261 
    __VERIFIER_assume(ret == 0);
    
#line 6262 
    goto ldv_31338;
    case 87: 
#line 6264 
    ;
    
#line 6265 
    cf_arg_94 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6266 
    cf_arg_94->arg0 = arg0;
    
#line 6267 
    ret = pthread_create(& ldv_thread_94,(pthread_attr_t const *)0,& ldv_character_driver_scenario_94,(void *)cf_arg_94);
    
#line 6268 
    __VERIFIER_assume(ret == 0);
    
#line 6269 
    goto ldv_31338;
    case 88: 
#line 6271 
    ;
    
#line 6272 
    cf_arg_95 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6273 
    cf_arg_95->arg0 = arg0;
    
#line 6274 
    ret = pthread_create(& ldv_thread_95,(pthread_attr_t const *)0,& ldv_character_driver_scenario_95,(void *)cf_arg_95);
    
#line 6275 
    __VERIFIER_assume(ret == 0);
    
#line 6276 
    goto ldv_31338;
    case 89: 
#line 6278 
    ;
    
#line 6279 
    cf_arg_96 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6280 
    cf_arg_96->arg0 = arg0;
    
#line 6281 
    ret = pthread_create(& ldv_thread_96,(pthread_attr_t const *)0,& ldv_character_driver_scenario_96,(void *)cf_arg_96);
    
#line 6282 
    __VERIFIER_assume(ret == 0);
    
#line 6283 
    goto ldv_31338;
    case 90: 
#line 6285 
    ;
    
#line 6286 
    cf_arg_97 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6287 
    cf_arg_97->arg0 = arg0;
    
#line 6288 
    ret = pthread_create(& ldv_thread_97,(pthread_attr_t const *)0,& ldv_character_driver_scenario_97,(void *)cf_arg_97);
    
#line 6289 
    __VERIFIER_assume(ret == 0);
    
#line 6290 
    goto ldv_31338;
    case 91: 
#line 6292 
    ;
    
#line 6293 
    cf_arg_98 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6294 
    cf_arg_98->arg0 = arg0;
    
#line 6295 
    ret = pthread_create(& ldv_thread_98,(pthread_attr_t const *)0,& ldv_character_driver_scenario_98,(void *)cf_arg_98);
    
#line 6296 
    __VERIFIER_assume(ret == 0);
    
#line 6297 
    goto ldv_31338;
    case 92: 
#line 6299 
    ;
    
#line 6300 
    cf_arg_99 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6301 
    cf_arg_99->arg0 = arg0;
    
#line 6302 
    ret = pthread_create(& ldv_thread_99,(pthread_attr_t const *)0,& ldv_character_driver_scenario_99,(void *)cf_arg_99);
    
#line 6303 
    __VERIFIER_assume(ret == 0);
    
#line 6304 
    goto ldv_31338;
    case 93: 
#line 6306 
    ;
    
#line 6307 
    cf_arg_100 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6308 
    cf_arg_100->arg0 = arg0;
    
#line 6309 
    ret = pthread_create(& ldv_thread_100,(pthread_attr_t const *)0,& ldv_character_driver_scenario_100,(void *)cf_arg_100);
    
#line 6310 
    __VERIFIER_assume(ret == 0);
    
#line 6311 
    goto ldv_31338;
    case 94: 
#line 6313 
    ;
    
#line 6314 
    cf_arg_101 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6315 
    cf_arg_101->arg0 = arg0;
    
#line 6316 
    ret = pthread_create(& ldv_thread_101,(pthread_attr_t const *)0,& ldv_character_driver_scenario_101,(void *)cf_arg_101);
    
#line 6317 
    __VERIFIER_assume(ret == 0);
    
#line 6318 
    goto ldv_31338;
    case 95: 
#line 6320 
    ;
    
#line 6321 
    cf_arg_102 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6322 
    cf_arg_102->arg0 = arg0;
    
#line 6323 
    ret = pthread_create(& ldv_thread_102,(pthread_attr_t const *)0,& ldv_character_driver_scenario_102,(void *)cf_arg_102);
    
#line 6324 
    __VERIFIER_assume(ret == 0);
    
#line 6325 
    goto ldv_31338;
    case 96: 
#line 6327 
    ;
    
#line 6328 
    cf_arg_103 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6329 
    cf_arg_103->arg0 = arg0;
    
#line 6330 
    ret = pthread_create(& ldv_thread_103,(pthread_attr_t const *)0,& ldv_character_driver_scenario_103,(void *)cf_arg_103);
    
#line 6331 
    __VERIFIER_assume(ret == 0);
    
#line 6332 
    goto ldv_31338;
    case 97: 
#line 6334 
    ;
    
#line 6335 
    cf_arg_104 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6336 
    cf_arg_104->arg0 = arg0;
    
#line 6337 
    ret = pthread_create(& ldv_thread_104,(pthread_attr_t const *)0,& ldv_character_driver_scenario_104,(void *)cf_arg_104);
    
#line 6338 
    __VERIFIER_assume(ret == 0);
    
#line 6339 
    goto ldv_31338;
    case 98: 
#line 6341 
    ;
    
#line 6342 
    cf_arg_105 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6343 
    cf_arg_105->arg0 = arg0;
    
#line 6344 
    ret = pthread_create(& ldv_thread_105,(pthread_attr_t const *)0,& ldv_character_driver_scenario_105,(void *)cf_arg_105);
    
#line 6345 
    __VERIFIER_assume(ret == 0);
    
#line 6346 
    goto ldv_31338;
    case 99: 
#line 6348 
    ;
    
#line 6349 
    cf_arg_106 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6350 
    cf_arg_106->arg0 = arg0;
    
#line 6351 
    ret = pthread_create(& ldv_thread_106,(pthread_attr_t const *)0,& ldv_character_driver_scenario_106,(void *)cf_arg_106);
    
#line 6352 
    __VERIFIER_assume(ret == 0);
    
#line 6353 
    goto ldv_31338;
    case 100: 
#line 6355 
    ;
    
#line 6356 
    cf_arg_107 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6357 
    cf_arg_107->arg0 = arg0;
    
#line 6358 
    ret = pthread_create(& ldv_thread_107,(pthread_attr_t const *)0,& ldv_character_driver_scenario_107,(void *)cf_arg_107);
    
#line 6359 
    __VERIFIER_assume(ret == 0);
    
#line 6360 
    goto ldv_31338;
    case 101: 
#line 6362 
    ;
    
#line 6363 
    cf_arg_109 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6364 
    cf_arg_109->arg0 = arg0;
    
#line 6365 
    ret = pthread_create(& ldv_thread_109,(pthread_attr_t const *)0,& ldv_character_driver_scenario_109,(void *)cf_arg_109);
    
#line 6366 
    __VERIFIER_assume(ret == 0);
    
#line 6367 
    goto ldv_31338;
    case 102: 
#line 6369 
    ;
    
#line 6370 
    cf_arg_110 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6371 
    cf_arg_110->arg0 = arg0;
    
#line 6372 
    ret = pthread_create(& ldv_thread_110,(pthread_attr_t const *)0,& ldv_character_driver_scenario_110,(void *)cf_arg_110);
    
#line 6373 
    __VERIFIER_assume(ret == 0);
    
#line 6374 
    goto ldv_31338;
    case 103: 
#line 6376 
    ;
    
#line 6377 
    cf_arg_111 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6378 
    cf_arg_111->arg0 = arg0;
    
#line 6379 
    ret = pthread_create(& ldv_thread_111,(pthread_attr_t const *)0,& ldv_character_driver_scenario_111,(void *)cf_arg_111);
    
#line 6380 
    __VERIFIER_assume(ret == 0);
    
#line 6381 
    goto ldv_31338;
    case 104: 
#line 6383 
    ;
    
#line 6384 
    cf_arg_112 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6385 
    cf_arg_112->arg0 = arg0;
    
#line 6386 
    ret = pthread_create(& ldv_thread_112,(pthread_attr_t const *)0,& ldv_character_driver_scenario_112,(void *)cf_arg_112);
    
#line 6387 
    __VERIFIER_assume(ret == 0);
    
#line 6388 
    goto ldv_31338;
    case 105: 
#line 6390 
    ;
    
#line 6391 
    cf_arg_113 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6392 
    cf_arg_113->arg0 = arg0;
    
#line 6393 
    ret = pthread_create(& ldv_thread_113,(pthread_attr_t const *)0,& ldv_character_driver_scenario_113,(void *)cf_arg_113);
    
#line 6394 
    __VERIFIER_assume(ret == 0);
    
#line 6395 
    goto ldv_31338;
    case 106: 
#line 6397 
    ;
    
#line 6398 
    cf_arg_114 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6399 
    cf_arg_114->arg0 = arg0;
    
#line 6400 
    ret = pthread_create(& ldv_thread_114,(pthread_attr_t const *)0,& ldv_character_driver_scenario_114,(void *)cf_arg_114);
    
#line 6401 
    __VERIFIER_assume(ret == 0);
    
#line 6402 
    goto ldv_31338;
    case 107: 
#line 6404 
    ;
    
#line 6405 
    cf_arg_115 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6406 
    cf_arg_115->arg0 = arg0;
    
#line 6407 
    ret = pthread_create(& ldv_thread_115,(pthread_attr_t const *)0,& ldv_character_driver_scenario_115,(void *)cf_arg_115);
    
#line 6408 
    __VERIFIER_assume(ret == 0);
    
#line 6409 
    goto ldv_31338;
    case 108: 
#line 6411 
    ;
    
#line 6412 
    cf_arg_116 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6413 
    cf_arg_116->arg0 = arg0;
    
#line 6414 
    ret = pthread_create(& ldv_thread_116,(pthread_attr_t const *)0,& ldv_character_driver_scenario_116,(void *)cf_arg_116);
    
#line 6415 
    __VERIFIER_assume(ret == 0);
    
#line 6416 
    goto ldv_31338;
    case 109: 
#line 6418 
    ;
    
#line 6419 
    cf_arg_117 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6420 
    cf_arg_117->arg0 = arg0;
    
#line 6421 
    ret = pthread_create(& ldv_thread_117,(pthread_attr_t const *)0,& ldv_character_driver_scenario_117,(void *)cf_arg_117);
    
#line 6422 
    __VERIFIER_assume(ret == 0);
    
#line 6423 
    goto ldv_31338;
    case 110: 
#line 6425 
    ;
    
#line 6426 
    cf_arg_118 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6427 
    cf_arg_118->arg0 = arg0;
    
#line 6428 
    ret = pthread_create(& ldv_thread_118,(pthread_attr_t const *)0,& ldv_character_driver_scenario_118,(void *)cf_arg_118);
    
#line 6429 
    __VERIFIER_assume(ret == 0);
    
#line 6430 
    goto ldv_31338;
    case 111: 
#line 6432 
    ;
    
#line 6433 
    cf_arg_119 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6434 
    cf_arg_119->arg0 = arg0;
    
#line 6435 
    ret = pthread_create(& ldv_thread_119,(pthread_attr_t const *)0,& ldv_character_driver_scenario_119,(void *)cf_arg_119);
    
#line 6436 
    __VERIFIER_assume(ret == 0);
    
#line 6437 
    goto ldv_31338;
    case 112: 
#line 6439 
    ;
    
#line 6440 
    cf_arg_120 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6441 
    cf_arg_120->arg0 = arg0;
    
#line 6442 
    ret = pthread_create(& ldv_thread_120,(pthread_attr_t const *)0,& ldv_character_driver_scenario_120,(void *)cf_arg_120);
    
#line 6443 
    __VERIFIER_assume(ret == 0);
    
#line 6444 
    goto ldv_31338;
    case 113: 
#line 6446 
    ;
    
#line 6447 
    cf_arg_121 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6448 
    cf_arg_121->arg0 = arg0;
    
#line 6449 
    ret = pthread_create(& ldv_thread_121,(pthread_attr_t const *)0,& ldv_character_driver_scenario_121,(void *)cf_arg_121);
    
#line 6450 
    __VERIFIER_assume(ret == 0);
    
#line 6451 
    goto ldv_31338;
    case 114: 
#line 6453 
    ;
    
#line 6454 
    cf_arg_122 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6455 
    cf_arg_122->arg0 = arg0;
    
#line 6456 
    ret = pthread_create(& ldv_thread_122,(pthread_attr_t const *)0,& ldv_character_driver_scenario_122,(void *)cf_arg_122);
    
#line 6457 
    __VERIFIER_assume(ret == 0);
    
#line 6458 
    goto ldv_31338;
    case 115: 
#line 6460 
    ;
    
#line 6461 
    cf_arg_123 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6462 
    cf_arg_123->arg0 = arg0;
    
#line 6463 
    ret = pthread_create(& ldv_thread_123,(pthread_attr_t const *)0,& ldv_character_driver_scenario_123,(void *)cf_arg_123);
    
#line 6464 
    __VERIFIER_assume(ret == 0);
    
#line 6465 
    goto ldv_31338;
    case 116: 
#line 6467 
    ;
    
#line 6468 
    cf_arg_124 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6469 
    cf_arg_124->arg0 = arg0;
    
#line 6470 
    ret = pthread_create(& ldv_thread_124,(pthread_attr_t const *)0,& ldv_character_driver_scenario_124,(void *)cf_arg_124);
    
#line 6471 
    __VERIFIER_assume(ret == 0);
    
#line 6472 
    goto ldv_31338;
    case 117: 
#line 6474 
    ;
    
#line 6475 
    cf_arg_125 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6476 
    cf_arg_125->arg0 = arg0;
    
#line 6477 
    ret = pthread_create(& ldv_thread_125,(pthread_attr_t const *)0,& ldv_character_driver_scenario_125,(void *)cf_arg_125);
    
#line 6478 
    __VERIFIER_assume(ret == 0);
    
#line 6479 
    goto ldv_31338;
    case 118: 
#line 6481 
    ;
    
#line 6482 
    cf_arg_126 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6483 
    cf_arg_126->arg0 = arg0;
    
#line 6484 
    ret = pthread_create(& ldv_thread_126,(pthread_attr_t const *)0,& ldv_character_driver_scenario_126,(void *)cf_arg_126);
    
#line 6485 
    __VERIFIER_assume(ret == 0);
    
#line 6486 
    goto ldv_31338;
    case 119: 
#line 6488 
    ;
    
#line 6489 
    cf_arg_127 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6490 
    cf_arg_127->arg0 = arg0;
    
#line 6491 
    ret = pthread_create(& ldv_thread_127,(pthread_attr_t const *)0,& ldv_character_driver_scenario_127,(void *)cf_arg_127);
    
#line 6492 
    __VERIFIER_assume(ret == 0);
    
#line 6493 
    goto ldv_31338;
    case 120: 
#line 6495 
    ;
    
#line 6496 
    cf_arg_128 = (struct ldv_struct_character_driver_scenario_6 *)ldv_xmalloc(16UL);
    
#line 6497 
    cf_arg_128->arg0 = arg0;
    
#line 6498 
    ret = pthread_create(& ldv_thread_128,(pthread_attr_t const *)0,& ldv_character_driver_scenario_128,(void *)cf_arg_128);
    
#line 6499 
    __VERIFIER_assume(ret == 0);
    
#line 6500 
    goto ldv_31338;
    default: 
#line 6502 
    ;
    
#line 6502 
    __VERIFIER_assume(0);
  }
  ldv_31338: 
#line 6503 
  ;
  
#line 6504 
  return;
}


#line 6508  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_117(void *arg0)
{
  void *__retres;
  struct file *ldv_117_resource_1;
  int ldv_117_ldv_param_2_3;
  long long ldv_117_ldv_param_1_2;
  char *ldv_117_ldv_param_1_4;
  struct inode *ldv_117_resource_0;
  unsigned long ldv_117_size_cnt;
  long long *ldv_117_ldv_param_3_5;
  char *ldv_117_ldv_param_1_6;
  long long *ldv_117_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 6519 
  struct file_operations *ldv_117_container = ldv_emg_alias_tx_tx_retry_template_ops_2;
  
#line 6520 
  int ldv_117_ret = ldv_undef_int();
  
#line 6523 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 6527 
  ldv_117_ret = ldv_undef_int();
  
#line 6530 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 6531 
    ldv_117_container = data->arg0;
    
#line 6532 
    ldv_free((void *)data);
  }
  else ;
  
#line 6537 
  ldv_117_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 6538 
  tmp_1 = ldv_undef_int();
  
#line 6538 
  ldv_117_size_cnt = (unsigned long)tmp_1;
  
#line 6545 
  goto ldv_main_117;
  
#line 6547 
  __retres = (void *)0;
  
#line 6547 
  goto return_label;
  ldv_main_117: 
#line 6550 
  ;
  
#line 6553 
  tmp_3 = ldv_undef_int();
  
#line 6553 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 6556 
    ldv_117_ret = (*ldv_emg_alias_simple_open_5)(ldv_117_resource_0,ldv_117_resource_1);
    
#line 6558 
    ldv_117_ret = ldv_filter_err_code(ldv_117_ret);
    
#line 6561 
    tmp_2 = ldv_undef_int();
    
#line 6561 
    if (tmp_2 != 0) {
      
#line 6563 
      __VERIFIER_assume(ldv_117_ret == 0);
      
#line 6570 
      goto ldv_call_117;
    }
    else {
      
#line 6574 
      __VERIFIER_assume(ldv_117_ret != 0);
      
#line 6581 
      goto ldv_main_117;
    }
  }
  else {
    
#line 6586 
    ldv_free((void *)ldv_117_resource_0);
    
#line 6594 
    __retres = (void *)0;
    
#line 6594 
    goto return_label;
  }
  
#line 6597 
  __retres = (void *)0;
  
#line 6597 
  goto return_label;
  ldv_call_117: 
#line 6600 
  ;
  
#line 6603 
  tmp_4 = ldv_undef_int();
  
#line 6603 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 6604 
    ;
    
#line 6606 
    ldv_117_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 6607 
    ldv_117_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 6611 
    if (ldv_117_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 6617 
      __VERIFIER_assume(ldv_117_size_cnt <= 2147479552UL);
      
#line 6619 
      (*(ldv_117_container->write))(ldv_117_resource_1,(char const *)ldv_117_ldv_param_1_6,ldv_117_size_cnt,ldv_117_ldv_param_3_7);
    }
    else ;
    
#line 6624 
    ldv_free((void *)ldv_117_ldv_param_1_6);
    
#line 6625 
    ldv_free((void *)ldv_117_ldv_param_3_7);
    
#line 6632 
    goto ldv_call_117;
    case 2: 
#line 6635 
    ;
    
#line 6637 
    if (ldv_117_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 6639 
      (*(ldv_117_container->release))(ldv_117_resource_0,ldv_117_resource_1); else ;
    
#line 6647 
    goto ldv_main_117;
    case 3: 
#line 6650 
    ;
    
#line 6654 
    tmp_9 = ldv_undef_int();
    
#line 6654 
    if (tmp_9 != 0) 
#line 6657 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_117_resource_1,ldv_117_ldv_param_1_2,ldv_117_ldv_param_2_3);
    else {
      
#line 6663 
      ldv_117_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 6664 
      ldv_117_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 6669 
      ldv_emg_wrapper_tx_tx_retry_template_read_3(ldv_117_resource_1,ldv_117_ldv_param_1_4,ldv_117_size_cnt,ldv_117_ldv_param_3_5);
      
#line 6673 
      ldv_free((void *)ldv_117_ldv_param_1_4);
      
#line 6674 
      ldv_free((void *)ldv_117_ldv_param_3_5);
    }
    
#line 6678 
    goto ldv_31480;
    default: 
#line 6680 
    ;
    
#line 6680 
    __VERIFIER_assume(0);
  }
  ldv_31480: 
#line 6689 
  ;
  
#line 6689 
  goto ldv_call_117;
  
#line 6691 
  __retres = (void *)0;
  return_label: 
#line 6691 
                return __retres;
}


#line 6696  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_122(void *arg0)
{
  void *__retres;
  struct file *ldv_122_resource_1;
  int ldv_122_ldv_param_2_3;
  long long ldv_122_ldv_param_1_2;
  char *ldv_122_ldv_param_1_4;
  struct inode *ldv_122_resource_0;
  unsigned long ldv_122_size_cnt;
  long long *ldv_122_ldv_param_3_5;
  char *ldv_122_ldv_param_1_6;
  long long *ldv_122_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 6707 
  struct file_operations *ldv_122_container = ldv_emg_alias_pipeline_pipeline_fifo_full_ops_2;
  
#line 6708 
  int ldv_122_ret = ldv_undef_int();
  
#line 6711 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 6715 
  ldv_122_ret = ldv_undef_int();
  
#line 6718 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 6719 
    ldv_122_container = data->arg0;
    
#line 6720 
    ldv_free((void *)data);
  }
  else ;
  
#line 6725 
  ldv_122_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 6726 
  tmp_1 = ldv_undef_int();
  
#line 6726 
  ldv_122_size_cnt = (unsigned long)tmp_1;
  
#line 6733 
  goto ldv_main_122;
  
#line 6735 
  __retres = (void *)0;
  
#line 6735 
  goto return_label;
  ldv_main_122: 
#line 6738 
  ;
  
#line 6741 
  tmp_3 = ldv_undef_int();
  
#line 6741 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 6744 
    ldv_122_ret = (*ldv_emg_alias_simple_open_5)(ldv_122_resource_0,ldv_122_resource_1);
    
#line 6746 
    ldv_122_ret = ldv_filter_err_code(ldv_122_ret);
    
#line 6749 
    tmp_2 = ldv_undef_int();
    
#line 6749 
    if (tmp_2 != 0) {
      
#line 6751 
      __VERIFIER_assume(ldv_122_ret == 0);
      
#line 6758 
      goto ldv_call_122;
    }
    else {
      
#line 6762 
      __VERIFIER_assume(ldv_122_ret != 0);
      
#line 6769 
      goto ldv_main_122;
    }
  }
  else {
    
#line 6774 
    ldv_free((void *)ldv_122_resource_0);
    
#line 6782 
    __retres = (void *)0;
    
#line 6782 
    goto return_label;
  }
  
#line 6785 
  __retres = (void *)0;
  
#line 6785 
  goto return_label;
  ldv_call_122: 
#line 6788 
  ;
  
#line 6791 
  tmp_4 = ldv_undef_int();
  
#line 6791 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 6792 
    ;
    
#line 6794 
    ldv_122_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 6795 
    ldv_122_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 6799 
    if (ldv_122_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 6805 
      __VERIFIER_assume(ldv_122_size_cnt <= 2147479552UL);
      
#line 6807 
      (*(ldv_122_container->write))(ldv_122_resource_1,(char const *)ldv_122_ldv_param_1_6,ldv_122_size_cnt,ldv_122_ldv_param_3_7);
    }
    else ;
    
#line 6812 
    ldv_free((void *)ldv_122_ldv_param_3_7);
    
#line 6813 
    ldv_free((void *)ldv_122_ldv_param_1_6);
    
#line 6820 
    goto ldv_call_122;
    case 2: 
#line 6823 
    ;
    
#line 6825 
    if (ldv_122_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 6827 
      (*(ldv_122_container->release))(ldv_122_resource_0,ldv_122_resource_1); else ;
    
#line 6835 
    goto ldv_main_122;
    case 3: 
#line 6838 
    ;
    
#line 6842 
    tmp_9 = ldv_undef_int();
    
#line 6842 
    if (tmp_9 != 0) 
#line 6845 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_122_resource_1,ldv_122_ldv_param_1_2,ldv_122_ldv_param_2_3);
    else {
      
#line 6851 
      ldv_122_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 6852 
      ldv_122_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 6857 
      ldv_emg_wrapper_pipeline_pipeline_fifo_full_read_3(ldv_122_resource_1,ldv_122_ldv_param_1_4,ldv_122_size_cnt,ldv_122_ldv_param_3_5);
      
#line 6861 
      ldv_free((void *)ldv_122_ldv_param_3_5);
      
#line 6862 
      ldv_free((void *)ldv_122_ldv_param_1_4);
    }
    
#line 6866 
    goto ldv_31502;
    default: 
#line 6868 
    ;
    
#line 6868 
    __VERIFIER_assume(0);
  }
  ldv_31502: 
#line 6877 
  ;
  
#line 6877 
  goto ldv_call_122;
  
#line 6879 
  __retres = (void *)0;
  return_label: 
#line 6879 
                return __retres;
}


#line 6884  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_95(void *arg0)
{
  void *__retres;
  struct file *ldv_95_resource_1;
  int ldv_95_ldv_param_2_3;
  long long ldv_95_ldv_param_1_2;
  char *ldv_95_ldv_param_1_4;
  struct inode *ldv_95_resource_0;
  unsigned long ldv_95_size_cnt;
  long long *ldv_95_ldv_param_3_5;
  char *ldv_95_ldv_param_1_6;
  long long *ldv_95_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 6895 
  struct file_operations *ldv_95_container = ldv_emg_alias_mem_tx_free_mem_blks_ops_2;
  
#line 6896 
  int ldv_95_ret = ldv_undef_int();
  
#line 6899 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 6903 
  ldv_95_ret = ldv_undef_int();
  
#line 6906 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 6907 
    ldv_95_container = data->arg0;
    
#line 6908 
    ldv_free((void *)data);
  }
  else ;
  
#line 6913 
  ldv_95_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 6914 
  tmp_1 = ldv_undef_int();
  
#line 6914 
  ldv_95_size_cnt = (unsigned long)tmp_1;
  
#line 6921 
  goto ldv_main_95;
  
#line 6923 
  __retres = (void *)0;
  
#line 6923 
  goto return_label;
  ldv_main_95: 
#line 6926 
  ;
  
#line 6929 
  tmp_3 = ldv_undef_int();
  
#line 6929 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 6932 
    ldv_95_ret = (*ldv_emg_alias_simple_open_5)(ldv_95_resource_0,ldv_95_resource_1);
    
#line 6934 
    ldv_95_ret = ldv_filter_err_code(ldv_95_ret);
    
#line 6937 
    tmp_2 = ldv_undef_int();
    
#line 6937 
    if (tmp_2 != 0) {
      
#line 6939 
      __VERIFIER_assume(ldv_95_ret == 0);
      
#line 6946 
      goto ldv_call_95;
    }
    else {
      
#line 6950 
      __VERIFIER_assume(ldv_95_ret != 0);
      
#line 6957 
      goto ldv_main_95;
    }
  }
  else {
    
#line 6962 
    ldv_free((void *)ldv_95_resource_0);
    
#line 6970 
    __retres = (void *)0;
    
#line 6970 
    goto return_label;
  }
  
#line 6973 
  __retres = (void *)0;
  
#line 6973 
  goto return_label;
  ldv_call_95: 
#line 6976 
  ;
  
#line 6979 
  tmp_4 = ldv_undef_int();
  
#line 6979 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 6980 
    ;
    
#line 6982 
    ldv_95_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 6983 
    ldv_95_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 6987 
    if (ldv_95_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 6993 
      __VERIFIER_assume(ldv_95_size_cnt <= 2147479552UL);
      
#line 6995 
      (*(ldv_95_container->write))(ldv_95_resource_1,(char const *)ldv_95_ldv_param_1_6,ldv_95_size_cnt,ldv_95_ldv_param_3_7);
    }
    else ;
    
#line 7000 
    ldv_free((void *)ldv_95_ldv_param_1_6);
    
#line 7001 
    ldv_free((void *)ldv_95_ldv_param_3_7);
    
#line 7008 
    goto ldv_call_95;
    case 2: 
#line 7011 
    ;
    
#line 7013 
    if (ldv_95_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 7015 
      (*(ldv_95_container->release))(ldv_95_resource_0,ldv_95_resource_1); else ;
    
#line 7023 
    goto ldv_main_95;
    case 3: 
#line 7026 
    ;
    
#line 7030 
    tmp_9 = ldv_undef_int();
    
#line 7030 
    if (tmp_9 != 0) 
#line 7033 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_95_resource_1,ldv_95_ldv_param_1_2,ldv_95_ldv_param_2_3);
    else {
      
#line 7039 
      ldv_95_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 7040 
      ldv_95_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 7045 
      ldv_emg_wrapper_mem_tx_free_mem_blks_read_3(ldv_95_resource_1,ldv_95_ldv_param_1_4,ldv_95_size_cnt,ldv_95_ldv_param_3_5);
      
#line 7049 
      ldv_free((void *)ldv_95_ldv_param_1_4);
      
#line 7050 
      ldv_free((void *)ldv_95_ldv_param_3_5);
    }
    
#line 7054 
    goto ldv_31524;
    default: 
#line 7056 
    ;
    
#line 7056 
    __VERIFIER_assume(0);
  }
  ldv_31524: 
#line 7065 
  ;
  
#line 7065 
  goto ldv_call_95;
  
#line 7067 
  __retres = (void *)0;
  return_label: 
#line 7067 
                return __retres;
}


#line 7072  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_25(void *arg0)
{
  void *__retres;
  struct file *ldv_25_resource_1;
  int ldv_25_ldv_param_2_3;
  long long ldv_25_ldv_param_1_2;
  char *ldv_25_ldv_param_1_4;
  struct inode *ldv_25_resource_0;
  unsigned long ldv_25_size_cnt;
  long long *ldv_25_ldv_param_3_5;
  char *ldv_25_ldv_param_1_6;
  long long *ldv_25_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 7083 
  struct file_operations *ldv_25_container = ldv_emg_alias_rx_defrag_need_defrag_ops_2;
  
#line 7084 
  int ldv_25_ret = ldv_undef_int();
  
#line 7087 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 7091 
  ldv_25_ret = ldv_undef_int();
  
#line 7094 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 7095 
    ldv_25_container = data->arg0;
    
#line 7096 
    ldv_free((void *)data);
  }
  else ;
  
#line 7101 
  ldv_25_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 7102 
  tmp_1 = ldv_undef_int();
  
#line 7102 
  ldv_25_size_cnt = (unsigned long)tmp_1;
  
#line 7109 
  goto ldv_main_25;
  
#line 7111 
  __retres = (void *)0;
  
#line 7111 
  goto return_label;
  ldv_main_25: 
#line 7114 
  ;
  
#line 7117 
  tmp_3 = ldv_undef_int();
  
#line 7117 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 7120 
    ldv_25_ret = (*ldv_emg_alias_simple_open_5)(ldv_25_resource_0,ldv_25_resource_1);
    
#line 7122 
    ldv_25_ret = ldv_filter_err_code(ldv_25_ret);
    
#line 7125 
    tmp_2 = ldv_undef_int();
    
#line 7125 
    if (tmp_2 != 0) {
      
#line 7127 
      __VERIFIER_assume(ldv_25_ret == 0);
      
#line 7134 
      goto ldv_call_25;
    }
    else {
      
#line 7138 
      __VERIFIER_assume(ldv_25_ret != 0);
      
#line 7145 
      goto ldv_main_25;
    }
  }
  else {
    
#line 7150 
    ldv_free((void *)ldv_25_resource_0);
    
#line 7158 
    __retres = (void *)0;
    
#line 7158 
    goto return_label;
  }
  
#line 7161 
  __retres = (void *)0;
  
#line 7161 
  goto return_label;
  ldv_call_25: 
#line 7164 
  ;
  
#line 7167 
  tmp_4 = ldv_undef_int();
  
#line 7167 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 7168 
    ;
    
#line 7170 
    ldv_25_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 7171 
    ldv_25_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 7175 
    if (ldv_25_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 7181 
      __VERIFIER_assume(ldv_25_size_cnt <= 2147479552UL);
      
#line 7183 
      (*(ldv_25_container->write))(ldv_25_resource_1,(char const *)ldv_25_ldv_param_1_6,ldv_25_size_cnt,ldv_25_ldv_param_3_7);
    }
    else ;
    
#line 7188 
    ldv_free((void *)ldv_25_ldv_param_3_7);
    
#line 7189 
    ldv_free((void *)ldv_25_ldv_param_1_6);
    
#line 7196 
    goto ldv_call_25;
    case 2: 
#line 7199 
    ;
    
#line 7201 
    if (ldv_25_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 7203 
      (*(ldv_25_container->release))(ldv_25_resource_0,ldv_25_resource_1); else ;
    
#line 7211 
    goto ldv_main_25;
    case 3: 
#line 7214 
    ;
    
#line 7218 
    tmp_9 = ldv_undef_int();
    
#line 7218 
    if (tmp_9 != 0) 
#line 7221 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_25_resource_1,ldv_25_ldv_param_1_2,ldv_25_ldv_param_2_3);
    else {
      
#line 7227 
      ldv_25_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 7228 
      ldv_25_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 7233 
      ldv_emg_wrapper_rx_defrag_need_defrag_read_3(ldv_25_resource_1,ldv_25_ldv_param_1_4,ldv_25_size_cnt,ldv_25_ldv_param_3_5);
      
#line 7237 
      ldv_free((void *)ldv_25_ldv_param_3_5);
      
#line 7238 
      ldv_free((void *)ldv_25_ldv_param_1_4);
    }
    
#line 7242 
    goto ldv_31546;
    default: 
#line 7244 
    ;
    
#line 7244 
    __VERIFIER_assume(0);
  }
  ldv_31546: 
#line 7253 
  ;
  
#line 7253 
  goto ldv_call_25;
  
#line 7255 
  __retres = (void *)0;
  return_label: 
#line 7255 
                return __retres;
}


#line 7260  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_49(void *arg0)
{
  void *__retres;
  struct file *ldv_49_resource_1;
  int ldv_49_ldv_param_2_3;
  long long ldv_49_ldv_param_1_2;
  char *ldv_49_ldv_param_1_4;
  struct inode *ldv_49_resource_0;
  unsigned long ldv_49_size_cnt;
  long long *ldv_49_ldv_param_3_5;
  char *ldv_49_ldv_param_1_6;
  long long *ldv_49_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 7271 
  struct file_operations *ldv_49_container = ldv_emg_alias_pipeline_cs_rx_packet_in_ops_2;
  
#line 7272 
  int ldv_49_ret = ldv_undef_int();
  
#line 7275 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 7279 
  ldv_49_ret = ldv_undef_int();
  
#line 7282 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 7283 
    ldv_49_container = data->arg0;
    
#line 7284 
    ldv_free((void *)data);
  }
  else ;
  
#line 7289 
  ldv_49_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 7290 
  tmp_1 = ldv_undef_int();
  
#line 7290 
  ldv_49_size_cnt = (unsigned long)tmp_1;
  
#line 7297 
  goto ldv_main_49;
  
#line 7299 
  __retres = (void *)0;
  
#line 7299 
  goto return_label;
  ldv_main_49: 
#line 7302 
  ;
  
#line 7305 
  tmp_3 = ldv_undef_int();
  
#line 7305 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 7308 
    ldv_49_ret = (*ldv_emg_alias_simple_open_5)(ldv_49_resource_0,ldv_49_resource_1);
    
#line 7310 
    ldv_49_ret = ldv_filter_err_code(ldv_49_ret);
    
#line 7313 
    tmp_2 = ldv_undef_int();
    
#line 7313 
    if (tmp_2 != 0) {
      
#line 7315 
      __VERIFIER_assume(ldv_49_ret == 0);
      
#line 7322 
      goto ldv_call_49;
    }
    else {
      
#line 7326 
      __VERIFIER_assume(ldv_49_ret != 0);
      
#line 7333 
      goto ldv_main_49;
    }
  }
  else {
    
#line 7338 
    ldv_free((void *)ldv_49_resource_0);
    
#line 7346 
    __retres = (void *)0;
    
#line 7346 
    goto return_label;
  }
  
#line 7349 
  __retres = (void *)0;
  
#line 7349 
  goto return_label;
  ldv_call_49: 
#line 7352 
  ;
  
#line 7355 
  tmp_4 = ldv_undef_int();
  
#line 7355 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 7356 
    ;
    
#line 7358 
    ldv_49_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 7359 
    ldv_49_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 7363 
    if (ldv_49_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 7369 
      __VERIFIER_assume(ldv_49_size_cnt <= 2147479552UL);
      
#line 7371 
      (*(ldv_49_container->write))(ldv_49_resource_1,(char const *)ldv_49_ldv_param_1_6,ldv_49_size_cnt,ldv_49_ldv_param_3_7);
    }
    else ;
    
#line 7376 
    ldv_free((void *)ldv_49_ldv_param_3_7);
    
#line 7377 
    ldv_free((void *)ldv_49_ldv_param_1_6);
    
#line 7384 
    goto ldv_call_49;
    case 2: 
#line 7387 
    ;
    
#line 7389 
    if (ldv_49_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 7391 
      (*(ldv_49_container->release))(ldv_49_resource_0,ldv_49_resource_1); else ;
    
#line 7399 
    goto ldv_main_49;
    case 3: 
#line 7402 
    ;
    
#line 7406 
    tmp_9 = ldv_undef_int();
    
#line 7406 
    if (tmp_9 != 0) 
#line 7409 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_49_resource_1,ldv_49_ldv_param_1_2,ldv_49_ldv_param_2_3);
    else {
      
#line 7415 
      ldv_49_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 7416 
      ldv_49_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 7421 
      ldv_emg_wrapper_pipeline_cs_rx_packet_in_read_3(ldv_49_resource_1,ldv_49_ldv_param_1_4,ldv_49_size_cnt,ldv_49_ldv_param_3_5);
      
#line 7425 
      ldv_free((void *)ldv_49_ldv_param_3_5);
      
#line 7426 
      ldv_free((void *)ldv_49_ldv_param_1_4);
    }
    
#line 7430 
    goto ldv_31568;
    default: 
#line 7432 
    ;
    
#line 7432 
    __VERIFIER_assume(0);
  }
  ldv_31568: 
#line 7441 
  ;
  
#line 7441 
  goto ldv_call_49;
  
#line 7443 
  __retres = (void *)0;
  return_label: 
#line 7443 
                return __retres;
}


#line 7448  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_55(void *arg0)
{
  void *__retres;
  struct file *ldv_55_resource_1;
  int ldv_55_ldv_param_2_3;
  long long ldv_55_ldv_param_1_2;
  char *ldv_55_ldv_param_1_4;
  struct inode *ldv_55_resource_0;
  unsigned long ldv_55_size_cnt;
  long long *ldv_55_ldv_param_3_5;
  char *ldv_55_ldv_param_1_6;
  long long *ldv_55_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 7459 
  struct file_operations *ldv_55_container = ldv_emg_alias_error_error_null_Frame_tx_start_ops_2;
  
#line 7460 
  int ldv_55_ret = ldv_undef_int();
  
#line 7463 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 7467 
  ldv_55_ret = ldv_undef_int();
  
#line 7470 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 7471 
    ldv_55_container = data->arg0;
    
#line 7472 
    ldv_free((void *)data);
  }
  else ;
  
#line 7477 
  ldv_55_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 7478 
  tmp_1 = ldv_undef_int();
  
#line 7478 
  ldv_55_size_cnt = (unsigned long)tmp_1;
  
#line 7485 
  goto ldv_main_55;
  
#line 7487 
  __retres = (void *)0;
  
#line 7487 
  goto return_label;
  ldv_main_55: 
#line 7490 
  ;
  
#line 7493 
  tmp_3 = ldv_undef_int();
  
#line 7493 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 7496 
    ldv_55_ret = (*ldv_emg_alias_simple_open_5)(ldv_55_resource_0,ldv_55_resource_1);
    
#line 7498 
    ldv_55_ret = ldv_filter_err_code(ldv_55_ret);
    
#line 7501 
    tmp_2 = ldv_undef_int();
    
#line 7501 
    if (tmp_2 != 0) {
      
#line 7503 
      __VERIFIER_assume(ldv_55_ret == 0);
      
#line 7510 
      goto ldv_call_55;
    }
    else {
      
#line 7514 
      __VERIFIER_assume(ldv_55_ret != 0);
      
#line 7521 
      goto ldv_main_55;
    }
  }
  else {
    
#line 7526 
    ldv_free((void *)ldv_55_resource_0);
    
#line 7534 
    __retres = (void *)0;
    
#line 7534 
    goto return_label;
  }
  
#line 7537 
  __retres = (void *)0;
  
#line 7537 
  goto return_label;
  ldv_call_55: 
#line 7540 
  ;
  
#line 7543 
  tmp_4 = ldv_undef_int();
  
#line 7543 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 7544 
    ;
    
#line 7546 
    ldv_55_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 7547 
    ldv_55_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 7551 
    if (ldv_55_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 7557 
      __VERIFIER_assume(ldv_55_size_cnt <= 2147479552UL);
      
#line 7559 
      (*(ldv_55_container->write))(ldv_55_resource_1,(char const *)ldv_55_ldv_param_1_6,ldv_55_size_cnt,ldv_55_ldv_param_3_7);
    }
    else ;
    
#line 7564 
    ldv_free((void *)ldv_55_ldv_param_3_7);
    
#line 7565 
    ldv_free((void *)ldv_55_ldv_param_1_6);
    
#line 7572 
    goto ldv_call_55;
    case 2: 
#line 7575 
    ;
    
#line 7577 
    if (ldv_55_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 7579 
      (*(ldv_55_container->release))(ldv_55_resource_0,ldv_55_resource_1); else ;
    
#line 7587 
    goto ldv_main_55;
    case 3: 
#line 7590 
    ;
    
#line 7594 
    tmp_9 = ldv_undef_int();
    
#line 7594 
    if (tmp_9 != 0) 
#line 7597 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_55_resource_1,ldv_55_ldv_param_1_2,ldv_55_ldv_param_2_3);
    else {
      
#line 7603 
      ldv_55_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 7604 
      ldv_55_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 7609 
      ldv_emg_wrapper_error_error_null_Frame_tx_start_read_3(ldv_55_resource_1,ldv_55_ldv_param_1_4,ldv_55_size_cnt,ldv_55_ldv_param_3_5);
      
#line 7613 
      ldv_free((void *)ldv_55_ldv_param_1_4);
      
#line 7614 
      ldv_free((void *)ldv_55_ldv_param_3_5);
    }
    
#line 7618 
    goto ldv_31590;
    default: 
#line 7620 
    ;
    
#line 7620 
    __VERIFIER_assume(0);
  }
  ldv_31590: 
#line 7629 
  ;
  
#line 7629 
  goto ldv_call_55;
  
#line 7631 
  __retres = (void *)0;
  return_label: 
#line 7631 
                return __retres;
}


#line 7636  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_116(void *arg0)
{
  void *__retres;
  struct file *ldv_116_resource_1;
  int ldv_116_ldv_param_2_3;
  long long ldv_116_ldv_param_1_2;
  char *ldv_116_ldv_param_1_4;
  struct inode *ldv_116_resource_0;
  unsigned long ldv_116_size_cnt;
  long long *ldv_116_ldv_param_3_5;
  char *ldv_116_ldv_param_1_6;
  long long *ldv_116_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 7647 
  struct file_operations *ldv_116_container = ldv_emg_alias_tx_frag_key_not_found_ops_2;
  
#line 7648 
  int ldv_116_ret = ldv_undef_int();
  
#line 7651 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 7655 
  ldv_116_ret = ldv_undef_int();
  
#line 7658 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 7659 
    ldv_116_container = data->arg0;
    
#line 7660 
    ldv_free((void *)data);
  }
  else ;
  
#line 7665 
  ldv_116_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 7666 
  tmp_1 = ldv_undef_int();
  
#line 7666 
  ldv_116_size_cnt = (unsigned long)tmp_1;
  
#line 7673 
  goto ldv_main_116;
  
#line 7675 
  __retres = (void *)0;
  
#line 7675 
  goto return_label;
  ldv_main_116: 
#line 7678 
  ;
  
#line 7681 
  tmp_3 = ldv_undef_int();
  
#line 7681 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 7684 
    ldv_116_ret = (*ldv_emg_alias_simple_open_5)(ldv_116_resource_0,ldv_116_resource_1);
    
#line 7686 
    ldv_116_ret = ldv_filter_err_code(ldv_116_ret);
    
#line 7689 
    tmp_2 = ldv_undef_int();
    
#line 7689 
    if (tmp_2 != 0) {
      
#line 7691 
      __VERIFIER_assume(ldv_116_ret == 0);
      
#line 7698 
      goto ldv_call_116;
    }
    else {
      
#line 7702 
      __VERIFIER_assume(ldv_116_ret != 0);
      
#line 7709 
      goto ldv_main_116;
    }
  }
  else {
    
#line 7714 
    ldv_free((void *)ldv_116_resource_0);
    
#line 7722 
    __retres = (void *)0;
    
#line 7722 
    goto return_label;
  }
  
#line 7725 
  __retres = (void *)0;
  
#line 7725 
  goto return_label;
  ldv_call_116: 
#line 7728 
  ;
  
#line 7731 
  tmp_4 = ldv_undef_int();
  
#line 7731 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 7732 
    ;
    
#line 7734 
    ldv_116_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 7735 
    ldv_116_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 7739 
    if (ldv_116_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 7745 
      __VERIFIER_assume(ldv_116_size_cnt <= 2147479552UL);
      
#line 7747 
      (*(ldv_116_container->write))(ldv_116_resource_1,(char const *)ldv_116_ldv_param_1_6,ldv_116_size_cnt,ldv_116_ldv_param_3_7);
    }
    else ;
    
#line 7752 
    ldv_free((void *)ldv_116_ldv_param_3_7);
    
#line 7753 
    ldv_free((void *)ldv_116_ldv_param_1_6);
    
#line 7760 
    goto ldv_call_116;
    case 2: 
#line 7763 
    ;
    
#line 7765 
    if (ldv_116_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 7767 
      (*(ldv_116_container->release))(ldv_116_resource_0,ldv_116_resource_1); else ;
    
#line 7775 
    goto ldv_main_116;
    case 3: 
#line 7778 
    ;
    
#line 7782 
    tmp_9 = ldv_undef_int();
    
#line 7782 
    if (tmp_9 != 0) 
#line 7785 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_116_resource_1,ldv_116_ldv_param_1_2,ldv_116_ldv_param_2_3);
    else {
      
#line 7791 
      ldv_116_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 7792 
      ldv_116_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 7797 
      ldv_emg_wrapper_tx_frag_key_not_found_read_3(ldv_116_resource_1,ldv_116_ldv_param_1_4,ldv_116_size_cnt,ldv_116_ldv_param_3_5);
      
#line 7801 
      ldv_free((void *)ldv_116_ldv_param_3_5);
      
#line 7802 
      ldv_free((void *)ldv_116_ldv_param_1_4);
    }
    
#line 7806 
    goto ldv_31612;
    default: 
#line 7808 
    ;
    
#line 7808 
    __VERIFIER_assume(0);
  }
  ldv_31612: 
#line 7817 
  ;
  
#line 7817 
  goto ldv_call_116;
  
#line 7819 
  __retres = (void *)0;
  return_label: 
#line 7819 
                return __retres;
}


#line 7824  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_113(void *arg0)
{
  void *__retres;
  struct file *ldv_113_resource_1;
  int ldv_113_ldv_param_2_3;
  long long ldv_113_ldv_param_1_2;
  char *ldv_113_ldv_param_1_4;
  struct inode *ldv_113_resource_0;
  unsigned long ldv_113_size_cnt;
  long long *ldv_113_ldv_param_3_5;
  char *ldv_113_ldv_param_1_6;
  long long *ldv_113_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 7835 
  struct file_operations *ldv_113_container = ldv_emg_alias_conf_ops_2;
  
#line 7836 
  int ldv_113_ret = ldv_undef_int();
  
#line 7839 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 7843 
  ldv_113_ret = ldv_undef_int();
  
#line 7846 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 7847 
    ldv_113_container = data->arg0;
    
#line 7848 
    ldv_free((void *)data);
  }
  else ;
  
#line 7853 
  ldv_113_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 7854 
  tmp_1 = ldv_undef_int();
  
#line 7854 
  ldv_113_size_cnt = (unsigned long)tmp_1;
  
#line 7861 
  goto ldv_main_113;
  
#line 7863 
  __retres = (void *)0;
  
#line 7863 
  goto return_label;
  ldv_main_113: 
#line 7866 
  ;
  
#line 7869 
  tmp_3 = ldv_undef_int();
  
#line 7869 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 7872 
    ldv_113_ret = (*ldv_emg_alias_simple_open_5)(ldv_113_resource_0,ldv_113_resource_1);
    
#line 7874 
    ldv_113_ret = ldv_filter_err_code(ldv_113_ret);
    
#line 7877 
    tmp_2 = ldv_undef_int();
    
#line 7877 
    if (tmp_2 != 0) {
      
#line 7879 
      __VERIFIER_assume(ldv_113_ret == 0);
      
#line 7886 
      goto ldv_call_113;
    }
    else {
      
#line 7890 
      __VERIFIER_assume(ldv_113_ret != 0);
      
#line 7897 
      goto ldv_main_113;
    }
  }
  else {
    
#line 7902 
    ldv_free((void *)ldv_113_resource_0);
    
#line 7910 
    __retres = (void *)0;
    
#line 7910 
    goto return_label;
  }
  
#line 7913 
  __retres = (void *)0;
  
#line 7913 
  goto return_label;
  ldv_call_113: 
#line 7916 
  ;
  
#line 7919 
  tmp_4 = ldv_undef_int();
  
#line 7919 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 7920 
    ;
    
#line 7922 
    ldv_113_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 7923 
    ldv_113_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 7927 
    if (ldv_113_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 7933 
      __VERIFIER_assume(ldv_113_size_cnt <= 2147479552UL);
      
#line 7935 
      (*(ldv_113_container->write))(ldv_113_resource_1,(char const *)ldv_113_ldv_param_1_6,ldv_113_size_cnt,ldv_113_ldv_param_3_7);
    }
    else ;
    
#line 7940 
    ldv_free((void *)ldv_113_ldv_param_3_7);
    
#line 7941 
    ldv_free((void *)ldv_113_ldv_param_1_6);
    
#line 7948 
    goto ldv_call_113;
    case 2: 
#line 7951 
    ;
    
#line 7953 
    if (ldv_113_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 7955 
      (*(ldv_113_container->release))(ldv_113_resource_0,ldv_113_resource_1); else ;
    
#line 7963 
    goto ldv_main_113;
    case 3: 
#line 7966 
    ;
    
#line 7970 
    tmp_9 = ldv_undef_int();
    
#line 7970 
    if (tmp_9 != 0) 
#line 7973 
                    (*ldv_emg_alias_default_llseek_3)(ldv_113_resource_1,ldv_113_ldv_param_1_2,ldv_113_ldv_param_2_3);
    else {
      
#line 7979 
      ldv_113_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 7980 
      ldv_113_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 7985 
      ldv_emg_wrapper_conf_read_3(ldv_113_resource_1,ldv_113_ldv_param_1_4,ldv_113_size_cnt,ldv_113_ldv_param_3_5);
      
#line 7989 
      ldv_free((void *)ldv_113_ldv_param_3_5);
      
#line 7990 
      ldv_free((void *)ldv_113_ldv_param_1_4);
    }
    
#line 7994 
    goto ldv_31634;
    default: 
#line 7996 
    ;
    
#line 7996 
    __VERIFIER_assume(0);
  }
  ldv_31634: 
#line 8005 
  ;
  
#line 8005 
  goto ldv_call_113;
  
#line 8007 
  __retres = (void *)0;
  return_label: 
#line 8007 
                return __retres;
}


#line 8012  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_35(void *arg0)
{
  void *__retres;
  struct file *ldv_35_resource_1;
  int ldv_35_ldv_param_2_3;
  long long ldv_35_ldv_param_1_2;
  char *ldv_35_ldv_param_1_4;
  struct inode *ldv_35_resource_0;
  unsigned long ldv_35_size_cnt;
  long long *ldv_35_ldv_param_3_5;
  char *ldv_35_ldv_param_1_6;
  long long *ldv_35_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 8023 
  struct file_operations *ldv_35_container = ldv_emg_alias_tx_tx_prepared_descs_ops_2;
  
#line 8024 
  int ldv_35_ret = ldv_undef_int();
  
#line 8027 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 8031 
  ldv_35_ret = ldv_undef_int();
  
#line 8034 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 8035 
    ldv_35_container = data->arg0;
    
#line 8036 
    ldv_free((void *)data);
  }
  else ;
  
#line 8041 
  ldv_35_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 8042 
  tmp_1 = ldv_undef_int();
  
#line 8042 
  ldv_35_size_cnt = (unsigned long)tmp_1;
  
#line 8049 
  goto ldv_main_35;
  
#line 8051 
  __retres = (void *)0;
  
#line 8051 
  goto return_label;
  ldv_main_35: 
#line 8054 
  ;
  
#line 8057 
  tmp_3 = ldv_undef_int();
  
#line 8057 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 8060 
    ldv_35_ret = (*ldv_emg_alias_simple_open_5)(ldv_35_resource_0,ldv_35_resource_1);
    
#line 8062 
    ldv_35_ret = ldv_filter_err_code(ldv_35_ret);
    
#line 8065 
    tmp_2 = ldv_undef_int();
    
#line 8065 
    if (tmp_2 != 0) {
      
#line 8067 
      __VERIFIER_assume(ldv_35_ret == 0);
      
#line 8074 
      goto ldv_call_35;
    }
    else {
      
#line 8078 
      __VERIFIER_assume(ldv_35_ret != 0);
      
#line 8085 
      goto ldv_main_35;
    }
  }
  else {
    
#line 8090 
    ldv_free((void *)ldv_35_resource_0);
    
#line 8098 
    __retres = (void *)0;
    
#line 8098 
    goto return_label;
  }
  
#line 8101 
  __retres = (void *)0;
  
#line 8101 
  goto return_label;
  ldv_call_35: 
#line 8104 
  ;
  
#line 8107 
  tmp_4 = ldv_undef_int();
  
#line 8107 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 8108 
    ;
    
#line 8110 
    ldv_35_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 8111 
    ldv_35_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 8115 
    if (ldv_35_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 8121 
      __VERIFIER_assume(ldv_35_size_cnt <= 2147479552UL);
      
#line 8123 
      (*(ldv_35_container->write))(ldv_35_resource_1,(char const *)ldv_35_ldv_param_1_6,ldv_35_size_cnt,ldv_35_ldv_param_3_7);
    }
    else ;
    
#line 8128 
    ldv_free((void *)ldv_35_ldv_param_3_7);
    
#line 8129 
    ldv_free((void *)ldv_35_ldv_param_1_6);
    
#line 8136 
    goto ldv_call_35;
    case 2: 
#line 8139 
    ;
    
#line 8141 
    if (ldv_35_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 8143 
      (*(ldv_35_container->release))(ldv_35_resource_0,ldv_35_resource_1); else ;
    
#line 8151 
    goto ldv_main_35;
    case 3: 
#line 8154 
    ;
    
#line 8158 
    tmp_9 = ldv_undef_int();
    
#line 8158 
    if (tmp_9 != 0) 
#line 8161 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_35_resource_1,ldv_35_ldv_param_1_2,ldv_35_ldv_param_2_3);
    else {
      
#line 8167 
      ldv_35_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 8168 
      ldv_35_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 8173 
      ldv_emg_wrapper_tx_tx_prepared_descs_read_3(ldv_35_resource_1,ldv_35_ldv_param_1_4,ldv_35_size_cnt,ldv_35_ldv_param_3_5);
      
#line 8177 
      ldv_free((void *)ldv_35_ldv_param_3_5);
      
#line 8178 
      ldv_free((void *)ldv_35_ldv_param_1_4);
    }
    
#line 8182 
    goto ldv_31656;
    default: 
#line 8184 
    ;
    
#line 8184 
    __VERIFIER_assume(0);
  }
  ldv_31656: 
#line 8193 
  ;
  
#line 8193 
  goto ldv_call_35;
  
#line 8195 
  __retres = (void *)0;
  return_label: 
#line 8195 
                return __retres;
}


#line 8200  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_84(void *arg0)
{
  void *__retres;
  struct file *ldv_84_resource_1;
  int ldv_84_ldv_param_2_3;
  long long ldv_84_ldv_param_1_2;
  char *ldv_84_ldv_param_1_4;
  struct inode *ldv_84_resource_0;
  unsigned long ldv_84_size_cnt;
  long long *ldv_84_ldv_param_3_5;
  char *ldv_84_ldv_param_1_6;
  long long *ldv_84_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 8211 
  struct file_operations *ldv_84_container = ldv_emg_alias_rx_rx_defrag_ops_2;
  
#line 8212 
  int ldv_84_ret = ldv_undef_int();
  
#line 8215 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 8219 
  ldv_84_ret = ldv_undef_int();
  
#line 8222 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 8223 
    ldv_84_container = data->arg0;
    
#line 8224 
    ldv_free((void *)data);
  }
  else ;
  
#line 8229 
  ldv_84_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 8230 
  tmp_1 = ldv_undef_int();
  
#line 8230 
  ldv_84_size_cnt = (unsigned long)tmp_1;
  
#line 8237 
  goto ldv_main_84;
  
#line 8239 
  __retres = (void *)0;
  
#line 8239 
  goto return_label;
  ldv_main_84: 
#line 8242 
  ;
  
#line 8245 
  tmp_3 = ldv_undef_int();
  
#line 8245 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 8248 
    ldv_84_ret = (*ldv_emg_alias_simple_open_5)(ldv_84_resource_0,ldv_84_resource_1);
    
#line 8250 
    ldv_84_ret = ldv_filter_err_code(ldv_84_ret);
    
#line 8253 
    tmp_2 = ldv_undef_int();
    
#line 8253 
    if (tmp_2 != 0) {
      
#line 8255 
      __VERIFIER_assume(ldv_84_ret == 0);
      
#line 8262 
      goto ldv_call_84;
    }
    else {
      
#line 8266 
      __VERIFIER_assume(ldv_84_ret != 0);
      
#line 8273 
      goto ldv_main_84;
    }
  }
  else {
    
#line 8278 
    ldv_free((void *)ldv_84_resource_0);
    
#line 8286 
    __retres = (void *)0;
    
#line 8286 
    goto return_label;
  }
  
#line 8289 
  __retres = (void *)0;
  
#line 8289 
  goto return_label;
  ldv_call_84: 
#line 8292 
  ;
  
#line 8295 
  tmp_4 = ldv_undef_int();
  
#line 8295 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 8296 
    ;
    
#line 8298 
    ldv_84_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 8299 
    ldv_84_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 8303 
    if (ldv_84_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 8309 
      __VERIFIER_assume(ldv_84_size_cnt <= 2147479552UL);
      
#line 8311 
      (*(ldv_84_container->write))(ldv_84_resource_1,(char const *)ldv_84_ldv_param_1_6,ldv_84_size_cnt,ldv_84_ldv_param_3_7);
    }
    else ;
    
#line 8316 
    ldv_free((void *)ldv_84_ldv_param_3_7);
    
#line 8317 
    ldv_free((void *)ldv_84_ldv_param_1_6);
    
#line 8324 
    goto ldv_call_84;
    case 2: 
#line 8327 
    ;
    
#line 8329 
    if (ldv_84_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 8331 
      (*(ldv_84_container->release))(ldv_84_resource_0,ldv_84_resource_1); else ;
    
#line 8339 
    goto ldv_main_84;
    case 3: 
#line 8342 
    ;
    
#line 8346 
    tmp_9 = ldv_undef_int();
    
#line 8346 
    if (tmp_9 != 0) 
#line 8349 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_84_resource_1,ldv_84_ldv_param_1_2,ldv_84_ldv_param_2_3);
    else {
      
#line 8355 
      ldv_84_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 8356 
      ldv_84_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 8361 
      ldv_emg_wrapper_rx_rx_defrag_read_3(ldv_84_resource_1,ldv_84_ldv_param_1_4,ldv_84_size_cnt,ldv_84_ldv_param_3_5);
      
#line 8365 
      ldv_free((void *)ldv_84_ldv_param_1_4);
      
#line 8366 
      ldv_free((void *)ldv_84_ldv_param_3_5);
    }
    
#line 8370 
    goto ldv_31678;
    default: 
#line 8372 
    ;
    
#line 8372 
    __VERIFIER_assume(0);
  }
  ldv_31678: 
#line 8381 
  ;
  
#line 8381 
  goto ldv_call_84;
  
#line 8383 
  __retres = (void *)0;
  return_label: 
#line 8383 
                return __retres;
}


#line 8388  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_86(void *arg0)
{
  void *__retres;
  struct file *ldv_86_resource_1;
  int ldv_86_ldv_param_2_3;
  long long ldv_86_ldv_param_1_2;
  char *ldv_86_ldv_param_1_4;
  struct inode *ldv_86_resource_0;
  unsigned long ldv_86_size_cnt;
  long long *ldv_86_ldv_param_3_5;
  char *ldv_86_ldv_param_1_6;
  long long *ldv_86_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 8399 
  struct file_operations *ldv_86_container = ldv_emg_alias_rx_decrypt_key_not_found_ops_2;
  
#line 8400 
  int ldv_86_ret = ldv_undef_int();
  
#line 8403 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 8407 
  ldv_86_ret = ldv_undef_int();
  
#line 8410 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 8411 
    ldv_86_container = data->arg0;
    
#line 8412 
    ldv_free((void *)data);
  }
  else ;
  
#line 8417 
  ldv_86_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 8418 
  tmp_1 = ldv_undef_int();
  
#line 8418 
  ldv_86_size_cnt = (unsigned long)tmp_1;
  
#line 8425 
  goto ldv_main_86;
  
#line 8427 
  __retres = (void *)0;
  
#line 8427 
  goto return_label;
  ldv_main_86: 
#line 8430 
  ;
  
#line 8433 
  tmp_3 = ldv_undef_int();
  
#line 8433 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 8436 
    ldv_86_ret = (*ldv_emg_alias_simple_open_5)(ldv_86_resource_0,ldv_86_resource_1);
    
#line 8438 
    ldv_86_ret = ldv_filter_err_code(ldv_86_ret);
    
#line 8441 
    tmp_2 = ldv_undef_int();
    
#line 8441 
    if (tmp_2 != 0) {
      
#line 8443 
      __VERIFIER_assume(ldv_86_ret == 0);
      
#line 8450 
      goto ldv_call_86;
    }
    else {
      
#line 8454 
      __VERIFIER_assume(ldv_86_ret != 0);
      
#line 8461 
      goto ldv_main_86;
    }
  }
  else {
    
#line 8466 
    ldv_free((void *)ldv_86_resource_0);
    
#line 8474 
    __retres = (void *)0;
    
#line 8474 
    goto return_label;
  }
  
#line 8477 
  __retres = (void *)0;
  
#line 8477 
  goto return_label;
  ldv_call_86: 
#line 8480 
  ;
  
#line 8483 
  tmp_4 = ldv_undef_int();
  
#line 8483 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 8484 
    ;
    
#line 8486 
    ldv_86_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 8487 
    ldv_86_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 8491 
    if (ldv_86_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 8497 
      __VERIFIER_assume(ldv_86_size_cnt <= 2147479552UL);
      
#line 8499 
      (*(ldv_86_container->write))(ldv_86_resource_1,(char const *)ldv_86_ldv_param_1_6,ldv_86_size_cnt,ldv_86_ldv_param_3_7);
    }
    else ;
    
#line 8504 
    ldv_free((void *)ldv_86_ldv_param_3_7);
    
#line 8505 
    ldv_free((void *)ldv_86_ldv_param_1_6);
    
#line 8512 
    goto ldv_call_86;
    case 2: 
#line 8515 
    ;
    
#line 8517 
    if (ldv_86_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 8519 
      (*(ldv_86_container->release))(ldv_86_resource_0,ldv_86_resource_1); else ;
    
#line 8527 
    goto ldv_main_86;
    case 3: 
#line 8530 
    ;
    
#line 8534 
    tmp_9 = ldv_undef_int();
    
#line 8534 
    if (tmp_9 != 0) 
#line 8537 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_86_resource_1,ldv_86_ldv_param_1_2,ldv_86_ldv_param_2_3);
    else {
      
#line 8543 
      ldv_86_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 8544 
      ldv_86_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 8549 
      ldv_emg_wrapper_rx_decrypt_key_not_found_read_3(ldv_86_resource_1,ldv_86_ldv_param_1_4,ldv_86_size_cnt,ldv_86_ldv_param_3_5);
      
#line 8553 
      ldv_free((void *)ldv_86_ldv_param_3_5);
      
#line 8554 
      ldv_free((void *)ldv_86_ldv_param_1_4);
    }
    
#line 8558 
    goto ldv_31700;
    default: 
#line 8560 
    ;
    
#line 8560 
    __VERIFIER_assume(0);
  }
  ldv_31700: 
#line 8569 
  ;
  
#line 8569 
  goto ldv_call_86;
  
#line 8571 
  __retres = (void *)0;
  return_label: 
#line 8571 
                return __retres;
}


#line 8576  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_26(void *arg0)
{
  void *__retres;
  struct file *ldv_26_resource_1;
  int ldv_26_ldv_param_2_3;
  long long ldv_26_ldv_param_1_2;
  char *ldv_26_ldv_param_1_4;
  struct inode *ldv_26_resource_0;
  unsigned long ldv_26_size_cnt;
  long long *ldv_26_ldv_param_3_5;
  char *ldv_26_ldv_param_1_6;
  long long *ldv_26_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 8587 
  struct file_operations *ldv_26_container = ldv_emg_alias_pwr_rcvd_bcns_cnt_ops_2;
  
#line 8588 
  int ldv_26_ret = ldv_undef_int();
  
#line 8591 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 8595 
  ldv_26_ret = ldv_undef_int();
  
#line 8598 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 8599 
    ldv_26_container = data->arg0;
    
#line 8600 
    ldv_free((void *)data);
  }
  else ;
  
#line 8605 
  ldv_26_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 8606 
  tmp_1 = ldv_undef_int();
  
#line 8606 
  ldv_26_size_cnt = (unsigned long)tmp_1;
  
#line 8613 
  goto ldv_main_26;
  
#line 8615 
  __retres = (void *)0;
  
#line 8615 
  goto return_label;
  ldv_main_26: 
#line 8618 
  ;
  
#line 8621 
  tmp_3 = ldv_undef_int();
  
#line 8621 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 8624 
    ldv_26_ret = (*ldv_emg_alias_simple_open_5)(ldv_26_resource_0,ldv_26_resource_1);
    
#line 8626 
    ldv_26_ret = ldv_filter_err_code(ldv_26_ret);
    
#line 8629 
    tmp_2 = ldv_undef_int();
    
#line 8629 
    if (tmp_2 != 0) {
      
#line 8631 
      __VERIFIER_assume(ldv_26_ret == 0);
      
#line 8638 
      goto ldv_call_26;
    }
    else {
      
#line 8642 
      __VERIFIER_assume(ldv_26_ret != 0);
      
#line 8649 
      goto ldv_main_26;
    }
  }
  else {
    
#line 8654 
    ldv_free((void *)ldv_26_resource_0);
    
#line 8662 
    __retres = (void *)0;
    
#line 8662 
    goto return_label;
  }
  
#line 8665 
  __retres = (void *)0;
  
#line 8665 
  goto return_label;
  ldv_call_26: 
#line 8668 
  ;
  
#line 8671 
  tmp_4 = ldv_undef_int();
  
#line 8671 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 8672 
    ;
    
#line 8674 
    ldv_26_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 8675 
    ldv_26_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 8679 
    if (ldv_26_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 8685 
      __VERIFIER_assume(ldv_26_size_cnt <= 2147479552UL);
      
#line 8687 
      (*(ldv_26_container->write))(ldv_26_resource_1,(char const *)ldv_26_ldv_param_1_6,ldv_26_size_cnt,ldv_26_ldv_param_3_7);
    }
    else ;
    
#line 8692 
    ldv_free((void *)ldv_26_ldv_param_3_7);
    
#line 8693 
    ldv_free((void *)ldv_26_ldv_param_1_6);
    
#line 8700 
    goto ldv_call_26;
    case 2: 
#line 8703 
    ;
    
#line 8705 
    if (ldv_26_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 8707 
      (*(ldv_26_container->release))(ldv_26_resource_0,ldv_26_resource_1); else ;
    
#line 8715 
    goto ldv_main_26;
    case 3: 
#line 8718 
    ;
    
#line 8722 
    tmp_9 = ldv_undef_int();
    
#line 8722 
    if (tmp_9 != 0) 
#line 8725 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_26_resource_1,ldv_26_ldv_param_1_2,ldv_26_ldv_param_2_3);
    else {
      
#line 8731 
      ldv_26_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 8732 
      ldv_26_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 8737 
      ldv_emg_wrapper_pwr_rcvd_bcns_cnt_read_3(ldv_26_resource_1,ldv_26_ldv_param_1_4,ldv_26_size_cnt,ldv_26_ldv_param_3_5);
      
#line 8741 
      ldv_free((void *)ldv_26_ldv_param_1_4);
      
#line 8742 
      ldv_free((void *)ldv_26_ldv_param_3_5);
    }
    
#line 8746 
    goto ldv_31722;
    default: 
#line 8748 
    ;
    
#line 8748 
    __VERIFIER_assume(0);
  }
  ldv_31722: 
#line 8757 
  ;
  
#line 8757 
  goto ldv_call_26;
  
#line 8759 
  __retres = (void *)0;
  return_label: 
#line 8759 
                return __retres;
}


#line 8764  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_91(void *arg0)
{
  void *__retres;
  struct file *ldv_91_resource_1;
  int ldv_91_ldv_param_2_3;
  long long ldv_91_ldv_param_1_2;
  char *ldv_91_ldv_param_1_4;
  struct inode *ldv_91_resource_0;
  unsigned long ldv_91_size_cnt;
  long long *ldv_91_ldv_param_3_5;
  char *ldv_91_ldv_param_1_6;
  long long *ldv_91_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 8775 
  struct file_operations *ldv_91_container = ldv_emg_alias_debug_debug3_ops_2;
  
#line 8776 
  int ldv_91_ret = ldv_undef_int();
  
#line 8779 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 8783 
  ldv_91_ret = ldv_undef_int();
  
#line 8786 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 8787 
    ldv_91_container = data->arg0;
    
#line 8788 
    ldv_free((void *)data);
  }
  else ;
  
#line 8793 
  ldv_91_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 8794 
  tmp_1 = ldv_undef_int();
  
#line 8794 
  ldv_91_size_cnt = (unsigned long)tmp_1;
  
#line 8801 
  goto ldv_main_91;
  
#line 8803 
  __retres = (void *)0;
  
#line 8803 
  goto return_label;
  ldv_main_91: 
#line 8806 
  ;
  
#line 8809 
  tmp_3 = ldv_undef_int();
  
#line 8809 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 8812 
    ldv_91_ret = (*ldv_emg_alias_simple_open_5)(ldv_91_resource_0,ldv_91_resource_1);
    
#line 8814 
    ldv_91_ret = ldv_filter_err_code(ldv_91_ret);
    
#line 8817 
    tmp_2 = ldv_undef_int();
    
#line 8817 
    if (tmp_2 != 0) {
      
#line 8819 
      __VERIFIER_assume(ldv_91_ret == 0);
      
#line 8826 
      goto ldv_call_91;
    }
    else {
      
#line 8830 
      __VERIFIER_assume(ldv_91_ret != 0);
      
#line 8837 
      goto ldv_main_91;
    }
  }
  else {
    
#line 8842 
    ldv_free((void *)ldv_91_resource_0);
    
#line 8850 
    __retres = (void *)0;
    
#line 8850 
    goto return_label;
  }
  
#line 8853 
  __retres = (void *)0;
  
#line 8853 
  goto return_label;
  ldv_call_91: 
#line 8856 
  ;
  
#line 8859 
  tmp_4 = ldv_undef_int();
  
#line 8859 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 8860 
    ;
    
#line 8862 
    ldv_91_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 8863 
    ldv_91_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 8867 
    if (ldv_91_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 8873 
      __VERIFIER_assume(ldv_91_size_cnt <= 2147479552UL);
      
#line 8875 
      (*(ldv_91_container->write))(ldv_91_resource_1,(char const *)ldv_91_ldv_param_1_6,ldv_91_size_cnt,ldv_91_ldv_param_3_7);
    }
    else ;
    
#line 8880 
    ldv_free((void *)ldv_91_ldv_param_1_6);
    
#line 8881 
    ldv_free((void *)ldv_91_ldv_param_3_7);
    
#line 8888 
    goto ldv_call_91;
    case 2: 
#line 8891 
    ;
    
#line 8893 
    if (ldv_91_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 8895 
      (*(ldv_91_container->release))(ldv_91_resource_0,ldv_91_resource_1); else ;
    
#line 8903 
    goto ldv_main_91;
    case 3: 
#line 8906 
    ;
    
#line 8910 
    tmp_9 = ldv_undef_int();
    
#line 8910 
    if (tmp_9 != 0) 
#line 8913 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_91_resource_1,ldv_91_ldv_param_1_2,ldv_91_ldv_param_2_3);
    else {
      
#line 8919 
      ldv_91_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 8920 
      ldv_91_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 8925 
      ldv_emg_wrapper_debug_debug3_read_3(ldv_91_resource_1,ldv_91_ldv_param_1_4,ldv_91_size_cnt,ldv_91_ldv_param_3_5);
      
#line 8929 
      ldv_free((void *)ldv_91_ldv_param_3_5);
      
#line 8930 
      ldv_free((void *)ldv_91_ldv_param_1_4);
    }
    
#line 8934 
    goto ldv_31744;
    default: 
#line 8936 
    ;
    
#line 8936 
    __VERIFIER_assume(0);
  }
  ldv_31744: 
#line 8945 
  ;
  
#line 8945 
  goto ldv_call_91;
  
#line 8947 
  __retres = (void *)0;
  return_label: 
#line 8947 
                return __retres;
}


#line 8952  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_103(void *arg0)
{
  void *__retres;
  struct file *ldv_103_resource_1;
  int ldv_103_ldv_param_2_3;
  long long ldv_103_ldv_param_1_2;
  char *ldv_103_ldv_param_1_4;
  struct inode *ldv_103_resource_0;
  unsigned long ldv_103_size_cnt;
  long long *ldv_103_ldv_param_3_5;
  char *ldv_103_ldv_param_1_6;
  long long *ldv_103_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 8963 
  struct file_operations *ldv_103_container = ldv_emg_alias_debug_debug5_ops_2;
  
#line 8964 
  int ldv_103_ret = ldv_undef_int();
  
#line 8967 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 8971 
  ldv_103_ret = ldv_undef_int();
  
#line 8974 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 8975 
    ldv_103_container = data->arg0;
    
#line 8976 
    ldv_free((void *)data);
  }
  else ;
  
#line 8981 
  ldv_103_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 8982 
  tmp_1 = ldv_undef_int();
  
#line 8982 
  ldv_103_size_cnt = (unsigned long)tmp_1;
  
#line 8989 
  goto ldv_main_103;
  
#line 8991 
  __retres = (void *)0;
  
#line 8991 
  goto return_label;
  ldv_main_103: 
#line 8994 
  ;
  
#line 8997 
  tmp_3 = ldv_undef_int();
  
#line 8997 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 9000 
    ldv_103_ret = (*ldv_emg_alias_simple_open_5)(ldv_103_resource_0,ldv_103_resource_1);
    
#line 9002 
    ldv_103_ret = ldv_filter_err_code(ldv_103_ret);
    
#line 9005 
    tmp_2 = ldv_undef_int();
    
#line 9005 
    if (tmp_2 != 0) {
      
#line 9007 
      __VERIFIER_assume(ldv_103_ret == 0);
      
#line 9014 
      goto ldv_call_103;
    }
    else {
      
#line 9018 
      __VERIFIER_assume(ldv_103_ret != 0);
      
#line 9025 
      goto ldv_main_103;
    }
  }
  else {
    
#line 9030 
    ldv_free((void *)ldv_103_resource_0);
    
#line 9038 
    __retres = (void *)0;
    
#line 9038 
    goto return_label;
  }
  
#line 9041 
  __retres = (void *)0;
  
#line 9041 
  goto return_label;
  ldv_call_103: 
#line 9044 
  ;
  
#line 9047 
  tmp_4 = ldv_undef_int();
  
#line 9047 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 9048 
    ;
    
#line 9050 
    ldv_103_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 9051 
    ldv_103_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 9055 
    if (ldv_103_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 9061 
      __VERIFIER_assume(ldv_103_size_cnt <= 2147479552UL);
      
#line 9063 
      (*(ldv_103_container->write))(ldv_103_resource_1,(char const *)ldv_103_ldv_param_1_6,ldv_103_size_cnt,ldv_103_ldv_param_3_7);
    }
    else ;
    
#line 9068 
    ldv_free((void *)ldv_103_ldv_param_1_6);
    
#line 9069 
    ldv_free((void *)ldv_103_ldv_param_3_7);
    
#line 9076 
    goto ldv_call_103;
    case 2: 
#line 9079 
    ;
    
#line 9081 
    if (ldv_103_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 9083 
      (*(ldv_103_container->release))(ldv_103_resource_0,ldv_103_resource_1); else ;
    
#line 9091 
    goto ldv_main_103;
    case 3: 
#line 9094 
    ;
    
#line 9098 
    tmp_9 = ldv_undef_int();
    
#line 9098 
    if (tmp_9 != 0) 
#line 9101 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_103_resource_1,ldv_103_ldv_param_1_2,ldv_103_ldv_param_2_3);
    else {
      
#line 9107 
      ldv_103_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 9108 
      ldv_103_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 9113 
      ldv_emg_wrapper_debug_debug5_read_3(ldv_103_resource_1,ldv_103_ldv_param_1_4,ldv_103_size_cnt,ldv_103_ldv_param_3_5);
      
#line 9117 
      ldv_free((void *)ldv_103_ldv_param_1_4);
      
#line 9118 
      ldv_free((void *)ldv_103_ldv_param_3_5);
    }
    
#line 9122 
    goto ldv_31766;
    default: 
#line 9124 
    ;
    
#line 9124 
    __VERIFIER_assume(0);
  }
  ldv_31766: 
#line 9133 
  ;
  
#line 9133 
  goto ldv_call_103;
  
#line 9135 
  __retres = (void *)0;
  return_label: 
#line 9135 
                return __retres;
}


#line 9140  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_101(void *arg0)
{
  void *__retres;
  struct file *ldv_101_resource_1;
  int ldv_101_ldv_param_2_3;
  long long ldv_101_ldv_param_1_2;
  char *ldv_101_ldv_param_1_4;
  struct inode *ldv_101_resource_0;
  unsigned long ldv_101_size_cnt;
  long long *ldv_101_ldv_param_3_5;
  char *ldv_101_ldv_param_1_6;
  long long *ldv_101_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 9151 
  struct file_operations *ldv_101_container = ldv_emg_alias_aggr_size_tx_agg_vs_rate_ops_2;
  
#line 9152 
  int ldv_101_ret = ldv_undef_int();
  
#line 9155 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 9159 
  ldv_101_ret = ldv_undef_int();
  
#line 9162 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 9163 
    ldv_101_container = data->arg0;
    
#line 9164 
    ldv_free((void *)data);
  }
  else ;
  
#line 9169 
  ldv_101_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 9170 
  tmp_1 = ldv_undef_int();
  
#line 9170 
  ldv_101_size_cnt = (unsigned long)tmp_1;
  
#line 9177 
  goto ldv_main_101;
  
#line 9179 
  __retres = (void *)0;
  
#line 9179 
  goto return_label;
  ldv_main_101: 
#line 9182 
  ;
  
#line 9185 
  tmp_3 = ldv_undef_int();
  
#line 9185 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 9188 
    ldv_101_ret = (*ldv_emg_alias_simple_open_5)(ldv_101_resource_0,ldv_101_resource_1);
    
#line 9190 
    ldv_101_ret = ldv_filter_err_code(ldv_101_ret);
    
#line 9193 
    tmp_2 = ldv_undef_int();
    
#line 9193 
    if (tmp_2 != 0) {
      
#line 9195 
      __VERIFIER_assume(ldv_101_ret == 0);
      
#line 9202 
      goto ldv_call_101;
    }
    else {
      
#line 9206 
      __VERIFIER_assume(ldv_101_ret != 0);
      
#line 9213 
      goto ldv_main_101;
    }
  }
  else {
    
#line 9218 
    ldv_free((void *)ldv_101_resource_0);
    
#line 9226 
    __retres = (void *)0;
    
#line 9226 
    goto return_label;
  }
  
#line 9229 
  __retres = (void *)0;
  
#line 9229 
  goto return_label;
  ldv_call_101: 
#line 9232 
  ;
  
#line 9235 
  tmp_4 = ldv_undef_int();
  
#line 9235 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 9236 
    ;
    
#line 9238 
    ldv_101_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 9239 
    ldv_101_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 9243 
    if (ldv_101_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 9249 
      __VERIFIER_assume(ldv_101_size_cnt <= 2147479552UL);
      
#line 9251 
      (*(ldv_101_container->write))(ldv_101_resource_1,(char const *)ldv_101_ldv_param_1_6,ldv_101_size_cnt,ldv_101_ldv_param_3_7);
    }
    else ;
    
#line 9256 
    ldv_free((void *)ldv_101_ldv_param_3_7);
    
#line 9257 
    ldv_free((void *)ldv_101_ldv_param_1_6);
    
#line 9264 
    goto ldv_call_101;
    case 2: 
#line 9267 
    ;
    
#line 9269 
    if (ldv_101_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 9271 
      (*(ldv_101_container->release))(ldv_101_resource_0,ldv_101_resource_1); else ;
    
#line 9279 
    goto ldv_main_101;
    case 3: 
#line 9282 
    ;
    
#line 9286 
    tmp_9 = ldv_undef_int();
    
#line 9286 
    if (tmp_9 != 0) 
#line 9289 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_101_resource_1,ldv_101_ldv_param_1_2,ldv_101_ldv_param_2_3);
    else {
      
#line 9295 
      ldv_101_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 9296 
      ldv_101_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 9301 
      ldv_emg_wrapper_aggr_size_tx_agg_vs_rate_read_3(ldv_101_resource_1,ldv_101_ldv_param_1_4,ldv_101_size_cnt,ldv_101_ldv_param_3_5);
      
#line 9305 
      ldv_free((void *)ldv_101_ldv_param_3_5);
      
#line 9306 
      ldv_free((void *)ldv_101_ldv_param_1_4);
    }
    
#line 9310 
    goto ldv_31788;
    default: 
#line 9312 
    ;
    
#line 9312 
    __VERIFIER_assume(0);
  }
  ldv_31788: 
#line 9321 
  ;
  
#line 9321 
  goto ldv_call_101;
  
#line 9323 
  __retres = (void *)0;
  return_label: 
#line 9323 
                return __retres;
}


#line 9328  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_19(void *arg0)
{
  void *__retres;
  struct file *ldv_19_resource_1;
  int ldv_19_ldv_param_2_3;
  long long ldv_19_ldv_param_1_2;
  char *ldv_19_ldv_param_1_4;
  struct inode *ldv_19_resource_0;
  unsigned long ldv_19_size_cnt;
  long long *ldv_19_ldv_param_3_5;
  char *ldv_19_ldv_param_1_6;
  long long *ldv_19_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 9339 
  struct file_operations *ldv_19_container = ldv_emg_alias_rx_rx_done_ops_2;
  
#line 9340 
  int ldv_19_ret = ldv_undef_int();
  
#line 9343 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 9347 
  ldv_19_ret = ldv_undef_int();
  
#line 9350 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 9351 
    ldv_19_container = data->arg0;
    
#line 9352 
    ldv_free((void *)data);
  }
  else ;
  
#line 9357 
  ldv_19_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 9358 
  tmp_1 = ldv_undef_int();
  
#line 9358 
  ldv_19_size_cnt = (unsigned long)tmp_1;
  
#line 9365 
  goto ldv_main_19;
  
#line 9367 
  __retres = (void *)0;
  
#line 9367 
  goto return_label;
  ldv_main_19: 
#line 9370 
  ;
  
#line 9373 
  tmp_3 = ldv_undef_int();
  
#line 9373 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 9376 
    ldv_19_ret = (*ldv_emg_alias_simple_open_5)(ldv_19_resource_0,ldv_19_resource_1);
    
#line 9378 
    ldv_19_ret = ldv_filter_err_code(ldv_19_ret);
    
#line 9381 
    tmp_2 = ldv_undef_int();
    
#line 9381 
    if (tmp_2 != 0) {
      
#line 9383 
      __VERIFIER_assume(ldv_19_ret == 0);
      
#line 9390 
      goto ldv_call_19;
    }
    else {
      
#line 9394 
      __VERIFIER_assume(ldv_19_ret != 0);
      
#line 9401 
      goto ldv_main_19;
    }
  }
  else {
    
#line 9406 
    ldv_free((void *)ldv_19_resource_0);
    
#line 9414 
    __retres = (void *)0;
    
#line 9414 
    goto return_label;
  }
  
#line 9417 
  __retres = (void *)0;
  
#line 9417 
  goto return_label;
  ldv_call_19: 
#line 9420 
  ;
  
#line 9423 
  tmp_4 = ldv_undef_int();
  
#line 9423 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 9424 
    ;
    
#line 9426 
    ldv_19_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 9427 
    ldv_19_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 9431 
    if (ldv_19_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 9437 
      __VERIFIER_assume(ldv_19_size_cnt <= 2147479552UL);
      
#line 9439 
      (*(ldv_19_container->write))(ldv_19_resource_1,(char const *)ldv_19_ldv_param_1_6,ldv_19_size_cnt,ldv_19_ldv_param_3_7);
    }
    else ;
    
#line 9444 
    ldv_free((void *)ldv_19_ldv_param_3_7);
    
#line 9445 
    ldv_free((void *)ldv_19_ldv_param_1_6);
    
#line 9452 
    goto ldv_call_19;
    case 2: 
#line 9455 
    ;
    
#line 9457 
    if (ldv_19_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 9459 
      (*(ldv_19_container->release))(ldv_19_resource_0,ldv_19_resource_1); else ;
    
#line 9467 
    goto ldv_main_19;
    case 3: 
#line 9470 
    ;
    
#line 9474 
    tmp_9 = ldv_undef_int();
    
#line 9474 
    if (tmp_9 != 0) 
#line 9477 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_19_resource_1,ldv_19_ldv_param_1_2,ldv_19_ldv_param_2_3);
    else {
      
#line 9483 
      ldv_19_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 9484 
      ldv_19_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 9489 
      ldv_emg_wrapper_rx_rx_done_read_3(ldv_19_resource_1,ldv_19_ldv_param_1_4,ldv_19_size_cnt,ldv_19_ldv_param_3_5);
      
#line 9493 
      ldv_free((void *)ldv_19_ldv_param_3_5);
      
#line 9494 
      ldv_free((void *)ldv_19_ldv_param_1_4);
    }
    
#line 9498 
    goto ldv_31810;
    default: 
#line 9500 
    ;
    
#line 9500 
    __VERIFIER_assume(0);
  }
  ldv_31810: 
#line 9509 
  ;
  
#line 9509 
  goto ldv_call_19;
  
#line 9511 
  __retres = (void *)0;
  return_label: 
#line 9511 
                return __retres;
}


#line 9516  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_109(void *arg0)
{
  void *__retres;
  struct file *ldv_109_resource_1;
  int ldv_109_ldv_param_2_3;
  long long ldv_109_ldv_param_1_2;
  char *ldv_109_ldv_param_1_4;
  struct inode *ldv_109_resource_0;
  unsigned long ldv_109_size_cnt;
  long long *ldv_109_ldv_param_3_5;
  char *ldv_109_ldv_param_1_6;
  long long *ldv_109_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 9527 
  struct file_operations *ldv_109_container = ldv_emg_alias_rx_rx_defrag_end_ops_2;
  
#line 9528 
  int ldv_109_ret = ldv_undef_int();
  
#line 9531 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 9535 
  ldv_109_ret = ldv_undef_int();
  
#line 9538 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 9539 
    ldv_109_container = data->arg0;
    
#line 9540 
    ldv_free((void *)data);
  }
  else ;
  
#line 9545 
  ldv_109_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 9546 
  tmp_1 = ldv_undef_int();
  
#line 9546 
  ldv_109_size_cnt = (unsigned long)tmp_1;
  
#line 9553 
  goto ldv_main_109;
  
#line 9555 
  __retres = (void *)0;
  
#line 9555 
  goto return_label;
  ldv_main_109: 
#line 9558 
  ;
  
#line 9561 
  tmp_3 = ldv_undef_int();
  
#line 9561 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 9564 
    ldv_109_ret = (*ldv_emg_alias_simple_open_5)(ldv_109_resource_0,ldv_109_resource_1);
    
#line 9566 
    ldv_109_ret = ldv_filter_err_code(ldv_109_ret);
    
#line 9569 
    tmp_2 = ldv_undef_int();
    
#line 9569 
    if (tmp_2 != 0) {
      
#line 9571 
      __VERIFIER_assume(ldv_109_ret == 0);
      
#line 9578 
      goto ldv_call_109;
    }
    else {
      
#line 9582 
      __VERIFIER_assume(ldv_109_ret != 0);
      
#line 9589 
      goto ldv_main_109;
    }
  }
  else {
    
#line 9594 
    ldv_free((void *)ldv_109_resource_0);
    
#line 9602 
    __retres = (void *)0;
    
#line 9602 
    goto return_label;
  }
  
#line 9605 
  __retres = (void *)0;
  
#line 9605 
  goto return_label;
  ldv_call_109: 
#line 9608 
  ;
  
#line 9611 
  tmp_4 = ldv_undef_int();
  
#line 9611 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 9612 
    ;
    
#line 9614 
    ldv_109_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 9615 
    ldv_109_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 9619 
    if (ldv_109_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 9625 
      __VERIFIER_assume(ldv_109_size_cnt <= 2147479552UL);
      
#line 9627 
      (*(ldv_109_container->write))(ldv_109_resource_1,(char const *)ldv_109_ldv_param_1_6,ldv_109_size_cnt,ldv_109_ldv_param_3_7);
    }
    else ;
    
#line 9632 
    ldv_free((void *)ldv_109_ldv_param_1_6);
    
#line 9633 
    ldv_free((void *)ldv_109_ldv_param_3_7);
    
#line 9640 
    goto ldv_call_109;
    case 2: 
#line 9643 
    ;
    
#line 9645 
    if (ldv_109_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 9647 
      (*(ldv_109_container->release))(ldv_109_resource_0,ldv_109_resource_1); else ;
    
#line 9655 
    goto ldv_main_109;
    case 3: 
#line 9658 
    ;
    
#line 9662 
    tmp_9 = ldv_undef_int();
    
#line 9662 
    if (tmp_9 != 0) 
#line 9665 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_109_resource_1,ldv_109_ldv_param_1_2,ldv_109_ldv_param_2_3);
    else {
      
#line 9671 
      ldv_109_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 9672 
      ldv_109_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 9677 
      ldv_emg_wrapper_rx_rx_defrag_end_read_3(ldv_109_resource_1,ldv_109_ldv_param_1_4,ldv_109_size_cnt,ldv_109_ldv_param_3_5);
      
#line 9681 
      ldv_free((void *)ldv_109_ldv_param_3_5);
      
#line 9682 
      ldv_free((void *)ldv_109_ldv_param_1_4);
    }
    
#line 9686 
    goto ldv_31832;
    default: 
#line 9688 
    ;
    
#line 9688 
    __VERIFIER_assume(0);
  }
  ldv_31832: 
#line 9697 
  ;
  
#line 9697 
  goto ldv_call_109;
  
#line 9699 
  __retres = (void *)0;
  return_label: 
#line 9699 
                return __retres;
}


#line 9704  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_pm_ops_scenario_81(void *arg0)
{
  void *__retres;
  struct dev_pm_ops *ldv_81_pm_ops;
  struct device *ldv_81_device;
  int tmp;
  
#line 9711 
  ldv_free(arg0);
  
#line 9718 
  goto ldv_do_81;
  
#line 9720 
  __retres = (void *)0;
  
#line 9720 
  goto return_label;
  ldv_do_81: 
#line 9723 
  ;
  
#line 9726 
  tmp = ldv_undef_int();
  
#line 9726 
  switch (tmp) {
    int tmp_0;
    case 1: 
#line 9727 
    ;
    
#line 9729 
    if (ldv_81_pm_ops->runtime_idle != (int (*)(struct device *))0) 
#line 9731 
                                                                    (*(ldv_81_pm_ops->runtime_idle))(ldv_81_device); else ;
    
#line 9739 
    goto ldv_do_81;
    case 2: 
#line 9742 
    ;
    
#line 9744 
    if (ldv_81_pm_ops->runtime_suspend != (int (*)(struct device *))0) 
      
#line 9746 
      (*(ldv_81_pm_ops->runtime_suspend))(ldv_81_device); else ;
    
#line 9751 
    if (ldv_81_pm_ops->runtime_resume != (int (*)(struct device *))0) 
      
#line 9753 
      (*(ldv_81_pm_ops->runtime_resume))(ldv_81_device); else ;
    
#line 9761 
    goto ldv_do_81;
    case 3: 
#line 9764 
    ;
    
#line 9766 
    if (ldv_81_pm_ops->prepare != (int (*)(struct device *))0) 
#line 9768 
                                                               (*(ldv_81_pm_ops->prepare))(ldv_81_device); else ;
    
#line 9772 
    tmp_0 = ldv_undef_int();
    
#line 9772 
    switch (tmp_0) {
      int tmp_1;
      int tmp_2;
      int tmp_3;
      case 1: 
#line 9773 
      ;
      
#line 9775 
      if (ldv_81_pm_ops->suspend != (int (*)(struct device *))0) 
#line 9777 
                                                                 (*(ldv_81_pm_ops->suspend))(ldv_81_device); else ;
      
#line 9781 
      tmp_1 = ldv_undef_int();
      
#line 9781 
      if (tmp_1 != 0) {
        
#line 9783 
        if (ldv_81_pm_ops->suspend_noirq != (int (*)(struct device *))0) 
          
#line 9785 
          (*(ldv_81_pm_ops->suspend_noirq))(ldv_81_device); else ;
        
#line 9790 
        if (ldv_81_pm_ops->resume_noirq != (int (*)(struct device *))0) 
          
#line 9792 
          (*(ldv_81_pm_ops->resume_noirq))(ldv_81_device); else ;
      }
      else {
        
#line 9799 
        if (ldv_81_pm_ops->suspend_late != (int (*)(struct device *))0) 
          
#line 9801 
          (*(ldv_81_pm_ops->suspend_late))(ldv_81_device); else ;
        
#line 9806 
        if (ldv_81_pm_ops->resume_early != (int (*)(struct device *))0) 
          
#line 9808 
          (*(ldv_81_pm_ops->resume_early))(ldv_81_device); else ;
      }
      
#line 9814 
      if (ldv_81_pm_ops->resume != (int (*)(struct device *))0) 
#line 9816 
                                                                (*(ldv_81_pm_ops->resume))(ldv_81_device); else ;
      
#line 9820 
      goto ldv_31844;
      case 2: 
#line 9822 
      ;
      
#line 9824 
      if (ldv_81_pm_ops->freeze != (int (*)(struct device *))0) 
#line 9826 
                                                                (*(ldv_81_pm_ops->freeze))(ldv_81_device); else ;
      
#line 9830 
      tmp_2 = ldv_undef_int();
      
#line 9830 
      if (tmp_2 != 0) {
        
#line 9832 
        if (ldv_81_pm_ops->freeze_late != (int (*)(struct device *))0) 
          
#line 9834 
          (*(ldv_81_pm_ops->freeze_late))(ldv_81_device); else ;
        
#line 9839 
        if (ldv_81_pm_ops->thaw_early != (int (*)(struct device *))0) 
          
#line 9841 
          (*(ldv_81_pm_ops->thaw_early))(ldv_81_device); else ;
      }
      else {
        
#line 9848 
        if (ldv_81_pm_ops->freeze_noirq != (int (*)(struct device *))0) 
          
#line 9850 
          (*(ldv_81_pm_ops->freeze_noirq))(ldv_81_device); else ;
        
#line 9855 
        if (ldv_81_pm_ops->thaw_noirq != (int (*)(struct device *))0) 
          
#line 9857 
          (*(ldv_81_pm_ops->thaw_noirq))(ldv_81_device); else ;
      }
      
#line 9863 
      if (ldv_81_pm_ops->thaw != (int (*)(struct device *))0) 
#line 9865 
                                                              (*(ldv_81_pm_ops->thaw))(ldv_81_device); else ;
      
#line 9869 
      goto ldv_31844;
      case 3: 
#line 9871 
      ;
      
#line 9873 
      if (ldv_81_pm_ops->poweroff != (int (*)(struct device *))0) 
#line 9875 
                                                                  (*(ldv_81_pm_ops->poweroff))(ldv_81_device); else ;
      
#line 9879 
      tmp_3 = ldv_undef_int();
      
#line 9879 
      if (tmp_3 != 0) {
        
#line 9881 
        if (ldv_81_pm_ops->poweroff_late != (int (*)(struct device *))0) 
          
#line 9883 
          (*(ldv_81_pm_ops->poweroff_late))(ldv_81_device); else ;
        
#line 9888 
        if (ldv_81_pm_ops->restore_early != (int (*)(struct device *))0) 
          
#line 9890 
          (*(ldv_81_pm_ops->restore_early))(ldv_81_device); else ;
      }
      else {
        
#line 9897 
        if (ldv_81_pm_ops->poweroff_noirq != (int (*)(struct device *))0) 
          
#line 9899 
          (*(ldv_81_pm_ops->poweroff_noirq))(ldv_81_device); else ;
        
#line 9904 
        if (ldv_81_pm_ops->restore_noirq != (int (*)(struct device *))0) 
          
#line 9906 
          (*(ldv_81_pm_ops->restore_noirq))(ldv_81_device); else ;
      }
      
#line 9912 
      if (ldv_81_pm_ops->restore != (int (*)(struct device *))0) 
#line 9914 
                                                                 (*(ldv_81_pm_ops->restore))(ldv_81_device); else ;
      
#line 9918 
      goto ldv_31844;
      default: 
#line 9920 
      ;
      
#line 9920 
      __VERIFIER_assume(0);
    }
    ldv_31844: 
#line 9923 
    ;
    
#line 9923 
    if (ldv_81_pm_ops->complete != (void (*)(struct device *))0) 
#line 9925 
                                                                 (*(ldv_81_pm_ops->complete))(ldv_81_device); else ;
    
#line 9933 
    goto ldv_do_81;
    case 4: 
#line 9936 
    ;
    
#line 9942 
    __retres = (void *)0;
    
#line 9942 
    goto return_label;
    default: 
#line 9945 
    ;
    
#line 9945 
    __VERIFIER_assume(0);
  }
  
#line 9948 
  __retres = (void *)0;
  return_label: 
#line 9948 
                return __retres;
}


#line 9953  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_42(void *arg0)
{
  void *__retres;
  struct file *ldv_42_resource_1;
  int ldv_42_ldv_param_2_3;
  long long ldv_42_ldv_param_1_2;
  char *ldv_42_ldv_param_1_4;
  struct inode *ldv_42_resource_0;
  unsigned long ldv_42_size_cnt;
  long long *ldv_42_ldv_param_3_5;
  char *ldv_42_ldv_param_1_6;
  long long *ldv_42_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 9964 
  struct file_operations *ldv_42_container = ldv_emg_alias_mem_rx_free_mem_blks_ops_2;
  
#line 9965 
  int ldv_42_ret = ldv_undef_int();
  
#line 9968 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 9972 
  ldv_42_ret = ldv_undef_int();
  
#line 9975 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 9976 
    ldv_42_container = data->arg0;
    
#line 9977 
    ldv_free((void *)data);
  }
  else ;
  
#line 9982 
  ldv_42_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 9983 
  tmp_1 = ldv_undef_int();
  
#line 9983 
  ldv_42_size_cnt = (unsigned long)tmp_1;
  
#line 9990 
  goto ldv_main_42;
  
#line 9992 
  __retres = (void *)0;
  
#line 9992 
  goto return_label;
  ldv_main_42: 
#line 9995 
  ;
  
#line 9998 
  tmp_3 = ldv_undef_int();
  
#line 9998 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 10001 
    ldv_42_ret = (*ldv_emg_alias_simple_open_5)(ldv_42_resource_0,ldv_42_resource_1);
    
#line 10003 
    ldv_42_ret = ldv_filter_err_code(ldv_42_ret);
    
#line 10006 
    tmp_2 = ldv_undef_int();
    
#line 10006 
    if (tmp_2 != 0) {
      
#line 10008 
      __VERIFIER_assume(ldv_42_ret == 0);
      
#line 10015 
      goto ldv_call_42;
    }
    else {
      
#line 10019 
      __VERIFIER_assume(ldv_42_ret != 0);
      
#line 10026 
      goto ldv_main_42;
    }
  }
  else {
    
#line 10031 
    ldv_free((void *)ldv_42_resource_0);
    
#line 10039 
    __retres = (void *)0;
    
#line 10039 
    goto return_label;
  }
  
#line 10042 
  __retres = (void *)0;
  
#line 10042 
  goto return_label;
  ldv_call_42: 
#line 10045 
  ;
  
#line 10048 
  tmp_4 = ldv_undef_int();
  
#line 10048 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 10049 
    ;
    
#line 10051 
    ldv_42_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 10052 
    ldv_42_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 10056 
    if (ldv_42_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 10062 
      __VERIFIER_assume(ldv_42_size_cnt <= 2147479552UL);
      
#line 10064 
      (*(ldv_42_container->write))(ldv_42_resource_1,(char const *)ldv_42_ldv_param_1_6,ldv_42_size_cnt,ldv_42_ldv_param_3_7);
    }
    else ;
    
#line 10069 
    ldv_free((void *)ldv_42_ldv_param_1_6);
    
#line 10070 
    ldv_free((void *)ldv_42_ldv_param_3_7);
    
#line 10077 
    goto ldv_call_42;
    case 2: 
#line 10080 
    ;
    
#line 10082 
    if (ldv_42_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 10084 
      (*(ldv_42_container->release))(ldv_42_resource_0,ldv_42_resource_1); else ;
    
#line 10092 
    goto ldv_main_42;
    case 3: 
#line 10095 
    ;
    
#line 10099 
    tmp_9 = ldv_undef_int();
    
#line 10099 
    if (tmp_9 != 0) 
#line 10102 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_42_resource_1,ldv_42_ldv_param_1_2,ldv_42_ldv_param_2_3);
    else {
      
#line 10108 
      ldv_42_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 10109 
      ldv_42_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 10114 
      ldv_emg_wrapper_mem_rx_free_mem_blks_read_3(ldv_42_resource_1,ldv_42_ldv_param_1_4,ldv_42_size_cnt,ldv_42_ldv_param_3_5);
      
#line 10118 
      ldv_free((void *)ldv_42_ldv_param_1_4);
      
#line 10119 
      ldv_free((void *)ldv_42_ldv_param_3_5);
    }
    
#line 10123 
    goto ldv_31870;
    default: 
#line 10125 
    ;
    
#line 10125 
    __VERIFIER_assume(0);
  }
  ldv_31870: 
#line 10134 
  ;
  
#line 10134 
  goto ldv_call_42;
  
#line 10136 
  __retres = (void *)0;
  return_label: 
#line 10136 
                return __retres;
}


#line 10141  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_94(void *arg0)
{
  void *__retres;
  struct file *ldv_94_resource_1;
  int ldv_94_ldv_param_2_3;
  long long ldv_94_ldv_param_1_2;
  char *ldv_94_ldv_param_1_4;
  struct inode *ldv_94_resource_0;
  unsigned long ldv_94_size_cnt;
  long long *ldv_94_ldv_param_3_5;
  char *ldv_94_ldv_param_1_6;
  long long *ldv_94_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 10152 
  struct file_operations *ldv_94_container = ldv_emg_alias_pipeline_hs_tx_stat_fifo_int_ops_2;
  
#line 10153 
  int ldv_94_ret = ldv_undef_int();
  
#line 10156 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 10160 
  ldv_94_ret = ldv_undef_int();
  
#line 10163 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 10164 
    ldv_94_container = data->arg0;
    
#line 10165 
    ldv_free((void *)data);
  }
  else ;
  
#line 10170 
  ldv_94_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 10171 
  tmp_1 = ldv_undef_int();
  
#line 10171 
  ldv_94_size_cnt = (unsigned long)tmp_1;
  
#line 10178 
  goto ldv_main_94;
  
#line 10180 
  __retres = (void *)0;
  
#line 10180 
  goto return_label;
  ldv_main_94: 
#line 10183 
  ;
  
#line 10186 
  tmp_3 = ldv_undef_int();
  
#line 10186 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 10189 
    ldv_94_ret = (*ldv_emg_alias_simple_open_5)(ldv_94_resource_0,ldv_94_resource_1);
    
#line 10191 
    ldv_94_ret = ldv_filter_err_code(ldv_94_ret);
    
#line 10194 
    tmp_2 = ldv_undef_int();
    
#line 10194 
    if (tmp_2 != 0) {
      
#line 10196 
      __VERIFIER_assume(ldv_94_ret == 0);
      
#line 10203 
      goto ldv_call_94;
    }
    else {
      
#line 10207 
      __VERIFIER_assume(ldv_94_ret != 0);
      
#line 10214 
      goto ldv_main_94;
    }
  }
  else {
    
#line 10219 
    ldv_free((void *)ldv_94_resource_0);
    
#line 10227 
    __retres = (void *)0;
    
#line 10227 
    goto return_label;
  }
  
#line 10230 
  __retres = (void *)0;
  
#line 10230 
  goto return_label;
  ldv_call_94: 
#line 10233 
  ;
  
#line 10236 
  tmp_4 = ldv_undef_int();
  
#line 10236 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 10237 
    ;
    
#line 10239 
    ldv_94_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 10240 
    ldv_94_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 10244 
    if (ldv_94_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 10250 
      __VERIFIER_assume(ldv_94_size_cnt <= 2147479552UL);
      
#line 10252 
      (*(ldv_94_container->write))(ldv_94_resource_1,(char const *)ldv_94_ldv_param_1_6,ldv_94_size_cnt,ldv_94_ldv_param_3_7);
    }
    else ;
    
#line 10257 
    ldv_free((void *)ldv_94_ldv_param_3_7);
    
#line 10258 
    ldv_free((void *)ldv_94_ldv_param_1_6);
    
#line 10265 
    goto ldv_call_94;
    case 2: 
#line 10268 
    ;
    
#line 10270 
    if (ldv_94_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 10272 
      (*(ldv_94_container->release))(ldv_94_resource_0,ldv_94_resource_1); else ;
    
#line 10280 
    goto ldv_main_94;
    case 3: 
#line 10283 
    ;
    
#line 10287 
    tmp_9 = ldv_undef_int();
    
#line 10287 
    if (tmp_9 != 0) 
#line 10290 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_94_resource_1,ldv_94_ldv_param_1_2,ldv_94_ldv_param_2_3);
    else {
      
#line 10296 
      ldv_94_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 10297 
      ldv_94_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 10302 
      ldv_emg_wrapper_pipeline_hs_tx_stat_fifo_int_read_3(ldv_94_resource_1,ldv_94_ldv_param_1_4,ldv_94_size_cnt,ldv_94_ldv_param_3_5);
      
#line 10306 
      ldv_free((void *)ldv_94_ldv_param_3_5);
      
#line 10307 
      ldv_free((void *)ldv_94_ldv_param_1_4);
    }
    
#line 10311 
    goto ldv_31892;
    default: 
#line 10313 
    ;
    
#line 10313 
    __VERIFIER_assume(0);
  }
  ldv_31892: 
#line 10322 
  ;
  
#line 10322 
  goto ldv_call_94;
  
#line 10324 
  __retres = (void *)0;
  return_label: 
#line 10324 
                return __retres;
}


#line 10329  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_68(void *arg0)
{
  void *__retres;
  struct file *ldv_68_resource_1;
  int ldv_68_ldv_param_2_3;
  long long ldv_68_ldv_param_1_2;
  char *ldv_68_ldv_param_1_4;
  struct inode *ldv_68_resource_0;
  unsigned long ldv_68_size_cnt;
  long long *ldv_68_ldv_param_3_5;
  char *ldv_68_ldv_param_1_6;
  long long *ldv_68_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 10340 
  struct file_operations *ldv_68_container = ldv_emg_alias_pipeline_dec_packet_in_fifo_full_ops_2;
  
#line 10341 
  int ldv_68_ret = ldv_undef_int();
  
#line 10344 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 10348 
  ldv_68_ret = ldv_undef_int();
  
#line 10351 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 10352 
    ldv_68_container = data->arg0;
    
#line 10353 
    ldv_free((void *)data);
  }
  else ;
  
#line 10358 
  ldv_68_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 10359 
  tmp_1 = ldv_undef_int();
  
#line 10359 
  ldv_68_size_cnt = (unsigned long)tmp_1;
  
#line 10366 
  goto ldv_main_68;
  
#line 10368 
  __retres = (void *)0;
  
#line 10368 
  goto return_label;
  ldv_main_68: 
#line 10371 
  ;
  
#line 10374 
  tmp_3 = ldv_undef_int();
  
#line 10374 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 10377 
    ldv_68_ret = (*ldv_emg_alias_simple_open_5)(ldv_68_resource_0,ldv_68_resource_1);
    
#line 10379 
    ldv_68_ret = ldv_filter_err_code(ldv_68_ret);
    
#line 10382 
    tmp_2 = ldv_undef_int();
    
#line 10382 
    if (tmp_2 != 0) {
      
#line 10384 
      __VERIFIER_assume(ldv_68_ret == 0);
      
#line 10391 
      goto ldv_call_68;
    }
    else {
      
#line 10395 
      __VERIFIER_assume(ldv_68_ret != 0);
      
#line 10402 
      goto ldv_main_68;
    }
  }
  else {
    
#line 10407 
    ldv_free((void *)ldv_68_resource_0);
    
#line 10415 
    __retres = (void *)0;
    
#line 10415 
    goto return_label;
  }
  
#line 10418 
  __retres = (void *)0;
  
#line 10418 
  goto return_label;
  ldv_call_68: 
#line 10421 
  ;
  
#line 10424 
  tmp_4 = ldv_undef_int();
  
#line 10424 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 10425 
    ;
    
#line 10427 
    ldv_68_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 10428 
    ldv_68_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 10432 
    if (ldv_68_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 10438 
      __VERIFIER_assume(ldv_68_size_cnt <= 2147479552UL);
      
#line 10440 
      (*(ldv_68_container->write))(ldv_68_resource_1,(char const *)ldv_68_ldv_param_1_6,ldv_68_size_cnt,ldv_68_ldv_param_3_7);
    }
    else ;
    
#line 10445 
    ldv_free((void *)ldv_68_ldv_param_3_7);
    
#line 10446 
    ldv_free((void *)ldv_68_ldv_param_1_6);
    
#line 10453 
    goto ldv_call_68;
    case 2: 
#line 10456 
    ;
    
#line 10458 
    if (ldv_68_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 10460 
      (*(ldv_68_container->release))(ldv_68_resource_0,ldv_68_resource_1); else ;
    
#line 10468 
    goto ldv_main_68;
    case 3: 
#line 10471 
    ;
    
#line 10475 
    tmp_9 = ldv_undef_int();
    
#line 10475 
    if (tmp_9 != 0) 
#line 10478 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_68_resource_1,ldv_68_ldv_param_1_2,ldv_68_ldv_param_2_3);
    else {
      
#line 10484 
      ldv_68_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 10485 
      ldv_68_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 10490 
      ldv_emg_wrapper_pipeline_dec_packet_in_fifo_full_read_3(ldv_68_resource_1,ldv_68_ldv_param_1_4,ldv_68_size_cnt,ldv_68_ldv_param_3_5);
      
#line 10494 
      ldv_free((void *)ldv_68_ldv_param_3_5);
      
#line 10495 
      ldv_free((void *)ldv_68_ldv_param_1_4);
    }
    
#line 10499 
    goto ldv_31914;
    default: 
#line 10501 
    ;
    
#line 10501 
    __VERIFIER_assume(0);
  }
  ldv_31914: 
#line 10510 
  ;
  
#line 10510 
  goto ldv_call_68;
  
#line 10512 
  __retres = (void *)0;
  return_label: 
#line 10512 
                return __retres;
}


#line 10517  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_71(void *arg0)
{
  void *__retres;
  struct file *ldv_71_resource_1;
  int ldv_71_ldv_param_2_3;
  long long ldv_71_ldv_param_1_2;
  char *ldv_71_ldv_param_1_4;
  struct inode *ldv_71_resource_0;
  unsigned long ldv_71_size_cnt;
  long long *ldv_71_ldv_param_3_5;
  char *ldv_71_ldv_param_1_6;
  long long *ldv_71_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 10528 
  struct file_operations *ldv_71_container = ldv_emg_alias_pipeline_dec_packet_in_ops_2;
  
#line 10529 
  int ldv_71_ret = ldv_undef_int();
  
#line 10532 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 10536 
  ldv_71_ret = ldv_undef_int();
  
#line 10539 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 10540 
    ldv_71_container = data->arg0;
    
#line 10541 
    ldv_free((void *)data);
  }
  else ;
  
#line 10546 
  ldv_71_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 10547 
  tmp_1 = ldv_undef_int();
  
#line 10547 
  ldv_71_size_cnt = (unsigned long)tmp_1;
  
#line 10554 
  goto ldv_main_71;
  
#line 10556 
  __retres = (void *)0;
  
#line 10556 
  goto return_label;
  ldv_main_71: 
#line 10559 
  ;
  
#line 10562 
  tmp_3 = ldv_undef_int();
  
#line 10562 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 10565 
    ldv_71_ret = (*ldv_emg_alias_simple_open_5)(ldv_71_resource_0,ldv_71_resource_1);
    
#line 10567 
    ldv_71_ret = ldv_filter_err_code(ldv_71_ret);
    
#line 10570 
    tmp_2 = ldv_undef_int();
    
#line 10570 
    if (tmp_2 != 0) {
      
#line 10572 
      __VERIFIER_assume(ldv_71_ret == 0);
      
#line 10579 
      goto ldv_call_71;
    }
    else {
      
#line 10583 
      __VERIFIER_assume(ldv_71_ret != 0);
      
#line 10590 
      goto ldv_main_71;
    }
  }
  else {
    
#line 10595 
    ldv_free((void *)ldv_71_resource_0);
    
#line 10603 
    __retres = (void *)0;
    
#line 10603 
    goto return_label;
  }
  
#line 10606 
  __retres = (void *)0;
  
#line 10606 
  goto return_label;
  ldv_call_71: 
#line 10609 
  ;
  
#line 10612 
  tmp_4 = ldv_undef_int();
  
#line 10612 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 10613 
    ;
    
#line 10615 
    ldv_71_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 10616 
    ldv_71_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 10620 
    if (ldv_71_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 10626 
      __VERIFIER_assume(ldv_71_size_cnt <= 2147479552UL);
      
#line 10628 
      (*(ldv_71_container->write))(ldv_71_resource_1,(char const *)ldv_71_ldv_param_1_6,ldv_71_size_cnt,ldv_71_ldv_param_3_7);
    }
    else ;
    
#line 10633 
    ldv_free((void *)ldv_71_ldv_param_1_6);
    
#line 10634 
    ldv_free((void *)ldv_71_ldv_param_3_7);
    
#line 10641 
    goto ldv_call_71;
    case 2: 
#line 10644 
    ;
    
#line 10646 
    if (ldv_71_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 10648 
      (*(ldv_71_container->release))(ldv_71_resource_0,ldv_71_resource_1); else ;
    
#line 10656 
    goto ldv_main_71;
    case 3: 
#line 10659 
    ;
    
#line 10663 
    tmp_9 = ldv_undef_int();
    
#line 10663 
    if (tmp_9 != 0) 
#line 10666 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_71_resource_1,ldv_71_ldv_param_1_2,ldv_71_ldv_param_2_3);
    else {
      
#line 10672 
      ldv_71_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 10673 
      ldv_71_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 10678 
      ldv_emg_wrapper_pipeline_dec_packet_in_read_3(ldv_71_resource_1,ldv_71_ldv_param_1_4,ldv_71_size_cnt,ldv_71_ldv_param_3_5);
      
#line 10682 
      ldv_free((void *)ldv_71_ldv_param_3_5);
      
#line 10683 
      ldv_free((void *)ldv_71_ldv_param_1_4);
    }
    
#line 10687 
    goto ldv_31936;
    default: 
#line 10689 
    ;
    
#line 10689 
    __VERIFIER_assume(0);
  }
  ldv_31936: 
#line 10698 
  ;
  
#line 10698 
  goto ldv_call_71;
  
#line 10700 
  __retres = (void *)0;
  return_label: 
#line 10700 
                return __retres;
}


#line 10705  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_80(void *arg0)
{
  void *__retres;
  struct file *ldv_80_resource_1;
  int ldv_80_ldv_param_2_3;
  long long ldv_80_ldv_param_1_2;
  char *ldv_80_ldv_param_1_4;
  struct inode *ldv_80_resource_0;
  unsigned long ldv_80_size_cnt;
  long long *ldv_80_ldv_param_3_5;
  char *ldv_80_ldv_param_1_6;
  long long *ldv_80_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 10716 
  struct file_operations *ldv_80_container = ldv_emg_alias_rx_rx_frame_checksum_ops_2;
  
#line 10717 
  int ldv_80_ret = ldv_undef_int();
  
#line 10720 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 10724 
  ldv_80_ret = ldv_undef_int();
  
#line 10727 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 10728 
    ldv_80_container = data->arg0;
    
#line 10729 
    ldv_free((void *)data);
  }
  else ;
  
#line 10734 
  ldv_80_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 10735 
  tmp_1 = ldv_undef_int();
  
#line 10735 
  ldv_80_size_cnt = (unsigned long)tmp_1;
  
#line 10742 
  goto ldv_main_80;
  
#line 10744 
  __retres = (void *)0;
  
#line 10744 
  goto return_label;
  ldv_main_80: 
#line 10747 
  ;
  
#line 10750 
  tmp_3 = ldv_undef_int();
  
#line 10750 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 10753 
    ldv_80_ret = (*ldv_emg_alias_simple_open_5)(ldv_80_resource_0,ldv_80_resource_1);
    
#line 10755 
    ldv_80_ret = ldv_filter_err_code(ldv_80_ret);
    
#line 10758 
    tmp_2 = ldv_undef_int();
    
#line 10758 
    if (tmp_2 != 0) {
      
#line 10760 
      __VERIFIER_assume(ldv_80_ret == 0);
      
#line 10767 
      goto ldv_call_80;
    }
    else {
      
#line 10771 
      __VERIFIER_assume(ldv_80_ret != 0);
      
#line 10778 
      goto ldv_main_80;
    }
  }
  else {
    
#line 10783 
    ldv_free((void *)ldv_80_resource_0);
    
#line 10791 
    __retres = (void *)0;
    
#line 10791 
    goto return_label;
  }
  
#line 10794 
  __retres = (void *)0;
  
#line 10794 
  goto return_label;
  ldv_call_80: 
#line 10797 
  ;
  
#line 10800 
  tmp_4 = ldv_undef_int();
  
#line 10800 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 10801 
    ;
    
#line 10803 
    ldv_80_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 10804 
    ldv_80_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 10808 
    if (ldv_80_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 10814 
      __VERIFIER_assume(ldv_80_size_cnt <= 2147479552UL);
      
#line 10816 
      (*(ldv_80_container->write))(ldv_80_resource_1,(char const *)ldv_80_ldv_param_1_6,ldv_80_size_cnt,ldv_80_ldv_param_3_7);
    }
    else ;
    
#line 10821 
    ldv_free((void *)ldv_80_ldv_param_1_6);
    
#line 10822 
    ldv_free((void *)ldv_80_ldv_param_3_7);
    
#line 10829 
    goto ldv_call_80;
    case 2: 
#line 10832 
    ;
    
#line 10834 
    if (ldv_80_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 10836 
      (*(ldv_80_container->release))(ldv_80_resource_0,ldv_80_resource_1); else ;
    
#line 10844 
    goto ldv_main_80;
    case 3: 
#line 10847 
    ;
    
#line 10851 
    tmp_9 = ldv_undef_int();
    
#line 10851 
    if (tmp_9 != 0) 
#line 10854 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_80_resource_1,ldv_80_ldv_param_1_2,ldv_80_ldv_param_2_3);
    else {
      
#line 10860 
      ldv_80_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 10861 
      ldv_80_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 10866 
      ldv_emg_wrapper_rx_rx_frame_checksum_read_3(ldv_80_resource_1,ldv_80_ldv_param_1_4,ldv_80_size_cnt,ldv_80_ldv_param_3_5);
      
#line 10870 
      ldv_free((void *)ldv_80_ldv_param_1_4);
      
#line 10871 
      ldv_free((void *)ldv_80_ldv_param_3_5);
    }
    
#line 10875 
    goto ldv_31958;
    default: 
#line 10877 
    ;
    
#line 10877 
    __VERIFIER_assume(0);
  }
  ldv_31958: 
#line 10886 
  ;
  
#line 10886 
  goto ldv_call_80;
  
#line 10888 
  __retres = (void *)0;
  return_label: 
#line 10888 
                return __retres;
}


#line 10893  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_90(void *arg0)
{
  void *__retres;
  struct file *ldv_90_resource_1;
  int ldv_90_ldv_param_2_3;
  long long ldv_90_ldv_param_1_2;
  char *ldv_90_ldv_param_1_4;
  struct inode *ldv_90_resource_0;
  unsigned long ldv_90_size_cnt;
  long long *ldv_90_ldv_param_3_5;
  char *ldv_90_ldv_param_1_6;
  long long *ldv_90_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 10904 
  struct file_operations *ldv_90_container = ldv_emg_alias_pipeline_cs_rx_packet_out_ops_2;
  
#line 10905 
  int ldv_90_ret = ldv_undef_int();
  
#line 10908 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 10912 
  ldv_90_ret = ldv_undef_int();
  
#line 10915 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 10916 
    ldv_90_container = data->arg0;
    
#line 10917 
    ldv_free((void *)data);
  }
  else ;
  
#line 10922 
  ldv_90_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 10923 
  tmp_1 = ldv_undef_int();
  
#line 10923 
  ldv_90_size_cnt = (unsigned long)tmp_1;
  
#line 10930 
  goto ldv_main_90;
  
#line 10932 
  __retres = (void *)0;
  
#line 10932 
  goto return_label;
  ldv_main_90: 
#line 10935 
  ;
  
#line 10938 
  tmp_3 = ldv_undef_int();
  
#line 10938 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 10941 
    ldv_90_ret = (*ldv_emg_alias_simple_open_5)(ldv_90_resource_0,ldv_90_resource_1);
    
#line 10943 
    ldv_90_ret = ldv_filter_err_code(ldv_90_ret);
    
#line 10946 
    tmp_2 = ldv_undef_int();
    
#line 10946 
    if (tmp_2 != 0) {
      
#line 10948 
      __VERIFIER_assume(ldv_90_ret == 0);
      
#line 10955 
      goto ldv_call_90;
    }
    else {
      
#line 10959 
      __VERIFIER_assume(ldv_90_ret != 0);
      
#line 10966 
      goto ldv_main_90;
    }
  }
  else {
    
#line 10971 
    ldv_free((void *)ldv_90_resource_0);
    
#line 10979 
    __retres = (void *)0;
    
#line 10979 
    goto return_label;
  }
  
#line 10982 
  __retres = (void *)0;
  
#line 10982 
  goto return_label;
  ldv_call_90: 
#line 10985 
  ;
  
#line 10988 
  tmp_4 = ldv_undef_int();
  
#line 10988 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 10989 
    ;
    
#line 10991 
    ldv_90_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 10992 
    ldv_90_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 10996 
    if (ldv_90_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 11002 
      __VERIFIER_assume(ldv_90_size_cnt <= 2147479552UL);
      
#line 11004 
      (*(ldv_90_container->write))(ldv_90_resource_1,(char const *)ldv_90_ldv_param_1_6,ldv_90_size_cnt,ldv_90_ldv_param_3_7);
    }
    else ;
    
#line 11009 
    ldv_free((void *)ldv_90_ldv_param_3_7);
    
#line 11010 
    ldv_free((void *)ldv_90_ldv_param_1_6);
    
#line 11017 
    goto ldv_call_90;
    case 2: 
#line 11020 
    ;
    
#line 11022 
    if (ldv_90_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 11024 
      (*(ldv_90_container->release))(ldv_90_resource_0,ldv_90_resource_1); else ;
    
#line 11032 
    goto ldv_main_90;
    case 3: 
#line 11035 
    ;
    
#line 11039 
    tmp_9 = ldv_undef_int();
    
#line 11039 
    if (tmp_9 != 0) 
#line 11042 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_90_resource_1,ldv_90_ldv_param_1_2,ldv_90_ldv_param_2_3);
    else {
      
#line 11048 
      ldv_90_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 11049 
      ldv_90_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 11054 
      ldv_emg_wrapper_pipeline_cs_rx_packet_out_read_3(ldv_90_resource_1,ldv_90_ldv_param_1_4,ldv_90_size_cnt,ldv_90_ldv_param_3_5);
      
#line 11058 
      ldv_free((void *)ldv_90_ldv_param_3_5);
      
#line 11059 
      ldv_free((void *)ldv_90_ldv_param_1_4);
    }
    
#line 11063 
    goto ldv_31980;
    default: 
#line 11065 
    ;
    
#line 11065 
    __VERIFIER_assume(0);
  }
  ldv_31980: 
#line 11074 
  ;
  
#line 11074 
  goto ldv_call_90;
  
#line 11076 
  __retres = (void *)0;
  return_label: 
#line 11076 
                return __retres;
}


#line 11081  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_18(void *arg0)
{
  void *__retres;
  struct file *ldv_18_resource_1;
  int ldv_18_ldv_param_2_3;
  long long ldv_18_ldv_param_1_2;
  char *ldv_18_ldv_param_1_4;
  struct inode *ldv_18_resource_0;
  unsigned long ldv_18_size_cnt;
  long long *ldv_18_ldv_param_3_5;
  char *ldv_18_ldv_param_1_6;
  long long *ldv_18_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 11092 
  struct file_operations *ldv_18_container = ldv_emg_alias_tx_tx_done_template_ops_2;
  
#line 11093 
  int ldv_18_ret = ldv_undef_int();
  
#line 11096 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 11100 
  ldv_18_ret = ldv_undef_int();
  
#line 11103 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 11104 
    ldv_18_container = data->arg0;
    
#line 11105 
    ldv_free((void *)data);
  }
  else ;
  
#line 11110 
  ldv_18_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 11111 
  tmp_1 = ldv_undef_int();
  
#line 11111 
  ldv_18_size_cnt = (unsigned long)tmp_1;
  
#line 11118 
  goto ldv_main_18;
  
#line 11120 
  __retres = (void *)0;
  
#line 11120 
  goto return_label;
  ldv_main_18: 
#line 11123 
  ;
  
#line 11126 
  tmp_3 = ldv_undef_int();
  
#line 11126 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 11129 
    ldv_18_ret = (*ldv_emg_alias_simple_open_5)(ldv_18_resource_0,ldv_18_resource_1);
    
#line 11131 
    ldv_18_ret = ldv_filter_err_code(ldv_18_ret);
    
#line 11134 
    tmp_2 = ldv_undef_int();
    
#line 11134 
    if (tmp_2 != 0) {
      
#line 11136 
      __VERIFIER_assume(ldv_18_ret == 0);
      
#line 11143 
      goto ldv_call_18;
    }
    else {
      
#line 11147 
      __VERIFIER_assume(ldv_18_ret != 0);
      
#line 11154 
      goto ldv_main_18;
    }
  }
  else {
    
#line 11159 
    ldv_free((void *)ldv_18_resource_0);
    
#line 11167 
    __retres = (void *)0;
    
#line 11167 
    goto return_label;
  }
  
#line 11170 
  __retres = (void *)0;
  
#line 11170 
  goto return_label;
  ldv_call_18: 
#line 11173 
  ;
  
#line 11176 
  tmp_4 = ldv_undef_int();
  
#line 11176 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 11177 
    ;
    
#line 11179 
    ldv_18_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 11180 
    ldv_18_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 11184 
    if (ldv_18_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 11190 
      __VERIFIER_assume(ldv_18_size_cnt <= 2147479552UL);
      
#line 11192 
      (*(ldv_18_container->write))(ldv_18_resource_1,(char const *)ldv_18_ldv_param_1_6,ldv_18_size_cnt,ldv_18_ldv_param_3_7);
    }
    else ;
    
#line 11197 
    ldv_free((void *)ldv_18_ldv_param_3_7);
    
#line 11198 
    ldv_free((void *)ldv_18_ldv_param_1_6);
    
#line 11205 
    goto ldv_call_18;
    case 2: 
#line 11208 
    ;
    
#line 11210 
    if (ldv_18_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 11212 
      (*(ldv_18_container->release))(ldv_18_resource_0,ldv_18_resource_1); else ;
    
#line 11220 
    goto ldv_main_18;
    case 3: 
#line 11223 
    ;
    
#line 11227 
    tmp_9 = ldv_undef_int();
    
#line 11227 
    if (tmp_9 != 0) 
#line 11230 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_18_resource_1,ldv_18_ldv_param_1_2,ldv_18_ldv_param_2_3);
    else {
      
#line 11236 
      ldv_18_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 11237 
      ldv_18_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 11242 
      ldv_emg_wrapper_tx_tx_done_template_read_3(ldv_18_resource_1,ldv_18_ldv_param_1_4,ldv_18_size_cnt,ldv_18_ldv_param_3_5);
      
#line 11246 
      ldv_free((void *)ldv_18_ldv_param_3_5);
      
#line 11247 
      ldv_free((void *)ldv_18_ldv_param_1_4);
    }
    
#line 11251 
    goto ldv_32002;
    default: 
#line 11253 
    ;
    
#line 11253 
    __VERIFIER_assume(0);
  }
  ldv_32002: 
#line 11262 
  ;
  
#line 11262 
  goto ldv_call_18;
  
#line 11264 
  __retres = (void *)0;
  return_label: 
#line 11264 
                return __retres;
}


#line 11269  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_77(void *arg0)
{
  void *__retres;
  struct file *ldv_77_resource_1;
  int ldv_77_ldv_param_2_3;
  long long ldv_77_ldv_param_1_2;
  char *ldv_77_ldv_param_1_4;
  struct inode *ldv_77_resource_0;
  unsigned long ldv_77_size_cnt;
  long long *ldv_77_ldv_param_3_5;
  char *ldv_77_ldv_param_1_6;
  long long *ldv_77_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 11280 
  struct file_operations *ldv_77_container = ldv_emg_alias_debug_debug1_ops_2;
  
#line 11281 
  int ldv_77_ret = ldv_undef_int();
  
#line 11284 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 11288 
  ldv_77_ret = ldv_undef_int();
  
#line 11291 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 11292 
    ldv_77_container = data->arg0;
    
#line 11293 
    ldv_free((void *)data);
  }
  else ;
  
#line 11298 
  ldv_77_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 11299 
  tmp_1 = ldv_undef_int();
  
#line 11299 
  ldv_77_size_cnt = (unsigned long)tmp_1;
  
#line 11306 
  goto ldv_main_77;
  
#line 11308 
  __retres = (void *)0;
  
#line 11308 
  goto return_label;
  ldv_main_77: 
#line 11311 
  ;
  
#line 11314 
  tmp_3 = ldv_undef_int();
  
#line 11314 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 11317 
    ldv_77_ret = (*ldv_emg_alias_simple_open_5)(ldv_77_resource_0,ldv_77_resource_1);
    
#line 11319 
    ldv_77_ret = ldv_filter_err_code(ldv_77_ret);
    
#line 11322 
    tmp_2 = ldv_undef_int();
    
#line 11322 
    if (tmp_2 != 0) {
      
#line 11324 
      __VERIFIER_assume(ldv_77_ret == 0);
      
#line 11331 
      goto ldv_call_77;
    }
    else {
      
#line 11335 
      __VERIFIER_assume(ldv_77_ret != 0);
      
#line 11342 
      goto ldv_main_77;
    }
  }
  else {
    
#line 11347 
    ldv_free((void *)ldv_77_resource_0);
    
#line 11355 
    __retres = (void *)0;
    
#line 11355 
    goto return_label;
  }
  
#line 11358 
  __retres = (void *)0;
  
#line 11358 
  goto return_label;
  ldv_call_77: 
#line 11361 
  ;
  
#line 11364 
  tmp_4 = ldv_undef_int();
  
#line 11364 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 11365 
    ;
    
#line 11367 
    ldv_77_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 11368 
    ldv_77_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 11372 
    if (ldv_77_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 11378 
      __VERIFIER_assume(ldv_77_size_cnt <= 2147479552UL);
      
#line 11380 
      (*(ldv_77_container->write))(ldv_77_resource_1,(char const *)ldv_77_ldv_param_1_6,ldv_77_size_cnt,ldv_77_ldv_param_3_7);
    }
    else ;
    
#line 11385 
    ldv_free((void *)ldv_77_ldv_param_1_6);
    
#line 11386 
    ldv_free((void *)ldv_77_ldv_param_3_7);
    
#line 11393 
    goto ldv_call_77;
    case 2: 
#line 11396 
    ;
    
#line 11398 
    if (ldv_77_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 11400 
      (*(ldv_77_container->release))(ldv_77_resource_0,ldv_77_resource_1); else ;
    
#line 11408 
    goto ldv_main_77;
    case 3: 
#line 11411 
    ;
    
#line 11415 
    tmp_9 = ldv_undef_int();
    
#line 11415 
    if (tmp_9 != 0) 
#line 11418 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_77_resource_1,ldv_77_ldv_param_1_2,ldv_77_ldv_param_2_3);
    else {
      
#line 11424 
      ldv_77_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 11425 
      ldv_77_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 11430 
      ldv_emg_wrapper_debug_debug1_read_3(ldv_77_resource_1,ldv_77_ldv_param_1_4,ldv_77_size_cnt,ldv_77_ldv_param_3_5);
      
#line 11434 
      ldv_free((void *)ldv_77_ldv_param_1_4);
      
#line 11435 
      ldv_free((void *)ldv_77_ldv_param_3_5);
    }
    
#line 11439 
    goto ldv_32024;
    default: 
#line 11441 
    ;
    
#line 11441 
    __VERIFIER_assume(0);
  }
  ldv_32024: 
#line 11450 
  ;
  
#line 11450 
  goto ldv_call_77;
  
#line 11452 
  __retres = (void *)0;
  return_label: 
#line 11452 
                return __retres;
}


#line 11457  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_13(void *arg0)
{
  void *__retres;
  struct file *ldv_13_resource_1;
  int ldv_13_ldv_param_2_3;
  long long ldv_13_ldv_param_1_2;
  char *ldv_13_ldv_param_1_4;
  struct inode *ldv_13_resource_0;
  unsigned long ldv_13_size_cnt;
  long long *ldv_13_ldv_param_3_5;
  char *ldv_13_ldv_param_1_6;
  long long *ldv_13_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 11468 
  struct file_operations *ldv_13_container = ldv_emg_alias_tx_tx_imm_resp_ops_2;
  
#line 11469 
  int ldv_13_ret = ldv_undef_int();
  
#line 11472 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 11476 
  ldv_13_ret = ldv_undef_int();
  
#line 11479 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 11480 
    ldv_13_container = data->arg0;
    
#line 11481 
    ldv_free((void *)data);
  }
  else ;
  
#line 11486 
  ldv_13_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 11487 
  tmp_1 = ldv_undef_int();
  
#line 11487 
  ldv_13_size_cnt = (unsigned long)tmp_1;
  
#line 11494 
  goto ldv_main_13;
  
#line 11496 
  __retres = (void *)0;
  
#line 11496 
  goto return_label;
  ldv_main_13: 
#line 11499 
  ;
  
#line 11502 
  tmp_3 = ldv_undef_int();
  
#line 11502 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 11505 
    ldv_13_ret = (*ldv_emg_alias_simple_open_5)(ldv_13_resource_0,ldv_13_resource_1);
    
#line 11507 
    ldv_13_ret = ldv_filter_err_code(ldv_13_ret);
    
#line 11510 
    tmp_2 = ldv_undef_int();
    
#line 11510 
    if (tmp_2 != 0) {
      
#line 11512 
      __VERIFIER_assume(ldv_13_ret == 0);
      
#line 11519 
      goto ldv_call_13;
    }
    else {
      
#line 11523 
      __VERIFIER_assume(ldv_13_ret != 0);
      
#line 11530 
      goto ldv_main_13;
    }
  }
  else {
    
#line 11535 
    ldv_free((void *)ldv_13_resource_0);
    
#line 11543 
    __retres = (void *)0;
    
#line 11543 
    goto return_label;
  }
  
#line 11546 
  __retres = (void *)0;
  
#line 11546 
  goto return_label;
  ldv_call_13: 
#line 11549 
  ;
  
#line 11552 
  tmp_4 = ldv_undef_int();
  
#line 11552 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 11553 
    ;
    
#line 11555 
    ldv_13_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 11556 
    ldv_13_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 11560 
    if (ldv_13_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 11566 
      __VERIFIER_assume(ldv_13_size_cnt <= 2147479552UL);
      
#line 11568 
      (*(ldv_13_container->write))(ldv_13_resource_1,(char const *)ldv_13_ldv_param_1_6,ldv_13_size_cnt,ldv_13_ldv_param_3_7);
    }
    else ;
    
#line 11573 
    ldv_free((void *)ldv_13_ldv_param_1_6);
    
#line 11574 
    ldv_free((void *)ldv_13_ldv_param_3_7);
    
#line 11581 
    goto ldv_call_13;
    case 2: 
#line 11584 
    ;
    
#line 11586 
    if (ldv_13_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 11588 
      (*(ldv_13_container->release))(ldv_13_resource_0,ldv_13_resource_1); else ;
    
#line 11596 
    goto ldv_main_13;
    case 3: 
#line 11599 
    ;
    
#line 11603 
    tmp_9 = ldv_undef_int();
    
#line 11603 
    if (tmp_9 != 0) 
#line 11606 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_13_resource_1,ldv_13_ldv_param_1_2,ldv_13_ldv_param_2_3);
    else {
      
#line 11612 
      ldv_13_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 11613 
      ldv_13_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 11618 
      ldv_emg_wrapper_tx_tx_imm_resp_read_3(ldv_13_resource_1,ldv_13_ldv_param_1_4,ldv_13_size_cnt,ldv_13_ldv_param_3_5);
      
#line 11622 
      ldv_free((void *)ldv_13_ldv_param_3_5);
      
#line 11623 
      ldv_free((void *)ldv_13_ldv_param_1_4);
    }
    
#line 11627 
    goto ldv_32046;
    default: 
#line 11629 
    ;
    
#line 11629 
    __VERIFIER_assume(0);
  }
  ldv_32046: 
#line 11638 
  ;
  
#line 11638 
  goto ldv_call_13;
  
#line 11640 
  __retres = (void *)0;
  return_label: 
#line 11640 
                return __retres;
}


#line 11645  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_32(void *arg0)
{
  void *__retres;
  struct file *ldv_32_resource_1;
  int ldv_32_ldv_param_2_3;
  long long ldv_32_ldv_param_1_2;
  char *ldv_32_ldv_param_1_4;
  struct inode *ldv_32_resource_0;
  unsigned long ldv_32_size_cnt;
  long long *ldv_32_ldv_param_3_5;
  char *ldv_32_ldv_param_1_6;
  long long *ldv_32_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 11656 
  struct file_operations *ldv_32_container = ldv_emg_alias_rx_rx_pre_complt_ops_2;
  
#line 11657 
  int ldv_32_ret = ldv_undef_int();
  
#line 11660 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 11664 
  ldv_32_ret = ldv_undef_int();
  
#line 11667 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 11668 
    ldv_32_container = data->arg0;
    
#line 11669 
    ldv_free((void *)data);
  }
  else ;
  
#line 11674 
  ldv_32_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 11675 
  tmp_1 = ldv_undef_int();
  
#line 11675 
  ldv_32_size_cnt = (unsigned long)tmp_1;
  
#line 11682 
  goto ldv_main_32;
  
#line 11684 
  __retres = (void *)0;
  
#line 11684 
  goto return_label;
  ldv_main_32: 
#line 11687 
  ;
  
#line 11690 
  tmp_3 = ldv_undef_int();
  
#line 11690 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 11693 
    ldv_32_ret = (*ldv_emg_alias_simple_open_5)(ldv_32_resource_0,ldv_32_resource_1);
    
#line 11695 
    ldv_32_ret = ldv_filter_err_code(ldv_32_ret);
    
#line 11698 
    tmp_2 = ldv_undef_int();
    
#line 11698 
    if (tmp_2 != 0) {
      
#line 11700 
      __VERIFIER_assume(ldv_32_ret == 0);
      
#line 11707 
      goto ldv_call_32;
    }
    else {
      
#line 11711 
      __VERIFIER_assume(ldv_32_ret != 0);
      
#line 11718 
      goto ldv_main_32;
    }
  }
  else {
    
#line 11723 
    ldv_free((void *)ldv_32_resource_0);
    
#line 11731 
    __retres = (void *)0;
    
#line 11731 
    goto return_label;
  }
  
#line 11734 
  __retres = (void *)0;
  
#line 11734 
  goto return_label;
  ldv_call_32: 
#line 11737 
  ;
  
#line 11740 
  tmp_4 = ldv_undef_int();
  
#line 11740 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 11741 
    ;
    
#line 11743 
    ldv_32_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 11744 
    ldv_32_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 11748 
    if (ldv_32_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 11754 
      __VERIFIER_assume(ldv_32_size_cnt <= 2147479552UL);
      
#line 11756 
      (*(ldv_32_container->write))(ldv_32_resource_1,(char const *)ldv_32_ldv_param_1_6,ldv_32_size_cnt,ldv_32_ldv_param_3_7);
    }
    else ;
    
#line 11761 
    ldv_free((void *)ldv_32_ldv_param_1_6);
    
#line 11762 
    ldv_free((void *)ldv_32_ldv_param_3_7);
    
#line 11769 
    goto ldv_call_32;
    case 2: 
#line 11772 
    ;
    
#line 11774 
    if (ldv_32_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 11776 
      (*(ldv_32_container->release))(ldv_32_resource_0,ldv_32_resource_1); else ;
    
#line 11784 
    goto ldv_main_32;
    case 3: 
#line 11787 
    ;
    
#line 11791 
    tmp_9 = ldv_undef_int();
    
#line 11791 
    if (tmp_9 != 0) 
#line 11794 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_32_resource_1,ldv_32_ldv_param_1_2,ldv_32_ldv_param_2_3);
    else {
      
#line 11800 
      ldv_32_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 11801 
      ldv_32_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 11806 
      ldv_emg_wrapper_rx_rx_pre_complt_read_3(ldv_32_resource_1,ldv_32_ldv_param_1_4,ldv_32_size_cnt,ldv_32_ldv_param_3_5);
      
#line 11810 
      ldv_free((void *)ldv_32_ldv_param_1_4);
      
#line 11811 
      ldv_free((void *)ldv_32_ldv_param_3_5);
    }
    
#line 11815 
    goto ldv_32068;
    default: 
#line 11817 
    ;
    
#line 11817 
    __VERIFIER_assume(0);
  }
  ldv_32068: 
#line 11826 
  ;
  
#line 11826 
  goto ldv_call_32;
  
#line 11828 
  __retres = (void *)0;
  return_label: 
#line 11828 
                return __retres;
}


#line 11833  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_100(void *arg0)
{
  void *__retres;
  struct file *ldv_100_resource_1;
  int ldv_100_ldv_param_2_3;
  long long ldv_100_ldv_param_1_2;
  char *ldv_100_ldv_param_1_4;
  unsigned long ldv_100_size_cnt;
  long long *ldv_100_ldv_param_3_5;
  struct inode *ldv_100_resource_0;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 11842 
  struct file_operations *ldv_100_container = ldv_emg_alias_radar_detection_ops_2;
  
#line 11843 
  int ldv_100_ret = ldv_undef_int();
  
#line 11846 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 11850 
  ldv_100_ret = ldv_undef_int();
  
#line 11853 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 11854 
    ldv_100_container = data->arg0;
    
#line 11855 
    ldv_free((void *)data);
  }
  else ;
  
#line 11860 
  ldv_100_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 11861 
  tmp_1 = ldv_undef_int();
  
#line 11861 
  ldv_100_size_cnt = (unsigned long)tmp_1;
  
#line 11868 
  goto ldv_main_100;
  
#line 11870 
  __retres = (void *)0;
  
#line 11870 
  goto return_label;
  ldv_main_100: 
#line 11873 
  ;
  
#line 11876 
  tmp_3 = ldv_undef_int();
  
#line 11876 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 11879 
    ldv_100_ret = (*ldv_emg_alias_simple_open_5)(ldv_100_resource_0,ldv_100_resource_1);
    
#line 11881 
    ldv_100_ret = ldv_filter_err_code(ldv_100_ret);
    
#line 11884 
    tmp_2 = ldv_undef_int();
    
#line 11884 
    if (tmp_2 != 0) {
      
#line 11886 
      __VERIFIER_assume(ldv_100_ret == 0);
      
#line 11893 
      goto ldv_call_100;
    }
    else {
      
#line 11897 
      __VERIFIER_assume(ldv_100_ret != 0);
      
#line 11904 
      goto ldv_main_100;
    }
  }
  else {
    
#line 11909 
    ldv_free((void *)ldv_100_resource_0);
    
#line 11917 
    __retres = (void *)0;
    
#line 11917 
    goto return_label;
  }
  
#line 11920 
  __retres = (void *)0;
  
#line 11920 
  goto return_label;
  ldv_call_100: 
#line 11923 
  ;
  
#line 11926 
  tmp_4 = ldv_undef_int();
  
#line 11926 
  switch (tmp_4) {
    case 1: 
#line 11927 
    ;
    
#line 11933 
    (*ldv_emg_alias_default_llseek_3)(ldv_100_resource_1,ldv_100_ldv_param_1_2,ldv_100_ldv_param_2_3);
    
#line 11943 
    goto ldv_call_100;
    case 2: 
#line 11946 
    ;
    
#line 11948 
    ldv_100_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 11949 
    ldv_100_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 11958 
    __VERIFIER_assume(ldv_100_size_cnt <= 2147479552UL);
    
#line 11960 
    ldv_emg_wrapper_radar_detection_write_3(ldv_100_resource_1,ldv_100_ldv_param_1_4,ldv_100_size_cnt,ldv_100_ldv_param_3_5);
    
#line 11964 
    ldv_free((void *)ldv_100_ldv_param_1_4);
    
#line 11965 
    ldv_free((void *)ldv_100_ldv_param_3_5);
    
#line 11972 
    goto ldv_call_100;
    case 3: 
#line 11975 
    ;
    
#line 11977 
    if (ldv_100_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 11979 
      (*(ldv_100_container->release))(ldv_100_resource_0,ldv_100_resource_1); else ;
    
#line 11987 
    goto ldv_main_100;
    default: 
#line 11990 
    ;
    
#line 11990 
    __VERIFIER_assume(0);
  }
  
#line 11993 
  __retres = (void *)0;
  return_label: 
#line 11993 
                return __retres;
}


#line 11998  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_106(void *arg0)
{
  void *__retres;
  struct file *ldv_106_resource_1;
  int ldv_106_ldv_param_2_3;
  long long ldv_106_ldv_param_1_2;
  char *ldv_106_ldv_param_1_4;
  struct inode *ldv_106_resource_0;
  unsigned long ldv_106_size_cnt;
  long long *ldv_106_ldv_param_3_5;
  char *ldv_106_ldv_param_1_6;
  long long *ldv_106_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 12009 
  struct file_operations *ldv_106_container = ldv_emg_alias_rx_rx_wa_density_dropped_frame_ops_2;
  
#line 12010 
  int ldv_106_ret = ldv_undef_int();
  
#line 12013 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 12017 
  ldv_106_ret = ldv_undef_int();
  
#line 12020 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 12021 
    ldv_106_container = data->arg0;
    
#line 12022 
    ldv_free((void *)data);
  }
  else ;
  
#line 12027 
  ldv_106_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 12028 
  tmp_1 = ldv_undef_int();
  
#line 12028 
  ldv_106_size_cnt = (unsigned long)tmp_1;
  
#line 12035 
  goto ldv_main_106;
  
#line 12037 
  __retres = (void *)0;
  
#line 12037 
  goto return_label;
  ldv_main_106: 
#line 12040 
  ;
  
#line 12043 
  tmp_3 = ldv_undef_int();
  
#line 12043 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 12046 
    ldv_106_ret = (*ldv_emg_alias_simple_open_5)(ldv_106_resource_0,ldv_106_resource_1);
    
#line 12048 
    ldv_106_ret = ldv_filter_err_code(ldv_106_ret);
    
#line 12051 
    tmp_2 = ldv_undef_int();
    
#line 12051 
    if (tmp_2 != 0) {
      
#line 12053 
      __VERIFIER_assume(ldv_106_ret == 0);
      
#line 12060 
      goto ldv_call_106;
    }
    else {
      
#line 12064 
      __VERIFIER_assume(ldv_106_ret != 0);
      
#line 12071 
      goto ldv_main_106;
    }
  }
  else {
    
#line 12076 
    ldv_free((void *)ldv_106_resource_0);
    
#line 12084 
    __retres = (void *)0;
    
#line 12084 
    goto return_label;
  }
  
#line 12087 
  __retres = (void *)0;
  
#line 12087 
  goto return_label;
  ldv_call_106: 
#line 12090 
  ;
  
#line 12093 
  tmp_4 = ldv_undef_int();
  
#line 12093 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 12094 
    ;
    
#line 12096 
    ldv_106_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 12097 
    ldv_106_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 12101 
    if (ldv_106_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 12107 
      __VERIFIER_assume(ldv_106_size_cnt <= 2147479552UL);
      
#line 12109 
      (*(ldv_106_container->write))(ldv_106_resource_1,(char const *)ldv_106_ldv_param_1_6,ldv_106_size_cnt,ldv_106_ldv_param_3_7);
    }
    else ;
    
#line 12114 
    ldv_free((void *)ldv_106_ldv_param_3_7);
    
#line 12115 
    ldv_free((void *)ldv_106_ldv_param_1_6);
    
#line 12122 
    goto ldv_call_106;
    case 2: 
#line 12125 
    ;
    
#line 12127 
    if (ldv_106_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 12129 
      (*(ldv_106_container->release))(ldv_106_resource_0,ldv_106_resource_1); else ;
    
#line 12137 
    goto ldv_main_106;
    case 3: 
#line 12140 
    ;
    
#line 12144 
    tmp_9 = ldv_undef_int();
    
#line 12144 
    if (tmp_9 != 0) 
#line 12147 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_106_resource_1,ldv_106_ldv_param_1_2,ldv_106_ldv_param_2_3);
    else {
      
#line 12153 
      ldv_106_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 12154 
      ldv_106_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 12159 
      ldv_emg_wrapper_rx_rx_wa_density_dropped_frame_read_3(ldv_106_resource_1,ldv_106_ldv_param_1_4,ldv_106_size_cnt,ldv_106_ldv_param_3_5);
      
#line 12163 
      ldv_free((void *)ldv_106_ldv_param_3_5);
      
#line 12164 
      ldv_free((void *)ldv_106_ldv_param_1_4);
    }
    
#line 12168 
    goto ldv_32109;
    default: 
#line 12170 
    ;
    
#line 12170 
    __VERIFIER_assume(0);
  }
  ldv_32109: 
#line 12179 
  ;
  
#line 12179 
  goto ldv_call_106;
  
#line 12181 
  __retres = (void *)0;
  return_label: 
#line 12181 
                return __retres;
}


#line 12186  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_24(void *arg0)
{
  void *__retres;
  struct file *ldv_24_resource_1;
  int ldv_24_ldv_param_2_3;
  long long ldv_24_ldv_param_1_2;
  char *ldv_24_ldv_param_1_4;
  struct inode *ldv_24_resource_0;
  unsigned long ldv_24_size_cnt;
  long long *ldv_24_ldv_param_3_5;
  char *ldv_24_ldv_param_1_6;
  long long *ldv_24_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 12197 
  struct file_operations *ldv_24_container = ldv_emg_alias_pipeline_post_proc_swi_ops_2;
  
#line 12198 
  int ldv_24_ret = ldv_undef_int();
  
#line 12201 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 12205 
  ldv_24_ret = ldv_undef_int();
  
#line 12208 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 12209 
    ldv_24_container = data->arg0;
    
#line 12210 
    ldv_free((void *)data);
  }
  else ;
  
#line 12215 
  ldv_24_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 12216 
  tmp_1 = ldv_undef_int();
  
#line 12216 
  ldv_24_size_cnt = (unsigned long)tmp_1;
  
#line 12223 
  goto ldv_main_24;
  
#line 12225 
  __retres = (void *)0;
  
#line 12225 
  goto return_label;
  ldv_main_24: 
#line 12228 
  ;
  
#line 12231 
  tmp_3 = ldv_undef_int();
  
#line 12231 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 12234 
    ldv_24_ret = (*ldv_emg_alias_simple_open_5)(ldv_24_resource_0,ldv_24_resource_1);
    
#line 12236 
    ldv_24_ret = ldv_filter_err_code(ldv_24_ret);
    
#line 12239 
    tmp_2 = ldv_undef_int();
    
#line 12239 
    if (tmp_2 != 0) {
      
#line 12241 
      __VERIFIER_assume(ldv_24_ret == 0);
      
#line 12248 
      goto ldv_call_24;
    }
    else {
      
#line 12252 
      __VERIFIER_assume(ldv_24_ret != 0);
      
#line 12259 
      goto ldv_main_24;
    }
  }
  else {
    
#line 12264 
    ldv_free((void *)ldv_24_resource_0);
    
#line 12272 
    __retres = (void *)0;
    
#line 12272 
    goto return_label;
  }
  
#line 12275 
  __retres = (void *)0;
  
#line 12275 
  goto return_label;
  ldv_call_24: 
#line 12278 
  ;
  
#line 12281 
  tmp_4 = ldv_undef_int();
  
#line 12281 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 12282 
    ;
    
#line 12284 
    ldv_24_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 12285 
    ldv_24_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 12289 
    if (ldv_24_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 12295 
      __VERIFIER_assume(ldv_24_size_cnt <= 2147479552UL);
      
#line 12297 
      (*(ldv_24_container->write))(ldv_24_resource_1,(char const *)ldv_24_ldv_param_1_6,ldv_24_size_cnt,ldv_24_ldv_param_3_7);
    }
    else ;
    
#line 12302 
    ldv_free((void *)ldv_24_ldv_param_3_7);
    
#line 12303 
    ldv_free((void *)ldv_24_ldv_param_1_6);
    
#line 12310 
    goto ldv_call_24;
    case 2: 
#line 12313 
    ;
    
#line 12315 
    if (ldv_24_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 12317 
      (*(ldv_24_container->release))(ldv_24_resource_0,ldv_24_resource_1); else ;
    
#line 12325 
    goto ldv_main_24;
    case 3: 
#line 12328 
    ;
    
#line 12332 
    tmp_9 = ldv_undef_int();
    
#line 12332 
    if (tmp_9 != 0) 
#line 12335 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_24_resource_1,ldv_24_ldv_param_1_2,ldv_24_ldv_param_2_3);
    else {
      
#line 12341 
      ldv_24_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 12342 
      ldv_24_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 12347 
      ldv_emg_wrapper_pipeline_post_proc_swi_read_3(ldv_24_resource_1,ldv_24_ldv_param_1_4,ldv_24_size_cnt,ldv_24_ldv_param_3_5);
      
#line 12351 
      ldv_free((void *)ldv_24_ldv_param_1_4);
      
#line 12352 
      ldv_free((void *)ldv_24_ldv_param_3_5);
    }
    
#line 12356 
    goto ldv_32131;
    default: 
#line 12358 
    ;
    
#line 12358 
    __VERIFIER_assume(0);
  }
  ldv_32131: 
#line 12367 
  ;
  
#line 12367 
  goto ldv_call_24;
  
#line 12369 
  __retres = (void *)0;
  return_label: 
#line 12369 
                return __retres;
}


#line 12374  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_8(void *arg0)
{
  void *__retres;
  struct file *ldv_8_resource_1;
  int ldv_8_ldv_param_2_3;
  long long ldv_8_ldv_param_1_2;
  char *ldv_8_ldv_param_1_4;
  struct inode *ldv_8_resource_0;
  unsigned long ldv_8_size_cnt;
  long long *ldv_8_ldv_param_3_5;
  char *ldv_8_ldv_param_1_6;
  long long *ldv_8_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 12385 
  struct file_operations *ldv_8_container = ldv_emg_alias_rx_defrag_decrypt_failed_ops_2;
  
#line 12386 
  int ldv_8_ret = ldv_undef_int();
  
#line 12389 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 12393 
  ldv_8_ret = ldv_undef_int();
  
#line 12396 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 12397 
    ldv_8_container = data->arg0;
    
#line 12398 
    ldv_free((void *)data);
  }
  else ;
  
#line 12403 
  ldv_8_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 12404 
  tmp_1 = ldv_undef_int();
  
#line 12404 
  ldv_8_size_cnt = (unsigned long)tmp_1;
  
#line 12411 
  goto ldv_main_8;
  
#line 12413 
  __retres = (void *)0;
  
#line 12413 
  goto return_label;
  ldv_main_8: 
#line 12416 
  ;
  
#line 12419 
  tmp_3 = ldv_undef_int();
  
#line 12419 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 12422 
    ldv_8_ret = (*ldv_emg_alias_simple_open_5)(ldv_8_resource_0,ldv_8_resource_1);
    
#line 12424 
    ldv_8_ret = ldv_filter_err_code(ldv_8_ret);
    
#line 12427 
    tmp_2 = ldv_undef_int();
    
#line 12427 
    if (tmp_2 != 0) {
      
#line 12429 
      __VERIFIER_assume(ldv_8_ret == 0);
      
#line 12436 
      goto ldv_call_8;
    }
    else {
      
#line 12440 
      __VERIFIER_assume(ldv_8_ret != 0);
      
#line 12447 
      goto ldv_main_8;
    }
  }
  else {
    
#line 12452 
    ldv_free((void *)ldv_8_resource_0);
    
#line 12460 
    __retres = (void *)0;
    
#line 12460 
    goto return_label;
  }
  
#line 12463 
  __retres = (void *)0;
  
#line 12463 
  goto return_label;
  ldv_call_8: 
#line 12466 
  ;
  
#line 12469 
  tmp_4 = ldv_undef_int();
  
#line 12469 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 12470 
    ;
    
#line 12472 
    ldv_8_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 12473 
    ldv_8_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 12477 
    if (ldv_8_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 12483 
      __VERIFIER_assume(ldv_8_size_cnt <= 2147479552UL);
      
#line 12485 
      (*(ldv_8_container->write))(ldv_8_resource_1,(char const *)ldv_8_ldv_param_1_6,ldv_8_size_cnt,ldv_8_ldv_param_3_7);
    }
    else ;
    
#line 12490 
    ldv_free((void *)ldv_8_ldv_param_3_7);
    
#line 12491 
    ldv_free((void *)ldv_8_ldv_param_1_6);
    
#line 12498 
    goto ldv_call_8;
    case 2: 
#line 12501 
    ;
    
#line 12503 
    if (ldv_8_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 12505 
      (*(ldv_8_container->release))(ldv_8_resource_0,ldv_8_resource_1); else ;
    
#line 12513 
    goto ldv_main_8;
    case 3: 
#line 12516 
    ;
    
#line 12520 
    tmp_9 = ldv_undef_int();
    
#line 12520 
    if (tmp_9 != 0) 
#line 12523 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_8_resource_1,ldv_8_ldv_param_1_2,ldv_8_ldv_param_2_3);
    else {
      
#line 12529 
      ldv_8_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 12530 
      ldv_8_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 12535 
      ldv_emg_wrapper_rx_defrag_decrypt_failed_read_3(ldv_8_resource_1,ldv_8_ldv_param_1_4,ldv_8_size_cnt,ldv_8_ldv_param_3_5);
      
#line 12539 
      ldv_free((void *)ldv_8_ldv_param_3_5);
      
#line 12540 
      ldv_free((void *)ldv_8_ldv_param_1_4);
    }
    
#line 12544 
    goto ldv_32153;
    default: 
#line 12546 
    ;
    
#line 12546 
    __VERIFIER_assume(0);
  }
  ldv_32153: 
#line 12555 
  ;
  
#line 12555 
  goto ldv_call_8;
  
#line 12557 
  __retres = (void *)0;
  return_label: 
#line 12557 
                return __retres;
}


#line 12562  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_59(void *arg0)
{
  void *__retres;
  struct file *ldv_59_resource_1;
  int ldv_59_ldv_param_2_3;
  long long ldv_59_ldv_param_1_2;
  char *ldv_59_ldv_param_1_4;
  struct inode *ldv_59_resource_0;
  unsigned long ldv_59_size_cnt;
  long long *ldv_59_ldv_param_3_5;
  char *ldv_59_ldv_param_1_6;
  long long *ldv_59_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 12573 
  struct file_operations *ldv_59_container = ldv_emg_alias_tx_tx_start_data_ops_2;
  
#line 12574 
  int ldv_59_ret = ldv_undef_int();
  
#line 12577 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 12581 
  ldv_59_ret = ldv_undef_int();
  
#line 12584 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 12585 
    ldv_59_container = data->arg0;
    
#line 12586 
    ldv_free((void *)data);
  }
  else ;
  
#line 12591 
  ldv_59_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 12592 
  tmp_1 = ldv_undef_int();
  
#line 12592 
  ldv_59_size_cnt = (unsigned long)tmp_1;
  
#line 12599 
  goto ldv_main_59;
  
#line 12601 
  __retres = (void *)0;
  
#line 12601 
  goto return_label;
  ldv_main_59: 
#line 12604 
  ;
  
#line 12607 
  tmp_3 = ldv_undef_int();
  
#line 12607 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 12610 
    ldv_59_ret = (*ldv_emg_alias_simple_open_5)(ldv_59_resource_0,ldv_59_resource_1);
    
#line 12612 
    ldv_59_ret = ldv_filter_err_code(ldv_59_ret);
    
#line 12615 
    tmp_2 = ldv_undef_int();
    
#line 12615 
    if (tmp_2 != 0) {
      
#line 12617 
      __VERIFIER_assume(ldv_59_ret == 0);
      
#line 12624 
      goto ldv_call_59;
    }
    else {
      
#line 12628 
      __VERIFIER_assume(ldv_59_ret != 0);
      
#line 12635 
      goto ldv_main_59;
    }
  }
  else {
    
#line 12640 
    ldv_free((void *)ldv_59_resource_0);
    
#line 12648 
    __retres = (void *)0;
    
#line 12648 
    goto return_label;
  }
  
#line 12651 
  __retres = (void *)0;
  
#line 12651 
  goto return_label;
  ldv_call_59: 
#line 12654 
  ;
  
#line 12657 
  tmp_4 = ldv_undef_int();
  
#line 12657 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 12658 
    ;
    
#line 12660 
    ldv_59_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 12661 
    ldv_59_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 12665 
    if (ldv_59_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 12671 
      __VERIFIER_assume(ldv_59_size_cnt <= 2147479552UL);
      
#line 12673 
      (*(ldv_59_container->write))(ldv_59_resource_1,(char const *)ldv_59_ldv_param_1_6,ldv_59_size_cnt,ldv_59_ldv_param_3_7);
    }
    else ;
    
#line 12678 
    ldv_free((void *)ldv_59_ldv_param_3_7);
    
#line 12679 
    ldv_free((void *)ldv_59_ldv_param_1_6);
    
#line 12686 
    goto ldv_call_59;
    case 2: 
#line 12689 
    ;
    
#line 12691 
    if (ldv_59_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 12693 
      (*(ldv_59_container->release))(ldv_59_resource_0,ldv_59_resource_1); else ;
    
#line 12701 
    goto ldv_main_59;
    case 3: 
#line 12704 
    ;
    
#line 12708 
    tmp_9 = ldv_undef_int();
    
#line 12708 
    if (tmp_9 != 0) 
#line 12711 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_59_resource_1,ldv_59_ldv_param_1_2,ldv_59_ldv_param_2_3);
    else {
      
#line 12717 
      ldv_59_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 12718 
      ldv_59_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 12723 
      ldv_emg_wrapper_tx_tx_start_data_read_3(ldv_59_resource_1,ldv_59_ldv_param_1_4,ldv_59_size_cnt,ldv_59_ldv_param_3_5);
      
#line 12727 
      ldv_free((void *)ldv_59_ldv_param_1_4);
      
#line 12728 
      ldv_free((void *)ldv_59_ldv_param_3_5);
    }
    
#line 12732 
    goto ldv_32175;
    default: 
#line 12734 
    ;
    
#line 12734 
    __VERIFIER_assume(0);
  }
  ldv_32175: 
#line 12743 
  ;
  
#line 12743 
  goto ldv_call_59;
  
#line 12745 
  __retres = (void *)0;
  return_label: 
#line 12745 
                return __retres;
}


#line 12750  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_31(void *arg0)
{
  void *__retres;
  struct file *ldv_31_resource_1;
  int ldv_31_ldv_param_2_3;
  long long ldv_31_ldv_param_1_2;
  char *ldv_31_ldv_param_1_4;
  struct inode *ldv_31_resource_0;
  unsigned long ldv_31_size_cnt;
  long long *ldv_31_ldv_param_3_5;
  char *ldv_31_ldv_param_1_6;
  long long *ldv_31_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 12761 
  struct file_operations *ldv_31_container = ldv_emg_alias_rx_defrag_init_called_ops_2;
  
#line 12762 
  int ldv_31_ret = ldv_undef_int();
  
#line 12765 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 12769 
  ldv_31_ret = ldv_undef_int();
  
#line 12772 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 12773 
    ldv_31_container = data->arg0;
    
#line 12774 
    ldv_free((void *)data);
  }
  else ;
  
#line 12779 
  ldv_31_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 12780 
  tmp_1 = ldv_undef_int();
  
#line 12780 
  ldv_31_size_cnt = (unsigned long)tmp_1;
  
#line 12787 
  goto ldv_main_31;
  
#line 12789 
  __retres = (void *)0;
  
#line 12789 
  goto return_label;
  ldv_main_31: 
#line 12792 
  ;
  
#line 12795 
  tmp_3 = ldv_undef_int();
  
#line 12795 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 12798 
    ldv_31_ret = (*ldv_emg_alias_simple_open_5)(ldv_31_resource_0,ldv_31_resource_1);
    
#line 12800 
    ldv_31_ret = ldv_filter_err_code(ldv_31_ret);
    
#line 12803 
    tmp_2 = ldv_undef_int();
    
#line 12803 
    if (tmp_2 != 0) {
      
#line 12805 
      __VERIFIER_assume(ldv_31_ret == 0);
      
#line 12812 
      goto ldv_call_31;
    }
    else {
      
#line 12816 
      __VERIFIER_assume(ldv_31_ret != 0);
      
#line 12823 
      goto ldv_main_31;
    }
  }
  else {
    
#line 12828 
    ldv_free((void *)ldv_31_resource_0);
    
#line 12836 
    __retres = (void *)0;
    
#line 12836 
    goto return_label;
  }
  
#line 12839 
  __retres = (void *)0;
  
#line 12839 
  goto return_label;
  ldv_call_31: 
#line 12842 
  ;
  
#line 12845 
  tmp_4 = ldv_undef_int();
  
#line 12845 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 12846 
    ;
    
#line 12848 
    ldv_31_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 12849 
    ldv_31_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 12853 
    if (ldv_31_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 12859 
      __VERIFIER_assume(ldv_31_size_cnt <= 2147479552UL);
      
#line 12861 
      (*(ldv_31_container->write))(ldv_31_resource_1,(char const *)ldv_31_ldv_param_1_6,ldv_31_size_cnt,ldv_31_ldv_param_3_7);
    }
    else ;
    
#line 12866 
    ldv_free((void *)ldv_31_ldv_param_3_7);
    
#line 12867 
    ldv_free((void *)ldv_31_ldv_param_1_6);
    
#line 12874 
    goto ldv_call_31;
    case 2: 
#line 12877 
    ;
    
#line 12879 
    if (ldv_31_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 12881 
      (*(ldv_31_container->release))(ldv_31_resource_0,ldv_31_resource_1); else ;
    
#line 12889 
    goto ldv_main_31;
    case 3: 
#line 12892 
    ;
    
#line 12896 
    tmp_9 = ldv_undef_int();
    
#line 12896 
    if (tmp_9 != 0) 
#line 12899 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_31_resource_1,ldv_31_ldv_param_1_2,ldv_31_ldv_param_2_3);
    else {
      
#line 12905 
      ldv_31_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 12906 
      ldv_31_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 12911 
      ldv_emg_wrapper_rx_defrag_init_called_read_3(ldv_31_resource_1,ldv_31_ldv_param_1_4,ldv_31_size_cnt,ldv_31_ldv_param_3_5);
      
#line 12915 
      ldv_free((void *)ldv_31_ldv_param_1_4);
      
#line 12916 
      ldv_free((void *)ldv_31_ldv_param_3_5);
    }
    
#line 12920 
    goto ldv_32197;
    default: 
#line 12922 
    ;
    
#line 12922 
    __VERIFIER_assume(0);
  }
  ldv_32197: 
#line 12931 
  ;
  
#line 12931 
  goto ldv_call_31;
  
#line 12933 
  __retres = (void *)0;
  return_label: 
#line 12933 
                return __retres;
}


#line 12938  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_118(void *arg0)
{
  void *__retres;
  struct file *ldv_118_resource_1;
  int ldv_118_ldv_param_2_3;
  long long ldv_118_ldv_param_1_2;
  char *ldv_118_ldv_param_1_4;
  struct inode *ldv_118_resource_0;
  unsigned long ldv_118_size_cnt;
  long long *ldv_118_ldv_param_3_5;
  char *ldv_118_ldv_param_1_6;
  long long *ldv_118_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 12949 
  struct file_operations *ldv_118_container = ldv_emg_alias_ps_poll_ps_poll_utilization_ops_2;
  
#line 12950 
  int ldv_118_ret = ldv_undef_int();
  
#line 12953 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 12957 
  ldv_118_ret = ldv_undef_int();
  
#line 12960 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 12961 
    ldv_118_container = data->arg0;
    
#line 12962 
    ldv_free((void *)data);
  }
  else ;
  
#line 12967 
  ldv_118_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 12968 
  tmp_1 = ldv_undef_int();
  
#line 12968 
  ldv_118_size_cnt = (unsigned long)tmp_1;
  
#line 12975 
  goto ldv_main_118;
  
#line 12977 
  __retres = (void *)0;
  
#line 12977 
  goto return_label;
  ldv_main_118: 
#line 12980 
  ;
  
#line 12983 
  tmp_3 = ldv_undef_int();
  
#line 12983 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 12986 
    ldv_118_ret = (*ldv_emg_alias_simple_open_5)(ldv_118_resource_0,ldv_118_resource_1);
    
#line 12988 
    ldv_118_ret = ldv_filter_err_code(ldv_118_ret);
    
#line 12991 
    tmp_2 = ldv_undef_int();
    
#line 12991 
    if (tmp_2 != 0) {
      
#line 12993 
      __VERIFIER_assume(ldv_118_ret == 0);
      
#line 13000 
      goto ldv_call_118;
    }
    else {
      
#line 13004 
      __VERIFIER_assume(ldv_118_ret != 0);
      
#line 13011 
      goto ldv_main_118;
    }
  }
  else {
    
#line 13016 
    ldv_free((void *)ldv_118_resource_0);
    
#line 13024 
    __retres = (void *)0;
    
#line 13024 
    goto return_label;
  }
  
#line 13027 
  __retres = (void *)0;
  
#line 13027 
  goto return_label;
  ldv_call_118: 
#line 13030 
  ;
  
#line 13033 
  tmp_4 = ldv_undef_int();
  
#line 13033 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 13034 
    ;
    
#line 13036 
    ldv_118_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 13037 
    ldv_118_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 13041 
    if (ldv_118_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 13047 
      __VERIFIER_assume(ldv_118_size_cnt <= 2147479552UL);
      
#line 13049 
      (*(ldv_118_container->write))(ldv_118_resource_1,(char const *)ldv_118_ldv_param_1_6,ldv_118_size_cnt,ldv_118_ldv_param_3_7);
    }
    else ;
    
#line 13054 
    ldv_free((void *)ldv_118_ldv_param_3_7);
    
#line 13055 
    ldv_free((void *)ldv_118_ldv_param_1_6);
    
#line 13062 
    goto ldv_call_118;
    case 2: 
#line 13065 
    ;
    
#line 13067 
    if (ldv_118_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 13069 
      (*(ldv_118_container->release))(ldv_118_resource_0,ldv_118_resource_1); else ;
    
#line 13077 
    goto ldv_main_118;
    case 3: 
#line 13080 
    ;
    
#line 13084 
    tmp_9 = ldv_undef_int();
    
#line 13084 
    if (tmp_9 != 0) 
#line 13087 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_118_resource_1,ldv_118_ldv_param_1_2,ldv_118_ldv_param_2_3);
    else {
      
#line 13093 
      ldv_118_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 13094 
      ldv_118_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 13099 
      ldv_emg_wrapper_ps_poll_ps_poll_utilization_read_3(ldv_118_resource_1,ldv_118_ldv_param_1_4,ldv_118_size_cnt,ldv_118_ldv_param_3_5);
      
#line 13103 
      ldv_free((void *)ldv_118_ldv_param_3_5);
      
#line 13104 
      ldv_free((void *)ldv_118_ldv_param_1_4);
    }
    
#line 13108 
    goto ldv_32219;
    default: 
#line 13110 
    ;
    
#line 13110 
    __VERIFIER_assume(0);
  }
  ldv_32219: 
#line 13119 
  ;
  
#line 13119 
  goto ldv_call_118;
  
#line 13121 
  __retres = (void *)0;
  return_label: 
#line 13121 
                return __retres;
}


#line 13126  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_52(void *arg0)
{
  void *__retres;
  struct file *ldv_52_resource_1;
  int ldv_52_ldv_param_2_3;
  long long ldv_52_ldv_param_1_2;
  char *ldv_52_ldv_param_1_4;
  struct inode *ldv_52_resource_0;
  unsigned long ldv_52_size_cnt;
  long long *ldv_52_ldv_param_3_5;
  char *ldv_52_ldv_param_1_6;
  long long *ldv_52_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 13137 
  struct file_operations *ldv_52_container = ldv_emg_alias_tx_tx_start_templates_ops_2;
  
#line 13138 
  int ldv_52_ret = ldv_undef_int();
  
#line 13141 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 13145 
  ldv_52_ret = ldv_undef_int();
  
#line 13148 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 13149 
    ldv_52_container = data->arg0;
    
#line 13150 
    ldv_free((void *)data);
  }
  else ;
  
#line 13155 
  ldv_52_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 13156 
  tmp_1 = ldv_undef_int();
  
#line 13156 
  ldv_52_size_cnt = (unsigned long)tmp_1;
  
#line 13163 
  goto ldv_main_52;
  
#line 13165 
  __retres = (void *)0;
  
#line 13165 
  goto return_label;
  ldv_main_52: 
#line 13168 
  ;
  
#line 13171 
  tmp_3 = ldv_undef_int();
  
#line 13171 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 13174 
    ldv_52_ret = (*ldv_emg_alias_simple_open_5)(ldv_52_resource_0,ldv_52_resource_1);
    
#line 13176 
    ldv_52_ret = ldv_filter_err_code(ldv_52_ret);
    
#line 13179 
    tmp_2 = ldv_undef_int();
    
#line 13179 
    if (tmp_2 != 0) {
      
#line 13181 
      __VERIFIER_assume(ldv_52_ret == 0);
      
#line 13188 
      goto ldv_call_52;
    }
    else {
      
#line 13192 
      __VERIFIER_assume(ldv_52_ret != 0);
      
#line 13199 
      goto ldv_main_52;
    }
  }
  else {
    
#line 13204 
    ldv_free((void *)ldv_52_resource_0);
    
#line 13212 
    __retres = (void *)0;
    
#line 13212 
    goto return_label;
  }
  
#line 13215 
  __retres = (void *)0;
  
#line 13215 
  goto return_label;
  ldv_call_52: 
#line 13218 
  ;
  
#line 13221 
  tmp_4 = ldv_undef_int();
  
#line 13221 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 13222 
    ;
    
#line 13224 
    ldv_52_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 13225 
    ldv_52_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 13229 
    if (ldv_52_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 13235 
      __VERIFIER_assume(ldv_52_size_cnt <= 2147479552UL);
      
#line 13237 
      (*(ldv_52_container->write))(ldv_52_resource_1,(char const *)ldv_52_ldv_param_1_6,ldv_52_size_cnt,ldv_52_ldv_param_3_7);
    }
    else ;
    
#line 13242 
    ldv_free((void *)ldv_52_ldv_param_1_6);
    
#line 13243 
    ldv_free((void *)ldv_52_ldv_param_3_7);
    
#line 13250 
    goto ldv_call_52;
    case 2: 
#line 13253 
    ;
    
#line 13255 
    if (ldv_52_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 13257 
      (*(ldv_52_container->release))(ldv_52_resource_0,ldv_52_resource_1); else ;
    
#line 13265 
    goto ldv_main_52;
    case 3: 
#line 13268 
    ;
    
#line 13272 
    tmp_9 = ldv_undef_int();
    
#line 13272 
    if (tmp_9 != 0) 
#line 13275 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_52_resource_1,ldv_52_ldv_param_1_2,ldv_52_ldv_param_2_3);
    else {
      
#line 13281 
      ldv_52_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 13282 
      ldv_52_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 13287 
      ldv_emg_wrapper_tx_tx_start_templates_read_3(ldv_52_resource_1,ldv_52_ldv_param_1_4,ldv_52_size_cnt,ldv_52_ldv_param_3_5);
      
#line 13291 
      ldv_free((void *)ldv_52_ldv_param_3_5);
      
#line 13292 
      ldv_free((void *)ldv_52_ldv_param_1_4);
    }
    
#line 13296 
    goto ldv_32241;
    default: 
#line 13298 
    ;
    
#line 13298 
    __VERIFIER_assume(0);
  }
  ldv_32241: 
#line 13307 
  ;
  
#line 13307 
  goto ldv_call_52;
  
#line 13309 
  __retres = (void *)0;
  return_label: 
#line 13309 
                return __retres;
}


#line 13314  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_96(void *arg0)
{
  void *__retres;
  struct file *ldv_96_resource_1;
  int ldv_96_ldv_param_2_3;
  long long ldv_96_ldv_param_1_2;
  char *ldv_96_ldv_param_1_4;
  struct inode *ldv_96_resource_0;
  unsigned long ldv_96_size_cnt;
  long long *ldv_96_ldv_param_3_5;
  char *ldv_96_ldv_param_1_6;
  long long *ldv_96_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 13325 
  struct file_operations *ldv_96_container = ldv_emg_alias_pipeline_csum_to_rx_xfer_swi_ops_2;
  
#line 13326 
  int ldv_96_ret = ldv_undef_int();
  
#line 13329 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 13333 
  ldv_96_ret = ldv_undef_int();
  
#line 13336 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 13337 
    ldv_96_container = data->arg0;
    
#line 13338 
    ldv_free((void *)data);
  }
  else ;
  
#line 13343 
  ldv_96_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 13344 
  tmp_1 = ldv_undef_int();
  
#line 13344 
  ldv_96_size_cnt = (unsigned long)tmp_1;
  
#line 13351 
  goto ldv_main_96;
  
#line 13353 
  __retres = (void *)0;
  
#line 13353 
  goto return_label;
  ldv_main_96: 
#line 13356 
  ;
  
#line 13359 
  tmp_3 = ldv_undef_int();
  
#line 13359 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 13362 
    ldv_96_ret = (*ldv_emg_alias_simple_open_5)(ldv_96_resource_0,ldv_96_resource_1);
    
#line 13364 
    ldv_96_ret = ldv_filter_err_code(ldv_96_ret);
    
#line 13367 
    tmp_2 = ldv_undef_int();
    
#line 13367 
    if (tmp_2 != 0) {
      
#line 13369 
      __VERIFIER_assume(ldv_96_ret == 0);
      
#line 13376 
      goto ldv_call_96;
    }
    else {
      
#line 13380 
      __VERIFIER_assume(ldv_96_ret != 0);
      
#line 13387 
      goto ldv_main_96;
    }
  }
  else {
    
#line 13392 
    ldv_free((void *)ldv_96_resource_0);
    
#line 13400 
    __retres = (void *)0;
    
#line 13400 
    goto return_label;
  }
  
#line 13403 
  __retres = (void *)0;
  
#line 13403 
  goto return_label;
  ldv_call_96: 
#line 13406 
  ;
  
#line 13409 
  tmp_4 = ldv_undef_int();
  
#line 13409 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 13410 
    ;
    
#line 13412 
    ldv_96_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 13413 
    ldv_96_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 13417 
    if (ldv_96_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 13423 
      __VERIFIER_assume(ldv_96_size_cnt <= 2147479552UL);
      
#line 13425 
      (*(ldv_96_container->write))(ldv_96_resource_1,(char const *)ldv_96_ldv_param_1_6,ldv_96_size_cnt,ldv_96_ldv_param_3_7);
    }
    else ;
    
#line 13430 
    ldv_free((void *)ldv_96_ldv_param_3_7);
    
#line 13431 
    ldv_free((void *)ldv_96_ldv_param_1_6);
    
#line 13438 
    goto ldv_call_96;
    case 2: 
#line 13441 
    ;
    
#line 13443 
    if (ldv_96_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 13445 
      (*(ldv_96_container->release))(ldv_96_resource_0,ldv_96_resource_1); else ;
    
#line 13453 
    goto ldv_main_96;
    case 3: 
#line 13456 
    ;
    
#line 13460 
    tmp_9 = ldv_undef_int();
    
#line 13460 
    if (tmp_9 != 0) 
#line 13463 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_96_resource_1,ldv_96_ldv_param_1_2,ldv_96_ldv_param_2_3);
    else {
      
#line 13469 
      ldv_96_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 13470 
      ldv_96_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 13475 
      ldv_emg_wrapper_pipeline_csum_to_rx_xfer_swi_read_3(ldv_96_resource_1,ldv_96_ldv_param_1_4,ldv_96_size_cnt,ldv_96_ldv_param_3_5);
      
#line 13479 
      ldv_free((void *)ldv_96_ldv_param_1_4);
      
#line 13480 
      ldv_free((void *)ldv_96_ldv_param_3_5);
    }
    
#line 13484 
    goto ldv_32263;
    default: 
#line 13486 
    ;
    
#line 13486 
    __VERIFIER_assume(0);
  }
  ldv_32263: 
#line 13495 
  ;
  
#line 13495 
  goto ldv_call_96;
  
#line 13497 
  __retres = (void *)0;
  return_label: 
#line 13497 
                return __retres;
}


#line 13502  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_119(void *arg0)
{
  void *__retres;
  struct file *ldv_119_resource_1;
  int ldv_119_ldv_param_2_3;
  long long ldv_119_ldv_param_1_2;
  char *ldv_119_ldv_param_1_4;
  struct inode *ldv_119_resource_0;
  unsigned long ldv_119_size_cnt;
  long long *ldv_119_ldv_param_3_5;
  char *ldv_119_ldv_param_1_6;
  long long *ldv_119_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 13513 
  struct file_operations *ldv_119_container = ldv_emg_alias_tx_frag_in_process_called_ops_2;
  
#line 13514 
  int ldv_119_ret = ldv_undef_int();
  
#line 13517 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 13521 
  ldv_119_ret = ldv_undef_int();
  
#line 13524 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 13525 
    ldv_119_container = data->arg0;
    
#line 13526 
    ldv_free((void *)data);
  }
  else ;
  
#line 13531 
  ldv_119_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 13532 
  tmp_1 = ldv_undef_int();
  
#line 13532 
  ldv_119_size_cnt = (unsigned long)tmp_1;
  
#line 13539 
  goto ldv_main_119;
  
#line 13541 
  __retres = (void *)0;
  
#line 13541 
  goto return_label;
  ldv_main_119: 
#line 13544 
  ;
  
#line 13547 
  tmp_3 = ldv_undef_int();
  
#line 13547 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 13550 
    ldv_119_ret = (*ldv_emg_alias_simple_open_5)(ldv_119_resource_0,ldv_119_resource_1);
    
#line 13552 
    ldv_119_ret = ldv_filter_err_code(ldv_119_ret);
    
#line 13555 
    tmp_2 = ldv_undef_int();
    
#line 13555 
    if (tmp_2 != 0) {
      
#line 13557 
      __VERIFIER_assume(ldv_119_ret == 0);
      
#line 13564 
      goto ldv_call_119;
    }
    else {
      
#line 13568 
      __VERIFIER_assume(ldv_119_ret != 0);
      
#line 13575 
      goto ldv_main_119;
    }
  }
  else {
    
#line 13580 
    ldv_free((void *)ldv_119_resource_0);
    
#line 13588 
    __retres = (void *)0;
    
#line 13588 
    goto return_label;
  }
  
#line 13591 
  __retres = (void *)0;
  
#line 13591 
  goto return_label;
  ldv_call_119: 
#line 13594 
  ;
  
#line 13597 
  tmp_4 = ldv_undef_int();
  
#line 13597 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 13598 
    ;
    
#line 13600 
    ldv_119_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 13601 
    ldv_119_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 13605 
    if (ldv_119_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 13611 
      __VERIFIER_assume(ldv_119_size_cnt <= 2147479552UL);
      
#line 13613 
      (*(ldv_119_container->write))(ldv_119_resource_1,(char const *)ldv_119_ldv_param_1_6,ldv_119_size_cnt,ldv_119_ldv_param_3_7);
    }
    else ;
    
#line 13618 
    ldv_free((void *)ldv_119_ldv_param_3_7);
    
#line 13619 
    ldv_free((void *)ldv_119_ldv_param_1_6);
    
#line 13626 
    goto ldv_call_119;
    case 2: 
#line 13629 
    ;
    
#line 13631 
    if (ldv_119_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 13633 
      (*(ldv_119_container->release))(ldv_119_resource_0,ldv_119_resource_1); else ;
    
#line 13641 
    goto ldv_main_119;
    case 3: 
#line 13644 
    ;
    
#line 13648 
    tmp_9 = ldv_undef_int();
    
#line 13648 
    if (tmp_9 != 0) 
#line 13651 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_119_resource_1,ldv_119_ldv_param_1_2,ldv_119_ldv_param_2_3);
    else {
      
#line 13657 
      ldv_119_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 13658 
      ldv_119_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 13663 
      ldv_emg_wrapper_tx_frag_in_process_called_read_3(ldv_119_resource_1,ldv_119_ldv_param_1_4,ldv_119_size_cnt,ldv_119_ldv_param_3_5);
      
#line 13667 
      ldv_free((void *)ldv_119_ldv_param_1_4);
      
#line 13668 
      ldv_free((void *)ldv_119_ldv_param_3_5);
    }
    
#line 13672 
    goto ldv_32285;
    default: 
#line 13674 
    ;
    
#line 13674 
    __VERIFIER_assume(0);
  }
  ldv_32285: 
#line 13683 
  ;
  
#line 13683 
  goto ldv_call_119;
  
#line 13685 
  __retres = (void *)0;
  return_label: 
#line 13685 
                return __retres;
}


#line 13690  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
_Bool ldv_emg_queue_work(struct workqueue_struct *arg0, struct work_struct *arg1)
{
  _Bool __retres;
  struct work_struct *ldv_5_work_struct;
  int tmp;
  
#line 13697 
  tmp = ldv_undef_int();
  
#line 13697 
  if (tmp != 0) {
    
#line 13699 
    ldv_5_work_struct = arg1;
    
#line 13703 
    if (ldv_5_work_struct->func != (void (*)(struct work_struct *))0) 
      
#line 13705 
      (*(ldv_5_work_struct->func))(ldv_5_work_struct); else ;
    
#line 13710 
    __retres = (_Bool)1;
    
#line 13710 
    goto return_label;
  }
  else {
    
#line 13717 
    __retres = (_Bool)0;
    
#line 13717 
    goto return_label;
  }
  return_label: 
#line 13697 
                return __retres;
}


#line 13727  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_46(void *arg0)
{
  void *__retres;
  struct file *ldv_46_resource_1;
  int ldv_46_ldv_param_2_3;
  long long ldv_46_ldv_param_1_2;
  char *ldv_46_ldv_param_1_4;
  struct inode *ldv_46_resource_0;
  unsigned long ldv_46_size_cnt;
  long long *ldv_46_ldv_param_3_5;
  char *ldv_46_ldv_param_1_6;
  long long *ldv_46_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 13738 
  struct file_operations *ldv_46_container = ldv_emg_alias_rx_rx_out_of_mpdu_nodes_ops_2;
  
#line 13739 
  int ldv_46_ret = ldv_undef_int();
  
#line 13742 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 13746 
  ldv_46_ret = ldv_undef_int();
  
#line 13749 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 13750 
    ldv_46_container = data->arg0;
    
#line 13751 
    ldv_free((void *)data);
  }
  else ;
  
#line 13756 
  ldv_46_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 13757 
  tmp_1 = ldv_undef_int();
  
#line 13757 
  ldv_46_size_cnt = (unsigned long)tmp_1;
  
#line 13764 
  goto ldv_main_46;
  
#line 13766 
  __retres = (void *)0;
  
#line 13766 
  goto return_label;
  ldv_main_46: 
#line 13769 
  ;
  
#line 13772 
  tmp_3 = ldv_undef_int();
  
#line 13772 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 13775 
    ldv_46_ret = (*ldv_emg_alias_simple_open_5)(ldv_46_resource_0,ldv_46_resource_1);
    
#line 13777 
    ldv_46_ret = ldv_filter_err_code(ldv_46_ret);
    
#line 13780 
    tmp_2 = ldv_undef_int();
    
#line 13780 
    if (tmp_2 != 0) {
      
#line 13782 
      __VERIFIER_assume(ldv_46_ret == 0);
      
#line 13789 
      goto ldv_call_46;
    }
    else {
      
#line 13793 
      __VERIFIER_assume(ldv_46_ret != 0);
      
#line 13800 
      goto ldv_main_46;
    }
  }
  else {
    
#line 13805 
    ldv_free((void *)ldv_46_resource_0);
    
#line 13813 
    __retres = (void *)0;
    
#line 13813 
    goto return_label;
  }
  
#line 13816 
  __retres = (void *)0;
  
#line 13816 
  goto return_label;
  ldv_call_46: 
#line 13819 
  ;
  
#line 13822 
  tmp_4 = ldv_undef_int();
  
#line 13822 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 13823 
    ;
    
#line 13825 
    ldv_46_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 13826 
    ldv_46_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 13830 
    if (ldv_46_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 13836 
      __VERIFIER_assume(ldv_46_size_cnt <= 2147479552UL);
      
#line 13838 
      (*(ldv_46_container->write))(ldv_46_resource_1,(char const *)ldv_46_ldv_param_1_6,ldv_46_size_cnt,ldv_46_ldv_param_3_7);
    }
    else ;
    
#line 13843 
    ldv_free((void *)ldv_46_ldv_param_1_6);
    
#line 13844 
    ldv_free((void *)ldv_46_ldv_param_3_7);
    
#line 13851 
    goto ldv_call_46;
    case 2: 
#line 13854 
    ;
    
#line 13856 
    if (ldv_46_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 13858 
      (*(ldv_46_container->release))(ldv_46_resource_0,ldv_46_resource_1); else ;
    
#line 13866 
    goto ldv_main_46;
    case 3: 
#line 13869 
    ;
    
#line 13873 
    tmp_9 = ldv_undef_int();
    
#line 13873 
    if (tmp_9 != 0) 
#line 13876 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_46_resource_1,ldv_46_ldv_param_1_2,ldv_46_ldv_param_2_3);
    else {
      
#line 13882 
      ldv_46_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 13883 
      ldv_46_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 13888 
      ldv_emg_wrapper_rx_rx_out_of_mpdu_nodes_read_3(ldv_46_resource_1,ldv_46_ldv_param_1_4,ldv_46_size_cnt,ldv_46_ldv_param_3_5);
      
#line 13892 
      ldv_free((void *)ldv_46_ldv_param_3_5);
      
#line 13893 
      ldv_free((void *)ldv_46_ldv_param_1_4);
    }
    
#line 13897 
    goto ldv_32312;
    default: 
#line 13899 
    ;
    
#line 13899 
    __VERIFIER_assume(0);
  }
  ldv_32312: 
#line 13908 
  ;
  
#line 13908 
  goto ldv_call_46;
  
#line 13910 
  __retres = (void *)0;
  return_label: 
#line 13910 
                return __retres;
}


#line 13915  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_87(void *arg0)
{
  void *__retres;
  struct file *ldv_87_resource_1;
  int ldv_87_ldv_param_2_3;
  long long ldv_87_ldv_param_1_2;
  char *ldv_87_ldv_param_1_4;
  struct inode *ldv_87_resource_0;
  unsigned long ldv_87_size_cnt;
  long long *ldv_87_ldv_param_3_5;
  char *ldv_87_ldv_param_1_6;
  long long *ldv_87_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 13926 
  struct file_operations *ldv_87_container = ldv_emg_alias_tx_tx_exch_expiry_ops_2;
  
#line 13927 
  int ldv_87_ret = ldv_undef_int();
  
#line 13930 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 13934 
  ldv_87_ret = ldv_undef_int();
  
#line 13937 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 13938 
    ldv_87_container = data->arg0;
    
#line 13939 
    ldv_free((void *)data);
  }
  else ;
  
#line 13944 
  ldv_87_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 13945 
  tmp_1 = ldv_undef_int();
  
#line 13945 
  ldv_87_size_cnt = (unsigned long)tmp_1;
  
#line 13952 
  goto ldv_main_87;
  
#line 13954 
  __retres = (void *)0;
  
#line 13954 
  goto return_label;
  ldv_main_87: 
#line 13957 
  ;
  
#line 13960 
  tmp_3 = ldv_undef_int();
  
#line 13960 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 13963 
    ldv_87_ret = (*ldv_emg_alias_simple_open_5)(ldv_87_resource_0,ldv_87_resource_1);
    
#line 13965 
    ldv_87_ret = ldv_filter_err_code(ldv_87_ret);
    
#line 13968 
    tmp_2 = ldv_undef_int();
    
#line 13968 
    if (tmp_2 != 0) {
      
#line 13970 
      __VERIFIER_assume(ldv_87_ret == 0);
      
#line 13977 
      goto ldv_call_87;
    }
    else {
      
#line 13981 
      __VERIFIER_assume(ldv_87_ret != 0);
      
#line 13988 
      goto ldv_main_87;
    }
  }
  else {
    
#line 13993 
    ldv_free((void *)ldv_87_resource_0);
    
#line 14001 
    __retres = (void *)0;
    
#line 14001 
    goto return_label;
  }
  
#line 14004 
  __retres = (void *)0;
  
#line 14004 
  goto return_label;
  ldv_call_87: 
#line 14007 
  ;
  
#line 14010 
  tmp_4 = ldv_undef_int();
  
#line 14010 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 14011 
    ;
    
#line 14013 
    ldv_87_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 14014 
    ldv_87_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 14018 
    if (ldv_87_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 14024 
      __VERIFIER_assume(ldv_87_size_cnt <= 2147479552UL);
      
#line 14026 
      (*(ldv_87_container->write))(ldv_87_resource_1,(char const *)ldv_87_ldv_param_1_6,ldv_87_size_cnt,ldv_87_ldv_param_3_7);
    }
    else ;
    
#line 14031 
    ldv_free((void *)ldv_87_ldv_param_1_6);
    
#line 14032 
    ldv_free((void *)ldv_87_ldv_param_3_7);
    
#line 14039 
    goto ldv_call_87;
    case 2: 
#line 14042 
    ;
    
#line 14044 
    if (ldv_87_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 14046 
      (*(ldv_87_container->release))(ldv_87_resource_0,ldv_87_resource_1); else ;
    
#line 14054 
    goto ldv_main_87;
    case 3: 
#line 14057 
    ;
    
#line 14061 
    tmp_9 = ldv_undef_int();
    
#line 14061 
    if (tmp_9 != 0) 
#line 14064 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_87_resource_1,ldv_87_ldv_param_1_2,ldv_87_ldv_param_2_3);
    else {
      
#line 14070 
      ldv_87_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 14071 
      ldv_87_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 14076 
      ldv_emg_wrapper_tx_tx_exch_expiry_read_3(ldv_87_resource_1,ldv_87_ldv_param_1_4,ldv_87_size_cnt,ldv_87_ldv_param_3_5);
      
#line 14080 
      ldv_free((void *)ldv_87_ldv_param_3_5);
      
#line 14081 
      ldv_free((void *)ldv_87_ldv_param_1_4);
    }
    
#line 14085 
    goto ldv_32334;
    default: 
#line 14087 
    ;
    
#line 14087 
    __VERIFIER_assume(0);
  }
  ldv_32334: 
#line 14096 
  ;
  
#line 14096 
  goto ldv_call_87;
  
#line 14098 
  __retres = (void *)0;
  return_label: 
#line 14098 
                return __retres;
}


#line 14103  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_deregister_3_1(struct platform_driver *arg0)
{
  int ret;
  struct ldv_struct_platform_instance_108 *cf_arg_108;
  int tmp;
  
#line 14106 
  tmp = ldv_undef_int();
  
#line 14106 
  switch (tmp) {
    case 0: 
#line 14107 
    ;
    
#line 14108 
    ret = pthread_join(ldv_thread_108,(void **)0);
    
#line 14109 
    __VERIFIER_assume(ret == 0);
    
#line 14110 
    goto ldv_32342;
    default: 
#line 14112 
    ;
    
#line 14112 
    __VERIFIER_assume(0);
  }
  ldv_32342: 
#line 14113 
  ;
  
#line 14114 
  return;
}


#line 14118  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_128(void *arg0)
{
  void *__retres;
  struct file *ldv_128_resource_1;
  int ldv_128_ldv_param_2_3;
  long long ldv_128_ldv_param_1_2;
  char *ldv_128_ldv_param_1_4;
  struct inode *ldv_128_resource_0;
  unsigned long ldv_128_size_cnt;
  long long *ldv_128_ldv_param_3_5;
  char *ldv_128_ldv_param_1_6;
  long long *ldv_128_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 14129 
  struct file_operations *ldv_128_container = ldv_emg_alias_tx_tx_template_prepared_ops_2;
  
#line 14130 
  int ldv_128_ret = ldv_undef_int();
  
#line 14133 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 14137 
  ldv_128_ret = ldv_undef_int();
  
#line 14140 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 14141 
    ldv_128_container = data->arg0;
    
#line 14142 
    ldv_free((void *)data);
  }
  else ;
  
#line 14147 
  ldv_128_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 14148 
  tmp_1 = ldv_undef_int();
  
#line 14148 
  ldv_128_size_cnt = (unsigned long)tmp_1;
  
#line 14155 
  goto ldv_main_128;
  
#line 14157 
  __retres = (void *)0;
  
#line 14157 
  goto return_label;
  ldv_main_128: 
#line 14160 
  ;
  
#line 14163 
  tmp_3 = ldv_undef_int();
  
#line 14163 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 14166 
    ldv_128_ret = (*ldv_emg_alias_simple_open_5)(ldv_128_resource_0,ldv_128_resource_1);
    
#line 14168 
    ldv_128_ret = ldv_filter_err_code(ldv_128_ret);
    
#line 14171 
    tmp_2 = ldv_undef_int();
    
#line 14171 
    if (tmp_2 != 0) {
      
#line 14173 
      __VERIFIER_assume(ldv_128_ret == 0);
      
#line 14180 
      goto ldv_call_128;
    }
    else {
      
#line 14184 
      __VERIFIER_assume(ldv_128_ret != 0);
      
#line 14191 
      goto ldv_main_128;
    }
  }
  else {
    
#line 14196 
    ldv_free((void *)ldv_128_resource_0);
    
#line 14204 
    __retres = (void *)0;
    
#line 14204 
    goto return_label;
  }
  
#line 14207 
  __retres = (void *)0;
  
#line 14207 
  goto return_label;
  ldv_call_128: 
#line 14210 
  ;
  
#line 14213 
  tmp_4 = ldv_undef_int();
  
#line 14213 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 14214 
    ;
    
#line 14216 
    ldv_128_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 14217 
    ldv_128_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 14221 
    if (ldv_128_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 14227 
      __VERIFIER_assume(ldv_128_size_cnt <= 2147479552UL);
      
#line 14229 
      (*(ldv_128_container->write))(ldv_128_resource_1,(char const *)ldv_128_ldv_param_1_6,ldv_128_size_cnt,ldv_128_ldv_param_3_7);
    }
    else ;
    
#line 14234 
    ldv_free((void *)ldv_128_ldv_param_3_7);
    
#line 14235 
    ldv_free((void *)ldv_128_ldv_param_1_6);
    
#line 14242 
    goto ldv_call_128;
    case 2: 
#line 14245 
    ;
    
#line 14247 
    if (ldv_128_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 14249 
      (*(ldv_128_container->release))(ldv_128_resource_0,ldv_128_resource_1); else ;
    
#line 14257 
    goto ldv_main_128;
    case 3: 
#line 14260 
    ;
    
#line 14264 
    tmp_9 = ldv_undef_int();
    
#line 14264 
    if (tmp_9 != 0) 
#line 14267 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_128_resource_1,ldv_128_ldv_param_1_2,ldv_128_ldv_param_2_3);
    else {
      
#line 14273 
      ldv_128_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 14274 
      ldv_128_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 14279 
      ldv_emg_wrapper_tx_tx_template_prepared_read_3(ldv_128_resource_1,ldv_128_ldv_param_1_4,ldv_128_size_cnt,ldv_128_ldv_param_3_5);
      
#line 14283 
      ldv_free((void *)ldv_128_ldv_param_3_5);
      
#line 14284 
      ldv_free((void *)ldv_128_ldv_param_1_4);
    }
    
#line 14288 
    goto ldv_32364;
    default: 
#line 14290 
    ;
    
#line 14290 
    __VERIFIER_assume(0);
  }
  ldv_32364: 
#line 14299 
  ;
  
#line 14299 
  goto ldv_call_128;
  
#line 14301 
  __retres = (void *)0;
  return_label: 
#line 14301 
                return __retres;
}


#line 14306  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_12(void *arg0)
{
  void *__retres;
  struct file *ldv_12_resource_1;
  int ldv_12_ldv_param_2_3;
  long long ldv_12_ldv_param_1_2;
  char *ldv_12_ldv_param_1_4;
  struct inode *ldv_12_resource_0;
  unsigned long ldv_12_size_cnt;
  long long *ldv_12_ldv_param_3_5;
  char *ldv_12_ldv_param_1_6;
  long long *ldv_12_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 14317 
  struct file_operations *ldv_12_container = ldv_emg_alias_rx_rx_cmplt_task_ops_2;
  
#line 14318 
  int ldv_12_ret = ldv_undef_int();
  
#line 14321 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 14325 
  ldv_12_ret = ldv_undef_int();
  
#line 14328 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 14329 
    ldv_12_container = data->arg0;
    
#line 14330 
    ldv_free((void *)data);
  }
  else ;
  
#line 14335 
  ldv_12_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 14336 
  tmp_1 = ldv_undef_int();
  
#line 14336 
  ldv_12_size_cnt = (unsigned long)tmp_1;
  
#line 14343 
  goto ldv_main_12;
  
#line 14345 
  __retres = (void *)0;
  
#line 14345 
  goto return_label;
  ldv_main_12: 
#line 14348 
  ;
  
#line 14351 
  tmp_3 = ldv_undef_int();
  
#line 14351 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 14354 
    ldv_12_ret = (*ldv_emg_alias_simple_open_5)(ldv_12_resource_0,ldv_12_resource_1);
    
#line 14356 
    ldv_12_ret = ldv_filter_err_code(ldv_12_ret);
    
#line 14359 
    tmp_2 = ldv_undef_int();
    
#line 14359 
    if (tmp_2 != 0) {
      
#line 14361 
      __VERIFIER_assume(ldv_12_ret == 0);
      
#line 14368 
      goto ldv_call_12;
    }
    else {
      
#line 14372 
      __VERIFIER_assume(ldv_12_ret != 0);
      
#line 14379 
      goto ldv_main_12;
    }
  }
  else {
    
#line 14384 
    ldv_free((void *)ldv_12_resource_0);
    
#line 14392 
    __retres = (void *)0;
    
#line 14392 
    goto return_label;
  }
  
#line 14395 
  __retres = (void *)0;
  
#line 14395 
  goto return_label;
  ldv_call_12: 
#line 14398 
  ;
  
#line 14401 
  tmp_4 = ldv_undef_int();
  
#line 14401 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 14402 
    ;
    
#line 14404 
    ldv_12_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 14405 
    ldv_12_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 14409 
    if (ldv_12_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 14415 
      __VERIFIER_assume(ldv_12_size_cnt <= 2147479552UL);
      
#line 14417 
      (*(ldv_12_container->write))(ldv_12_resource_1,(char const *)ldv_12_ldv_param_1_6,ldv_12_size_cnt,ldv_12_ldv_param_3_7);
    }
    else ;
    
#line 14422 
    ldv_free((void *)ldv_12_ldv_param_1_6);
    
#line 14423 
    ldv_free((void *)ldv_12_ldv_param_3_7);
    
#line 14430 
    goto ldv_call_12;
    case 2: 
#line 14433 
    ;
    
#line 14435 
    if (ldv_12_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 14437 
      (*(ldv_12_container->release))(ldv_12_resource_0,ldv_12_resource_1); else ;
    
#line 14445 
    goto ldv_main_12;
    case 3: 
#line 14448 
    ;
    
#line 14452 
    tmp_9 = ldv_undef_int();
    
#line 14452 
    if (tmp_9 != 0) 
#line 14455 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_12_resource_1,ldv_12_ldv_param_1_2,ldv_12_ldv_param_2_3);
    else {
      
#line 14461 
      ldv_12_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 14462 
      ldv_12_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 14467 
      ldv_emg_wrapper_rx_rx_cmplt_task_read_3(ldv_12_resource_1,ldv_12_ldv_param_1_4,ldv_12_size_cnt,ldv_12_ldv_param_3_5);
      
#line 14471 
      ldv_free((void *)ldv_12_ldv_param_1_4);
      
#line 14472 
      ldv_free((void *)ldv_12_ldv_param_3_5);
    }
    
#line 14476 
    goto ldv_32386;
    default: 
#line 14478 
    ;
    
#line 14478 
    __VERIFIER_assume(0);
  }
  ldv_32386: 
#line 14487 
  ;
  
#line 14487 
  goto ldv_call_12;
  
#line 14489 
  __retres = (void *)0;
  return_label: 
#line 14489 
                return __retres;
}


#line 14494  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_79(void *arg0)
{
  void *__retres;
  struct file *ldv_79_resource_1;
  int ldv_79_ldv_param_2_3;
  long long ldv_79_ldv_param_1_2;
  char *ldv_79_ldv_param_1_4;
  struct inode *ldv_79_resource_0;
  unsigned long ldv_79_size_cnt;
  long long *ldv_79_ldv_param_3_5;
  char *ldv_79_ldv_param_1_6;
  long long *ldv_79_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 14505 
  struct file_operations *ldv_79_container = ldv_emg_alias_mem_fw_gen_free_mem_blks_ops_2;
  
#line 14506 
  int ldv_79_ret = ldv_undef_int();
  
#line 14509 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 14513 
  ldv_79_ret = ldv_undef_int();
  
#line 14516 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 14517 
    ldv_79_container = data->arg0;
    
#line 14518 
    ldv_free((void *)data);
  }
  else ;
  
#line 14523 
  ldv_79_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 14524 
  tmp_1 = ldv_undef_int();
  
#line 14524 
  ldv_79_size_cnt = (unsigned long)tmp_1;
  
#line 14531 
  goto ldv_main_79;
  
#line 14533 
  __retres = (void *)0;
  
#line 14533 
  goto return_label;
  ldv_main_79: 
#line 14536 
  ;
  
#line 14539 
  tmp_3 = ldv_undef_int();
  
#line 14539 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 14542 
    ldv_79_ret = (*ldv_emg_alias_simple_open_5)(ldv_79_resource_0,ldv_79_resource_1);
    
#line 14544 
    ldv_79_ret = ldv_filter_err_code(ldv_79_ret);
    
#line 14547 
    tmp_2 = ldv_undef_int();
    
#line 14547 
    if (tmp_2 != 0) {
      
#line 14549 
      __VERIFIER_assume(ldv_79_ret == 0);
      
#line 14556 
      goto ldv_call_79;
    }
    else {
      
#line 14560 
      __VERIFIER_assume(ldv_79_ret != 0);
      
#line 14567 
      goto ldv_main_79;
    }
  }
  else {
    
#line 14572 
    ldv_free((void *)ldv_79_resource_0);
    
#line 14580 
    __retres = (void *)0;
    
#line 14580 
    goto return_label;
  }
  
#line 14583 
  __retres = (void *)0;
  
#line 14583 
  goto return_label;
  ldv_call_79: 
#line 14586 
  ;
  
#line 14589 
  tmp_4 = ldv_undef_int();
  
#line 14589 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 14590 
    ;
    
#line 14592 
    ldv_79_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 14593 
    ldv_79_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 14597 
    if (ldv_79_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 14603 
      __VERIFIER_assume(ldv_79_size_cnt <= 2147479552UL);
      
#line 14605 
      (*(ldv_79_container->write))(ldv_79_resource_1,(char const *)ldv_79_ldv_param_1_6,ldv_79_size_cnt,ldv_79_ldv_param_3_7);
    }
    else ;
    
#line 14610 
    ldv_free((void *)ldv_79_ldv_param_3_7);
    
#line 14611 
    ldv_free((void *)ldv_79_ldv_param_1_6);
    
#line 14618 
    goto ldv_call_79;
    case 2: 
#line 14621 
    ;
    
#line 14623 
    if (ldv_79_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 14625 
      (*(ldv_79_container->release))(ldv_79_resource_0,ldv_79_resource_1); else ;
    
#line 14633 
    goto ldv_main_79;
    case 3: 
#line 14636 
    ;
    
#line 14640 
    tmp_9 = ldv_undef_int();
    
#line 14640 
    if (tmp_9 != 0) 
#line 14643 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_79_resource_1,ldv_79_ldv_param_1_2,ldv_79_ldv_param_2_3);
    else {
      
#line 14649 
      ldv_79_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 14650 
      ldv_79_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 14655 
      ldv_emg_wrapper_mem_fw_gen_free_mem_blks_read_3(ldv_79_resource_1,ldv_79_ldv_param_1_4,ldv_79_size_cnt,ldv_79_ldv_param_3_5);
      
#line 14659 
      ldv_free((void *)ldv_79_ldv_param_3_5);
      
#line 14660 
      ldv_free((void *)ldv_79_ldv_param_1_4);
    }
    
#line 14664 
    goto ldv_32408;
    default: 
#line 14666 
    ;
    
#line 14666 
    __VERIFIER_assume(0);
  }
  ldv_32408: 
#line 14675 
  ;
  
#line 14675 
  goto ldv_call_79;
  
#line 14677 
  __retres = (void *)0;
  return_label: 
#line 14677 
                return __retres;
}


#line 14682  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_22(void *arg0)
{
  void *__retres;
  struct file *ldv_22_resource_1;
  int ldv_22_ldv_param_2_3;
  long long ldv_22_ldv_param_1_2;
  char *ldv_22_ldv_param_1_4;
  struct inode *ldv_22_resource_0;
  unsigned long ldv_22_size_cnt;
  long long *ldv_22_ldv_param_3_5;
  char *ldv_22_ldv_param_1_6;
  long long *ldv_22_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 14693 
  struct file_operations *ldv_22_container = ldv_emg_alias_tx_tx_done_int_template_ops_2;
  
#line 14694 
  int ldv_22_ret = ldv_undef_int();
  
#line 14697 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 14701 
  ldv_22_ret = ldv_undef_int();
  
#line 14704 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 14705 
    ldv_22_container = data->arg0;
    
#line 14706 
    ldv_free((void *)data);
  }
  else ;
  
#line 14711 
  ldv_22_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 14712 
  tmp_1 = ldv_undef_int();
  
#line 14712 
  ldv_22_size_cnt = (unsigned long)tmp_1;
  
#line 14719 
  goto ldv_main_22;
  
#line 14721 
  __retres = (void *)0;
  
#line 14721 
  goto return_label;
  ldv_main_22: 
#line 14724 
  ;
  
#line 14727 
  tmp_3 = ldv_undef_int();
  
#line 14727 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 14730 
    ldv_22_ret = (*ldv_emg_alias_simple_open_5)(ldv_22_resource_0,ldv_22_resource_1);
    
#line 14732 
    ldv_22_ret = ldv_filter_err_code(ldv_22_ret);
    
#line 14735 
    tmp_2 = ldv_undef_int();
    
#line 14735 
    if (tmp_2 != 0) {
      
#line 14737 
      __VERIFIER_assume(ldv_22_ret == 0);
      
#line 14744 
      goto ldv_call_22;
    }
    else {
      
#line 14748 
      __VERIFIER_assume(ldv_22_ret != 0);
      
#line 14755 
      goto ldv_main_22;
    }
  }
  else {
    
#line 14760 
    ldv_free((void *)ldv_22_resource_0);
    
#line 14768 
    __retres = (void *)0;
    
#line 14768 
    goto return_label;
  }
  
#line 14771 
  __retres = (void *)0;
  
#line 14771 
  goto return_label;
  ldv_call_22: 
#line 14774 
  ;
  
#line 14777 
  tmp_4 = ldv_undef_int();
  
#line 14777 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 14778 
    ;
    
#line 14780 
    ldv_22_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 14781 
    ldv_22_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 14785 
    if (ldv_22_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 14791 
      __VERIFIER_assume(ldv_22_size_cnt <= 2147479552UL);
      
#line 14793 
      (*(ldv_22_container->write))(ldv_22_resource_1,(char const *)ldv_22_ldv_param_1_6,ldv_22_size_cnt,ldv_22_ldv_param_3_7);
    }
    else ;
    
#line 14798 
    ldv_free((void *)ldv_22_ldv_param_3_7);
    
#line 14799 
    ldv_free((void *)ldv_22_ldv_param_1_6);
    
#line 14806 
    goto ldv_call_22;
    case 2: 
#line 14809 
    ;
    
#line 14811 
    if (ldv_22_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 14813 
      (*(ldv_22_container->release))(ldv_22_resource_0,ldv_22_resource_1); else ;
    
#line 14821 
    goto ldv_main_22;
    case 3: 
#line 14824 
    ;
    
#line 14828 
    tmp_9 = ldv_undef_int();
    
#line 14828 
    if (tmp_9 != 0) 
#line 14831 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_22_resource_1,ldv_22_ldv_param_1_2,ldv_22_ldv_param_2_3);
    else {
      
#line 14837 
      ldv_22_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 14838 
      ldv_22_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 14843 
      ldv_emg_wrapper_tx_tx_done_int_template_read_3(ldv_22_resource_1,ldv_22_ldv_param_1_4,ldv_22_size_cnt,ldv_22_ldv_param_3_5);
      
#line 14847 
      ldv_free((void *)ldv_22_ldv_param_1_4);
      
#line 14848 
      ldv_free((void *)ldv_22_ldv_param_3_5);
    }
    
#line 14852 
    goto ldv_32430;
    default: 
#line 14854 
    ;
    
#line 14854 
    __VERIFIER_assume(0);
  }
  ldv_32430: 
#line 14863 
  ;
  
#line 14863 
  goto ldv_call_22;
  
#line 14865 
  __retres = (void *)0;
  return_label: 
#line 14865 
                return __retres;
}


#line 14870  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_82(void *arg0)
{
  void *__retres;
  struct file *ldv_82_resource_1;
  int ldv_82_ldv_param_2_3;
  long long ldv_82_ldv_param_1_2;
  char *ldv_82_ldv_param_1_4;
  struct inode *ldv_82_resource_0;
  unsigned long ldv_82_size_cnt;
  long long *ldv_82_ldv_param_3_5;
  char *ldv_82_ldv_param_1_6;
  long long *ldv_82_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 14881 
  struct file_operations *ldv_82_container = ldv_emg_alias_tx_tx_cmplt_ops_2;
  
#line 14882 
  int ldv_82_ret = ldv_undef_int();
  
#line 14885 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 14889 
  ldv_82_ret = ldv_undef_int();
  
#line 14892 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 14893 
    ldv_82_container = data->arg0;
    
#line 14894 
    ldv_free((void *)data);
  }
  else ;
  
#line 14899 
  ldv_82_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 14900 
  tmp_1 = ldv_undef_int();
  
#line 14900 
  ldv_82_size_cnt = (unsigned long)tmp_1;
  
#line 14907 
  goto ldv_main_82;
  
#line 14909 
  __retres = (void *)0;
  
#line 14909 
  goto return_label;
  ldv_main_82: 
#line 14912 
  ;
  
#line 14915 
  tmp_3 = ldv_undef_int();
  
#line 14915 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 14918 
    ldv_82_ret = (*ldv_emg_alias_simple_open_5)(ldv_82_resource_0,ldv_82_resource_1);
    
#line 14920 
    ldv_82_ret = ldv_filter_err_code(ldv_82_ret);
    
#line 14923 
    tmp_2 = ldv_undef_int();
    
#line 14923 
    if (tmp_2 != 0) {
      
#line 14925 
      __VERIFIER_assume(ldv_82_ret == 0);
      
#line 14932 
      goto ldv_call_82;
    }
    else {
      
#line 14936 
      __VERIFIER_assume(ldv_82_ret != 0);
      
#line 14943 
      goto ldv_main_82;
    }
  }
  else {
    
#line 14948 
    ldv_free((void *)ldv_82_resource_0);
    
#line 14956 
    __retres = (void *)0;
    
#line 14956 
    goto return_label;
  }
  
#line 14959 
  __retres = (void *)0;
  
#line 14959 
  goto return_label;
  ldv_call_82: 
#line 14962 
  ;
  
#line 14965 
  tmp_4 = ldv_undef_int();
  
#line 14965 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 14966 
    ;
    
#line 14968 
    ldv_82_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 14969 
    ldv_82_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 14973 
    if (ldv_82_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 14979 
      __VERIFIER_assume(ldv_82_size_cnt <= 2147479552UL);
      
#line 14981 
      (*(ldv_82_container->write))(ldv_82_resource_1,(char const *)ldv_82_ldv_param_1_6,ldv_82_size_cnt,ldv_82_ldv_param_3_7);
    }
    else ;
    
#line 14986 
    ldv_free((void *)ldv_82_ldv_param_1_6);
    
#line 14987 
    ldv_free((void *)ldv_82_ldv_param_3_7);
    
#line 14994 
    goto ldv_call_82;
    case 2: 
#line 14997 
    ;
    
#line 14999 
    if (ldv_82_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 15001 
      (*(ldv_82_container->release))(ldv_82_resource_0,ldv_82_resource_1); else ;
    
#line 15009 
    goto ldv_main_82;
    case 3: 
#line 15012 
    ;
    
#line 15016 
    tmp_9 = ldv_undef_int();
    
#line 15016 
    if (tmp_9 != 0) 
#line 15019 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_82_resource_1,ldv_82_ldv_param_1_2,ldv_82_ldv_param_2_3);
    else {
      
#line 15025 
      ldv_82_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 15026 
      ldv_82_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 15031 
      ldv_emg_wrapper_tx_tx_cmplt_read_3(ldv_82_resource_1,ldv_82_ldv_param_1_4,ldv_82_size_cnt,ldv_82_ldv_param_3_5);
      
#line 15035 
      ldv_free((void *)ldv_82_ldv_param_3_5);
      
#line 15036 
      ldv_free((void *)ldv_82_ldv_param_1_4);
    }
    
#line 15040 
    goto ldv_32452;
    default: 
#line 15042 
    ;
    
#line 15042 
    __VERIFIER_assume(0);
  }
  ldv_32452: 
#line 15051 
  ;
  
#line 15051 
  goto ldv_call_82;
  
#line 15053 
  __retres = (void *)0;
  return_label: 
#line 15053 
                return __retres;
}


#line 15058  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_43(void *arg0)
{
  void *__retres;
  struct file *ldv_43_resource_1;
  int ldv_43_ldv_param_2_3;
  long long ldv_43_ldv_param_1_2;
  char *ldv_43_ldv_param_1_4;
  struct inode *ldv_43_resource_0;
  unsigned long ldv_43_size_cnt;
  long long *ldv_43_ldv_param_3_5;
  char *ldv_43_ldv_param_1_6;
  long long *ldv_43_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 15069 
  struct file_operations *ldv_43_container = ldv_emg_alias_rx_filter_accum_arp_pend_requests_ops_2;
  
#line 15070 
  int ldv_43_ret = ldv_undef_int();
  
#line 15073 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 15077 
  ldv_43_ret = ldv_undef_int();
  
#line 15080 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 15081 
    ldv_43_container = data->arg0;
    
#line 15082 
    ldv_free((void *)data);
  }
  else ;
  
#line 15087 
  ldv_43_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 15088 
  tmp_1 = ldv_undef_int();
  
#line 15088 
  ldv_43_size_cnt = (unsigned long)tmp_1;
  
#line 15095 
  goto ldv_main_43;
  
#line 15097 
  __retres = (void *)0;
  
#line 15097 
  goto return_label;
  ldv_main_43: 
#line 15100 
  ;
  
#line 15103 
  tmp_3 = ldv_undef_int();
  
#line 15103 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 15106 
    ldv_43_ret = (*ldv_emg_alias_simple_open_5)(ldv_43_resource_0,ldv_43_resource_1);
    
#line 15108 
    ldv_43_ret = ldv_filter_err_code(ldv_43_ret);
    
#line 15111 
    tmp_2 = ldv_undef_int();
    
#line 15111 
    if (tmp_2 != 0) {
      
#line 15113 
      __VERIFIER_assume(ldv_43_ret == 0);
      
#line 15120 
      goto ldv_call_43;
    }
    else {
      
#line 15124 
      __VERIFIER_assume(ldv_43_ret != 0);
      
#line 15131 
      goto ldv_main_43;
    }
  }
  else {
    
#line 15136 
    ldv_free((void *)ldv_43_resource_0);
    
#line 15144 
    __retres = (void *)0;
    
#line 15144 
    goto return_label;
  }
  
#line 15147 
  __retres = (void *)0;
  
#line 15147 
  goto return_label;
  ldv_call_43: 
#line 15150 
  ;
  
#line 15153 
  tmp_4 = ldv_undef_int();
  
#line 15153 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 15154 
    ;
    
#line 15156 
    ldv_43_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 15157 
    ldv_43_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 15161 
    if (ldv_43_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 15167 
      __VERIFIER_assume(ldv_43_size_cnt <= 2147479552UL);
      
#line 15169 
      (*(ldv_43_container->write))(ldv_43_resource_1,(char const *)ldv_43_ldv_param_1_6,ldv_43_size_cnt,ldv_43_ldv_param_3_7);
    }
    else ;
    
#line 15174 
    ldv_free((void *)ldv_43_ldv_param_3_7);
    
#line 15175 
    ldv_free((void *)ldv_43_ldv_param_1_6);
    
#line 15182 
    goto ldv_call_43;
    case 2: 
#line 15185 
    ;
    
#line 15187 
    if (ldv_43_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 15189 
      (*(ldv_43_container->release))(ldv_43_resource_0,ldv_43_resource_1); else ;
    
#line 15197 
    goto ldv_main_43;
    case 3: 
#line 15200 
    ;
    
#line 15204 
    tmp_9 = ldv_undef_int();
    
#line 15204 
    if (tmp_9 != 0) 
#line 15207 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_43_resource_1,ldv_43_ldv_param_1_2,ldv_43_ldv_param_2_3);
    else {
      
#line 15213 
      ldv_43_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 15214 
      ldv_43_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 15219 
      ldv_emg_wrapper_rx_filter_accum_arp_pend_requests_read_3(ldv_43_resource_1,ldv_43_ldv_param_1_4,ldv_43_size_cnt,ldv_43_ldv_param_3_5);
      
#line 15223 
      ldv_free((void *)ldv_43_ldv_param_1_4);
      
#line 15224 
      ldv_free((void *)ldv_43_ldv_param_3_5);
    }
    
#line 15228 
    goto ldv_32474;
    default: 
#line 15230 
    ;
    
#line 15230 
    __VERIFIER_assume(0);
  }
  ldv_32474: 
#line 15239 
  ;
  
#line 15239 
  goto ldv_call_43;
  
#line 15241 
  __retres = (void *)0;
  return_label: 
#line 15241 
                return __retres;
}


#line 15246  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_72(void *arg0)
{
  void *__retres;
  struct file *ldv_72_resource_1;
  int ldv_72_ldv_param_2_3;
  long long ldv_72_ldv_param_1_2;
  char *ldv_72_ldv_param_1_4;
  struct inode *ldv_72_resource_0;
  unsigned long ldv_72_size_cnt;
  long long *ldv_72_ldv_param_3_5;
  char *ldv_72_ldv_param_1_6;
  long long *ldv_72_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 15257 
  struct file_operations *ldv_72_container = ldv_emg_alias_rx_defrag_in_process_called_ops_2;
  
#line 15258 
  int ldv_72_ret = ldv_undef_int();
  
#line 15261 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 15265 
  ldv_72_ret = ldv_undef_int();
  
#line 15268 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 15269 
    ldv_72_container = data->arg0;
    
#line 15270 
    ldv_free((void *)data);
  }
  else ;
  
#line 15275 
  ldv_72_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 15276 
  tmp_1 = ldv_undef_int();
  
#line 15276 
  ldv_72_size_cnt = (unsigned long)tmp_1;
  
#line 15283 
  goto ldv_main_72;
  
#line 15285 
  __retres = (void *)0;
  
#line 15285 
  goto return_label;
  ldv_main_72: 
#line 15288 
  ;
  
#line 15291 
  tmp_3 = ldv_undef_int();
  
#line 15291 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 15294 
    ldv_72_ret = (*ldv_emg_alias_simple_open_5)(ldv_72_resource_0,ldv_72_resource_1);
    
#line 15296 
    ldv_72_ret = ldv_filter_err_code(ldv_72_ret);
    
#line 15299 
    tmp_2 = ldv_undef_int();
    
#line 15299 
    if (tmp_2 != 0) {
      
#line 15301 
      __VERIFIER_assume(ldv_72_ret == 0);
      
#line 15308 
      goto ldv_call_72;
    }
    else {
      
#line 15312 
      __VERIFIER_assume(ldv_72_ret != 0);
      
#line 15319 
      goto ldv_main_72;
    }
  }
  else {
    
#line 15324 
    ldv_free((void *)ldv_72_resource_0);
    
#line 15332 
    __retres = (void *)0;
    
#line 15332 
    goto return_label;
  }
  
#line 15335 
  __retres = (void *)0;
  
#line 15335 
  goto return_label;
  ldv_call_72: 
#line 15338 
  ;
  
#line 15341 
  tmp_4 = ldv_undef_int();
  
#line 15341 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 15342 
    ;
    
#line 15344 
    ldv_72_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 15345 
    ldv_72_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 15349 
    if (ldv_72_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 15355 
      __VERIFIER_assume(ldv_72_size_cnt <= 2147479552UL);
      
#line 15357 
      (*(ldv_72_container->write))(ldv_72_resource_1,(char const *)ldv_72_ldv_param_1_6,ldv_72_size_cnt,ldv_72_ldv_param_3_7);
    }
    else ;
    
#line 15362 
    ldv_free((void *)ldv_72_ldv_param_3_7);
    
#line 15363 
    ldv_free((void *)ldv_72_ldv_param_1_6);
    
#line 15370 
    goto ldv_call_72;
    case 2: 
#line 15373 
    ;
    
#line 15375 
    if (ldv_72_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 15377 
      (*(ldv_72_container->release))(ldv_72_resource_0,ldv_72_resource_1); else ;
    
#line 15385 
    goto ldv_main_72;
    case 3: 
#line 15388 
    ;
    
#line 15392 
    tmp_9 = ldv_undef_int();
    
#line 15392 
    if (tmp_9 != 0) 
#line 15395 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_72_resource_1,ldv_72_ldv_param_1_2,ldv_72_ldv_param_2_3);
    else {
      
#line 15401 
      ldv_72_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 15402 
      ldv_72_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 15407 
      ldv_emg_wrapper_rx_defrag_in_process_called_read_3(ldv_72_resource_1,ldv_72_ldv_param_1_4,ldv_72_size_cnt,ldv_72_ldv_param_3_5);
      
#line 15411 
      ldv_free((void *)ldv_72_ldv_param_1_4);
      
#line 15412 
      ldv_free((void *)ldv_72_ldv_param_3_5);
    }
    
#line 15416 
    goto ldv_32496;
    default: 
#line 15418 
    ;
    
#line 15418 
    __VERIFIER_assume(0);
  }
  ldv_32496: 
#line 15427 
  ;
  
#line 15427 
  goto ldv_call_72;
  
#line 15429 
  __retres = (void *)0;
  return_label: 
#line 15429 
                return __retres;
}


#line 15434  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_20(void *arg0)
{
  void *__retres;
  struct file *ldv_20_resource_1;
  int ldv_20_ldv_param_2_3;
  long long ldv_20_ldv_param_1_2;
  char *ldv_20_ldv_param_1_4;
  struct inode *ldv_20_resource_0;
  unsigned long ldv_20_size_cnt;
  long long *ldv_20_ldv_param_3_5;
  char *ldv_20_ldv_param_1_6;
  long long *ldv_20_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 15445 
  struct file_operations *ldv_20_container = ldv_emg_alias_tx_tx_exch_ops_2;
  
#line 15446 
  int ldv_20_ret = ldv_undef_int();
  
#line 15449 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 15453 
  ldv_20_ret = ldv_undef_int();
  
#line 15456 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 15457 
    ldv_20_container = data->arg0;
    
#line 15458 
    ldv_free((void *)data);
  }
  else ;
  
#line 15463 
  ldv_20_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 15464 
  tmp_1 = ldv_undef_int();
  
#line 15464 
  ldv_20_size_cnt = (unsigned long)tmp_1;
  
#line 15471 
  goto ldv_main_20;
  
#line 15473 
  __retres = (void *)0;
  
#line 15473 
  goto return_label;
  ldv_main_20: 
#line 15476 
  ;
  
#line 15479 
  tmp_3 = ldv_undef_int();
  
#line 15479 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 15482 
    ldv_20_ret = (*ldv_emg_alias_simple_open_5)(ldv_20_resource_0,ldv_20_resource_1);
    
#line 15484 
    ldv_20_ret = ldv_filter_err_code(ldv_20_ret);
    
#line 15487 
    tmp_2 = ldv_undef_int();
    
#line 15487 
    if (tmp_2 != 0) {
      
#line 15489 
      __VERIFIER_assume(ldv_20_ret == 0);
      
#line 15496 
      goto ldv_call_20;
    }
    else {
      
#line 15500 
      __VERIFIER_assume(ldv_20_ret != 0);
      
#line 15507 
      goto ldv_main_20;
    }
  }
  else {
    
#line 15512 
    ldv_free((void *)ldv_20_resource_0);
    
#line 15520 
    __retres = (void *)0;
    
#line 15520 
    goto return_label;
  }
  
#line 15523 
  __retres = (void *)0;
  
#line 15523 
  goto return_label;
  ldv_call_20: 
#line 15526 
  ;
  
#line 15529 
  tmp_4 = ldv_undef_int();
  
#line 15529 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 15530 
    ;
    
#line 15532 
    ldv_20_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 15533 
    ldv_20_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 15537 
    if (ldv_20_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 15543 
      __VERIFIER_assume(ldv_20_size_cnt <= 2147479552UL);
      
#line 15545 
      (*(ldv_20_container->write))(ldv_20_resource_1,(char const *)ldv_20_ldv_param_1_6,ldv_20_size_cnt,ldv_20_ldv_param_3_7);
    }
    else ;
    
#line 15550 
    ldv_free((void *)ldv_20_ldv_param_3_7);
    
#line 15551 
    ldv_free((void *)ldv_20_ldv_param_1_6);
    
#line 15558 
    goto ldv_call_20;
    case 2: 
#line 15561 
    ;
    
#line 15563 
    if (ldv_20_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 15565 
      (*(ldv_20_container->release))(ldv_20_resource_0,ldv_20_resource_1); else ;
    
#line 15573 
    goto ldv_main_20;
    case 3: 
#line 15576 
    ;
    
#line 15580 
    tmp_9 = ldv_undef_int();
    
#line 15580 
    if (tmp_9 != 0) 
#line 15583 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_20_resource_1,ldv_20_ldv_param_1_2,ldv_20_ldv_param_2_3);
    else {
      
#line 15589 
      ldv_20_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 15590 
      ldv_20_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 15595 
      ldv_emg_wrapper_tx_tx_exch_read_3(ldv_20_resource_1,ldv_20_ldv_param_1_4,ldv_20_size_cnt,ldv_20_ldv_param_3_5);
      
#line 15599 
      ldv_free((void *)ldv_20_ldv_param_1_4);
      
#line 15600 
      ldv_free((void *)ldv_20_ldv_param_3_5);
    }
    
#line 15604 
    goto ldv_32518;
    default: 
#line 15606 
    ;
    
#line 15606 
    __VERIFIER_assume(0);
  }
  ldv_32518: 
#line 15615 
  ;
  
#line 15615 
  goto ldv_call_20;
  
#line 15617 
  __retres = (void *)0;
  return_label: 
#line 15617 
                return __retres;
}


#line 15622  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_63(void *arg0)
{
  void *__retres;
  struct file *ldv_63_resource_1;
  int ldv_63_ldv_param_2_3;
  long long ldv_63_ldv_param_1_2;
  char *ldv_63_ldv_param_1_4;
  struct inode *ldv_63_resource_0;
  unsigned long ldv_63_size_cnt;
  long long *ldv_63_ldv_param_3_5;
  char *ldv_63_ldv_param_1_6;
  long long *ldv_63_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 15633 
  struct file_operations *ldv_63_container = ldv_emg_alias_pwr_cont_miss_bcns_spread_ops_2;
  
#line 15634 
  int ldv_63_ret = ldv_undef_int();
  
#line 15637 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 15641 
  ldv_63_ret = ldv_undef_int();
  
#line 15644 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 15645 
    ldv_63_container = data->arg0;
    
#line 15646 
    ldv_free((void *)data);
  }
  else ;
  
#line 15651 
  ldv_63_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 15652 
  tmp_1 = ldv_undef_int();
  
#line 15652 
  ldv_63_size_cnt = (unsigned long)tmp_1;
  
#line 15659 
  goto ldv_main_63;
  
#line 15661 
  __retres = (void *)0;
  
#line 15661 
  goto return_label;
  ldv_main_63: 
#line 15664 
  ;
  
#line 15667 
  tmp_3 = ldv_undef_int();
  
#line 15667 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 15670 
    ldv_63_ret = (*ldv_emg_alias_simple_open_5)(ldv_63_resource_0,ldv_63_resource_1);
    
#line 15672 
    ldv_63_ret = ldv_filter_err_code(ldv_63_ret);
    
#line 15675 
    tmp_2 = ldv_undef_int();
    
#line 15675 
    if (tmp_2 != 0) {
      
#line 15677 
      __VERIFIER_assume(ldv_63_ret == 0);
      
#line 15684 
      goto ldv_call_63;
    }
    else {
      
#line 15688 
      __VERIFIER_assume(ldv_63_ret != 0);
      
#line 15695 
      goto ldv_main_63;
    }
  }
  else {
    
#line 15700 
    ldv_free((void *)ldv_63_resource_0);
    
#line 15708 
    __retres = (void *)0;
    
#line 15708 
    goto return_label;
  }
  
#line 15711 
  __retres = (void *)0;
  
#line 15711 
  goto return_label;
  ldv_call_63: 
#line 15714 
  ;
  
#line 15717 
  tmp_4 = ldv_undef_int();
  
#line 15717 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 15718 
    ;
    
#line 15720 
    ldv_63_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 15721 
    ldv_63_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 15725 
    if (ldv_63_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 15731 
      __VERIFIER_assume(ldv_63_size_cnt <= 2147479552UL);
      
#line 15733 
      (*(ldv_63_container->write))(ldv_63_resource_1,(char const *)ldv_63_ldv_param_1_6,ldv_63_size_cnt,ldv_63_ldv_param_3_7);
    }
    else ;
    
#line 15738 
    ldv_free((void *)ldv_63_ldv_param_1_6);
    
#line 15739 
    ldv_free((void *)ldv_63_ldv_param_3_7);
    
#line 15746 
    goto ldv_call_63;
    case 2: 
#line 15749 
    ;
    
#line 15751 
    if (ldv_63_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 15753 
      (*(ldv_63_container->release))(ldv_63_resource_0,ldv_63_resource_1); else ;
    
#line 15761 
    goto ldv_main_63;
    case 3: 
#line 15764 
    ;
    
#line 15768 
    tmp_9 = ldv_undef_int();
    
#line 15768 
    if (tmp_9 != 0) 
#line 15771 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_63_resource_1,ldv_63_ldv_param_1_2,ldv_63_ldv_param_2_3);
    else {
      
#line 15777 
      ldv_63_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 15778 
      ldv_63_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 15783 
      ldv_emg_wrapper_pwr_cont_miss_bcns_spread_read_3(ldv_63_resource_1,ldv_63_ldv_param_1_4,ldv_63_size_cnt,ldv_63_ldv_param_3_5);
      
#line 15787 
      ldv_free((void *)ldv_63_ldv_param_1_4);
      
#line 15788 
      ldv_free((void *)ldv_63_ldv_param_3_5);
    }
    
#line 15792 
    goto ldv_32540;
    default: 
#line 15794 
    ;
    
#line 15794 
    __VERIFIER_assume(0);
  }
  ldv_32540: 
#line 15803 
  ;
  
#line 15803 
  goto ldv_call_63;
  
#line 15805 
  __retres = (void *)0;
  return_label: 
#line 15805 
                return __retres;
}


#line 15810  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_125(void *arg0)
{
  void *__retres;
  struct file *ldv_125_resource_1;
  int ldv_125_ldv_param_2_3;
  long long ldv_125_ldv_param_1_2;
  char *ldv_125_ldv_param_1_4;
  unsigned long ldv_125_size_cnt;
  long long *ldv_125_ldv_param_3_5;
  struct inode *ldv_125_resource_0;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 15819 
  struct file_operations *ldv_125_container = ldv_emg_alias_clear_fw_stats_ops_2;
  
#line 15820 
  int ldv_125_ret = ldv_undef_int();
  
#line 15823 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 15827 
  ldv_125_ret = ldv_undef_int();
  
#line 15830 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 15831 
    ldv_125_container = data->arg0;
    
#line 15832 
    ldv_free((void *)data);
  }
  else ;
  
#line 15837 
  ldv_125_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 15838 
  tmp_1 = ldv_undef_int();
  
#line 15838 
  ldv_125_size_cnt = (unsigned long)tmp_1;
  
#line 15845 
  goto ldv_main_125;
  
#line 15847 
  __retres = (void *)0;
  
#line 15847 
  goto return_label;
  ldv_main_125: 
#line 15850 
  ;
  
#line 15853 
  tmp_3 = ldv_undef_int();
  
#line 15853 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 15856 
    ldv_125_ret = (*ldv_emg_alias_simple_open_5)(ldv_125_resource_0,ldv_125_resource_1);
    
#line 15858 
    ldv_125_ret = ldv_filter_err_code(ldv_125_ret);
    
#line 15861 
    tmp_2 = ldv_undef_int();
    
#line 15861 
    if (tmp_2 != 0) {
      
#line 15863 
      __VERIFIER_assume(ldv_125_ret == 0);
      
#line 15870 
      goto ldv_call_125;
    }
    else {
      
#line 15874 
      __VERIFIER_assume(ldv_125_ret != 0);
      
#line 15881 
      goto ldv_main_125;
    }
  }
  else {
    
#line 15886 
    ldv_free((void *)ldv_125_resource_0);
    
#line 15894 
    __retres = (void *)0;
    
#line 15894 
    goto return_label;
  }
  
#line 15897 
  __retres = (void *)0;
  
#line 15897 
  goto return_label;
  ldv_call_125: 
#line 15900 
  ;
  
#line 15903 
  tmp_4 = ldv_undef_int();
  
#line 15903 
  switch (tmp_4) {
    case 1: 
#line 15904 
    ;
    
#line 15910 
    (*ldv_emg_alias_default_llseek_3)(ldv_125_resource_1,ldv_125_ldv_param_1_2,ldv_125_ldv_param_2_3);
    
#line 15920 
    goto ldv_call_125;
    case 2: 
#line 15923 
    ;
    
#line 15925 
    ldv_125_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 15926 
    ldv_125_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 15935 
    __VERIFIER_assume(ldv_125_size_cnt <= 2147479552UL);
    
#line 15937 
    ldv_emg_wrapper_clear_fw_stats_write_4(ldv_125_resource_1,ldv_125_ldv_param_1_4,ldv_125_size_cnt,ldv_125_ldv_param_3_5);
    
#line 15941 
    ldv_free((void *)ldv_125_ldv_param_1_4);
    
#line 15942 
    ldv_free((void *)ldv_125_ldv_param_3_5);
    
#line 15949 
    goto ldv_call_125;
    case 3: 
#line 15952 
    ;
    
#line 15954 
    if (ldv_125_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 15956 
      (*(ldv_125_container->release))(ldv_125_resource_0,ldv_125_resource_1); else ;
    
#line 15964 
    goto ldv_main_125;
    default: 
#line 15967 
    ;
    
#line 15967 
    __VERIFIER_assume(0);
  }
  
#line 15970 
  __retres = (void *)0;
  return_label: 
#line 15970 
                return __retres;
}


#line 15975  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_99(void *arg0)
{
  void *__retres;
  struct file *ldv_99_resource_1;
  int ldv_99_ldv_param_2_3;
  long long ldv_99_ldv_param_1_2;
  char *ldv_99_ldv_param_1_4;
  struct inode *ldv_99_resource_0;
  unsigned long ldv_99_size_cnt;
  long long *ldv_99_ldv_param_3_5;
  char *ldv_99_ldv_param_1_6;
  long long *ldv_99_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 15986 
  struct file_operations *ldv_99_container = ldv_emg_alias_tx_frag_bad_mblk_num_ops_2;
  
#line 15987 
  int ldv_99_ret = ldv_undef_int();
  
#line 15990 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 15994 
  ldv_99_ret = ldv_undef_int();
  
#line 15997 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 15998 
    ldv_99_container = data->arg0;
    
#line 15999 
    ldv_free((void *)data);
  }
  else ;
  
#line 16004 
  ldv_99_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 16005 
  tmp_1 = ldv_undef_int();
  
#line 16005 
  ldv_99_size_cnt = (unsigned long)tmp_1;
  
#line 16012 
  goto ldv_main_99;
  
#line 16014 
  __retres = (void *)0;
  
#line 16014 
  goto return_label;
  ldv_main_99: 
#line 16017 
  ;
  
#line 16020 
  tmp_3 = ldv_undef_int();
  
#line 16020 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 16023 
    ldv_99_ret = (*ldv_emg_alias_simple_open_5)(ldv_99_resource_0,ldv_99_resource_1);
    
#line 16025 
    ldv_99_ret = ldv_filter_err_code(ldv_99_ret);
    
#line 16028 
    tmp_2 = ldv_undef_int();
    
#line 16028 
    if (tmp_2 != 0) {
      
#line 16030 
      __VERIFIER_assume(ldv_99_ret == 0);
      
#line 16037 
      goto ldv_call_99;
    }
    else {
      
#line 16041 
      __VERIFIER_assume(ldv_99_ret != 0);
      
#line 16048 
      goto ldv_main_99;
    }
  }
  else {
    
#line 16053 
    ldv_free((void *)ldv_99_resource_0);
    
#line 16061 
    __retres = (void *)0;
    
#line 16061 
    goto return_label;
  }
  
#line 16064 
  __retres = (void *)0;
  
#line 16064 
  goto return_label;
  ldv_call_99: 
#line 16067 
  ;
  
#line 16070 
  tmp_4 = ldv_undef_int();
  
#line 16070 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 16071 
    ;
    
#line 16073 
    ldv_99_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 16074 
    ldv_99_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 16078 
    if (ldv_99_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 16084 
      __VERIFIER_assume(ldv_99_size_cnt <= 2147479552UL);
      
#line 16086 
      (*(ldv_99_container->write))(ldv_99_resource_1,(char const *)ldv_99_ldv_param_1_6,ldv_99_size_cnt,ldv_99_ldv_param_3_7);
    }
    else ;
    
#line 16091 
    ldv_free((void *)ldv_99_ldv_param_3_7);
    
#line 16092 
    ldv_free((void *)ldv_99_ldv_param_1_6);
    
#line 16099 
    goto ldv_call_99;
    case 2: 
#line 16102 
    ;
    
#line 16104 
    if (ldv_99_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 16106 
      (*(ldv_99_container->release))(ldv_99_resource_0,ldv_99_resource_1); else ;
    
#line 16114 
    goto ldv_main_99;
    case 3: 
#line 16117 
    ;
    
#line 16121 
    tmp_9 = ldv_undef_int();
    
#line 16121 
    if (tmp_9 != 0) 
#line 16124 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_99_resource_1,ldv_99_ldv_param_1_2,ldv_99_ldv_param_2_3);
    else {
      
#line 16130 
      ldv_99_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 16131 
      ldv_99_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 16136 
      ldv_emg_wrapper_tx_frag_bad_mblk_num_read_3(ldv_99_resource_1,ldv_99_ldv_param_1_4,ldv_99_size_cnt,ldv_99_ldv_param_3_5);
      
#line 16140 
      ldv_free((void *)ldv_99_ldv_param_1_4);
      
#line 16141 
      ldv_free((void *)ldv_99_ldv_param_3_5);
    }
    
#line 16145 
    goto ldv_32581;
    default: 
#line 16147 
    ;
    
#line 16147 
    __VERIFIER_assume(0);
  }
  ldv_32581: 
#line 16156 
  ;
  
#line 16156 
  goto ldv_call_99;
  
#line 16158 
  __retres = (void *)0;
  return_label: 
#line 16158 
                return __retres;
}


#line 16163  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_pm_deregister_108_12(void)
{
  int ret;
  struct ldv_struct_platform_instance_108 *cf_arg_81;
  int tmp;
  
#line 16166 
  tmp = ldv_undef_int();
  
#line 16166 
  switch (tmp) {
    case 0: 
#line 16167 
    ;
    
#line 16168 
    ret = pthread_join(ldv_thread_81,(void **)0);
    
#line 16169 
    __VERIFIER_assume(ret == 0);
    
#line 16170 
    goto ldv_32589;
    default: 
#line 16172 
    ;
    
#line 16172 
    __VERIFIER_assume(0);
  }
  ldv_32589: 
#line 16173 
  ;
  
#line 16174 
  return;
}


#line 16178  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_120(void *arg0)
{
  void *__retres;
  struct file *ldv_120_resource_1;
  int ldv_120_ldv_param_2_3;
  long long ldv_120_ldv_param_1_2;
  char *ldv_120_ldv_param_1_4;
  struct inode *ldv_120_resource_0;
  unsigned long ldv_120_size_cnt;
  long long *ldv_120_ldv_param_3_5;
  char *ldv_120_ldv_param_1_6;
  long long *ldv_120_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 16189 
  struct file_operations *ldv_120_container = ldv_emg_alias_rx_filter_ibss_filter_ops_2;
  
#line 16190 
  int ldv_120_ret = ldv_undef_int();
  
#line 16193 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 16197 
  ldv_120_ret = ldv_undef_int();
  
#line 16200 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 16201 
    ldv_120_container = data->arg0;
    
#line 16202 
    ldv_free((void *)data);
  }
  else ;
  
#line 16207 
  ldv_120_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 16208 
  tmp_1 = ldv_undef_int();
  
#line 16208 
  ldv_120_size_cnt = (unsigned long)tmp_1;
  
#line 16215 
  goto ldv_main_120;
  
#line 16217 
  __retres = (void *)0;
  
#line 16217 
  goto return_label;
  ldv_main_120: 
#line 16220 
  ;
  
#line 16223 
  tmp_3 = ldv_undef_int();
  
#line 16223 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 16226 
    ldv_120_ret = (*ldv_emg_alias_simple_open_5)(ldv_120_resource_0,ldv_120_resource_1);
    
#line 16228 
    ldv_120_ret = ldv_filter_err_code(ldv_120_ret);
    
#line 16231 
    tmp_2 = ldv_undef_int();
    
#line 16231 
    if (tmp_2 != 0) {
      
#line 16233 
      __VERIFIER_assume(ldv_120_ret == 0);
      
#line 16240 
      goto ldv_call_120;
    }
    else {
      
#line 16244 
      __VERIFIER_assume(ldv_120_ret != 0);
      
#line 16251 
      goto ldv_main_120;
    }
  }
  else {
    
#line 16256 
    ldv_free((void *)ldv_120_resource_0);
    
#line 16264 
    __retres = (void *)0;
    
#line 16264 
    goto return_label;
  }
  
#line 16267 
  __retres = (void *)0;
  
#line 16267 
  goto return_label;
  ldv_call_120: 
#line 16270 
  ;
  
#line 16273 
  tmp_4 = ldv_undef_int();
  
#line 16273 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 16274 
    ;
    
#line 16276 
    ldv_120_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 16277 
    ldv_120_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 16281 
    if (ldv_120_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 16287 
      __VERIFIER_assume(ldv_120_size_cnt <= 2147479552UL);
      
#line 16289 
      (*(ldv_120_container->write))(ldv_120_resource_1,(char const *)ldv_120_ldv_param_1_6,ldv_120_size_cnt,ldv_120_ldv_param_3_7);
    }
    else ;
    
#line 16294 
    ldv_free((void *)ldv_120_ldv_param_1_6);
    
#line 16295 
    ldv_free((void *)ldv_120_ldv_param_3_7);
    
#line 16302 
    goto ldv_call_120;
    case 2: 
#line 16305 
    ;
    
#line 16307 
    if (ldv_120_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 16309 
      (*(ldv_120_container->release))(ldv_120_resource_0,ldv_120_resource_1); else ;
    
#line 16317 
    goto ldv_main_120;
    case 3: 
#line 16320 
    ;
    
#line 16324 
    tmp_9 = ldv_undef_int();
    
#line 16324 
    if (tmp_9 != 0) 
#line 16327 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_120_resource_1,ldv_120_ldv_param_1_2,ldv_120_ldv_param_2_3);
    else {
      
#line 16333 
      ldv_120_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 16334 
      ldv_120_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 16339 
      ldv_emg_wrapper_rx_filter_ibss_filter_read_3(ldv_120_resource_1,ldv_120_ldv_param_1_4,ldv_120_size_cnt,ldv_120_ldv_param_3_5);
      
#line 16343 
      ldv_free((void *)ldv_120_ldv_param_3_5);
      
#line 16344 
      ldv_free((void *)ldv_120_ldv_param_1_4);
    }
    
#line 16348 
    goto ldv_32611;
    default: 
#line 16350 
    ;
    
#line 16350 
    __VERIFIER_assume(0);
  }
  ldv_32611: 
#line 16359 
  ;
  
#line 16359 
  goto ldv_call_120;
  
#line 16361 
  __retres = (void *)0;
  return_label: 
#line 16361 
                return __retres;
}


#line 16366  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_64(void *arg0)
{
  void *__retres;
  struct file *ldv_64_resource_1;
  int ldv_64_ldv_param_2_3;
  long long ldv_64_ldv_param_1_2;
  char *ldv_64_ldv_param_1_4;
  struct inode *ldv_64_resource_0;
  unsigned long ldv_64_size_cnt;
  long long *ldv_64_ldv_param_3_5;
  char *ldv_64_ldv_param_1_6;
  long long *ldv_64_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 16377 
  struct file_operations *ldv_64_container = ldv_emg_alias_tx_frag_need_fragmentation_ops_2;
  
#line 16378 
  int ldv_64_ret = ldv_undef_int();
  
#line 16381 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 16385 
  ldv_64_ret = ldv_undef_int();
  
#line 16388 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 16389 
    ldv_64_container = data->arg0;
    
#line 16390 
    ldv_free((void *)data);
  }
  else ;
  
#line 16395 
  ldv_64_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 16396 
  tmp_1 = ldv_undef_int();
  
#line 16396 
  ldv_64_size_cnt = (unsigned long)tmp_1;
  
#line 16403 
  goto ldv_main_64;
  
#line 16405 
  __retres = (void *)0;
  
#line 16405 
  goto return_label;
  ldv_main_64: 
#line 16408 
  ;
  
#line 16411 
  tmp_3 = ldv_undef_int();
  
#line 16411 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 16414 
    ldv_64_ret = (*ldv_emg_alias_simple_open_5)(ldv_64_resource_0,ldv_64_resource_1);
    
#line 16416 
    ldv_64_ret = ldv_filter_err_code(ldv_64_ret);
    
#line 16419 
    tmp_2 = ldv_undef_int();
    
#line 16419 
    if (tmp_2 != 0) {
      
#line 16421 
      __VERIFIER_assume(ldv_64_ret == 0);
      
#line 16428 
      goto ldv_call_64;
    }
    else {
      
#line 16432 
      __VERIFIER_assume(ldv_64_ret != 0);
      
#line 16439 
      goto ldv_main_64;
    }
  }
  else {
    
#line 16444 
    ldv_free((void *)ldv_64_resource_0);
    
#line 16452 
    __retres = (void *)0;
    
#line 16452 
    goto return_label;
  }
  
#line 16455 
  __retres = (void *)0;
  
#line 16455 
  goto return_label;
  ldv_call_64: 
#line 16458 
  ;
  
#line 16461 
  tmp_4 = ldv_undef_int();
  
#line 16461 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 16462 
    ;
    
#line 16464 
    ldv_64_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 16465 
    ldv_64_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 16469 
    if (ldv_64_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 16475 
      __VERIFIER_assume(ldv_64_size_cnt <= 2147479552UL);
      
#line 16477 
      (*(ldv_64_container->write))(ldv_64_resource_1,(char const *)ldv_64_ldv_param_1_6,ldv_64_size_cnt,ldv_64_ldv_param_3_7);
    }
    else ;
    
#line 16482 
    ldv_free((void *)ldv_64_ldv_param_3_7);
    
#line 16483 
    ldv_free((void *)ldv_64_ldv_param_1_6);
    
#line 16490 
    goto ldv_call_64;
    case 2: 
#line 16493 
    ;
    
#line 16495 
    if (ldv_64_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 16497 
      (*(ldv_64_container->release))(ldv_64_resource_0,ldv_64_resource_1); else ;
    
#line 16505 
    goto ldv_main_64;
    case 3: 
#line 16508 
    ;
    
#line 16512 
    tmp_9 = ldv_undef_int();
    
#line 16512 
    if (tmp_9 != 0) 
#line 16515 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_64_resource_1,ldv_64_ldv_param_1_2,ldv_64_ldv_param_2_3);
    else {
      
#line 16521 
      ldv_64_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 16522 
      ldv_64_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 16527 
      ldv_emg_wrapper_tx_frag_need_fragmentation_read_3(ldv_64_resource_1,ldv_64_ldv_param_1_4,ldv_64_size_cnt,ldv_64_ldv_param_3_5);
      
#line 16531 
      ldv_free((void *)ldv_64_ldv_param_3_5);
      
#line 16532 
      ldv_free((void *)ldv_64_ldv_param_1_4);
    }
    
#line 16536 
    goto ldv_32633;
    default: 
#line 16538 
    ;
    
#line 16538 
    __VERIFIER_assume(0);
  }
  ldv_32633: 
#line 16547 
  ;
  
#line 16547 
  goto ldv_call_64;
  
#line 16549 
  __retres = (void *)0;
  return_label: 
#line 16549 
                return __retres;
}


#line 16554  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_78(void *arg0)
{
  void *__retres;
  struct file *ldv_78_resource_1;
  int ldv_78_ldv_param_2_3;
  long long ldv_78_ldv_param_1_2;
  char *ldv_78_ldv_param_1_4;
  struct inode *ldv_78_resource_0;
  unsigned long ldv_78_size_cnt;
  long long *ldv_78_ldv_param_3_5;
  char *ldv_78_ldv_param_1_6;
  long long *ldv_78_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 16565 
  struct file_operations *ldv_78_container = ldv_emg_alias_ps_poll_upsd_timeouts_ops_2;
  
#line 16566 
  int ldv_78_ret = ldv_undef_int();
  
#line 16569 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 16573 
  ldv_78_ret = ldv_undef_int();
  
#line 16576 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 16577 
    ldv_78_container = data->arg0;
    
#line 16578 
    ldv_free((void *)data);
  }
  else ;
  
#line 16583 
  ldv_78_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 16584 
  tmp_1 = ldv_undef_int();
  
#line 16584 
  ldv_78_size_cnt = (unsigned long)tmp_1;
  
#line 16591 
  goto ldv_main_78;
  
#line 16593 
  __retres = (void *)0;
  
#line 16593 
  goto return_label;
  ldv_main_78: 
#line 16596 
  ;
  
#line 16599 
  tmp_3 = ldv_undef_int();
  
#line 16599 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 16602 
    ldv_78_ret = (*ldv_emg_alias_simple_open_5)(ldv_78_resource_0,ldv_78_resource_1);
    
#line 16604 
    ldv_78_ret = ldv_filter_err_code(ldv_78_ret);
    
#line 16607 
    tmp_2 = ldv_undef_int();
    
#line 16607 
    if (tmp_2 != 0) {
      
#line 16609 
      __VERIFIER_assume(ldv_78_ret == 0);
      
#line 16616 
      goto ldv_call_78;
    }
    else {
      
#line 16620 
      __VERIFIER_assume(ldv_78_ret != 0);
      
#line 16627 
      goto ldv_main_78;
    }
  }
  else {
    
#line 16632 
    ldv_free((void *)ldv_78_resource_0);
    
#line 16640 
    __retres = (void *)0;
    
#line 16640 
    goto return_label;
  }
  
#line 16643 
  __retres = (void *)0;
  
#line 16643 
  goto return_label;
  ldv_call_78: 
#line 16646 
  ;
  
#line 16649 
  tmp_4 = ldv_undef_int();
  
#line 16649 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 16650 
    ;
    
#line 16652 
    ldv_78_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 16653 
    ldv_78_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 16657 
    if (ldv_78_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 16663 
      __VERIFIER_assume(ldv_78_size_cnt <= 2147479552UL);
      
#line 16665 
      (*(ldv_78_container->write))(ldv_78_resource_1,(char const *)ldv_78_ldv_param_1_6,ldv_78_size_cnt,ldv_78_ldv_param_3_7);
    }
    else ;
    
#line 16670 
    ldv_free((void *)ldv_78_ldv_param_1_6);
    
#line 16671 
    ldv_free((void *)ldv_78_ldv_param_3_7);
    
#line 16678 
    goto ldv_call_78;
    case 2: 
#line 16681 
    ;
    
#line 16683 
    if (ldv_78_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 16685 
      (*(ldv_78_container->release))(ldv_78_resource_0,ldv_78_resource_1); else ;
    
#line 16693 
    goto ldv_main_78;
    case 3: 
#line 16696 
    ;
    
#line 16700 
    tmp_9 = ldv_undef_int();
    
#line 16700 
    if (tmp_9 != 0) 
#line 16703 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_78_resource_1,ldv_78_ldv_param_1_2,ldv_78_ldv_param_2_3);
    else {
      
#line 16709 
      ldv_78_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 16710 
      ldv_78_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 16715 
      ldv_emg_wrapper_ps_poll_upsd_timeouts_read_3(ldv_78_resource_1,ldv_78_ldv_param_1_4,ldv_78_size_cnt,ldv_78_ldv_param_3_5);
      
#line 16719 
      ldv_free((void *)ldv_78_ldv_param_3_5);
      
#line 16720 
      ldv_free((void *)ldv_78_ldv_param_1_4);
    }
    
#line 16724 
    goto ldv_32655;
    default: 
#line 16726 
    ;
    
#line 16726 
    __VERIFIER_assume(0);
  }
  ldv_32655: 
#line 16735 
  ;
  
#line 16735 
  goto ldv_call_78;
  
#line 16737 
  __retres = (void *)0;
  return_label: 
#line 16737 
                return __retres;
}


#line 16742  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_105(void *arg0)
{
  void *__retres;
  struct file *ldv_105_resource_1;
  int ldv_105_ldv_param_2_3;
  long long ldv_105_ldv_param_1_2;
  char *ldv_105_ldv_param_1_4;
  struct inode *ldv_105_resource_0;
  unsigned long ldv_105_size_cnt;
  long long *ldv_105_ldv_param_3_5;
  char *ldv_105_ldv_param_1_6;
  long long *ldv_105_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 16753 
  struct file_operations *ldv_105_container = ldv_emg_alias_rx_defrag_need_decrypt_ops_2;
  
#line 16754 
  int ldv_105_ret = ldv_undef_int();
  
#line 16757 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 16761 
  ldv_105_ret = ldv_undef_int();
  
#line 16764 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 16765 
    ldv_105_container = data->arg0;
    
#line 16766 
    ldv_free((void *)data);
  }
  else ;
  
#line 16771 
  ldv_105_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 16772 
  tmp_1 = ldv_undef_int();
  
#line 16772 
  ldv_105_size_cnt = (unsigned long)tmp_1;
  
#line 16779 
  goto ldv_main_105;
  
#line 16781 
  __retres = (void *)0;
  
#line 16781 
  goto return_label;
  ldv_main_105: 
#line 16784 
  ;
  
#line 16787 
  tmp_3 = ldv_undef_int();
  
#line 16787 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 16790 
    ldv_105_ret = (*ldv_emg_alias_simple_open_5)(ldv_105_resource_0,ldv_105_resource_1);
    
#line 16792 
    ldv_105_ret = ldv_filter_err_code(ldv_105_ret);
    
#line 16795 
    tmp_2 = ldv_undef_int();
    
#line 16795 
    if (tmp_2 != 0) {
      
#line 16797 
      __VERIFIER_assume(ldv_105_ret == 0);
      
#line 16804 
      goto ldv_call_105;
    }
    else {
      
#line 16808 
      __VERIFIER_assume(ldv_105_ret != 0);
      
#line 16815 
      goto ldv_main_105;
    }
  }
  else {
    
#line 16820 
    ldv_free((void *)ldv_105_resource_0);
    
#line 16828 
    __retres = (void *)0;
    
#line 16828 
    goto return_label;
  }
  
#line 16831 
  __retres = (void *)0;
  
#line 16831 
  goto return_label;
  ldv_call_105: 
#line 16834 
  ;
  
#line 16837 
  tmp_4 = ldv_undef_int();
  
#line 16837 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 16838 
    ;
    
#line 16840 
    ldv_105_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 16841 
    ldv_105_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 16845 
    if (ldv_105_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 16851 
      __VERIFIER_assume(ldv_105_size_cnt <= 2147479552UL);
      
#line 16853 
      (*(ldv_105_container->write))(ldv_105_resource_1,(char const *)ldv_105_ldv_param_1_6,ldv_105_size_cnt,ldv_105_ldv_param_3_7);
    }
    else ;
    
#line 16858 
    ldv_free((void *)ldv_105_ldv_param_1_6);
    
#line 16859 
    ldv_free((void *)ldv_105_ldv_param_3_7);
    
#line 16866 
    goto ldv_call_105;
    case 2: 
#line 16869 
    ;
    
#line 16871 
    if (ldv_105_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 16873 
      (*(ldv_105_container->release))(ldv_105_resource_0,ldv_105_resource_1); else ;
    
#line 16881 
    goto ldv_main_105;
    case 3: 
#line 16884 
    ;
    
#line 16888 
    tmp_9 = ldv_undef_int();
    
#line 16888 
    if (tmp_9 != 0) 
#line 16891 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_105_resource_1,ldv_105_ldv_param_1_2,ldv_105_ldv_param_2_3);
    else {
      
#line 16897 
      ldv_105_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 16898 
      ldv_105_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 16903 
      ldv_emg_wrapper_rx_defrag_need_decrypt_read_3(ldv_105_resource_1,ldv_105_ldv_param_1_4,ldv_105_size_cnt,ldv_105_ldv_param_3_5);
      
#line 16907 
      ldv_free((void *)ldv_105_ldv_param_1_4);
      
#line 16908 
      ldv_free((void *)ldv_105_ldv_param_3_5);
    }
    
#line 16912 
    goto ldv_32677;
    default: 
#line 16914 
    ;
    
#line 16914 
    __VERIFIER_assume(0);
  }
  ldv_32677: 
#line 16923 
  ;
  
#line 16923 
  goto ldv_call_105;
  
#line 16925 
  __retres = (void *)0;
  return_label: 
#line 16925 
                return __retres;
}


#line 16930  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_112(void *arg0)
{
  void *__retres;
  struct file *ldv_112_resource_1;
  int ldv_112_ldv_param_2_3;
  long long ldv_112_ldv_param_1_2;
  char *ldv_112_ldv_param_1_4;
  struct inode *ldv_112_resource_0;
  unsigned long ldv_112_size_cnt;
  long long *ldv_112_ldv_param_3_5;
  char *ldv_112_ldv_param_1_6;
  long long *ldv_112_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 16941 
  struct file_operations *ldv_112_container = ldv_emg_alias_mem_fwlog_free_mem_blks_ops_2;
  
#line 16942 
  int ldv_112_ret = ldv_undef_int();
  
#line 16945 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 16949 
  ldv_112_ret = ldv_undef_int();
  
#line 16952 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 16953 
    ldv_112_container = data->arg0;
    
#line 16954 
    ldv_free((void *)data);
  }
  else ;
  
#line 16959 
  ldv_112_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 16960 
  tmp_1 = ldv_undef_int();
  
#line 16960 
  ldv_112_size_cnt = (unsigned long)tmp_1;
  
#line 16967 
  goto ldv_main_112;
  
#line 16969 
  __retres = (void *)0;
  
#line 16969 
  goto return_label;
  ldv_main_112: 
#line 16972 
  ;
  
#line 16975 
  tmp_3 = ldv_undef_int();
  
#line 16975 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 16978 
    ldv_112_ret = (*ldv_emg_alias_simple_open_5)(ldv_112_resource_0,ldv_112_resource_1);
    
#line 16980 
    ldv_112_ret = ldv_filter_err_code(ldv_112_ret);
    
#line 16983 
    tmp_2 = ldv_undef_int();
    
#line 16983 
    if (tmp_2 != 0) {
      
#line 16985 
      __VERIFIER_assume(ldv_112_ret == 0);
      
#line 16992 
      goto ldv_call_112;
    }
    else {
      
#line 16996 
      __VERIFIER_assume(ldv_112_ret != 0);
      
#line 17003 
      goto ldv_main_112;
    }
  }
  else {
    
#line 17008 
    ldv_free((void *)ldv_112_resource_0);
    
#line 17016 
    __retres = (void *)0;
    
#line 17016 
    goto return_label;
  }
  
#line 17019 
  __retres = (void *)0;
  
#line 17019 
  goto return_label;
  ldv_call_112: 
#line 17022 
  ;
  
#line 17025 
  tmp_4 = ldv_undef_int();
  
#line 17025 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 17026 
    ;
    
#line 17028 
    ldv_112_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 17029 
    ldv_112_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 17033 
    if (ldv_112_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 17039 
      __VERIFIER_assume(ldv_112_size_cnt <= 2147479552UL);
      
#line 17041 
      (*(ldv_112_container->write))(ldv_112_resource_1,(char const *)ldv_112_ldv_param_1_6,ldv_112_size_cnt,ldv_112_ldv_param_3_7);
    }
    else ;
    
#line 17046 
    ldv_free((void *)ldv_112_ldv_param_1_6);
    
#line 17047 
    ldv_free((void *)ldv_112_ldv_param_3_7);
    
#line 17054 
    goto ldv_call_112;
    case 2: 
#line 17057 
    ;
    
#line 17059 
    if (ldv_112_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 17061 
      (*(ldv_112_container->release))(ldv_112_resource_0,ldv_112_resource_1); else ;
    
#line 17069 
    goto ldv_main_112;
    case 3: 
#line 17072 
    ;
    
#line 17076 
    tmp_9 = ldv_undef_int();
    
#line 17076 
    if (tmp_9 != 0) 
#line 17079 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_112_resource_1,ldv_112_ldv_param_1_2,ldv_112_ldv_param_2_3);
    else {
      
#line 17085 
      ldv_112_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 17086 
      ldv_112_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 17091 
      ldv_emg_wrapper_mem_fwlog_free_mem_blks_read_3(ldv_112_resource_1,ldv_112_ldv_param_1_4,ldv_112_size_cnt,ldv_112_ldv_param_3_5);
      
#line 17095 
      ldv_free((void *)ldv_112_ldv_param_1_4);
      
#line 17096 
      ldv_free((void *)ldv_112_ldv_param_3_5);
    }
    
#line 17100 
    goto ldv_32699;
    default: 
#line 17102 
    ;
    
#line 17102 
    __VERIFIER_assume(0);
  }
  ldv_32699: 
#line 17111 
  ;
  
#line 17111 
  goto ldv_call_112;
  
#line 17113 
  __retres = (void *)0;
  return_label: 
#line 17113 
                return __retres;
}


#line 17118  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
struct dentry *ldv_emg_debugfs_create_file(char *arg0, unsigned short arg1, struct dentry *arg2, void *arg3, struct file_operations *arg4)
{
  struct dentry *__retres;
  struct dentry *ldv_4_dentry;
  struct file_operations *ldv_4_file_operations;
  int tmp_1;
  
#line 17126 
  tmp_1 = ldv_undef_int();
  
#line 17126 
  if (tmp_1 != 0) {
    
#line 17128 
    ldv_4_dentry = (struct dentry *)ldv_xmalloc_unknown_size(0UL);
    
#line 17129 
    ldv_4_file_operations = arg4;
    
#line 17133 
    ldv_dispatch_register_4_3(ldv_4_file_operations);
    
#line 17137 
    __retres = ldv_4_dentry;
    
#line 17137 
    goto return_label;
  }
  else {
    struct dentry *tmp_0;
    
#line 17144 
    tmp_0 = (struct dentry *)ERR_PTR(-19L);
    
#line 17144 
    __retres = tmp_0;
    
#line 17144 
    goto return_label;
  }
  return_label: 
#line 17126 
                return __retres;
}


#line 17154  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_pm_register_108_13(void)
{
  int ret;
  struct ldv_struct_platform_instance_108 *cf_arg_81;
  int tmp;
  
#line 17157 
  tmp = ldv_undef_int();
  
#line 17157 
  switch (tmp) {
    case 0: 
#line 17158 
    ;
    
#line 17159 
    cf_arg_81 = (struct ldv_struct_platform_instance_108 *)ldv_xmalloc(16UL);
    
#line 17160 
    ret = pthread_create(& ldv_thread_81,(pthread_attr_t const *)0,& ldv_pm_ops_scenario_81,(void *)cf_arg_81);
    
#line 17161 
    __VERIFIER_assume(ret == 0);
    
#line 17162 
    goto ldv_32716;
    default: 
#line 17164 
    ;
    
#line 17164 
    __VERIFIER_assume(0);
  }
  ldv_32716: 
#line 17165 
  ;
  
#line 17166 
  return;
}


#line 17170  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_14(void *arg0)
{
  void *__retres;
  struct file *ldv_14_resource_1;
  int ldv_14_ldv_param_2_3;
  long long ldv_14_ldv_param_1_2;
  char *ldv_14_ldv_param_1_4;
  struct inode *ldv_14_resource_0;
  unsigned long ldv_14_size_cnt;
  long long *ldv_14_ldv_param_3_5;
  char *ldv_14_ldv_param_1_6;
  long long *ldv_14_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 17181 
  struct file_operations *ldv_14_container = ldv_emg_alias_tx_tx_burst_programmed_ops_2;
  
#line 17182 
  int ldv_14_ret = ldv_undef_int();
  
#line 17185 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 17189 
  ldv_14_ret = ldv_undef_int();
  
#line 17192 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 17193 
    ldv_14_container = data->arg0;
    
#line 17194 
    ldv_free((void *)data);
  }
  else ;
  
#line 17199 
  ldv_14_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 17200 
  tmp_1 = ldv_undef_int();
  
#line 17200 
  ldv_14_size_cnt = (unsigned long)tmp_1;
  
#line 17207 
  goto ldv_main_14;
  
#line 17209 
  __retres = (void *)0;
  
#line 17209 
  goto return_label;
  ldv_main_14: 
#line 17212 
  ;
  
#line 17215 
  tmp_3 = ldv_undef_int();
  
#line 17215 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 17218 
    ldv_14_ret = (*ldv_emg_alias_simple_open_5)(ldv_14_resource_0,ldv_14_resource_1);
    
#line 17220 
    ldv_14_ret = ldv_filter_err_code(ldv_14_ret);
    
#line 17223 
    tmp_2 = ldv_undef_int();
    
#line 17223 
    if (tmp_2 != 0) {
      
#line 17225 
      __VERIFIER_assume(ldv_14_ret == 0);
      
#line 17232 
      goto ldv_call_14;
    }
    else {
      
#line 17236 
      __VERIFIER_assume(ldv_14_ret != 0);
      
#line 17243 
      goto ldv_main_14;
    }
  }
  else {
    
#line 17248 
    ldv_free((void *)ldv_14_resource_0);
    
#line 17256 
    __retres = (void *)0;
    
#line 17256 
    goto return_label;
  }
  
#line 17259 
  __retres = (void *)0;
  
#line 17259 
  goto return_label;
  ldv_call_14: 
#line 17262 
  ;
  
#line 17265 
  tmp_4 = ldv_undef_int();
  
#line 17265 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 17266 
    ;
    
#line 17268 
    ldv_14_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 17269 
    ldv_14_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 17273 
    if (ldv_14_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 17279 
      __VERIFIER_assume(ldv_14_size_cnt <= 2147479552UL);
      
#line 17281 
      (*(ldv_14_container->write))(ldv_14_resource_1,(char const *)ldv_14_ldv_param_1_6,ldv_14_size_cnt,ldv_14_ldv_param_3_7);
    }
    else ;
    
#line 17286 
    ldv_free((void *)ldv_14_ldv_param_3_7);
    
#line 17287 
    ldv_free((void *)ldv_14_ldv_param_1_6);
    
#line 17294 
    goto ldv_call_14;
    case 2: 
#line 17297 
    ;
    
#line 17299 
    if (ldv_14_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 17301 
      (*(ldv_14_container->release))(ldv_14_resource_0,ldv_14_resource_1); else ;
    
#line 17309 
    goto ldv_main_14;
    case 3: 
#line 17312 
    ;
    
#line 17316 
    tmp_9 = ldv_undef_int();
    
#line 17316 
    if (tmp_9 != 0) 
#line 17319 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_14_resource_1,ldv_14_ldv_param_1_2,ldv_14_ldv_param_2_3);
    else {
      
#line 17325 
      ldv_14_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 17326 
      ldv_14_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 17331 
      ldv_emg_wrapper_tx_tx_burst_programmed_read_3(ldv_14_resource_1,ldv_14_ldv_param_1_4,ldv_14_size_cnt,ldv_14_ldv_param_3_5);
      
#line 17335 
      ldv_free((void *)ldv_14_ldv_param_1_4);
      
#line 17336 
      ldv_free((void *)ldv_14_ldv_param_3_5);
    }
    
#line 17340 
    goto ldv_32738;
    default: 
#line 17342 
    ;
    
#line 17342 
    __VERIFIER_assume(0);
  }
  ldv_32738: 
#line 17351 
  ;
  
#line 17351 
  goto ldv_call_14;
  
#line 17353 
  __retres = (void *)0;
  return_label: 
#line 17353 
                return __retres;
}


#line 17358  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_127(void *arg0)
{
  void *__retres;
  struct file *ldv_127_resource_1;
  int ldv_127_ldv_param_2_3;
  long long ldv_127_ldv_param_1_2;
  char *ldv_127_ldv_param_1_4;
  struct inode *ldv_127_resource_0;
  unsigned long ldv_127_size_cnt;
  long long *ldv_127_ldv_param_3_5;
  char *ldv_127_ldv_param_1_6;
  long long *ldv_127_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 17369 
  struct file_operations *ldv_127_container = ldv_emg_alias_rx_filter_beacon_filter_ops_2;
  
#line 17370 
  int ldv_127_ret = ldv_undef_int();
  
#line 17373 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 17377 
  ldv_127_ret = ldv_undef_int();
  
#line 17380 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 17381 
    ldv_127_container = data->arg0;
    
#line 17382 
    ldv_free((void *)data);
  }
  else ;
  
#line 17387 
  ldv_127_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 17388 
  tmp_1 = ldv_undef_int();
  
#line 17388 
  ldv_127_size_cnt = (unsigned long)tmp_1;
  
#line 17395 
  goto ldv_main_127;
  
#line 17397 
  __retres = (void *)0;
  
#line 17397 
  goto return_label;
  ldv_main_127: 
#line 17400 
  ;
  
#line 17403 
  tmp_3 = ldv_undef_int();
  
#line 17403 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 17406 
    ldv_127_ret = (*ldv_emg_alias_simple_open_5)(ldv_127_resource_0,ldv_127_resource_1);
    
#line 17408 
    ldv_127_ret = ldv_filter_err_code(ldv_127_ret);
    
#line 17411 
    tmp_2 = ldv_undef_int();
    
#line 17411 
    if (tmp_2 != 0) {
      
#line 17413 
      __VERIFIER_assume(ldv_127_ret == 0);
      
#line 17420 
      goto ldv_call_127;
    }
    else {
      
#line 17424 
      __VERIFIER_assume(ldv_127_ret != 0);
      
#line 17431 
      goto ldv_main_127;
    }
  }
  else {
    
#line 17436 
    ldv_free((void *)ldv_127_resource_0);
    
#line 17444 
    __retres = (void *)0;
    
#line 17444 
    goto return_label;
  }
  
#line 17447 
  __retres = (void *)0;
  
#line 17447 
  goto return_label;
  ldv_call_127: 
#line 17450 
  ;
  
#line 17453 
  tmp_4 = ldv_undef_int();
  
#line 17453 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 17454 
    ;
    
#line 17456 
    ldv_127_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 17457 
    ldv_127_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 17461 
    if (ldv_127_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 17467 
      __VERIFIER_assume(ldv_127_size_cnt <= 2147479552UL);
      
#line 17469 
      (*(ldv_127_container->write))(ldv_127_resource_1,(char const *)ldv_127_ldv_param_1_6,ldv_127_size_cnt,ldv_127_ldv_param_3_7);
    }
    else ;
    
#line 17474 
    ldv_free((void *)ldv_127_ldv_param_1_6);
    
#line 17475 
    ldv_free((void *)ldv_127_ldv_param_3_7);
    
#line 17482 
    goto ldv_call_127;
    case 2: 
#line 17485 
    ;
    
#line 17487 
    if (ldv_127_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 17489 
      (*(ldv_127_container->release))(ldv_127_resource_0,ldv_127_resource_1); else ;
    
#line 17497 
    goto ldv_main_127;
    case 3: 
#line 17500 
    ;
    
#line 17504 
    tmp_9 = ldv_undef_int();
    
#line 17504 
    if (tmp_9 != 0) 
#line 17507 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_127_resource_1,ldv_127_ldv_param_1_2,ldv_127_ldv_param_2_3);
    else {
      
#line 17513 
      ldv_127_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 17514 
      ldv_127_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 17519 
      ldv_emg_wrapper_rx_filter_beacon_filter_read_3(ldv_127_resource_1,ldv_127_ldv_param_1_4,ldv_127_size_cnt,ldv_127_ldv_param_3_5);
      
#line 17523 
      ldv_free((void *)ldv_127_ldv_param_3_5);
      
#line 17524 
      ldv_free((void *)ldv_127_ldv_param_1_4);
    }
    
#line 17528 
    goto ldv_32760;
    default: 
#line 17530 
    ;
    
#line 17530 
    __VERIFIER_assume(0);
  }
  ldv_32760: 
#line 17539 
  ;
  
#line 17539 
  goto ldv_call_127;
  
#line 17541 
  __retres = (void *)0;
  return_label: 
#line 17541 
                return __retres;
}


#line 17546  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_47(void *arg0)
{
  void *__retres;
  struct file *ldv_47_resource_1;
  int ldv_47_ldv_param_2_3;
  long long ldv_47_ldv_param_1_2;
  char *ldv_47_ldv_param_1_4;
  struct inode *ldv_47_resource_0;
  unsigned long ldv_47_size_cnt;
  long long *ldv_47_ldv_param_3_5;
  char *ldv_47_ldv_param_1_6;
  long long *ldv_47_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 17557 
  struct file_operations *ldv_47_container = ldv_emg_alias_rx_defrag_tkip_called_ops_2;
  
#line 17558 
  int ldv_47_ret = ldv_undef_int();
  
#line 17561 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 17565 
  ldv_47_ret = ldv_undef_int();
  
#line 17568 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 17569 
    ldv_47_container = data->arg0;
    
#line 17570 
    ldv_free((void *)data);
  }
  else ;
  
#line 17575 
  ldv_47_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 17576 
  tmp_1 = ldv_undef_int();
  
#line 17576 
  ldv_47_size_cnt = (unsigned long)tmp_1;
  
#line 17583 
  goto ldv_main_47;
  
#line 17585 
  __retres = (void *)0;
  
#line 17585 
  goto return_label;
  ldv_main_47: 
#line 17588 
  ;
  
#line 17591 
  tmp_3 = ldv_undef_int();
  
#line 17591 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 17594 
    ldv_47_ret = (*ldv_emg_alias_simple_open_5)(ldv_47_resource_0,ldv_47_resource_1);
    
#line 17596 
    ldv_47_ret = ldv_filter_err_code(ldv_47_ret);
    
#line 17599 
    tmp_2 = ldv_undef_int();
    
#line 17599 
    if (tmp_2 != 0) {
      
#line 17601 
      __VERIFIER_assume(ldv_47_ret == 0);
      
#line 17608 
      goto ldv_call_47;
    }
    else {
      
#line 17612 
      __VERIFIER_assume(ldv_47_ret != 0);
      
#line 17619 
      goto ldv_main_47;
    }
  }
  else {
    
#line 17624 
    ldv_free((void *)ldv_47_resource_0);
    
#line 17632 
    __retres = (void *)0;
    
#line 17632 
    goto return_label;
  }
  
#line 17635 
  __retres = (void *)0;
  
#line 17635 
  goto return_label;
  ldv_call_47: 
#line 17638 
  ;
  
#line 17641 
  tmp_4 = ldv_undef_int();
  
#line 17641 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 17642 
    ;
    
#line 17644 
    ldv_47_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 17645 
    ldv_47_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 17649 
    if (ldv_47_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 17655 
      __VERIFIER_assume(ldv_47_size_cnt <= 2147479552UL);
      
#line 17657 
      (*(ldv_47_container->write))(ldv_47_resource_1,(char const *)ldv_47_ldv_param_1_6,ldv_47_size_cnt,ldv_47_ldv_param_3_7);
    }
    else ;
    
#line 17662 
    ldv_free((void *)ldv_47_ldv_param_3_7);
    
#line 17663 
    ldv_free((void *)ldv_47_ldv_param_1_6);
    
#line 17670 
    goto ldv_call_47;
    case 2: 
#line 17673 
    ;
    
#line 17675 
    if (ldv_47_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 17677 
      (*(ldv_47_container->release))(ldv_47_resource_0,ldv_47_resource_1); else ;
    
#line 17685 
    goto ldv_main_47;
    case 3: 
#line 17688 
    ;
    
#line 17692 
    tmp_9 = ldv_undef_int();
    
#line 17692 
    if (tmp_9 != 0) 
#line 17695 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_47_resource_1,ldv_47_ldv_param_1_2,ldv_47_ldv_param_2_3);
    else {
      
#line 17701 
      ldv_47_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 17702 
      ldv_47_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 17707 
      ldv_emg_wrapper_rx_defrag_tkip_called_read_3(ldv_47_resource_1,ldv_47_ldv_param_1_4,ldv_47_size_cnt,ldv_47_ldv_param_3_5);
      
#line 17711 
      ldv_free((void *)ldv_47_ldv_param_1_4);
      
#line 17712 
      ldv_free((void *)ldv_47_ldv_param_3_5);
    }
    
#line 17716 
    goto ldv_32782;
    default: 
#line 17718 
    ;
    
#line 17718 
    __VERIFIER_assume(0);
  }
  ldv_32782: 
#line 17727 
  ;
  
#line 17727 
  goto ldv_call_47;
  
#line 17729 
  __retres = (void *)0;
  return_label: 
#line 17729 
                return __retres;
}


#line 17734  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_58(void *arg0)
{
  void *__retres;
  struct file *ldv_58_resource_1;
  int ldv_58_ldv_param_2_3;
  long long ldv_58_ldv_param_1_2;
  char *ldv_58_ldv_param_1_4;
  struct inode *ldv_58_resource_0;
  unsigned long ldv_58_size_cnt;
  long long *ldv_58_ldv_param_3_5;
  char *ldv_58_ldv_param_1_6;
  long long *ldv_58_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 17745 
  struct file_operations *ldv_58_container = ldv_emg_alias_pipeline_enc_tx_stat_fifo_int_ops_2;
  
#line 17746 
  int ldv_58_ret = ldv_undef_int();
  
#line 17749 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 17753 
  ldv_58_ret = ldv_undef_int();
  
#line 17756 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 17757 
    ldv_58_container = data->arg0;
    
#line 17758 
    ldv_free((void *)data);
  }
  else ;
  
#line 17763 
  ldv_58_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 17764 
  tmp_1 = ldv_undef_int();
  
#line 17764 
  ldv_58_size_cnt = (unsigned long)tmp_1;
  
#line 17771 
  goto ldv_main_58;
  
#line 17773 
  __retres = (void *)0;
  
#line 17773 
  goto return_label;
  ldv_main_58: 
#line 17776 
  ;
  
#line 17779 
  tmp_3 = ldv_undef_int();
  
#line 17779 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 17782 
    ldv_58_ret = (*ldv_emg_alias_simple_open_5)(ldv_58_resource_0,ldv_58_resource_1);
    
#line 17784 
    ldv_58_ret = ldv_filter_err_code(ldv_58_ret);
    
#line 17787 
    tmp_2 = ldv_undef_int();
    
#line 17787 
    if (tmp_2 != 0) {
      
#line 17789 
      __VERIFIER_assume(ldv_58_ret == 0);
      
#line 17796 
      goto ldv_call_58;
    }
    else {
      
#line 17800 
      __VERIFIER_assume(ldv_58_ret != 0);
      
#line 17807 
      goto ldv_main_58;
    }
  }
  else {
    
#line 17812 
    ldv_free((void *)ldv_58_resource_0);
    
#line 17820 
    __retres = (void *)0;
    
#line 17820 
    goto return_label;
  }
  
#line 17823 
  __retres = (void *)0;
  
#line 17823 
  goto return_label;
  ldv_call_58: 
#line 17826 
  ;
  
#line 17829 
  tmp_4 = ldv_undef_int();
  
#line 17829 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 17830 
    ;
    
#line 17832 
    ldv_58_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 17833 
    ldv_58_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 17837 
    if (ldv_58_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 17843 
      __VERIFIER_assume(ldv_58_size_cnt <= 2147479552UL);
      
#line 17845 
      (*(ldv_58_container->write))(ldv_58_resource_1,(char const *)ldv_58_ldv_param_1_6,ldv_58_size_cnt,ldv_58_ldv_param_3_7);
    }
    else ;
    
#line 17850 
    ldv_free((void *)ldv_58_ldv_param_1_6);
    
#line 17851 
    ldv_free((void *)ldv_58_ldv_param_3_7);
    
#line 17858 
    goto ldv_call_58;
    case 2: 
#line 17861 
    ;
    
#line 17863 
    if (ldv_58_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 17865 
      (*(ldv_58_container->release))(ldv_58_resource_0,ldv_58_resource_1); else ;
    
#line 17873 
    goto ldv_main_58;
    case 3: 
#line 17876 
    ;
    
#line 17880 
    tmp_9 = ldv_undef_int();
    
#line 17880 
    if (tmp_9 != 0) 
#line 17883 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_58_resource_1,ldv_58_ldv_param_1_2,ldv_58_ldv_param_2_3);
    else {
      
#line 17889 
      ldv_58_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 17890 
      ldv_58_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 17895 
      ldv_emg_wrapper_pipeline_enc_tx_stat_fifo_int_read_3(ldv_58_resource_1,ldv_58_ldv_param_1_4,ldv_58_size_cnt,ldv_58_ldv_param_3_5);
      
#line 17899 
      ldv_free((void *)ldv_58_ldv_param_1_4);
      
#line 17900 
      ldv_free((void *)ldv_58_ldv_param_3_5);
    }
    
#line 17904 
    goto ldv_32804;
    default: 
#line 17906 
    ;
    
#line 17906 
    __VERIFIER_assume(0);
  }
  ldv_32804: 
#line 17915 
  ;
  
#line 17915 
  goto ldv_call_58;
  
#line 17917 
  __retres = (void *)0;
  return_label: 
#line 17917 
                return __retres;
}


#line 17922  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_9(void *arg0)
{
  void *__retres;
  struct file *ldv_9_resource_1;
  int ldv_9_ldv_param_2_3;
  long long ldv_9_ldv_param_1_2;
  char *ldv_9_ldv_param_1_4;
  struct inode *ldv_9_resource_0;
  unsigned long ldv_9_size_cnt;
  long long *ldv_9_ldv_param_3_5;
  char *ldv_9_ldv_param_1_6;
  long long *ldv_9_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 17933 
  struct file_operations *ldv_9_container = ldv_emg_alias_tx_frag_cache_miss_ops_2;
  
#line 17934 
  int ldv_9_ret = ldv_undef_int();
  
#line 17937 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 17941 
  ldv_9_ret = ldv_undef_int();
  
#line 17944 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 17945 
    ldv_9_container = data->arg0;
    
#line 17946 
    ldv_free((void *)data);
  }
  else ;
  
#line 17951 
  ldv_9_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 17952 
  tmp_1 = ldv_undef_int();
  
#line 17952 
  ldv_9_size_cnt = (unsigned long)tmp_1;
  
#line 17959 
  goto ldv_main_9;
  
#line 17961 
  __retres = (void *)0;
  
#line 17961 
  goto return_label;
  ldv_main_9: 
#line 17964 
  ;
  
#line 17967 
  tmp_3 = ldv_undef_int();
  
#line 17967 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 17970 
    ldv_9_ret = (*ldv_emg_alias_simple_open_5)(ldv_9_resource_0,ldv_9_resource_1);
    
#line 17972 
    ldv_9_ret = ldv_filter_err_code(ldv_9_ret);
    
#line 17975 
    tmp_2 = ldv_undef_int();
    
#line 17975 
    if (tmp_2 != 0) {
      
#line 17977 
      __VERIFIER_assume(ldv_9_ret == 0);
      
#line 17984 
      goto ldv_call_9;
    }
    else {
      
#line 17988 
      __VERIFIER_assume(ldv_9_ret != 0);
      
#line 17995 
      goto ldv_main_9;
    }
  }
  else {
    
#line 18000 
    ldv_free((void *)ldv_9_resource_0);
    
#line 18008 
    __retres = (void *)0;
    
#line 18008 
    goto return_label;
  }
  
#line 18011 
  __retres = (void *)0;
  
#line 18011 
  goto return_label;
  ldv_call_9: 
#line 18014 
  ;
  
#line 18017 
  tmp_4 = ldv_undef_int();
  
#line 18017 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 18018 
    ;
    
#line 18020 
    ldv_9_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 18021 
    ldv_9_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 18025 
    if (ldv_9_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 18031 
      __VERIFIER_assume(ldv_9_size_cnt <= 2147479552UL);
      
#line 18033 
      (*(ldv_9_container->write))(ldv_9_resource_1,(char const *)ldv_9_ldv_param_1_6,ldv_9_size_cnt,ldv_9_ldv_param_3_7);
    }
    else ;
    
#line 18038 
    ldv_free((void *)ldv_9_ldv_param_3_7);
    
#line 18039 
    ldv_free((void *)ldv_9_ldv_param_1_6);
    
#line 18046 
    goto ldv_call_9;
    case 2: 
#line 18049 
    ;
    
#line 18051 
    if (ldv_9_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 18053 
      (*(ldv_9_container->release))(ldv_9_resource_0,ldv_9_resource_1); else ;
    
#line 18061 
    goto ldv_main_9;
    case 3: 
#line 18064 
    ;
    
#line 18068 
    tmp_9 = ldv_undef_int();
    
#line 18068 
    if (tmp_9 != 0) 
#line 18071 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_9_resource_1,ldv_9_ldv_param_1_2,ldv_9_ldv_param_2_3);
    else {
      
#line 18077 
      ldv_9_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 18078 
      ldv_9_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 18083 
      ldv_emg_wrapper_tx_frag_cache_miss_read_3(ldv_9_resource_1,ldv_9_ldv_param_1_4,ldv_9_size_cnt,ldv_9_ldv_param_3_5);
      
#line 18087 
      ldv_free((void *)ldv_9_ldv_param_1_4);
      
#line 18088 
      ldv_free((void *)ldv_9_ldv_param_3_5);
    }
    
#line 18092 
    goto ldv_32826;
    default: 
#line 18094 
    ;
    
#line 18094 
    __VERIFIER_assume(0);
  }
  ldv_32826: 
#line 18103 
  ;
  
#line 18103 
  goto ldv_call_9;
  
#line 18105 
  __retres = (void *)0;
  return_label: 
#line 18105 
                return __retres;
}


#line 18110  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_61(void *arg0)
{
  void *__retres;
  struct file *ldv_61_resource_1;
  int ldv_61_ldv_param_2_3;
  long long ldv_61_ldv_param_1_2;
  char *ldv_61_ldv_param_1_4;
  struct inode *ldv_61_resource_0;
  unsigned long ldv_61_size_cnt;
  long long *ldv_61_ldv_param_3_5;
  char *ldv_61_ldv_param_1_6;
  long long *ldv_61_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 18121 
  struct file_operations *ldv_61_container = ldv_emg_alias_ps_poll_ps_poll_max_ap_turn_ops_2;
  
#line 18122 
  int ldv_61_ret = ldv_undef_int();
  
#line 18125 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 18129 
  ldv_61_ret = ldv_undef_int();
  
#line 18132 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 18133 
    ldv_61_container = data->arg0;
    
#line 18134 
    ldv_free((void *)data);
  }
  else ;
  
#line 18139 
  ldv_61_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 18140 
  tmp_1 = ldv_undef_int();
  
#line 18140 
  ldv_61_size_cnt = (unsigned long)tmp_1;
  
#line 18147 
  goto ldv_main_61;
  
#line 18149 
  __retres = (void *)0;
  
#line 18149 
  goto return_label;
  ldv_main_61: 
#line 18152 
  ;
  
#line 18155 
  tmp_3 = ldv_undef_int();
  
#line 18155 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 18158 
    ldv_61_ret = (*ldv_emg_alias_simple_open_5)(ldv_61_resource_0,ldv_61_resource_1);
    
#line 18160 
    ldv_61_ret = ldv_filter_err_code(ldv_61_ret);
    
#line 18163 
    tmp_2 = ldv_undef_int();
    
#line 18163 
    if (tmp_2 != 0) {
      
#line 18165 
      __VERIFIER_assume(ldv_61_ret == 0);
      
#line 18172 
      goto ldv_call_61;
    }
    else {
      
#line 18176 
      __VERIFIER_assume(ldv_61_ret != 0);
      
#line 18183 
      goto ldv_main_61;
    }
  }
  else {
    
#line 18188 
    ldv_free((void *)ldv_61_resource_0);
    
#line 18196 
    __retres = (void *)0;
    
#line 18196 
    goto return_label;
  }
  
#line 18199 
  __retres = (void *)0;
  
#line 18199 
  goto return_label;
  ldv_call_61: 
#line 18202 
  ;
  
#line 18205 
  tmp_4 = ldv_undef_int();
  
#line 18205 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 18206 
    ;
    
#line 18208 
    ldv_61_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 18209 
    ldv_61_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 18213 
    if (ldv_61_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 18219 
      __VERIFIER_assume(ldv_61_size_cnt <= 2147479552UL);
      
#line 18221 
      (*(ldv_61_container->write))(ldv_61_resource_1,(char const *)ldv_61_ldv_param_1_6,ldv_61_size_cnt,ldv_61_ldv_param_3_7);
    }
    else ;
    
#line 18226 
    ldv_free((void *)ldv_61_ldv_param_3_7);
    
#line 18227 
    ldv_free((void *)ldv_61_ldv_param_1_6);
    
#line 18234 
    goto ldv_call_61;
    case 2: 
#line 18237 
    ;
    
#line 18239 
    if (ldv_61_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 18241 
      (*(ldv_61_container->release))(ldv_61_resource_0,ldv_61_resource_1); else ;
    
#line 18249 
    goto ldv_main_61;
    case 3: 
#line 18252 
    ;
    
#line 18256 
    tmp_9 = ldv_undef_int();
    
#line 18256 
    if (tmp_9 != 0) 
#line 18259 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_61_resource_1,ldv_61_ldv_param_1_2,ldv_61_ldv_param_2_3);
    else {
      
#line 18265 
      ldv_61_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 18266 
      ldv_61_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 18271 
      ldv_emg_wrapper_ps_poll_ps_poll_max_ap_turn_read_3(ldv_61_resource_1,ldv_61_ldv_param_1_4,ldv_61_size_cnt,ldv_61_ldv_param_3_5);
      
#line 18275 
      ldv_free((void *)ldv_61_ldv_param_1_4);
      
#line 18276 
      ldv_free((void *)ldv_61_ldv_param_3_5);
    }
    
#line 18280 
    goto ldv_32848;
    default: 
#line 18282 
    ;
    
#line 18282 
    __VERIFIER_assume(0);
  }
  ldv_32848: 
#line 18291 
  ;
  
#line 18291 
  goto ldv_call_61;
  
#line 18293 
  __retres = (void *)0;
  return_label: 
#line 18293 
                return __retres;
}


#line 18298  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_76(void *arg0)
{
  void *__retres;
  struct file *ldv_76_resource_1;
  int ldv_76_ldv_param_2_3;
  long long ldv_76_ldv_param_1_2;
  char *ldv_76_ldv_param_1_4;
  struct inode *ldv_76_resource_0;
  unsigned long ldv_76_size_cnt;
  long long *ldv_76_ldv_param_3_5;
  char *ldv_76_ldv_param_1_6;
  long long *ldv_76_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 18309 
  struct file_operations *ldv_76_container = ldv_emg_alias_tx_tx_frame_checksum_ops_2;
  
#line 18310 
  int ldv_76_ret = ldv_undef_int();
  
#line 18313 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 18317 
  ldv_76_ret = ldv_undef_int();
  
#line 18320 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 18321 
    ldv_76_container = data->arg0;
    
#line 18322 
    ldv_free((void *)data);
  }
  else ;
  
#line 18327 
  ldv_76_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 18328 
  tmp_1 = ldv_undef_int();
  
#line 18328 
  ldv_76_size_cnt = (unsigned long)tmp_1;
  
#line 18335 
  goto ldv_main_76;
  
#line 18337 
  __retres = (void *)0;
  
#line 18337 
  goto return_label;
  ldv_main_76: 
#line 18340 
  ;
  
#line 18343 
  tmp_3 = ldv_undef_int();
  
#line 18343 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 18346 
    ldv_76_ret = (*ldv_emg_alias_simple_open_5)(ldv_76_resource_0,ldv_76_resource_1);
    
#line 18348 
    ldv_76_ret = ldv_filter_err_code(ldv_76_ret);
    
#line 18351 
    tmp_2 = ldv_undef_int();
    
#line 18351 
    if (tmp_2 != 0) {
      
#line 18353 
      __VERIFIER_assume(ldv_76_ret == 0);
      
#line 18360 
      goto ldv_call_76;
    }
    else {
      
#line 18364 
      __VERIFIER_assume(ldv_76_ret != 0);
      
#line 18371 
      goto ldv_main_76;
    }
  }
  else {
    
#line 18376 
    ldv_free((void *)ldv_76_resource_0);
    
#line 18384 
    __retres = (void *)0;
    
#line 18384 
    goto return_label;
  }
  
#line 18387 
  __retres = (void *)0;
  
#line 18387 
  goto return_label;
  ldv_call_76: 
#line 18390 
  ;
  
#line 18393 
  tmp_4 = ldv_undef_int();
  
#line 18393 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 18394 
    ;
    
#line 18396 
    ldv_76_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 18397 
    ldv_76_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 18401 
    if (ldv_76_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 18407 
      __VERIFIER_assume(ldv_76_size_cnt <= 2147479552UL);
      
#line 18409 
      (*(ldv_76_container->write))(ldv_76_resource_1,(char const *)ldv_76_ldv_param_1_6,ldv_76_size_cnt,ldv_76_ldv_param_3_7);
    }
    else ;
    
#line 18414 
    ldv_free((void *)ldv_76_ldv_param_1_6);
    
#line 18415 
    ldv_free((void *)ldv_76_ldv_param_3_7);
    
#line 18422 
    goto ldv_call_76;
    case 2: 
#line 18425 
    ;
    
#line 18427 
    if (ldv_76_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 18429 
      (*(ldv_76_container->release))(ldv_76_resource_0,ldv_76_resource_1); else ;
    
#line 18437 
    goto ldv_main_76;
    case 3: 
#line 18440 
    ;
    
#line 18444 
    tmp_9 = ldv_undef_int();
    
#line 18444 
    if (tmp_9 != 0) 
#line 18447 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_76_resource_1,ldv_76_ldv_param_1_2,ldv_76_ldv_param_2_3);
    else {
      
#line 18453 
      ldv_76_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 18454 
      ldv_76_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 18459 
      ldv_emg_wrapper_tx_tx_frame_checksum_read_3(ldv_76_resource_1,ldv_76_ldv_param_1_4,ldv_76_size_cnt,ldv_76_ldv_param_3_5);
      
#line 18463 
      ldv_free((void *)ldv_76_ldv_param_3_5);
      
#line 18464 
      ldv_free((void *)ldv_76_ldv_param_1_4);
    }
    
#line 18468 
    goto ldv_32870;
    default: 
#line 18470 
    ;
    
#line 18470 
    __VERIFIER_assume(0);
  }
  ldv_32870: 
#line 18479 
  ;
  
#line 18479 
  goto ldv_call_76;
  
#line 18481 
  __retres = (void *)0;
  return_label: 
#line 18481 
                return __retres;
}


#line 18486  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_85(void *arg0)
{
  void *__retres;
  struct file *ldv_85_resource_1;
  int ldv_85_ldv_param_2_3;
  long long ldv_85_ldv_param_1_2;
  char *ldv_85_ldv_param_1_4;
  struct inode *ldv_85_resource_0;
  unsigned long ldv_85_size_cnt;
  long long *ldv_85_ldv_param_3_5;
  char *ldv_85_ldv_param_1_6;
  long long *ldv_85_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 18497 
  struct file_operations *ldv_85_container = ldv_emg_alias_rx_rx_timeout_wa_ops_2;
  
#line 18498 
  int ldv_85_ret = ldv_undef_int();
  
#line 18501 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 18505 
  ldv_85_ret = ldv_undef_int();
  
#line 18508 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 18509 
    ldv_85_container = data->arg0;
    
#line 18510 
    ldv_free((void *)data);
  }
  else ;
  
#line 18515 
  ldv_85_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 18516 
  tmp_1 = ldv_undef_int();
  
#line 18516 
  ldv_85_size_cnt = (unsigned long)tmp_1;
  
#line 18523 
  goto ldv_main_85;
  
#line 18525 
  __retres = (void *)0;
  
#line 18525 
  goto return_label;
  ldv_main_85: 
#line 18528 
  ;
  
#line 18531 
  tmp_3 = ldv_undef_int();
  
#line 18531 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 18534 
    ldv_85_ret = (*ldv_emg_alias_simple_open_5)(ldv_85_resource_0,ldv_85_resource_1);
    
#line 18536 
    ldv_85_ret = ldv_filter_err_code(ldv_85_ret);
    
#line 18539 
    tmp_2 = ldv_undef_int();
    
#line 18539 
    if (tmp_2 != 0) {
      
#line 18541 
      __VERIFIER_assume(ldv_85_ret == 0);
      
#line 18548 
      goto ldv_call_85;
    }
    else {
      
#line 18552 
      __VERIFIER_assume(ldv_85_ret != 0);
      
#line 18559 
      goto ldv_main_85;
    }
  }
  else {
    
#line 18564 
    ldv_free((void *)ldv_85_resource_0);
    
#line 18572 
    __retres = (void *)0;
    
#line 18572 
    goto return_label;
  }
  
#line 18575 
  __retres = (void *)0;
  
#line 18575 
  goto return_label;
  ldv_call_85: 
#line 18578 
  ;
  
#line 18581 
  tmp_4 = ldv_undef_int();
  
#line 18581 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 18582 
    ;
    
#line 18584 
    ldv_85_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 18585 
    ldv_85_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 18589 
    if (ldv_85_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 18595 
      __VERIFIER_assume(ldv_85_size_cnt <= 2147479552UL);
      
#line 18597 
      (*(ldv_85_container->write))(ldv_85_resource_1,(char const *)ldv_85_ldv_param_1_6,ldv_85_size_cnt,ldv_85_ldv_param_3_7);
    }
    else ;
    
#line 18602 
    ldv_free((void *)ldv_85_ldv_param_3_7);
    
#line 18603 
    ldv_free((void *)ldv_85_ldv_param_1_6);
    
#line 18610 
    goto ldv_call_85;
    case 2: 
#line 18613 
    ;
    
#line 18615 
    if (ldv_85_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 18617 
      (*(ldv_85_container->release))(ldv_85_resource_0,ldv_85_resource_1); else ;
    
#line 18625 
    goto ldv_main_85;
    case 3: 
#line 18628 
    ;
    
#line 18632 
    tmp_9 = ldv_undef_int();
    
#line 18632 
    if (tmp_9 != 0) 
#line 18635 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_85_resource_1,ldv_85_ldv_param_1_2,ldv_85_ldv_param_2_3);
    else {
      
#line 18641 
      ldv_85_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 18642 
      ldv_85_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 18647 
      ldv_emg_wrapper_rx_rx_timeout_wa_read_3(ldv_85_resource_1,ldv_85_ldv_param_1_4,ldv_85_size_cnt,ldv_85_ldv_param_3_5);
      
#line 18651 
      ldv_free((void *)ldv_85_ldv_param_1_4);
      
#line 18652 
      ldv_free((void *)ldv_85_ldv_param_3_5);
    }
    
#line 18656 
    goto ldv_32892;
    default: 
#line 18658 
    ;
    
#line 18658 
    __VERIFIER_assume(0);
  }
  ldv_32892: 
#line 18667 
  ;
  
#line 18667 
  goto ldv_call_85;
  
#line 18669 
  __retres = (void *)0;
  return_label: 
#line 18669 
                return __retres;
}


#line 18674  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_21(void *arg0)
{
  void *__retres;
  struct file *ldv_21_resource_1;
  int ldv_21_ldv_param_2_3;
  long long ldv_21_ldv_param_1_2;
  char *ldv_21_ldv_param_1_4;
  struct inode *ldv_21_resource_0;
  unsigned long ldv_21_size_cnt;
  long long *ldv_21_ldv_param_3_5;
  char *ldv_21_ldv_param_1_6;
  long long *ldv_21_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 18685 
  struct file_operations *ldv_21_container = ldv_emg_alias_pipeline_pre_proc_swi_ops_2;
  
#line 18686 
  int ldv_21_ret = ldv_undef_int();
  
#line 18689 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 18693 
  ldv_21_ret = ldv_undef_int();
  
#line 18696 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 18697 
    ldv_21_container = data->arg0;
    
#line 18698 
    ldv_free((void *)data);
  }
  else ;
  
#line 18703 
  ldv_21_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 18704 
  tmp_1 = ldv_undef_int();
  
#line 18704 
  ldv_21_size_cnt = (unsigned long)tmp_1;
  
#line 18711 
  goto ldv_main_21;
  
#line 18713 
  __retres = (void *)0;
  
#line 18713 
  goto return_label;
  ldv_main_21: 
#line 18716 
  ;
  
#line 18719 
  tmp_3 = ldv_undef_int();
  
#line 18719 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 18722 
    ldv_21_ret = (*ldv_emg_alias_simple_open_5)(ldv_21_resource_0,ldv_21_resource_1);
    
#line 18724 
    ldv_21_ret = ldv_filter_err_code(ldv_21_ret);
    
#line 18727 
    tmp_2 = ldv_undef_int();
    
#line 18727 
    if (tmp_2 != 0) {
      
#line 18729 
      __VERIFIER_assume(ldv_21_ret == 0);
      
#line 18736 
      goto ldv_call_21;
    }
    else {
      
#line 18740 
      __VERIFIER_assume(ldv_21_ret != 0);
      
#line 18747 
      goto ldv_main_21;
    }
  }
  else {
    
#line 18752 
    ldv_free((void *)ldv_21_resource_0);
    
#line 18760 
    __retres = (void *)0;
    
#line 18760 
    goto return_label;
  }
  
#line 18763 
  __retres = (void *)0;
  
#line 18763 
  goto return_label;
  ldv_call_21: 
#line 18766 
  ;
  
#line 18769 
  tmp_4 = ldv_undef_int();
  
#line 18769 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 18770 
    ;
    
#line 18772 
    ldv_21_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 18773 
    ldv_21_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 18777 
    if (ldv_21_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 18783 
      __VERIFIER_assume(ldv_21_size_cnt <= 2147479552UL);
      
#line 18785 
      (*(ldv_21_container->write))(ldv_21_resource_1,(char const *)ldv_21_ldv_param_1_6,ldv_21_size_cnt,ldv_21_ldv_param_3_7);
    }
    else ;
    
#line 18790 
    ldv_free((void *)ldv_21_ldv_param_3_7);
    
#line 18791 
    ldv_free((void *)ldv_21_ldv_param_1_6);
    
#line 18798 
    goto ldv_call_21;
    case 2: 
#line 18801 
    ;
    
#line 18803 
    if (ldv_21_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 18805 
      (*(ldv_21_container->release))(ldv_21_resource_0,ldv_21_resource_1); else ;
    
#line 18813 
    goto ldv_main_21;
    case 3: 
#line 18816 
    ;
    
#line 18820 
    tmp_9 = ldv_undef_int();
    
#line 18820 
    if (tmp_9 != 0) 
#line 18823 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_21_resource_1,ldv_21_ldv_param_1_2,ldv_21_ldv_param_2_3);
    else {
      
#line 18829 
      ldv_21_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 18830 
      ldv_21_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 18835 
      ldv_emg_wrapper_pipeline_pre_proc_swi_read_3(ldv_21_resource_1,ldv_21_ldv_param_1_4,ldv_21_size_cnt,ldv_21_ldv_param_3_5);
      
#line 18839 
      ldv_free((void *)ldv_21_ldv_param_3_5);
      
#line 18840 
      ldv_free((void *)ldv_21_ldv_param_1_4);
    }
    
#line 18844 
    goto ldv_32914;
    default: 
#line 18846 
    ;
    
#line 18846 
    __VERIFIER_assume(0);
  }
  ldv_32914: 
#line 18855 
  ;
  
#line 18855 
  goto ldv_call_21;
  
#line 18857 
  __retres = (void *)0;
  return_label: 
#line 18857 
                return __retres;
}


#line 18862  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_platform_driver_unregister(struct platform_driver *arg0)
{
  
#line 18865 
  struct platform_driver *ldv_3_platform_driver = ldv_emg_alias_wl18xx_driver_2;
  
#line 18868 
  ldv_3_platform_driver = arg0;
  
#line 18872 
  ldv_dispatch_deregister_3_1(ldv_3_platform_driver);
  
#line 18876 
  goto return_label;
  return_label: 
#line 18878 
                return;
}


#line 18883  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_110(void *arg0)
{
  void *__retres;
  struct file *ldv_110_resource_1;
  int ldv_110_ldv_param_2_3;
  long long ldv_110_ldv_param_1_2;
  char *ldv_110_ldv_param_1_4;
  struct inode *ldv_110_resource_0;
  unsigned long ldv_110_size_cnt;
  long long *ldv_110_ldv_param_3_5;
  char *ldv_110_ldv_param_1_6;
  long long *ldv_110_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 18894 
  struct file_operations *ldv_110_container = ldv_emg_alias_error_error_frame_ops_2;
  
#line 18895 
  int ldv_110_ret = ldv_undef_int();
  
#line 18898 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 18902 
  ldv_110_ret = ldv_undef_int();
  
#line 18905 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 18906 
    ldv_110_container = data->arg0;
    
#line 18907 
    ldv_free((void *)data);
  }
  else ;
  
#line 18912 
  ldv_110_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 18913 
  tmp_1 = ldv_undef_int();
  
#line 18913 
  ldv_110_size_cnt = (unsigned long)tmp_1;
  
#line 18920 
  goto ldv_main_110;
  
#line 18922 
  __retres = (void *)0;
  
#line 18922 
  goto return_label;
  ldv_main_110: 
#line 18925 
  ;
  
#line 18928 
  tmp_3 = ldv_undef_int();
  
#line 18928 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 18931 
    ldv_110_ret = (*ldv_emg_alias_simple_open_5)(ldv_110_resource_0,ldv_110_resource_1);
    
#line 18933 
    ldv_110_ret = ldv_filter_err_code(ldv_110_ret);
    
#line 18936 
    tmp_2 = ldv_undef_int();
    
#line 18936 
    if (tmp_2 != 0) {
      
#line 18938 
      __VERIFIER_assume(ldv_110_ret == 0);
      
#line 18945 
      goto ldv_call_110;
    }
    else {
      
#line 18949 
      __VERIFIER_assume(ldv_110_ret != 0);
      
#line 18956 
      goto ldv_main_110;
    }
  }
  else {
    
#line 18961 
    ldv_free((void *)ldv_110_resource_0);
    
#line 18969 
    __retres = (void *)0;
    
#line 18969 
    goto return_label;
  }
  
#line 18972 
  __retres = (void *)0;
  
#line 18972 
  goto return_label;
  ldv_call_110: 
#line 18975 
  ;
  
#line 18978 
  tmp_4 = ldv_undef_int();
  
#line 18978 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 18979 
    ;
    
#line 18981 
    ldv_110_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 18982 
    ldv_110_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 18986 
    if (ldv_110_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 18992 
      __VERIFIER_assume(ldv_110_size_cnt <= 2147479552UL);
      
#line 18994 
      (*(ldv_110_container->write))(ldv_110_resource_1,(char const *)ldv_110_ldv_param_1_6,ldv_110_size_cnt,ldv_110_ldv_param_3_7);
    }
    else ;
    
#line 18999 
    ldv_free((void *)ldv_110_ldv_param_3_7);
    
#line 19000 
    ldv_free((void *)ldv_110_ldv_param_1_6);
    
#line 19007 
    goto ldv_call_110;
    case 2: 
#line 19010 
    ;
    
#line 19012 
    if (ldv_110_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 19014 
      (*(ldv_110_container->release))(ldv_110_resource_0,ldv_110_resource_1); else ;
    
#line 19022 
    goto ldv_main_110;
    case 3: 
#line 19025 
    ;
    
#line 19029 
    tmp_9 = ldv_undef_int();
    
#line 19029 
    if (tmp_9 != 0) 
#line 19032 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_110_resource_1,ldv_110_ldv_param_1_2,ldv_110_ldv_param_2_3);
    else {
      
#line 19038 
      ldv_110_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 19039 
      ldv_110_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 19044 
      ldv_emg_wrapper_error_error_frame_read_3(ldv_110_resource_1,ldv_110_ldv_param_1_4,ldv_110_size_cnt,ldv_110_ldv_param_3_5);
      
#line 19048 
      ldv_free((void *)ldv_110_ldv_param_3_5);
      
#line 19049 
      ldv_free((void *)ldv_110_ldv_param_1_4);
    }
    
#line 19053 
    goto ldv_32940;
    default: 
#line 19055 
    ;
    
#line 19055 
    __VERIFIER_assume(0);
  }
  ldv_32940: 
#line 19064 
  ;
  
#line 19064 
  goto ldv_call_110;
  
#line 19066 
  __retres = (void *)0;
  return_label: 
#line 19066 
                return __retres;
}


#line 19071  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_6(void *arg0)
{
  void *__retres;
  struct file *ldv_6_resource_1;
  int ldv_6_ldv_param_2_3;
  long long ldv_6_ldv_param_1_2;
  char *ldv_6_ldv_param_1_4;
  struct inode *ldv_6_resource_0;
  unsigned long ldv_6_size_cnt;
  long long *ldv_6_ldv_param_3_5;
  char *ldv_6_ldv_param_1_6;
  long long *ldv_6_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 19082 
  struct file_operations *ldv_6_container = ldv_emg_alias_pipeline_dec_packet_out_ops_2;
  
#line 19083 
  int ldv_6_ret = ldv_undef_int();
  
#line 19086 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 19090 
  ldv_6_ret = ldv_undef_int();
  
#line 19093 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 19094 
    ldv_6_container = data->arg0;
    
#line 19095 
    ldv_free((void *)data);
  }
  else ;
  
#line 19100 
  ldv_6_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 19101 
  tmp_1 = ldv_undef_int();
  
#line 19101 
  ldv_6_size_cnt = (unsigned long)tmp_1;
  
#line 19108 
  goto ldv_main_6;
  
#line 19110 
  __retres = (void *)0;
  
#line 19110 
  goto return_label;
  ldv_main_6: 
#line 19113 
  ;
  
#line 19116 
  tmp_3 = ldv_undef_int();
  
#line 19116 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 19119 
    ldv_6_ret = (*ldv_emg_alias_simple_open_5)(ldv_6_resource_0,ldv_6_resource_1);
    
#line 19121 
    ldv_6_ret = ldv_filter_err_code(ldv_6_ret);
    
#line 19124 
    tmp_2 = ldv_undef_int();
    
#line 19124 
    if (tmp_2 != 0) {
      
#line 19126 
      __VERIFIER_assume(ldv_6_ret == 0);
      
#line 19133 
      goto ldv_call_6;
    }
    else {
      
#line 19137 
      __VERIFIER_assume(ldv_6_ret != 0);
      
#line 19144 
      goto ldv_main_6;
    }
  }
  else {
    
#line 19149 
    ldv_free((void *)ldv_6_resource_0);
    
#line 19157 
    __retres = (void *)0;
    
#line 19157 
    goto return_label;
  }
  
#line 19160 
  __retres = (void *)0;
  
#line 19160 
  goto return_label;
  ldv_call_6: 
#line 19163 
  ;
  
#line 19166 
  tmp_4 = ldv_undef_int();
  
#line 19166 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 19167 
    ;
    
#line 19169 
    ldv_6_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 19170 
    ldv_6_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 19174 
    if (ldv_6_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 19180 
      __VERIFIER_assume(ldv_6_size_cnt <= 2147479552UL);
      
#line 19182 
      (*(ldv_6_container->write))(ldv_6_resource_1,(char const *)ldv_6_ldv_param_1_6,ldv_6_size_cnt,ldv_6_ldv_param_3_7);
    }
    else ;
    
#line 19187 
    ldv_free((void *)ldv_6_ldv_param_1_6);
    
#line 19188 
    ldv_free((void *)ldv_6_ldv_param_3_7);
    
#line 19195 
    goto ldv_call_6;
    case 2: 
#line 19198 
    ;
    
#line 19200 
    if (ldv_6_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 19202 
      (*(ldv_6_container->release))(ldv_6_resource_0,ldv_6_resource_1); else ;
    
#line 19210 
    goto ldv_main_6;
    case 3: 
#line 19213 
    ;
    
#line 19217 
    tmp_9 = ldv_undef_int();
    
#line 19217 
    if (tmp_9 != 0) 
#line 19220 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_6_resource_1,ldv_6_ldv_param_1_2,ldv_6_ldv_param_2_3);
    else {
      
#line 19226 
      ldv_6_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 19227 
      ldv_6_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 19232 
      ldv_emg_wrapper_pipeline_dec_packet_out_read_3(ldv_6_resource_1,ldv_6_ldv_param_1_4,ldv_6_size_cnt,ldv_6_ldv_param_3_5);
      
#line 19236 
      ldv_free((void *)ldv_6_ldv_param_1_4);
      
#line 19237 
      ldv_free((void *)ldv_6_ldv_param_3_5);
    }
    
#line 19241 
    goto ldv_32962;
    default: 
#line 19243 
    ;
    
#line 19243 
    __VERIFIER_assume(0);
  }
  ldv_32962: 
#line 19252 
  ;
  
#line 19252 
  goto ldv_call_6;
  
#line 19254 
  __retres = (void *)0;
  return_label: 
#line 19254 
                return __retres;
}


#line 19259  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_50(void *arg0)
{
  void *__retres;
  struct file *ldv_50_resource_1;
  int ldv_50_ldv_param_2_3;
  long long ldv_50_ldv_param_1_2;
  char *ldv_50_ldv_param_1_4;
  struct inode *ldv_50_resource_0;
  unsigned long ldv_50_size_cnt;
  long long *ldv_50_ldv_param_3_5;
  char *ldv_50_ldv_param_1_6;
  long long *ldv_50_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 19270 
  struct file_operations *ldv_50_container = ldv_emg_alias_tx_frag_mpdu_alloc_failed_ops_2;
  
#line 19271 
  int ldv_50_ret = ldv_undef_int();
  
#line 19274 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 19278 
  ldv_50_ret = ldv_undef_int();
  
#line 19281 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 19282 
    ldv_50_container = data->arg0;
    
#line 19283 
    ldv_free((void *)data);
  }
  else ;
  
#line 19288 
  ldv_50_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 19289 
  tmp_1 = ldv_undef_int();
  
#line 19289 
  ldv_50_size_cnt = (unsigned long)tmp_1;
  
#line 19296 
  goto ldv_main_50;
  
#line 19298 
  __retres = (void *)0;
  
#line 19298 
  goto return_label;
  ldv_main_50: 
#line 19301 
  ;
  
#line 19304 
  tmp_3 = ldv_undef_int();
  
#line 19304 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 19307 
    ldv_50_ret = (*ldv_emg_alias_simple_open_5)(ldv_50_resource_0,ldv_50_resource_1);
    
#line 19309 
    ldv_50_ret = ldv_filter_err_code(ldv_50_ret);
    
#line 19312 
    tmp_2 = ldv_undef_int();
    
#line 19312 
    if (tmp_2 != 0) {
      
#line 19314 
      __VERIFIER_assume(ldv_50_ret == 0);
      
#line 19321 
      goto ldv_call_50;
    }
    else {
      
#line 19325 
      __VERIFIER_assume(ldv_50_ret != 0);
      
#line 19332 
      goto ldv_main_50;
    }
  }
  else {
    
#line 19337 
    ldv_free((void *)ldv_50_resource_0);
    
#line 19345 
    __retres = (void *)0;
    
#line 19345 
    goto return_label;
  }
  
#line 19348 
  __retres = (void *)0;
  
#line 19348 
  goto return_label;
  ldv_call_50: 
#line 19351 
  ;
  
#line 19354 
  tmp_4 = ldv_undef_int();
  
#line 19354 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 19355 
    ;
    
#line 19357 
    ldv_50_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 19358 
    ldv_50_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 19362 
    if (ldv_50_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 19368 
      __VERIFIER_assume(ldv_50_size_cnt <= 2147479552UL);
      
#line 19370 
      (*(ldv_50_container->write))(ldv_50_resource_1,(char const *)ldv_50_ldv_param_1_6,ldv_50_size_cnt,ldv_50_ldv_param_3_7);
    }
    else ;
    
#line 19375 
    ldv_free((void *)ldv_50_ldv_param_3_7);
    
#line 19376 
    ldv_free((void *)ldv_50_ldv_param_1_6);
    
#line 19383 
    goto ldv_call_50;
    case 2: 
#line 19386 
    ;
    
#line 19388 
    if (ldv_50_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 19390 
      (*(ldv_50_container->release))(ldv_50_resource_0,ldv_50_resource_1); else ;
    
#line 19398 
    goto ldv_main_50;
    case 3: 
#line 19401 
    ;
    
#line 19405 
    tmp_9 = ldv_undef_int();
    
#line 19405 
    if (tmp_9 != 0) 
#line 19408 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_50_resource_1,ldv_50_ldv_param_1_2,ldv_50_ldv_param_2_3);
    else {
      
#line 19414 
      ldv_50_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 19415 
      ldv_50_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 19420 
      ldv_emg_wrapper_tx_frag_mpdu_alloc_failed_read_3(ldv_50_resource_1,ldv_50_ldv_param_1_4,ldv_50_size_cnt,ldv_50_ldv_param_3_5);
      
#line 19424 
      ldv_free((void *)ldv_50_ldv_param_1_4);
      
#line 19425 
      ldv_free((void *)ldv_50_ldv_param_3_5);
    }
    
#line 19429 
    goto ldv_32984;
    default: 
#line 19431 
    ;
    
#line 19431 
    __VERIFIER_assume(0);
  }
  ldv_32984: 
#line 19440 
  ;
  
#line 19440 
  goto ldv_call_50;
  
#line 19442 
  __retres = (void *)0;
  return_label: 
#line 19442 
                return __retres;
}


#line 19447  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_16(void *arg0)
{
  void *__retres;
  struct file *ldv_16_resource_1;
  int ldv_16_ldv_param_2_3;
  long long ldv_16_ldv_param_1_2;
  char *ldv_16_ldv_param_1_4;
  struct inode *ldv_16_resource_0;
  unsigned long ldv_16_size_cnt;
  long long *ldv_16_ldv_param_3_5;
  char *ldv_16_ldv_param_1_6;
  long long *ldv_16_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 19458 
  struct file_operations *ldv_16_container = ldv_emg_alias_tx_tx_checksum_result_ops_2;
  
#line 19459 
  int ldv_16_ret = ldv_undef_int();
  
#line 19462 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 19466 
  ldv_16_ret = ldv_undef_int();
  
#line 19469 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 19470 
    ldv_16_container = data->arg0;
    
#line 19471 
    ldv_free((void *)data);
  }
  else ;
  
#line 19476 
  ldv_16_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 19477 
  tmp_1 = ldv_undef_int();
  
#line 19477 
  ldv_16_size_cnt = (unsigned long)tmp_1;
  
#line 19484 
  goto ldv_main_16;
  
#line 19486 
  __retres = (void *)0;
  
#line 19486 
  goto return_label;
  ldv_main_16: 
#line 19489 
  ;
  
#line 19492 
  tmp_3 = ldv_undef_int();
  
#line 19492 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 19495 
    ldv_16_ret = (*ldv_emg_alias_simple_open_5)(ldv_16_resource_0,ldv_16_resource_1);
    
#line 19497 
    ldv_16_ret = ldv_filter_err_code(ldv_16_ret);
    
#line 19500 
    tmp_2 = ldv_undef_int();
    
#line 19500 
    if (tmp_2 != 0) {
      
#line 19502 
      __VERIFIER_assume(ldv_16_ret == 0);
      
#line 19509 
      goto ldv_call_16;
    }
    else {
      
#line 19513 
      __VERIFIER_assume(ldv_16_ret != 0);
      
#line 19520 
      goto ldv_main_16;
    }
  }
  else {
    
#line 19525 
    ldv_free((void *)ldv_16_resource_0);
    
#line 19533 
    __retres = (void *)0;
    
#line 19533 
    goto return_label;
  }
  
#line 19536 
  __retres = (void *)0;
  
#line 19536 
  goto return_label;
  ldv_call_16: 
#line 19539 
  ;
  
#line 19542 
  tmp_4 = ldv_undef_int();
  
#line 19542 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 19543 
    ;
    
#line 19545 
    ldv_16_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 19546 
    ldv_16_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 19550 
    if (ldv_16_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 19556 
      __VERIFIER_assume(ldv_16_size_cnt <= 2147479552UL);
      
#line 19558 
      (*(ldv_16_container->write))(ldv_16_resource_1,(char const *)ldv_16_ldv_param_1_6,ldv_16_size_cnt,ldv_16_ldv_param_3_7);
    }
    else ;
    
#line 19563 
    ldv_free((void *)ldv_16_ldv_param_1_6);
    
#line 19564 
    ldv_free((void *)ldv_16_ldv_param_3_7);
    
#line 19571 
    goto ldv_call_16;
    case 2: 
#line 19574 
    ;
    
#line 19576 
    if (ldv_16_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 19578 
      (*(ldv_16_container->release))(ldv_16_resource_0,ldv_16_resource_1); else ;
    
#line 19586 
    goto ldv_main_16;
    case 3: 
#line 19589 
    ;
    
#line 19593 
    tmp_9 = ldv_undef_int();
    
#line 19593 
    if (tmp_9 != 0) 
#line 19596 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_16_resource_1,ldv_16_ldv_param_1_2,ldv_16_ldv_param_2_3);
    else {
      
#line 19602 
      ldv_16_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 19603 
      ldv_16_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 19608 
      ldv_emg_wrapper_tx_tx_checksum_result_read_3(ldv_16_resource_1,ldv_16_ldv_param_1_4,ldv_16_size_cnt,ldv_16_ldv_param_3_5);
      
#line 19612 
      ldv_free((void *)ldv_16_ldv_param_1_4);
      
#line 19613 
      ldv_free((void *)ldv_16_ldv_param_3_5);
    }
    
#line 19617 
    goto ldv_33006;
    default: 
#line 19619 
    ;
    
#line 19619 
    __VERIFIER_assume(0);
  }
  ldv_33006: 
#line 19628 
  ;
  
#line 19628 
  goto ldv_call_16;
  
#line 19630 
  __retres = (void *)0;
  return_label: 
#line 19630 
                return __retres;
}


#line 19635  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_74(void *arg0)
{
  void *__retres;
  struct file *ldv_74_resource_1;
  int ldv_74_ldv_param_2_3;
  long long ldv_74_ldv_param_1_2;
  char *ldv_74_ldv_param_1_4;
  struct inode *ldv_74_resource_0;
  unsigned long ldv_74_size_cnt;
  long long *ldv_74_ldv_param_3_5;
  char *ldv_74_ldv_param_1_6;
  long long *ldv_74_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 19646 
  struct file_operations *ldv_74_container = ldv_emg_alias_rx_defrag_called_ops_2;
  
#line 19647 
  int ldv_74_ret = ldv_undef_int();
  
#line 19650 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 19654 
  ldv_74_ret = ldv_undef_int();
  
#line 19657 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 19658 
    ldv_74_container = data->arg0;
    
#line 19659 
    ldv_free((void *)data);
  }
  else ;
  
#line 19664 
  ldv_74_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 19665 
  tmp_1 = ldv_undef_int();
  
#line 19665 
  ldv_74_size_cnt = (unsigned long)tmp_1;
  
#line 19672 
  goto ldv_main_74;
  
#line 19674 
  __retres = (void *)0;
  
#line 19674 
  goto return_label;
  ldv_main_74: 
#line 19677 
  ;
  
#line 19680 
  tmp_3 = ldv_undef_int();
  
#line 19680 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 19683 
    ldv_74_ret = (*ldv_emg_alias_simple_open_5)(ldv_74_resource_0,ldv_74_resource_1);
    
#line 19685 
    ldv_74_ret = ldv_filter_err_code(ldv_74_ret);
    
#line 19688 
    tmp_2 = ldv_undef_int();
    
#line 19688 
    if (tmp_2 != 0) {
      
#line 19690 
      __VERIFIER_assume(ldv_74_ret == 0);
      
#line 19697 
      goto ldv_call_74;
    }
    else {
      
#line 19701 
      __VERIFIER_assume(ldv_74_ret != 0);
      
#line 19708 
      goto ldv_main_74;
    }
  }
  else {
    
#line 19713 
    ldv_free((void *)ldv_74_resource_0);
    
#line 19721 
    __retres = (void *)0;
    
#line 19721 
    goto return_label;
  }
  
#line 19724 
  __retres = (void *)0;
  
#line 19724 
  goto return_label;
  ldv_call_74: 
#line 19727 
  ;
  
#line 19730 
  tmp_4 = ldv_undef_int();
  
#line 19730 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 19731 
    ;
    
#line 19733 
    ldv_74_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 19734 
    ldv_74_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 19738 
    if (ldv_74_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 19744 
      __VERIFIER_assume(ldv_74_size_cnt <= 2147479552UL);
      
#line 19746 
      (*(ldv_74_container->write))(ldv_74_resource_1,(char const *)ldv_74_ldv_param_1_6,ldv_74_size_cnt,ldv_74_ldv_param_3_7);
    }
    else ;
    
#line 19751 
    ldv_free((void *)ldv_74_ldv_param_3_7);
    
#line 19752 
    ldv_free((void *)ldv_74_ldv_param_1_6);
    
#line 19759 
    goto ldv_call_74;
    case 2: 
#line 19762 
    ;
    
#line 19764 
    if (ldv_74_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 19766 
      (*(ldv_74_container->release))(ldv_74_resource_0,ldv_74_resource_1); else ;
    
#line 19774 
    goto ldv_main_74;
    case 3: 
#line 19777 
    ;
    
#line 19781 
    tmp_9 = ldv_undef_int();
    
#line 19781 
    if (tmp_9 != 0) 
#line 19784 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_74_resource_1,ldv_74_ldv_param_1_2,ldv_74_ldv_param_2_3);
    else {
      
#line 19790 
      ldv_74_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 19791 
      ldv_74_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 19796 
      ldv_emg_wrapper_rx_defrag_called_read_3(ldv_74_resource_1,ldv_74_ldv_param_1_4,ldv_74_size_cnt,ldv_74_ldv_param_3_5);
      
#line 19800 
      ldv_free((void *)ldv_74_ldv_param_1_4);
      
#line 19801 
      ldv_free((void *)ldv_74_ldv_param_3_5);
    }
    
#line 19805 
    goto ldv_33028;
    default: 
#line 19807 
    ;
    
#line 19807 
    __VERIFIER_assume(0);
  }
  ldv_33028: 
#line 19816 
  ;
  
#line 19816 
  goto ldv_call_74;
  
#line 19818 
  __retres = (void *)0;
  return_label: 
#line 19818 
                return __retres;
}


#line 19823  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_30(void *arg0)
{
  void *__retres;
  struct file *ldv_30_resource_1;
  int ldv_30_ldv_param_2_3;
  long long ldv_30_ldv_param_1_2;
  char *ldv_30_ldv_param_1_4;
  struct inode *ldv_30_resource_0;
  unsigned long ldv_30_size_cnt;
  long long *ldv_30_ldv_param_3_5;
  char *ldv_30_ldv_param_1_6;
  long long *ldv_30_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 19834 
  struct file_operations *ldv_30_container = ldv_emg_alias_ps_poll_upsd_max_ap_turn_ops_2;
  
#line 19835 
  int ldv_30_ret = ldv_undef_int();
  
#line 19838 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 19842 
  ldv_30_ret = ldv_undef_int();
  
#line 19845 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 19846 
    ldv_30_container = data->arg0;
    
#line 19847 
    ldv_free((void *)data);
  }
  else ;
  
#line 19852 
  ldv_30_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 19853 
  tmp_1 = ldv_undef_int();
  
#line 19853 
  ldv_30_size_cnt = (unsigned long)tmp_1;
  
#line 19860 
  goto ldv_main_30;
  
#line 19862 
  __retres = (void *)0;
  
#line 19862 
  goto return_label;
  ldv_main_30: 
#line 19865 
  ;
  
#line 19868 
  tmp_3 = ldv_undef_int();
  
#line 19868 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 19871 
    ldv_30_ret = (*ldv_emg_alias_simple_open_5)(ldv_30_resource_0,ldv_30_resource_1);
    
#line 19873 
    ldv_30_ret = ldv_filter_err_code(ldv_30_ret);
    
#line 19876 
    tmp_2 = ldv_undef_int();
    
#line 19876 
    if (tmp_2 != 0) {
      
#line 19878 
      __VERIFIER_assume(ldv_30_ret == 0);
      
#line 19885 
      goto ldv_call_30;
    }
    else {
      
#line 19889 
      __VERIFIER_assume(ldv_30_ret != 0);
      
#line 19896 
      goto ldv_main_30;
    }
  }
  else {
    
#line 19901 
    ldv_free((void *)ldv_30_resource_0);
    
#line 19909 
    __retres = (void *)0;
    
#line 19909 
    goto return_label;
  }
  
#line 19912 
  __retres = (void *)0;
  
#line 19912 
  goto return_label;
  ldv_call_30: 
#line 19915 
  ;
  
#line 19918 
  tmp_4 = ldv_undef_int();
  
#line 19918 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 19919 
    ;
    
#line 19921 
    ldv_30_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 19922 
    ldv_30_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 19926 
    if (ldv_30_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 19932 
      __VERIFIER_assume(ldv_30_size_cnt <= 2147479552UL);
      
#line 19934 
      (*(ldv_30_container->write))(ldv_30_resource_1,(char const *)ldv_30_ldv_param_1_6,ldv_30_size_cnt,ldv_30_ldv_param_3_7);
    }
    else ;
    
#line 19939 
    ldv_free((void *)ldv_30_ldv_param_3_7);
    
#line 19940 
    ldv_free((void *)ldv_30_ldv_param_1_6);
    
#line 19947 
    goto ldv_call_30;
    case 2: 
#line 19950 
    ;
    
#line 19952 
    if (ldv_30_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 19954 
      (*(ldv_30_container->release))(ldv_30_resource_0,ldv_30_resource_1); else ;
    
#line 19962 
    goto ldv_main_30;
    case 3: 
#line 19965 
    ;
    
#line 19969 
    tmp_9 = ldv_undef_int();
    
#line 19969 
    if (tmp_9 != 0) 
#line 19972 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_30_resource_1,ldv_30_ldv_param_1_2,ldv_30_ldv_param_2_3);
    else {
      
#line 19978 
      ldv_30_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 19979 
      ldv_30_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 19984 
      ldv_emg_wrapper_ps_poll_upsd_max_ap_turn_read_3(ldv_30_resource_1,ldv_30_ldv_param_1_4,ldv_30_size_cnt,ldv_30_ldv_param_3_5);
      
#line 19988 
      ldv_free((void *)ldv_30_ldv_param_3_5);
      
#line 19989 
      ldv_free((void *)ldv_30_ldv_param_1_4);
    }
    
#line 19993 
    goto ldv_33050;
    default: 
#line 19995 
    ;
    
#line 19995 
    __VERIFIER_assume(0);
  }
  ldv_33050: 
#line 20004 
  ;
  
#line 20004 
  goto ldv_call_30;
  
#line 20006 
  __retres = (void *)0;
  return_label: 
#line 20006 
                return __retres;
}


#line 20011  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_39(void *arg0)
{
  void *__retres;
  struct file *ldv_39_resource_1;
  int ldv_39_ldv_param_2_3;
  long long ldv_39_ldv_param_1_2;
  char *ldv_39_ldv_param_1_4;
  struct inode *ldv_39_resource_0;
  unsigned long ldv_39_size_cnt;
  long long *ldv_39_ldv_param_3_5;
  char *ldv_39_ldv_param_1_6;
  long long *ldv_39_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 20022 
  struct file_operations *ldv_39_container = ldv_emg_alias_rx_filter_mc_filter_ops_2;
  
#line 20023 
  int ldv_39_ret = ldv_undef_int();
  
#line 20026 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 20030 
  ldv_39_ret = ldv_undef_int();
  
#line 20033 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 20034 
    ldv_39_container = data->arg0;
    
#line 20035 
    ldv_free((void *)data);
  }
  else ;
  
#line 20040 
  ldv_39_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 20041 
  tmp_1 = ldv_undef_int();
  
#line 20041 
  ldv_39_size_cnt = (unsigned long)tmp_1;
  
#line 20048 
  goto ldv_main_39;
  
#line 20050 
  __retres = (void *)0;
  
#line 20050 
  goto return_label;
  ldv_main_39: 
#line 20053 
  ;
  
#line 20056 
  tmp_3 = ldv_undef_int();
  
#line 20056 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 20059 
    ldv_39_ret = (*ldv_emg_alias_simple_open_5)(ldv_39_resource_0,ldv_39_resource_1);
    
#line 20061 
    ldv_39_ret = ldv_filter_err_code(ldv_39_ret);
    
#line 20064 
    tmp_2 = ldv_undef_int();
    
#line 20064 
    if (tmp_2 != 0) {
      
#line 20066 
      __VERIFIER_assume(ldv_39_ret == 0);
      
#line 20073 
      goto ldv_call_39;
    }
    else {
      
#line 20077 
      __VERIFIER_assume(ldv_39_ret != 0);
      
#line 20084 
      goto ldv_main_39;
    }
  }
  else {
    
#line 20089 
    ldv_free((void *)ldv_39_resource_0);
    
#line 20097 
    __retres = (void *)0;
    
#line 20097 
    goto return_label;
  }
  
#line 20100 
  __retres = (void *)0;
  
#line 20100 
  goto return_label;
  ldv_call_39: 
#line 20103 
  ;
  
#line 20106 
  tmp_4 = ldv_undef_int();
  
#line 20106 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 20107 
    ;
    
#line 20109 
    ldv_39_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 20110 
    ldv_39_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 20114 
    if (ldv_39_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 20120 
      __VERIFIER_assume(ldv_39_size_cnt <= 2147479552UL);
      
#line 20122 
      (*(ldv_39_container->write))(ldv_39_resource_1,(char const *)ldv_39_ldv_param_1_6,ldv_39_size_cnt,ldv_39_ldv_param_3_7);
    }
    else ;
    
#line 20127 
    ldv_free((void *)ldv_39_ldv_param_3_7);
    
#line 20128 
    ldv_free((void *)ldv_39_ldv_param_1_6);
    
#line 20135 
    goto ldv_call_39;
    case 2: 
#line 20138 
    ;
    
#line 20140 
    if (ldv_39_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 20142 
      (*(ldv_39_container->release))(ldv_39_resource_0,ldv_39_resource_1); else ;
    
#line 20150 
    goto ldv_main_39;
    case 3: 
#line 20153 
    ;
    
#line 20157 
    tmp_9 = ldv_undef_int();
    
#line 20157 
    if (tmp_9 != 0) 
#line 20160 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_39_resource_1,ldv_39_ldv_param_1_2,ldv_39_ldv_param_2_3);
    else {
      
#line 20166 
      ldv_39_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 20167 
      ldv_39_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 20172 
      ldv_emg_wrapper_rx_filter_mc_filter_read_3(ldv_39_resource_1,ldv_39_ldv_param_1_4,ldv_39_size_cnt,ldv_39_ldv_param_3_5);
      
#line 20176 
      ldv_free((void *)ldv_39_ldv_param_3_5);
      
#line 20177 
      ldv_free((void *)ldv_39_ldv_param_1_4);
    }
    
#line 20181 
    goto ldv_33072;
    default: 
#line 20183 
    ;
    
#line 20183 
    __VERIFIER_assume(0);
  }
  ldv_33072: 
#line 20192 
  ;
  
#line 20192 
  goto ldv_call_39;
  
#line 20194 
  __retres = (void *)0;
  return_label: 
#line 20194 
                return __retres;
}


#line 20199  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_62(void *arg0)
{
  void *__retres;
  struct file *ldv_62_resource_1;
  int ldv_62_ldv_param_2_3;
  long long ldv_62_ldv_param_1_2;
  char *ldv_62_ldv_param_1_4;
  struct inode *ldv_62_resource_0;
  unsigned long ldv_62_size_cnt;
  long long *ldv_62_ldv_param_3_5;
  char *ldv_62_ldv_param_1_6;
  long long *ldv_62_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 20210 
  struct file_operations *ldv_62_container = ldv_emg_alias_aggr_size_rx_size_ops_2;
  
#line 20211 
  int ldv_62_ret = ldv_undef_int();
  
#line 20214 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 20218 
  ldv_62_ret = ldv_undef_int();
  
#line 20221 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 20222 
    ldv_62_container = data->arg0;
    
#line 20223 
    ldv_free((void *)data);
  }
  else ;
  
#line 20228 
  ldv_62_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 20229 
  tmp_1 = ldv_undef_int();
  
#line 20229 
  ldv_62_size_cnt = (unsigned long)tmp_1;
  
#line 20236 
  goto ldv_main_62;
  
#line 20238 
  __retres = (void *)0;
  
#line 20238 
  goto return_label;
  ldv_main_62: 
#line 20241 
  ;
  
#line 20244 
  tmp_3 = ldv_undef_int();
  
#line 20244 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 20247 
    ldv_62_ret = (*ldv_emg_alias_simple_open_5)(ldv_62_resource_0,ldv_62_resource_1);
    
#line 20249 
    ldv_62_ret = ldv_filter_err_code(ldv_62_ret);
    
#line 20252 
    tmp_2 = ldv_undef_int();
    
#line 20252 
    if (tmp_2 != 0) {
      
#line 20254 
      __VERIFIER_assume(ldv_62_ret == 0);
      
#line 20261 
      goto ldv_call_62;
    }
    else {
      
#line 20265 
      __VERIFIER_assume(ldv_62_ret != 0);
      
#line 20272 
      goto ldv_main_62;
    }
  }
  else {
    
#line 20277 
    ldv_free((void *)ldv_62_resource_0);
    
#line 20285 
    __retres = (void *)0;
    
#line 20285 
    goto return_label;
  }
  
#line 20288 
  __retres = (void *)0;
  
#line 20288 
  goto return_label;
  ldv_call_62: 
#line 20291 
  ;
  
#line 20294 
  tmp_4 = ldv_undef_int();
  
#line 20294 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 20295 
    ;
    
#line 20297 
    ldv_62_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 20298 
    ldv_62_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 20302 
    if (ldv_62_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 20308 
      __VERIFIER_assume(ldv_62_size_cnt <= 2147479552UL);
      
#line 20310 
      (*(ldv_62_container->write))(ldv_62_resource_1,(char const *)ldv_62_ldv_param_1_6,ldv_62_size_cnt,ldv_62_ldv_param_3_7);
    }
    else ;
    
#line 20315 
    ldv_free((void *)ldv_62_ldv_param_3_7);
    
#line 20316 
    ldv_free((void *)ldv_62_ldv_param_1_6);
    
#line 20323 
    goto ldv_call_62;
    case 2: 
#line 20326 
    ;
    
#line 20328 
    if (ldv_62_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 20330 
      (*(ldv_62_container->release))(ldv_62_resource_0,ldv_62_resource_1); else ;
    
#line 20338 
    goto ldv_main_62;
    case 3: 
#line 20341 
    ;
    
#line 20345 
    tmp_9 = ldv_undef_int();
    
#line 20345 
    if (tmp_9 != 0) 
#line 20348 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_62_resource_1,ldv_62_ldv_param_1_2,ldv_62_ldv_param_2_3);
    else {
      
#line 20354 
      ldv_62_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 20355 
      ldv_62_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 20360 
      ldv_emg_wrapper_aggr_size_rx_size_read_4(ldv_62_resource_1,ldv_62_ldv_param_1_4,ldv_62_size_cnt,ldv_62_ldv_param_3_5);
      
#line 20364 
      ldv_free((void *)ldv_62_ldv_param_1_4);
      
#line 20365 
      ldv_free((void *)ldv_62_ldv_param_3_5);
    }
    
#line 20369 
    goto ldv_33094;
    default: 
#line 20371 
    ;
    
#line 20371 
    __VERIFIER_assume(0);
  }
  ldv_33094: 
#line 20380 
  ;
  
#line 20380 
  goto ldv_call_62;
  
#line 20382 
  __retres = (void *)0;
  return_label: 
#line 20382 
                return __retres;
}


#line 20387  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_115(void *arg0)
{
  void *__retres;
  struct file *ldv_115_resource_1;
  int ldv_115_ldv_param_2_3;
  long long ldv_115_ldv_param_1_2;
  char *ldv_115_ldv_param_1_4;
  struct inode *ldv_115_resource_0;
  unsigned long ldv_115_size_cnt;
  long long *ldv_115_ldv_param_3_5;
  char *ldv_115_ldv_param_1_6;
  long long *ldv_115_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 20398 
  struct file_operations *ldv_115_container = ldv_emg_alias_tx_tx_done_data_ops_2;
  
#line 20399 
  int ldv_115_ret = ldv_undef_int();
  
#line 20402 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 20406 
  ldv_115_ret = ldv_undef_int();
  
#line 20409 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 20410 
    ldv_115_container = data->arg0;
    
#line 20411 
    ldv_free((void *)data);
  }
  else ;
  
#line 20416 
  ldv_115_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 20417 
  tmp_1 = ldv_undef_int();
  
#line 20417 
  ldv_115_size_cnt = (unsigned long)tmp_1;
  
#line 20424 
  goto ldv_main_115;
  
#line 20426 
  __retres = (void *)0;
  
#line 20426 
  goto return_label;
  ldv_main_115: 
#line 20429 
  ;
  
#line 20432 
  tmp_3 = ldv_undef_int();
  
#line 20432 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 20435 
    ldv_115_ret = (*ldv_emg_alias_simple_open_5)(ldv_115_resource_0,ldv_115_resource_1);
    
#line 20437 
    ldv_115_ret = ldv_filter_err_code(ldv_115_ret);
    
#line 20440 
    tmp_2 = ldv_undef_int();
    
#line 20440 
    if (tmp_2 != 0) {
      
#line 20442 
      __VERIFIER_assume(ldv_115_ret == 0);
      
#line 20449 
      goto ldv_call_115;
    }
    else {
      
#line 20453 
      __VERIFIER_assume(ldv_115_ret != 0);
      
#line 20460 
      goto ldv_main_115;
    }
  }
  else {
    
#line 20465 
    ldv_free((void *)ldv_115_resource_0);
    
#line 20473 
    __retres = (void *)0;
    
#line 20473 
    goto return_label;
  }
  
#line 20476 
  __retres = (void *)0;
  
#line 20476 
  goto return_label;
  ldv_call_115: 
#line 20479 
  ;
  
#line 20482 
  tmp_4 = ldv_undef_int();
  
#line 20482 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 20483 
    ;
    
#line 20485 
    ldv_115_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 20486 
    ldv_115_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 20490 
    if (ldv_115_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 20496 
      __VERIFIER_assume(ldv_115_size_cnt <= 2147479552UL);
      
#line 20498 
      (*(ldv_115_container->write))(ldv_115_resource_1,(char const *)ldv_115_ldv_param_1_6,ldv_115_size_cnt,ldv_115_ldv_param_3_7);
    }
    else ;
    
#line 20503 
    ldv_free((void *)ldv_115_ldv_param_3_7);
    
#line 20504 
    ldv_free((void *)ldv_115_ldv_param_1_6);
    
#line 20511 
    goto ldv_call_115;
    case 2: 
#line 20514 
    ;
    
#line 20516 
    if (ldv_115_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 20518 
      (*(ldv_115_container->release))(ldv_115_resource_0,ldv_115_resource_1); else ;
    
#line 20526 
    goto ldv_main_115;
    case 3: 
#line 20529 
    ;
    
#line 20533 
    tmp_9 = ldv_undef_int();
    
#line 20533 
    if (tmp_9 != 0) 
#line 20536 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_115_resource_1,ldv_115_ldv_param_1_2,ldv_115_ldv_param_2_3);
    else {
      
#line 20542 
      ldv_115_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 20543 
      ldv_115_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 20548 
      ldv_emg_wrapper_tx_tx_done_data_read_3(ldv_115_resource_1,ldv_115_ldv_param_1_4,ldv_115_size_cnt,ldv_115_ldv_param_3_5);
      
#line 20552 
      ldv_free((void *)ldv_115_ldv_param_3_5);
      
#line 20553 
      ldv_free((void *)ldv_115_ldv_param_1_4);
    }
    
#line 20557 
    goto ldv_33116;
    default: 
#line 20559 
    ;
    
#line 20559 
    __VERIFIER_assume(0);
  }
  ldv_33116: 
#line 20568 
  ;
  
#line 20568 
  goto ldv_call_115;
  
#line 20570 
  __retres = (void *)0;
  return_label: 
#line 20570 
                return __retres;
}


#line 20575  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_124(void *arg0)
{
  void *__retres;
  struct file *ldv_124_resource_1;
  int ldv_124_ldv_param_2_3;
  long long ldv_124_ldv_param_1_2;
  char *ldv_124_ldv_param_1_4;
  struct inode *ldv_124_resource_0;
  unsigned long ldv_124_size_cnt;
  long long *ldv_124_ldv_param_3_5;
  char *ldv_124_ldv_param_1_6;
  long long *ldv_124_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 20586 
  struct file_operations *ldv_124_container = ldv_emg_alias_rx_filter_protection_filter_ops_2;
  
#line 20587 
  int ldv_124_ret = ldv_undef_int();
  
#line 20590 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 20594 
  ldv_124_ret = ldv_undef_int();
  
#line 20597 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 20598 
    ldv_124_container = data->arg0;
    
#line 20599 
    ldv_free((void *)data);
  }
  else ;
  
#line 20604 
  ldv_124_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 20605 
  tmp_1 = ldv_undef_int();
  
#line 20605 
  ldv_124_size_cnt = (unsigned long)tmp_1;
  
#line 20612 
  goto ldv_main_124;
  
#line 20614 
  __retres = (void *)0;
  
#line 20614 
  goto return_label;
  ldv_main_124: 
#line 20617 
  ;
  
#line 20620 
  tmp_3 = ldv_undef_int();
  
#line 20620 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 20623 
    ldv_124_ret = (*ldv_emg_alias_simple_open_5)(ldv_124_resource_0,ldv_124_resource_1);
    
#line 20625 
    ldv_124_ret = ldv_filter_err_code(ldv_124_ret);
    
#line 20628 
    tmp_2 = ldv_undef_int();
    
#line 20628 
    if (tmp_2 != 0) {
      
#line 20630 
      __VERIFIER_assume(ldv_124_ret == 0);
      
#line 20637 
      goto ldv_call_124;
    }
    else {
      
#line 20641 
      __VERIFIER_assume(ldv_124_ret != 0);
      
#line 20648 
      goto ldv_main_124;
    }
  }
  else {
    
#line 20653 
    ldv_free((void *)ldv_124_resource_0);
    
#line 20661 
    __retres = (void *)0;
    
#line 20661 
    goto return_label;
  }
  
#line 20664 
  __retres = (void *)0;
  
#line 20664 
  goto return_label;
  ldv_call_124: 
#line 20667 
  ;
  
#line 20670 
  tmp_4 = ldv_undef_int();
  
#line 20670 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 20671 
    ;
    
#line 20673 
    ldv_124_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 20674 
    ldv_124_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 20678 
    if (ldv_124_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 20684 
      __VERIFIER_assume(ldv_124_size_cnt <= 2147479552UL);
      
#line 20686 
      (*(ldv_124_container->write))(ldv_124_resource_1,(char const *)ldv_124_ldv_param_1_6,ldv_124_size_cnt,ldv_124_ldv_param_3_7);
    }
    else ;
    
#line 20691 
    ldv_free((void *)ldv_124_ldv_param_3_7);
    
#line 20692 
    ldv_free((void *)ldv_124_ldv_param_1_6);
    
#line 20699 
    goto ldv_call_124;
    case 2: 
#line 20702 
    ;
    
#line 20704 
    if (ldv_124_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 20706 
      (*(ldv_124_container->release))(ldv_124_resource_0,ldv_124_resource_1); else ;
    
#line 20714 
    goto ldv_main_124;
    case 3: 
#line 20717 
    ;
    
#line 20721 
    tmp_9 = ldv_undef_int();
    
#line 20721 
    if (tmp_9 != 0) 
#line 20724 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_124_resource_1,ldv_124_ldv_param_1_2,ldv_124_ldv_param_2_3);
    else {
      
#line 20730 
      ldv_124_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 20731 
      ldv_124_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 20736 
      ldv_emg_wrapper_rx_filter_protection_filter_read_3(ldv_124_resource_1,ldv_124_ldv_param_1_4,ldv_124_size_cnt,ldv_124_ldv_param_3_5);
      
#line 20740 
      ldv_free((void *)ldv_124_ldv_param_3_5);
      
#line 20741 
      ldv_free((void *)ldv_124_ldv_param_1_4);
    }
    
#line 20745 
    goto ldv_33138;
    default: 
#line 20747 
    ;
    
#line 20747 
    __VERIFIER_assume(0);
  }
  ldv_33138: 
#line 20756 
  ;
  
#line 20756 
  goto ldv_call_124;
  
#line 20758 
  __retres = (void *)0;
  return_label: 
#line 20758 
                return __retres;
}


#line 20763  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_45(void *arg0)
{
  void *__retres;
  struct file *ldv_45_resource_1;
  int ldv_45_ldv_param_2_3;
  long long ldv_45_ldv_param_1_2;
  char *ldv_45_ldv_param_1_4;
  struct inode *ldv_45_resource_0;
  unsigned long ldv_45_size_cnt;
  long long *ldv_45_ldv_param_3_5;
  char *ldv_45_ldv_param_1_6;
  long long *ldv_45_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 20774 
  struct file_operations *ldv_45_container = ldv_emg_alias_tx_tx_start_null_frame_ops_2;
  
#line 20775 
  int ldv_45_ret = ldv_undef_int();
  
#line 20778 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 20782 
  ldv_45_ret = ldv_undef_int();
  
#line 20785 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 20786 
    ldv_45_container = data->arg0;
    
#line 20787 
    ldv_free((void *)data);
  }
  else ;
  
#line 20792 
  ldv_45_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 20793 
  tmp_1 = ldv_undef_int();
  
#line 20793 
  ldv_45_size_cnt = (unsigned long)tmp_1;
  
#line 20800 
  goto ldv_main_45;
  
#line 20802 
  __retres = (void *)0;
  
#line 20802 
  goto return_label;
  ldv_main_45: 
#line 20805 
  ;
  
#line 20808 
  tmp_3 = ldv_undef_int();
  
#line 20808 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 20811 
    ldv_45_ret = (*ldv_emg_alias_simple_open_5)(ldv_45_resource_0,ldv_45_resource_1);
    
#line 20813 
    ldv_45_ret = ldv_filter_err_code(ldv_45_ret);
    
#line 20816 
    tmp_2 = ldv_undef_int();
    
#line 20816 
    if (tmp_2 != 0) {
      
#line 20818 
      __VERIFIER_assume(ldv_45_ret == 0);
      
#line 20825 
      goto ldv_call_45;
    }
    else {
      
#line 20829 
      __VERIFIER_assume(ldv_45_ret != 0);
      
#line 20836 
      goto ldv_main_45;
    }
  }
  else {
    
#line 20841 
    ldv_free((void *)ldv_45_resource_0);
    
#line 20849 
    __retres = (void *)0;
    
#line 20849 
    goto return_label;
  }
  
#line 20852 
  __retres = (void *)0;
  
#line 20852 
  goto return_label;
  ldv_call_45: 
#line 20855 
  ;
  
#line 20858 
  tmp_4 = ldv_undef_int();
  
#line 20858 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 20859 
    ;
    
#line 20861 
    ldv_45_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 20862 
    ldv_45_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 20866 
    if (ldv_45_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 20872 
      __VERIFIER_assume(ldv_45_size_cnt <= 2147479552UL);
      
#line 20874 
      (*(ldv_45_container->write))(ldv_45_resource_1,(char const *)ldv_45_ldv_param_1_6,ldv_45_size_cnt,ldv_45_ldv_param_3_7);
    }
    else ;
    
#line 20879 
    ldv_free((void *)ldv_45_ldv_param_1_6);
    
#line 20880 
    ldv_free((void *)ldv_45_ldv_param_3_7);
    
#line 20887 
    goto ldv_call_45;
    case 2: 
#line 20890 
    ;
    
#line 20892 
    if (ldv_45_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 20894 
      (*(ldv_45_container->release))(ldv_45_resource_0,ldv_45_resource_1); else ;
    
#line 20902 
    goto ldv_main_45;
    case 3: 
#line 20905 
    ;
    
#line 20909 
    tmp_9 = ldv_undef_int();
    
#line 20909 
    if (tmp_9 != 0) 
#line 20912 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_45_resource_1,ldv_45_ldv_param_1_2,ldv_45_ldv_param_2_3);
    else {
      
#line 20918 
      ldv_45_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 20919 
      ldv_45_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 20924 
      ldv_emg_wrapper_tx_tx_start_null_frame_read_3(ldv_45_resource_1,ldv_45_ldv_param_1_4,ldv_45_size_cnt,ldv_45_ldv_param_3_5);
      
#line 20928 
      ldv_free((void *)ldv_45_ldv_param_1_4);
      
#line 20929 
      ldv_free((void *)ldv_45_ldv_param_3_5);
    }
    
#line 20933 
    goto ldv_33160;
    default: 
#line 20935 
    ;
    
#line 20935 
    __VERIFIER_assume(0);
  }
  ldv_33160: 
#line 20944 
  ;
  
#line 20944 
  goto ldv_call_45;
  
#line 20946 
  __retres = (void *)0;
  return_label: 
#line 20946 
                return __retres;
}


#line 20951  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_89(void *arg0)
{
  void *__retres;
  struct file *ldv_89_resource_1;
  int ldv_89_ldv_param_2_3;
  long long ldv_89_ldv_param_1_2;
  char *ldv_89_ldv_param_1_4;
  struct inode *ldv_89_resource_0;
  unsigned long ldv_89_size_cnt;
  long long *ldv_89_ldv_param_3_5;
  char *ldv_89_ldv_param_1_6;
  long long *ldv_89_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 20962 
  struct file_operations *ldv_89_container = ldv_emg_alias_rx_rx_wa_ba_not_expected_ops_2;
  
#line 20963 
  int ldv_89_ret = ldv_undef_int();
  
#line 20966 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 20970 
  ldv_89_ret = ldv_undef_int();
  
#line 20973 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 20974 
    ldv_89_container = data->arg0;
    
#line 20975 
    ldv_free((void *)data);
  }
  else ;
  
#line 20980 
  ldv_89_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 20981 
  tmp_1 = ldv_undef_int();
  
#line 20981 
  ldv_89_size_cnt = (unsigned long)tmp_1;
  
#line 20988 
  goto ldv_main_89;
  
#line 20990 
  __retres = (void *)0;
  
#line 20990 
  goto return_label;
  ldv_main_89: 
#line 20993 
  ;
  
#line 20996 
  tmp_3 = ldv_undef_int();
  
#line 20996 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 20999 
    ldv_89_ret = (*ldv_emg_alias_simple_open_5)(ldv_89_resource_0,ldv_89_resource_1);
    
#line 21001 
    ldv_89_ret = ldv_filter_err_code(ldv_89_ret);
    
#line 21004 
    tmp_2 = ldv_undef_int();
    
#line 21004 
    if (tmp_2 != 0) {
      
#line 21006 
      __VERIFIER_assume(ldv_89_ret == 0);
      
#line 21013 
      goto ldv_call_89;
    }
    else {
      
#line 21017 
      __VERIFIER_assume(ldv_89_ret != 0);
      
#line 21024 
      goto ldv_main_89;
    }
  }
  else {
    
#line 21029 
    ldv_free((void *)ldv_89_resource_0);
    
#line 21037 
    __retres = (void *)0;
    
#line 21037 
    goto return_label;
  }
  
#line 21040 
  __retres = (void *)0;
  
#line 21040 
  goto return_label;
  ldv_call_89: 
#line 21043 
  ;
  
#line 21046 
  tmp_4 = ldv_undef_int();
  
#line 21046 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 21047 
    ;
    
#line 21049 
    ldv_89_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 21050 
    ldv_89_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 21054 
    if (ldv_89_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 21060 
      __VERIFIER_assume(ldv_89_size_cnt <= 2147479552UL);
      
#line 21062 
      (*(ldv_89_container->write))(ldv_89_resource_1,(char const *)ldv_89_ldv_param_1_6,ldv_89_size_cnt,ldv_89_ldv_param_3_7);
    }
    else ;
    
#line 21067 
    ldv_free((void *)ldv_89_ldv_param_3_7);
    
#line 21068 
    ldv_free((void *)ldv_89_ldv_param_1_6);
    
#line 21075 
    goto ldv_call_89;
    case 2: 
#line 21078 
    ;
    
#line 21080 
    if (ldv_89_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 21082 
      (*(ldv_89_container->release))(ldv_89_resource_0,ldv_89_resource_1); else ;
    
#line 21090 
    goto ldv_main_89;
    case 3: 
#line 21093 
    ;
    
#line 21097 
    tmp_9 = ldv_undef_int();
    
#line 21097 
    if (tmp_9 != 0) 
#line 21100 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_89_resource_1,ldv_89_ldv_param_1_2,ldv_89_ldv_param_2_3);
    else {
      
#line 21106 
      ldv_89_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 21107 
      ldv_89_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 21112 
      ldv_emg_wrapper_rx_rx_wa_ba_not_expected_read_3(ldv_89_resource_1,ldv_89_ldv_param_1_4,ldv_89_size_cnt,ldv_89_ldv_param_3_5);
      
#line 21116 
      ldv_free((void *)ldv_89_ldv_param_3_5);
      
#line 21117 
      ldv_free((void *)ldv_89_ldv_param_1_4);
    }
    
#line 21121 
    goto ldv_33182;
    default: 
#line 21123 
    ;
    
#line 21123 
    __VERIFIER_assume(0);
  }
  ldv_33182: 
#line 21132 
  ;
  
#line 21132 
  goto ldv_call_89;
  
#line 21134 
  __retres = (void *)0;
  return_label: 
#line 21134 
                return __retres;
}


#line 21139  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_36(void *arg0)
{
  void *__retres;
  struct file *ldv_36_resource_1;
  int ldv_36_ldv_param_2_3;
  long long ldv_36_ldv_param_1_2;
  char *ldv_36_ldv_param_1_4;
  struct inode *ldv_36_resource_0;
  unsigned long ldv_36_size_cnt;
  long long *ldv_36_ldv_param_3_5;
  char *ldv_36_ldv_param_1_6;
  long long *ldv_36_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 21150 
  struct file_operations *ldv_36_container = ldv_emg_alias_pipeline_defrag_to_csum_swi_ops_2;
  
#line 21151 
  int ldv_36_ret = ldv_undef_int();
  
#line 21154 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 21158 
  ldv_36_ret = ldv_undef_int();
  
#line 21161 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 21162 
    ldv_36_container = data->arg0;
    
#line 21163 
    ldv_free((void *)data);
  }
  else ;
  
#line 21168 
  ldv_36_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 21169 
  tmp_1 = ldv_undef_int();
  
#line 21169 
  ldv_36_size_cnt = (unsigned long)tmp_1;
  
#line 21176 
  goto ldv_main_36;
  
#line 21178 
  __retres = (void *)0;
  
#line 21178 
  goto return_label;
  ldv_main_36: 
#line 21181 
  ;
  
#line 21184 
  tmp_3 = ldv_undef_int();
  
#line 21184 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 21187 
    ldv_36_ret = (*ldv_emg_alias_simple_open_5)(ldv_36_resource_0,ldv_36_resource_1);
    
#line 21189 
    ldv_36_ret = ldv_filter_err_code(ldv_36_ret);
    
#line 21192 
    tmp_2 = ldv_undef_int();
    
#line 21192 
    if (tmp_2 != 0) {
      
#line 21194 
      __VERIFIER_assume(ldv_36_ret == 0);
      
#line 21201 
      goto ldv_call_36;
    }
    else {
      
#line 21205 
      __VERIFIER_assume(ldv_36_ret != 0);
      
#line 21212 
      goto ldv_main_36;
    }
  }
  else {
    
#line 21217 
    ldv_free((void *)ldv_36_resource_0);
    
#line 21225 
    __retres = (void *)0;
    
#line 21225 
    goto return_label;
  }
  
#line 21228 
  __retres = (void *)0;
  
#line 21228 
  goto return_label;
  ldv_call_36: 
#line 21231 
  ;
  
#line 21234 
  tmp_4 = ldv_undef_int();
  
#line 21234 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 21235 
    ;
    
#line 21237 
    ldv_36_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 21238 
    ldv_36_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 21242 
    if (ldv_36_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 21248 
      __VERIFIER_assume(ldv_36_size_cnt <= 2147479552UL);
      
#line 21250 
      (*(ldv_36_container->write))(ldv_36_resource_1,(char const *)ldv_36_ldv_param_1_6,ldv_36_size_cnt,ldv_36_ldv_param_3_7);
    }
    else ;
    
#line 21255 
    ldv_free((void *)ldv_36_ldv_param_1_6);
    
#line 21256 
    ldv_free((void *)ldv_36_ldv_param_3_7);
    
#line 21263 
    goto ldv_call_36;
    case 2: 
#line 21266 
    ;
    
#line 21268 
    if (ldv_36_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 21270 
      (*(ldv_36_container->release))(ldv_36_resource_0,ldv_36_resource_1); else ;
    
#line 21278 
    goto ldv_main_36;
    case 3: 
#line 21281 
    ;
    
#line 21285 
    tmp_9 = ldv_undef_int();
    
#line 21285 
    if (tmp_9 != 0) 
#line 21288 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_36_resource_1,ldv_36_ldv_param_1_2,ldv_36_ldv_param_2_3);
    else {
      
#line 21294 
      ldv_36_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 21295 
      ldv_36_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 21300 
      ldv_emg_wrapper_pipeline_defrag_to_csum_swi_read_3(ldv_36_resource_1,ldv_36_ldv_param_1_4,ldv_36_size_cnt,ldv_36_ldv_param_3_5);
      
#line 21304 
      ldv_free((void *)ldv_36_ldv_param_1_4);
      
#line 21305 
      ldv_free((void *)ldv_36_ldv_param_3_5);
    }
    
#line 21309 
    goto ldv_33204;
    default: 
#line 21311 
    ;
    
#line 21311 
    __VERIFIER_assume(0);
  }
  ldv_33204: 
#line 21320 
  ;
  
#line 21320 
  goto ldv_call_36;
  
#line 21322 
  __retres = (void *)0;
  return_label: 
#line 21322 
                return __retres;
}


#line 21327  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_platform_instance_108(void *arg0)
{
  void *__retres;
  struct platform_device *ldv_108_resource;
  int tmp_1;
  int tmp_2;
  
#line 21331 
  struct platform_driver *ldv_108_container = ldv_emg_alias_wl18xx_driver_2;
  
#line 21332 
  int ldv_108_probed = 1;
  
#line 21334 
  struct ldv_struct_platform_instance_108 *data = (struct ldv_struct_platform_instance_108 *)arg0;
  
#line 21338 
  ldv_108_probed = 1;
  
#line 21341 
  if (data != (struct ldv_struct_platform_instance_108 *)0) {
    
#line 21342 
    ldv_108_container = data->arg0;
    
#line 21343 
    ldv_free((void *)data);
  }
  else ;
  
#line 21348 
  ldv_108_resource = (struct platform_device *)ldv_xmalloc_unknown_size(0UL);
  
#line 21355 
  goto ldv_main_108;
  
#line 21357 
  __retres = (void *)0;
  
#line 21357 
  goto return_label;
  ldv_main_108: 
#line 21360 
  ;
  
#line 21363 
  tmp_1 = ldv_undef_int();
  
#line 21363 
  if (tmp_1 != 0) {
    int tmp_0;
    
#line 21366 
    ldv_pre_probe();
    
#line 21368 
    ldv_108_probed = ldv_emg_wrapper_wl18xx_probe_2(ldv_108_resource);
    
#line 21370 
    ldv_108_probed = ldv_post_probe(ldv_108_probed);
    
#line 21373 
    tmp_0 = ldv_undef_int();
    
#line 21373 
    if (tmp_0 != 0) {
      
#line 21375 
      __VERIFIER_assume(ldv_108_probed == 0);
      
#line 21382 
      goto ldv_call_108;
    }
    else {
      
#line 21386 
      __VERIFIER_assume(ldv_108_probed != 0);
      
#line 21393 
      goto ldv_main_108;
    }
  }
  else {
    
#line 21398 
    ldv_free((void *)ldv_108_resource);
    
#line 21406 
    __retres = (void *)0;
    
#line 21406 
    goto return_label;
  }
  
#line 21409 
  __retres = (void *)0;
  
#line 21409 
  goto return_label;
  ldv_call_108: 
#line 21412 
  ;
  
#line 21415 
  tmp_2 = ldv_undef_int();
  
#line 21415 
  switch (tmp_2) {
    case 1: 
#line 21416 
    ;
    
#line 21425 
    goto ldv_call_108;
    case 2: 
#line 21428 
    ;
    
#line 21430 
    ldv_dispatch_pm_register_108_13();
    
#line 21434 
    ldv_dispatch_pm_deregister_108_12();
    
#line 21441 
    goto ldv_call_108;
    case 3: 
#line 21444 
    ;
    
#line 21447 
    (*ldv_emg_alias_wlcore_remove_3)(ldv_108_resource);
    
#line 21451 
    ldv_108_probed = 1;
    
#line 21458 
    goto ldv_main_108;
    default: 
#line 21461 
    ;
    
#line 21461 
    __VERIFIER_assume(0);
  }
  
#line 21464 
  __retres = (void *)0;
  return_label: 
#line 21464 
                return __retres;
}


#line 21469  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_38(void *arg0)
{
  void *__retres;
  struct file *ldv_38_resource_1;
  int ldv_38_ldv_param_2_3;
  long long ldv_38_ldv_param_1_2;
  char *ldv_38_ldv_param_1_4;
  struct inode *ldv_38_resource_0;
  unsigned long ldv_38_size_cnt;
  long long *ldv_38_ldv_param_3_5;
  char *ldv_38_ldv_param_1_6;
  long long *ldv_38_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 21480 
  struct file_operations *ldv_38_container = ldv_emg_alias_tx_tx_data_programmed_ops_2;
  
#line 21481 
  int ldv_38_ret = ldv_undef_int();
  
#line 21484 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 21488 
  ldv_38_ret = ldv_undef_int();
  
#line 21491 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 21492 
    ldv_38_container = data->arg0;
    
#line 21493 
    ldv_free((void *)data);
  }
  else ;
  
#line 21498 
  ldv_38_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 21499 
  tmp_1 = ldv_undef_int();
  
#line 21499 
  ldv_38_size_cnt = (unsigned long)tmp_1;
  
#line 21506 
  goto ldv_main_38;
  
#line 21508 
  __retres = (void *)0;
  
#line 21508 
  goto return_label;
  ldv_main_38: 
#line 21511 
  ;
  
#line 21514 
  tmp_3 = ldv_undef_int();
  
#line 21514 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 21517 
    ldv_38_ret = (*ldv_emg_alias_simple_open_5)(ldv_38_resource_0,ldv_38_resource_1);
    
#line 21519 
    ldv_38_ret = ldv_filter_err_code(ldv_38_ret);
    
#line 21522 
    tmp_2 = ldv_undef_int();
    
#line 21522 
    if (tmp_2 != 0) {
      
#line 21524 
      __VERIFIER_assume(ldv_38_ret == 0);
      
#line 21531 
      goto ldv_call_38;
    }
    else {
      
#line 21535 
      __VERIFIER_assume(ldv_38_ret != 0);
      
#line 21542 
      goto ldv_main_38;
    }
  }
  else {
    
#line 21547 
    ldv_free((void *)ldv_38_resource_0);
    
#line 21555 
    __retres = (void *)0;
    
#line 21555 
    goto return_label;
  }
  
#line 21558 
  __retres = (void *)0;
  
#line 21558 
  goto return_label;
  ldv_call_38: 
#line 21561 
  ;
  
#line 21564 
  tmp_4 = ldv_undef_int();
  
#line 21564 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 21565 
    ;
    
#line 21567 
    ldv_38_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 21568 
    ldv_38_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 21572 
    if (ldv_38_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 21578 
      __VERIFIER_assume(ldv_38_size_cnt <= 2147479552UL);
      
#line 21580 
      (*(ldv_38_container->write))(ldv_38_resource_1,(char const *)ldv_38_ldv_param_1_6,ldv_38_size_cnt,ldv_38_ldv_param_3_7);
    }
    else ;
    
#line 21585 
    ldv_free((void *)ldv_38_ldv_param_3_7);
    
#line 21586 
    ldv_free((void *)ldv_38_ldv_param_1_6);
    
#line 21593 
    goto ldv_call_38;
    case 2: 
#line 21596 
    ;
    
#line 21598 
    if (ldv_38_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 21600 
      (*(ldv_38_container->release))(ldv_38_resource_0,ldv_38_resource_1); else ;
    
#line 21608 
    goto ldv_main_38;
    case 3: 
#line 21611 
    ;
    
#line 21615 
    tmp_9 = ldv_undef_int();
    
#line 21615 
    if (tmp_9 != 0) 
#line 21618 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_38_resource_1,ldv_38_ldv_param_1_2,ldv_38_ldv_param_2_3);
    else {
      
#line 21624 
      ldv_38_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 21625 
      ldv_38_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 21630 
      ldv_emg_wrapper_tx_tx_data_programmed_read_3(ldv_38_resource_1,ldv_38_ldv_param_1_4,ldv_38_size_cnt,ldv_38_ldv_param_3_5);
      
#line 21634 
      ldv_free((void *)ldv_38_ldv_param_3_5);
      
#line 21635 
      ldv_free((void *)ldv_38_ldv_param_1_4);
    }
    
#line 21639 
    goto ldv_33239;
    default: 
#line 21641 
    ;
    
#line 21641 
    __VERIFIER_assume(0);
  }
  ldv_33239: 
#line 21650 
  ;
  
#line 21650 
  goto ldv_call_38;
  
#line 21652 
  __retres = (void *)0;
  return_label: 
#line 21652 
                return __retres;
}


#line 21657  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_66(void *arg0)
{
  void *__retres;
  struct file *ldv_66_resource_1;
  int ldv_66_ldv_param_2_3;
  long long ldv_66_ldv_param_1_2;
  char *ldv_66_ldv_param_1_4;
  struct inode *ldv_66_resource_0;
  unsigned long ldv_66_size_cnt;
  long long *ldv_66_ldv_param_3_5;
  char *ldv_66_ldv_param_1_6;
  long long *ldv_66_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 21668 
  struct file_operations *ldv_66_container = ldv_emg_alias_tx_frag_called_ops_2;
  
#line 21669 
  int ldv_66_ret = ldv_undef_int();
  
#line 21672 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 21676 
  ldv_66_ret = ldv_undef_int();
  
#line 21679 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 21680 
    ldv_66_container = data->arg0;
    
#line 21681 
    ldv_free((void *)data);
  }
  else ;
  
#line 21686 
  ldv_66_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 21687 
  tmp_1 = ldv_undef_int();
  
#line 21687 
  ldv_66_size_cnt = (unsigned long)tmp_1;
  
#line 21694 
  goto ldv_main_66;
  
#line 21696 
  __retres = (void *)0;
  
#line 21696 
  goto return_label;
  ldv_main_66: 
#line 21699 
  ;
  
#line 21702 
  tmp_3 = ldv_undef_int();
  
#line 21702 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 21705 
    ldv_66_ret = (*ldv_emg_alias_simple_open_5)(ldv_66_resource_0,ldv_66_resource_1);
    
#line 21707 
    ldv_66_ret = ldv_filter_err_code(ldv_66_ret);
    
#line 21710 
    tmp_2 = ldv_undef_int();
    
#line 21710 
    if (tmp_2 != 0) {
      
#line 21712 
      __VERIFIER_assume(ldv_66_ret == 0);
      
#line 21719 
      goto ldv_call_66;
    }
    else {
      
#line 21723 
      __VERIFIER_assume(ldv_66_ret != 0);
      
#line 21730 
      goto ldv_main_66;
    }
  }
  else {
    
#line 21735 
    ldv_free((void *)ldv_66_resource_0);
    
#line 21743 
    __retres = (void *)0;
    
#line 21743 
    goto return_label;
  }
  
#line 21746 
  __retres = (void *)0;
  
#line 21746 
  goto return_label;
  ldv_call_66: 
#line 21749 
  ;
  
#line 21752 
  tmp_4 = ldv_undef_int();
  
#line 21752 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 21753 
    ;
    
#line 21755 
    ldv_66_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 21756 
    ldv_66_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 21760 
    if (ldv_66_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 21766 
      __VERIFIER_assume(ldv_66_size_cnt <= 2147479552UL);
      
#line 21768 
      (*(ldv_66_container->write))(ldv_66_resource_1,(char const *)ldv_66_ldv_param_1_6,ldv_66_size_cnt,ldv_66_ldv_param_3_7);
    }
    else ;
    
#line 21773 
    ldv_free((void *)ldv_66_ldv_param_1_6);
    
#line 21774 
    ldv_free((void *)ldv_66_ldv_param_3_7);
    
#line 21781 
    goto ldv_call_66;
    case 2: 
#line 21784 
    ;
    
#line 21786 
    if (ldv_66_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 21788 
      (*(ldv_66_container->release))(ldv_66_resource_0,ldv_66_resource_1); else ;
    
#line 21796 
    goto ldv_main_66;
    case 3: 
#line 21799 
    ;
    
#line 21803 
    tmp_9 = ldv_undef_int();
    
#line 21803 
    if (tmp_9 != 0) 
#line 21806 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_66_resource_1,ldv_66_ldv_param_1_2,ldv_66_ldv_param_2_3);
    else {
      
#line 21812 
      ldv_66_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 21813 
      ldv_66_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 21818 
      ldv_emg_wrapper_tx_frag_called_read_3(ldv_66_resource_1,ldv_66_ldv_param_1_4,ldv_66_size_cnt,ldv_66_ldv_param_3_5);
      
#line 21822 
      ldv_free((void *)ldv_66_ldv_param_1_4);
      
#line 21823 
      ldv_free((void *)ldv_66_ldv_param_3_5);
    }
    
#line 21827 
    goto ldv_33261;
    default: 
#line 21829 
    ;
    
#line 21829 
    __VERIFIER_assume(0);
  }
  ldv_33261: 
#line 21838 
  ;
  
#line 21838 
  goto ldv_call_66;
  
#line 21840 
  __retres = (void *)0;
  return_label: 
#line 21840 
                return __retres;
}


#line 21845  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_7(void *arg0)
{
  void *__retres;
  struct file *ldv_7_resource_1;
  int ldv_7_ldv_param_2_3;
  long long ldv_7_ldv_param_1_2;
  char *ldv_7_ldv_param_1_4;
  struct inode *ldv_7_resource_0;
  unsigned long ldv_7_size_cnt;
  long long *ldv_7_ldv_param_3_5;
  char *ldv_7_ldv_param_1_6;
  long long *ldv_7_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 21856 
  struct file_operations *ldv_7_container = ldv_emg_alias_pipeline_pre_to_defrag_swi_ops_2;
  
#line 21857 
  int ldv_7_ret = ldv_undef_int();
  
#line 21860 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 21864 
  ldv_7_ret = ldv_undef_int();
  
#line 21867 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 21868 
    ldv_7_container = data->arg0;
    
#line 21869 
    ldv_free((void *)data);
  }
  else ;
  
#line 21874 
  ldv_7_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 21875 
  tmp_1 = ldv_undef_int();
  
#line 21875 
  ldv_7_size_cnt = (unsigned long)tmp_1;
  
#line 21882 
  goto ldv_main_7;
  
#line 21884 
  __retres = (void *)0;
  
#line 21884 
  goto return_label;
  ldv_main_7: 
#line 21887 
  ;
  
#line 21890 
  tmp_3 = ldv_undef_int();
  
#line 21890 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 21893 
    ldv_7_ret = (*ldv_emg_alias_simple_open_5)(ldv_7_resource_0,ldv_7_resource_1);
    
#line 21895 
    ldv_7_ret = ldv_filter_err_code(ldv_7_ret);
    
#line 21898 
    tmp_2 = ldv_undef_int();
    
#line 21898 
    if (tmp_2 != 0) {
      
#line 21900 
      __VERIFIER_assume(ldv_7_ret == 0);
      
#line 21907 
      goto ldv_call_7;
    }
    else {
      
#line 21911 
      __VERIFIER_assume(ldv_7_ret != 0);
      
#line 21918 
      goto ldv_main_7;
    }
  }
  else {
    
#line 21923 
    ldv_free((void *)ldv_7_resource_0);
    
#line 21931 
    __retres = (void *)0;
    
#line 21931 
    goto return_label;
  }
  
#line 21934 
  __retres = (void *)0;
  
#line 21934 
  goto return_label;
  ldv_call_7: 
#line 21937 
  ;
  
#line 21940 
  tmp_4 = ldv_undef_int();
  
#line 21940 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 21941 
    ;
    
#line 21943 
    ldv_7_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 21944 
    ldv_7_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 21948 
    if (ldv_7_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 21954 
      __VERIFIER_assume(ldv_7_size_cnt <= 2147479552UL);
      
#line 21956 
      (*(ldv_7_container->write))(ldv_7_resource_1,(char const *)ldv_7_ldv_param_1_6,ldv_7_size_cnt,ldv_7_ldv_param_3_7);
    }
    else ;
    
#line 21961 
    ldv_free((void *)ldv_7_ldv_param_1_6);
    
#line 21962 
    ldv_free((void *)ldv_7_ldv_param_3_7);
    
#line 21969 
    goto ldv_call_7;
    case 2: 
#line 21972 
    ;
    
#line 21974 
    if (ldv_7_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 21976 
      (*(ldv_7_container->release))(ldv_7_resource_0,ldv_7_resource_1); else ;
    
#line 21984 
    goto ldv_main_7;
    case 3: 
#line 21987 
    ;
    
#line 21991 
    tmp_9 = ldv_undef_int();
    
#line 21991 
    if (tmp_9 != 0) 
#line 21994 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_7_resource_1,ldv_7_ldv_param_1_2,ldv_7_ldv_param_2_3);
    else {
      
#line 22000 
      ldv_7_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 22001 
      ldv_7_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 22006 
      ldv_emg_wrapper_pipeline_pre_to_defrag_swi_read_3(ldv_7_resource_1,ldv_7_ldv_param_1_4,ldv_7_size_cnt,ldv_7_ldv_param_3_5);
      
#line 22010 
      ldv_free((void *)ldv_7_ldv_param_3_5);
      
#line 22011 
      ldv_free((void *)ldv_7_ldv_param_1_4);
    }
    
#line 22015 
    goto ldv_33283;
    default: 
#line 22017 
    ;
    
#line 22017 
    __VERIFIER_assume(0);
  }
  ldv_33283: 
#line 22026 
  ;
  
#line 22026 
  goto ldv_call_7;
  
#line 22028 
  __retres = (void *)0;
  return_label: 
#line 22028 
                return __retres;
}


#line 22033  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_102(void *arg0)
{
  void *__retres;
  struct file *ldv_102_resource_1;
  int ldv_102_ldv_param_2_3;
  long long ldv_102_ldv_param_1_2;
  char *ldv_102_ldv_param_1_4;
  struct inode *ldv_102_resource_0;
  unsigned long ldv_102_size_cnt;
  long long *ldv_102_ldv_param_3_5;
  char *ldv_102_ldv_param_1_6;
  long long *ldv_102_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 22044 
  struct file_operations *ldv_102_container = ldv_emg_alias_pipeline_enc_rx_stat_fifo_int_ops_2;
  
#line 22045 
  int ldv_102_ret = ldv_undef_int();
  
#line 22048 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 22052 
  ldv_102_ret = ldv_undef_int();
  
#line 22055 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 22056 
    ldv_102_container = data->arg0;
    
#line 22057 
    ldv_free((void *)data);
  }
  else ;
  
#line 22062 
  ldv_102_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 22063 
  tmp_1 = ldv_undef_int();
  
#line 22063 
  ldv_102_size_cnt = (unsigned long)tmp_1;
  
#line 22070 
  goto ldv_main_102;
  
#line 22072 
  __retres = (void *)0;
  
#line 22072 
  goto return_label;
  ldv_main_102: 
#line 22075 
  ;
  
#line 22078 
  tmp_3 = ldv_undef_int();
  
#line 22078 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 22081 
    ldv_102_ret = (*ldv_emg_alias_simple_open_5)(ldv_102_resource_0,ldv_102_resource_1);
    
#line 22083 
    ldv_102_ret = ldv_filter_err_code(ldv_102_ret);
    
#line 22086 
    tmp_2 = ldv_undef_int();
    
#line 22086 
    if (tmp_2 != 0) {
      
#line 22088 
      __VERIFIER_assume(ldv_102_ret == 0);
      
#line 22095 
      goto ldv_call_102;
    }
    else {
      
#line 22099 
      __VERIFIER_assume(ldv_102_ret != 0);
      
#line 22106 
      goto ldv_main_102;
    }
  }
  else {
    
#line 22111 
    ldv_free((void *)ldv_102_resource_0);
    
#line 22119 
    __retres = (void *)0;
    
#line 22119 
    goto return_label;
  }
  
#line 22122 
  __retres = (void *)0;
  
#line 22122 
  goto return_label;
  ldv_call_102: 
#line 22125 
  ;
  
#line 22128 
  tmp_4 = ldv_undef_int();
  
#line 22128 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 22129 
    ;
    
#line 22131 
    ldv_102_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 22132 
    ldv_102_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 22136 
    if (ldv_102_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 22142 
      __VERIFIER_assume(ldv_102_size_cnt <= 2147479552UL);
      
#line 22144 
      (*(ldv_102_container->write))(ldv_102_resource_1,(char const *)ldv_102_ldv_param_1_6,ldv_102_size_cnt,ldv_102_ldv_param_3_7);
    }
    else ;
    
#line 22149 
    ldv_free((void *)ldv_102_ldv_param_1_6);
    
#line 22150 
    ldv_free((void *)ldv_102_ldv_param_3_7);
    
#line 22157 
    goto ldv_call_102;
    case 2: 
#line 22160 
    ;
    
#line 22162 
    if (ldv_102_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 22164 
      (*(ldv_102_container->release))(ldv_102_resource_0,ldv_102_resource_1); else ;
    
#line 22172 
    goto ldv_main_102;
    case 3: 
#line 22175 
    ;
    
#line 22179 
    tmp_9 = ldv_undef_int();
    
#line 22179 
    if (tmp_9 != 0) 
#line 22182 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_102_resource_1,ldv_102_ldv_param_1_2,ldv_102_ldv_param_2_3);
    else {
      
#line 22188 
      ldv_102_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 22189 
      ldv_102_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 22194 
      ldv_emg_wrapper_pipeline_enc_rx_stat_fifo_int_read_3(ldv_102_resource_1,ldv_102_ldv_param_1_4,ldv_102_size_cnt,ldv_102_ldv_param_3_5);
      
#line 22198 
      ldv_free((void *)ldv_102_ldv_param_1_4);
      
#line 22199 
      ldv_free((void *)ldv_102_ldv_param_3_5);
    }
    
#line 22203 
    goto ldv_33305;
    default: 
#line 22205 
    ;
    
#line 22205 
    __VERIFIER_assume(0);
  }
  ldv_33305: 
#line 22214 
  ;
  
#line 22214 
  goto ldv_call_102;
  
#line 22216 
  __retres = (void *)0;
  return_label: 
#line 22216 
                return __retres;
}


#line 22221  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_126(void *arg0)
{
  void *__retres;
  struct file *ldv_126_resource_1;
  int ldv_126_ldv_param_2_3;
  long long ldv_126_ldv_param_1_2;
  char *ldv_126_ldv_param_1_4;
  struct inode *ldv_126_resource_0;
  unsigned long ldv_126_size_cnt;
  long long *ldv_126_ldv_param_3_5;
  char *ldv_126_ldv_param_1_6;
  long long *ldv_126_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 22232 
  struct file_operations *ldv_126_container = ldv_emg_alias_pipeline_tcp_tx_stat_fifo_int_ops_2;
  
#line 22233 
  int ldv_126_ret = ldv_undef_int();
  
#line 22236 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 22240 
  ldv_126_ret = ldv_undef_int();
  
#line 22243 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 22244 
    ldv_126_container = data->arg0;
    
#line 22245 
    ldv_free((void *)data);
  }
  else ;
  
#line 22250 
  ldv_126_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 22251 
  tmp_1 = ldv_undef_int();
  
#line 22251 
  ldv_126_size_cnt = (unsigned long)tmp_1;
  
#line 22258 
  goto ldv_main_126;
  
#line 22260 
  __retres = (void *)0;
  
#line 22260 
  goto return_label;
  ldv_main_126: 
#line 22263 
  ;
  
#line 22266 
  tmp_3 = ldv_undef_int();
  
#line 22266 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 22269 
    ldv_126_ret = (*ldv_emg_alias_simple_open_5)(ldv_126_resource_0,ldv_126_resource_1);
    
#line 22271 
    ldv_126_ret = ldv_filter_err_code(ldv_126_ret);
    
#line 22274 
    tmp_2 = ldv_undef_int();
    
#line 22274 
    if (tmp_2 != 0) {
      
#line 22276 
      __VERIFIER_assume(ldv_126_ret == 0);
      
#line 22283 
      goto ldv_call_126;
    }
    else {
      
#line 22287 
      __VERIFIER_assume(ldv_126_ret != 0);
      
#line 22294 
      goto ldv_main_126;
    }
  }
  else {
    
#line 22299 
    ldv_free((void *)ldv_126_resource_0);
    
#line 22307 
    __retres = (void *)0;
    
#line 22307 
    goto return_label;
  }
  
#line 22310 
  __retres = (void *)0;
  
#line 22310 
  goto return_label;
  ldv_call_126: 
#line 22313 
  ;
  
#line 22316 
  tmp_4 = ldv_undef_int();
  
#line 22316 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 22317 
    ;
    
#line 22319 
    ldv_126_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 22320 
    ldv_126_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 22324 
    if (ldv_126_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 22330 
      __VERIFIER_assume(ldv_126_size_cnt <= 2147479552UL);
      
#line 22332 
      (*(ldv_126_container->write))(ldv_126_resource_1,(char const *)ldv_126_ldv_param_1_6,ldv_126_size_cnt,ldv_126_ldv_param_3_7);
    }
    else ;
    
#line 22337 
    ldv_free((void *)ldv_126_ldv_param_1_6);
    
#line 22338 
    ldv_free((void *)ldv_126_ldv_param_3_7);
    
#line 22345 
    goto ldv_call_126;
    case 2: 
#line 22348 
    ;
    
#line 22350 
    if (ldv_126_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 22352 
      (*(ldv_126_container->release))(ldv_126_resource_0,ldv_126_resource_1); else ;
    
#line 22360 
    goto ldv_main_126;
    case 3: 
#line 22363 
    ;
    
#line 22367 
    tmp_9 = ldv_undef_int();
    
#line 22367 
    if (tmp_9 != 0) 
#line 22370 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_126_resource_1,ldv_126_ldv_param_1_2,ldv_126_ldv_param_2_3);
    else {
      
#line 22376 
      ldv_126_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 22377 
      ldv_126_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 22382 
      ldv_emg_wrapper_pipeline_tcp_tx_stat_fifo_int_read_3(ldv_126_resource_1,ldv_126_ldv_param_1_4,ldv_126_size_cnt,ldv_126_ldv_param_3_5);
      
#line 22386 
      ldv_free((void *)ldv_126_ldv_param_1_4);
      
#line 22387 
      ldv_free((void *)ldv_126_ldv_param_3_5);
    }
    
#line 22391 
    goto ldv_33327;
    default: 
#line 22393 
    ;
    
#line 22393 
    __VERIFIER_assume(0);
  }
  ldv_33327: 
#line 22402 
  ;
  
#line 22402 
  goto ldv_call_126;
  
#line 22404 
  __retres = (void *)0;
  return_label: 
#line 22404 
                return __retres;
}


#line 22409  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_54(void *arg0)
{
  void *__retres;
  struct file *ldv_54_resource_1;
  int ldv_54_ldv_param_2_3;
  long long ldv_54_ldv_param_1_2;
  char *ldv_54_ldv_param_1_4;
  struct inode *ldv_54_resource_0;
  unsigned long ldv_54_size_cnt;
  long long *ldv_54_ldv_param_3_5;
  char *ldv_54_ldv_param_1_6;
  long long *ldv_54_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 22420 
  struct file_operations *ldv_54_container = ldv_emg_alias_tx_frag_init_called_ops_2;
  
#line 22421 
  int ldv_54_ret = ldv_undef_int();
  
#line 22424 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 22428 
  ldv_54_ret = ldv_undef_int();
  
#line 22431 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 22432 
    ldv_54_container = data->arg0;
    
#line 22433 
    ldv_free((void *)data);
  }
  else ;
  
#line 22438 
  ldv_54_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 22439 
  tmp_1 = ldv_undef_int();
  
#line 22439 
  ldv_54_size_cnt = (unsigned long)tmp_1;
  
#line 22446 
  goto ldv_main_54;
  
#line 22448 
  __retres = (void *)0;
  
#line 22448 
  goto return_label;
  ldv_main_54: 
#line 22451 
  ;
  
#line 22454 
  tmp_3 = ldv_undef_int();
  
#line 22454 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 22457 
    ldv_54_ret = (*ldv_emg_alias_simple_open_5)(ldv_54_resource_0,ldv_54_resource_1);
    
#line 22459 
    ldv_54_ret = ldv_filter_err_code(ldv_54_ret);
    
#line 22462 
    tmp_2 = ldv_undef_int();
    
#line 22462 
    if (tmp_2 != 0) {
      
#line 22464 
      __VERIFIER_assume(ldv_54_ret == 0);
      
#line 22471 
      goto ldv_call_54;
    }
    else {
      
#line 22475 
      __VERIFIER_assume(ldv_54_ret != 0);
      
#line 22482 
      goto ldv_main_54;
    }
  }
  else {
    
#line 22487 
    ldv_free((void *)ldv_54_resource_0);
    
#line 22495 
    __retres = (void *)0;
    
#line 22495 
    goto return_label;
  }
  
#line 22498 
  __retres = (void *)0;
  
#line 22498 
  goto return_label;
  ldv_call_54: 
#line 22501 
  ;
  
#line 22504 
  tmp_4 = ldv_undef_int();
  
#line 22504 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 22505 
    ;
    
#line 22507 
    ldv_54_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 22508 
    ldv_54_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 22512 
    if (ldv_54_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 22518 
      __VERIFIER_assume(ldv_54_size_cnt <= 2147479552UL);
      
#line 22520 
      (*(ldv_54_container->write))(ldv_54_resource_1,(char const *)ldv_54_ldv_param_1_6,ldv_54_size_cnt,ldv_54_ldv_param_3_7);
    }
    else ;
    
#line 22525 
    ldv_free((void *)ldv_54_ldv_param_3_7);
    
#line 22526 
    ldv_free((void *)ldv_54_ldv_param_1_6);
    
#line 22533 
    goto ldv_call_54;
    case 2: 
#line 22536 
    ;
    
#line 22538 
    if (ldv_54_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 22540 
      (*(ldv_54_container->release))(ldv_54_resource_0,ldv_54_resource_1); else ;
    
#line 22548 
    goto ldv_main_54;
    case 3: 
#line 22551 
    ;
    
#line 22555 
    tmp_9 = ldv_undef_int();
    
#line 22555 
    if (tmp_9 != 0) 
#line 22558 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_54_resource_1,ldv_54_ldv_param_1_2,ldv_54_ldv_param_2_3);
    else {
      
#line 22564 
      ldv_54_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 22565 
      ldv_54_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 22570 
      ldv_emg_wrapper_tx_frag_init_called_read_3(ldv_54_resource_1,ldv_54_ldv_param_1_4,ldv_54_size_cnt,ldv_54_ldv_param_3_5);
      
#line 22574 
      ldv_free((void *)ldv_54_ldv_param_3_5);
      
#line 22575 
      ldv_free((void *)ldv_54_ldv_param_1_4);
    }
    
#line 22579 
    goto ldv_33349;
    default: 
#line 22581 
    ;
    
#line 22581 
    __VERIFIER_assume(0);
  }
  ldv_33349: 
#line 22590 
  ;
  
#line 22590 
  goto ldv_call_54;
  
#line 22592 
  __retres = (void *)0;
  return_label: 
#line 22592 
                return __retres;
}


#line 22597  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_28(void *arg0)
{
  void *__retres;
  struct file *ldv_28_resource_1;
  int ldv_28_ldv_param_2_3;
  long long ldv_28_ldv_param_1_2;
  char *ldv_28_ldv_param_1_4;
  struct inode *ldv_28_resource_0;
  unsigned long ldv_28_size_cnt;
  long long *ldv_28_ldv_param_3_5;
  char *ldv_28_ldv_param_1_6;
  long long *ldv_28_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 22608 
  struct file_operations *ldv_28_container = ldv_emg_alias_rx_rx_tkip_replays_ops_2;
  
#line 22609 
  int ldv_28_ret = ldv_undef_int();
  
#line 22612 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 22616 
  ldv_28_ret = ldv_undef_int();
  
#line 22619 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 22620 
    ldv_28_container = data->arg0;
    
#line 22621 
    ldv_free((void *)data);
  }
  else ;
  
#line 22626 
  ldv_28_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 22627 
  tmp_1 = ldv_undef_int();
  
#line 22627 
  ldv_28_size_cnt = (unsigned long)tmp_1;
  
#line 22634 
  goto ldv_main_28;
  
#line 22636 
  __retres = (void *)0;
  
#line 22636 
  goto return_label;
  ldv_main_28: 
#line 22639 
  ;
  
#line 22642 
  tmp_3 = ldv_undef_int();
  
#line 22642 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 22645 
    ldv_28_ret = (*ldv_emg_alias_simple_open_5)(ldv_28_resource_0,ldv_28_resource_1);
    
#line 22647 
    ldv_28_ret = ldv_filter_err_code(ldv_28_ret);
    
#line 22650 
    tmp_2 = ldv_undef_int();
    
#line 22650 
    if (tmp_2 != 0) {
      
#line 22652 
      __VERIFIER_assume(ldv_28_ret == 0);
      
#line 22659 
      goto ldv_call_28;
    }
    else {
      
#line 22663 
      __VERIFIER_assume(ldv_28_ret != 0);
      
#line 22670 
      goto ldv_main_28;
    }
  }
  else {
    
#line 22675 
    ldv_free((void *)ldv_28_resource_0);
    
#line 22683 
    __retres = (void *)0;
    
#line 22683 
    goto return_label;
  }
  
#line 22686 
  __retres = (void *)0;
  
#line 22686 
  goto return_label;
  ldv_call_28: 
#line 22689 
  ;
  
#line 22692 
  tmp_4 = ldv_undef_int();
  
#line 22692 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 22693 
    ;
    
#line 22695 
    ldv_28_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 22696 
    ldv_28_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 22700 
    if (ldv_28_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 22706 
      __VERIFIER_assume(ldv_28_size_cnt <= 2147479552UL);
      
#line 22708 
      (*(ldv_28_container->write))(ldv_28_resource_1,(char const *)ldv_28_ldv_param_1_6,ldv_28_size_cnt,ldv_28_ldv_param_3_7);
    }
    else ;
    
#line 22713 
    ldv_free((void *)ldv_28_ldv_param_3_7);
    
#line 22714 
    ldv_free((void *)ldv_28_ldv_param_1_6);
    
#line 22721 
    goto ldv_call_28;
    case 2: 
#line 22724 
    ;
    
#line 22726 
    if (ldv_28_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 22728 
      (*(ldv_28_container->release))(ldv_28_resource_0,ldv_28_resource_1); else ;
    
#line 22736 
    goto ldv_main_28;
    case 3: 
#line 22739 
    ;
    
#line 22743 
    tmp_9 = ldv_undef_int();
    
#line 22743 
    if (tmp_9 != 0) 
#line 22746 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_28_resource_1,ldv_28_ldv_param_1_2,ldv_28_ldv_param_2_3);
    else {
      
#line 22752 
      ldv_28_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 22753 
      ldv_28_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 22758 
      ldv_emg_wrapper_rx_rx_tkip_replays_read_3(ldv_28_resource_1,ldv_28_ldv_param_1_4,ldv_28_size_cnt,ldv_28_ldv_param_3_5);
      
#line 22762 
      ldv_free((void *)ldv_28_ldv_param_3_5);
      
#line 22763 
      ldv_free((void *)ldv_28_ldv_param_1_4);
    }
    
#line 22767 
    goto ldv_33371;
    default: 
#line 22769 
    ;
    
#line 22769 
    __VERIFIER_assume(0);
  }
  ldv_33371: 
#line 22778 
  ;
  
#line 22778 
  goto ldv_call_28;
  
#line 22780 
  __retres = (void *)0;
  return_label: 
#line 22780 
                return __retres;
}


#line 22785  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_56(void *arg0)
{
  void *__retres;
  struct file *ldv_56_resource_1;
  int ldv_56_ldv_param_2_3;
  long long ldv_56_ldv_param_1_2;
  char *ldv_56_ldv_param_1_4;
  struct inode *ldv_56_resource_0;
  unsigned long ldv_56_size_cnt;
  long long *ldv_56_ldv_param_3_5;
  char *ldv_56_ldv_param_1_6;
  long long *ldv_56_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 22796 
  struct file_operations *ldv_56_container = ldv_emg_alias_debug_debug4_ops_2;
  
#line 22797 
  int ldv_56_ret = ldv_undef_int();
  
#line 22800 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 22804 
  ldv_56_ret = ldv_undef_int();
  
#line 22807 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 22808 
    ldv_56_container = data->arg0;
    
#line 22809 
    ldv_free((void *)data);
  }
  else ;
  
#line 22814 
  ldv_56_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 22815 
  tmp_1 = ldv_undef_int();
  
#line 22815 
  ldv_56_size_cnt = (unsigned long)tmp_1;
  
#line 22822 
  goto ldv_main_56;
  
#line 22824 
  __retres = (void *)0;
  
#line 22824 
  goto return_label;
  ldv_main_56: 
#line 22827 
  ;
  
#line 22830 
  tmp_3 = ldv_undef_int();
  
#line 22830 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 22833 
    ldv_56_ret = (*ldv_emg_alias_simple_open_5)(ldv_56_resource_0,ldv_56_resource_1);
    
#line 22835 
    ldv_56_ret = ldv_filter_err_code(ldv_56_ret);
    
#line 22838 
    tmp_2 = ldv_undef_int();
    
#line 22838 
    if (tmp_2 != 0) {
      
#line 22840 
      __VERIFIER_assume(ldv_56_ret == 0);
      
#line 22847 
      goto ldv_call_56;
    }
    else {
      
#line 22851 
      __VERIFIER_assume(ldv_56_ret != 0);
      
#line 22858 
      goto ldv_main_56;
    }
  }
  else {
    
#line 22863 
    ldv_free((void *)ldv_56_resource_0);
    
#line 22871 
    __retres = (void *)0;
    
#line 22871 
    goto return_label;
  }
  
#line 22874 
  __retres = (void *)0;
  
#line 22874 
  goto return_label;
  ldv_call_56: 
#line 22877 
  ;
  
#line 22880 
  tmp_4 = ldv_undef_int();
  
#line 22880 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 22881 
    ;
    
#line 22883 
    ldv_56_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 22884 
    ldv_56_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 22888 
    if (ldv_56_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 22894 
      __VERIFIER_assume(ldv_56_size_cnt <= 2147479552UL);
      
#line 22896 
      (*(ldv_56_container->write))(ldv_56_resource_1,(char const *)ldv_56_ldv_param_1_6,ldv_56_size_cnt,ldv_56_ldv_param_3_7);
    }
    else ;
    
#line 22901 
    ldv_free((void *)ldv_56_ldv_param_3_7);
    
#line 22902 
    ldv_free((void *)ldv_56_ldv_param_1_6);
    
#line 22909 
    goto ldv_call_56;
    case 2: 
#line 22912 
    ;
    
#line 22914 
    if (ldv_56_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 22916 
      (*(ldv_56_container->release))(ldv_56_resource_0,ldv_56_resource_1); else ;
    
#line 22924 
    goto ldv_main_56;
    case 3: 
#line 22927 
    ;
    
#line 22931 
    tmp_9 = ldv_undef_int();
    
#line 22931 
    if (tmp_9 != 0) 
#line 22934 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_56_resource_1,ldv_56_ldv_param_1_2,ldv_56_ldv_param_2_3);
    else {
      
#line 22940 
      ldv_56_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 22941 
      ldv_56_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 22946 
      ldv_emg_wrapper_debug_debug4_read_3(ldv_56_resource_1,ldv_56_ldv_param_1_4,ldv_56_size_cnt,ldv_56_ldv_param_3_5);
      
#line 22950 
      ldv_free((void *)ldv_56_ldv_param_3_5);
      
#line 22951 
      ldv_free((void *)ldv_56_ldv_param_1_4);
    }
    
#line 22955 
    goto ldv_33393;
    default: 
#line 22957 
    ;
    
#line 22957 
    __VERIFIER_assume(0);
  }
  ldv_33393: 
#line 22966 
  ;
  
#line 22966 
  goto ldv_call_56;
  
#line 22968 
  __retres = (void *)0;
  return_label: 
#line 22968 
                return __retres;
}


#line 22973  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_23(void *arg0)
{
  void *__retres;
  struct file *ldv_23_resource_1;
  int ldv_23_ldv_param_2_3;
  long long ldv_23_ldv_param_1_2;
  char *ldv_23_ldv_param_1_4;
  struct inode *ldv_23_resource_0;
  unsigned long ldv_23_size_cnt;
  long long *ldv_23_ldv_param_3_5;
  char *ldv_23_ldv_param_1_6;
  long long *ldv_23_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 22984 
  struct file_operations *ldv_23_container = ldv_emg_alias_rx_rx_dropped_frame_ops_2;
  
#line 22985 
  int ldv_23_ret = ldv_undef_int();
  
#line 22988 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 22992 
  ldv_23_ret = ldv_undef_int();
  
#line 22995 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 22996 
    ldv_23_container = data->arg0;
    
#line 22997 
    ldv_free((void *)data);
  }
  else ;
  
#line 23002 
  ldv_23_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 23003 
  tmp_1 = ldv_undef_int();
  
#line 23003 
  ldv_23_size_cnt = (unsigned long)tmp_1;
  
#line 23010 
  goto ldv_main_23;
  
#line 23012 
  __retres = (void *)0;
  
#line 23012 
  goto return_label;
  ldv_main_23: 
#line 23015 
  ;
  
#line 23018 
  tmp_3 = ldv_undef_int();
  
#line 23018 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 23021 
    ldv_23_ret = (*ldv_emg_alias_simple_open_5)(ldv_23_resource_0,ldv_23_resource_1);
    
#line 23023 
    ldv_23_ret = ldv_filter_err_code(ldv_23_ret);
    
#line 23026 
    tmp_2 = ldv_undef_int();
    
#line 23026 
    if (tmp_2 != 0) {
      
#line 23028 
      __VERIFIER_assume(ldv_23_ret == 0);
      
#line 23035 
      goto ldv_call_23;
    }
    else {
      
#line 23039 
      __VERIFIER_assume(ldv_23_ret != 0);
      
#line 23046 
      goto ldv_main_23;
    }
  }
  else {
    
#line 23051 
    ldv_free((void *)ldv_23_resource_0);
    
#line 23059 
    __retres = (void *)0;
    
#line 23059 
    goto return_label;
  }
  
#line 23062 
  __retres = (void *)0;
  
#line 23062 
  goto return_label;
  ldv_call_23: 
#line 23065 
  ;
  
#line 23068 
  tmp_4 = ldv_undef_int();
  
#line 23068 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 23069 
    ;
    
#line 23071 
    ldv_23_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 23072 
    ldv_23_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 23076 
    if (ldv_23_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 23082 
      __VERIFIER_assume(ldv_23_size_cnt <= 2147479552UL);
      
#line 23084 
      (*(ldv_23_container->write))(ldv_23_resource_1,(char const *)ldv_23_ldv_param_1_6,ldv_23_size_cnt,ldv_23_ldv_param_3_7);
    }
    else ;
    
#line 23089 
    ldv_free((void *)ldv_23_ldv_param_3_7);
    
#line 23090 
    ldv_free((void *)ldv_23_ldv_param_1_6);
    
#line 23097 
    goto ldv_call_23;
    case 2: 
#line 23100 
    ;
    
#line 23102 
    if (ldv_23_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 23104 
      (*(ldv_23_container->release))(ldv_23_resource_0,ldv_23_resource_1); else ;
    
#line 23112 
    goto ldv_main_23;
    case 3: 
#line 23115 
    ;
    
#line 23119 
    tmp_9 = ldv_undef_int();
    
#line 23119 
    if (tmp_9 != 0) 
#line 23122 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_23_resource_1,ldv_23_ldv_param_1_2,ldv_23_ldv_param_2_3);
    else {
      
#line 23128 
      ldv_23_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 23129 
      ldv_23_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 23134 
      ldv_emg_wrapper_rx_rx_dropped_frame_read_3(ldv_23_resource_1,ldv_23_ldv_param_1_4,ldv_23_size_cnt,ldv_23_ldv_param_3_5);
      
#line 23138 
      ldv_free((void *)ldv_23_ldv_param_1_4);
      
#line 23139 
      ldv_free((void *)ldv_23_ldv_param_3_5);
    }
    
#line 23143 
    goto ldv_33415;
    default: 
#line 23145 
    ;
    
#line 23145 
    __VERIFIER_assume(0);
  }
  ldv_33415: 
#line 23154 
  ;
  
#line 23154 
  goto ldv_call_23;
  
#line 23156 
  __retres = (void *)0;
  return_label: 
#line 23156 
                return __retres;
}


#line 23161  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_27(void *arg0)
{
  void *__retres;
  struct file *ldv_27_resource_1;
  int ldv_27_ldv_param_2_3;
  long long ldv_27_ldv_param_1_2;
  char *ldv_27_ldv_param_1_4;
  struct inode *ldv_27_resource_0;
  unsigned long ldv_27_size_cnt;
  long long *ldv_27_ldv_param_3_5;
  char *ldv_27_ldv_param_1_6;
  long long *ldv_27_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 23172 
  struct file_operations *ldv_27_container = ldv_emg_alias_debug_debug2_ops_2;
  
#line 23173 
  int ldv_27_ret = ldv_undef_int();
  
#line 23176 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 23180 
  ldv_27_ret = ldv_undef_int();
  
#line 23183 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 23184 
    ldv_27_container = data->arg0;
    
#line 23185 
    ldv_free((void *)data);
  }
  else ;
  
#line 23190 
  ldv_27_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 23191 
  tmp_1 = ldv_undef_int();
  
#line 23191 
  ldv_27_size_cnt = (unsigned long)tmp_1;
  
#line 23198 
  goto ldv_main_27;
  
#line 23200 
  __retres = (void *)0;
  
#line 23200 
  goto return_label;
  ldv_main_27: 
#line 23203 
  ;
  
#line 23206 
  tmp_3 = ldv_undef_int();
  
#line 23206 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 23209 
    ldv_27_ret = (*ldv_emg_alias_simple_open_5)(ldv_27_resource_0,ldv_27_resource_1);
    
#line 23211 
    ldv_27_ret = ldv_filter_err_code(ldv_27_ret);
    
#line 23214 
    tmp_2 = ldv_undef_int();
    
#line 23214 
    if (tmp_2 != 0) {
      
#line 23216 
      __VERIFIER_assume(ldv_27_ret == 0);
      
#line 23223 
      goto ldv_call_27;
    }
    else {
      
#line 23227 
      __VERIFIER_assume(ldv_27_ret != 0);
      
#line 23234 
      goto ldv_main_27;
    }
  }
  else {
    
#line 23239 
    ldv_free((void *)ldv_27_resource_0);
    
#line 23247 
    __retres = (void *)0;
    
#line 23247 
    goto return_label;
  }
  
#line 23250 
  __retres = (void *)0;
  
#line 23250 
  goto return_label;
  ldv_call_27: 
#line 23253 
  ;
  
#line 23256 
  tmp_4 = ldv_undef_int();
  
#line 23256 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 23257 
    ;
    
#line 23259 
    ldv_27_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 23260 
    ldv_27_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 23264 
    if (ldv_27_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 23270 
      __VERIFIER_assume(ldv_27_size_cnt <= 2147479552UL);
      
#line 23272 
      (*(ldv_27_container->write))(ldv_27_resource_1,(char const *)ldv_27_ldv_param_1_6,ldv_27_size_cnt,ldv_27_ldv_param_3_7);
    }
    else ;
    
#line 23277 
    ldv_free((void *)ldv_27_ldv_param_3_7);
    
#line 23278 
    ldv_free((void *)ldv_27_ldv_param_1_6);
    
#line 23285 
    goto ldv_call_27;
    case 2: 
#line 23288 
    ;
    
#line 23290 
    if (ldv_27_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 23292 
      (*(ldv_27_container->release))(ldv_27_resource_0,ldv_27_resource_1); else ;
    
#line 23300 
    goto ldv_main_27;
    case 3: 
#line 23303 
    ;
    
#line 23307 
    tmp_9 = ldv_undef_int();
    
#line 23307 
    if (tmp_9 != 0) 
#line 23310 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_27_resource_1,ldv_27_ldv_param_1_2,ldv_27_ldv_param_2_3);
    else {
      
#line 23316 
      ldv_27_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 23317 
      ldv_27_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 23322 
      ldv_emg_wrapper_debug_debug2_read_3(ldv_27_resource_1,ldv_27_ldv_param_1_4,ldv_27_size_cnt,ldv_27_ldv_param_3_5);
      
#line 23326 
      ldv_free((void *)ldv_27_ldv_param_3_5);
      
#line 23327 
      ldv_free((void *)ldv_27_ldv_param_1_4);
    }
    
#line 23331 
    goto ldv_33437;
    default: 
#line 23333 
    ;
    
#line 23333 
    __VERIFIER_assume(0);
  }
  ldv_33437: 
#line 23342 
  ;
  
#line 23342 
  goto ldv_call_27;
  
#line 23344 
  __retres = (void *)0;
  return_label: 
#line 23344 
                return __retres;
}


#line 23349  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_33(void *arg0)
{
  void *__retres;
  struct file *ldv_33_resource_1;
  int ldv_33_ldv_param_2_3;
  long long ldv_33_ldv_param_1_2;
  char *ldv_33_ldv_param_1_4;
  struct inode *ldv_33_resource_0;
  unsigned long ldv_33_size_cnt;
  long long *ldv_33_ldv_param_3_5;
  char *ldv_33_ldv_param_1_6;
  long long *ldv_33_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 23360 
  struct file_operations *ldv_33_container = ldv_emg_alias_rx_rx_timeout_ops_2;
  
#line 23361 
  int ldv_33_ret = ldv_undef_int();
  
#line 23364 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 23368 
  ldv_33_ret = ldv_undef_int();
  
#line 23371 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 23372 
    ldv_33_container = data->arg0;
    
#line 23373 
    ldv_free((void *)data);
  }
  else ;
  
#line 23378 
  ldv_33_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 23379 
  tmp_1 = ldv_undef_int();
  
#line 23379 
  ldv_33_size_cnt = (unsigned long)tmp_1;
  
#line 23386 
  goto ldv_main_33;
  
#line 23388 
  __retres = (void *)0;
  
#line 23388 
  goto return_label;
  ldv_main_33: 
#line 23391 
  ;
  
#line 23394 
  tmp_3 = ldv_undef_int();
  
#line 23394 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 23397 
    ldv_33_ret = (*ldv_emg_alias_simple_open_5)(ldv_33_resource_0,ldv_33_resource_1);
    
#line 23399 
    ldv_33_ret = ldv_filter_err_code(ldv_33_ret);
    
#line 23402 
    tmp_2 = ldv_undef_int();
    
#line 23402 
    if (tmp_2 != 0) {
      
#line 23404 
      __VERIFIER_assume(ldv_33_ret == 0);
      
#line 23411 
      goto ldv_call_33;
    }
    else {
      
#line 23415 
      __VERIFIER_assume(ldv_33_ret != 0);
      
#line 23422 
      goto ldv_main_33;
    }
  }
  else {
    
#line 23427 
    ldv_free((void *)ldv_33_resource_0);
    
#line 23435 
    __retres = (void *)0;
    
#line 23435 
    goto return_label;
  }
  
#line 23438 
  __retres = (void *)0;
  
#line 23438 
  goto return_label;
  ldv_call_33: 
#line 23441 
  ;
  
#line 23444 
  tmp_4 = ldv_undef_int();
  
#line 23444 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 23445 
    ;
    
#line 23447 
    ldv_33_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 23448 
    ldv_33_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 23452 
    if (ldv_33_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 23458 
      __VERIFIER_assume(ldv_33_size_cnt <= 2147479552UL);
      
#line 23460 
      (*(ldv_33_container->write))(ldv_33_resource_1,(char const *)ldv_33_ldv_param_1_6,ldv_33_size_cnt,ldv_33_ldv_param_3_7);
    }
    else ;
    
#line 23465 
    ldv_free((void *)ldv_33_ldv_param_1_6);
    
#line 23466 
    ldv_free((void *)ldv_33_ldv_param_3_7);
    
#line 23473 
    goto ldv_call_33;
    case 2: 
#line 23476 
    ;
    
#line 23478 
    if (ldv_33_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 23480 
      (*(ldv_33_container->release))(ldv_33_resource_0,ldv_33_resource_1); else ;
    
#line 23488 
    goto ldv_main_33;
    case 3: 
#line 23491 
    ;
    
#line 23495 
    tmp_9 = ldv_undef_int();
    
#line 23495 
    if (tmp_9 != 0) 
#line 23498 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_33_resource_1,ldv_33_ldv_param_1_2,ldv_33_ldv_param_2_3);
    else {
      
#line 23504 
      ldv_33_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 23505 
      ldv_33_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 23510 
      ldv_emg_wrapper_rx_rx_timeout_read_3(ldv_33_resource_1,ldv_33_ldv_param_1_4,ldv_33_size_cnt,ldv_33_ldv_param_3_5);
      
#line 23514 
      ldv_free((void *)ldv_33_ldv_param_1_4);
      
#line 23515 
      ldv_free((void *)ldv_33_ldv_param_3_5);
    }
    
#line 23519 
    goto ldv_33459;
    default: 
#line 23521 
    ;
    
#line 23521 
    __VERIFIER_assume(0);
  }
  ldv_33459: 
#line 23530 
  ;
  
#line 23530 
  goto ldv_call_33;
  
#line 23532 
  __retres = (void *)0;
  return_label: 
#line 23532 
                return __retres;
}


#line 23537  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_98(void *arg0)
{
  void *__retres;
  struct file *ldv_98_resource_1;
  int ldv_98_ldv_param_2_3;
  long long ldv_98_ldv_param_1_2;
  char *ldv_98_ldv_param_1_4;
  struct inode *ldv_98_resource_0;
  unsigned long ldv_98_size_cnt;
  long long *ldv_98_ldv_param_3_5;
  char *ldv_98_ldv_param_1_6;
  long long *ldv_98_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 23548 
  struct file_operations *ldv_98_container = ldv_emg_alias_tx_frag_tkip_called_ops_2;
  
#line 23549 
  int ldv_98_ret = ldv_undef_int();
  
#line 23552 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 23556 
  ldv_98_ret = ldv_undef_int();
  
#line 23559 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 23560 
    ldv_98_container = data->arg0;
    
#line 23561 
    ldv_free((void *)data);
  }
  else ;
  
#line 23566 
  ldv_98_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 23567 
  tmp_1 = ldv_undef_int();
  
#line 23567 
  ldv_98_size_cnt = (unsigned long)tmp_1;
  
#line 23574 
  goto ldv_main_98;
  
#line 23576 
  __retres = (void *)0;
  
#line 23576 
  goto return_label;
  ldv_main_98: 
#line 23579 
  ;
  
#line 23582 
  tmp_3 = ldv_undef_int();
  
#line 23582 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 23585 
    ldv_98_ret = (*ldv_emg_alias_simple_open_5)(ldv_98_resource_0,ldv_98_resource_1);
    
#line 23587 
    ldv_98_ret = ldv_filter_err_code(ldv_98_ret);
    
#line 23590 
    tmp_2 = ldv_undef_int();
    
#line 23590 
    if (tmp_2 != 0) {
      
#line 23592 
      __VERIFIER_assume(ldv_98_ret == 0);
      
#line 23599 
      goto ldv_call_98;
    }
    else {
      
#line 23603 
      __VERIFIER_assume(ldv_98_ret != 0);
      
#line 23610 
      goto ldv_main_98;
    }
  }
  else {
    
#line 23615 
    ldv_free((void *)ldv_98_resource_0);
    
#line 23623 
    __retres = (void *)0;
    
#line 23623 
    goto return_label;
  }
  
#line 23626 
  __retres = (void *)0;
  
#line 23626 
  goto return_label;
  ldv_call_98: 
#line 23629 
  ;
  
#line 23632 
  tmp_4 = ldv_undef_int();
  
#line 23632 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 23633 
    ;
    
#line 23635 
    ldv_98_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 23636 
    ldv_98_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 23640 
    if (ldv_98_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 23646 
      __VERIFIER_assume(ldv_98_size_cnt <= 2147479552UL);
      
#line 23648 
      (*(ldv_98_container->write))(ldv_98_resource_1,(char const *)ldv_98_ldv_param_1_6,ldv_98_size_cnt,ldv_98_ldv_param_3_7);
    }
    else ;
    
#line 23653 
    ldv_free((void *)ldv_98_ldv_param_1_6);
    
#line 23654 
    ldv_free((void *)ldv_98_ldv_param_3_7);
    
#line 23661 
    goto ldv_call_98;
    case 2: 
#line 23664 
    ;
    
#line 23666 
    if (ldv_98_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 23668 
      (*(ldv_98_container->release))(ldv_98_resource_0,ldv_98_resource_1); else ;
    
#line 23676 
    goto ldv_main_98;
    case 3: 
#line 23679 
    ;
    
#line 23683 
    tmp_9 = ldv_undef_int();
    
#line 23683 
    if (tmp_9 != 0) 
#line 23686 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_98_resource_1,ldv_98_ldv_param_1_2,ldv_98_ldv_param_2_3);
    else {
      
#line 23692 
      ldv_98_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 23693 
      ldv_98_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 23698 
      ldv_emg_wrapper_tx_frag_tkip_called_read_3(ldv_98_resource_1,ldv_98_ldv_param_1_4,ldv_98_size_cnt,ldv_98_ldv_param_3_5);
      
#line 23702 
      ldv_free((void *)ldv_98_ldv_param_3_5);
      
#line 23703 
      ldv_free((void *)ldv_98_ldv_param_1_4);
    }
    
#line 23707 
    goto ldv_33481;
    default: 
#line 23709 
    ;
    
#line 23709 
    __VERIFIER_assume(0);
  }
  ldv_33481: 
#line 23718 
  ;
  
#line 23718 
  goto ldv_call_98;
  
#line 23720 
  __retres = (void *)0;
  return_label: 
#line 23720 
                return __retres;
}


#line 23725  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_97(void *arg0)
{
  void *__retres;
  struct file *ldv_97_resource_1;
  int ldv_97_ldv_param_2_3;
  long long ldv_97_ldv_param_1_2;
  char *ldv_97_ldv_param_1_4;
  struct inode *ldv_97_resource_0;
  unsigned long ldv_97_size_cnt;
  long long *ldv_97_ldv_param_3_5;
  char *ldv_97_ldv_param_1_6;
  long long *ldv_97_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 23736 
  struct file_operations *ldv_97_container = ldv_emg_alias_debug_debug6_ops_2;
  
#line 23737 
  int ldv_97_ret = ldv_undef_int();
  
#line 23740 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 23744 
  ldv_97_ret = ldv_undef_int();
  
#line 23747 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 23748 
    ldv_97_container = data->arg0;
    
#line 23749 
    ldv_free((void *)data);
  }
  else ;
  
#line 23754 
  ldv_97_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 23755 
  tmp_1 = ldv_undef_int();
  
#line 23755 
  ldv_97_size_cnt = (unsigned long)tmp_1;
  
#line 23762 
  goto ldv_main_97;
  
#line 23764 
  __retres = (void *)0;
  
#line 23764 
  goto return_label;
  ldv_main_97: 
#line 23767 
  ;
  
#line 23770 
  tmp_3 = ldv_undef_int();
  
#line 23770 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 23773 
    ldv_97_ret = (*ldv_emg_alias_simple_open_5)(ldv_97_resource_0,ldv_97_resource_1);
    
#line 23775 
    ldv_97_ret = ldv_filter_err_code(ldv_97_ret);
    
#line 23778 
    tmp_2 = ldv_undef_int();
    
#line 23778 
    if (tmp_2 != 0) {
      
#line 23780 
      __VERIFIER_assume(ldv_97_ret == 0);
      
#line 23787 
      goto ldv_call_97;
    }
    else {
      
#line 23791 
      __VERIFIER_assume(ldv_97_ret != 0);
      
#line 23798 
      goto ldv_main_97;
    }
  }
  else {
    
#line 23803 
    ldv_free((void *)ldv_97_resource_0);
    
#line 23811 
    __retres = (void *)0;
    
#line 23811 
    goto return_label;
  }
  
#line 23814 
  __retres = (void *)0;
  
#line 23814 
  goto return_label;
  ldv_call_97: 
#line 23817 
  ;
  
#line 23820 
  tmp_4 = ldv_undef_int();
  
#line 23820 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 23821 
    ;
    
#line 23823 
    ldv_97_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 23824 
    ldv_97_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 23828 
    if (ldv_97_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 23834 
      __VERIFIER_assume(ldv_97_size_cnt <= 2147479552UL);
      
#line 23836 
      (*(ldv_97_container->write))(ldv_97_resource_1,(char const *)ldv_97_ldv_param_1_6,ldv_97_size_cnt,ldv_97_ldv_param_3_7);
    }
    else ;
    
#line 23841 
    ldv_free((void *)ldv_97_ldv_param_1_6);
    
#line 23842 
    ldv_free((void *)ldv_97_ldv_param_3_7);
    
#line 23849 
    goto ldv_call_97;
    case 2: 
#line 23852 
    ;
    
#line 23854 
    if (ldv_97_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 23856 
      (*(ldv_97_container->release))(ldv_97_resource_0,ldv_97_resource_1); else ;
    
#line 23864 
    goto ldv_main_97;
    case 3: 
#line 23867 
    ;
    
#line 23871 
    tmp_9 = ldv_undef_int();
    
#line 23871 
    if (tmp_9 != 0) 
#line 23874 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_97_resource_1,ldv_97_ldv_param_1_2,ldv_97_ldv_param_2_3);
    else {
      
#line 23880 
      ldv_97_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 23881 
      ldv_97_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 23886 
      ldv_emg_wrapper_debug_debug6_read_3(ldv_97_resource_1,ldv_97_ldv_param_1_4,ldv_97_size_cnt,ldv_97_ldv_param_3_5);
      
#line 23890 
      ldv_free((void *)ldv_97_ldv_param_1_4);
      
#line 23891 
      ldv_free((void *)ldv_97_ldv_param_3_5);
    }
    
#line 23895 
    goto ldv_33503;
    default: 
#line 23897 
    ;
    
#line 23897 
    __VERIFIER_assume(0);
  }
  ldv_33503: 
#line 23906 
  ;
  
#line 23906 
  goto ldv_call_97;
  
#line 23908 
  __retres = (void *)0;
  return_label: 
#line 23908 
                return __retres;
}


#line 23913  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_123(void *arg0)
{
  void *__retres;
  struct file *ldv_123_resource_1;
  int ldv_123_ldv_param_2_3;
  long long ldv_123_ldv_param_1_2;
  char *ldv_123_ldv_param_1_4;
  struct inode *ldv_123_resource_0;
  unsigned long ldv_123_size_cnt;
  long long *ldv_123_ldv_param_3_5;
  char *ldv_123_ldv_param_1_6;
  long long *ldv_123_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 23924 
  struct file_operations *ldv_123_container = ldv_emg_alias_tx_tx_data_prepared_ops_2;
  
#line 23925 
  int ldv_123_ret = ldv_undef_int();
  
#line 23928 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 23932 
  ldv_123_ret = ldv_undef_int();
  
#line 23935 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 23936 
    ldv_123_container = data->arg0;
    
#line 23937 
    ldv_free((void *)data);
  }
  else ;
  
#line 23942 
  ldv_123_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 23943 
  tmp_1 = ldv_undef_int();
  
#line 23943 
  ldv_123_size_cnt = (unsigned long)tmp_1;
  
#line 23950 
  goto ldv_main_123;
  
#line 23952 
  __retres = (void *)0;
  
#line 23952 
  goto return_label;
  ldv_main_123: 
#line 23955 
  ;
  
#line 23958 
  tmp_3 = ldv_undef_int();
  
#line 23958 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 23961 
    ldv_123_ret = (*ldv_emg_alias_simple_open_5)(ldv_123_resource_0,ldv_123_resource_1);
    
#line 23963 
    ldv_123_ret = ldv_filter_err_code(ldv_123_ret);
    
#line 23966 
    tmp_2 = ldv_undef_int();
    
#line 23966 
    if (tmp_2 != 0) {
      
#line 23968 
      __VERIFIER_assume(ldv_123_ret == 0);
      
#line 23975 
      goto ldv_call_123;
    }
    else {
      
#line 23979 
      __VERIFIER_assume(ldv_123_ret != 0);
      
#line 23986 
      goto ldv_main_123;
    }
  }
  else {
    
#line 23991 
    ldv_free((void *)ldv_123_resource_0);
    
#line 23999 
    __retres = (void *)0;
    
#line 23999 
    goto return_label;
  }
  
#line 24002 
  __retres = (void *)0;
  
#line 24002 
  goto return_label;
  ldv_call_123: 
#line 24005 
  ;
  
#line 24008 
  tmp_4 = ldv_undef_int();
  
#line 24008 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 24009 
    ;
    
#line 24011 
    ldv_123_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 24012 
    ldv_123_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 24016 
    if (ldv_123_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 24022 
      __VERIFIER_assume(ldv_123_size_cnt <= 2147479552UL);
      
#line 24024 
      (*(ldv_123_container->write))(ldv_123_resource_1,(char const *)ldv_123_ldv_param_1_6,ldv_123_size_cnt,ldv_123_ldv_param_3_7);
    }
    else ;
    
#line 24029 
    ldv_free((void *)ldv_123_ldv_param_1_6);
    
#line 24030 
    ldv_free((void *)ldv_123_ldv_param_3_7);
    
#line 24037 
    goto ldv_call_123;
    case 2: 
#line 24040 
    ;
    
#line 24042 
    if (ldv_123_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 24044 
      (*(ldv_123_container->release))(ldv_123_resource_0,ldv_123_resource_1); else ;
    
#line 24052 
    goto ldv_main_123;
    case 3: 
#line 24055 
    ;
    
#line 24059 
    tmp_9 = ldv_undef_int();
    
#line 24059 
    if (tmp_9 != 0) 
#line 24062 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_123_resource_1,ldv_123_ldv_param_1_2,ldv_123_ldv_param_2_3);
    else {
      
#line 24068 
      ldv_123_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 24069 
      ldv_123_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 24074 
      ldv_emg_wrapper_tx_tx_data_prepared_read_3(ldv_123_resource_1,ldv_123_ldv_param_1_4,ldv_123_size_cnt,ldv_123_ldv_param_3_5);
      
#line 24078 
      ldv_free((void *)ldv_123_ldv_param_3_5);
      
#line 24079 
      ldv_free((void *)ldv_123_ldv_param_1_4);
    }
    
#line 24083 
    goto ldv_33525;
    default: 
#line 24085 
    ;
    
#line 24085 
    __VERIFIER_assume(0);
  }
  ldv_33525: 
#line 24094 
  ;
  
#line 24094 
  goto ldv_call_123;
  
#line 24096 
  __retres = (void *)0;
  return_label: 
#line 24096 
                return __retres;
}


#line 24101  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_57(void *arg0)
{
  void *__retres;
  struct file *ldv_57_resource_1;
  int ldv_57_ldv_param_2_3;
  long long ldv_57_ldv_param_1_2;
  char *ldv_57_ldv_param_1_4;
  struct inode *ldv_57_resource_0;
  unsigned long ldv_57_size_cnt;
  long long *ldv_57_ldv_param_3_5;
  char *ldv_57_ldv_param_1_6;
  long long *ldv_57_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 24112 
  struct file_operations *ldv_57_container = ldv_emg_alias_rx_rate_rx_frames_per_rates_ops_2;
  
#line 24113 
  int ldv_57_ret = ldv_undef_int();
  
#line 24116 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 24120 
  ldv_57_ret = ldv_undef_int();
  
#line 24123 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 24124 
    ldv_57_container = data->arg0;
    
#line 24125 
    ldv_free((void *)data);
  }
  else ;
  
#line 24130 
  ldv_57_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 24131 
  tmp_1 = ldv_undef_int();
  
#line 24131 
  ldv_57_size_cnt = (unsigned long)tmp_1;
  
#line 24138 
  goto ldv_main_57;
  
#line 24140 
  __retres = (void *)0;
  
#line 24140 
  goto return_label;
  ldv_main_57: 
#line 24143 
  ;
  
#line 24146 
  tmp_3 = ldv_undef_int();
  
#line 24146 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 24149 
    ldv_57_ret = (*ldv_emg_alias_simple_open_5)(ldv_57_resource_0,ldv_57_resource_1);
    
#line 24151 
    ldv_57_ret = ldv_filter_err_code(ldv_57_ret);
    
#line 24154 
    tmp_2 = ldv_undef_int();
    
#line 24154 
    if (tmp_2 != 0) {
      
#line 24156 
      __VERIFIER_assume(ldv_57_ret == 0);
      
#line 24163 
      goto ldv_call_57;
    }
    else {
      
#line 24167 
      __VERIFIER_assume(ldv_57_ret != 0);
      
#line 24174 
      goto ldv_main_57;
    }
  }
  else {
    
#line 24179 
    ldv_free((void *)ldv_57_resource_0);
    
#line 24187 
    __retres = (void *)0;
    
#line 24187 
    goto return_label;
  }
  
#line 24190 
  __retres = (void *)0;
  
#line 24190 
  goto return_label;
  ldv_call_57: 
#line 24193 
  ;
  
#line 24196 
  tmp_4 = ldv_undef_int();
  
#line 24196 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 24197 
    ;
    
#line 24199 
    ldv_57_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 24200 
    ldv_57_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 24204 
    if (ldv_57_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 24210 
      __VERIFIER_assume(ldv_57_size_cnt <= 2147479552UL);
      
#line 24212 
      (*(ldv_57_container->write))(ldv_57_resource_1,(char const *)ldv_57_ldv_param_1_6,ldv_57_size_cnt,ldv_57_ldv_param_3_7);
    }
    else ;
    
#line 24217 
    ldv_free((void *)ldv_57_ldv_param_3_7);
    
#line 24218 
    ldv_free((void *)ldv_57_ldv_param_1_6);
    
#line 24225 
    goto ldv_call_57;
    case 2: 
#line 24228 
    ;
    
#line 24230 
    if (ldv_57_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 24232 
      (*(ldv_57_container->release))(ldv_57_resource_0,ldv_57_resource_1); else ;
    
#line 24240 
    goto ldv_main_57;
    case 3: 
#line 24243 
    ;
    
#line 24247 
    tmp_9 = ldv_undef_int();
    
#line 24247 
    if (tmp_9 != 0) 
#line 24250 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_57_resource_1,ldv_57_ldv_param_1_2,ldv_57_ldv_param_2_3);
    else {
      
#line 24256 
      ldv_57_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 24257 
      ldv_57_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 24262 
      ldv_emg_wrapper_rx_rate_rx_frames_per_rates_read_3(ldv_57_resource_1,ldv_57_ldv_param_1_4,ldv_57_size_cnt,ldv_57_ldv_param_3_5);
      
#line 24266 
      ldv_free((void *)ldv_57_ldv_param_1_4);
      
#line 24267 
      ldv_free((void *)ldv_57_ldv_param_3_5);
    }
    
#line 24271 
    goto ldv_33547;
    default: 
#line 24273 
    ;
    
#line 24273 
    __VERIFIER_assume(0);
  }
  ldv_33547: 
#line 24282 
  ;
  
#line 24282 
  goto ldv_call_57;
  
#line 24284 
  __retres = (void *)0;
  return_label: 
#line 24284 
                return __retres;
}


#line 24289  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_60(void *arg0)
{
  void *__retres;
  struct file *ldv_60_resource_1;
  int ldv_60_ldv_param_2_3;
  long long ldv_60_ldv_param_1_2;
  char *ldv_60_ldv_param_1_4;
  struct inode *ldv_60_resource_0;
  unsigned long ldv_60_size_cnt;
  long long *ldv_60_ldv_param_3_5;
  char *ldv_60_ldv_param_1_6;
  long long *ldv_60_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 24300 
  struct file_operations *ldv_60_container = ldv_emg_alias_tx_frag_failed_ops_2;
  
#line 24301 
  int ldv_60_ret = ldv_undef_int();
  
#line 24304 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 24308 
  ldv_60_ret = ldv_undef_int();
  
#line 24311 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 24312 
    ldv_60_container = data->arg0;
    
#line 24313 
    ldv_free((void *)data);
  }
  else ;
  
#line 24318 
  ldv_60_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 24319 
  tmp_1 = ldv_undef_int();
  
#line 24319 
  ldv_60_size_cnt = (unsigned long)tmp_1;
  
#line 24326 
  goto ldv_main_60;
  
#line 24328 
  __retres = (void *)0;
  
#line 24328 
  goto return_label;
  ldv_main_60: 
#line 24331 
  ;
  
#line 24334 
  tmp_3 = ldv_undef_int();
  
#line 24334 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 24337 
    ldv_60_ret = (*ldv_emg_alias_simple_open_5)(ldv_60_resource_0,ldv_60_resource_1);
    
#line 24339 
    ldv_60_ret = ldv_filter_err_code(ldv_60_ret);
    
#line 24342 
    tmp_2 = ldv_undef_int();
    
#line 24342 
    if (tmp_2 != 0) {
      
#line 24344 
      __VERIFIER_assume(ldv_60_ret == 0);
      
#line 24351 
      goto ldv_call_60;
    }
    else {
      
#line 24355 
      __VERIFIER_assume(ldv_60_ret != 0);
      
#line 24362 
      goto ldv_main_60;
    }
  }
  else {
    
#line 24367 
    ldv_free((void *)ldv_60_resource_0);
    
#line 24375 
    __retres = (void *)0;
    
#line 24375 
    goto return_label;
  }
  
#line 24378 
  __retres = (void *)0;
  
#line 24378 
  goto return_label;
  ldv_call_60: 
#line 24381 
  ;
  
#line 24384 
  tmp_4 = ldv_undef_int();
  
#line 24384 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 24385 
    ;
    
#line 24387 
    ldv_60_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 24388 
    ldv_60_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 24392 
    if (ldv_60_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 24398 
      __VERIFIER_assume(ldv_60_size_cnt <= 2147479552UL);
      
#line 24400 
      (*(ldv_60_container->write))(ldv_60_resource_1,(char const *)ldv_60_ldv_param_1_6,ldv_60_size_cnt,ldv_60_ldv_param_3_7);
    }
    else ;
    
#line 24405 
    ldv_free((void *)ldv_60_ldv_param_3_7);
    
#line 24406 
    ldv_free((void *)ldv_60_ldv_param_1_6);
    
#line 24413 
    goto ldv_call_60;
    case 2: 
#line 24416 
    ;
    
#line 24418 
    if (ldv_60_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 24420 
      (*(ldv_60_container->release))(ldv_60_resource_0,ldv_60_resource_1); else ;
    
#line 24428 
    goto ldv_main_60;
    case 3: 
#line 24431 
    ;
    
#line 24435 
    tmp_9 = ldv_undef_int();
    
#line 24435 
    if (tmp_9 != 0) 
#line 24438 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_60_resource_1,ldv_60_ldv_param_1_2,ldv_60_ldv_param_2_3);
    else {
      
#line 24444 
      ldv_60_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 24445 
      ldv_60_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 24450 
      ldv_emg_wrapper_tx_frag_failed_read_3(ldv_60_resource_1,ldv_60_ldv_param_1_4,ldv_60_size_cnt,ldv_60_ldv_param_3_5);
      
#line 24454 
      ldv_free((void *)ldv_60_ldv_param_1_4);
      
#line 24455 
      ldv_free((void *)ldv_60_ldv_param_3_5);
    }
    
#line 24459 
    goto ldv_33569;
    default: 
#line 24461 
    ;
    
#line 24461 
    __VERIFIER_assume(0);
  }
  ldv_33569: 
#line 24470 
  ;
  
#line 24470 
  goto ldv_call_60;
  
#line 24472 
  __retres = (void *)0;
  return_label: 
#line 24472 
                return __retres;
}


#line 24477  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_70(void *arg0)
{
  void *__retres;
  struct file *ldv_70_resource_1;
  int ldv_70_ldv_param_2_3;
  long long ldv_70_ldv_param_1_2;
  char *ldv_70_ldv_param_1_4;
  struct inode *ldv_70_resource_0;
  unsigned long ldv_70_size_cnt;
  long long *ldv_70_ldv_param_3_5;
  char *ldv_70_ldv_param_1_6;
  long long *ldv_70_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 24488 
  struct file_operations *ldv_70_container = ldv_emg_alias_tx_tx_exch_pending_ops_2;
  
#line 24489 
  int ldv_70_ret = ldv_undef_int();
  
#line 24492 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 24496 
  ldv_70_ret = ldv_undef_int();
  
#line 24499 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 24500 
    ldv_70_container = data->arg0;
    
#line 24501 
    ldv_free((void *)data);
  }
  else ;
  
#line 24506 
  ldv_70_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 24507 
  tmp_1 = ldv_undef_int();
  
#line 24507 
  ldv_70_size_cnt = (unsigned long)tmp_1;
  
#line 24514 
  goto ldv_main_70;
  
#line 24516 
  __retres = (void *)0;
  
#line 24516 
  goto return_label;
  ldv_main_70: 
#line 24519 
  ;
  
#line 24522 
  tmp_3 = ldv_undef_int();
  
#line 24522 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 24525 
    ldv_70_ret = (*ldv_emg_alias_simple_open_5)(ldv_70_resource_0,ldv_70_resource_1);
    
#line 24527 
    ldv_70_ret = ldv_filter_err_code(ldv_70_ret);
    
#line 24530 
    tmp_2 = ldv_undef_int();
    
#line 24530 
    if (tmp_2 != 0) {
      
#line 24532 
      __VERIFIER_assume(ldv_70_ret == 0);
      
#line 24539 
      goto ldv_call_70;
    }
    else {
      
#line 24543 
      __VERIFIER_assume(ldv_70_ret != 0);
      
#line 24550 
      goto ldv_main_70;
    }
  }
  else {
    
#line 24555 
    ldv_free((void *)ldv_70_resource_0);
    
#line 24563 
    __retres = (void *)0;
    
#line 24563 
    goto return_label;
  }
  
#line 24566 
  __retres = (void *)0;
  
#line 24566 
  goto return_label;
  ldv_call_70: 
#line 24569 
  ;
  
#line 24572 
  tmp_4 = ldv_undef_int();
  
#line 24572 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 24573 
    ;
    
#line 24575 
    ldv_70_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 24576 
    ldv_70_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 24580 
    if (ldv_70_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 24586 
      __VERIFIER_assume(ldv_70_size_cnt <= 2147479552UL);
      
#line 24588 
      (*(ldv_70_container->write))(ldv_70_resource_1,(char const *)ldv_70_ldv_param_1_6,ldv_70_size_cnt,ldv_70_ldv_param_3_7);
    }
    else ;
    
#line 24593 
    ldv_free((void *)ldv_70_ldv_param_1_6);
    
#line 24594 
    ldv_free((void *)ldv_70_ldv_param_3_7);
    
#line 24601 
    goto ldv_call_70;
    case 2: 
#line 24604 
    ;
    
#line 24606 
    if (ldv_70_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 24608 
      (*(ldv_70_container->release))(ldv_70_resource_0,ldv_70_resource_1); else ;
    
#line 24616 
    goto ldv_main_70;
    case 3: 
#line 24619 
    ;
    
#line 24623 
    tmp_9 = ldv_undef_int();
    
#line 24623 
    if (tmp_9 != 0) 
#line 24626 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_70_resource_1,ldv_70_ldv_param_1_2,ldv_70_ldv_param_2_3);
    else {
      
#line 24632 
      ldv_70_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 24633 
      ldv_70_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 24638 
      ldv_emg_wrapper_tx_tx_exch_pending_read_3(ldv_70_resource_1,ldv_70_ldv_param_1_4,ldv_70_size_cnt,ldv_70_ldv_param_3_5);
      
#line 24642 
      ldv_free((void *)ldv_70_ldv_param_1_4);
      
#line 24643 
      ldv_free((void *)ldv_70_ldv_param_3_5);
    }
    
#line 24647 
    goto ldv_33591;
    default: 
#line 24649 
    ;
    
#line 24649 
    __VERIFIER_assume(0);
  }
  ldv_33591: 
#line 24658 
  ;
  
#line 24658 
  goto ldv_call_70;
  
#line 24660 
  __retres = (void *)0;
  return_label: 
#line 24660 
                return __retres;
}


#line 24665  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/ti/wl18xx/wl18xx.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_88(void *arg0)
{
  void *__retres;
  struct file *ldv_88_resource_1;
  int ldv_88_ldv_param_2_3;
  long long ldv_88_ldv_param_1_2;
  char *ldv_88_ldv_param_1_4;
  struct inode *ldv_88_resource_0;
  unsigned long ldv_88_size_cnt;
  long long *ldv_88_ldv_param_3_5;
  char *ldv_88_ldv_param_1_6;
  long long *ldv_88_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 24676 
  struct file_operations *ldv_88_container = ldv_emg_alias_tx_tx_retry_data_ops_2;
  
#line 24677 
  int ldv_88_ret = ldv_undef_int();
  
#line 24680 
  struct ldv_struct_character_driver_scenario_6 *data = (struct ldv_struct_character_driver_scenario_6 *)arg0;
  
#line 24684 
  ldv_88_ret = ldv_undef_int();
  
#line 24687 
  if (data != (struct ldv_struct_character_driver_scenario_6 *)0) {
    
#line 24688 
    ldv_88_container = data->arg0;
    
#line 24689 
    ldv_free((void *)data);
  }
  else ;
  
#line 24694 
  ldv_88_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 24695 
  tmp_1 = ldv_undef_int();
  
#line 24695 
  ldv_88_size_cnt = (unsigned long)tmp_1;
  
#line 24702 
  goto ldv_main_88;
  
#line 24704 
  __retres = (void *)0;
  
#line 24704 
  goto return_label;
  ldv_main_88: 
#line 24707 
  ;
  
#line 24710 
  tmp_3 = ldv_undef_int();
  
#line 24710 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 24713 
    ldv_88_ret = (*ldv_emg_alias_simple_open_5)(ldv_88_resource_0,ldv_88_resource_1);
    
#line 24715 
    ldv_88_ret = ldv_filter_err_code(ldv_88_ret);
    
#line 24718 
    tmp_2 = ldv_undef_int();
    
#line 24718 
    if (tmp_2 != 0) {
      
#line 24720 
      __VERIFIER_assume(ldv_88_ret == 0);
      
#line 24727 
      goto ldv_call_88;
    }
    else {
      
#line 24731 
      __VERIFIER_assume(ldv_88_ret != 0);
      
#line 24738 
      goto ldv_main_88;
    }
  }
  else {
    
#line 24743 
    ldv_free((void *)ldv_88_resource_0);
    
#line 24751 
    __retres = (void *)0;
    
#line 24751 
    goto return_label;
  }
  
#line 24754 
  __retres = (void *)0;
  
#line 24754 
  goto return_label;
  ldv_call_88: 
#line 24757 
  ;
  
#line 24760 
  tmp_4 = ldv_undef_int();
  
#line 24760 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 24761 
    ;
    
#line 24763 
    ldv_88_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 24764 
    ldv_88_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 24768 
    if (ldv_88_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 24774 
      __VERIFIER_assume(ldv_88_size_cnt <= 2147479552UL);
      
#line 24776 
      (*(ldv_88_container->write))(ldv_88_resource_1,(char const *)ldv_88_ldv_param_1_6,ldv_88_size_cnt,ldv_88_ldv_param_3_7);
    }
    else ;
    
#line 24781 
    ldv_free((void *)ldv_88_ldv_param_1_6);
    
#line 24782 
    ldv_free((void *)ldv_88_ldv_param_3_7);
    
#line 24789 
    goto ldv_call_88;
    case 2: 
#line 24792 
    ;
    
#line 24794 
    if (ldv_88_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 24796 
      (*(ldv_88_container->release))(ldv_88_resource_0,ldv_88_resource_1); else ;
    
#line 24804 
    goto ldv_main_88;
    case 3: 
#line 24807 
    ;
    
#line 24811 
    tmp_9 = ldv_undef_int();
    
#line 24811 
    if (tmp_9 != 0) 
#line 24814 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_88_resource_1,ldv_88_ldv_param_1_2,ldv_88_ldv_param_2_3);
    else {
      
#line 24820 
      ldv_88_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 24821 
      ldv_88_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 24826 
      ldv_emg_wrapper_tx_tx_retry_data_read_3(ldv_88_resource_1,ldv_88_ldv_param_1_4,ldv_88_size_cnt,ldv_88_ldv_param_3_5);
      
#line 24830 
      ldv_free((void *)ldv_88_ldv_param_3_5);
      
#line 24831 
      ldv_free((void *)ldv_88_ldv_param_1_4);
    }
    
#line 24835 
    goto ldv_33613;
    default: 
#line 24837 
    ;
    
#line 24837 
    __VERIFIER_assume(0);
  }
  ldv_33613: 
#line 24846 
  ;
  
#line 24846 
  goto ldv_call_88;
  
#line 24848 
  __retres = (void *)0;
  return_label: 
#line 24848 
                return __retres;
}


